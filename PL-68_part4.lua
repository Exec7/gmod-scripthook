--Stealed clientside server code by exechack.cc
--Hostname: [PL] [PixelMod] PelugeRP SWRP | .gg/pixelmod - Part 4/10 - 06/04/2025


--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/arccw_kraken_republic_sounds.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_controls.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/sh_k_explosives_hooks.lua:
gsr_flashtime = 5
gsr_flashfade = 2
gsr_flashdistance = 1280
gsr_flashdistancefade = 1280 - 512

local tab = {
	["$pp_colour_addr"] = 0,
	["$pp_colour_addg"] = 0,
	["$pp_colour_addb"] = 0,
	["$pp_colour_brightness"] = 0.0,
	["$pp_colour_contrast"] = 1.0,
	["$pp_colour_colour"] = 1.0,
	["$pp_colour_mulr"] = 0,
	["$pp_colour_mulg"] = 0,
	["$pp_colour_mulb"] = 0
}

function ARC9_GSR_FlashIntensity(ply)
	local flashtime = ply:GetNWFloat("ARC9_GSR_LastFlash", -999)
	local flashdistance = ply:GetNWFloat("ARC9_GSR_FlashDistance", 0)
	local flashfac = ply:GetNWFloat("ARC9_GSR_FlashFactor", 1)
	local distancefac = 1 - math.Clamp((flashdistance - gsr_flashdistance + gsr_flashdistancefade) / gsr_flashdistancefade, 0, 1)
	local intensity = 1 - math.Clamp(((CurTime() - flashtime) / distancefac - gsr_flashtime + gsr_flashfade) / gsr_flashfade, 0, 1)
	intensity = intensity * distancefac
	intensity = intensity * math.Clamp(flashfac + 0.1, 0.35, 1)

	return intensity
end

if CLIENT then
	hook.Add("RenderScreenspaceEffects", "ARC9_GSR_FLASHBANG", function()
		local ply = LocalPlayer()
		if not IsValid(ply) then return end
		local intensity = ARC9_GSR_FlashIntensity(ply)

		if intensity > 0.01 then
			tab["$pp_colour_brightness"] = math.pow(intensity, 3)
			tab["$pp_colour_colour"] = 1 - intensity * 0.33
			DrawColorModify(tab) --Draws Color Modify effect
			DrawMotionBlur(0.2, intensity, 0.03)
		end
	end)
end

function ARC9GSRSmokeBlind()
	local ply = LocalPlayer()

	local IsInSmoke = false

	local SmokeAmount = 0

	for k,v in pairs(ents.FindByClass("nade_k_thrown_smoke")) do
		local Distance = ply:GetPos():Distance(v:GetPos())
		if Distance <= 144 and v:GetNWBool("IsDetonated",false) then
			IsInSmoke = true
			SmokeAmount = SmokeAmount + (144 - Distance)*2
		end
	end

	if IsInSmoke then
		local ModAmount = math.Clamp(SmokeAmount / 100,0,1)
		local smokeMat = Material( "csgo/particle/particle_smokegrenade_view" )

		surface.SetDrawColor( Color(99, 99, 99,ModAmount*255) )
		surface.SetMaterial( smokeMat )
		--surface.DrawTexturedRect( 0, 0, ScrW(), ScrH() )
		--render.SetMaterial( IMaterial mat )
		--render.DrawScreenQuad()
		surface.DrawRect( 0, 0, ScrW(), ScrH() )		
	end
end
hook.Add("RenderScreenspaceEffects","ARC9GSRSmokeBlind",ARC9GSRSmokeBlind)
--PATH lua/arccw/shared/sh_loadatts.lua:
ArcCW = ArcCW or {}
ArcCW.AttachmentTable = {}
ArcCW.AttachmentIDTable = {}
ArcCW.AttachmentSlotTable = {}
ArcCW.AttachmentBlacklistTable = {}
ArcCW.NumAttachments = 1
ArcCW.GenerateAttEntities = true

ArcCW.AttachmentCachedLists = {}

local shortname = ""
local genAttCvar = ArcCW.ConVars["reloadatts_registerentities"]

function ArcCW.LoadAttachmentType(att, name)
    if name == "" then return end
    name = name or shortname

    if !att.Ignore or ArcCW.ConVars["reloadatts_showignored"]:GetBool() then
        ArcCW.AttachmentTable[name] = att
        ArcCW.AttachmentIDTable[ArcCW.NumAttachments] = name

        att.Blacklisted = false
        att.ShortName = name

        if !ArcCW.AttachmentSlotTable[att.Slot] then
            ArcCW.AttachmentSlotTable[att.Slot] = {}
        end
        table.insert(ArcCW.AttachmentSlotTable[att.Slot], ArcCW.NumAttachments)

        att.ID = ArcCW.NumAttachments

        if genAttCvar:GetBool() and !att.DoNotRegister and !att.InvAtt and !att.Free then
            local attent = {}
            attent.Base = "arccw_att_base"
            if CLIENT and att.Icon then
                attent.IconOverride = string.Replace( att.Icon:GetTexture( "$basetexture" ):GetName() .. ".png", "0001010", "" )
            end
            attent.PrintName = att.PrintName or name
            attent.Spawnable = att.Spawnable or true
            attent.AdminOnly = att.AdminOnly or false
            attent.Category = att.EntityCategory or "ArcCW - Attachments"
            attent.Model = att.DroppedModel or att.Model or "models/Items/BoxSRounds.mdl"
            attent.GiveAttachments = {
                [att.ShortName] = 1
            }

            if att.EntityCategory and !list.HasEntry("ContentCategoryIcons", att.EntityCategory) then
                list.Set("ContentCategoryIcons", att.EntityCategory, "arccw/icon_16.png")
            end

            scripted_ents.Register( attent, "acwatt_" .. name )
        end

        ArcCW.NumAttachments = ArcCW.NumAttachments + 1

        hook.Run("ArcCW_OnAttLoad", att)
    end
end

local function VerifyBlacklist()
    for attName, v in pairs(ArcCW.AttachmentBlacklistTable) do
        if !ArcCW.AttachmentTable[attName] then
            ArcCW.AttachmentBlacklistTable[attName] = nil
        end
    end
end

local function ArcCW_SendBlacklist(ply)
    if SERVER then
        -- Only load if table is empty, bruh
        if table.IsEmpty(ArcCW.AttachmentBlacklistTable) then
            ArcCW.AttachmentBlacklistTable = util.JSONToTable(file.Read("arccw_blacklist.txt") or "") or {}
            local curcount = table.Count(ArcCW.AttachmentBlacklistTable)
            VerifyBlacklist()
            print("Loaded " .. curcount .. " active (" .. curcount .. " total) blacklisted ArcCW attachments.")
        end
        if ArcCW.AttachmentBlacklistTable and player.GetCount() > 0 then
            timer.Simple(0, function()
                net.Start("arccw_blacklist")
                    net.WriteUInt(table.Count(ArcCW.AttachmentBlacklistTable), ArcCW.GetBitNecessity())
                    for attName, bStatus in pairs(ArcCW.AttachmentBlacklistTable) do
                        net.WriteUInt(ArcCW.AttachmentTable[attName].ID, ArcCW.GetBitNecessity())
                    end
                if ply then net.Send(ply) else net.Broadcast() end
            end)
        end
    elseif CLIENT and ArcCW.AttachmentBlacklistTable == nil then
        -- Actively request the table, this happens on player load into server once
        net.Start("arccw_blacklist")
            net.WriteBool(true)
        net.SendToServer()
    end
end


local attachments_path = "arccw/shared/attachments/"
local bulk_path = "arccw/shared/attachments_bulk/"

local function ArcCW_LoadAtt(att_file)
    att = {} -- Do not bleed over attributes from previous attachments
    --shortname = string.sub(att_file, 1, -5)
    local s = string.Explode("/", att_file)
    shortname = string.sub(s[#s], 1, -5)

    include(att_file)
    AddCSLuaFile(att_file)

    ArcCW.LoadAttachmentType(att)

end

local function ArcCW_LoadFolder(folder)
    folder = folder and (attachments_path .. folder .. "/") or attachments_path
    for k, v in pairs(file.Find(folder .. "*", "LUA")) do
        local yaya, yoyo = pcall(function() ArcCW_LoadAtt(folder .. v) end)
        if !yaya then
            print( "!!!! Attachment " .. v .. " has errors!", yoyo )
            -- Create a stub attachment to prevent customization UI freaking out
            ArcCW.AttachmentTable[shortname] = {
                PrintName = shortname or "ERROR",
                Description = "This attachment failed to load!\nIts file path is: " .. v
            }
        end
    end
end

local function ArcCW_LoadAtts()
    ArcCW.AttachmentTable = {}
    ArcCW.AttachmentIDTable = {}
    ArcCW.AttachmentSlotTable = {}
    ArcCW.NumAttachments = 1
    ArcCW.AttachmentBits = nil
    ArcCW.AttachmentCachedLists = {}

    ArcCW_LoadFolder()
    local _, folders = file.Find(attachments_path .. "/*", "LUA")
    if folders then
        for _, folder in pairs(folders) do
            ArcCW_LoadFolder(folder)
        end
    end

    local bulkfiles = file.Find(bulk_path .. "/*.lua", "LUA")
    for _, filename in pairs(bulkfiles) do
        if filename == "default.lua" then continue end
        local try = pcall(function()
            include(bulk_path .. filename)
            AddCSLuaFile(bulk_path .. filename)
        end)
        if !try then
            print("!!!! Bulk attachment file " .. filename .. " has errors!")
        end
    end

    print("Loaded " .. tostring(ArcCW.NumAttachments) .. " ArcCW attachments.")

    if !game.SinglePlayer() then
        ArcCW_SendBlacklist()
    else
        -- Simply read the file and do no networking, since both client/server has access to it
        ArcCW.AttachmentBlacklistTable = util.JSONToTable(file.Read("arccw_blacklist.txt") or "") or {}
        for i, v in pairs(ArcCW.AttachmentTable) do
            v.Blacklisted = ArcCW.AttachmentBlacklistTable[i]
        end
        print("Loaded blacklist with " .. table.Count(ArcCW.AttachmentBlacklistTable) .. " attachments.")
    end

    hook.Run("ArcCW_PostLoadAtts")
end

function ArcCW.GetBitNecessity()
    if !ArcCW.AttachmentBits then
        ArcCW.AttachmentBits = math.min(math.ceil(math.log(ArcCW.NumAttachments + 1, 2)), 32)
    end
    return ArcCW.AttachmentBits
end

if CLIENT then
    concommand.Add("arccw_reloadatts", function()
        if !LocalPlayer():IsSuperAdmin() then return end

        net.Start("arccw_reloadatts")
        net.SendToServer()
    end)

    net.Receive("arccw_reloadatts", function(len, ply)
        ArcCW_LoadAtts()
    end)

    spawnmenu.AddCreationTab( "#spawnmenu.category.entities", function()

        local ctrl = vgui.Create( "SpawnmenuContentPanel" )
        ctrl:EnableSearch( "entities", "PopulateEntities" )
        ctrl:CallPopulateHook( "PopulateEntities" )

        return ctrl

    end, "icon16/bricks.png", 20 )

    -- Client receives blacklist table from server and updates itself
    net.Receive("arccw_blacklist", function()
        ArcCW.AttachmentBlacklistTable = {}
        local amt = net.ReadUInt(ArcCW.GetBitNecessity())
        for i = 1, amt do
            local id = net.ReadUInt(ArcCW.GetBitNecessity())
            ArcCW.AttachmentBlacklistTable[ArcCW.AttachmentIDTable[id]] = true
        end
        for i, v in pairs(ArcCW.AttachmentTable) do
            v.Blacklisted = ArcCW.AttachmentBlacklistTable[i]
        end
        print("Received blacklist with " .. table.Count(ArcCW.AttachmentBlacklistTable) .. " attachments.")
    end)

    -- Gets around Listen server spawn issues
    hook.Add( "InitPostEntity", "Ready", function()
        if !game.SinglePlayer() then
            net.Start("arccw_blacklist")
                net.WriteBool(true)
            net.SendToServer()
        end
    end )
elseif SERVER then
    net.Receive("arccw_reloadatts", function(len, ply)
        if !ply:IsSuperAdmin() then return end

        ArcCW_LoadAtts()

        net.Start("arccw_reloadatts")
        net.Broadcast()
    end)

    local antiSpam = {}
    net.Receive("arccw_blacklist", function(len, ply)

        -- If this message is a request to get blacklist, send it and return
        local isRequest = net.ReadBool()
        if isRequest then
            if antiSpam[ply] and antiSpam[ply] > CurTime() then return end
            -- Debounce client request so they can't attempt to spam netmessages
            antiSpam[ply] = CurTime() + 10

            ArcCW_SendBlacklist(ply)
            return
        elseif !isRequest and !ply:IsAdmin() then
            return
        end

        -- Server receives admin's changes to blacklist table
        local amt = net.ReadUInt(ArcCW.GetBitNecessity())
        ArcCW.AttachmentBlacklistTable = {}
        for i = 1, amt do
            local id = net.ReadUInt(ArcCW.GetBitNecessity())
            local attName = ArcCW.AttachmentIDTable[id]
            if attName and ArcCW.AttachmentTable[attName] then
                ArcCW.AttachmentBlacklistTable[attName] = true
            end
        end
        for i, k in pairs(ArcCW.AttachmentTable) do
            k.Blacklisted = ArcCW.AttachmentBlacklistTable[i] or false
        end
        print("Received blacklist with " .. table.Count(ArcCW.AttachmentBlacklistTable) .. " attachments.")
        file.Write("arccw_blacklist.txt", util.TableToJSON(ArcCW.AttachmentBlacklistTable))
        ArcCW_SendBlacklist()
    end)
end

hook.Add("PostCleanupMap", "ArcCW_ReloadAttsDebug", function()
    if ArcCW.ConVars["reloadatts_mapcleanup"]:GetBool() then ArcCW_LoadAtts() end
end)

ArcCW_LoadAtts()

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_top_stabilizer.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_mag_drum.lua:
att.PrintName = "15s Extended Magazine (DRUM)"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine for DC-15s"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Slot = "15s_mag"
att.ActivateElements = {"15s_mag_drum"}

att.AutoStats = true
att.HideIfBlocked = true
att.Override_ClipSize = 100

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1
att.Mult_SpeedMult = 0.90
att.Mult_ShootSpeedMult = 0.90
att.Mult_DrawTime = 1.35
att.Mult_HolsterTime = 1.25
att.Mult_HipDispersion = 1.9

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/242_barrel_sniper.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_smoke.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/ammo_low.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_piercing.lua:
att.PrintName = "Armorpiercing Module"
att.Icon = Material("interfaz/armas/sw_piercingshot.png")
att.Description = "Higher damage and armor piercing at the cost of higher recoil and lower fire-ratio."
att.Override_MuzzleEffect = "wpn_muzzleflash_dc17_purple"
att.Override_Tracer = "tracer_purple"
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.NotForNPCs = true
att.AutoStats = true
att.Slot = "ammo"

att.Mult_ShootPitch = 0.8
att.Reload = 1.1
att.Mult_Penetration = 1.2
att.Mult_DamageMin = 1.18
att.Mult_Recoil = 1.47
att.Mult_SightTime = 1.1
att.Mult_RPM = 0.57
att.Mult_Damage = 1.10
att.Mult_MuzzleVelocity = 1.36
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/bipod_specialforces.lua:
att.PrintName = "Deployed Bipod"
att.Icon = Material("entities/kraken/sops/atts/bipod.png", "mips smooth")
att.Description = "Deployed bipod for heavy weapons"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = "specialforces_bipod"
att.ActivateElements = {"specialforces_bipod"}

att.Bipod = true
att.LHIK = true

att.Mult_SightTime = 1.5
att.Mult_SpeedMult = 0.9

att.Mult_BipodRecoil = 0.45
att.Mult_BipodDispersion = 0.5
--PATH lua/arccw/shared/attachments/dc15a_range_finder.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_bacta.lua:
att.PrintName = "Grenade Launcher (Bacta)"
att.Icon = Material("interfaz/armas/sw_powercore.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Bacta)"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_heal", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_dioxis.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_smoke.lua:
att.PrintName = "Grenade Launcher (Smoke)"
att.Icon = Material("interfaz/armas/sw_smokegrenade.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Smoke)"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_smoke", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_at.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_overcharged.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_basic.lua:
att.PrintName = "Basic Training"

att.Icon = Material("interfaz/iconos/kraken/jedi comm assault specialist/3099160832_1788285497.png")
att.Description = [[Clone troopers, also known as Republic troopers, Republic troops, Republic soldiers, Regs, and nicknamed the "Boys in White," were highly trained soldiers in the Grand Army of the Republic. Representing the future of galactic warfare, clones were designed to be far superior to battle droids.]]
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true

att.Mult_MoveSpeed = 1.1
att.Mult_JumpDispersion = 0.85

att.Mult_AccuracyMOA = 0.95
att.Mult_HipDispersion = 0.95
att.Mult_MoveDispersion = 0.95

att.Mult_DrawTime = 0.9
att.Mult_HolsterTime = 0.9
att.Mult_SightTime = 0.9

att.Mult_SpeedMult = 1.05
att.Mult_SightedSpeedMult = 1.1

att.Mult_ReloadTime = 0.95

att.Mult_Recoil = 0.85
att.Mult_RecoilSide = 0.85
att.Mult_VisualRecoilMult = 0.8
att.Mult_Sway = 0.9

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_loadingdrills.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_dc15a_60mag.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/universal_vibroknife.lua:
return gluapack()()
--PATH lua/arccw/shared/status_effects.lua:
if SERVER then AddCSLuaFile() end

GMSERV = {}
GMSERV.StatusEffects = {
	["heal"] = {
		["string"] = "Healing",
		["function"] =
			function(target, dealer, effect, duration, amount)
				local mult
				if target == dealer then
					mult = 0.25
				else
					mult = 1
				end
				local hpam = amount*mult
				local hpdur = duration
				local hptick = (amount/duration)*mult

				local HealAmount
				for i = 1, hpdur*hptick do
					timer.Simple(i/hptick, function()
						if !target:IsValid() then return end
						local futureheal = ( hpam/hpdur )/hptick

						if (target:GetMaxHealth()*2) - target:Health() >= futureheal then
							HealAmount = futureheal
						else
							HealAmount = ((target:GetMaxHealth()*2) - target:Health())
						end

						target:SetHealth( target:Health() + HealAmount )
					end)
				end

				if effect then
					local ED_Heal = EffectData()
					ED_Heal:SetOrigin( target:GetPos() )
					ED_Heal:SetEntity( target )
					ED_Heal:SetMagnitude( hpam )
					ED_Heal:SetScale( hpdur )
					util.Effect("serv_passive_heal", ED_Heal, true, true)
				end
			end
		},
	["stun"] = {
		["string"] = "Stun",
		["function"] =
			function(target, dealer, effect, duration)
				local function RemoveFrozen(target)
					if target:IsValid() then
						target.SERVStatFrozen = false

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.IN, Color( 0, 0, 0, 0 ), 0.4, 0.2 )
							target:Freeze( false )
						elseif target:IsNPC() then
							target:SetCondition( 68 )
							if target:Health() < 1 then
								target:SetNPCState(7)
							end
						end
					end
				end

				if ((target:IsPlayer() and target ~= dealer) or target:IsNPC()) then
					if target.SERVStatFrozen then
						if target:Health() < 1 then
							RemoveFrozen(target)
						end
					else
						target.SERVStatFrozen = true

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.OUT, Color( 0, 200, 255, 0 ), 0.2, 2.5 )
							target:Freeze( true ) 
						elseif target:IsNPC() then
							target:SetSchedule( SCHED_NPC_FREEZE )
							target:StopMoving()
						end

						timer.Simple( duration, function()
							RemoveFrozen(target)
						end )
					end

					if effect then
						local ED_Stun = EffectData()
						ED_Stun:SetOrigin( target:GetPos() )
						ED_Stun:SetEntity( target )
						ED_Stun:SetScale( duration )
						util.Effect("SERV_passive_stun", ED_Stun, true, true)
					end
				end
			end
		},
	["poison"] = {
		["string"] = "Poison",
		["function"] =
			function(target, dealer, effect, duration, damage)
				if !(target:IsPlayer() or target:IsNPC()) then return false end
				local tick = damage/duration
				if target:IsPlayer() then
					local playerdead = false
				end
				for i = 1, duration do
					timer.Simple(i-1, function()
						if target:IsPlayer() then
							if !target:Alive() then 
								playerdead = true
							end
							if playerdead then return end
						end
						if !target:IsValid() then return end
						local futdmg = ( damage/duration )
						target:TakeDamage(futdmg, dealer, dealer)
					end)
				end

				if effect then
					local ED_Poison = EffectData()
					ED_Poison:SetOrigin( target:GetPos() )
					ED_Poison:SetEntity( target )
					ED_Poison:SetMagnitude( damage )
					ED_Poison:SetScale( duration )
					util.Effect("SERV_passive_poison", ED_Poison, true, true)
				end

			end
		},
}

function GMSERV:AddStatus(target, dealer, type, a, b, c)
	if target:IsPlayer() or target:IsNPC() then
		GMSERV.StatusEffects[type]["function"](target, dealer, c, a, b)
	end
end
--PATH lua/arccw/client/cl_glint.lua:
local rnd        = render
local r_lightcol = rnd.GetLightColor

local glintmat = Material("effects/blueflare1")

local players
local playerssaver = {}

hook.Add("PostDrawEffects", "ArcCW_ScopeGlint", function()
    if playerssaver != players then -- less calls on GetAll
        players      = player.GetAll()
        playerssaver = players
    end

    cam.Start3D()
        for _, ply in ipairs(players) do
            if !IsValid(ply) then continue end

            if ply == LocalPlayer() and !ply:ShouldDrawLocalPlayer() then continue end

            local wep = ply:GetActiveWeapon()

            if !(IsValid(wep) and wep.ArcCW) then continue end

            if !wep:GetBuff_Override("ScopeGlint") then continue end

            if wep:GetState() != ArcCW.STATE_SIGHTS then continue end

            local vec = (ply:EyePos() - EyePos()):GetNormalized()
            local dot = vec:Dot(-ply:EyeAngles():Forward())

            dot = (dot * dot * 1.75) - 0.75
            dot = dot * (0.5 + (1 - wep:GetSightDelta()) * 0.5)

            if dot < 0 then continue end

            local pos = ply:EyePos() + (ply:EyeAngles():Forward() * 16) + (ply:EyeAngles():Right() * 8)

            local _, scope_i = wep:GetBuff_Override("ScopeGlint")

            if scope_i then
                local world = (wep.Attachments[scope_i].WElement or {}).Model

                if world and IsValid(world) then
                    local att = world:LookupAttachment("holosight") or world:LookupAttachment("scope")

                    if att then pos = world:GetAttachment(att).Pos end
                end
            end

            local lcolpos = r_lightcol(pos):Length()
            local lcoleye = r_lightcol(EyePos()):Length()

            local mag       = wep:GetBuff_Mult("Mult_GlintMagnitude") or 1
            local intensity = math.min(0.2 + (lcolpos + lcoleye) / 2 * 1, 1) * mag
            local col       = 255 * intensity

            rnd.SetMaterial(glintmat)
            rnd.DrawSprite(pos, 96 * dot, 96 * dot, Color(col, col, col))
        end
    cam.End3D()
end)
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/autorun/arccw_kraken_ammo.lua:
return gluapack()()
--PATH lua/autorun/atrt_sounds.lua:
sound.Add( {
	name = "atrt.step1",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/step1.wav"
} )

sound.Add( {
	name = "atrt.step2",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/step2.wav"
} )

sound.Add( {
	name = "atrt.shoot",
	channel = CHAN_BODY,
	volume = 1.0,
	level = 90,
	pitch = { 95, 105 },
	sound = {
	"KingPommes/starwars/atrt/shoot1.wav",
	"KingPommes/starwars/atrt/shoot2.wav" }
} )

sound.Add( {
	name = "atrt.standup",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/standup.wav"
} )

sound.Add( {
	name = "atrt.sitdown",
	channel = CHAN_BODY,
	volume = .8,
	level = 70,
	pitch = { 95, 105 },
	sound = "KingPommes/starwars/atrt/sitdown.wav"
} )
--PATH lua/autorun/aussi_cgi501st_arms.lua:
list.Set( "PlayerOptionsModel", "Phase 2 501st Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_trooper.mdl" )
player_manager.AddValidModel( "Phase 2 501st Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_trooper.mdl" )
player_manager.AddValidHands( "Phase 2 501st Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st BARC Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_barc.mdl" )
player_manager.AddValidModel( "Phase 2 501st BARC Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_barc.mdl" )
player_manager.AddValidHands( "Phase 2 501st BARC Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Medic (CGI)", "models/aussiwozzi/cgi/base/501st_medic.mdl" )
player_manager.AddValidModel( "Phase 2 501st Medic (CGI)", "models/aussiwozzi/cgi/base/501st_medic.mdl" )
player_manager.AddValidHands( "Phase 2 501st Medic (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Torrent Company (CGI)", "models/aussiwozzi/cgi/base/501st_torrent.mdl" )
player_manager.AddValidModel( "Phase 2 501st Torrent Company (CGI)", "models/aussiwozzi/cgi/base/501st_torrent.mdl" )
player_manager.AddValidHands( "Phase 2 501st Torrent Company (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Medic Officer (CGI)", "models/aussiwozzi/cgi/base/501st_medic_officer.mdl" )
player_manager.AddValidModel( "Phase 2 501st Medic Officer (CGI)", "models/aussiwozzi/cgi/base/501st_medic_officer.mdl" )
player_manager.AddValidHands( "Phase 2 501st Medic Officer (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Officer (CGI)", "models/aussiwozzi/cgi/base/501st_officer.mdl" )
player_manager.AddValidModel( "Phase 2 501st Officer (CGI)", "models/aussiwozzi/cgi/base/501st_officer.mdl" )
player_manager.AddValidHands( "Phase 2 501st Officer (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Hawk (CGI)", "models/aussiwozzi/cgi/base/501st_hawk.mdl" )
player_manager.AddValidModel( "Phase 2 501st Hawk (CGI)", "models/aussiwozzi/cgi/base/501st_hawk.mdl" )
player_manager.AddValidHands( "Phase 2 501st Hawk (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Pilot (CGI)", "models/aussiwozzi/cgi/base/501st_pilot.mdl" )
player_manager.AddValidModel( "Phase 2 501st Pilot (CGI)", "models/aussiwozzi/cgi/base/501st_pilot.mdl" )
player_manager.AddValidHands( "Phase 2 501st Pilot (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Appo (CGI)", "models/aussiwozzi/cgi/base/501st_appo.mdl" )
player_manager.AddValidModel( "Phase 2 501st Appo (CGI)", "models/aussiwozzi/cgi/base/501st_appo.mdl" )
player_manager.AddValidHands( "Phase 2 501st Appo (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_arf.mdl" )
player_manager.AddValidModel( "Phase 2 501st ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_arf.mdl" )
player_manager.AddValidHands( "Phase 2 501st ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Vaughn (CGI)", "models/aussiwozzi/cgi/base/501st_vaughn.mdl" )
player_manager.AddValidModel( "Phase 2 501st Vaughn (CGI)", "models/aussiwozzi/cgi/base/501st_vaughn.mdl" )
player_manager.AddValidHands( "Phase 2 501st Vaughn (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Kix (CGI)", "models/aussiwozzi/cgi/base/501st_kix.mdl" )
player_manager.AddValidModel( "Phase 2 501st Kix (CGI)", "models/aussiwozzi/cgi/base/501st_kix.mdl" )
player_manager.AddValidHands( "Phase 2 501st Kix (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Hardcase (CGI)", "models/aussiwozzi/cgi/base/501st_hardcase.mdl" )
player_manager.AddValidModel( "Phase 2 501st Hardcase (CGI)", "models/aussiwozzi/cgi/base/501st_hardcase.mdl" )
player_manager.AddValidHands( "Phase 2 501st Hardcase (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Dogma (CGI)", "models/aussiwozzi/cgi/base/501st_dogma.mdl" )
player_manager.AddValidModel( "Phase 2 501st Dogma (CGI)", "models/aussiwozzi/cgi/base/501st_dogma.mdl" )
player_manager.AddValidHands( "Phase 2 501st Dogma (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Rex (CGI)", "models/aussiwozzi/cgi/base/501st_rex.mdl" )
player_manager.AddValidModel( "Phase 2 501st Rex (CGI)", "models/aussiwozzi/cgi/base/501st_rex.mdl" )
player_manager.AddValidHands( "Phase 2 501st Rex (CGI)", "models/aussiwozzi/cgi/base/501st_rex_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Tup (CGI)", "models/aussiwozzi/cgi/base/501st_tup.mdl" )
player_manager.AddValidModel( "Phase 2 501st Tup (CGI)", "models/aussiwozzi/cgi/base/501st_tup.mdl" )
player_manager.AddValidHands( "Phase 2 501st Tup (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Jesse (CGI)", "models/aussiwozzi/cgi/base/501st_jesse.mdl" )
player_manager.AddValidModel( "Phase 2 501st Jesse (CGI)", "models/aussiwozzi/cgi/base/501st_jesse.mdl" )
player_manager.AddValidHands( "Phase 2 501st Jesse (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Jet Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_jet_trooper.mdl" )
player_manager.AddValidModel( "Phase 2 501st Jet Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_jet_trooper.mdl" )
player_manager.AddValidHands( "Phase 2 501st Jet Trooper (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st ARC Fives (CGI)", "models/aussiwozzi/cgi/base/501st_fives.mdl" )
player_manager.AddValidModel( "Phase 2 501st ARC Fives (CGI)", "models/aussiwozzi/cgi/base/501st_fives.mdl" )
player_manager.AddValidHands( "Phase 2 501st ARC Fives (CGI)", "models/aussiwozzi/cgi/base/501st_arc_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st ARC Jesse (CGI)", "models/aussiwozzi/cgi/base/501st_jesse_arc.mdl" )
player_manager.AddValidModel( "Phase 2 501st ARC Jesse (CGI)", "models/aussiwozzi/cgi/base/501st_jesse_arc.mdl" )
player_manager.AddValidHands( "Phase 2 501st ARC Jesse (CGI)", "models/aussiwozzi/cgi/base/501st_arc_arms.mdl",0,"10000000" )

--PATH addons/[admin] awarn3/lua/localizations/de.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/localizations/de.lua:
local language_code = "DE"

--[[German translation by Funny_TV]]--
--https://www.gmodstore.com/users/Funny_TV

 AWarn.Localization:RegisterLanguage( language_code, "German" )
 
AWarn.Localization:AddDefinition( language_code, "welcome1",                    "Willkommen zu AWarn3!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms",           "Unzureichende Rechte um dieses Command auszuführen." )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2",          "Unzureichend Rechte um die Warns des Spielers einzusehen." )
AWarn.Localization:AddDefinition( language_code, "commandnonexist",             "Dieses Command existiert nicht." )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid",             "Ungültige Person oder ID." )
AWarn.Localization:AddDefinition( language_code, "invalidtarget",               "Ungültige Person." )
AWarn.Localization:AddDefinition( language_code, "reasonrequired",              "Warn Grund benötigt." )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn",           "Du entfernst 1x Warn von" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid",            "Warn ID gelöscht" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings",           "Du entfernst alle Warns von" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor",          "Alle Warns löschen für" )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole",             "Du kannst diese Menü nicht über die Konsole öffnen." )
AWarn.Localization:AddDefinition( language_code, "invalidoption",               "Ungültige Option." )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",      "Ungültiger Wert." )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",               "Option geladen!" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",                "Keine Bestrafung für diese Warnung zählen." )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",           "Bestrafungen geladen!" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",        "Dieser Spieler kann nicht gewarnt werden." )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",                "Du wurdest von %s für %s gewarnt." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",                "Du warnst %s für %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",                "%s wurde von %s für %s gewarnt" )
AWarn.Localization:AddDefinition( language_code, "warnmessage4",                "Du wurdest von %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage5",                "Du warnst %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage6",                "%s wurde von %s." )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",                "joint dem Server mit Warns." )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",                "Der letzte Warn ist vom:" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",                "Willkommen zurück! Du wurdest in der Vergangenheit schon einmal gewarnt." )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",                "Du kannst deine Warns mit folgendem Command einsehen:" )
AWarn.Localization:AddDefinition( language_code, "closemenu",                   "Menuü schliessen" )
AWarn.Localization:AddDefinition( language_code, "searchplayers",               "Spieler suchen" )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",                "Warns Anzeigen" )
AWarn.Localization:AddDefinition( language_code, "configuration",               "Konfiguration" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",               "User Optionen" )
AWarn.Localization:AddDefinition( language_code, "serveroptions",               "Server Optionen" )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",          "Farb Einstellungen" )
AWarn.Localization:AddDefinition( language_code, "colorselection",              "Farb auswahl" )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",       "Sprach Einstellungen" )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",              "Sprache auswählen" )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",            "Kick Bestrafung Aktivieren" )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",             "Ban Bestrafung Aktivieren" )
AWarn.Localization:AddDefinition( language_code, "enabledecay",                 "Warn verfall aktivieren" )
AWarn.Localization:AddDefinition( language_code, "resetafterban",               "Aktive Warn nach Ban reseten" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",             "Erlaube Teammitglieder zu warnen" )
AWarn.Localization:AddDefinition( language_code, "pressenter",                  "Enter zum Speichern" )
AWarn.Localization:AddDefinition( language_code, "entertosave",                 "Enter zum Speichern" )
AWarn.Localization:AddDefinition( language_code, "chatprefix",                  "Chat Prefix" )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",            "Warn verfall Rate (in Minuten)" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",              "Server Sprache" )
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",    "Bestrafungs Einstellungen" )
AWarn.Localization:AddDefinition( language_code, "addpunishment",               "Bestrafung hinzufügen" )
AWarn.Localization:AddDefinition( language_code, "warnings",                    "Warnungen" )
AWarn.Localization:AddDefinition( language_code, "punishtype",                  "Bestrafungs Typ" )
AWarn.Localization:AddDefinition( language_code, "punishlength",                "Bestrafungs Länge" )
AWarn.Localization:AddDefinition( language_code, "playermessage",               "Spieler Nachricht" )
AWarn.Localization:AddDefinition( language_code, "playername",                  "Spieler Name" )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",             "Nachrivht an Spieler" )
AWarn.Localization:AddDefinition( language_code, "servermessage",               "Server Nachricht" )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",             "Nachricht an Server" )
AWarn.Localization:AddDefinition( language_code, "deletewarning",               "Warn löschen" )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",               "Bestrafung hinzufügen Menü" )
AWarn.Localization:AddDefinition( language_code, "inminutes",                   "In Minuten" )
AWarn.Localization:AddDefinition( language_code, "0equalperma",                 "0 = Permanent" )
AWarn.Localization:AddDefinition( language_code, "use%",                        "Benutz %s um den Namen des Spieler einzusehen" )
AWarn.Localization:AddDefinition( language_code, "setdefault",                  "Standart setzen" )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",          "Eigene Warnungen anzeigen" )
AWarn.Localization:AddDefinition( language_code, "warnedby",                    "Gewarnt von" )
AWarn.Localization:AddDefinition( language_code, "warningserver",               "Warn Server" )
AWarn.Localization:AddDefinition( language_code, "warningreason",               "Warn Grund" )
AWarn.Localization:AddDefinition( language_code, "warningdate",                 "Warn Datum" )
AWarn.Localization:AddDefinition( language_code, "nothing",                     "NICHTS" )
AWarn.Localization:AddDefinition( language_code, "submit",                      "Bestätigen" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",            "Verbundene Spieler" )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",          "Warns anzeigen für" )
AWarn.Localization:AddDefinition( language_code, "activewarnings",              "Active Warns" )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",    "Der Spieler hat keine aktiven Warns." )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",     "Spieler aussuchen um Warns einzusehen." )
AWarn.Localization:AddDefinition( language_code, "warnplayer",                  "Spieler Warnen" )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",             "Reduzier aktive Warns um 1" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",           "Spieler Warn Menü" )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",            "Spieler such Menü" )
AWarn.Localization:AddDefinition( language_code, "warningplayer",               "Warns Spieler" )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",              "Spieler mit 0 Warns im Verlauf Ausschließen" )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",            "Spiler anhand von Namen oder SteamID64 suchen" )
AWarn.Localization:AddDefinition( language_code, "name",                        "Name" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",                  "Als letztes online am" )
AWarn.Localization:AddDefinition( language_code, "lastwarned",                  "Als letztes gewarnt am" )
AWarn.Localization:AddDefinition( language_code, "never",                       "Noch nie" )
AWarn.Localization:AddDefinition( language_code, "playerid",                    "Spieler ID" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",        "Spieler's Warns anzeigen" )
AWarn.Localization:AddDefinition( language_code, "servername",                  "Server Name" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"Warnungszähler für Spieler beim Beitritt anzeigen" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"Admins eine Nachricht anzeigen, wenn Spieler mit Warnungen beitreten" )
AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"Strafen" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		"Wenn aktiviert, kann AWarn3 Spieler als Strafe vom Server werfen." )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		"Wenn aktiviert, kann AWarn3 Spieler als Strafe vom Server sperren." )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"Wenn aktiviert, werden aktive Warnungen mit der Zeit abklingen." )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"Wenn diese Option aktiviert ist, müssen Administratoren in ihrer Warnung einen Grund angeben." )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"Wenn aktiviert, werden die aktiven Warnungen eines Benutzers auf 0 zurückgesetzt, nachdem sie von AWarn3 gesperrt wurden." )
AWarn.Localization:AddDefinition( language_code, "logevents",					"Warnereignisse protokollieren." )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"Wenn aktiviert, werden Aktionen in AWarn3 in einer Textdatei protokolliert." )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"Wenn diese Option aktiviert ist, können Administratoren andere Administratoren warnen." )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","Wenn diese Option aktiviert ist, sehen Benutzer, die dem Server beitreten, eine Nachricht im Chat, wenn sie Warnungen haben." )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"Wenn diese Option aktiviert ist, sehen Admins auf dem Server, wenn ein Spieler beitritt, der Warnungen hat." )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		"Der Chat-Befehl, der für AWarn3-Befehle verwendet wird. Standard: !warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	"The time (in minutes) a player needs to be connected for 1 active warning to decay." )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"Die Zeit (in Minuten), die ein Spieler benötigt, damit eine aktive Warnung abklingt." )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	"Dies ist die Sprache, in der Servernachrichten angezeigt werden." )
AWarn.Localization:AddDefinition( language_code, "theme",						"Interface-Theme" )
AWarn.Localization:AddDefinition( language_code, "themeselect",					"Thema wählen" )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					"Bestrafungsgruppe" )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"Zum Einstellen gruppieren" )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"Spielernotizen anzeigen" )
AWarn.Localization:AddDefinition( language_code, "playernotes",					"Spielernotizen" )
AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		"Schnittstellenanpassungen" )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"Hintergrundunschärfe aktivieren" )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"Wählen Sie eine Voreinstellung (optional)" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"Voreinstellungen" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				"Voreinstellung hinzufügen/bearbeiten" )
AWarn.Localization:AddDefinition( language_code, "presetname",					"Voreinstellungsname" )
AWarn.Localization:AddDefinition( language_code, "presetreason",				"Voreingestellter Grund" )

--PATH addons/[admin] awarn3/lua/localizations/fr.lua:
local language_code = "FR"

AWarn.Localization:RegisterLanguage( language_code, "Français" )

//Credit: https://www.gmodstore.com/users/76561198047157426

AWarn.Localization:AddDefinition( language_code, "welcome1", 					"Bienvenue sur AWarn3!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms", 			"Permissions insuffisantes pour exécuter cette commande." )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2", 			"Permissions insuffisantes pour visualiser les avertissements de ce joueur." )
AWarn.Localization:AddDefinition( language_code, "commandnonexist", 			"Cette commande n'existe pas." )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid", 			"Cible ou ID invalide." )
AWarn.Localization:AddDefinition( language_code, "invalidtarget", 				"Cible invalide." )
AWarn.Localization:AddDefinition( language_code, "reasonrequired", 				"Motif d'avertissement requis." )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn", 			"Vous avez supprimé 1 avertissement actif de" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid", 			"ID d'avertissement supprimé" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings", 			"Vous avez supprimé tous les avertissements de" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor", 			"Suppression de tous les avertissements pour" )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole", 			"Vous ne pouvez pas ouvrir le menu à partir de la console du serveur." )
AWarn.Localization:AddDefinition( language_code, "invalidoption", 				"Option Invalide." )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",		"Type de valeur d'option invalide." )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",				"Options chargées!" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",				"Aucune punition pour ce nombre d'avertissement." )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",			"Punitions chargées!" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",		"Ce joueur n'a pas le droit d'être averti." )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",				"Vous avez reçu un avertissement de %s pour %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",				"Vous avez donné un avertissement à %s pour %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",				"%s a reçu un avertissement de %s pour %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage4",				"Vous avez reçu un avertissement de %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage5",				"Vous avez donné un avertissement à %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage6",				"%s a reçu un avertissement de %s." )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",				"a rejoint le serveur avec des avertissements." )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",				"Son dernier avertissement était :" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",				"Bienvenue sur le serveur ! Il semble que vous avez été avertis récemment." )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",				"Vous pouvez consulter vos avertissements à tout moment en tapant" )
AWarn.Localization:AddDefinition( language_code, "closemenu",					"Fermer le menu" )
AWarn.Localization:AddDefinition( language_code, "searchplayers",				"Trouver des joueurs" )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",				"Avertissements" )
AWarn.Localization:AddDefinition( language_code, "configuration",				"Configuration" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",				"Options utilisateur" )
AWarn.Localization:AddDefinition( language_code, "serveroptions",				"Options serveur" )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",			"Personnalisation des couleurs" )
AWarn.Localization:AddDefinition( language_code, "colorselection",				"Choix des couleurs" )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",		"Choix de la lanque" )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",				"Sélectionnez une langue" )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",			"Activer le kick en punition" )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",				"Activer le ban en punition" )
AWarn.Localization:AddDefinition( language_code, "enabledecay",					"Activer l'expiration des avertissements" )
AWarn.Localization:AddDefinition( language_code, "resetafterban",				"Réinitialiser les avertissements actifs après le ban" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",				"Activer la possibilité de warn les admins" )
AWarn.Localization:AddDefinition( language_code, "pressenter",					"Appuyez sur Entrée pour enregistrer les changements" )
AWarn.Localization:AddDefinition( language_code, "entertosave",					"Entrer pour enregistrer" )
AWarn.Localization:AddDefinition( language_code, "chatprefix",					"Préfixe du Chat" )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",			"Temps d'expiration des avertissements (en minutes)" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",				"Langue du serveur" )
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",	"Configuration des punitions" )
AWarn.Localization:AddDefinition( language_code, "addpunishment",				"Ajouter une punition" )
AWarn.Localization:AddDefinition( language_code, "warnings",					"Avertissements" )
AWarn.Localization:AddDefinition( language_code, "punishtype",					"Type de punition" )
AWarn.Localization:AddDefinition( language_code, "punishlength",				"Temps de la punition" )
AWarn.Localization:AddDefinition( language_code, "playermessage",				"Message du joueur" )
AWarn.Localization:AddDefinition( language_code, "playername",					"Pseudo" )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",				"Message au joueur" )
AWarn.Localization:AddDefinition( language_code, "servermessage",				"Message du serveur" )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",				"Message au serveur" )
AWarn.Localization:AddDefinition( language_code, "deletewarning",				"Supprimer l'avertissement" )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",				"Menu d'ajout de punitions" )
AWarn.Localization:AddDefinition( language_code, "inminutes",					"En Minutes" )
AWarn.Localization:AddDefinition( language_code, "0equalperma",					"0 = Permanent" )
AWarn.Localization:AddDefinition( language_code, "use%",						"Utiliser %s pour afficher le nom du joueur" )
AWarn.Localization:AddDefinition( language_code, "setdefault",					"Définir la valeur par défaut" )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",			"Affichage de vos propres avertissements" )
AWarn.Localization:AddDefinition( language_code, "warnedby",					"Averti par" )
AWarn.Localization:AddDefinition( language_code, "warningserver",				"Serveur d'avertissement" )
AWarn.Localization:AddDefinition( language_code, "warningreason",				"Raison  de l'avertissement" )
AWarn.Localization:AddDefinition( language_code, "warningdate",					"Date de l'avertissement" )
AWarn.Localization:AddDefinition( language_code, "nothing",						"RIEN" )
AWarn.Localization:AddDefinition( language_code, "submit",						"Envoyer" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",			"Joueurs en ligne" )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",			"Affichage des avertissements pour" )
AWarn.Localization:AddDefinition( language_code, "activewarnings",				"Avertissements actifs" )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",	"Le joueur sélectionné n'a pas d'avertissement enregistrer." )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",		"Sélectionnez un joueur pour voir ses avertissements." )
AWarn.Localization:AddDefinition( language_code, "warnplayer",					"Avertir le joueur" )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",				"Réduire les avertissements actifs de 1" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",			"Menu d'avertissement du joueur" )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",			"Menu de recherche de joueur" )
AWarn.Localization:AddDefinition( language_code, "warningplayer",				"Avertissement Joueur" )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",				"Exclure les joueurs qui n'ont pas d'historique d'avertissement" )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",			"Rechercher des joueurs par leur nom ou leur SteamID64" )
AWarn.Localization:AddDefinition( language_code, "name",						"Nom" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",					"Dernière connexion" )
AWarn.Localization:AddDefinition( language_code, "lastwarned",					"Dernier avertissement" )
AWarn.Localization:AddDefinition( language_code, "never",						"Jamais" )
AWarn.Localization:AddDefinition( language_code, "playerid",					"ID du Joueur" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",		"Consulter les avertissements de ce joueur" )
AWarn.Localization:AddDefinition( language_code, "servername",					"Nom du serveur" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"Afficher le nombre d'avertissements au joueur lors de l'adhésion" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"Afficher un message aux administrateurs lorsque le joueur se joint avec des avertissements" )
AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"Les sanctions" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		"S'il est activé, AWarn3 peut expulser les joueurs du serveur en guise de punition." )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		"S'il est activé, AWarn3 peut bannir les joueurs du serveur en guise de punition." )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"Si cette option est activée, les avertissements actifs s'atténueront avec le temps." )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"Si cette option est activée, les administrateurs devront fournir une raison dans leur avertissement." )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"Si activé, les avertissements actifs d'un utilisateur seront réinitialisés à 0 après avoir été bannis par AWarn3." )
AWarn.Localization:AddDefinition( language_code, "logevents",					"Consigner les événements d'avertissement." )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"Si activé, les actions dans AWarn3 seront enregistrées dans un fichier texte." )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"Si activé, les administrateurs pourront avertir les autres administrateurs." )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","Si activé, les utilisateurs qui rejoignent le serveur verront un message dans le chat s'ils ont des avertissements." )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"Si cette option est activée, les administrateurs sur le serveur verront quand un joueur se joint à lui qui a des avertissements." )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		"La commande chat utilisée pour les commandes AWarn3. Par défaut : !warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	"Le temps (en minutes) qu'un joueur doit être connecté pour qu'un avertissement actif se désintègre." )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"Le nom de ce serveur. Ceci est utile pour les configurations de plusieurs serveurs." )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	"Il s'agit de la langue dans laquelle les messages du serveur seront affichés." )
AWarn.Localization:AddDefinition( language_code, "theme",						"Thème de l'interface" )
AWarn.Localization:AddDefinition( language_code, "themeselect",					"Sélectionne un thème" )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					"Groupe de punition" )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"Groupe à définir" )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"Afficher les notes des joueurs" )
AWarn.Localization:AddDefinition( language_code, "playernotes",					"Notes du joueur" )
AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		"Personnalisations de l'interface" )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"Activer le flou d'arrière-plan" )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"Choisissez un préréglage (facultatif)" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"Préconfigurations" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				"Ajouter/Modifier un préréglage" )
AWarn.Localization:AddDefinition( language_code, "presetname",					"Nom du préréglage" )
AWarn.Localization:AddDefinition( language_code, "presetreason",				"Motif prédéfini" )

--PATH addons/[admin] awarn3/lua/localizations/pl.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/localizations/pt.lua:
local language_code = "PT"

AWarn.Localization:RegisterLanguage( language_code, "Português" )

//Credit: https://www.gmodstore.com/users/76561198283808068

AWarn.Localization:AddDefinition( language_code, "welcome1", 					"Bem-vindo ao AWarn3!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms", 			"Permissões insuficientes para executar este comando." )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2", 			"Permissões insuficientes para ver as advertências deste jogador." )
AWarn.Localization:AddDefinition( language_code, "commandnonexist", 			"Este comando não existe." )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid", 			"Alvo ou ID inválido." )
AWarn.Localization:AddDefinition( language_code, "invalidtarget", 				"Alvo inválido." )
AWarn.Localization:AddDefinition( language_code, "reasonrequired", 				"É necessária uma Razão para Advertir" )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn", 			"Você removeu 1 advertência ativa de" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid", 			"Advertência excluída - ID" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings", 			"Você removeu todas as advertências de" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor", 			"Foram excluídas todas as advertências de" )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole", 			"Você não pode abrir o menu através do console do servidor." )
AWarn.Localization:AddDefinition( language_code, "invalidoption", 				"Opção Inválida." )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",		"O tipo de valor da opção é inválido." )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",				"Opções Carregadas!" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",				"Nenhuma punição para esta contagem de advertências." )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",			"Punições Carregadas!" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",		"Este jogador não pode ser advertido." )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",				"Você foi advertido por %s: %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",				"Você advertiu %s: %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",				"%s foi advertido por %s: %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage4",				"Você foi advertido por %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage5",				"Você advertiu %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage6",				"%s foi advertido por %s." )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",				"entrou no servidor com advertências." )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",				"Sua última advertência foi em:" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",				"Bem-vindo de volta ao servidor! Parece que você já foi advertido no passado." )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",				"Você pode ver as suas advertências a qualquer momento, digitando" )
AWarn.Localization:AddDefinition( language_code, "joinmessage5",				"O jogador está entrando com advertências ativas: " )
AWarn.Localization:AddDefinition( language_code, "closemenu",					"Fechar Menu" )
AWarn.Localization:AddDefinition( language_code, "searchplayers",				"Buscar Jogador" )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",				"Advertências" )
AWarn.Localization:AddDefinition( language_code, "configuration",				"Configuração" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",				"Opções do Usuário" )
AWarn.Localization:AddDefinition( language_code, "serveroptions",				"Opções do Servidor" )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",			"Personalização de Cor" )
AWarn.Localization:AddDefinition( language_code, "colorselection",				"Seleção de Cor" )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",		"Personalização do Idioma" )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",				"Selecione um Idioma" )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",			"Habilitar Punição de Kick" )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",				"Habilitar Punição de Ban" )
AWarn.Localization:AddDefinition( language_code, "enabledecay",					"Habilitar Decaimento de Adver. Ativa" )
AWarn.Localization:AddDefinition( language_code, "resetafterban",				"Resetar Adver. Ativa Após Banimento" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",				"Permitir Advertir Admins" )
AWarn.Localization:AddDefinition( language_code, "pressenter",					"Pressione Enter para Salvar Alteração" )
AWarn.Localization:AddDefinition( language_code, "entertosave",					"Enter para Salvar" )
AWarn.Localization:AddDefinition( language_code, "chatprefix",					"Prefixo do Chat" )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",			"Tempo de Decaimento (em minutos)" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",				"Idioma do Servidor" )
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",	"Configuração de Punição" )
AWarn.Localization:AddDefinition( language_code, "addpunishment",				"Adicionar Punição" )
AWarn.Localization:AddDefinition( language_code, "warnings",					"Advertências" )
AWarn.Localization:AddDefinition( language_code, "punishtype",					"Tipo de Punição" )
AWarn.Localization:AddDefinition( language_code, "punishlength",				"Duração da Punição" )
AWarn.Localization:AddDefinition( language_code, "playermessage",				"Mensagem do Jogador" )
AWarn.Localization:AddDefinition( language_code, "playername",					"Nome do Jogador" )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",				"Mensagem para o Jogador" )
AWarn.Localization:AddDefinition( language_code, "servermessage",				"Mensagem do Servidor" )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",				"Mensagem para o Servidor" )
AWarn.Localization:AddDefinition( language_code, "deletewarning",				"Apagar Advertência" )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",				"Menu Adicionar Punição" )
AWarn.Localization:AddDefinition( language_code, "inminutes",					"Em Minutos" )
AWarn.Localization:AddDefinition( language_code, "0equalperma",					"0 = Permanente" )
AWarn.Localization:AddDefinition( language_code, "use%",						"Use %s para mostrar o nome do jogador" )
AWarn.Localization:AddDefinition( language_code, "setdefault",					"Definir Padrão" )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",			"Mostrar as suas próprias advertências" )
AWarn.Localization:AddDefinition( language_code, "warnedby",					"Advertido por" )
AWarn.Localization:AddDefinition( language_code, "warningserver",				"Advertência do Servidor" )
AWarn.Localization:AddDefinition( language_code, "warningreason",				"Razão da Advertência" )
AWarn.Localization:AddDefinition( language_code, "warningdate",					"Data da Advertência" )
AWarn.Localization:AddDefinition( language_code, "nothing",						"NADA" )
AWarn.Localization:AddDefinition( language_code, "submit",						"Enviar" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",			"Jogadores Conectados" )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",			"Mostrando Advertências de" )
AWarn.Localization:AddDefinition( language_code, "activewarnings",				"Advertências Ativas" )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",	"O jogador selecionado não tem advertências registradas." )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",		"Selecione um jogador para ver as advertências do mesmo." )
AWarn.Localization:AddDefinition( language_code, "warnplayer",					"Advertir Jogador" )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",				"Reduzir advertências ativas em 1" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",			"Menu de Advertência do Jogador" )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",			"Menu de Busca de Jogadores" )
AWarn.Localization:AddDefinition( language_code, "warningplayer",				"Advertindo Jogador" )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",				"Excluir jogadores sem histórico de advertência" )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",			"Buscar jogadores por nome ou SteamID64" )
AWarn.Localization:AddDefinition( language_code, "name",						"Nome" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",					"Última Partida" )
AWarn.Localization:AddDefinition( language_code, "lastwarned",					"Última Advertência" )
AWarn.Localization:AddDefinition( language_code, "never",						"Nunca" )
AWarn.Localization:AddDefinition( language_code, "playerid",					"ID do Jogador" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",		"Pesquisar advertências deste jogador" )
AWarn.Localization:AddDefinition( language_code, "servername",					"Nome do Servidor" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"Exibir contagem de aviso para o jogador ao entrar" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"Exibir mensagem para administradores quando o jogador entrar com avisos" )
AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"Punições" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		"Se habilitado, AWarn3 pode expulsar jogadores do servidor como punição." )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		"Se habilitado, AWarn3 pode banir jogadores do servidor como punição." )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"Se habilitado, os avisos ativos diminuirão com o tempo." )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"Se ativado, os administradores serão solicitados a fornecer um motivo em seu aviso." )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"Se habilitado, os avisos ativos de um usuário serão redefinidos para 0 após serem banidos por AWarn3." )
AWarn.Localization:AddDefinition( language_code, "logevents",					"Registrar eventos de aviso." )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"Se ativado, as ações no AWarn3 serão registradas em um arquivo de texto." )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"Se habilitado, os administradores poderão avisar outros administradores." )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","Se ativado, os usuários que entrarem no servidor verão uma mensagem no bate-papo se tiverem avisos." )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"Se habilitado, os administradores do servidor verão quando algum jogador entrar com avisos." )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		"O comando chat usado para comandos AWarn3. Padrão: !warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	"O tempo (em minutos) que um jogador precisa estar conectado para que 1 aviso ativo diminua." )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"O nome deste servidor. Isso é útil para várias configurações de servidor." )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	"Este é o idioma no qual as mensagens do servidor serão exibidas." )
AWarn.Localization:AddDefinition( language_code, "theme",						"Tema da Interface" )
AWarn.Localization:AddDefinition( language_code, "themeselect",					"Selecione o tema" )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					"Grupo de Punição" )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"Grupo para definir" )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"Ver notas do jogador" )
AWarn.Localization:AddDefinition( language_code, "playernotes",					"Notas do jogador" )
AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		"Customizações de Interface" )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"Habilitar desfoque de fundo" )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"Escolha uma predefinição (opcional)" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"Presets" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				"Adicionar/Editar Predefinição" )
AWarn.Localization:AddDefinition( language_code, "presetname",					"Nome Predefinido" )
AWarn.Localization:AddDefinition( language_code, "presetreason",				"Razão Predefinida" )

--PATH addons/[admin] awarn3/lua/localizations/th.lua:
local language_code = "TH-th"

--[[Thai translation by Kaname]]--
--https://steamcommunity.com/id/KanameA/

AWarn.Localization:RegisterLanguage( language_code, "Thai" )

AWarn.Localization:AddDefinition( language_code, "welcome1", 					"ยินดีต้อนรับสู่ AWarn3!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms", 			"คุณไม่มีสิทธิ์ที่จะใช้คำสั่งนี้" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2", 			"คุณไม่มีสิทธิ์ที่จะดูคำเตือนของผู้เล่นคนนี้" )
AWarn.Localization:AddDefinition( language_code, "commandnonexist", 			"ไม่พบคำสั่ง" )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid", 			"ไม่พบผู้เล่น หรือ ID" )
AWarn.Localization:AddDefinition( language_code, "invalidtarget", 				"ไม่พบผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "reasonrequired", 				"การตักเตือนจำเป็นต้องใส่เหตุผล" )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn", 			"คุณได้ทำการลบ 1 คำเตือนออกจาก" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid", 			"ลบคำเตือนจาก ID" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings", 			"คุณได้ทำการลบคำเตือนทั้งหมดออกจาก" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor", 			"ลบคำเตือนทำหมดสำหรับ" )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole", 			"คุณไม่สามารถเปิดเมนูจากเซิฟเวอร์คอนโซล" )
AWarn.Localization:AddDefinition( language_code, "invalidoption", 				"การตั้งค่าผิด" )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",		"การตั้งค่าผิดประเภท" )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",				"โหลดการตั้งค่าแล้ว" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",				"ไม่มีบทลงโทษสำหรับจำนวนคำเตือนเท่านี้" )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",			"โหลดการตั้งค่าบทลงโทษเสร็จแล้ว" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",		"ผู้เล่นคนนี้ไม่สามารถถูกตักเตือนได้" )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",				"คุณโดนตักเตือนโดย %s เพราะ %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",				"คุณตักเตือน %s เพราะ %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",				"%s ถูกตักเตือนโดย %s เพราะ %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage4",				"คุณโดนตักเตือนโดย %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage5",				"คุณตักเตือน %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage6",				"%s ถูกตักเตือนโดย %s" )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",				"ได้เข้าสู่เซิฟเวอร์พร้อมกับคำตักเตือน" )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",				"คำตักเตือนล่าสุด:" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",				"ยินดีต้อนรับกับเข้าสู่เซิฟเวอร์ เหมือนว่าคุณจะโดนตักเตือนมา" )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",				"คุณสามารถดูคำตักเตือนของคุณได้โดยพิม" )
AWarn.Localization:AddDefinition( language_code, "closemenu",					"ปิดเมนู" )
AWarn.Localization:AddDefinition( language_code, "searchplayers",				"ค้นหาผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",				"ดูคำตักเตือน" )
AWarn.Localization:AddDefinition( language_code, "configuration",				"แก้ไข" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",				"ตัวเลือกผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "serveroptions",				"ตัวเลือกเซิฟเวอร์" )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",			"แก้ไขสี" )
AWarn.Localization:AddDefinition( language_code, "colorselection",				"เลือกสี" )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",		"แก้ไขภาษา" )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",				"เลือกภาษา" )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",			"เปิดให้ใช้การเตะเป็นบทลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",				"เปิดให้ใช้การแบนเป็นบทลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "enabledecay",					"เปิดให้คำเตือนที่เปิดใช้งานอยู่สามารถหายไปได้" )
AWarn.Localization:AddDefinition( language_code, "resetafterban",				"รีเซตคำเตือนที่เปิดใช้งานอยู่หลังจากโดนแบน" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",				"อนุญาตให้ตักเตือนแอดมิน" )
AWarn.Localization:AddDefinition( language_code, "pressenter",					"กด Enter เพื่อบันทึก" )
AWarn.Localization:AddDefinition( language_code, "entertosave",					"กด Enter เพื่อบันทึก" )
AWarn.Localization:AddDefinition( language_code, "chatprefix",					"คำนำหน้าข้อความ" )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",			"การตักเตือนจะหายไปหลังจาก (ในนาที)" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",				"ภาษาของเซิฟเวอร์" )
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",	"แก้ไขบทลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "addpunishment",				"เพิ่มบทลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "warnings",					"คำตักเตือน" )
AWarn.Localization:AddDefinition( language_code, "punishtype",					"ประเภทของบทลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "punishlength",				"ระยะเวลาของบทลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "playermessage",				"ข้อความของผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "playername",					"ชื่อผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",				"ส่งข้อความไปยังผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "servermessage",				"ข้อความจากเซิฟเวอร์" )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",				"ส่งข้อความไปยังเซิฟเวอร์" )
AWarn.Localization:AddDefinition( language_code, "deletewarning",				"ลบคำตักเตือน" )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",				"เมนูเพิ่มบทลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "inminutes",					"ในนาที" )
AWarn.Localization:AddDefinition( language_code, "0equalperma",					"0 = ถาวร" )
AWarn.Localization:AddDefinition( language_code, "use%",						"กด %s เพื่อดูชื่อผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "setdefault",					"ตั้งค่าเริ่มต้น" )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",			"ดูการตักเตือนของตนเอง" )
AWarn.Localization:AddDefinition( language_code, "warnedby",					"ถูกตักเตือนโดย" )
AWarn.Localization:AddDefinition( language_code, "warningserver",				"เซิฟเวอร์ที่ตักเตือน" )
AWarn.Localization:AddDefinition( language_code, "warningreason",				"เหตุผลที่ตักเตือน" )
AWarn.Localization:AddDefinition( language_code, "warningdate",					"วันที่ตักเตือน" )
AWarn.Localization:AddDefinition( language_code, "nothing",						"ไม่" )
AWarn.Localization:AddDefinition( language_code, "submit",						"ตกลง" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",			"ผู้เล่นที่เชื่อมต่ออยู่" )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",			"แสดงคำตักเตือนสำหรับ" )
AWarn.Localization:AddDefinition( language_code, "activewarnings",				"คำเตือนที่ใช้งานอยู่" )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",	"ผู้เล่นที่ถูกเลือกไม่เคยถูกตักเตือน" )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",		"เลือกผู้เล่นที่ต้องการจะดูการตักเตือน" )
AWarn.Localization:AddDefinition( language_code, "warnplayer",					"ตักเตือนผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",				"ลด 1 คำเตือนที่ใช้งานอยู่" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",			"เมนูตักเตือนผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",			"เมนูค้นหาผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "warningplayer",				"ตักเตือนผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",				"ยกเว้นผู้เล่นที่ไม่เคยถูกเตือน" )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",			"ค้นหาผู้เล่นจาก ชื่อ หรือ SteamID64" )
AWarn.Localization:AddDefinition( language_code, "name",						"ชื่อ" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",					"เล่นครั้งล่าสุด" )
AWarn.Localization:AddDefinition( language_code, "lastwarned",					"เตือนครั้งล่าสุด" )
AWarn.Localization:AddDefinition( language_code, "never",						"ไม่เคย" )
AWarn.Localization:AddDefinition( language_code, "playerid",					"ไอดีผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",		"ค้นหาคำเตือนของผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "servername",					"ชื่อเซิฟเวอร์" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"แสดงจำนวนคำเตือนให้ผู้เล่นเข้าร่วม" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"แสดงข้อความถึงผู้ดูแลระบบเมื่อผู้เล่นเข้าร่วมพร้อมคำเตือน" )
AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"การลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		"หากเปิดใช้งาน AWarn3 สามารถเตะผู้เล่นจากเซิร์ฟเวอร์เพื่อลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		"หากเปิดใช้งาน AWarn3 สามารถแบนผู้เล่นจากเซิร์ฟเวอร์เป็นการลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"หากเปิดใช้งาน คำเตือนที่ทำงานอยู่จะลดลงเมื่อเวลาผ่านไป" )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"หากเปิดใช้งาน ผู้ดูแลระบบจะต้องให้เหตุผลในคำเตือน" )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"หากเปิดใช้งาน คำเตือนที่แอ็คทีฟของผู้ใช้จะรีเซ็ตเป็น 0 หลังจากที่ถูกแบนโดย AWarn3" )
AWarn.Localization:AddDefinition( language_code, "logevents",					"บันทึกเหตุการณ์คำเตือน" )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"หากเปิดใช้งาน การดำเนินการภายใน AWarn3 จะถูกบันทึกลงในไฟล์ข้อความ" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"หากเปิดใช้งาน ผู้ดูแลระบบจะสามารถเตือนผู้ดูแลระบบคนอื่นได้" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","หากเปิดใช้งาน ผู้ใช้ที่เข้าร่วมเซิร์ฟเวอร์จะเห็นข้อความในแชทหากมีคำเตือน" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"หากเปิดใช้งาน ผู้ดูแลระบบบนเซิร์ฟเวอร์จะเห็นเมื่อมีผู้เล่นเข้าร่วมซึ่งมีคำเตือน" )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		"คำสั่งแชทที่ใช้สำหรับคำสั่ง AWarn3 ค่าเริ่มต้น: !warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	"เวลา (เป็นนาที) ที่ผู้เล่นต้องเชื่อมต่อเพื่อให้มีการเตือน 1 ครั้งจึงจะสลายตัว" )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"ชื่อของเซิร์ฟเวอร์นี้ สิ่งนี้มีประโยชน์สำหรับการตั้งค่าเซิร์ฟเวอร์หลายตัว" )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	"นี่คือภาษาที่ข้อความเซิร์ฟเวอร์จะแสดง" )
AWarn.Localization:AddDefinition( language_code, "theme",						"ธีมอินเทอร์เฟซ" )
AWarn.Localization:AddDefinition( language_code, "themeselect",					"เลือกธีม" )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					"กลุ่มลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"กลุ่มที่จะตั้งค่า" )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"ดูบันทึกย่อของผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "playernotes",					"หมายเหตุผู้เล่น" )
AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		"การปรับแต่งอินเทอร์เฟซ" )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"เปิดใช้งานพื้นหลังเบลอ" )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"เลือกที่ตั้งไว้ล่วงหน้า (ไม่บังคับ)" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"ที่ตั้งไว้ล่วงหน้า" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				"เพิ่ม/แก้ไขพรีเซ็ต" )
AWarn.Localization:AddDefinition( language_code, "presetname",					"ชื่อที่ตั้งไว้ล่วงหน้า" )
AWarn.Localization:AddDefinition( language_code, "presetreason",				"เหตุผลที่ตั้งไว้ล่วงหน้า" )

--PATH addons/[admin] awarn3/lua/includes/vgui/aw3_menu_configuration_settings.lua:
return gluapack()()
--PATH addons/[misc] bodygroupr/lua/bodyman/bodyman_config.lua:
BODYMAN.HelpText = [[]]

BODYMAN.HelpText_En = [[Wybierz Grupy ciała w panelu po prawej stronie.
Przeciągnij poziomo, aby obrócić model gracza.
Przeciągnij w pionie, aby powiększyć.
Kliknij prawym przyciskiem myszy i przeciągnij, aby ustawić kamerę.]] -- edit this to your liking.

BODYMAN.HelpText_Fr = [[Sélectionnez Bodygroups dans le panneau de droite .
Faites glisser horizontalement pour faire pivoter le joueur.
Faites glisser verticalement pour zoomer.
Faites un clic droit et faites glisser pour positionner la caméra.]]

BODYMAN.HelpText_De = [[Wähle die Körper Gruppe im rechten Feld.
Ziehe Horizontal um das Model zu drehen.
Ziehe Vertikal um an das Model heran/heraus zu zoomen.
Rechts Klick und ziehen um die Kamera zu bewegen.]]

BODYMAN.ClosetViewDistance = 256 -- how far the text can be seen on the closet
BODYMAN.ClosetName = "" -- what should the closet be called?
BODYMAN.ClosetHelpText = [[]]

BODYMAN.ClosetName_En = "Closet" -- what should the closet be called?
BODYMAN.ClosetHelpText_En = [[Naciśnij [E], aby dostosować swój
wygląd.]]

BODYMAN.ClosetName_Fr = "Armoire"
BODYMAN.ClosetHelpText_Fr = [[Appuyez sur [ E ] pour personnaliser votre
apparence.]]

BODYMAN.ClosetName_De = "Kleiderschrank" -- what should the closet be called?
BODYMAN.ClosetHelpText_De = [[Drücke [E] um dein Aussehen zu verändern.]]

BODYMAN.ClosetsOnly = true -- set this to true if you think players MUST use a closet. They will not be able to access the interface normally.

BODYMAN.strings = {
	Appearance = "Appearance",
	Playermodels = "Playermodels",
	Skins = "Skins",
	Bodygroups = "Bodygroups",
	Save = "Save",
	Load = "Load",
	Remove_All = "Remove All",
	Without_Saving = "Without Saving",
	Spawn_a = "Spawn a",
	Physique = "Build",
}
BODYMAN.strings_en = {
	Appearance = "Wygląd",
	Playermodels = "Playermodels",
	Skins = "Skins",
	Bodygroups = "Grupy ciała",
	Save = "Zapisz",
	Load = "Załaduj",
	Remove_All = "Usuń wszystko",
	Without_Saving = "Bez zapisywania",
	Spawn_a = "Spawn a",
	Physique = "Buduj",
}
BODYMAN.strings_fr = {
	Appearance = "Apparence",
	Playermodels = "Joueur",
	Skins = "Peau",
	Bodygroups = "Bodygroups",
	Save = "Sauvegarder l'",
	Load = "Reapparaître",
	Remove_All = "Retirer toutes les",
	Without_Saving = "sans sauvegarder",
	Spawn_a = "Apparaître",
	Physique = "Physique",
}
BODYMAN.strings_de = {
	Appearance = "Aussehen",
	Playermodels = "Spieler Modelle",
	Skins = "Haut",
	Bodygroups = "Accessoire",
	Save = "Speichern",
	Load = "Laden",
	Remove_All = "Alle entfernen",
	Without_Saving = "Ohne zu speichern",
	Spawn_a = "Erzeugen",
	Physique = "Build",
}

BODYMAN.French = false -- Set this to true if your server speaks French/Francais.
BODYMAN.German = false -- Set this to true if your server speaks German/Deutsche.

BODYMAN.ClosetsCanBreak = false -- set this to true if you want closets to be destroyable with guns
BODYMAN.ClosetHealth = 100 -- default HP of closets. increase this if you want to take more shots to destroy them.

BODYMAN.Ranks = {}

-- !! Note !! the default required access level for changing bodygroups and skins is 10. If you wanted to make bodygroupr VIP only, then you would have to change bodyman_openmenu access level.
-- Players can only access commands when their access level meets or exceeds the command's access level.
-- e.g. admin can access all commands with access level 30 or lower.

-- Any group not found defaults to access level 10.

BODYMAN.Ranks["user"] = 10
BODYMAN.Ranks["support"] = 10
BODYMAN.Ranks["moderator"] = 10
BODYMAN.Ranks["admin"] = 29
BODYMAN.Ranks["superadmin"] = 40
BODYMAN.Ranks["Developer"] = 50

BODYMAN.PlayerAccess = {}

BODYMAN.PlayerAccess["owner_steamid"] = 50

BODYMAN.Permissions = {

	-- moderator and admin tools
	["listbodygroups"] = 20,
	["bodyman_saveclosets"] = 30,
	["bodyman_loadclosets"] = 30,
	["bodyman_removeclosets"] = 30,
	["bodyman_spawncloset"] = 20,

	-- playermodel, bodygroup and skin changes
	["bodyman_model_change"] = 9,
	["bodygroups_change"] = 9,
	["skins_change"] = 9,

	-- menus
	["bodyman_openmenu"] = 10,
	["bodyman_adminmenu"] = 30,
}


function BODYMAN:IsVip(ply)
	--edit this to fit your server
	return true
end
--PATH addons/[misc] bodygroupr/lua/bodyman/arizard_derma.lua:
local fontstandard = "Roboto"
print("Loaded arizard derma utilities for doorHandle")

-- collection of generic derma panels etc
-- a drop in solution for most of my addons, so that i can get nice UI up and running faster
-- yes, you have to ask me before using this stuff

surface.CreateFont("arizard_derma_Large", {
	font = fontstandard,
	size = 32,
	antialias = true,
	weight = 800
})
surface.CreateFont("arizard_derma_Medium", {
	font = fontstandard,
	size = 24,
	antialias = true,
	weight = 800
})

surface.CreateFont("arizard_derma_Small", {
	font = fontstandard,
	size = 20,
	antialias = true,
	weight = 800
})
surface.CreateFont("arizard_derma_Tiny", {
	font = fontstandard,
	size = 12,
	antialias = true,
	weight = 600
})

local hexvals = {
    ["0"] = 0,
    ["1"] = 1,
    ["2"] = 2,
    ["3"] = 3,
    ["4"] = 4,
    ["5"] = 5,
    ["6"] = 6,
    ["7"] = 7,
    ["8"] = 8,
    ["9"] = 9,
    ["A"] = 10,
    ["B"] = 11,
    ["C"] = 12,
    ["D"] = 13,
    ["E"] = 14,
    ["F"] = 15,
}



function Hex( hex ) -- utility functions

    hex = string.upper( hex )
    hex = string.Split( hex, "" )

    local num = 0

    for i = 1, #hex do
        local h = hex[i]
        local v = hexvals[h] or 15

        v = v * (16^(#hex-i))
        num = num + v
    end

    return num

end

local hexcache = {}

function HexColor(hex, alpha)

    if not hexcache[ hex ] then

        local temphex = hex

        if string.sub(hex, 1, 1) ~= "#" then return Color(255,255,255,255) end

        hex = string.Replace(hex, "#", "") -- remove #

        local ct = {}
        local len = string.len( hex )
        if len ~= 3 and len ~= 6 then return Color(255,255,255,255) end

        for i=1,3 do
            local l2 = len/3
            local m = 1
            ct[i] = Hex( string.sub(hex, l2*i -m, l2*i) )
        end
        --PrintTable(ct)
        local tempcol = Color( ct[1], ct[2], ct[3], 255)
        hexcache[ temphex ] = tempcol

        print("Created and cached hex color: "..temphex.." = "..tostring(ct[1]).." "..tostring(ct[2]).." "..tostring(ct[3]).." "..tostring(alpha or 255))

        tempcol.a = alpha or 255

        return tempcol
    else
        local col = hexcache[ hex ]
        col.a = alpha or 255
        return col
    end

end

local COLORS = {}
COLORS.Bad = HexColor("#e74c3c")
COLORS.BadDark = HexColor("#c0392b")
COLORS.Good = HexColor("#2ecc71")
COLORS.GoodDark = HexColor("#27ae60")
COLORS.NeutralHigh = HexColor("#ecf0f1")
COLORS.NeutralMed = HexColor("#bdc3c7")
COLORS.NeutralLow = HexColor("#95a5a6")
COLORS.NeutralDark = HexColor("#7f8c8d")
COLORS.Turq = HexColor("#e67e22")
COLORS.TurqDark = HexColor("#d35400")

function ArizardShadowText( text, font, x, y, col, ax, ay , d)
	draw.DrawText( text, font, x+d, y+d, Color(0,0,0,col.a), ax, ay )
	draw.DrawText( text, font, x, y, col, ax, ay)
end

local blur = Material("pp/blurscreen")
local function ArizardDrawBlur(panel, amount)

	local x, y = panel:LocalToScreen(0,0)
	local w, h = ScrW(), ScrH()

	surface.SetDrawColor(255,255,255)
	surface.SetMaterial(blur)

	for i = 1, 3 do -- 3 pass blur i guess?
		blur:SetFloat("$blur", (i/3) * (amount or 7))
		blur:Recompute()

		render.UpdateScreenEffectTexture()

		surface.DrawTexturedRect(x*-1,y*-1,w,h)
	end
end


local MAIN = {}

function MAIN:OnClose() end-- stub

function MAIN:Init()  
	
	self.bgalpha = 255
	self.bgcolor = COLORS.NeutralHigh
	self.fgcolor = COLORS.NeutralDark
	self.title = "Arizard Window"
   
	self.cb = vgui.Create("DButton", self)      
	function self.cb:DoClick()
		self:GetParent():OnClose()
		self:GetParent():Close()
	end
	function self.cb:PaintOver(w,h)
		draw.RoundedBox(4,0,0,w,h, COLORS.Bad)
		draw.DrawText("✖","arizard_derma_Medium",w/2,-3,COLORS.NeutralHigh, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end	

	self.inner = vgui.Create("DPanel", self)
	function self.inner:Paint() end

	self:SetSize(384,512+28+8)
	self:Center()
	self:MakePopup()
	self:ShowCloseButton( false )
	self.lblTitle:SetVisible(false)

	

end

function MAIN:PerformLayout()

	
	self.cb:SetSize(20,20)
	self.cb:SetPos(self:GetWide()-20-4, 4)

	self.inner:SetSize( self:GetWide(), self:GetTall() - 28 - 8 )
	self.inner:SetPos(0,28)


end

function MAIN:Paint(w,h)
	local inner = {x = 0,y = 28, w = self:GetWide(), h = self:GetTall() - 28 - 8}

	surface.SetDrawColor(255,255,255, 0)
	ArizardDrawBlur(self, 4)

	local bgcol = self:GetSecondaryColor()
	local fgcol = self:GetPrimaryColor()

	surface.SetDrawColor( bgcol )
	surface.DrawRect(inner.x, inner.y, inner.w, inner.h)

	surface.SetDrawColor( fgcol)
	draw.RoundedBox(4,0,0,w,16, fgcol)
	surface.DrawRect(0,8,w,20)

	draw.RoundedBox(4,0,h-8,w,8, fgcol)
	surface.DrawRect(0,h-8,w,4)

	--title
	ArizardShadowText( self.title ,"arizard_derma_Small",w/2,4,Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1)
end

function MAIN:SetPrimaryColor( col )
	self.fgcolor = table.Copy(col)
end

function MAIN:SetSecondaryColor( col )
	self.bgcolor = table.Copy(col)
end

function MAIN:GetPrimaryColor( )
	return self.fgcolor
end

function MAIN:GetSecondaryColor( )
	return self.bgcolor
end

function MAIN:SetTitle( str )
	self.title = str
end

vgui.Register("arizard_window", MAIN, "DFrame")

local BUTTN = {} -- custom buttons

function BUTTN:Init()
	self.w, self.h = 64,24
	
	self.color = {}
	self.color.up = Color(192, 57, 43)
	self.color.hover = Color(231, 76, 60)
	self.hover = false
	self.active = false

	self.font = "arizard_derma_Small"
	self.offsets = {0,-11}

	self.text = "Label"

	self.b = vgui.Create("DButton", self)

	self.b.OnCursorEntered = function()
		self.hover = true
	end

	self.b.OnCursorExited = function()
		self.hover = false
	end

	self.b.OnMousePressed = function( self2, mkey )

		self:OnMousePressed(mkey)
	end

	function self.b:Paint() end
	self.b:SetText("")
	self.disabled = false
end

function BUTTN:PerformLayout()
	self.b:SetSize(self:GetWide(),self:GetTall())
end
function BUTTN:Paint() end
function BUTTN:PaintOver(w,h)
	if self.hover == true or self.active == true then
		surface.SetDrawColor(self.color.hover)
		draw.RoundedBox(4,0,0,w,h, self.color.hover)
	elseif self.hover == false then
		surface.SetDrawColor(self.color.up)
		draw.RoundedBox(4,0,0,w,h, self.color.up)
	end
	

	ArizardShadowText(self.text,self.font,self:GetWide()/2 + self.offsets[1], self:GetTall()/2 +self.offsets[2], Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1)
end

function BUTTN:SetFont(fo)
	self.font = fo
end

function BUTTN:SetOffsets(x,y)
	self.offsets = {x,y}
end

function BUTTN:SetSelected( bool )

	self.active = bool

end

function BUTTN:SetText( text )

	self.text = text

end

function BUTTN:SetColors(upcol, hovercol)
	self.color.up = upcol
	self.color.hover = hovercol
end

function BUTTN:DoClick()

end

function BUTTN:DoRightClick()
end

function BUTTN:OnMousePressed( mkey )

	if not self.disabled then
		if mkey == MOUSE_LEFT then
			self:DoClick()
		end

		if mkey == MOUSE_RIGHT then
			self:DoRightClick()
		end
	end

end

function BUTTN:IsDown()

	if self.hover == true then
		if input.IsMouseDown( MOUSE_LEFT ) then
			return true
		end
	end

	return false
end

function BUTTN:SetDisabled( bool )
	self.disabled = bool
end


vgui.Register("arizard_button",BUTTN)


--hub multi panels

local MPANEL = {}

function MPANEL:Init()

	self.buttonoffset = 0

	self:SetSize(640,320)
	self.panels = {}
	self.buttons = {}
	self.tabs = {}

	self.color = {
		HexColor("#c0392b"),
		HexColor("#e74c3c")
	}

	self:PerformLayout()

	self.activetab = 0

	self.spacer = vgui.Create("DPanel",self)

	function self.spacer:Paint()
		surface.SetDrawColor(COLORS.NeutralLow)
		surface.DrawRect(0,0,self:GetWide(),self:GetTall())
	end
	self.spacer:SetPos(0,24)
	 -- Color(46, 204, 113)
	  -- Color(39, 174, 96)
	self.navleft = vgui.Create("arizard_button", self)
	self.navleft:SetColors( Color(39, 174, 96), Color(46, 204, 113))
	self.navleft:SetText( "<" )
	self.navleft:SetSize(24,24)

	function self.navleft:Think()
		if self:IsDown() then
			self:GetParent().buttonoffset = self:GetParent().buttonoffset + 2 * (FrameTime()/(1/100))
			self:GetParent():PerformLayout()
		end
	end

	self.navright = vgui.Create("arizard_button", self)
	self.navright:SetColors( Color(39, 174, 96), Color(46, 204, 113))
	self.navright:SetText( ">" )
	self.navright:SetSize(24,24)

	function self.navright:Think()
		if self:IsDown() then
			print("moving right")
			self:GetParent().buttonoffset = self:GetParent().buttonoffset - 2 * (FrameTime()/(1/100))
			self:GetParent():PerformLayout()
		end
	end

	self.navleft:SetZPos(99)
	self.navright:SetZPos(98)


	self.arrowsvisible = true
end

function MPANEL:ArrowsVisible( bool )

	self.navleft:SetVisible( bool )
	self.navright:SetVisible( bool )

end

function MPANEL:SetTab( idx )

	for i = 1, #self.tabs do
		
		self.buttons[self.tabs[i]]:SetSelected( false )
		self.panels[self.tabs[i]]:SetVisible( false )

	end

	self.buttons[self.tabs[idx]]:SetSelected( true )
	self.panels[self.tabs[idx]]:SetVisible( true )

end

function MPANEL:SetTabDisabled( idx, bool )

	self.buttons[self.tabs[idx]]:SetDisabled( bool )

end

function MPANEL:SetColors(c1, c2)
	self.color[1] = c1
	self.color[2] = c2

end

function MPANEL:AddTab(str_name)

	self.buttons[str_name] = vgui.Create("arizard_button", self)
	self.buttons[str_name]:SetSize(92,24)
	self.buttons[str_name]:SetText(str_name)
	self.buttons[str_name]:SetColors(COLORS.GoodDark, COLORS.Good)

	self.tabs[#self.tabs+1] = str_name

	self.activetab = #self.tabs
	self.buttons[str_name].idx = #self.tabs

	

	local temp = self.buttons[str_name]

	function temp:DoClick()
		local parent = self:GetParent()
		parent:SetTab( self.idx )
	end


	temp.PaintOver = function(self, w, h)
		if self.hover == true or self.active == true then
			surface.SetDrawColor(self.color.hover)
			draw.RoundedBox(4,0,0,self:GetWide(),12, self.color.hover)
		elseif self.hover == false then
			surface.SetDrawColor(self.color.up)
			draw.RoundedBox(4,0,0,self:GetWide(),12,self.color.up)
		end

		surface.DrawRect(0,8,self:GetWide(),self:GetTall()-8)

		ArizardShadowText(self.text,self.font,self:GetWide()/2 + self.offsets[1], self:GetTall()/2 +self.offsets[2], Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1)
	end

	self.panels[str_name] = vgui.Create("DPanel", self)
	self.panels[str_name]:SetSize(self:GetWide(),self:GetTall()-28)
	self.panels[str_name]:SetPos(0,28)
	self.panels[str_name]:SetVisible(false)

	self.panels[str_name].Paint = function(self, w, h)
		surface.SetDrawColor(Color(225,225,225))
		surface.DrawRect(0,0,w, h) -- meh
	end

	self:PerformLayout()

	self:SetTab( self.activetab )

	return self.panels[str_name]

end

function MPANEL:PerformLayout()

	
	local maxoff = -((#self.tabs * 92) - self:GetWide()) -24*2 -8
	if self.buttonoffset > 8 then self.buttonoffset = 8 end
	if self.buttonoffset < maxoff then self.buttonoffset = maxoff end

	if maxoff > 0 then self.buttonoffset = 8 end
	
	if self.navright then
		self.navright:SetPos(self:GetWide() - 24)
	end

	if self.spacer then
		self.spacer:SetSize(self:GetWide(), 4)
	end
	for i = 1,#self.tabs do
		self.buttons[self.tabs[i]]:SetPos(24+(i-1)*92+self.buttonoffset,0)
		self.buttons[self.tabs[i]].OriginalX = 8+(i-1)*92
		self.panels[self.tabs[i]]:SetSize(self:GetWide(),self:GetTall()-28)

	end

end
vgui.Register("arizard_multipanel", MPANEL)

concommand.Add("arizard_test_derma", function()
	vgui.Create("arizard_window")
end)
--PATH lua/autorun/boss_health.lua:
return gluapack()()
--PATH lua/autorun/bx_npc.lua:
local NPC = {
	Name = "HD Commando Droid PVT (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD CIS Commando Droids",
	Model = "models/bx/npc_droid_cis_bx_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_droid_cis_bx_f", NPC )


local NPC = {
	Name = "HD Commando Droid PVT (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD CIS Commando Droids",
	Model = "models/bx/npc_droid_cis_bx_h.mdl",
}
list.Set( "NPC", "npc_droid_cis_bx_h", NPC )

local NPC = {
	Name = "HD Commando Droid Captain (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD CIS Commando Droids",
	Model = "models/bx_captain/npc_droid_cis_bx_cpt_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_droid_cis_bx_cpt_f", NPC )


local NPC = {
	Name = "HD Commando Droid Captain (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD CIS Commando Droids",
	Model = "models/bx_captain/npc_droid_cis_bx_cpt_h.mdl",
}
list.Set( "NPC", "npc_droid_cis_bx_cpt_h", NPC )

local NPC = {
	Name = "HD Senate Commando Droid (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD CIS Commando Droids",
	Model = "models/bx_senate/npc_droid_cis_bx_senate_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_droid_cis_bx_senate_f", NPC )


local NPC = {
	Name = "HD Senate Commando Droid (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD CIS Commando Droids",
	Model = "models/bx_senate/npc_droid_cis_bx_senate_h.mdl",
}
list.Set( "NPC", "npc_droid_cis_bx_senate_h", NPC )

local NPC = {
	Name = "HD Citadel Commando Droid (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD CIS Commando Droids",
	Model = "models/bx_citadel/npc_droid_cis_bx_citadel_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_droid_cis_bx_citadel_f", NPC )


local NPC = {
	Name = "HD Citadel Commando Droid (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD CIS Commando Droids",
	Model = "models/bx_citadel/npc_droid_cis_bx_citadel_h.mdl",
}
list.Set( "NPC", "npc_droid_cis_bx_citadel_h", NPC )

local NPC = {
	Name = "HD Training Commando Droid (Friendly)",
	Class = "npc_citizen",
	Category = "CGI HD CIS Commando Droids",
	Model = "models/bx_training/npc_droid_cis_bx_training_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_droid_cis_bx_training_f", NPC )


local NPC = {
	Name = "HD Training Commando Droid (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI HD CIS Commando Droids",
	Model = "models/bx_training/npc_droid_cis_bx_training_h.mdl",
}
list.Set( "NPC", "npc_droid_cis_bx_training_h", NPC )






--PATH lua/autorun/cadet_pm.lua:
player_manager.AddValidModel( "pm_training_cadet_domino", "models/cadet_green/pm_training_cadet_domino.mdl" )
player_manager.AddValidModel( "pm_training_cadet_bravo", "models/cadet_red/pm_training_cadet_bravo.mdl" )
player_manager.AddValidModel( "pm_training_cadet_zeta", "models/cadet_orange/pm_training_cadet_zeta.mdl" )
player_manager.AddValidModel( "pm_training_cadet_alpha", "models/cadet_blue/pm_training_cadet_alpha.mdl" )

--PATH addons/[miecze] mexicano_drzewko/lua/autorun/cl_drzewo.lua:
if not CLIENT then return end


surface.CreateFont( "Drzewo_font_5", {
	font = "Bahnschrift", 
	extended = false,
	size = ScreenScale(5),
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})
surface.CreateFont( "Drzewo_font_13", {
	font = "Bahnschrift", 
	extended = false,
	size = ScreenScale(13),
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})
if CLIENT then return end
function drzewoderma()
    net.Start("Drzewko_RequestTable")
    net.SendToServer()

    local playerboughtstuff = {
        jedi_punkty = 0,
        kupione_upgradey = {}
    }
    net.Receive("Drzewko_SendTable", function()
        playerboughtstuff = net.ReadTable()
        MX_LSCS.NewNET(playerboughtstuff)
    end)
   -- print("table playerbought: ")
   -- PrintTable(playerboughtstuff)

    local frame = vgui.Create("DFrame")
    frame:SetSize(ScrW(), ScrH())
    frame:SetTitle("")
    frame:ShowCloseButton(false)
    frame:SetDraggable(false)
    frame:MakePopup()
    frame.Paint = function(self, w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(30, 30, 30, 255))
    end

    local offsetX, offsetY = 0, 0
    local targetX, targetY = 0, 0 
    local scrollSpeed = 5 


    local scrollPanel = vgui.Create("Panel", frame)
    scrollPanel:SetSize(frame:GetWide(), frame:GetTall())
    scrollPanel:SetPos(ScreenScale(65), 0)

    local elements = {}


    local function ClearElements()
        for _, el in ipairs(elements) do
            if IsValid(el.obj) then
                el.obj:Remove()
            end
        end
        table.Empty(elements)
    end

    local function GenerateButtons(categoryName)
        ClearElements()
    
        local moces = {}
        for _, moc in ipairs(MX_LSCS.Moce) do
            if moc.category == categoryName then
                moces[moc.subcategory] = moces[moc.subcategory] or {}
                table.insert(moces[moc.subcategory], moc)
            end
        end
    
        local startX = ScreenScale(10)
        local ySpacing = ScreenScale(45)
        local subcategoryButtons = {}
    
        for subcategory, subMoces in pairs(moces) do
            local startY = ScreenScale(10)
    
            local subLabel = vgui.Create("DLabel", scrollPanel)
            subLabel:SetText("")
            subLabel:SetSize(ScreenScale(40), ScreenScale(8))
            subLabel:SetTextColor(Color(255, 255, 255))
            subLabel:SetPos(startX + offsetX, startY + offsetY)
            table.insert(elements, { obj = subLabel, x = startX, y = startY })
            subLabel.Paint = function(me, w, h)
                draw.DrawText(subcategory, "Drzewo_font_5", w * 0.5, 0, color_white, TEXT_ALIGN_CENTER)
            end

            startY = startY + ScreenScale(6)
    
            local buttons = {}
    
            for i, moc in ipairs(subMoces) do
                local btn = vgui.Create("DButton", scrollPanel)
                btn:SetText("")
                btn:SetSize(ScreenScale(40), ScreenScale(40))
                btn:SetTextColor(Color(0, 0, 0))
                btn:SetPos(startX + offsetX, startY + (i - 1) * ySpacing + offsetY)
                btn.Paint = function(self, w, h)
                    if table.HasValue(playerboughtstuff.kupione_upgradey, moc.sciezka) then
                        draw.RoundedBox(4, 0, 0, w, h, Color(112, 112, 112))
                    else
                        draw.RoundedBox(4, 0, 0, w, h, Color(200, 200, 200))
                    end
                    surface.SetFont("Drzewo_font_5")
                    local texthm = moc.name
                    local textw, texth = surface.GetTextSize(texthm) 
                    surface.SetTextColor(255, 255, 255)
                    surface.SetTextPos((w - textw) / 2, (h - texth) / 2 - ScreenScale(3)) 
                    surface.DrawText(texthm)
                    local text2 = moc.cost.. " Punkty/ów"
                    local textw2, texth2 = surface.GetTextSize(text2) 
                    surface.SetTextColor(255, 255, 255)
                    surface.SetTextPos((w - textw2) / 2, (h - texth2) / 2 + ScreenScale(3)) 
                    surface.DrawText(text2)
                end
                btn.DoClick = function()
                    if table.HasValue(playerboughtstuff.kupione_upgradey, moc.sciezka) then
                        return
                    end
                    

                    if i > 1 then
                        local prevMoc = subMoces[i - 1]
                        if not table.HasValue(playerboughtstuff.kupione_upgradey, prevMoc.sciezka) then
                            LocalPlayer():ChatPrint("Musisz najpierw kupić: " .. prevMoc.name)
                            return
                        end
                    end
                    if LocalPlayer():GetNWInt("jedi_punkty") >= moc.cost then
                        table.insert(playerboughtstuff.kupione_upgradey,moc.sciezka)
                    end
                    net.Start("DrzewoKupSkill")
                    net.WriteString(moc.sciezka)
                    net.SendToServer()    
                    
                end
                table.insert(elements, { obj = btn, x = startX, y = startY + (i - 1) * ySpacing })
                table.insert(buttons, btn)
            end
    
            subcategoryButtons[subcategory] = buttons 
            startX = startX + ScreenScale(45)
        end
    

        scrollPanel.PaintOver = function(_, w, h)
            for _, buttons in pairs(subcategoryButtons) do
                for i = 1, #buttons - 1 do
                    local btn1 = buttons[i]
                    local btn2 = buttons[i + 1]
                    if IsValid(btn1) and IsValid(btn2) then
                        surface.SetDrawColor(255, 255, 255, 150)
                        surface.DrawLine(
                            btn1:GetPos() + btn1:GetWide() / 2, btn1:GetY() + btn1:GetTall(),
                            btn2:GetPos() + btn2:GetWide() / 2, btn2:GetY()
                        )
                    end
                end
            end
        end
    end
    
    local buttonY = ScreenScale(10)
    for _, category in ipairs(MX_LSCS.Drzewko) do
        local button = vgui.Create("DButton", frame)
        button:SetText("")
        button:SetPos(ScreenScale(5), buttonY)
        button:SetSize(ScreenScale(60), ScreenScale(20))
        button:SetTextColor(Color(255, 255, 255))
        button.Paint = function(self, w, h)
            draw.RoundedBox(4, 0, 0, w, h, Color(100, 100, 255))
            surface.SetFont("Drzewo_font_13")
            local texthm = category.name
            local textw, texth = surface.GetTextSize(texthm) 
            surface.SetTextColor(255, 255, 255)
            surface.SetTextPos((w - textw) / 2, (h - texth) / 2) 
            surface.DrawText(texthm)
        end

        button.DoClick = function()
            GenerateButtons(category.name)
        end

        buttonY = buttonY + ScreenScale(25)
    end

    frame.Think = function()
        if input.IsKeyDown(KEY_LEFT) then
            targetX = targetX + ScreenScale(1)
        elseif input.IsKeyDown(KEY_RIGHT) then
            targetX = targetX - ScreenScale(1)
        end

        if input.IsKeyDown(KEY_UP) then
            targetY = targetY + ScreenScale(1)
        elseif input.IsKeyDown(KEY_DOWN) then
            targetY = targetY - ScreenScale(1)
        end

        offsetX = Lerp(scrollSpeed * FrameTime(), offsetX, targetX)
        offsetY = Lerp(scrollSpeed * FrameTime(), offsetY, targetY)

        for _, el in ipairs(elements) do
            el.obj:SetPos(el.x + offsetX, el.y + offsetY)
        end
    end


    local colorr = math.random(0,255)
    local colorg = math.random(0,255)
    local colorb = math.random(0,255)
    local xpButton = vgui.Create("DButton", frame)
    xpButton:SetSize(ScreenScale(84), ScreenScale(15))
    xpButton:SetPos(frame:GetWide() - ScreenScale(87),frame:GetTall() - ScreenScale(18))
    xpButton:SetText("")
    xpButton:SetTextColor(Color(255, 255, 255))
    xpButton.Paint = function(self, w, h)
        draw.RoundedBox(8, 0, 0, w, h, Color(colorr, colorg, colorb, 255))
        draw.SimpleText("Punkty Dośw.: "..LocalPlayer():GetNWInt("jedi_punkty"), "DermaLarge", w / 2, h / 2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    xpButton.DoClick = function()
        colorr = math.random(0,255)
        colorg = math.random(0,255)
        colorb = math.random(0,255)
    end

    local resetxpbutton = vgui.Create("DButton", frame)
    resetxpbutton:SetSize(ScreenScale(84), ScreenScale(15))
    resetxpbutton:SetPos(frame:GetWide() - ScreenScale(87),frame:GetTall() - ScreenScale(38))
    resetxpbutton:SetText("")
    resetxpbutton:SetTextColor(Color(255, 255, 255))
    resetxpbutton.Paint = function(self, w, h)
        draw.RoundedBox(8, 0, 0, w, h, Color(100, 100, 255))
        draw.SimpleText("Refund Punktów", "DermaLarge", w / 2, h / 2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    resetxpbutton.DoClick = function()
        if !table.IsEmpty(playerboughtstuff.kupione_upgradey) then
            net.Start("DrzewoResetPunktow")
            net.SendToServer()
            frame:Close()
        end
    end
    
    local closeButton = vgui.Create("DButton", frame)
    closeButton:SetSize(ScreenScale(15), ScreenScale(15))
    closeButton:SetPos(frame:GetWide() - ScreenScale(18), ScreenScale(3))
    closeButton:SetText("")
    closeButton:SetTextColor(Color(255, 255, 255))
    closeButton.Paint = function(self, w, h)
        draw.RoundedBox(8, 0, 0, w, h, Color(200, 50, 50, 255))
        if self:IsHovered() then
            draw.RoundedBox(8, 0, 0, w, h, Color(255, 70, 70, 255))
        end
        draw.SimpleText("X", "DermaLarge", w / 2, h / 2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    closeButton.DoClick = function()
        frame:Close()
    end
end



list.Set( "DesktopWindows", "LSCSDrzewko", {
	title = "[LSCS] Drzewko",
	icon = "lscs/ui/icon64.png",
	init = function( icon, window )
        local teamData = RPExtraTeams[LocalPlayer():Team()]
        if teamData.category ~= "Jedi" then 
            LocalPlayer():ChatPrint("Tylko dla Jedi!") 
            return 
        end
		
        drzewoderma()
	end
} )

concommand.Add( "drzewko_openmenu", function( ply, cmd, args )         
    local teamData = RPExtraTeams[ply:Team()]
    if teamData.category ~= "Jedi" then 
        ply:ChatPrint("Tylko dla Jedi!") 
        return 
    end 
    drzewoderma() 
end )
--PATH lua/autorun/cl_falleffect.lua:
// Falling & Roll Effect for Climb SWEP2
CreateClientConVar("climbswep2_windsound", 1, true, false)
CreateClientConVar("climbswep2_falleffect_allweps", 0, true, false)
local PrevCurT = 0
local CurAngles = nil
local Rot = 0
local Random
local Snd
local Snd2
hook.Add("CreateMove", "ClimbFall", function(cmd)

    local Ply = LocalPlayer()
	if !Snd then

        Snd = CreateSound(Ply, Sound("player/heartbeat1.wav"))
        Snd:Play()
        Snd:ChangeVolume(0, 0)
        Snd:ChangePitch(100, 0)

        Snd2 = CreateSound(Ply, Sound("ambient/ambience/Wind_Light02_loop.wav"))
        Snd2:Play()
        Snd2:ChangeVolume(0, 0)

    end
    if !IsValid(Ply) or !IsValid(Ply:GetActiveWeapon()) then return
    elseif Ply:GetVelocity().z > -900 or (GetConVarNumber("climbswep2_falleffect_allweps") == 0 and Ply:GetActiveWeapon():GetClass() != "climb_swep2") or !Ply:Alive() or Ply:GetMoveType() != MOVETYPE_WALK then

        if PrevCurT > 0 then

            cmd:SetViewAngles(Angle(CurAngles.p, CurAngles.y, 0))
            CurAngles = nil
            Snd:ChangeVolume(0, 0)
            Snd:ChangePitch(100, 0)
            Snd2:ChangeVolume(0, 0)
			hook.Remove("RenderScreenspaceEffects", "ClimbFallBlur")
			PrevCurT = 0

        end		
        return

    end
    if PrevCurT == 0 then

        PrevCurT = CurTime()
        local function DrawEffect()
            --DrawMotionBlur(0.1, Time/5, 0.01)
            local Time = CurTime() - PrevCurT
            local Colour = {}
            Colour[ "$pp_colour_addr" ] = 0
            Colour[ "$pp_colour_addg" ] = 0
            Colour[ "$pp_colour_addb" ] = 0
            Colour[ "$pp_colour_brightness" ] = 0
            Colour[ "$pp_colour_contrast" ] = (1 - Time/7.5)
            Colour[ "$pp_colour_colour" ] = (1 - Time/7.5)
            Colour[ "$pp_colour_mulr" ] = 0
            Colour[ "$pp_colour_mulg" ] = 0
            Colour[ "$pp_colour_mulb" ] = 0
            DrawColorModify(Colour)
            DrawMotionBlur(math.Clamp(0.75-Time/100, 0.25, 1), math.Clamp(Time/10, 0, 0.75), 0.05)

        end
        hook.Add("RenderScreenspaceEffects", "ClimbFallBlur", DrawEffect)

    end

    if !IsValid(CurAngles) then CurAngles = cmd:GetViewAngles(); end
	

	
    local Time = (CurTime() - PrevCurT) * (8 + (CurTime() - PrevCurT) * 2)
    if Time/25 < 1 then Snd:ChangeVolume(math.Clamp(Time/25, 0, 1), 0) end
    if Time < 101 then Snd:ChangePitch(100 + Time, 0); if GetConVarNumber("climbswep2_windsound") == 1 then Snd2:ChangeVolume(Time/100, 0) else Snd2:ChangeVolume(0, 0) end end

    CurAngles.p = math.Round(CurAngles.p) < 75 and math.Round(CurAngles.p) + 0.5 or math.Round(CurAngles.p) - 0.5

    cmd:SetViewAngles(Angle(CurAngles.p, CurAngles.y + math.sin(Time) * 1.25, 0))

end)
--PATH lua/autorun/coolzkillchains.lua:
-- this was initially a part of coolhitmarkers 
-- so in order to make it work without them i need to crop out hooks & nets from it here (with removal of some useless things)

local usefallback = false
if !CoolHitmarkersInstalled then usefallback = true end
CoolKillchainsInstalled = true


local hmoverride = usefallback and CreateConVar("profiteers_override_enabled", "0", flags, "Override Profiteers UI settings.", 0, 1) or GetConVar("profiteers_override_enabled")
local skullssv = usefallback and CreateConVar("profiteers_override_skulls", "1", flags, "Override Show how many enemys youve killed. very cruel.", 0, 1) or GetConVar("profiteers_override_skulls")
local skullscalesv = CreateConVar("profiteers_override_skull_scale", "1", flags, "Override scale of skylls", 0.25, 2.5)
local skullglobaloffsetsv = CreateConVar("profiteers_override_offset", "0.7", flags, "Override offset of skylls", 0.05, 0.95)
local skullmaxxsv = CreateConVar("profiteers_override_max", "0", flags, "Override max skulls, zero means no more than half of screen width", 0, 50)

if SERVER then
    if usefallback then
        util.AddNetworkString("profiteers_hitmark_FALLBACK")

        local npcheadshotted = false -- fuck you garry

        local function fallbackhitmarker(ent, dmginfo, took)
            local attacker, inflictor = dmginfo:GetAttacker(), dmginfo:GetInflictor()
            if attacker:IsVehicle() and IsValid(attacker:GetDriver()) then attacker = attacker:GetDriver() end
            local attply, vicply = attacker:IsPlayer(), ent:IsPlayer()
            if !attply or !took or dmginfo:GetDamage() <= 0 then return end
            if inflictor == ent or attacker == ent then return end
            local vichp = ent:Health()
            -- local ct = CurTime()
            -- if ent.phm_lastHealth and ent.phm_lastHealth == vichp and (!took and (vichp <= 0 or attacker.phm_lastMarker and attacker.phm_lastMarker > ct) or dmginfo:GetDamage() == 0 or took) then return end
            local vicnpc = ent:IsNextBot() or ent:IsNPC()
    
            if IsValid(ent) and IsValid(attacker) and attply and (vicply or vicnpc) then
                local dmgtype = dmginfo:GetDamageType()
                local hs = false
                local killtype = 0
                if (ent.LastHitGroup and ent:LastHitGroup() == HITGROUP_HEAD or npcheadshotted) then
                    hs = true
                    if ent.SetLastHitGroup then ent:SetLastHitGroup(HITGROUP_GENERIC) end
                end
                if (vichp <= 0) then
                    if inflictor == attacker and dmginfo:GetDamageCustom() == 67 then killtype = 1
                    elseif inflictor:IsWeapon() and bit.band(dmgtype, bit.bor(DMG_CLUB, DMG_SLASH)) != 0 then killtype = 2
                    elseif bit.band(dmgtype, DMG_BLAST) != 0 then killtype = 3
                    elseif inflictor:IsVehicle() and bit.band(dmgtype, bit.bor(DMG_VEHICLE, DMG_CRUSH)) != 0 then killtype = 4
                    elseif bit.band(dmgtype, DMG_DISSOLVE) != 0 then killtype = 5
                    elseif bit.band(dmgtype, DMG_CRUSH) != 0 then killtype = 6
                    elseif bit.band(dmgtype, DMG_BURN+DMG_DIRECT) != 0 then killtype = 7
                    end

                    net.Start("profiteers_hitmark_FALLBACK")
                    net.WriteBool(hs) -- Headshot or not
                    net.WriteUInt(killtype, 3) -- Type of kill damage
                    net.Send(attacker)
                end
                
                npcheadshotted = false
            end
        end
    
        -- fuck you garry
        hook.Add("ScaleNPCDamage", "profiteers_hitmarkers_npcheadshots", function(ent, hitgroup, dmginfo)
            npcheadshotted = IsValid(ent) and IsValid(dmginfo:GetAttacker()) and dmginfo:GetAttacker():IsPlayer() and hitgroup == HITGROUP_HEAD
        end)

        hook.Add("PostEntityTakeDamage", "profiteers_hitmarkers", fallbackhitmarker)
    end
else
    local skulls = usefallback and CreateClientConVar("profiteers_skulls", "1", true, true, "Show how many enemys youve killed. very cruel.", 0, 1) or GetConVar("profiteers_skulls")
    local skullscale = CreateClientConVar("profiteers_skull_scale", "1", true, true, "scale of skylls", 0.25, 2.5)
    local skullglobaloffset = CreateClientConVar("profiteers_skull_offset", "0.7", true, true, "offset of skylls", 0.05, 0.95)
    local skullmaxx = CreateClientConVar("profiteers_skull_max", "0", true, true, "max skulls, zero means no more than half of screen width", 0, 50)

    
    hook.Add("PopulateToolMenu", "profiteers_hitmark_options_killchains", function()
        spawnmenu.AddToolMenuOption("Utilities", "Cool™ Combat", "profiteers_hitmarker_kc", "Killchains", "", "", function(pan)
            pan:SetName("Cool™ Killchains")
            local cl, sv = vgui.Create("DForm"), vgui.Create("DForm")
            pan:AddItem(cl)
            pan:AddItem(sv)
            cl:SetName("Client")
            sv:SetName("Server Overrides")
            cl:ControlHelp("\nKillstreak skulls")
            cl:CheckBox("Show killstreak skulls under crosshair", "profiteers_skulls")
            cl:NumSlider("Skulls scale", "profiteers_skull_scale", 0.25, 2.5, 3)
            cl:NumSlider("Skulls vertical offset", "profiteers_skull_offset", 0.05, 0.95, 2)
            cl:NumSlider("Max streak on screen", "profiteers_skull_max", 0, 50, 0)
            cl:Help("0 means autocalculated - won't take more than half of screen width")

            sv:CheckBox("Enforce server killchain settings for all players", "profiteers_override_enabled")
            sv:ControlHelp("\nKillstreak skulls")
            sv:CheckBox("Show killstreak skulls under crosshair", "profiteers_override_skulls")
            sv:NumSlider("Skulls scale", "profiteers_override_skull_scale", 0.25, 2.5, 3)
            sv:NumSlider("Skulls vertical offset", "profiteers_override_offset", 0.05, 0.95, 2)
            sv:NumSlider("Max streak on screen", "profiteers_override_max", 0, 50, 0)
            sv:Help("0 means autocalculated - won't take more than half of screen width")

            if usefallback then
                pan:ControlHelp("\nBest used with:")
                local btn = pan:Button("Cool™ Hitmarkers <3")
                btn.DoClick = function()
                    gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=2987119816")
                end
            end
        end)
    end)

    local hmauth = 0
    local lasthmhead = false

    -- hush
    local function DoSize2(size, scale)
        return size * (ScrW() / 640) * ((hmauth and skullscalesv or skullscale):GetFloat())
    end
    

    local skulltable = {}
    local skullnextdelete = 0
    local skullsmoothcount = 0
    local skullsize = 10
    local skulldecaytimeconstant = 4
    local skulldecaytime = 4 -- +0.33s per kill in a streak

    local matskull = Material("profiteers/skull.png", "noclamp smooth")
    local matskullhs = Material("profiteers/skullhs.png", "noclamp smooth")
    local matexplosion = Material("profiteers/explosion.png", "noclamp smooth")
    local matmelee = Material("profiteers/knife.png", "noclamp smooth")
    local matkick = Material("profiteers/kick.png", "noclamp smooth")
    local matkick2 = Material("profiteers/kick2.png", "noclamp smooth")
    local matcar = Material("profiteers/car.png", "noclamp smooth")
    local matball = Material("profiteers/dissolve.png", "noclamp smooth")
    local matprop = Material("profiteers/propkill.png", "noclamp smooth")
    local matfire = Material("profiteers/fire.png", "noclamp smooth")

    hook.Add("HUDPaint", "profiteers_hitmark_paint_killchains", function()
        if !(hmauth and skullssv:GetBool() or skulls:GetBool()) then return end

        -- local lp = LocalPlayer()
        local ct = CurTime()
        local scrw, scrh = ScrW(), ScrH()
        
        if #skulltable > 0 then
            skullsmoothcount = math.max(1, math.Round(Lerp(FrameTime()*5, skullsmoothcount, #skulltable), 5))
            local wholeoffset = skullsmoothcount * DoSize2(skullsize + 2) * 0.5
            local skullsdecay = math.Clamp((skullnextdelete - ct) * skulldecaytime * 0.5, 0, 1)
            local maxoverride = (hmauth and skullmaxxsv or skullmaxx):GetInt() or 0
            local maxskulls = (maxoverride == 0) and (math.ceil((scrw * 0.5) / (DoSize2(skullsize + 2)))) or maxoverride
            -- local maxskulls = 5
            local verticaloffset = (hmauth and skullglobaloffsetsv or skullglobaloffset):GetFloat() or 0.7
            
            -- if #skulltable == maxskulls and skulltable[1].fadein then skulltable[1].fadein = false skulltable[1].time = ct + 0.33 end
            if #skulltable > maxskulls then
                skullsmoothcount = skullsmoothcount - 1 -- for noticable new skull
                table.remove(skulltable, 1)
            end
            
            for k, v in pairs(skulltable) do -- skulls
                local offsett = k * DoSize2(skullsize + 2)
                local fadein = math.ease.InQuart(math.min((1 - (v.time - ct) / skulldecaytime)*30, 1))
                local scalein = 1 + (1 - fadein) * 0.75
                
                surface.SetDrawColor(255, 255, 255, 200 * skullsdecay * fadein)
                surface.SetMaterial(matskull)
                if v.hs then
                    surface.SetDrawColor(255, 58, 58, 200 * skullsdecay * fadein)
                    surface.SetMaterial(matskullhs)
                elseif v.exploded then
                    surface.SetDrawColor(255, 137, 59, 200 * skullsdecay * fadein)
                    surface.SetMaterial(matexplosion)
                elseif v.burned then
                    surface.SetDrawColor(255, 137, 59, 200 * skullsdecay * fadein)
                    surface.SetMaterial(matfire)
                end

                if v.roadkill then
                    surface.SetMaterial(matcar)
                elseif v.dissolve then
                    surface.SetMaterial(matball)
                elseif v.propkill then
                    surface.SetMaterial(matprop)
                elseif v.kicked then
                    surface.SetMaterial(matkick2)
                elseif v.meleed then
                    surface.SetDrawColor(255, 58, 58, 200 * skullsdecay * fadein)
                    surface.SetMaterial(matmelee)
                end
                
                local localskullsize = skullsize * scalein
                surface.DrawTexturedRect(scrw * 0.5 - DoSize2(localskullsize * 0.5 + (localskullsize) * 0.5 + 1) + DoSize2((scalein - 1) * 4) + offsett - wholeoffset, scrh * verticaloffset - DoSize2(localskullsize * 0.5), DoSize2(localskullsize), DoSize2(localskullsize))

                if skullnextdelete < ct then
                    skulltable = {}
                    skullsmoothcount = 0
                    skulldecaytime = skulldecaytimeconstant
                    break
                end
            end
        end
    end)

    function CoolKillchainFunction(head, killtype, sv)
        lasthmhead = head -- two params from below

        local ct = CurTime()
        skulldecaytime = skulldecaytimeconstant + #skulltable * 0.33
        skullnextdelete = ct + skulldecaytime

        table.insert(skulltable, {
            time = ct + skulldecaytime,
            hs = lasthmhead,
            kicked = killtype == 1,
            meleed = killtype == 2,
            exploded = killtype == 3,
            roadkill = killtype == 4,
            dissolve = killtype == 5,
            propkill = killtype == 6,
            burned = killtype == 7,
            fadein = true,
        })

        hmauth = sv
    end

    if usefallback then
        local function fallbackhitmarker()
            local sv = hmoverride:GetBool()
            if !(sv and skullssv:GetBool() or skulls:GetBool()) then return end
            local head = net.ReadBool()
            local killtype = net.ReadUInt(3)

            CoolKillchainFunction(head, killtype, sv)
            
        end

        net.Receive("profiteers_hitmark_FALLBACK", fallbackhitmarker)
    end
end
--PATH lua/autorun/dao.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/core/cl_core.lua:
return gluapack()()
--PATH lua/autorun/dw.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-config-master/lua/gmodadminsuite_config.lua:
--[[

	   ______                    _____       __          _      _____       _ __     
	  / ____/___ ___  ____  ____/ /   | ____/ /___ ___  (_)___ / ___/__  __(_) /____ 
	 / / __/ __ `__ \/ __ \/ __  / /| |/ __  / __ `__ \/ / __ \\__ \/ / / / / __/ _ \
	/ /_/ / / / / / / /_/ / /_/ / ___ / /_/ / / / / / / / / / /__/ / /_/ / / /_/  __/
	\____/_/ /_/ /_/\____/\__,_/_/  |_\__,_/_/ /_/ /_/_/_/ /_/____/\__,_/_/\__/\___/ 
	                                                                                 
	Welcome to the main config.
	You may have noticed that it's a bit small - but no worries; this is because most configuration
	for GmodAdminSuite is in the menu itself.

]]

-- What chat command should open the GmodAdminSuite main menu?
GAS.Config.ChatCommand = "!gas"

-- In seconds, how long until an inactive player is marked AFK?
GAS.Config.AFKTime = 300

-- Should GmodAdminSuite content (sounds, materials, etc.) be downloaded by users through the Workshop when they join the server?
GAS.Config.WorkshopDL = true

-- Should GmodAdminSuite content be downloaded by users directly from the server when they join? (this is unnecessary if you are using WorkshopDL)
GAS.Config.ServerDL = false

-- Do not delete the following line; your config will break.
return true

--PATH lua/gmodadminsuite/thirdparty/pon.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/fpsbooster/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "FPS Booster",

		--####################### UI PHRASES #######################--

		fps_booster          = "Booster de FPS",
		never_show_again     = "Ne plus afficher",
		never_show_again_tip = "Vous perdrez les avantages de ce menu ! Tapez \"gmodadminsuite fpsbooster\" dans votre console pour ouvrir ce menu dans le futur.",

		--####################### SETTING PHRASES #######################--

		show_fps                 = "Afficher FPS",
		multicore_rendering      = "Afficher le rendu Multi-Coeur",
		multicore_rendering_help = "C'est une fonctionnalité expérimentale de GMod qui permet d'augmenter les FPS en faisant un rendu des images sur plusieurs coeurs de votre processeur.",
		hardware_acceleration    = "Activer l'Accélération Matérielle",
		shadows                  = "Désactiver les Ombres",
		disable_skybox           = "Désactiver Skybox",
		sprays                   = "Désactiver les Sprays des Joueurs",
		gibs                     = "Désactiver Gibs",
		gibs_help                = "\"Gibs\" Sont des particules qui volent hors des cadavres et des ragdolls.",

} end }
--PATH lua/gmodadminsuite/sh_offline_player_data.lua:
return gluapack()()
--PATH lua/gmodadminsuite/sh_afk.lua:
GAS.AFK = {}
GAS.AFK.AFKTime = GAS.Config.AFKTime

if (SERVER) then

	GAS_AFK_PlayerPositions = GAS_AFK_PlayerPositions or {}
	GAS_AFK_PlayerLastMoved = GAS_AFK_PlayerLastMoved or {}

	function GAS.AFK:SetAFK(ply, is_afk, pos_signature)
		if (is_afk) then
			if (not ply.GAS_PlayerAFK) then
				ply.GAS_PlayerAFK = true
				ply:SetNWBool("GAS_PlayerAFK", true)
				hook.Run("GAS:AFK", ply)
			end
		else
			GAS_AFK_PlayerLastMoved[ply] = os.time()
			GAS_AFK_PlayerPositions[ply] = pos_signature
			if (ply.GAS_PlayerAFK) then
				ply.GAS_PlayerAFK = false
				ply:SetNWBool("GAS_PlayerAFK", false)
				hook.Run("GAS:UnAFK", ply)
			end
		end
	end

	GAS:timer("afk:update_player_positions", 5, 0, function()
		for _,ply in ipairs(player.GetHumans()) do
			local pos = ply:GetPos()
			local pos_signature = math.Round(pos.x) + math.Round(pos.y) + math.Round(pos.z)
			if (GAS_AFK_PlayerLastMoved[ply]) then
				if (pos_signature ~= GAS_AFK_PlayerPositions[ply]) then
					GAS.AFK:SetAFK(ply, false, pos_signature)
				elseif (os.time() - GAS_AFK_PlayerLastMoved[ply] >= GAS.AFK.AFKTime) then
					GAS.AFK:SetAFK(ply, true)
				end
			end
		end
	end)

	GAS:hook("PlayerInitialSpawn", "afk:PlayerInitialSpawn", function(ply)
		if (ply:IsBot()) then return end
		ply.GAS_PlayerAFK = true

		ply:SetNWBool("GAS_PlayerAFK", true)
	end)

	GAS:hook("PlayerDisconnected", "afk:GC", function(ply)
		GAS_AFK_PlayerLastMoved[ply] = nil
		GAS_AFK_PlayerPositions[ply] = nil
	end)

	GAS:netInit("afk:InitPostEntity")
	GAS:netReceive("afk:InitPostEntity", function(ply)
		local pos = ply:GetPos()
		local pos_signature = math.Round(pos.x) + math.Round(pos.y) + math.Round(pos.z)
		GAS_AFK_PlayerLastMoved[ply] = os.time()
		GAS_AFK_PlayerPositions[ply] = pos_signature
	end)

else

	GAS:InitPostEntity(function()
		GAS:netStart("afk:InitPostEntity")
		net.SendToServer()
	end)

end

function GAS.AFK:IsAFK(ply)
	return ply.GAS_PlayerAFK or ply:GetNWBool("GAS_PlayerAFK", true)
end
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/gmodadminsuite/modules/jobwhitelist/_gas_info.lua:
return gluapack()()
--PATH lua/gmodadminsuite/cl_selection_prompts.lua:
return gluapack()()
--PATH lua/autorun/grievous_pm.lua:
list.Set( "PlayerOptionsModel", "General Grievous", "models/aussisengels/grievous/general_grievous.mdl" )
player_manager.AddValidModel( "General Grievous", "models/aussisengels/grievous/general_grievous.mdl" )
player_manager.AddValidHands( "General Grievous", "models/aussisengels/grievous/general_grievous_hands.mdl",0,"10000000" )

--PATH lua/autorun/jawachef.lua:
return gluapack()()
--PATH lua/autorun/jkrevangoh.lua:
return gluapack()()
--PATH lua/autorun/kilian.lua:
player_manager.AddValidModel( "navy kilian", 		"models/navy/gnavykilian.mdl" );
list.Set( "PlayerOptionsModel", "navy kilian", 	"models/navy/gnavykilian.mdl" );
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_gesture_anims.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_inventory.lua:
local meta = FindMetaTable( "Player" )

if SERVER then
	util.AddNetworkString( "lscs_inventory" )
	util.AddNetworkString( "lscs_inventory_refresh" )
	util.AddNetworkString( "lscs_sync" )
	util.AddNetworkString( "lscs_equip" )

	function meta:lscsAddInventory( class_or_entity, equip, index )
		local item = class_or_entity

		if IsEntity( class_or_entity ) then
			item = class_or_entity:GetClass()
		end

		if not isnumber( index ) then
			index = 1 -- start at 1
			for _,_ in ipairs( self:lscsGetInventory() ) do
				index = index + 1 -- lets find an empty slot. Thanks to ipairs nature it will automatically stop at an empty slot
			end
		end

		if self:lscsGetInventory()[ index ] then print( "[LSCS] - Refusing to add Item to inventory! Index: "..index.." already in use for player "..self:GetName().."!" ) return end

		if hook.Run( "LSCS:PlayerInventory", self, item, index ) then return end

		if self._lscsNetworkingReady then
			net.Start( "lscs_inventory" )
				net.WriteBool( true )
				net.WriteInt( index, 8 )
				net.WriteString( item )
			net.Send( self )
		end

		self:lscsGetInventory()[ index ] = item

		if isbool( equip ) then -- this makes sure we can not equip two hilts or blades in one hand
			local object = LSCS:ClassToItem( item )

			if object then
				local type = object.type

				if type == "hilt" or type == "crystal" then
					self:lscsClearEquipped( type, equip )
				end
			end
		end

		self:lscsEquipItem( index, equip )

		if IsEntity( class_or_entity ) then
			class_or_entity:Remove()
		end

		hook.Run( "LSCS:PostPlayerInventory", self, item, index )
	end

	function meta:lscsEquipItem( index, hand )
		local class = self:lscsGetInventory()[ index ]
		if not class then return end

		local WasEquipped = self:lscsGetEquipped()[ index ]
		self:lscsGetEquipped()[ index ] = hand

		if self._lscsNetworkingReady then
			net.Start( "lscs_equip" )
				net.WriteInt( index, 8 )
				if hand == true then
					net.WriteInt( 1, 3 )
				elseif hand == false then
					net.WriteInt( 0, 3 )
				else
					net.WriteInt( -1, 3 )
				end
			net.Send( self )
		end

		self:lscsBuildPlayerInfo()

		if isbool( hand ) then
			hook.Run( "LSCS:OnPlayerEquippedItem", self, LSCS:ClassToItem( class ), hand, index )
		else
			if isbool( WasEquipped ) then
				hook.Run( "LSCS:OnPlayerUnEquippedItem", self, LSCS:ClassToItem( class ), index )
			end
		end
	end

	net.Receive( "lscs_equip", function( len, ply )
		local inventory = ply:lscsGetInventory()
		local equipped = ply:lscsGetEquipped()

		local index = net.ReadInt( 8 )
		local equip = net.ReadInt( 3 )

		if inventory[ index ] then
			if equip == 1 then
				ply:EmitSound( "lscs/equip.mp3" )
				equipped[ index ] = true

			elseif equip == 0 then
				ply:EmitSound( "lscs/equip.mp3" )
				equipped[ index ] = false

			else
				if isbool( equipped[ index ] ) then
					equipped[ index ] = nil
					ply:EmitSound( "weapons/sniper/sniper_zoomout.wav" )
				end
			end
		else
			equipped[ index ] = nil
		end

		ply:lscsBuildPlayerInfo()

		if equip == 0 or equip == 1 then
			hook.Run( "LSCS:OnPlayerEquippedItem", ply, LSCS:ClassToItem( inventory[ index ] ), equip == 1, index )
		else
			hook.Run( "LSCS:OnPlayerUnEquippedItem", ply, LSCS:ClassToItem( inventory[ index ], index ) )
		end
	end )

	function meta:lscsSyncInventory()
		if not self._lscsNetworkingReady then return end

		local inv = self:lscsGetInventory()
		local eq = self:lscsGetEquipped()

		local num = table.Count( inv )

		net.Start( "lscs_sync" )
			net.WriteInt( num, 8 )
			for index, item in pairs( inv ) do
				net.WriteInt( index, 8 )

				local IsEquipped = eq[ index ]
				if IsEquipped == true then
					net.WriteInt( 1, 3 )
				elseif IsEquipped == false then
					net.WriteInt( 0, 3 )
				else
					net.WriteInt( -1, 3 )
				end

				net.WriteString( item )
			end
		net.Send( self )
	end

	function meta:lscsWipeInventory( wipe_unequipped )
		if wipe_unequipped then
			local inv = self:lscsGetInventory()
			local eq = self:lscsGetEquipped()

			for id, item in pairs( inv ) do
				if eq[ id ] == nil then
					inv[ id ] = nil
				end
			end
		else
			local inv = self:lscsGetInventory()
			local eq = self:lscsGetEquipped()

			self:StripWeapon( "weapon_lscs" )

			for id, class in pairs( self:lscsGetInventory() ) do
				if isbool( eq[ id ] ) then
					hook.Run( "LSCS:OnPlayerUnEquippedItem", self, LSCS:ClassToItem( class ), id )
				end
			end

			table.Empty( inv )
			table.Empty( eq )
		end

		self:lscsSyncInventory()
		self:lscsBuildPlayerInfo()
	end

	function meta:lscsDropItem( id )
		local item = self:lscsGetInventory()[ id ]

		if not item then return end

		local tr = util.TraceLine( {
			start = self:GetShootPos(),
			endpos = self:GetShootPos() + self:GetAimVector() * 50,
			filter = self,
		} )

		local ent = ents.Create( item )

		if not IsValid( ent ) then self:lscsRemoveItem( id ) return end

		ent:SetPos( tr.HitPos )
		ent:SetAngles( Angle(90,self:EyeAngles().y,0) )

		ent.PreventTouch = true
		ent.DieTime = CurTime() + 240

		ent:Spawn()
		ent:Activate()
		ent:PhysWake()

		net.Start( "lscs_inventory" )
			net.WriteBool( false )
			net.WriteInt( id, 8 )
		net.Send( self )

		if self:lscsGetEquipped()[ id ] then -- we dropped a equipped item
			local _item = LSCS:ClassToItem( item ) -- convert item from inventory which is a class to actual item data
			if _item.type =="hilt" or _item.type == "crystal" then -- the item is a crystal or hilt which means we have to craft a lightsaber so it actually takes these parts out

				-- this garbage has to be called before crafting because it pulls stuff out of the inventory
				self:lscsRemoveItem( id )
				self:lscsBuildPlayerInfo()

				-- craft the saber
				self:lscsCraftSaber()
			end

			if _item.type == "stance" then -- dropped a equipped stance
				self:lscsRemoveItem( id )
				self:lscsBuildPlayerInfo() -- sync stances
			end

			hook.Run( "LSCS:OnPlayerUnEquippedItem", self, _item, id )
		end

		self:lscsRemoveItem( id )

		hook.Run( "LSCS:OnPlayerDroppedItem", self, ent, id, item )
	end

	function meta:lscsRemoveItem( id )
		local item = self:lscsGetInventory()[ id ]

		if not item then return end

		net.Start( "lscs_inventory" )
			net.WriteBool( false )
			net.WriteInt( id, 8 )
		net.Send( self )

		self:lscsGetInventory()[ id ] = nil
		self:lscsGetEquipped()[ id ] = nil
	end

	net.Receive( "lscs_inventory", function( len, ply )
		local id = net.ReadInt( 8 )
		ply:lscsDropItem( id )
	end)

	net.Receive( "lscs_sync", function( len, ply )
		if ply._lscsNetworkingReady then return end -- only allow this to be called once. This will prevent them from doing malicious bullshit.

		-- in case someone was spamming ply:Give while the player wasnt ready for networking
		-- this will make sure the client's inventory is 100% in sync with the server
		ply._lscsNetworkingReady = true
		ply:lscsSyncInventory()
		ply:lscsBuildPlayerInfo()

		hook.Run( "LSCS:OnPlayerFullySpawned", ply )
	end )

	net.Receive( "lscs_inventory_refresh", function( len, ply )
		local Wipe = net.ReadBool()

		if Wipe then
			ply:lscsWipeInventory( net.ReadBool() )
		else
			ply._lscsInvRefNext = ply._lscsInvRefNext or 0

			local Time = CurTime()

			if ply._lscsInvRefNext > Time then
				ply._lscsInvRefNext = ply._lscsInvRefNext + 1 -- add 1 second penality
				ply:ChatPrint("[LSCS] - Please wait ".. math.Round(ply._lscsInvRefNext-Time,0) .." seconds before refreshing your Inventory again")
				return
			end

			ply._lscsInvRefNext = Time + 10

			ply:lscsSyncInventory()
			ply:lscsBuildPlayerInfo()

			ply:ChatPrint("[LSCS] - Inventory Refreshed")
		end
	end)
else
	hook.Add( "InitPostEntity", "!!!lscsPlayerReady", function()
		net.Start( "lscs_sync" )
		net.SendToServer()
	end )

	net.Receive( "lscs_inventory", function( len )
		local ply = LocalPlayer()

		local Add = net.ReadBool()
		local id = net.ReadInt( 8 )

		local inventory = ply:lscsGetInventory()
		local equipped = ply:lscsGetEquipped()
	
		if Add then
			local item = net.ReadString()
			inventory[ id ] = item
		else
			inventory[ id ] = nil
		end
		equipped[ id ] = nil

		LSCS:RefreshMenu()
	end)

	net.Receive( "lscs_sync", function( len )
		local ply = LocalPlayer()

		local inventory = ply:lscsGetInventory()
		local equipped = ply:lscsGetEquipped()

		table.Empty( inventory )
		table.Empty( equipped )

		local num = net.ReadInt( 8 )
		for i = 1, num do
			local index = net.ReadInt( 8 )
			local IsEquipped = net.ReadInt( 3 )
			local item = net.ReadString( item )

			inventory[ index ] = item

			if IsEquipped == 1 then
				equipped[ index ] = true
			elseif IsEquipped == 0 then
				equipped[ index ] = false
			else
				equipped[ index ] = nil
			end
		end

		LSCS:RefreshMenu()
	end)

	function meta:lscsDropItem( id )
		net.Start( "lscs_inventory" )
			net.WriteInt( id, 8 )
		net.SendToServer()

		self:lscsGetInventory()[ id ] = nil
		self:lscsGetEquipped()[ id ] = nil

		self:lscsBuildPlayerInfo()
	end

	function meta:lscsEquipItem( index, hand )
		if not self:lscsGetInventory()[ index ] then return end

		self:lscsGetEquipped()[ index ] = hand

		net.Start( "lscs_equip" )
			net.WriteInt( index, 8 )
			if hand == true then
				net.WriteInt( 1, 3 )
			elseif hand == false then
				net.WriteInt( 0, 3 )
			else
				net.WriteInt( -1, 3 )
			end
		net.SendToServer()

		self:lscsBuildPlayerInfo()
	end

	net.Receive( "lscs_equip", function( len )
		local ply = LocalPlayer()

		local inventory = ply:lscsGetInventory()
		local equipped = ply:lscsGetEquipped()

		local index = net.ReadInt( 8 )
		local equip = net.ReadInt( 3 )

		if inventory[ index ] then
			if equip == 1 then
				equipped[ index ] = true

			elseif equip == 0 then
				equipped[ index ] = false

			else
				equipped[ index ] = nil
			end
		else
			equipped[ index ] = nil
		end

		ply:lscsBuildPlayerInfo()
	end )
end

--PATH lua/lscs/combos/advances_form5.lua:
COMBO.id = "form5b"
COMBO.PrintName = "Advanced:Shien Djem So(V)"
COMBO.Author = "Storm"
COMBO.Description = "The Way of the Krayt Dragon"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 65 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 100 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form5_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "shien_atk_normal",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "shienv2_atk_w_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
	["-45-"] = {
		AttackAnim = "shienv2_atk_w_60s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
	["+45+"] = {
		AttackAnim = "shienv2_atk_w_60s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
	["W_S_"] = {
		AttackAnim = "shienv2_atk_w_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
	["__S_"] = {
		AttackAnim = "shienv2_atk_s_60s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
	["_A__"] = {
		AttackAnim = "shienv2_atk_a_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
	["___D"] = {
		AttackAnim = "shienv2_atk_d_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
	["W__D"] = {
		AttackAnim = "shienv2_atk_wd_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
	["WA__"] = {
		AttackAnim = "shienv2_atk_wa_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
	["__SD"] = {
		AttackAnim = "shienv2_atk_sd_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
	["_AS_"] = {
		AttackAnim = "shienv2_atk_sa_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
	["W___"] = {
		AttackAnim = "shienv2_atk_normal_60s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.60,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/bladedancer.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/bladedancerdual.lua:
COMBO.id = "dancerdual"
COMBO.PrintName = "Blade Dancer {Dual Wield}"
COMBO.Author = "UCCROW"
COMBO.Description = "Dance With Sword."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "wos_dancer_corvinus"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "ryoku_a_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.5,
		Duration = 1.2,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "ryoku_r_c1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["-45-"] = {
		AttackAnim = "vanguard_b_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "ryoku_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["__S_"] = {
		AttackAnim = "pure_h_right_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.5,
	},
	["_A__"] = {
		AttackAnim = "pure_h_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["___D"] = {
		AttackAnim = "ryoku_r_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.8,
	},
	["W__D"] = {
		AttackAnim = "ryoku_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["WA__"] = {
		AttackAnim = "ryoku_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["__SD"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W___"] = {
		AttackAnim = "pure_b_s3_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/determination.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/juggernautdual.lua:
COMBO.id = "juggernautdual"
COMBO.PrintName = "Juggernaut {Dual Wield}"
COMBO.Author = "Luna"
COMBO.Description = "Hit's hard but easy to counter due to it's slow nature"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "melee2"

COMBO.DamageMultiplier = 1.15
COMBO.BPDrainPerHit = 50

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "h_c3_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "h_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "h_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "h_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["___D"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["W__D"] = {
		AttackAnim = "vanguard_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.5,
	},
	["WA__"] = {
		AttackAnim = "vanguard_h_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "judge_b_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.5,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "judge_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/vader.lua:
COMBO.id = "vader"
COMBO.PrintName = "Vader"
COMBO.Author = "Skip"
COMBO.Description = "Perferred stance by the Dark Lord himself. Firm, but lethal. And never retreating."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "lscs_vader"

COMBO.DamageMultiplier = 2
COMBO.BPDrainPerHit = 100

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "h_c3_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(200,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1,
	},
	["FRONT_DASH"] = {
		AttackAnim = "phalanx_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 500 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 100 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.3,
	},
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["-45-"] = {
		AttackAnim = "phalanx_h_s1_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.4,
	},
	["____"] = {
		AttackAnim = "phalanx_r_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.6,
	},
	["_A__"] = {
		AttackAnim = "judge_r_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = .7,
	},
	["___D"] = {
		AttackAnim = "phalanx_r_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = .7,
	},
	["W__D"] = {
		AttackAnim = "vanguard_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.5,
	},
	["WA__"] = {
		AttackAnim = "phalanx_h_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "phalanx_r_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.5,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_gica.lua:

sound.Add( {
	name = "darksaber_hup",
	channel = CHAN_STATIC,
	volume = 1,
	level = 110,
	pitch = 100,
	sound = {
		"gica_costi/darksaber_swing1.wav",
		"gica_costi/darksaber_swing2.wav",
	}
} )

sound.Add( {
	name = "darksaber_turnon",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 75,
	pitch = 100,
	sound = "gica_costi/darksaber_activate.wav",
} )

sound.Add( {
	name = "darksaber_turnoff",
	channel = CHAN_STATIC,
	volume = 0.3,
	level = 75,
	pitch = 100,
	sound = {
		"gica_costi/darksaber_turnoff.wav",
	}
} )

sound.Add( {
	name = "darksaber_idle",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = 75,
	sound = "gica_costi/darksaber_idle.wav",
} )


local blade = {}
blade.PrintName = "Darksaber Crystal"
blade.Author = "Gica Costi"
blade.Spawnable = false
blade.id = "actual_darksaber"
blade.color_blur = Color(255,255,255)
blade.color_core = Color(0,0,0)
blade.mdl = "models/dreadtrap/starwars/DarkSaber.mdl"
blade.mdl_poseparameter = "blade_retract"
blade.length = 50
blade.dynamic_light = true
blade.no_trail = false
blade.sounds = {
	Attack = "darksaber_hup", -- called then the combo file calls SWEP:DoAttackSound() or SWEP:DoAttackSound(nil, NUMBER_HAND) where NUMBER_HAND being SWEP.HAND_LEFT or SWEP.HAND_RIGHT or nil for both sabers
	Activate = "darksaber_turnon",
	Disable = "darksaber_turnoff",
	Idle =  "darksaber_idle",
}
LSCS:RegisterBlade( blade )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_breach.lua:
local force = {}
force.PrintName = "Breach"
force.Author = "Kokushibo and vReinZeix"
force.Description = "Force open any door that blocks your path."
force.id = "breach"
force.Spawnable = true

force.Equip = function(ply)
    print("i got equipped")
end

force.UnEquip = function(ply)
    print("i got unequipped :(")
end

force.StartUse = function(ply)
    if ply:lscsGetForce() < 10 then return end -- Needs at least 10 strength

    local Time = CurTime()
    local CanDo = (ply._lscsNextForce or 0) < Time
    if not CanDo then return end

    ply._lscsNextForce = Time + 2 -- 2 second cooldown

    -- Detects the entity in front of the player
    local tr = util.TraceLine(util.GetPlayerTrace(ply))
    if not IsValid(tr.Entity) then return end

    ply:EmitSound("npc/combine_gunship/ping_search.wav")

    -- Check if the entity is a valid door
    if not (tr.Entity:GetClass() == "func_door" or 
            tr.Entity:GetClass() == "prop_door_rotating" or 
            tr.Entity:GetClass() == "func_door_rotating") then return end

    ply:lscsTakeForce(0) 
    tr.Entity:Fire("unlock", "", 0)
    tr.Entity:Fire("Open", "", 0)

    ply:EmitSound("lscs/force/open_door.mp3")

    return true
end

force.StopUse = function(ply)
    -- Here you could add logic to stop the action if necessary
end

LSCS:RegisterForce(force)
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_choke_vader.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_drain.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_healother.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_meditation.lua:
local force = {}
force.PrintName = "Meditate [Basic]"
force.Author = "Storm"
force.Description = "Recover your force through meditation"
force.id = "meditate"
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 1

	local available = ply:lscsGetForce()
	local need = ply:lscsGetMaxForce() - ply:lscsGetForce()

	if need > 0 and available >= 5 then
		local take = math.min( need, available, 25 )

		
		ply:SetHealth( math.min(ply:Health() + take ) )
		ply:lscsSetForce( math.min(ply:lscsGetForce() + take, ply:lscsGetMaxForce()) )

		LSCS:PlayVCDSequence( ply, "force_meditate", 0.01 )
		ply:ConCommand("+reload")
		timer.Simple(0.05, function()
		if ply:Health() > 1 and IsValid(ply) then
		ply:Freeze( true )
		end
	
		
		timer.Simple(2.01, function()
		if ply:Health() > 1 and IsValid(ply) then
		ply:Freeze( false )
		else
		ply:Freeze( false )
		end
ply:ConCommand("-reload")
end)
end)

		ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )

	end
end
LSCS:RegisterForce( force )



local force = {}
force.PrintName = "Meditate [Advanced]"
force.Author = "Storm"
force.Description = "Recover your force through meditation"
force.id = "meditateii"
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2

	local available = ply:lscsGetForce()
	local need = ply:lscsGetMaxForce() - ply:lscsGetForce()

	if need > 0 and available >= 5 then
		local take = math.min( need, available, 25 )

		
		ply:SetHealth( math.min(ply:Health() + take ) )
		ply:lscsSetForce( math.min(ply:lscsGetForce() + take, ply:lscsGetMaxForce()) )

		LSCS:PlayVCDSequence( ply, "force_meditate")
		ply:ConCommand("+reload")
		timer.Simple(0.05, function()
		if ply:Health() > 1 and IsValid(ply) then
		ply:Freeze( true )
		end
	
		
		timer.Simple(2.01, function()
		if ply:Health() > 1 and IsValid(ply) then
		ply:Freeze( false )
		else
		ply:Freeze( false )
		end
ply:ConCommand("-reload")
end)
end)

		ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )

	end
end
LSCS:RegisterForce( force )
--PATH lua/lscs/content/force_pull.lua:
local force = {}
force.PrintName = "Basic Pull"
force.Author = "Blu-x92 / Luna"
force.Description = "Pull things towards yourself"
force.id = "pull"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 20 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/pull.mp3")
	ply:lscsTakeForce( 10 ) --Pullun aldığı force miktarı

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_becon", 0.8 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_pull", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 200 ) ) do --Çekme yarıçapı
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 20 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = -Sub:GetNormalized() * 500 + Vector(0,0,50) -- + dan önceki kısım çekme kudreti

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Advanced Pull"
force.Author = "Storm"
force.Description = "Pull things towards yourself"
force.id = "pullii"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 15 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/pull.mp3")
	ply:lscsTakeForce( 15 ) --Pullun aldığı force miktarı

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_becon", 0.8 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_pull", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 500 ) ) do --Çekme yarıçapı
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 20 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = -Sub:GetNormalized() * 750 + Vector(0,0,100) -- + dan önceki kısım çekme kudreti

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Master Pull"
force.Author = "Storm"
force.Description = "Pull things towards yourself"
force.id = "pulliii"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 10 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/pull.mp3")
	ply:lscsTakeForce( 10 ) --Pullun aldığı force miktarı

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_becon", 0.8 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_pull", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 800 ) ) do --Çekme yarıçapı
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 20 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = -Sub:GetNormalized() * 2000 + Vector(0,0,150) -- + dan önceki kısım çekme kudreti

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_sense.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_anzatis.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_badjay.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_zhroms.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_zhroms.lua:
local hilt = {}
hilt.PrintName = "Gold Gauntlet"
hilt.Author = "Zhrom"
hilt.id = "Gold Gauntlet"
hilt.mdl = "models/zhrom/donation gauntlet/donation gauntlet.mdl"
hilt.info = {
    ParentData = {	
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -7), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, -7),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Silver Gauntlet"
hilt.Author = "Zhrom"
hilt.id = "Silver Gauntlet"
hilt.mdl = "models/zhrom/gauntlet/gauntlet.mdl"
hilt.info = {
    ParentData = {	
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -7), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, -7),
            ang = Angle(-90, -90, -90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

--PATH addons/[miecze] moce i hilty/lua/lscs/content/vader_blade.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/cl_camera.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/lvs_bulletsystem.lua:
local LVS = LVS

LVS._ActiveBullets = {}

function LVS:RemoveBullet( index )
	LVS._ActiveBullets[ index ] = nil
end

function LVS:GetBullet( index )
	if not LVS._ActiveBullets then return end

	return LVS._ActiveBullets[ index ]
end

local NewBullet = {}
NewBullet.__index = NewBullet 

function NewBullet:SetPos( pos )
	self.curpos = pos
end

function NewBullet:GetBulletIndex()
	return self.bulletindex
end

function NewBullet:Remove()
	local index = self.bulletindex

	if SERVER then
		-- prevents ghost bullets if the client fails to detect the hit
		net.Start( "lvs_remove_bullet", true )
			net.WriteInt( index, 13 )
		net.SendPVS( self:GetPos() )
	end

	LVS:RemoveBullet( index )
end

function NewBullet:GetPos()
	if not self.curpos then return self.Src end

	return self.curpos
end

function NewBullet:SetGravity( new )
	self.Gravity = new
end

function NewBullet:GetGravity()
	return self.Gravity or vector_origin
end

function NewBullet:GetDir()
	return self.Dir or vector_origin
end

function NewBullet:SetDir( newdir )
	self.Dir = newdir
end

function NewBullet:GetTimeAlive()
	return CurTime() - self.StartTime
end

function NewBullet:GetSpawnTime()
	if SERVER then
		return self.StartTime
	else
		return math.min( self.StartTimeCL, CurTime() ) -- time when the bullet is received on client
	end
end

function NewBullet:GetLength()
	return math.min((CurTime() - self:GetSpawnTime()) * 14,1)
end

function NewBullet:HandleWaterImpact( traceStart, traceEnd, Filter )
	if self.HasHitWater then return end

	local traceWater = util.TraceLine( {
		start = traceStart,
		endpos = traceEnd,
		filter = Filter,
		mask = MASK_WATER,
	} )

	if not traceWater.Hit then return end

	self.HasHitWater = true

	local effectdata = EffectData()
	effectdata:SetOrigin( traceWater.HitPos )
	effectdata:SetScale( 10 + self.HullSize * 0.5 )
	effectdata:SetFlags( 2 )
	util.Effect( "WaterSplash", effectdata, true, true )
end

function NewBullet:HandleFlybySound( EarPos )
	if self.Muted or not LVS.EnableBulletNearmiss then return end

	local BulletPos = self:GetPos()

	local EarDist = (EarPos - BulletPos):LengthSqr()

	if self.OldEarDist and self.OldEarDist < EarDist then

		if EarDist < 250000 then
			local effectdata = EffectData()
			effectdata:SetOrigin( EarPos + (BulletPos - EarPos):GetNormalized() * 20 )
			effectdata:SetFlags( 2 )
			util.Effect( "TracerSound", effectdata )
		end

		self.Muted = true
	end

	self.OldEarDist = EarDist
end

function NewBullet:DoBulletFlight( TimeAlive )

	local StartPos = self.Src
	local StartDirection = self.StartDir

	local Velocity = self.Velocity

	local PosOffset

	-- startpos, direction and curtime of creation is networked to client. 
	-- the bullet position is simulated by doing startpos + dir * time * velocity
	if self.EnableBallistics then
		local PosTheoretical = StartDirection * TimeAlive * Velocity

		PosOffset = PosTheoretical + self:GetGravity() * (TimeAlive ^ 2)

		self:SetDir( (StartPos + PosOffset - StartPos):GetNormalized() )
	else
		PosOffset = self.Dir * TimeAlive * Velocity
	end

	if SERVER then
		self:SetPos( StartPos + PosOffset )
	else

		-- "parent" the bullet to the vehicle for a very short time on client. This will give the illusion of the bullet not lagging behind even tho it is fired later on client
		if IsValid( self.Entity ) and self.SrcEntity then
			local mul = self:GetLength()
			local inv = 1 - mul

			self:SetPos( StartPos * mul + self.Entity:LocalToWorld( self.SrcEntity ) * inv + PosOffset )

			return
		end

		-- if no parent detected, run same code as server
		self:SetPos( StartPos + PosOffset )
	end
end

function NewBullet:OnCollide( trace )
	if CLIENT then return end

	if trace.Entity == self.LastDamageTarget then return end

	local Attacker = (IsValid( self.Attacker ) and self.Attacker) or (IsValid( self.Entity ) and self.Entity) or game.GetWorld()
	local Inflictor = (IsValid( self.Entity ) and self.Entity) or (IsValid( self.Attacker ) and self.Attacker) or game.GetWorld()

	local dmginfo = DamageInfo()
	dmginfo:SetDamage( self.Damage )
	dmginfo:SetAttacker( Attacker )
	dmginfo:SetInflictor( Inflictor )
	dmginfo:SetDamageType( DMG_AIRBOAT )
	dmginfo:SetDamagePosition( trace.HitPos )

	if self.Force1km then
		local Mul = math.min( (self.Src - trace.HitPos):Length() / 39370, 1 )
		local invMul = math.max( 1 - Mul, 0 )

		dmginfo:SetDamageForce( self.Dir * (self.Force * invMul + self.Force1km * Mul) )
	else
		dmginfo:SetDamageForce( self.Dir * self.Force )
	end

	if self.Callback then
		self.Callback( Attacker, trace, dmginfo )
	end

	if trace.Entity:GetClass() == "func_breakable_surf" then
		-- this will cause the entire thing to just fall apart
		dmginfo:SetDamageType( DMG_BLAST )
	end

	trace.Entity:DispatchTraceAttack( dmginfo, trace )

	self.LastDamageTarget = trace.Entity
end

function NewBullet:DoSplashDamage( trace )
	if not self.SplashDamage or not self.SplashDamageRadius then return false end

	if self.SplashDamageEffect ~= "" then
		local effectdata = EffectData()
		effectdata:SetOrigin( trace.HitPos )
		effectdata:SetNormal( trace.HitWorld and trace.HitNormal or self.Dir )
		effectdata:SetMagnitude( self.SplashDamageRadius / 250 )
		util.Effect( self.SplashDamageEffect, effectdata )
	end

	local Attacker = (IsValid( self.Attacker ) and self.Attacker) or (IsValid( self.Entity ) and self.Entity) or game.GetWorld()
	local Inflictor = (IsValid( self.Entity ) and self.Entity) or (IsValid( self.Attacker ) and self.Attacker) or game.GetWorld()

	LVS:BlastDamage( trace.HitPos, self.Dir, Attacker, Inflictor, self.SplashDamage, self.SplashDamageType, self.SplashDamageRadius, self.SplashDamageForce )

	self.SplashDamage = nil
	self.SplashDamageRadius = nil
	self.SplashDamageEffect = nil

	return true
end

function NewBullet:HandleCollision( traceStart, traceEnd, Filter )
	local TraceMask = self.HullSize <= 1 and MASK_SHOT_PORTAL or MASK_SHOT_HULL

	local traceLine
	local traceHull

	if self.HullTraceResult then
		traceHull = self.HullTraceResult
	else
		traceLine = util.TraceLine( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mask = TraceMask
		} )

		local trace = util.TraceHull( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mins = self.Mins,
			maxs = self.Maxs,
			mask = TraceMask,
			ignoreworld = true
		} )

		if traceLine.Entity == trace.Entity and trace.Hit and traceLine.Hit then
			trace = traceLine
		end

		if trace.Hit then
			self.HullTraceResult = trace
			traceHull = trace

			self:OnCollide( trace )

			if self:DoSplashDamage( trace ) then
				self:Remove()
			end
		else
			traceHull = { Hit = false }
		end
	end

	if not traceLine then
		traceLine = util.TraceLine( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mask = TraceMask
		} )
	end

	if not traceLine.Hit then
		return
	end

	self:OnCollide( traceLine )

	self:DoSplashDamage( traceLine )

	self:Remove()

	if SERVER then return end

	if not traceLine.HitSky then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceLine.HitPos )
		effectdata:SetEntity( traceLine.Entity )
		effectdata:SetStart( traceStart )
		effectdata:SetNormal( traceLine.HitNormal )
		effectdata:SetSurfaceProp( traceLine.SurfaceProps )
		util.Effect( "Impact", effectdata )
	end
end

local function GetEarPos()
	if SERVER then return vector_origin end

	local EarPos

	local ply = LocalPlayer()
	local ViewEnt = ply:GetViewEntity()

	if ViewEnt == ply then
		if IsValid( ply:lvsGetVehicle() ) then
			EarPos = ply:lvsGetView()
		else
			EarPos = ply:GetShootPos()
		end
	else
		EarPos = ViewEnt:GetPos()
	end

	return EarPos
end

local function HandleBullets()
	local T = CurTime()
	local FT = FrameTime()

	local EarPos = GetEarPos()

	for id, bullet in pairs( LVS._ActiveBullets ) do
		if bullet:GetSpawnTime() + 5 < T then -- destroy all bullets older than 5 seconds
			bullet:Remove()

			continue
		end

		local TimeAlive = bullet:GetTimeAlive()

		if TimeAlive < 0 then continue end -- CurTime() is predicted, this can be a negative number in some cases.

		local Filter = bullet.Filter

		local traceStart = bullet:GetPos()
			bullet:DoBulletFlight( TimeAlive )
		local traceEnd = bullet:GetPos()

		if CLIENT then
			--debugoverlay.Line( traceStart, traceEnd, Color( 255, 255, 255 ), true )

			-- bullet flyby sounds
			bullet:HandleFlybySound( EarPos )

			-- bullet water impact effects
			bullet:HandleWaterImpact( traceStart, traceEnd, Filter )
		end

		bullet:HandleCollision( traceStart, traceEnd, Filter )
	end
end

local vector_one = Vector(1,1,1)

if SERVER then
	util.AddNetworkString( "lvs_fire_bullet" )
	util.AddNetworkString( "lvs_remove_bullet" )

	hook.Add( "Tick", "!!!!lvs_bullet_handler", function( ply, ent ) -- from what i understand, think can "skip" on lag, while tick still simulates all steps
		HandleBullets()
	end )

	local Index = 0
	local MaxIndex = 4094 -- this is the util.effect limit

	function LVS:FireBullet( data )

		Index = Index + 1

		if Index > MaxIndex then
			Index = 1
		end

		LVS._ActiveBullets[ Index ] = nil

		local bullet = {}

		setmetatable( bullet, NewBullet )

		bullet.TracerName = data.TracerName or "lvs_tracer_orange"
		bullet.Src = data.Src or vector_origin
		bullet.Dir = (data.Dir + VectorRand() * (data.Spread or vector_origin) * 0.5):GetNormalized()
		bullet.StartDir = bullet.Dir
		bullet.Force = data.Force or 10

		if data.Force1km then
			bullet.Force1km = data.Force1km
		end

		bullet.HullSize = data.HullSize or 5
		bullet.Mins = -vector_one * bullet.HullSize
		bullet.Maxs = vector_one * bullet.HullSize
		bullet.Velocity = data.Velocity or 2500
		bullet.Attacker = IsValid( data.Attacker ) and data.Attacker or (IsValid( data.Entity ) and data.Entity or game.GetWorld())
		bullet.Damage = data.Damage or 10
		bullet.Entity = data.Entity
		if IsValid( bullet.Entity ) and bullet.Entity.GetCrosshairFilterEnts then
			bullet.Filter = bullet.Entity:GetCrosshairFilterEnts()
		else
			bullet.Filter = bullet.Entity
		end
		bullet.SrcEntity = data.SrcEntity or vector_origin
		bullet.Callback = data.Callback
		bullet.SplashDamage = data.SplashDamage
		bullet.SplashDamageForce = data.SplashDamageForce or 500
		bullet.SplashDamageRadius = data.SplashDamageRadius
		bullet.SplashDamageEffect = data.SplashDamageEffect or "lvs_bullet_impact"
		bullet.SplashDamageType = data.SplashDamageType or DMG_SONIC
		bullet.StartTime = CurTime()
		bullet.EnableBallistics = data.EnableBallistics == true

		if bullet.EnableBallistics then
			bullet:SetGravity( physenv.GetGravity() )
		end

		if InfMap then
			for _, ply in ipairs( player.GetAll() ) do
				local NewPos = Vector( bullet.Src.x, bullet.Src.y, bullet.Src.z ) - InfMap.unlocalize_vector( Vector(), ply.CHUNK_OFFSET )

				net.Start( "lvs_fire_bullet", true )
					net.WriteInt( Index, 13 )
					net.WriteString( bullet.TracerName )
					net.WriteFloat( NewPos.x )
					net.WriteFloat( NewPos.y )
					net.WriteFloat( NewPos.z )
					net.WriteAngle( bullet.Dir:Angle() )
					net.WriteFloat( bullet.StartTime )
					net.WriteFloat( bullet.HullSize )
					net.WriteEntity( bullet.Entity )
					net.WriteFloat( bullet.SrcEntity.x )
					net.WriteFloat( bullet.SrcEntity.y )
					net.WriteFloat( bullet.SrcEntity.z )
					net.WriteFloat( bullet.Velocity )
					net.WriteBool( bullet.EnableBallistics )
				net.Send( ply )
			end
		else
			net.Start( "lvs_fire_bullet", true )
				net.WriteInt( Index, 13 )
				net.WriteString( bullet.TracerName )
				net.WriteFloat( bullet.Src.x )
				net.WriteFloat( bullet.Src.y )
				net.WriteFloat( bullet.Src.z )
				net.WriteAngle( bullet.Dir:Angle() )
				net.WriteFloat( bullet.StartTime )
				net.WriteFloat( bullet.HullSize )
				net.WriteEntity( bullet.Entity )
				net.WriteFloat( bullet.SrcEntity.x )
				net.WriteFloat( bullet.SrcEntity.y )
				net.WriteFloat( bullet.SrcEntity.z )
				net.WriteFloat( bullet.Velocity )
				net.WriteBool( bullet.EnableBallistics )
			net.SendPVS( bullet.Src )
		end

		bullet.bulletindex = Index
		LVS._ActiveBullets[ Index ] = bullet
	end
else
	net.Receive( "lvs_remove_bullet", function( length )
		LVS:RemoveBullet( net.ReadInt( 13 ) )
	end)

	net.Receive( "lvs_fire_bullet", function( length )
		local Index = net.ReadInt( 13 )

		LVS._ActiveBullets[ Index ] = nil

		local bullet = {}

		setmetatable( bullet, NewBullet )

		bullet.TracerName = net.ReadString()
		bullet.Src = Vector(net.ReadFloat(),net.ReadFloat(),net.ReadFloat())
		bullet.Dir = net.ReadAngle():Forward()
		bullet.StartDir = bullet.Dir
		bullet.StartTime = net.ReadFloat()
		bullet.HullSize = net.ReadFloat()
		bullet.Mins = -vector_one * bullet.HullSize
		bullet.Maxs = vector_one * bullet.HullSize
		bullet.Entity = net.ReadEntity()
		if IsValid( bullet.Entity ) and bullet.Entity.GetCrosshairFilterEnts then
			bullet.Filter = bullet.Entity:GetCrosshairFilterEnts()
		else
			bullet.Filter = bullet.Entity
		end
		bullet.SrcEntity = Vector(net.ReadFloat(),net.ReadFloat(),net.ReadFloat())

		if bullet.SrcEntity == vector_origin then
			bullet.SrcEntity = nil
		end

		bullet.Velocity = net.ReadFloat()

		bullet.EnableBallistics = net.ReadBool()

		if bullet.EnableBallistics then
			bullet:SetGravity( physenv.GetGravity() )
		end

		bullet.StartTimeCL = CurTime() + RealFrameTime()

		local ply = LocalPlayer()

		if IsValid( ply ) then
			bullet.Muted = bullet.Entity == ply:lvsGetVehicle() or bullet.Entity:GetOwner() == ply
		end

		bullet.bulletindex = Index
		LVS._ActiveBullets[ Index ] = bullet

		local effectdata = EffectData()
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( bullet.Dir )
		effectdata:SetMaterialIndex( Index )
		util.Effect( bullet.TracerName, effectdata )
	end )

	hook.Add( "Think", "!!!!_lvs_bullet_think_cl", function()
		HandleBullets()
	end )
end
--PATH lua/lvs_framework/autorun/lvs_pod.lua:
return gluapack()()
--PATH lua/autorun/includes/modules/eventemitter.lua:
return gluapack()()
--PATH lua/autorun/includes/modules/htmlmaterial.lua:
local ipairs = ipairs
local table = table
local timer = timer
local ceil = math.ceil
local log = math.log
local pow = math.pow

local tblconcat = table.concat

local cache = {}
local downloads = {}
local styles = {}

local embedHtml = [[
<!doctype html>
<html>
<head>
	<meta charset="utf-8">
</head>
<body>
	<script>
	var src = '%s';
	</script>
	<img id="mat">

	<style>
	html, body {
		width: 100%%;
		height: 100%%;
		margin: 0;
		padding: 0;
		overflow: hidden;
	}
	%s
	</style>

	<script>
	var mat = document.getElementById('mat');
	mat.onload = function() {
		setTimeout(function() {
			gmod.imageLoaded();
		}, 100);
	};
	mat.onerror = function() {
		gmod.imageLoaded();
	};
	mat.src = src;
	</script>
</body>
</html>]]

local UpdateTimerName = "HtmlMatUpdate"
local TimerRunning = false

local function updateCache(download)
	download.browser:UpdateHTMLTexture()
	cache[download.key] = download.browser:GetHTMLMaterial()
end

local function updateMaterials()
	for _, download in ipairs(downloads) do
		updateCache(download)
	end
end

local function onImageLoaded(key, browser)
	local idx

	for k, v in pairs(downloads) do
		if v.key == key then
			idx = k
			break
		end
	end

	if idx > 0 then
		-- html materials are unique to each browser; re-using a browser will
		-- result in previous materials being updated. Therefore, used browsers
		-- must be destroyed rather than pooled.
		local download = downloads[idx]
		browserpool.release(browser, true)
		table.remove(downloads, idx)
	end

	if #downloads == 0 and TimerRunning then
		timer.Destroy(UpdateTimerName)
		TimerRunning = false
	end
end

local DefaultMat = Material("vgui/white")
local DefaultWidth = 128
local DefaultStyle = {}

local function enqueueUrl( url, styleName, key, callback )
	cache[key] = DefaultMat

	browserpool.get(function(browser)
		local style = styles[styleName] or DefaultStyle
		local w = style.width or DefaultWidth
		local h = style.height or w

		browser:SetSize( w, h )

		local download = {
			url = url,
			key = key,
			browser = browser
		}

		table.insert(downloads, download)

		browser:AddFunction("gmod", "imageLoaded", function()
			updateCache(download)
			onImageLoaded(key, browser)

			if type(callback) == "function" then
				callback( cache[key] )
			end
		end)

		if not TimerRunning then
			timer.Create(UpdateTimerName, 0.05, 0, updateMaterials)
			timer.Start(UpdateTimerName)
			TimerRunning = true
		end

		local html = (style.html or embedHtml):format(url, style.css or '')
		browser:SetHTML( html )
	end)
end

-- cached for performance
local MAT_STR_TABLE = { '', '@', '' }

---
-- Renders a URL as a material.
--
-- @param url		URL.
-- @param style		HTMLMaterial style.
--
function HTMLMaterial( url, style, callback )
	if not url then
		return DefaultMat
	end

	local key

	-- Build unique key for material
	if style then
		MAT_STR_TABLE[1] = url
		MAT_STR_TABLE[3] = style
		key = tblconcat( MAT_STR_TABLE )
	else
		key = url
	end

	-- Enqueue the URL to be downloaded if it hasn't been loaded yet.
	if cache[key] == nil then
		enqueueUrl( url, style, key, callback )
	elseif callback then
		callback( cache[key] )
	end

	-- Return cached URL
	return cache[key]
end

local SetDrawColor = surface.SetDrawColor
local SetMaterial = surface.SetMaterial
local DrawTexturedRect = surface.DrawTexturedRect

function CeilPower2(n)
	return pow(2, ceil(log(n) / log(2)))
end

function DrawHTMLMaterial( url, styleName, w, h )
	local mat = HTMLMaterial( url, styleName )
	local style = styles[styleName] or DefaultStyle

	-- Desired dimensions
	local width = style.width or DefaultWidth
	local height = style.height or w

	-- Convert to scalar
	w = w / width
	h = h / height

	-- Fix for non-power-of-two html panel size
	width = CeilPower2(width)
	height = CeilPower2(height)

	SetDrawColor( color_white )
	SetMaterial( mat )
	DrawTexturedRect( 0, 0, w * width, h * height )
end

---
-- Registers a style that can be used with `HTMLMaterial`
--
-- @param name		Style name.
-- @param params	Table of style parameters.
--
function AddHTMLMaterialStyle( name, params, base )
	params = params or {}

	if base then
		table.Merge( params, table.Copy( styles[base] or {} ) )
	end

	styles[name] = params
end

HTMLMAT_STYLE_BLUR       = 'htmlmat.style.blur'
HTMLMAT_STYLE_GRAYSCALE  = 'htmlmat.style.grayscale'
HTMLMAT_STYLE_SEPIA      = 'htmlmat.style.sepia'
HTMLMAT_STYLE_INVERT     = 'htmlmat.style.invert'
HTMLMAT_STYLE_CIRCLE     = 'htmlmat.style.circle'
HTMLMAT_STYLE_COVER      = 'htmlmat.style.cover'
HTMLMAT_STYLE_COVER_IMG  = 'htmlmat.style.coverimg'

AddHTMLMaterialStyle( HTMLMAT_STYLE_BLUR, {
	css = [[img {
	-webkit-filter: blur(8px);
	-webkit-transform: scale(1.1, 1.1);
}]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_GRAYSCALE, {
	css = [[img { -webkit-filter: grayscale(1); }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_SEPIA, {
	css = [[img { -webkit-filter: sepia(1); }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_INVERT, {
	css = [[img { -webkit-filter: invert(1); }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_CIRCLE, {
	css = [[img { border-radius: 50%; }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_COVER, {
	html = [[
<script>
var src = '%s';
</script>

<style type="text/css">
html, body {
	width: 100%%;
	height: 100%%;
	margin: 0;
	padding: 0;
	overflow: hidden;
}

#mat {
	background: no-repeat 50%% 50%%;
	background-size: cover;
	width: 100%%;
	height: 100%%;
}

%s
</style>

<div id="mat"></div>

<script type="application/javascript">
var mat = document.getElementById('mat');
mat.style.backgroundImage = 'url('+src+')';

var img = new Image();
img.onload = function() {
	setTimeout(function() {
		gmod.imageLoaded();
	}, 100);
};
img.onerror = gmod.imageLoaded.bind(gmod);
img.src = src;
</script>
]]
})

-- Use this if you want to use -webkit-filter blur on the image;
-- you'll also need to use a transform to scale it a bit. This prevents
-- the edges from blurring as seen with background-size cover.
AddHTMLMaterialStyle( HTMLMAT_STYLE_COVER_IMG, {
	html = [[
<script>
var src = '%s';
</script>

<style type="text/css">
html, body {
	width: 100%%;
	height: 100%%;
	margin: 0;
	padding: 0;
	overflow: hidden;
}
img {
	width: auto;
	height: auto;
	position: absolute;
	top: 50%%;
	left: 50%%;
	-webkit-transform: translate(-50%%, -50%%);
}
%s
</style>

<img id="mat">

<script type="application/javascript">
var mat = document.getElementById('mat');
mat.onload = function() {
	if (mat.width > mat.height) {
		mat.style.height = '100%%';
	} else {
		mat.style.width = '100%%';
	}
	setTimeout(function() {
		gmod.imageLoaded();
	}, 100);
};
mat.onerror = function() {
	gmod.imageLoaded();
};
mat.src = src;
</script>
]]
})

--PATH lua/mediaplayer/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/controls/dhtmlcontrols.lua:
return gluapack()()
--PATH lua/mediaplayer/controls/dmediaplayerrequest.lua:
return gluapack()()
--PATH lua/mediaplayer/players/base/cl_draw.lua:
return gluapack()()
--PATH lua/mediaplayer/players/entity/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_base" )

local pcall = pcall
local print = print
local Angle = Angle
local IsValid = IsValid
local ValidPanel = ValidPanel
local Vector = Vector
local cam = cam
local Start3D = cam.Start3D
local Start3D2D = cam.Start3D2D
local End3D2D = cam.End3D2D
local draw = draw
local math = math
local string = string
local surface = surface

local FullscreenCvar = MediaPlayer.Cvars.Fullscreen

MEDIAPLAYER.Enable3DAudio = true

function MEDIAPLAYER:NetReadUpdate()
	local entIndex = net.ReadUInt(16)
	local ent = Entity(entIndex)
	local mpEnt = self.Entity

	if MediaPlayer.DEBUG then
		print("MEDIAPLAYER.NetReadUpdate[entity]: ", ent, entIndex)
	end

	if ent ~= mpEnt then
		if IsValid(ent) and ent ~= NULL then
			ent:InstallMediaPlayer( self )
		else
			-- Wait until the entity becomes valid
			self._EntIndex = entIndex
		end
	end
end

local RenderScale = 0.1
local InfoScale = 1/17

function MEDIAPLAYER:GetOrientation()
	local ent = self.Entity

	if ent then
		return ent:GetMediaPlayerPosition()
	end

	return nil
end

---
-- Draws the idlescreen; this is drawn when there is no media playing.
--
function MEDIAPLAYER:DrawIdlescreen( w, h )
	local browser = MediaPlayer.GetIdlescreen()

	if ValidPanel(browser) then
		self:DrawHTML( browser, w, h )
	end
end

local BaseInfoHeight = 60

function MEDIAPLAYER:Draw( bDrawingDepth, bDrawingSkybox )

	local ent = self.Entity

	if --bDrawingSkybox or
			FullscreenCvar:GetBool() or -- Don't draw if we're drawing fullscreen
			not IsValid(ent) or
			(ent.IsDormant and ent:IsDormant()) then
		return
	end

	local media = self:GetMedia()
	local w, h, pos, ang = self:GetOrientation()

	-- Render scale
	local rw, rh = w / RenderScale, h / RenderScale

	if IsValid(media) then

		-- Custom media draw function
		if media.Draw then
			Start3D2D( pos, ang, RenderScale )
				media:Draw( rw, rh )
			End3D2D()
		end
		-- TODO: else draw 'not yet implemented' screen?

		-- scale based off of height
		local scale = InfoScale * ( h / BaseInfoHeight )

		-- Media info
		Start3D2D( pos, ang, scale )
			local iw, ih = w / scale, h / scale
			self:DrawMediaInfo( media, iw, ih )
		End3D2D()

	else

		Start3D2D( pos, ang, RenderScale )
			self:DrawIdlescreen( rw, rh )
		End3D2D()

	end

end

function MEDIAPLAYER:SetMedia( media )
	if media then
		-- Set entity on media for 3D audio support and setting proper
		-- browser resolution
		media.Entity = self:GetEntity()
	end

	BaseClass.SetMedia( self, media )
end

---
-- Mouse click intersected with 3D2D screen.
--
function MEDIAPLAYER:OnMousePressed( x, y )
	local media = self:GetMedia()
	if media and media:IsMouseInputEnabled() then
		media:OnMousePressed( x, y )
	end
end

function MEDIAPLAYER:OnMouseWheeled( scrollDelta )
	local media = self:GetMedia()
	if media and media:IsMouseInputEnabled() then
		media:OnMouseWheeled( scrollDelta )
	end
end

--PATH lua/mediaplayer/players/entity/shared.lua:
include "sh_meta.lua"

DEFINE_BASECLASS( "mp_base" )

--[[---------------------------------------------------------
	Entity Media Player
-----------------------------------------------------------]]

local MEDIAPLAYER = MEDIAPLAYER
MEDIAPLAYER.Name = "entity"

function MEDIAPLAYER:IsValid()
	if not BaseClass.IsValid(self) then
		return false
	end

	local ent = self.Entity

	if ent then
		return IsValid(ent)
	end

	-- Client may still be waiting on the entity to be created by the network;
	-- let's just say it's valid until the entity is setup
	return true
end

function MEDIAPLAYER:Init(...)
	BaseClass.Init(self, ...)

	if SERVER then
		-- Manually manage listeners by default
		self._TransmitState = TRANSMIT_NEVER
	end
end

function MEDIAPLAYER:SetEntity(ent)
	self.Entity = ent

	if SERVER then
		local creator = ent:GetCreator()

		if IsValid(creator) and creator:IsPlayer() then
			self:SetOwner(creator)
		end
	else
		-- Setup hooks for drawing the screen onto the entity
		hook.Add( "HUDPaint", self, self.DrawFullscreen )
		hook.Add( "PostDrawOpaqueRenderables", self, self.Draw )
	end
end

function MEDIAPLAYER:GetEntity()
	-- Clients may wait for the entity to become valid
	if CLIENT and self._EntIndex then
		local ent = Entity(self._EntIndex)

		if IsValid(ent) and ent ~= NULL then
			ent:InstallMediaPlayer(self)
			self._EntIndex = nil
		else
			return nil
		end
	end

	return self.Entity
end

function MEDIAPLAYER:GetPos()
	return IsValid(self.Entity) and self.Entity:GetPos() or Vector(0,0,0)
end

function MEDIAPLAYER:GetLocation()
	if IsValid(self.Entity) and self.Entity.Location then
		return self.Entity:Location()
	end
	return self._Location
end

function MEDIAPLAYER:Think()
	BaseClass.Think(self)

	local ent = self:GetEntity()

	if IsValid(ent) then
		-- Lua refresh fix
		if ent._mp ~= self then
			self:Remove()
		end
	elseif SERVER then
		-- Only remove on the server since the client may still be connecting
		-- and the entity will be created when they finish.
		self:Remove()
	end
end

function MEDIAPLAYER:Remove()
	-- remove draw hooks
	if CLIENT then
		hook.Remove( "HUDPaint", self )
		hook.Remove( "PostDrawOpaqueRenderables", self )
	end

	-- remove reference to media player installed on entity
	if self.Entity then
		self.Entity._mp = nil
	end

	BaseClass.Remove(self)
end

--PATH lua/mediaplayer/services/googledrive/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/services/googledrive/shared.lua:
return gluapack()()
--PATH lua/mediaplayer/services/twitchstream/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/services/shoutcast.lua:
return gluapack()()
--PATH lua/mp_menu/volume_control.lua:
local math = math
local ceil = math.ceil
local clamp = math.Clamp

local surface = surface
local color_white = color_white

local PANEL = {}

PANEL.Margin = 16
PANEL.ButtonWidth = 18
PANEL.ButtonSpacing = 8
PANEL.BackgroundColor = Color( 28, 100, 157 )

function PANEL:Init()

	self.BaseClass.Init( self )

	self.VolumeButton = vgui.Create( "MP.VolumeButton", self )

	self.VolumeSlider = vgui.Create( "MP.VolumeSlider", self )

	self.BtnList = vgui.Create( "DHorizontalList", self )
	self.BtnList:SetSpacing( self.ButtonSpacing )

	if hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then
		self.RepeatBtn = vgui.Create( "MP.RepeatButton" )
		self:AddButton( self.RepeatBtn )
		self.ShuffleBtn = vgui.Create( "MP.ShuffleButton" )
		self:AddButton( self.ShuffleBtn )
		self.LockBtn = vgui.Create( "MP.LockButton" )
		self:AddButton( self.LockBtn )
	end

	self:OnVolumeChanged( MediaPlayer.Volume() )

	hook.Add( MP.EVENTS.VOLUME_CHANGED, self, self.OnVolumeChanged )
	hook.Add( MP.EVENTS.UI.MEDIA_PLAYER_CHANGED, self, self.OnMediaPlayerChanged )

end

function PANEL:AddButton( panel )
	self.BtnList:AddItem( panel )
end

function PANEL:OnVolumeChanged( volume )

	self.VolumeSlider:SetSlideX( volume )

	self:InvalidateChildren()

end

function PANEL:OnMediaPlayerChanged( mp )

	if hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then
		self.RepeatBtn:SetEnabled( mp:GetQueueRepeat() )
		self.ShuffleBtn:SetEnabled( mp:GetQueueShuffle() )
		self.LockBtn:SetEnabled( mp:GetQueueLocked() )
	end

end

function PANEL:Paint( w, h )

	surface.SetDrawColor( self.BackgroundColor )
	surface.DrawRect( 0, 0, w, h )

end

function PANEL:PerformLayout( w, h )

	self.BtnList:InvalidateLayout( true )
	self.BtnList:CenterVertical()
	self.BtnList:AlignRight( self.Margin )

	self.VolumeButton:CenterVertical()
	self.VolumeButton:AlignLeft( self.Margin )

	local sliderWidth = ( self.BtnList:GetPos() - 15 ) -
			( self.VolumeButton:GetPos() + self.VolumeButton:GetWide() + 15 )
	self.VolumeSlider:SetWide( sliderWidth )
	self.VolumeSlider:CenterVertical()
	self.VolumeSlider:MoveRightOf( self.VolumeButton, 15 )

end

function PANEL:OnRemove()

	hook.Remove( MP.EVENTS.VOLUME_CHANGED, self )

end

derma.DefineControl( "MP.VolumeControl", "", PANEL, "DPanel" )


local VOLUME_BUTTON = {}

function VOLUME_BUTTON:Init()

	self.BaseClass.Init( self )

	self:SetIcon( 'mp-volume' )
	self:SetSize( 18, 17 )

end

function VOLUME_BUTTON:DoClick()

	MediaPlayer.ToggleMute()

end

derma.DefineControl( "MP.VolumeButton", "", VOLUME_BUTTON, "MP.SidebarButton" )


local VOLUME_SLIDER = {}

VOLUME_SLIDER.BarHeight = 3
VOLUME_SLIDER.KnobSize = 12

VOLUME_SLIDER.BarBgColor = Color( 13, 41, 62 )

VOLUME_SLIDER.ScrollIncrement = 0.1 -- out of 1

function VOLUME_SLIDER:Init()

	self.BaseClass.Init( self )

	self.Knob:SetSize( self.KnobSize, self.KnobSize )
	self.Knob.Paint = self.PaintKnob

	-- Remove some hidden panel child from the inherited DSlider control; I have
	-- no idea where it's being created...
	for _, child in pairs( self:GetChildren() ) do
		if child ~= self.Knob then
			child:Remove()
		end
	end

end

function VOLUME_SLIDER:Paint( w, h )

	local progress = self.m_fSlideX
	local vmid = ceil((h / 2) - (self.BarHeight / 2))

	surface.SetDrawColor( self.BarBgColor )
	surface.DrawRect( 0, vmid, w, self.BarHeight )

	surface.SetDrawColor( color_white )
	surface.DrawRect( 0, vmid, ceil(w * progress), self.BarHeight )

end

function VOLUME_SLIDER:PaintKnob( w, h )

	draw.RoundedBoxEx( ceil(w/2), 0, 0, w, h, color_white, true, true, true, true )

end

function VOLUME_SLIDER:SetSlideX( value )

	if self._lockVolume then return end

	value = clamp(value, 0, 1)

	self.m_fSlideX = value
	self:InvalidateLayout()

	self._lockVolume = true
	MediaPlayer.Volume( value )
	self._lockVolume = nil

end

function VOLUME_SLIDER:OnMouseWheeled( delta )

	local change = self.ScrollIncrement * delta
	local value = clamp(self.m_fSlideX + change, 0, 1)

	self:SetSlideX( value )

end

derma.DefineControl( "MP.VolumeSlider", "", VOLUME_SLIDER, "DSlider" )


local REPEAT_BTN = {}

function REPEAT_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-repeat" )
	self:SetTooltip( "Repeat" )
end

function REPEAT_BTN:DoClick()
	self.BaseClass.DoClick( self )
	hook.Run( MP.EVENTS.UI.TOGGLE_REPEAT )
end

derma.DefineControl( "MP.RepeatButton", "", REPEAT_BTN, "MP.SidebarToggleButton" )


local SHUFFLE_BTN = {}

function SHUFFLE_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-shuffle" )
	self:SetTooltip( "Shuffle" )
end

function SHUFFLE_BTN:DoClick()
	self.BaseClass.DoClick( self )
	hook.Run( MP.EVENTS.UI.TOGGLE_SHUFFLE )
end

derma.DefineControl( "MP.ShuffleButton", "", SHUFFLE_BTN, "MP.SidebarToggleButton" )


local LOCK_BTN = {}

function LOCK_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-lock-open" )
	self:SetTooltip( "Toggle Queue Lock" )
end

function LOCK_BTN:DoClick()
	self.BaseClass.DoClick( self )

	hook.Run( MP.EVENTS.UI.TOGGLE_LOCK )
	self:UpdateIcon()
end

function LOCK_BTN:SetEnabled( bEnabled )
	self.BaseClass.SetEnabled( self, bEnabled )
	self:UpdateIcon()
end

function LOCK_BTN:UpdateIcon()
	local icon = self:GetEnabled() and "mp-lock" or "mp-lock-open"
	self:SetIcon( icon )
end

derma.DefineControl( "MP.LockButton", "", LOCK_BTN, "MP.SidebarToggleButton" )

--PATH lua/mp_menu/horizontal_list.lua:
local PANEL = {}

function PANEL:Init()
	DPanelList.Init( self )

	self:EnableVerticalScrollbar( false )
	self:EnableHorizontal( true )
	self:SetAutoSize( true )
end

function PANEL:Rebuild()

	local OffsetX, OffsetY = 0, 0
	self.m_iBuilds = self.m_iBuilds + 1;

	self:CleanList()

	if ( self.Horizontal ) then

		local x, y = self.Padding, self.Padding;
		for k, panel in pairs( self.Items ) do

			if ( panel:IsVisible() ) then

				local OwnLine = (panel.m_strLineState and panel.m_strLineState == "ownline");

				local w = panel:GetWide()
				local h = panel:GetTall()

				local breakLine = ( not self.m_bSizeToContents and
					( x > self.Padding ) and
					(x + w > self:GetWide() or OwnLine) )

				if breakLine then

					x = self.Padding
					y = y + h + self.Spacing

				end

				if ( self.m_fAnimTime > 0 and self.m_iBuilds > 1 ) then
					panel:MoveTo( x, y, self.m_fAnimTime, 0, self.m_fAnimEase )
				else
					panel:SetPos( x, y )
				end

				x = x + w + self.Spacing

				OffsetX = x
				OffsetY = y + h + self.Spacing

				if ( OwnLine ) then

					x = self.Padding
					y = y + h + self.Spacing

				end

			end

		end

	else

		for k, panel in pairs( self.Items ) do

			if ( panel:IsVisible() ) then

				if ( self.m_bNoSizing ) then
					panel:SizeToContents()
					if ( self.m_fAnimTime > 0 and self.m_iBuilds > 1 ) then
						panel:MoveTo( (self:GetCanvas():GetWide() - panel:GetWide()) * 0.5, self.Padding + OffsetY, self.m_fAnimTime, 0, self.m_fAnimEase )
					else
						panel:SetPos( (self:GetCanvas():GetWide() - panel:GetWide()) * 0.5, self.Padding + OffsetY )
					end
				else
					panel:SetSize( self:GetCanvas():GetWide() - self.Padding * 2, panel:GetTall() )
					if ( self.m_fAnimTime > 0 and self.m_iBuilds > 1 ) then
						panel:MoveTo( self.Padding, self.Padding + OffsetY, self.m_fAnimTime, self.m_fAnimEase )
					else
						panel:SetPos( self.Padding, self.Padding + OffsetY )
					end
				end

				-- Changing the width might ultimately change the height
				-- So give the panel a chance to change its height now,
				-- so when we call GetTall below the height will be correct.
				-- True means layout now.
				panel:InvalidateLayout( true )

				OffsetY = OffsetY + panel:GetTall() + self.Spacing

			end

		end

		OffsetY = OffsetY + self.Padding

	end

	self:GetCanvas():SetWide( OffsetX + self.Padding - self.Spacing )
	self:GetCanvas():SetTall( OffsetY + self.Padding - self.Spacing )

	-- Although this behaviour isn't exactly implied, center vertically too
	if ( self.m_bNoSizing and self:GetCanvas():GetTall() < self:GetTall() ) then
		self:GetCanvas():SetPos( 0, (self:GetTall()-self:GetCanvas():GetTall()) * 0.5 )
	end

end

function PANEL:PerformLayout()

	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	if self.VBar and not m_bSizeToContents then

		self.VBar:SetPos( self:GetWide() - 13, 0 )
		self.VBar:SetSize( 13, self:GetTall() )
		self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
		YPos = self.VBar:GetOffset()

		if ( self.VBar.Enabled ) then Wide = Wide - 13 end

	end

	if self:GetAutoSize() then

		self:SetWide( self.pnlCanvas:GetWide() )
		self:SetTall( self.pnlCanvas:GetTall() )
		self.pnlCanvas:SetPos( 0, 0 )

	else

		self.pnlCanvas:SetPos( 0, YPos )
		self.pnlCanvas:SetWide( Wide )

	end

end

derma.DefineControl( "DHorizontalList", "", PANEL, "DPanelList" )

--PATH lua/autorun/medic.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/autorun/mpowers_loader.lua:
local addonpath = "memetispowers/"

if SERVER then
    local function RecursionServerLoader(path)
        path = path or addonpath
        local files,folders = file.Find(path .. "*","LUA")
        if files then
            for _,v in pairs(files) do
                if string.StartWith(v, "sh_") then
                    include(path  ..  v)
                    AddCSLuaFile(path  ..  v)
                elseif string.StartWith(v, "sv_") then
                    include(path  ..  v)
                elseif string.StartWith(v, "cl_") then
                    AddCSLuaFile(path .. v)
                end
                print("[Memeti's LSCS Powers] Loaded file " .. v)
            end
        end

        if folders then
            for _,v in pairs(folders) do
                RecursionServerLoader(path .. v .. "/")
            end
        end
    end
    RecursionServerLoader()
    print("[Memeti's LSCS Powers] Serverside Loaded!")
else
    local function RecursionClientLoader(path)
        path = path or addonpath
        local files,folders = file.Find(path .. "*","LUA")
        if files then
            for _,v in pairs(files) do
                if string.StartWith(v, "sh_") or string.StartWith(v, "cl_") then
                    include(path .. v)
                end
                print("[Memeti's LSCS Powers] Loaded file " .. v)
            end
        end

        if folders then
            for _,v in pairs(folders) do
                RecursionClientLoader(path .. v .. "/")
            end
        end
    end
    RecursionClientLoader()
    print("[Memeti's LSCS Powers] Clientside Loaded!")
end
--PATH addons/[miecze] moce i hilty/lua/memetispowers/sh_rebuke.lua:
hook.Add("EntityTakeDamage", "lscs_rebuke_hook", function(ply, dmginfo)
	if not IsValid(ply) or not ply:IsPlayer() then return end
	if ply:GetNWFloat("lscs_rebuke", 0) < CurTime() then return end

	local damage = dmginfo:GetDamage()
	local attacker = dmginfo:GetAttacker()
	local blockpercent = 0.5

	dmginfo:ScaleDamage(1 - blockpercent)
	if not IsValid(attacker) or dmginfo:IsFallDamage() then return end
	attacker:TakeDamage(damage * blockpercent, ply, ply)
end)
--PATH addons/[miecze] moce i hilty/lua/memetispowers/client/cl_holo.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/autorun/msd_autorun.lua:
-- ┏━┓┏━┳━━━┳━━━┓───────────────────────
-- ┃┃┗┛┃┃┏━┓┣┓┏┓┃───────────────────────
-- ┃┏┓┏┓┃┗━━┓┃┃┃┃──By MacTavish <3──────
-- ┃┃┃┃┃┣━━┓┃┃┃┃┃───────────────────────
-- ┃┃┃┃┃┃┗━┛┣┛┗┛┃───────────────────────
-- ┗┛┗┛┗┻━━━┻━━━┛───────────────────────

-- MIT License

-- Copyright (c) 2021 Ayden Mactavish

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

if MSD and MSD.Version ~= "1.0.2" then MsgC( Color(255, 8, 0), "[MSD] Another version of MSD detacted\n" ) return end

MSD = {}
MSD.Version = "1.0.2"
MSD.Config = {}
MSD.Modules = {}
MSD.ModuleIds = {}
MSD.Language = {}

if SERVER then
	util.AddNetworkString( "MSD.GetConfigData" )
	util.AddNetworkString( "MSD.SaveConfig" )
end

function MSD.Load()
	MsgC( Color(174, 0, 255), "[MSD] Initialization started\n" )
	if !file.Exists("msd_data", "DATA") then
		file.CreateDir("msd_data")
		MsgC( Color(174, 0, 255), "[MSD] Server DATA Dir created \n" )
	end

	MsgC( Color(174, 0, 255), "[MSD] Initialization started\n" )

	if SERVER then
		include("msd/sh_config.lua")
		include("msd/sh_language.lua")
		AddCSLuaFile("msd/sh_config.lua")
		AddCSLuaFile("msd/sh_language.lua")

		local f = file.Find( "msd/ui/*", "LUA" )
		for k,v in ipairs( f ) do
			AddCSLuaFile( "msd/ui/" .. v )
		end

	else
		include("msd/sh_config.lua")
		include("msd/sh_language.lua")

		local f = file.Find( "msd/ui/*", "LUA" )
		for k,v in ipairs( f ) do
			include( "msd/ui/" .. v )
		end

		list.Set( "DesktopWindows", "MSDModulesSetup", {
			title		= "Setup Menu",
			icon		= "msd/macnco.png",
			width		= 960,
			height		= 700,
			onewindow	= true,
			init		= function( icon, window )
				window:Close()
				icon.Window = MSD.OpenMenuManager(g_ContextMenu)
			end
		} )
	end


	MsgC( Color(174, 0, 255), "[MSD] Initialization done\n" )
end

MSD.Load()
--PATH addons/[ui] msd_ui/lua/msd/sh_config.lua:
-- ┏━┓┏━┳━━━┳━━━┓───────────────────────
-- ┃┃┗┛┃┃┏━┓┣┓┏┓┃───────────────────────
-- ┃┏┓┏┓┃┗━━┓┃┃┃┃──By MacTavish <3──────
-- ┃┃┃┃┃┣━━┓┃┃┃┃┃───────────────────────
-- ┃┃┃┃┃┃┗━┛┣┛┗┛┃───────────────────────
-- ┗┛┗┛┗┻━━━┻━━━┛───────────────────────
-- MIT License
-- Copyright (c) 2021 Ayden Mactavish
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

MSD.Config.Language = "en"
MSD.Config.Rounded = 8
MSD.Config.Blur = false
MSD.Config.Vignette = false
MSD.Config.BgrColor = Color(45, 45, 45)
MSD.Config.MainColor = {
	["p"] = Color(0, 155, 255),
	["r"] = Color(255, 0, 0),
	["rd"] = Color(220, 0, 0),
}

-- Util

function MSD.AddModule(name, menu, icon)
	local mod = {
		name = name,
		icon = icon,
		menu = menu
	}

	local id = MSD.ModuleIds[name]

	if id then
		MSD.Modules[id] = mod
	else
		id = table.insert(MSD.Modules, mod)
		MSD.ModuleIds[name] = id
	end

	return id
end

--──────────────────────────────────--
------------- CFG Saving -------------
--──────────────────────────────────--
net.Receive("MSD.GetConfigData", function(l, ply)
	if CLIENT then
		local config = net.ReadTable()
		MSD.Config = config
	else
		net.Start("MSD.GetConfigData")
		net.WriteTable(MSD.Config)
		net.Send(ply)
	end
end)

MSD.SaveConfig = function()
	if CLIENT then
		local json_data = util.TableToJSON(MSD.Config, false)
		local cd = util.Compress(json_data)
		local bn = string.len(cd)
		net.Start("MSD.SaveConfig")
			net.WriteInt(bn, 32)
			net.WriteData(cd, bn)
		net.SendToServer()
	else
		net.Start("MSD.GetConfigData")
		net.WriteTable(MSD.Config)
		net.Broadcast()
		json_table = util.TableToJSON(MSD.Config, true)
		file.Write("msd_data/config.txt", json_table)
	end
end

function MSD.LoadConfig()
	if CLIENT then
		net.Start("MSD.GetConfigData")
		net.SendToServer()
	end

	if SERVER then
		net.Receive("MSD.SaveConfig", function(l, ply)
			if MSD.cfgLastChange and MSD.cfgLastChange > CurTime() then return end
			MSD.cfgLastChange = CurTime() + 1
			if not ply:IsSuperAdmin() then return end
			local bytes_number = net.ReadInt(32)
			local compressed_data = net.ReadData(bytes_number)
			local json_data = util.Decompress(compressed_data)
			local config = util.JSONToTable(json_data)

			MSD.Config = config
			MSD.SaveConfig()
		end)

		if not file.Exists("msd_data/config.txt", "DATA") then
			json_table = util.TableToJSON(MSD.Config, true)
			file.Write("msd_data/config.txt", json_table)
		else
			local config = util.JSONToTable(file.Read("msd_data/config.txt", "DATA"))

			for k, v in pairs(config) do
				if MSD.Config[k] != nil then
					MSD.Config[k] = v
				end
			end
			if #player.GetAll() > 0 then
				net.Start("MSD.GetConfigData")
				net.WriteTable(MSD.Config)
				net.Broadcast()
			end
		end
	end
end

if SERVER then
	hook.Add("PostGamemodeLoaded", "MQMSDS.Load.SV", function()
		MSD.LoadConfig()
	end)
else
	hook.Add("InitPostEntity", "MSD.Load.CL", function()
		MSD.LoadConfig()
	end)
end

if GAMEMODE then
	MSD.LoadConfig()
end
--PATH addons/[ui] msd_ui/lua/msd/language/de.lua:
MSD.Language["de"] = {

	-- UI

	lang_name = "Deutsch",

	ok = "OK",
	map = "Karte",
	off = "Aus",
	on = "An",
	time_add = "Zeit zum Hinzufügen",
	type = "Typ",
	delay = "Verzögerung",
	cancel = "Abbrechen",
	enable = "Aktivieren",
	model = "Model",
	name = "Name",
	settings = "Einstellungen",
	editor = "Editor",
	red = "Rot",
	green = "Grün",
	blue = "Blau",
	admin_menu = "Administrationsmenü",
	ui_settings = "UI Einstellungen",
	active = "Aktiv",
	inactive = "Inaktiv",
	disabled = "Deaktiviert",
	warning = "Warnung!",
	remove = "Entfernen",
	theme = "Theme",
	dark_theme = "Dunkles Theme",
	payment = "Zahlung",
	load_autosave = "Letzte automatische Speicherung laden?",
	load_save = "Speicherung laden",
	create_new = "Neu erstellen",
	enable_option = "Option aktivieren",
	main_opt = "Hauptoptionen",
	copy_data = "Kopiere Daten",
	save_chng = "Speichere Änderungen",
	enter_name = "Gib den Namen ein",
	enter_id = "Gib die ID ein",
	confirm_action = "Bitte bestätige deine Aktion",
	check_fpr_errors = "Auf Fehler prüfen",
	enter_description = "Gib die Beschreibung ein",
	cooldown_ok = "Abklingzeit bei Erfolg",
	cooldown_fail = "Abklingzeit bei Fehlschlag",
	s_team_whitelist = "Team-Whitelist einrichten",
	whitelist_blacklist = "Die Whitelist als Blacklist benutzen",
	custom_val = "Setze spezifischen Wert",
	set_hp_full = "Setze volle HP",
	dist_to_close = "Distanz zum nächsten",

	e_text = "Text eingeben",
	e_number = "Nummer eingeben",
	e_class = "Klasse eingeben",
	e_value = "Wert eingeben",
	e_blank_dis = "Leer lassen, um es zu deaktiveren",
	e_blank_default = "Leer lassen, um Standard zu benutzen",
	e_url = "URL eingeben",
	e_model = "Modelpfad eingeben",
	e_material = "Materialpfad eingeben",
	e_wep_class = "Waffenklasse eingeben",
	e_ent_class = "Entityklasse eingeben",
	e_veh_class = "Fahrzeugklasse eingeben",
	e_npc_class = "NPC-Klasse eingeben",


	select_ammo = "Ausgewählte Munition",
	amount_ammo = "Munitionsmenge",
	disable_phys = "Physik deaktivieren",
	none = "Nichts",
	custom_icon = "Setzte eigenes Icon",
	weapon_name = "Waffenname",
	moveup = "Aufwärts bewegen",
	movedown = "Abwärts bewegen",
	movepoint = "Punkt bewegen",
	swap = "Tauschen",
	swapmod = "Tausch-Modus aktiviert. Klicke zum Deaktivieren",
	copy_from_ent = "Kopiere vom Entity",
	set_pos_self = "Zu deiner Position setzen",
	set_pos_aim = "Zu anvisiertem Punkt setzen",
	spawn_point = "Spawnpunkt",
	spawn_ang = "Spawnwinkel",
	mark_area = "Markiere Bereich",
	time_wait = "Zeit zum Warten",
	map_marker = "Wähle Map-Makierung aus",
	in_sec = "in Sekunden",
	def_units = "Standard %s Einheiten", -- "Default 350 units" leave %s as is
	def_seconds = "Standard %s Sekunden", -- "Default 10 seconds" leave %s as is
	ent_show_pointer = "Zeiger über dem Entity anzeigen",
	ent_arcade_style = "Erscheinungsbild des Entitys im Arcade-Stil",
	ent_stnd_style = "Standard Entity Erscheinungsbild",
	custom_color = "Aktiviere eigene Farbe",
	mat_default = "Leer lassen für Standardmaterial",


	set_ui = "UI Einstellungen",
	set_hud = "HUD Einstellungen",
	set_hud_pos = "Quest HUD Position",
	set_hud_themes = "HUD Themes",
	set_server = "Server Einstellungen",
	set_ui_blur = "Unscharfer Hintergrund",
	set_ui_mono = "Einfarbiger Hintergrund",
	set_ui_vignette = "Vignetteneffekt für den Hintergrund",
	set_ui_brightness = "Helligkeit des Hintergrunds",
	set_ui_color = "Wähle die Hauptfarbe",
	set_ui_align_left = "Horizontale Ausrichtung nach links",
	set_ui_align_right = "Horizontale Ausrichtung nach rechts",
	set_ui_align_top = "Vertikale Ausrichtung nach oben",
	set_ui_align_bottom = "Vertikale Ausrichtung nach unten",
	set_ui_offset_h = "Horizontaler Versatz",
	set_ui_offset_v = "Vertikaler Versatz",


	upl_changes = "Änderungen auf den Server hochladen",
	res_changes = "Änderungen wiederherstellen",


	-- Player


	dead = "Du bist tot",
	time_ex = "Zeit abgelaufen",
	vehicle_bum = "Dein Fahrzeug wurde zerstört",
	left_area = "Du hast den Bereich verlassen",
	m_blew = "Du hast die Mission gesprengt",
	m_failed = "Mission fehlgeschlagen",
	m_success = "Mission erfolgreich",
	m_loop = "Mission aktualisieren",

	-- Errors


	inv_quest = "Ungültige Quest",
	team_bl = "Dein Team ist auf der Blacklist",
	no_players = "Der Server benötigt mehr Spieler, die gleichzeitig online sind, bevor du fortfahren kannst.",
	no_players_team = "Der Server benötigt mehr Spieler, die gleichzeitig in spezifischen Teams online sind, bevor du fortfahren kannst.",
	need_admin = "Nur Admins können diese Aktion durchführen",


	-- Quests


	active_quest = "Du hast eine aktive Quest",
	inactive_quest = "Du kannst diese Quest nicht spielen",
	quest_editor = "Quest Editor",
	quest_list = "Quest Liste",
	quests = "Quests",
	leave_pnt = "Punkt zum Verlassen",


	q_editobj = "Objekte bearbeiten",
	q_incvobj = "Ungültige Objekte",
	q_setobj = "Objekt Einstellungen",
	q_newobj = "Neues Objekt hinzufügen",
	q_editrwd = "Belohnungen bearbeiten",
	q_rwdeditor = "Belohnungs Editor",
	q_rwdlist = "Belohnungsliste",
	q_rwdsets = "Belohnungseinstellungen",
	q_findmap = "Quests aus anderen Maps suchen",
	q_obj_des = "Objekt Beschreibung",
	q_dist_point = "Distanz zum Punkt",
	q_dist_from_point = "Distanz vom Punkt",
	q_ignore_veh = "Quest Fahrzeug ignorieren",
	q_timer_show = "Dem Spieler einen Timer anzeigen",
	q_area_stay = "Der Spieler muss im Bereich bleiben",
	q_start = "Quest starten",
	q_new = "Neue Quest",
	q_submit = "Quest abschicken",
	q_addnew = "Neue Quest hinzufügen",
	q_remove = "Quest entfernen",
	q_id_unique = "Die ID muss für jede Quest einzigartig sein",
	q_complete_msg = "Nachricht für fertiggestellte Quest",
	q_dotime = "Nachricht für fertiggestellte Quest",
	q_dotime_ok = "Schließe die Quest am Ende der Zeit ab",
	q_dotime_fail = "Scheitere an der Quest am Ende der Zeit",
	q_death_fail = "Scheitere die Quest beim Tod des Spielers",
	q_loop = "Schleifenaufgaben Quest",
	q_loop_reward = "Belohne Spieler bei jeder Wiederholung",
	q_enable = "Aktiviere Quest",
	q_events = "Events",
	q_eventadd = "Event hinzufügen",
	q_eventedit = "Event bearbeiten",
	q_eventremove = "Event entfernen",
	q_in_progress = "Quest in Bearbeitung",
	q_time_left = "Verbleibende Zeit",
	q_ply_limit = "Spielerlimit für die Quest",
	q_ply_team_limit = "Teamlimit einrichten",
	q_ply_team_need = "Benötigte Spieler im Team",
	q_ply_need = "Zum Starten benötigte Anzahl der Spieler",
	q_play_limit = "Es gibt ein Limit wie viele Spieler diese Quest spielen können",
	q_must_stay_area = "Du musst in diesem Bereich bleiben, oder die Quest wird fehlgeschlagen",
	q_time_wait = "Du musst warten bevor du die Quest wiederholen kannst",
	q_dotime_reset = "Zeit für die Quest zurücksetzen",
	q_dotime_add = "Zeit zur Quest hinzufügen",
	q_noreplay = "Du kannst diese Quest nicht wiederholen",
	q_dis_replay = "Wiederholung der Quest deaktivieren",
	q_needquest = "Du musst zuerst eine andere Quest abschließen",
	q_needquest_menu = "Benötigt abgeschlossene Quest",
	q_enterror = "Quest Entities sind nicht gespawnt, überprüfe die Einrichtung der Quest",
	q_get = "Du kannst eine Quest von diesen NPCs erhalten",
	q_noquests = "Es gibt noch keine Möglichkeit Quests zu spielen :(",
	q_ent_draw = "Quest Entity Drawdistanz",
	q_loop_stop_key = "Schleifenquest Stoptaste",
	q_hold_key_stop = "Um die Quest zu stoppen, halte [%s]", -- To stop quest hold [P]
	q_enter_veh = "Steig in dein Fahrzeug ein",
	q_npc_link = "Verlinke Quest zu einem NPC",
	q_icon68 = "Gib eine URL zu einem .PNG Bild mit 68x68px ein",
	q_ent_pos_show = "Zeige dem Spieler die Positionen der Entities",
	q_area_size = "Größe des Bereichs",
	q_area_pos = "Position des Bereichs",
	q_s_area_size = "Suche Größe des Bereichs",
	q_s_area_pos = "Suche Position des Bereichs",
	q_npc_answer_ok = "Positive Antwort des Spielers",
	q_npc_answer_no = "Negative Antwort des Spielers",
	q_npc_answer_noq = "Antwort des Spielers bei keiner Quest",
	q_npc_quest_no = "NPC Sprache bei keiner Quest",
	q_money_give = "Geld zum Geben",

	-- Simple NPCs

	npc_editor = "NPC ",
	npc_new = "Neuer NPC",
	npc_select = "Wähle einen NPC",
	npc_e_speech = "Gib NPC Sprache ein",
	npc_submit = "Bestätige NPC Erstellung",
	npc_update = "Aktualisiere NPC",
	npc_remove = "Entferne NPC",
	npc_q_enable = "Aktiviere Quest NPCs",
	npc_did_open = "Dialog ID zum Öffnen",
	npc_q_target = "NPC ist ein objektives Ziel",
	npc_hostile = "Feindlicher NPC",

		-- Update 1.1.0
	cam_start = "Startparameter der Kamera",
	cam_end = "Kamera-Endparameter",
	cam_pos = "Kamera Position",
	cam_ang = "Kamera Winkel",
	cam_fov = "Kamera-Sichtfeld",
	cam_effect = "Kameraverschluss-Effekt",
	q_open_target = "Erlaubt anderen Spielern NPCs zu töten",
	q_npc_mind = "Mindest Distanz zu NPCs",
	not_spawned = "nicht gespawnt",
	dis_text = "Angezeigter Text",
	cam_speed = "Kamerabewegungsgeschwindigkeit (niedrigere Zahl - langsamere Bewegung)",
	fov_speed = "FOV-Wechselgeschwindigkeit (niedrigere Zahl - langsamere Bewegung)",
	category_des = "Questkategorie, wird verwendet, um Quests zu sortieren",
	sortquests_cat = "Quests nach Kategorie sortieren",
	search_q = "Suche nach Quests",
	quest_tools = "Quest Tools",
	set_anim = "Animation einstellen",
	s_quest_blacklist = "Quest-Blacklist einrichten",
	s_quest_blacklist_desc = "Wählen Sie Quests aus, die diese Quest blockieren, wenn Sie sie gespielt haben",
	hold_use = "Halten sie [%s] gedrückt",
	duplicate = "Duplizieren",
	unsorted = "Unsortiert",
	search = "Suche",
	duration = "Dauer",
	category = "Kategorie",
	blacklist = "Blacklist",


	--  Update 1.2.0

	restore_wep = "Stellen Sie Waffen am Questende wieder her",
	e_cmd = "Geben sie eine Konsolen Kommand ein",
	e_args = "Enter command arguments",
	hint_cmd = "Verknüpfungen zum automatischen Ausfüllen: \n$uid - UserID, \n$sid - SteamID, \n$s64 - SteamID 64, \n$n - Spielername",
	youaretracked = "Deine Positon ist nun für alle Sichtbar.",
	border_rounded = "Abgerundetes Border desgin",
	border_square = "Quadrat border design",
	access_settings = "Menüzugriff",
	compact_obj = "Kompakte Zielliste für Quests",
	e_usergroup = "Benutzergruppe eingeben",
	ug_isanadmin = "Diese Benutzergruppe hat bereits vollen Zugriff",
	find_player_id32 = "Finde Spielerdaten nach SteamID 32",
	user_data = "Benutzerdaten-Editor",
	access_editors = "Zugriff für Quest-Editoren festlegen",
	access_admins = "Vollzugriff einstellen",
	add_usergroup = "Benutzergruppe hinzufügen",
	edit_objmod = "Zielreihenfolge bearbeiten",
	editmod = "Bearbeitungsmodus",
	move = "Bewegen",
	q_errorloop = "Quest in einer Endlosschleife eingegeben",
	q_cooldow_perply = "Öffentlicher Cooldown-Timer",
	q_cooldow_publick = "Abklingzeit pro Spieler",
	q_stop_anytime = "Erlaube, die Quest manuell abzubrechen",
	quest_abandon = "Du hast die Quest abgebrochen",
	q_dotime_set = "Quest-Erledigungszeit einstellen",


	-- Ranks

	enter_path_or_url = "Geben sie einen Pfad oder eine URL ein",
	rank_edit = "Rang einstellen",
	rank_list = "Rang Liste",
	group_list = "Gruppen Liste",
	group_addnew = "Eine neue Gruppe hinzufügen",
	blank = "Leer",
	mrs_show_all = "Ränge allen Spielern anzeigen",
	mrs_show_team = "Ränge nur der Gruppe anzeigen",
	mrs_use_sn = "Kurze Rangnamen anzeigen",
	use_url = "URL verwenden",
	enter_srt_name = "Kurznamen eingeben",
	srt_name = "Kurzbezeichnung",
	mrs_prom_demote = "Die nächsten 2 Optionen betreffen nur niedrigere Ränge. Spieler mit diesem Rang können keine anderen Spieler auf höhere Ränge oder den gleichen Rang befördern.",
	mrs_whilelist = "Wenn Sie eine Ranganforderung für einen Job auswählen, kann der Spieler diesen Job nur spielen, wenn sein Rang dem gewählten Rang entspricht oder höher ist.",
	can_promote = "Kann den Spielerrang erhöhen",
	can_demote = "Kann den Spielerrang zurückstufen",
	edit_player_model = "Benutzerdefiniertes Spielermodell bearbeiten",
	enable_player_model = "Benutzerdefiniertes Spielermodell aktivieren",
	disable_player_model = "Benutzerdefiniertes Spielermodell deaktivieren",
	edit_custom_stats = "Benutzerdefinierte Spielerstatistiken bearbeiten",
	autoprom = "Automatische Beförderung zum nächsten Rang",
	in_min = "in Minuten",
	mrs_promoted = "Sie sind befördert worden",
	mrs_demoted = "Sie sind degradiert worden",
	mrs_job_smallrank = "Du musst %s oder höher sein, um als %s zu spielen", -- You must be Sergeant II or higher to play as Watch Commander
	show_group = "Ranggruppenname anzeigen",
	hide_rank = "Nur Rangsymbol anzeigen",
	mrs_hud_follow = "Drehen der Benutzeroberfläche um den Spieler je nach Blickwinkel",
	set_overhead = "Spieler-Info UI",
	offline_users = "Offline-Benutzer",
	mrs_noranks = "Ihr derzeitiger Arbeitsplatz hat keine Dienstgrade",
	mrs_nopower = "Ihr aktueller Rang hat keine zusätzlichen Berechtigungen",
	promotion = "Beförderung",
	on_duty = "Im Dienst",
	other_players = "Andere Spieler",
	mrs_change_jobname = "Jobname in den Rangnamen ändern",
	mrs_set_prefix = "Fügen Sie den Namen des Dienstgrads als Präfix zum Jobnamen hinzu.",
	copy_all_data = "Alle Daten kopieren",
	copy_only_stats = "Nur Statistiken und Spielermodell kopieren",
}


-- Other phrases
local lng = "de"


MSD.Language[lng]["Move to point"] = "Zum Punkt bewegen"
MSD.Language[lng]["Leave area"] = "Verlasse Bereich"
MSD.Language[lng]["Kill NPC"] = "Töte NPC"
MSD.Language[lng]["Collect quest ents"] = "Sammle Quest Gegenstände"
MSD.Language[lng]["Talk to NPC"] = "Spreche mit dem NPC"


MSD.Language[lng]["There is no quests avalible"] = "Es sind keine Quests verfügbar"


MSD.Language[lng]["Give weapon"] = "Gebe Waffe"
MSD.Language[lng]["Give ammo"] = "Gebe Munition"
MSD.Language[lng]["Strip Weapon"] = "Nehme Waffe weg"
MSD.Language[lng]["Spawn quest entity"] = "Spawne Quest Gegenstand"
MSD.Language[lng]["Spawn entity"] = "Spawne Gegenstand"
MSD.Language[lng]["Spawn npc"] = "Spawne NPC"
MSD.Language[lng]["Manage do time"] = "Verwalte Do-Zeit"
MSD.Language[lng]["Spawn vehicle"] = "Spawne Fahrzeug"
MSD.Language[lng]["Remove vehicle"] = "Entferne Fahrzeug"
MSD.Language[lng]["Remove all entites"] = "Entferne alle Gegenstände"
MSD.Language[lng]["Set HP"] = "Setze HP"
MSD.Language[lng]["Set Armor"] = "Setze Rüstung"


MSD.Language[lng]["DarkRP Money"] = "DarkRP Geld"


MSD.Language[lng]["Quest NPCs are disabled"] = "Quest NPCs sind deaktiviert"
MSD.Language[lng]["You can enable them in settings"] = "Du kannst sie in den Einstellungen aktivieren"
MSD.Language[lng]["Wait time"] = "Wartezeit"
--PATH addons/[ui] msd_ui/lua/msd/language/en.lua:
MSD.Language["en"] = {

	lang_name = "English",

	ok = "OK",
	map = "Map",
	off = "Off",
	on = "On",
	time_add = "Time to add",
	type = "Type",
	delay = "Delay",
	cancel = "Cancel",
	enable = "Enable",
	model = "Model",
	name = "Name",
	settings = "Settings",
	editor = "Editor",
	red = "Red",
	green = "Green",
	blue = "Blue",
	admin_menu = "Administration menu",
	ui_settings = "UI Settings",
	active = "Active",
	inactive = "Inactive",
	disabled = "Disabled",
	warning = "Warning!",
	remove = "Remove",
	theme = "Theme",
	dark_theme = "Dark theme",
	payment = "Payment",
	load_autosave = "Load last autosave?",
	load_save = "Load save",
	create_new = "Create new",
	enable_option = "Enable option",
	main_opt = "Main options",
	copy_data = "Copy data",
	save_chng = "Save changes",
	enter_name = "Enter the name",
	enter_id = "Enter the ID",
	confirm_action = "Please confirm your actions",
	check_fpr_errors = "Check for errors",
	enter_description = "Enter description",
	cooldown_ok = "Cooldown on success",
	cooldown_fail = "Cooldown on fail",
	s_team_whitelist = "Setup team whitelist",
	whitelist_blacklist = "The whitelist is a blacklist",
	custom_val = "Set custom value",
	set_hp_full = "Set full HP",
	dist_to_close = "Distance to closest",

	e_text = "Enter text",
	e_number = "Enter number",
	e_class = "Enter class",
	e_value = "Enter value",
	e_blank_dis = "Leave blank to disable",
	e_blank_default = "Leave blank to use default",
	e_url = "Enter URL",
	e_model = "Enter model path",
	e_material = "Enter material path",
	e_wep_class = "Enter weapon class",
	e_ent_class = "Enter entity class",
	e_veh_class = "Enter vehicle class",
	e_npc_class = "Enter NPC class",

	select_ammo = "Selected ammo",
	amount_ammo = "Ammo amount",
	disable_phys = "Disable physics",
	none = "None",
	custom_icon = "Set custom icon",
	weapon_name = "Weapon name",
	moveup = "Move up",
	movedown = "Move down",
	movepoint = "Move point",
	swap = "Swap",
	swapmod = "Swap mod enabled. Click to disable",
	copy_from_ent = "Copy from looking entity",
	set_pos_self = "Set to your position",
	set_pos_aim = "Set to looking poit",
	spawn_point = "Spawn point",
	spawn_ang = "Spawn angle",
	mark_area = "Mark area",
	time_wait = "Time to wait",
	map_marker = "Select map marker",
	in_sec = "in seconds",
	def_units = "Default %s units", -- "Default 350 units" leave %s as is
	def_seconds = "Default %s seconds", -- "Default 10 seconds" leave %s as is
	ent_show_pointer = "Show pointer above the entity",
	ent_arcade_style = "Arcade-style entity appearance",
	ent_stnd_style = "Standart entity appearance",
	custom_color = "Enable custom color",
	mat_default = "Leave blank for default material",

	set_ui = "UI settings",
	set_hud = "HUD settings",
	set_hud_pos = "Quest HUD position",
	set_hud_themes = "HUD Themes",
	set_server = "Server settings",
	set_ui_blur = "Blur background",
	set_ui_mono = "Monochrome background",
	set_ui_vignette = "Vignette effect for background",
	set_ui_brightness = "Background brightness",
	set_ui_color = "Select the main color",
	set_ui_align_left = "Horizontal alignment to the left",
	set_ui_align_right = "Horizontal alignment to the right",
	set_ui_align_top = "Vertical alignment to the top",
	set_ui_align_bottom = "Vertical alignment to the bottom",
	set_ui_offset_h = "Horizontal Offset",
	set_ui_offset_v = "Vertical Offset",

	upl_changes = "Upload changes to server",
	res_changes = "Restore changes",

	-- Player

	dead = "You are dead",
	time_ex = "Time expired",
	vehicle_bum = "Your vehicle is destroyed",
	left_area = "You left the area",
	m_blew = "You blew up the mission",
	m_failed = "Mission failed",
	m_success = "Mission success",
	m_loop = "Mission update",

	-- Errors

	inv_quest = "Invalid quest",
	team_bl = "Your team is blacklisted",
	no_players = "Server needs more players to be online before you can do this",
	no_players_team = "Server needs more players for specific team(s) to be online before you can do this",
	need_admin = "Only admins can do this action",

	-- Quests

	active_quest = "You have an active quest",
	inactive_quest = "You can't play this quest",
	quest_editor = "Quest Editor",
	quest_list = "Quest List",
	quests = "Quests",
	leave_pnt = "Leave point",

	q_editobj = "Edit objectives",
	q_incvobj = "Invalid objective",
	q_setobj = "Objective settings",
	q_newobj = "Add new objective",
	q_editrwd = "Edit rewards",
	q_rwdeditor = "Reward Editor",
	q_rwdlist = "Reward List",
	q_rwdsets = "Reward Settings",
	q_findmap = "Find quest from other maps",
	q_obj_des = "Objecive description",
	q_dist_point = "Distance to point",
	q_dist_from_point = "Distance from point",
	q_ignore_veh = "Ignore quest vehicle",
	q_timer_show = "Show the timer to player",
	q_area_stay = "Player must stay in area",
	q_start = "Start Quest",
	q_new = "New quest",
	q_submit = "Submit quest",
	q_addnew = "Add new quest",
	q_remove = "Remove quest",
	q_id_unique = "ID must be unique for each quest",
	q_complete_msg = "Quest complete message",
	q_dotime = "Quest do time",
	q_dotime_ok = "Succeed quest on time end",
	q_dotime_fail = "Fail quest on time end",
	q_death_fail = "Fail quest on player death",
	q_loop = "Loop quest tasks",
	q_loop_reward = "Reward player on each loop",
	q_enable = "Enable quest",
	q_events = "Events",
	q_eventadd = "Add Event",
	q_eventedit = "event edit",
	q_eventremove = "Remove event",
	q_in_progress = "Quest in progress",
	q_time_left = "Time left",
	q_ply_limit = "Player limit for the quest",
	q_ply_team_limit = "Setup team limits",
	q_ply_team_need = "Needed team players",
	q_ply_need = "Player amount needed to start",
	q_play_limit = "There is a limit on how much players can play this quest",
	q_must_stay_area = "You must stay inside this area, or quest will be failed",
	q_time_wait = "You need to wait before replaying this quest",
	q_dotime_reset = "Reset quest do time",
	q_dotime_add = "Add quest do time",
	q_noreplay = "You can't replay this quest",
	q_dis_replay = "Disable quest replay",
	q_needquest = "You need to finish another quest first",
	q_needquest_menu = "Require completed quest",
	q_enterror = "Quest entities didn't spawn, check quest setup",
	q_get = "You can get a quest from these NPCs",
	q_noquests = "There is no way to play quests yet :(",
	q_ent_draw = "Quest entity draw distance",
	q_loop_stop_key = "Looped quest stop key",
	q_hold_key_stop = "To stop quest hold [%s]", -- To stop quest hold [P]
	q_enter_veh = "Enter your vehicle",
	q_npc_link = "Link quest to an NPC",
	q_icon68 = "Enter url to .PNG icon 68x68 px",
	q_ent_pos_show = "Show entities location to the player",
	q_area_size = "Area size",
	q_area_pos = "Area postition",
	q_s_area_size = "Search area size",
	q_s_area_pos = "Search area postition",
	q_npc_answer_ok = "Player's positive answer",
	q_npc_answer_no = "Player's negative answer",
	q_npc_answer_noq = "Player's answer if no quests",
	q_npc_quest_no = "NPC speech if no quests",
	q_money_give = "Money to give",

	-- Simple NPCs

	npc_editor = "NPC Editor",
	npc_new = "New NPC",
	npc_select = "Select an NPC",
	npc_e_speech = "Enter NPC speech",
	npc_submit = "Confirm NPC creation",
	npc_update = "Update NPC",
	npc_remove = "Remove NPC",
	npc_q_enable = "Enable quest NPCs",
	npc_did_open = "Dialog ID to open",
	npc_q_target = "NPC is an objective target",
	npc_hostile = "Hostile NPC",


	-- Update 1.1.0

	cam_start = "Camera start parameters",
	cam_end = "Camera end parameters",
	cam_pos = "Camera position",
	cam_ang = "Camera angle",
	cam_fov = "Camera FOV",
	cam_effect = "Camera shutter effect",
	q_open_target = "Allow other players to kill NPCs",
	q_npc_mind = "Min. distance to NPCs",
	not_spawned = "not spawned",
	dis_text = "Displayed text",
	cam_speed = "Camera movement speed (lower number - slower movement)",
	fov_speed = "FOV change speed (lower number - slower movement)",
	category_des = "Quest category, used to sort quests",
	sortquests_cat = "Sort quests by category",
	search_q = "Search quests",
	quest_tools = "Quest tools",
	set_anim = "Set Animation",
	s_quest_blacklist = "Setup quest blacklist",
	s_quest_blacklist_desc = "Select quests that will block this quest if you played them",
	hold_use = "Hold [%s] key",
	duplicate = "Duplicate",
	unsorted = "Unsorted",
	search = "Search",
	duration = "Duration",
	category = "Category",
	blacklist = "Blacklist",


	--  Update 1.2.0

	restore_wep = "Restore weapons on quest end",
	e_cmd = "Enter console command",
	e_args = "Enter command arguments",
	hint_cmd = "Autofill shortcuts: \n$uid - UserID, \n$sid - SteamID,  \n$s64 - SteamID 64, \n$n - Player name",
	youaretracked = "Your position is now compromised to other players!",
	border_rounded = "Rounded border design",
	border_square = "Square border design",
	access_settings = "Menu access",
	compact_obj = "Compact objective list for quests",
	e_usergroup = "Enter user group",
	ug_isanadmin = "This user group already has full access",
	find_player_id32 = "Find player data by SteamID 32",
	user_data = "User data editor",
	access_editors = "Set quest editors access",
	access_admins = "Set full access",
	add_usergroup = "Add user group",
	edit_objmod = "Edit objective order",
	editmod = "Edit mode",
	move = "Move",
	q_errorloop = "Quest entered in an endless loop",
	q_cooldow_perply = "Public cooldown timer",
	q_cooldow_publick = "Per-Player cooldown timer",
	q_stop_anytime = "Allow to abandon quest manually",
	quest_abandon = "You abandoned the quest",
	q_dotime_set = "Set quest do time",

	-- Ranks

	enter_path_or_url = "Enter path or url",
	rank_edit = "Ranks setup",
	rank_list = "Ranks list",
	group_list = "Group list",
	group_addnew = "Add new group",
	blank = "Blank",
	mrs_show_all = "Show ranks to all players",
	mrs_show_team = "Show ranks only to the group",
	mrs_use_sn = "Display short rank names",
	use_url = "Use URL",
	enter_srt_name = "Enter short name",
	srt_name = "Short name",
	mrs_prom_demote = "The next 2 options affect only lower ranks. Players with this rank will not be able to promote other players to higher ranks or the same rank.",
	mrs_whilelist = "If you select rank requirement for a job, the player will be able to play this job only if his rank matches the chosen one or higher.",
	can_promote = "Can promote player rank",
	can_demote = "Can demote player rank",
	edit_player_model = "Edit custom player model",
	enable_player_model = "Enable custom player model",
	disable_player_model = "Disable custom player model",
	edit_custom_stats = "Edit custom player stats",
	autoprom = "Auto promote to next rank",
	in_min = "in minutes",
	mrs_promoted = "You have been promoted",
	mrs_demoted = "You have been demoted",
	mrs_job_smallrank = "You must be %s or higher to play as %s", -- You must be Sergeant II or higher to play as Watch Commander
	show_group = "Display rank group name",
	hide_rank = "Display only rank icon",
	mrs_hud_follow = "Rotate UI around player depending on view angle",
	set_overhead = "Player info UI",
	offline_users = "Offline users",
	mrs_noranks = "Your current job has no ranks",
	mrs_nopower = "Your current rank has no extra permissions",
	promotion = "Promotion",
	on_duty = "On Duty",
	other_players = "Other players",
	mrs_change_jobname = "Change job name to the rank name",
	mrs_set_prefix = "Add the rank name as a prefix to the job name",
	copy_all_data = "Copy all data",
	copy_only_stats = "Copy only stats and player model",
	mrs_change_plyname = "Change player name to the rank name",
	mrs_set_prefix_ply = "Add the rank name as a prefix to the player name",

	promote_limit = "Promotion limitationn",
	demote_limit = "Demotion limitation",
	salary_value = "Salary value",
	salary_set = "Set given value as a salary",
	salary_add = "Add given value on top of salary",
	salary_multiply = "Multiply salary by given value",
	force_team = "Force change team to",
	mrs_hud_3d2d = "Use 3D2D hud for players",
	mrs_chat_command = "Chat command to open the Rank menu",
	mrs_promote_command = "Chat command to promote a player",
	mrs_demote_command = "Chat command to demote a player",

	mqs_fix_cam = "Fix Cinematic Camera event (toggle only if needed)",
	add_new_spawn = "Add new spawn point",
	remove_all_spawn = "Remove all spawn point",
	nolongertracked = "You are no longer tracked by other players",
	target = "Target",
	kill_player = "Kill Player",
	kill_amount = "Amount of targets to kill",
	into_quest = "Introduction quest",
	into_quest_auto = "Force player to play introduction quest",
	into_quest_start = "To strat quest hold [%s]",
	set_ui_align_center = "Horizontal alignment to the center",
	icon_size = "Icon size",
	icon_right = "Icon alignment to the right",
	font_size = "Font size",
	rank_hide = "Do not display this rank on the HUD",
	action_select = "Select an action",
	action_set_rank = "Set rank to selected, only if current rank is lower",
	action_set_rank_force = "Set rank to selected, anyway",
	action_promote_rank = "Promote only by one rank, selected rank is maximum",
	action_demote_rank = "Demote by one rank, selected rank is minimum",
	rank = "Rank",
	format = "Format",
	file_list = "File list",
	file_exist = "This save file is already exist"
}

-- Other phrases
local lng = "en"

MSD.Language[lng]["Move to point"] = "Move to point"
MSD.Language[lng]["Leave area"] = "Leave area"
MSD.Language[lng]["Kill NPC"] = "Kill NPC"
MSD.Language[lng]["Collect quest ents"] = "Collect quest ents"
MSD.Language[lng]["Talk to NPC"] = "Talk to NPC"
MSD.Language[lng]["There is no quests available"] = "There is no quests available"
MSD.Language[lng]["Give weapon"] = "Give weapon"
MSD.Language[lng]["Give ammo"] = "Give ammo"
MSD.Language[lng]["Strip Weapon"] = "Strip Weapon"
MSD.Language[lng]["Spawn quest entity"] = "Spawn quest entity"
MSD.Language[lng]["Spawn entity"] = "Spawn entity"
MSD.Language[lng]["Spawn npc"] = "Spawn npc"
MSD.Language[lng]["Manage do time"] = "Manage do time"
MSD.Language[lng]["Spawn vehicle"] = "Spawn vehicle"
MSD.Language[lng]["Remove vehicle"] = "Remove vehicle"
MSD.Language[lng]["Remove all entites"] = "Remove all entites"
MSD.Language[lng]["Set HP"] = "Set HP"
MSD.Language[lng]["Set Armor"] = "Set Armor"
MSD.Language[lng]["DarkRP Money"] = "DarkRP Money"
MSD.Language[lng]["Quest NPCs are disabled"] = "Quest NPCs are disabled"
MSD.Language[lng]["You can enable them in settings"] = "You can enable them in settings"
--PATH addons/[ui] msd_ui/lua/msd/ui/assets.lua:
return gluapack()()
--PATH lua/mvp/sh_init.lua:
return gluapack()()
--PATH lua/mvp/core/sh_types.lua:
return gluapack()()
--PATH lua/mvp/core/cl_fonts.lua:
return gluapack()()
--PATH lua/mvp/core/cl_fonts.lua:
mvp = mvp or {}
mvp.fonts = mvp.fonts or {}

mvp.fonts.list = mvp.fonts.list or {}

function mvp.fonts.Get(size, font, weight)
    local scale = mvp.ui.Scale(size)

    return mvp.fonts.GetUnscaled(scale, font, weight)
end

function mvp.fonts.GetUnscaled(size, font, weight)
    local fontName = font .. "_" .. size .. "_" .. weight

    if mvp.fonts.list[fontName] then
        return mvp.fonts.list[fontName]
    end

    local fontData = {
        font = font,
        size = size,
        weight = weight,
        extended = true,
        -- antialias = true,
    }

    surface.CreateFont(fontName, fontData)

    mvp.fonts.list[fontName] = fontName

    return fontName    
end

local weightToName = {
    [100] = "Proxima Nova Th",
    [200] = "Proxima Nova Lt",
    [300] = "Proxima Nova Lt",
    [400] = "Proxima Nova Rg",
    [500] = "Proxima Nova Rg",
    [600] = "Proxima Nova Semibold",
    [700] = "Proxima Nova Bold",
    [800] = "Proxima Nova Extrabold",
    [900] = "Proxima Nova Bl"
}

function mvp.Font(size, weight)
    return mvp.fonts.Get(size, weightToName[weight] or "Proxima Nova Rg", weight)
end
--PATH lua/mvp/packages/radialmenu/cl_credits.lua:
-- <a href="https://www.flaticon.com/free-icons/left-click" title="left click icons">Left click icons created by Smashicons - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/radialmenu/lmb.png", "smooth mips"), "Left mouse button", "Smashicons - Flaticon", "https://www.flaticon.com/authors/smashicons")

-- <a href="https://www.flaticon.com/free-icons/right-click" title="right click icons">Right click icons created by Smashicons - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/radialmenu/rmb.png", "smooth mips"), "Right mouse button", "Smashicons - Flaticon", "https://www.flaticon.com/authors/smashicons")
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/configs/perfecthands.lua:
local PERFECTHANDS_SECTION = mvp.config.RegisterSection("perfecthands")

local APPEARANCE_GROUP = mvp.config.RegisterCategory("appearance", PERFECTHANDS_SECTION, 1)

mvp.config.Add("phands.useIcons", true, {
    description = "If enabled, animations will be using icons, otherwise they will use text.",
    category = APPEARANCE_GROUP,

    ui = {}
}, 1)

mvp.config.Add("phands.useModels", false, {
    description = "If enabled, animations will be using player model, FPS heavy.",
    category = APPEARANCE_GROUP,

    ui = {}
}, 2)

mvp.config.Add("phands.iconsTheme", "clones2", {
    description = "Theme for the icons",
    category = APPEARANCE_GROUP,

    ui = {
        type = "dropdown",
        choices = function()
            local P = mvp.package.Get("perfecthands")
            local themes = P.themes.GetAll()

            local choices = {}
            for k, v in pairs(themes) do
                choices[k] = mvp.q.Lang("phands.themes." .. k)
            end

            return choices
        end
    }
}, 3)

mvp.config.Add("phands.hintMargin", 50, {
    description = "Controls the margin for the hint text.",
    category = APPEARANCE_GROUP,

    ui = {}
}, 4)

local ANIMATION_GROUP = mvp.config.RegisterCategory("animations", PERFECTHANDS_SECTION, 3)

mvp.config.Add("phands.useAnimations", true, {
    description = "Enable animation system.",
    category = ANIMATION_GROUP,

    ui = {}
}, 1)

mvp.config.Add("phands.animationAllowFreelook", true, {
    description = "Allow freelook while the animation is playing.",
    category = ANIMATION_GROUP,

    ui = {}
}, 2)

mvp.config.Add("phands.animationSpeed", 5, {
    description = "Controls how fast player's hands will move.",
    category = ANIMATION_GROUP,

    ui = {}
}, 3)

mvp.config.Add("phands.animationVelocityCutoff", 5, {
    description = "Controls the maximum velocity at which the animation will play. If the player's velocity is higher than this value, the animation will not play.",
    category = ANIMATION_GROUP,

    ui = {}
}, 4)

local INTERACTION_GROUP = mvp.config.RegisterCategory("interactions", PERFECTHANDS_SECTION, 4)

mvp.config.Add("phands.useInteractions", true, {
    description = "Enable interaction system.",
    category = INTERACTION_GROUP,

    ui = {}
}, 1)

mvp.config.Add("phands.interactionDistance", 100, {
    description = "Controls the maximum distance at which the player can interact with objects.",
    category = INTERACTION_GROUP,

    ui = {}
}, 2)

mvp.config.Add("phands.interactionWeightMultiplier", 1, {
    description = "Controls the weight multiplier for the interaction system. This will affect how heavy the objects feel when the player is holding them.",
    category = INTERACTION_GROUP,

    ui = {}
}, 3)
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/animations/cl_animations.lua:
local P = mvp.package.Get()

P.animations = P.animations or {}

local closestBone = nil
local closestBoneDist = 999999
function P.animations.Apply(ply, animationID, targetValue)
    if (not mvp.config.Get("phands.useAnimations")) then
        return
    end

    if (not IsValid(ply)) then
        return
    end
    if (not animationID) then
        return
    end

    if (not P.animations.Get(animationID)) then
        return
    end

    if (ply.mvp_phands_animation_progress ~= targetValue) then
        ply.mvp_phands_animation_progress = Lerp(FrameTime() * (mvp.config.Get("phands.animationSpeed", 5)), ply.mvp_phands_animation_progress, targetValue)
    end

    local oldAnimationID = ply.mvp_phands_animationID_old

    if (oldAnimationID ~= animationID and P.animations.Get(oldAnimationID)) then
       
        for boneName, _ in pairs(P.animations.Get(oldAnimationID)) do
            local bone = ply:LookupBone(boneName)

            if (not bone) then
                continue
            end

            ply:ManipulateBoneAngles(bone, Angle(0, 0, 0))
        end

        if (P.animations.Get(oldAnimationID)["Animation.ZOffset"]) then
            ply:ManipulateBonePosition(0, Vector(0, 0, 0))
        end
    end

    ply.mvp_phands_animationID_old = animationID

    for boneName, angles in pairs(P.animations.Get(animationID)) do
        local bone = ply:LookupBone(boneName)

        if (not bone) then
            continue
        end

        ply:ManipulateBoneAngles(bone, angles * ply.mvp_phands_animation_progress)
    end

    if (P.animations.Get(animationID)["Animation.ZOffset"]) then
        ply:ManipulateBonePosition(0, Vector(0, 0, P.animations.Get(animationID)["Animation.ZOffset"] * ply.mvp_phands_animation_progress))
    end
end

hook.Add("Think", "mvp.phands.ApplyAnimations", function()
    if (not mvp.config.Get("phands.useAnimations")) then
        return
    end

    for k, ply in ipairs(player.GetAll()) do
        if (not IsValid(ply)) then
            continue
        end
        if (ply:InVehicle()) then
            continue
        end

        local animationID = ply.mvp_phands_animationID

        if (animationID == nil) then
            continue
        end

        if (not ply.mvp_phands_animation_progress) then
            ply.mvp_phands_animation_progress = 0
        end

        if (ply.mvp_phands_animation_playing) then
            P.animations.Apply(ply, animationID, 1)
        else
            P.animations.Apply(ply, animationID, 0)
        end
    end
end)

function P.animations.CreateCamera()
    local ply = LocalPlayer()
    local cameraAng = ply:EyeAngles()
    local savedAng = nil

    local conX = 0
    local conY = -15
    local conZ = 0

    P.animations.cameraActive = true

    hook.Add("Think", "mvp.phands.CameraLook", function()
        if (not ply:Alive()) then
            P.animations.DestroyCamera()
            return
        end

        local weapon = ply:GetActiveWeapon()
        if (IsValid(weapon) and weapon:GetClass() ~= "mvp_perfecthands") then
            P.animations.DestroyCamera()
            return
        end

        local allowFreelook = mvp.config.Get("phands.animationAllowFreelook", true)

        if (allowFreelook and not ply:KeyDown(IN_RELOAD)) then
            if (savedAng) then
                cameraAng = savedAng
            end

            savedAng = nil
            return 
        end

        savedAng = savedAng or ply:EyeAngles()
        ply:SetEyeAngles(savedAng)
    end)
    
    hook.Add("CalcView", "!!!mvp.phands.AnimationView", function(ply, camPos, ang, fov, znear, zfar)
        if (not IsValid(ply) or not cameraAng) then
            return
        end
    
        local camTr = util.TraceLine({
            start = camPos,
            endpos = camPos + (cameraAng:Forward() * 9999),
            filter = ply
        })
    
        local trace = util.TraceHull({
            start = camPos,
            endpos = camPos - cameraAng:Forward() * (100 + conZ) - cameraAng:Right() * conX - cameraAng:Up() * conY,
            filter = { ply:GetActiveWeapon(), ply },
            mins = Vector(-6, -4, -4),
            maxs = Vector(6, 4, 4)
        })

        local pos

        if (trace.Hit) then
            pos = trace.HitPos
        else
            pos = camPos - cameraAng:Forward() * (100 + conZ)
            pos = pos - cameraAng:Right() * (conX)
            pos = pos - cameraAng:Up() * (conY)
        end

        ply:SetEyeAngles( (camTr.HitPos - ply:EyePos()):Angle() )

        return {
            fov = fov,
            drawviewer = true,
            origin = pos,
            angles = cameraAng
        }
    end)

    hook.Add("InputMouseApply", "mvp.phands.ModifyMouseInput", function(cmd, x, y, ang)
        if (not cameraAng) then
            cameraAng = Angle(0, 0, 0)
        end

        cameraAng.p = math.NormalizeAngle(cameraAng.p + y / 50)
        cameraAng.y = math.NormalizeAngle(cameraAng.y - x / 50)

        cameraAng.p = math.Clamp(cameraAng.p, -60, 80)

        return true
    end)
end

function P.animations.DestroyCamera()
    hook.Remove("CalcView", "!!!mvp.phands.AnimationView")
    hook.Remove("Think", "mvp.phands.CameraLook")
    hook.Remove("InputMouseApply", "mvp.phands.ModifyMouseInput")

    P.animations.cameraActive = false
end

net.Receive("mvp.phands.startAnimation", function()
    local anim = net.ReadString()
    local ply = net.ReadEntity()

    ply.mvp_phands_animationID = anim
    ply.mvp_phands_animation_playing = true

    if (ply == LocalPlayer()) then
        P.animations.CreateCamera()
    end
end)

net.Receive("mvp.phands.stopAnimation", function()
    local ply = net.ReadEntity()

    ply.mvp_phands_animation_playing = false

    local closestBone = nil
    local closestBoneDist = 999999

    if (ply == LocalPlayer()) then
        P.animations.DestroyCamera()
    end
end)
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/animations/sh_animations.lua:
return gluapack()()
--PATH lua/mvp/packages/simpledefcons/languages/ru.lua:
local l = {}

l["section.simpledefcons"] = "Simple DEFCONs"
l["section.simpledefcons.general"] = "Общее"
l["section.simpledefcons.appearance"] = "Внешний вид"

l["value.simpledefcons.timeOnScreen.description"] = "Время в секундах, в течение которого статус должен быть отображен, если к нему не прикреплен звук."
l["value.simpledefcons.defcons.description"] = "Список DEFCON. Каждый DEFCON имеет название и цвет."
l["value.simpledefcons.allowedJobs.description"] = "Список профессий, которым разрешено изменять базовый статус."

l["value.simpledefcons.showHUD.description"] = "Показывать статус базы на HUD."
l["value.simpledefcons.hudPosition.description"] = "Положение статуса базы на HUD."
l["value.simpledefcons.entityManagerModel.description"] = "Модель для энтити управление статусом на базе."
l["value.simpledefcons.entityDisplayModel.description"] = "Модель для энтити отображения статуса базы."

l["simpledefcons.configure_allowed_jobs"] = "Настройка профессий"
l["simpledefcons.search_jobs"] = "Поиск..."
l["simpledefcons.configure_defcons"] = "Настройка DEFCON"
l["simpledefcons.defcon_name"] = "Название DEFCON"
l["simpledefcons.defcon_color"] = "Цвет DEFCON"
l["simpledefcons.defcon_description"] = "Описание DEFCON"
l["simpledefcons.defcon_sound"] = "Звук DEFCON (необязательно)"

l["simpledefcons.set"] = "Установить"
l["simpledefcons.apply"] = "Применить"
l["simpledefcons.active"] = "Активен"
l["simpledefcons.attention"] = "ВНИМАНИЕ"
l["simpledefcons.base_status"] = "Статус базы"
l["simpledefcons.initiated_by"] = "{{color:Accent}}{{lang:simpledefcons.attention}}{{color:Text}} - {{color:%s}}%s{{color:Text}} был установлен {{color:%s}}%s{{color:Text}}!"

l["simpledefcons.managerEntity"] = "Управление статусом базы"
l["simpledefcons.managerEntity.description"] = "Управляет статусом на базе."

l["simpledefcons.displayEntity"] = l["simpledefcons.base_status"] .. ":"

mvp.language.Register("ru", l)

--PATH lua/mvp/core/gamemode/sh_gamemode.lua:
return gluapack()()
--PATH lua/mvp/vgui/cl_category_list.lua:
return gluapack()()
--PATH lua/mvp/vgui/cl_frame.lua:
local PANEL = {}

local titleFont = mvp.Font(32, 600)
local closeIcon = Material("mvp/terminal/close.png", "smooth mips")

local roundness = mvp.ui.ScaleWithFactor(16)

function PANEL:Init()
    self.top = vgui.Create("EditablePanel", self)
    self.top:Dock(TOP)
    self.top:DockMargin(0, 0, 0, 10)

    self.icon = vgui.Create("DPanel", self.top)
    self.icon:Dock(LEFT)
    self.icon:DockMargin(5, 5, 0, 5)

    self.icon.Paint = function(pnl, w, h)

        if (not self.iconData) then return end
        if (self.iconData.isGradient) then
            mvp.ui.DrawRoundedGradient( mvp.ui.ScaleWithFactor(8), 0, 0, w, h, self.iconData.bg.startCol, self.iconData.bg.endCol )
        else
            draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, self.iconData.bg)
        end
        -- mvp.ui.DrawRoundedGradient( mvp.ui.ScaleWithFactor(16), 0, 0, w, h, mvp.colors.Red, mvp.colors.Accent )

        surface.SetDrawColor(self.iconData.col)

        local iconSize = w - 18
        surface.SetMaterial(self.iconData.mat)
        surface.DrawTexturedRect(9, 9, iconSize, iconSize)

        return true
    end

    self.title = vgui.Create("DLabel", self.top)
    self.title:Dock(LEFT)
    self.title:DockMargin(5, 0, 0, 0)
    self.title:SetTextColor(mvp.colors.Text)
    self.title:SetFont(titleFont)
    self.title:SetContentAlignment(4)

    self.close = vgui.Create("DButton", self.top)
    self.close:Dock(RIGHT)
    self.close:DockMargin(0, 5, 5, 5)

    self.close.DoClick = function(pnl)
        self:Remove()
    end

    self.close.iconColor = Color(195, 195, 195)
    self.close.backgroundAlpha = 0
    
    self.close.Paint = function(pnl, w, h)
        draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.Red, pnl.backgroundAlpha), false, true, false, false)

        surface.SetDrawColor(pnl.iconColor)
        surface.SetMaterial(closeIcon)
        surface.DrawTexturedRect(12, 12, w - 24, h - 24)

        return true
    end

    self.close.OnCursorEntered = function(pnl)
        pnl:Lerp("backgroundAlpha", 255, 0.2)
        pnl:LerpColor("iconColor", color_white, 0.2)
    end

    self.close.OnCursorExited = function(pnl)
        pnl:Lerp("backgroundAlpha", 0, 0.2)
        pnl:LerpColor("iconColor", Color(195, 195, 195), 0.2)
    end    
end

function PANEL:SetTitle(title)
    self.title:SetText(title)
    self.title:SizeToContents()
end

function PANEL:SetupIcon(iconMat, iconCol, bgColor)
    if (not iconMat) then return end
    iconCol = mvp.utils.IsColor(iconCol) and iconCol or mvp.colors.Text
    
    local isGradient = false 

    if (bgColor and bgColor.startCol and bgColor.endCol and mvp.utils.IsColor(bgColor.startCol) and mvp.utils.IsColor(bgColor.endCol)) then
        isGradient = true
    else
        bgColor = mvp.utils.IsColor(bgColor) and bgColor or mvp.colors.BackgroundHover
    end

    self.iconData = {
        mat = iconMat,
        col = iconCol,
        bg = bgColor,
        isGradient = isGradient
    }
end

function PANEL:PerformLayout(w, h)
    self.top:SetTall(mvp.ui.Scale(64))

    self.close:SetWide(mvp.ui.Scale(64) - 10)
    
    if (self.iconData) then
        self.icon:SetWide(mvp.ui.Scale(64) - 10)
    else
        self.icon:SetWide(0)
    end
end

function PANEL:Paint(w, h)
    draw.RoundedBox(roundness, 0, 0, w, h, Color(36, 36, 36))
    draw.RoundedBoxEx(mvp.ui.ScaleWithFactor(8), 0, 0, w, self.top:GetTall(), mvp.colors.SecondaryBackground, true, true, false, false)
end

vgui.Register("mvp.Frame", PANEL, "EditablePanel")
--PATH lua/mvp/vgui/button/cl_button_group.lua:
local PANEL = {}

function PANEL:Init()
    self.buttons = {}

    self:SetRoundness(mvp.ui.ScaleWithFactor(16))
end

local spaceBetween = mvp.ui.Scale(10)

AccessorFunc(PANEL, "roundness", "Roundness")

function PANEL:AddButton(text, callback)
    local button = vgui.Create("mvp.Button", self)
    button:SetText(text)
    button:Dock(LEFT)
    button:SetFont(mvp.Font(18, 600))
    button:SetRoundness(self:GetRoundness())
    if (callback) then
        button.DoClick = callback
    end

    table.insert(self.buttons, button)

    self:InvalidateLayout()

    return button
end

function PANEL:PerformLayout()
    local firstButton = self.buttons[1]
    local lastButton = self.buttons[#self.buttons]

    local buttonWidth = 0
    for k, v in pairs(self.buttons) do
        v:SetExtendedRoundness({false, false, false, false})
        v:SizeToContentsX(spaceBetween * 2)

        buttonWidth = buttonWidth + v:GetWide()
    end

    if (IsValid(firstButton)) then
        firstButton:SetRoundedTopLeft(true)
        firstButton:SetRoundedBottomLeft(true)
    end

    if (IsValid(lastButton)) then
        lastButton:SetRoundedTopRight(true)
        lastButton:SetRoundedBottomRight(true)
    end

    self:SetWide(buttonWidth)
end

vgui.Register("mvp.ButtonGroup", PANEL, "EditablePanel")
--PATH lua/mvp/menus/admin/cl_packages.lua:
mvp = mvp or {}
mvp.menus = mvp.menus or {}

mvp.menus.admin = mvp.menus.admin or {}

local spaceBetween = mvp.ui.Scale(10)
local spacing = mvp.ui.Scale(10)

function mvp.menus.admin.Packages(container)
    local content = vgui.Create("EditablePanel", container)
    content:Dock(FILL)
    content:InvalidateParent(true)

    local title = vgui.Create("mvp.MenuHeader", content)
    title:Dock(TOP)
    title:SetTall(mvp.ui.Scale(64))  
    
    title:SetText(mvp.q.Lang("ui.packages"))
    title:SetDescription(mvp.q.Lang("ui.packages.description"))

    local pageContent = vgui.Create("EditablePanel", content)
    pageContent:Dock(FILL)
    pageContent:InvalidateParent(true)
    
    local grid = vgui.Create("ThreeGrid", pageContent)
    grid:Dock(FILL)
    grid:InvalidateParent(true)

    grid:SetColumns(2)
    grid:SetHorizontalMargin(spaceBetween * .5)
    grid:SetVerticalMargin(spaceBetween * .5)

    local packages = mvp.package.GetAll()

    for k, v in pairs(packages) do
        local package = vgui.Create("DPanel")
        package:SetTall(mvp.ui.Scale(128))

        local iconMaterial = v:GetIcon()
        local iconSize = mvp.ui.Scale(100)

        local packageName = v:GetName()
        local authorText = mvp.q.Lang("general.by_x", v:GetAuthor())
        local packageId = string.format("%s@%s", v:GetID(), v:GetVersion())
        local desription = v:GetDescription()

        package.Paint = function(pnl, w, h)
            draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 150))

            if (iconMaterial and not iconMaterial:IsError()) then
                surface.SetDrawColor(mvp.colors.Text)
                surface.SetMaterial(iconMaterial)
                surface.DrawTexturedRect(spaceBetween, h * .5 - iconSize * .5, iconSize, iconSize)
            else
                draw.RoundedBox(mvp.ui.ScaleWithFactor(8), spaceBetween, h * .5 - iconSize * .5, iconSize, iconSize, mvp.colors.SecondaryBackground)
                draw.SimpleText("?", mvp.Font(32, 600), spaceBetween + iconSize * .5, h * .5, mvp.colors.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end

            local tw, th = draw.SimpleText(packageName, mvp.Font(28, 600), iconSize + spaceBetween * 2, h * .5 - spacing, mvp.colors.Accent, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
            draw.SimpleText(authorText, mvp.Font(20, 400), iconSize + spaceBetween * 2 + tw + spacing * .5, h * .5  - spacing - th * .5, ColorAlpha(mvp.colors.Text, 110), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            draw.SimpleText(desription, mvp.Font(20, 400), iconSize + spaceBetween * 2, h * .5, mvp.colors.Text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            draw.SimpleText(packageId, mvp.Font(20, 400), iconSize + spaceBetween * 2, h * .5 + spacing, ColorAlpha(mvp.colors.Text, 110), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
        end

        grid:AddCell(package)
    
    end
end
--PATH lua/ncs_shared/sh_functions.lua:
function NCS_SHARED.AddText(receivers, ...)
    if SERVER then
        net.Start("NCS_SHARED.AddText")
            net.WriteTable({...})
        net.Send(receivers)
    else
        chat.AddText(...)

        surface.PlaySound("common/talk.wav")
    end
end

function NCS_SHARED.PlaySound(client, snd)
    if !IsValid(client) or !snd then
        return
    end
    
    if SERVER then
        net.Start("NCS_SHARED.PlaySound")
            net.WriteString(snd)
        net.Send(client)
    else
        surface.PlaySound(snd)
    end
end

if CLIENT then
    net.Receive("NCS_SHARED.PlaySound", function()
        local SND = net.ReadString()

        surface.PlaySound(SND)
    end)

    net.Receive("NCS_SHARED.AddText", function()
        chat.AddText(unpack(net.ReadTable()))

        surface.PlaySound("common/talk.wav")
    end)
else
    util.AddNetworkString("NCS_SHARED.PlaySound")
    util.AddNetworkString("NCS_SHARED.AddText")
end
--PATH lua/ncs_shared/currencies/currencies/sh_basewars.lua:
NCS_SHARED.RegisterCurrency("basewars", {
    addMoney = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)
        P:GiveMoney(AMOUNT)
    end,
    canAfford = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)
        return P:GetMoney() >= AMOUNT
    end,
    getMoney = function(P)
        return P:GetMoney()
    end,
    formatMoney = function(AMOUNT)
        AMOUNT = tonumber(AMOUNT)
        return string.Comma(AMOUNT)
    end,
})
--PATH lua/ncs_shared/currencies/currencies/sh_santos.lua:
return gluapack()()
--PATH lua/ncs_shared/modules/configuration/cl_main.lua:
return gluapack()()
--PATH lua/ncs_shared/vgui/cl_imgur.lua:
local PANEL = {}

AccessorFunc(PANEL, "ImgurID", "ImgurID", FORCE_STRING)
AccessorFunc(PANEL, "ImageSize", "ImageSize", FORCE_NUMBER)
AccessorFunc(PANEL, "NormalColor", "NormalColor")
AccessorFunc(PANEL, "HoverColor", "HoverColor")
AccessorFunc(PANEL, "ClickColor", "ClickColor")
AccessorFunc(PANEL, "DisabledColor", "DisabledColor")

function PANEL:Init()
    self:SetText("")
    self.ImageCol = color_white
    self:SetImgurID("635PPvg")

    self:SetNormalColor(color_white)
    self:SetHoverColor(color_white)
    self:SetClickColor(color_white)
    self:SetDisabledColor(color_white)

    self:SetImageSize(1)
end

function PANEL:PaintBackground(w, h) end

function PANEL:Paint(w, h)
    self:PaintBackground(w, h)

    local imageSize = w * 0.125 + (h * 0.1) * self:GetImageSize()
    local imageOffsetW = (w - imageSize) / 2
    local imageOffset = (h - imageSize) / 2

    if not self:IsEnabled() then
        NCS_SHARED.DrawImgur(imageOffsetW, imageOffset, imageSize, imageSize, self:GetImgurID(), self:GetDisabledColor())
        return
    end

    local col = self:GetNormalColor()

    if self:IsHovered() then
        col = self:GetHoverColor()
    end

    if self:IsDown() or self:GetToggle() then
        col = self:GetClickColor()
    end

    NCS_SHARED.DrawImgur(imageOffsetW, imageOffset, imageSize, imageSize, self:GetImgurID(), col)
end

vgui.Register("NCS_SHARED_IMGUR", PANEL, "DButton")
--PATH lua/ncs_shared/vgui/cl_textbutton.lua:
local PANEL = {}

function PANEL:Init()
    self.HOVERED = false
    self:SetFont("NCS_SHARED_FRAME_TITLE")
    self:SetTextColor(color_white)
end

function PANEL:Paint(w, h)
    local COL

    if !self.HOVERED then
        COL = Color(122,132,137, 180)
    else
        COL = Color(252,180,9,255)
    end

    surface.SetDrawColor(COL)
    surface.DrawOutlinedRect( 0, 0, w, h )
end
function PANEL:OnCursorEntered()
    surface.PlaySound("ncs/ui/slider.mp3")

    self:SetTextColor(Color(252,180,9,255))
    self.HOVERED = true
end

function PANEL:OnCursorExited()
    self:SetTextColor(color_white)
    self.HOVERED = false
end


vgui.Register("NCS_SHARED_TextButton", PANEL, "DButton")
--PATH lua/effect/trail.lua:
WeaponTrail.Eff = {}
local iSteps = 10
local Eff = {}
local mat = Material( "down/vs/trail")
Eff.Time = 10
function Eff:InitEffect()
	self.DieTime = CurTime() + (self.CustomTime or 5)
    self.Flag	 = self.Flag or 0
	self.Size = self.Size or 100

    local lastseq = self.Owner:GetSequenceName(self.Owner:GetSequence())//self.Owner:GetNW2Int("Anim_Name")
    if  self.Seq != "none" then
        self.Seq = lastseq or "none"
    end
	self.Mat = Material(self.Mat or "")

	self.TrailData = {}

	self.Mesh = Mesh()


	local BoneData = WeaponTrail.BoneSet[self.Flag]
	local ply = self.Owner
	local pos, ang = ply:GetBonePosition(ply:LookupBone(BoneData.BoneName or "" ) or 0)
	ang = ang + BoneData.AddAngle or Angle()


	local basePos = pos
	local curPos = pos + ang:Up() * self.Size

	if BoneData.AngleType == 0 then
		curPos = pos + ang:Up() * self.Size
	end
	if BoneData.AngleType == 1 then
		curPos = pos + ang:Right() * self.Size
	end
	if BoneData.AngleType == 2 then
		curPos = pos + ang:Forward() * self.Size
	end
	if self.DieTime - CurTime() >= 0 then

		self.TrailData[#self.TrailData+1] = {
			basePos = basePos,
			curPos =  curPos,
			_Time = BoneData.Trail_Time  + CurTime(),
		}
	end

end
function Eff:Think()

end
function Eff:EndEffect()
end

function Eff:Draw(_call)
	if !self.Owner:IsValid() then
		return

	end
		local ply = self.Owner
		local BoneData = WeaponTrail.BoneSet[self.Flag]

		local pos, ang = ply:GetBonePosition(ply:LookupBone(BoneData.BoneName or "" ) or 0)
		ang = ang + BoneData.AddAngle or ""


		local basePos = pos
		local curPos = pos + ang:Up() * self.Size

		if BoneData.AngleType == 0 then
			curPos = pos + ang:Up() * self.Size
		end
		if BoneData.AngleType == 1 then
			curPos = pos + ang:Right() * self.Size
		end
		if BoneData.AngleType == 2 then
			curPos = pos + ang:Forward() * self.Size
		end
		if self.DieTime - CurTime() >= 0 then

			self.TrailData[#self.TrailData+1] = {
				basePos = basePos,
				curPos =  curPos,
				_Time = BoneData.Trail_Time  + CurTime(),
			}
		end

		local vMesh = {}
		local icount = iSteps
		for v, k in pairs(self.TrailData) do
			if self.TrailData[v-1] and self.TrailData[v-2] and v % 2 == 0 then
				local p = self.TrailData[v-1]
				local p2 = self.TrailData[v-2]

				local ppos = k.curPos
				local ppos2 = k.basePos
				for i = 1, icount do
					local t = (i/icount)
					local count_1 = (1/#self.TrailData) * t
					local pos = math.Beizer(k.curPos, p.curPos, p2.curPos, t)
					local pos2 = math.Beizer(k.basePos, p.basePos, p2.basePos, t)
					local fUvRatio = (v / (#self.TrailData))
					local U = fUvRatio - count_1
					local a = #vMesh


					vMesh[a+1] = {pos = pos2, u = U, v = 1}
					vMesh[a+2] = {pos = pos, u = U, v = 0}
					vMesh[a+3] = {pos = ppos, u = U, v = 0}

					vMesh[a+4] = {pos = pos2, u = U, v = 1}
					vMesh[a+5] = {pos = ppos, u = U, v = 0}
					vMesh[a+6] = {pos = ppos2, u = U, v = 1}

					ppos = pos
					ppos2 = pos2
				end
			end
			if k._Time - CurTime() <= 0 then
				table.remove(self.TrailData, v)
			end
		end
		self.vMesh = vMesh
		if #self.TrailData <= 0 and self.DieTime - CurTime() <= 0 then
			return false
		end
		local lastseq = self.Owner:GetSequenceName(self.Owner:GetSequence())//self.Owner:GetNW2Int("Anim_Name")
		if self.Seq != "none" and self.Seq != lastseq then
			self.Seq = "none"
			return false
		 end

	render.SetMaterial(self.Mat)
	local imesh = Mesh()
	if #self.TrailData > 1 and self.vMesh then
		imesh:BuildFromTriangles(self.vMesh)
	end
	imesh:Draw()
	imesh:Destroy()
	return true
end

WeaponTrail.Eff = Eff

function math.Beizer(p0, p1, p2, t)
	return LerpVector(t, LerpVector(t, p0, p1), LerpVector(t, p1, p2))
end

--PATH addons/[lib] onyx_framework_2/lua/autorun/onyx_autorun.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

onyx = {}
onyx.cfg = {}

AddCSLuaFile('onyx/util.lua')
include('onyx/util.lua')
AddCSLuaFile('onyx/init.lua')
include('onyx/init.lua')
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_4.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_inconfig.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_net_extension.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

23/04/2023

--]]

onyx.net = {}

function onyx.net.WriteTable(tbl)
    assert(tbl, 'missing table')
    assert(istable(tbl), 'the provided argument must be a table')

    local encoded = pon.encode(tbl)
    local len = #encoded

    net.WriteUInt(len, 32)
    net.WriteData(encoded, len)
end

function onyx.net.ReadTable()
    local len = net.ReadUInt(32)
    local data = net.ReadData(len)
    local success, decoded = pcall(pon.decode, data)

    if (success) then
        return decoded
    end

    return {}
end

function onyx.net.Send(ply)
    if (ply) then
        net.Send(ply)
    else
        net.Broadcast()
    end
end

if (SERVER) then
    local function GetHookName(ply)
        return ('onyx.NetReadyCheck_' .. ply:SteamID64())
    end

    hook.Add('PlayerInitialSpawn', 'onyx.GetNetworkReady', function(ply)
        hook.Add('SetupMove', GetHookName(ply), function(ply2, mvd, cmd)
            if ply == ply2 and not cmd:IsForced() then
                hook.Remove('SetupMove', GetHookName(ply2))
                hook.Run('onyx.PlayerNetworkReady', ply2)
                hook.Run('onyx.PostPlayerNetworkReady', ply2) -- required for netvar library and etc.
                ply2:SetVar('onyx_NetReady', true)
            end
        end)
    end)
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/thirdparty/cl_tween.lua:
-- Put your Lua here
local tween = {
    _VERSION = 'tween 2.1.1',
    _DESCRIPTION = 'tweening for lua',
    _URL = 'https://github.com/kikito/tween.lua',
    _LICENSE = [[
      MIT LICENSE

      Copyright (c) 2014 Enrique García Cota, Yuichi Tateno, Emmanuel Oga

      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this software and associated documentation files (the
      "Software"), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:

      The above copyright notice and this permission notice shall be included
      in all copies or substantial portions of the Software.

      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    ]]
}

-- easing
-- Adapted from https://github.com/EmmanuelOga/easing. See LICENSE.txt for credits.
-- For all easing functions:
-- t = time == how much time has to pass for the tweening to complete
-- b = begin == starting property value
-- c = change == ending - beginning
-- d = duration == running time. How much time has passed *right now*
local pow, sin, cos, pi, sqrt, abs, asin = math.pow, math.sin, math.cos, math.pi, math.sqrt, math.abs, math.asin

-- linear
local function linear(t, b, c, d)
    return c * t / d + b
end

-- quad
local function inQuad(t, b, c, d)
    return c * pow(t / d, 2) + b
end

local function outQuad(t, b, c, d)
    t = t / d

    return -c * t * (t - 2) + b
end

local function inOutQuad(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c / 2 * pow(t, 2) + b end

    return -c / 2 * ((t - 1) * (t - 3) - 1) + b
end

local function outInQuad(t, b, c, d)
    if t < d / 2 then return outQuad(t * 2, b, c / 2, d) end

    return inQuad((t * 2) - d, b + c / 2, c / 2, d)
end

-- cubic
local function inCubic(t, b, c, d)
    return c * pow(t / d, 3) + b
end

local function outCubic(t, b, c, d)
    return c * (pow(t / d - 1, 3) + 1) + b
end

local function inOutCubic(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c / 2 * t * t * t + b end
    t = t - 2

    return c / 2 * (t * t * t + 2) + b
end

local function outInCubic(t, b, c, d)
    if t < d / 2 then return outCubic(t * 2, b, c / 2, d) end

    return inCubic((t * 2) - d, b + c / 2, c / 2, d)
end

-- quart
local function inQuart(t, b, c, d)
    return c * pow(t / d, 4) + b
end

local function outQuart(t, b, c, d)
    return -c * (pow(t / d - 1, 4) - 1) + b
end

local function inOutQuart(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c / 2 * pow(t, 4) + b end

    return -c / 2 * (pow(t - 2, 4) - 2) + b
end

local function outInQuart(t, b, c, d)
    if t < d / 2 then return outQuart(t * 2, b, c / 2, d) end

    return inQuart((t * 2) - d, b + c / 2, c / 2, d)
end

-- quint
local function inQuint(t, b, c, d)
    return c * pow(t / d, 5) + b
end

local function outQuint(t, b, c, d)
    return c * (pow(t / d - 1, 5) + 1) + b
end

local function inOutQuint(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c / 2 * pow(t, 5) + b end

    return c / 2 * (pow(t - 2, 5) + 2) + b
end

local function outInQuint(t, b, c, d)
    if t < d / 2 then return outQuint(t * 2, b, c / 2, d) end

    return inQuint((t * 2) - d, b + c / 2, c / 2, d)
end

-- sine
local function inSine(t, b, c, d)
    return -c * cos(t / d * (pi / 2)) + c + b
end

local function outSine(t, b, c, d)
    return c * sin(t / d * (pi / 2)) + b
end

local function inOutSine(t, b, c, d)
    return -c / 2 * (cos(pi * t / d) - 1) + b
end

local function outInSine(t, b, c, d)
    if t < d / 2 then return outSine(t * 2, b, c / 2, d) end

    return inSine((t * 2) - d, b + c / 2, c / 2, d)
end

-- expo
local function inExpo(t, b, c, d)
    if t == 0 then return b end

    return c * pow(2, 10 * (t / d - 1)) + b - c * 0.001
end

local function outExpo(t, b, c, d)
    if t == d then return b + c end

    return c * 1.001 * (-pow(2, -10 * t / d) + 1) + b
end

local function inOutExpo(t, b, c, d)
    if t == 0 then return b end
    if t == d then return b + c end
    t = t / d * 2
    if t < 1 then return c / 2 * pow(2, 10 * (t - 1)) + b - c * 0.0005 end

    return c / 2 * 1.0005 * (-pow(2, -10 * (t - 1)) + 2) + b
end

local function outInExpo(t, b, c, d)
    if t < d / 2 then return outExpo(t * 2, b, c / 2, d) end

    return inExpo((t * 2) - d, b + c / 2, c / 2, d)
end

-- circ
local function inCirc(t, b, c, d)
    return -c * (sqrt(1 - pow(t / d, 2)) - 1) + b
end

local function outCirc(t, b, c, d)
    return c * sqrt(1 - pow(t / d - 1, 2)) + b
end

local function inOutCirc(t, b, c, d)
    t = t / d * 2
    if t < 1 then return -c / 2 * (sqrt(1 - t * t) - 1) + b end
    t = t - 2

    return c / 2 * (sqrt(1 - t * t) + 1) + b
end

local function outInCirc(t, b, c, d)
    if t < d / 2 then return outCirc(t * 2, b, c / 2, d) end

    return inCirc((t * 2) - d, b + c / 2, c / 2, d)
end

-- elastic
local function calculatePAS(p, a, c, d)
    p, a = p or d * 0.3, a or 0
    if a < abs(c) then return p, c, p / 4 end -- p, a, s
    -- p,a,s

    return p, a, p / (2 * pi) * asin(c / a)
end

local function inElastic(t, b, c, d, a, p)
    local s
    if t == 0 then return b end
    t = t / d
    if t == 1 then return b + c end
    p, a, s = calculatePAS(p, a, c, d)
    t = t - 1

    return -(a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
end

local function outElastic(t, b, c, d, a, p)
    local s
    if t == 0 then return b end
    t = t / d
    if t == 1 then return b + c end
    p, a, s = calculatePAS(p, a, c, d)

    return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) + c + b
end

local function inOutElastic(t, b, c, d, a, p)
    local s
    if t == 0 then return b end
    t = t / d * 2
    if t == 2 then return b + c end
    p, a, s = calculatePAS(p, a, c, d)
    t = t - 1
    if t < 0 then return -0.5 * (a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b end

    return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) * 0.5 + c + b
end

local function outInElastic(t, b, c, d, a, p)
    if t < d / 2 then return outElastic(t * 2, b, c / 2, d, a, p) end

    return inElastic((t * 2) - d, b + c / 2, c / 2, d, a, p)
end

-- back
local function inBack(t, b, c, d, s)
    s = s or 1.70158
    t = t / d

    return c * t * t * ((s + 1) * t - s) + b
end

local function outBack(t, b, c, d, s)
    s = s or 1.70158
    t = t / d - 1

    return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function inOutBack(t, b, c, d, s)
    s = (s or 1.70158) * 1.525
    t = t / d * 2
    if t < 1 then return c / 2 * (t * t * ((s + 1) * t - s)) + b end
    t = t - 2

    return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
end

local function outInBack(t, b, c, d, s)
    if t < d / 2 then return outBack(t * 2, b, c / 2, d, s) end

    return inBack((t * 2) - d, b + c / 2, c / 2, d, s)
end

-- bounce
local function outBounce(t, b, c, d)
    t = t / d
    if t < 1 / 2.75 then return c * (7.5625 * t * t) + b end

    if t < 2 / 2.75 then
        t = t - (1.5 / 2.75)

        return c * (7.5625 * t * t + 0.75) + b
    elseif t < 2.5 / 2.75 then
        t = t - (2.25 / 2.75)

        return c * (7.5625 * t * t + 0.9375) + b
    end

    t = t - (2.625 / 2.75)

    return c * (7.5625 * t * t + 0.984375) + b
end

local function inBounce(t, b, c, d)
    return c - outBounce(d - t, 0, c, d) + b
end

local function inOutBounce(t, b, c, d)
    if t < d / 2 then return inBounce(t * 2, 0, c, d) * 0.5 + b end

    return outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
end

local function outInBounce(t, b, c, d)
    if t < d / 2 then return outBounce(t * 2, b, c / 2, d) end

    return inBounce((t * 2) - d, b + c / 2, c / 2, d)
end

tween.easing = {
    linear = linear,
    inQuad = inQuad,
    outQuad = outQuad,
    inOutQuad = inOutQuad,
    outInQuad = outInQuad,
    inCubic = inCubic,
    outCubic = outCubic,
    inOutCubic = inOutCubic,
    outInCubic = outInCubic,
    inQuart = inQuart,
    outQuart = outQuart,
    inOutQuart = inOutQuart,
    outInQuart = outInQuart,
    inQuint = inQuint,
    outQuint = outQuint,
    inOutQuint = inOutQuint,
    outInQuint = outInQuint,
    inSine = inSine,
    outSine = outSine,
    inOutSine = inOutSine,
    outInSine = outInSine,
    inExpo = inExpo,
    outExpo = outExpo,
    inOutExpo = inOutExpo,
    outInExpo = outInExpo,
    inCirc = inCirc,
    outCirc = outCirc,
    inOutCirc = inOutCirc,
    outInCirc = outInCirc,
    inElastic = inElastic,
    outElastic = outElastic,
    inOutElastic = inOutElastic,
    outInElastic = outInElastic,
    inBack = inBack,
    outBack = outBack,
    inOutBack = inOutBack,
    outInBack = outInBack,
    inBounce = inBounce,
    outBounce = outBounce,
    inOutBounce = inOutBounce,
    outInBounce = outInBounce
}

-- private stuff
local function copyTables(destination, keysTable, valuesTable)
    valuesTable = valuesTable or keysTable
    local mt = getmetatable(keysTable)

    if mt and getmetatable(destination) == nil then
        setmetatable(destination, mt)
    end

    for k, v in pairs(keysTable) do
        if type(v) == 'table' then
            destination[k] = copyTables({}, v, valuesTable[k])
        else
            destination[k] = valuesTable[k]
        end
    end

    return destination
end

local function checkSubjectAndTargetRecursively(subject, target, path)
    path = path or {}
    local targetType, newPath

    for k, targetValue in pairs(target) do
        targetType, newPath = type(targetValue), copyTables({}, path)
        table.insert(newPath, tostring(k))

        if targetType == 'number' then
            assert(type(subject[k]) == 'number', "Parameter '" .. table.concat(newPath, '/') .. "' is missing from subject or isn't a number")
        elseif targetType == 'table' then
            checkSubjectAndTargetRecursively(subject[k], targetValue, newPath)
        else
            assert(targetType == 'number', "Parameter '" .. table.concat(newPath, '/') .. "' must be a number or table of numbers")
        end
    end
end

local function checkNewParams(duration, subject, target, easing)
    assert(type(duration) == 'number' and duration > 0, "duration must be a positive number. Was " .. tostring(duration))
    local tsubject = type(subject)
    assert(tsubject == 'table' or tsubject == 'userdata' or tsubject == 'Panel', "subject must be a table or userdata. Was " .. tostring(subject))
    assert(type(target) == 'table', "target must be a table. Was " .. tostring(target))
    assert(type(easing) == 'function', "easing must be a function. Was " .. tostring(easing))
    checkSubjectAndTargetRecursively(subject, target)
end

local function getEasingFunction(easing)
    easing = easing or "linear"

    if type(easing) == 'string' then
        local name = easing
        easing = tween.easing[name]

        if type(easing) ~= 'function' then
            error("The easing function name '" .. name .. "' is invalid")
        end
    end

    return easing
end

local function performEasingOnSubject(subject, target, initial, clock, duration, easing)
    local t, b, c, d

    for k, v in pairs(target) do
        if type(v) == 'table' then
            performEasingOnSubject(subject[k], v, initial[k], clock, duration, easing)
        else
            t, b, c, d = clock, initial[k], v - initial[k], duration
            subject[k] = easing(t, b, c, d)
        end
    end
end

-- Tween methods
local Tween = {}

local Tween_mt = {
    __index = Tween
}

function Tween:set(clock)
    assert(type(clock) == 'number', "clock must be a positive number or 0")
    self.initial = self.initial or copyTables({}, self.target, self.subject)
    self.clock = clock

    if self.clock <= 0 then
        self.clock = 0
        copyTables(self.subject, self.initial)
    elseif self.clock >= self.duration then
        -- the tween has expired
        self.clock = self.duration
        copyTables(self.subject, self.target)
    else
        performEasingOnSubject(self.subject, self.target, self.initial, self.clock, self.duration, self.easing)
    end

    return self.clock >= self.duration
end

function Tween:reset()
    return self:set(0)
end

function Tween:update(dt)
    assert(type(dt) == 'number', "dt must be a number")

    return self:set(self.clock + dt)
end

-- Public interface
function tween.new(duration, subject, target, easing)
    easing = getEasingFunction(easing)
    checkNewParams(duration, subject, target, easing)

    return setmetatable({
        duration = duration,
        subject = subject,
        target = target,
        easing = easing,
        clock = 0
    }, Tween_mt)
end

onyx.tween = tween
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_gui.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_trait.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/04/2022

--]]

onyx.trait = onyx.trait or {}
onyx.trait.list = onyx.trait.list or {}

local trait = onyx.trait

function trait.Register(id, data)
    trait.list[id] = data
end

function trait.Get(id)
    return trait.list[id]
end

do
    local hookList = {
        ['Think'] = true,
        ['OnMousePressed'] = true,
        ['OnMouseReleased'] = true,
        ['PerformLayout'] = true,
        ['OnCursorEntered'] = true,
        ['OnCursorExited'] = true,
    }

    function trait.Import(panel, id)
        panel.onyxTraits = panel.onyxTraits or {}

        local data = trait.Get(id)

        -- Check if trait is valid
        if not data then return false end

        -- Check if already imported
        if panel.onyxTraits[id] then return false end

        local initFunc = data.Init

        for k, v in pairs(data) do
            if k == 'Init' then
                goto skip
            end

            if hookList[k] then
                onyx.gui.InjectEventHandler(panel, k)
                onyx.gui.AddEvent(panel, k, v)
            else
                panel[k] = v
            end

            ::skip::
        end

        if initFunc then
            initFunc(panel)
        end

        panel.onyxTraits[id] = true

        return true
    end
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/cfg/cl_config.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/core/cl_draw_functions.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

18/11/2023

--]]

do
    for thickness = 1, 6 do
        onyx.spoly.Generate('onyx_circle_outline_' .. thickness, function(w, h)
            local scaledThickness = thickness * 32

            local x = w * .5
            local y = h * .5
            local r = h * .5
            local vertices = 64

            local circleInner = onyx.CalculateCircle(x, y, r - scaledThickness, vertices)
            local circleOuter = onyx.CalculateCircle(x, y, r, vertices)

            onyx.InverseMaskFn(function()
                surface.DrawPoly(circleInner)
            end, function()
                surface.DrawPoly(circleOuter)
            end)
        end)
    end
end

do
    onyx.spoly.Generate('onyx_circle', function(w, h)
        local x0, y0 = w * .5, h * .5
        local r = h * .5
        local vertexs = 64
        local circle = onyx.CalculateCircle(x0, y0, r, vertexs)

        surface.DrawPoly(circle)
    end)
end

--[[------------------------------
Draws a smooth outline for a circle
Available thickness: [1; 6]
--------------------------------]]
function onyx.DrawOutlinedCircle(x0, y0, r, thickness, color)
    local id = 'onyx_circle_outline_' .. thickness
    local d = r * 2

    onyx.spoly.DrawRotated(id, x0, y0, d, d, 0, color)
end

--[[------------------------------
Draws a smooth circle
--------------------------------]]
function onyx.DrawCircle(x0, y0, r, color)
    local x = x0 - r
    local y = y0 - r
    local d = r * 2

    if (color) then
        surface.SetDrawColor(color)
    end
    onyx.spoly.Draw('onyx_circle', x, y, d, d)
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_frame.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local PANEL = {}

function PANEL:Init()
    self.divHeader = self:Add('onyx.Frame.Header')
    self.colorBG = onyx.OffsetColor(onyx:Config('colors.primary'), -5)

    self:Combine(self.divHeader, 'SetTitle')
    self:SetTitle('Frame')

    self.disabledPanels = {}
    self.focusMultiplier = 0

    self._Remove = self.Remove
    self.Remove = function(panel)
        panel:Close()
    end
end

function PANEL:ShowCloseButton(bVis)
    self.divHeader.btnClose:SetVisible(bVis)
end

function PANEL:PerformLayout(w, h)
    self.divHeader:Dock(TOP)
    self.divHeader:SetTall(ScreenScale(12))
end

function PANEL:Paint(w, h)
    local x, y = self:LocalToScreen(0, 0)

    if (self.focused and self.focusMultiplier > 0) then
        DisableClipping(true)
            onyx.DrawBlurExpensive(self, self.focusMultiplier)
        DisableClipping(false)
    end

    assert( self.colorBG )
    onyx.bshadows.BeginShadow()
        draw.RoundedBox(8, x, y, w, h, self.colorBG)
    onyx.bshadows.EndShadow(1, 5, 5)
end

function PANEL:Focus()
    local panels = vgui.GetWorldPanel():GetChildren()
    for _, child in ipairs(panels) do
        if child:IsVisible() and child ~= self and child:IsMouseInputEnabled() then
            child:SetMouseInputEnabled(false)
            table.insert(self.disabledPanels, child)
        end
    end

    self.focused = true

    onyx.anim.Simple(self, .33, {
        focusMultiplier = 5
    }, 1)
end

function PANEL:UnFocus()
    for _, child in ipairs(self.disabledPanels) do
        if IsValid(child) then
            child:SetMouseInputEnabled(true)
        end
    end

    self.disabledPanels = {}
    self.focused = false
end

function PANEL:OnRemove()
    self:UnFocus()
end

function PANEL:Close()
    self:AlphaTo(0, .2, 0, function(_, panel)
        if (IsValid(panel)) then
            panel:_Remove()
        end
    end)
end

onyx.gui.Register('onyx.Frame', PANEL, 'EditablePanel')

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .65, .65, function(self)
--     self:Focus()
-- end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_rounded_avatar.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_toggler.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

20/01/2024

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorTertiary = onyx:Config('colors.tertiary')
local colorAccent = onyx:Config('colors.accent')

do
    local PANEL = {}

    AccessorFunc(PANEL, 'm_bChecked', 'Checked', FORCE_BOOL)

    function PANEL:Init()
        local size = onyx.ScaleTall(18)

        self.m_bChecked = false

        self:Import('click')
        self:SetSize(size * 2, size)

        self.perfectWidth = size * 2
        self.perfectHeight = size

        self.stateFraction = 0

        self:SetBackgroundColor(colorSecondary)
    end

    function PANEL:Paint(w, h)
        local radius = h * .5
        local height = h * .66
        local circleX = radius + (w - radius * 2) * self.stateFraction
        local realX, realY = self:LocalToScreen(0, 0)

        draw.RoundedBox(16, 0, h * .5 - height * .5, w, height, self.backgroundColorCurrent)

        render.SetScissorRect(realX, realY, realX + circleX, realY + h, true)
            surface.SetAlphaMultiplier(self.stateFraction)
                draw.RoundedBox(16, 0, h * .5 - height * .5, w, height, self.backgroundColorActive)
            surface.SetAlphaMultiplier(1)
        render.SetScissorRect(0, 0, 0, 0, false)

        onyx.DrawCircle(circleX, h * .5, radius, self.gripColorCurrent)
    end

    function PANEL:DoClick()
        self:SetValue(not self.m_bChecked)
    end

    function PANEL:AnimState(bBool, ignoreAnimation)
        local time = .15
        if (bBool) then
            onyx.anim.Create(self, time, {
                index = 40,
                skipAnimation = ignoreAnimation,
                target = {
                    stateFraction = 1,
                    gripColorCurrent = self.gripColorActive
                }
            })
        else
            onyx.anim.Create(self, time, {
                index = 40,
                skipAnimation = ignoreAnimation,
                target = {
                    stateFraction = 0,
                    gripColorCurrent = self.gripColorIdle
                }
            })
        end
    end

    function PANEL:SetChecked(bBool, ignoreAnimation)
        assert(isbool(bBool), string.format('bad argument #1 to `SetChecked` (expected bool, got %s)', type(bBool)))
        self.m_bChecked = bBool
        self:AnimState(bBool, ignoreAnimation)
    end

    function PANEL:SetValue(bBool)
        self:SetChecked(bBool)
        self:Call('OnChange', nil, bBool)
    end

    function PANEL:GetValue()
        return self.m_bChecked
    end

    function PANEL:SetBackgroundColor(color)
        self.backgroundColorCurrent = color
        self.backgroundColorActive = onyx.LerpColor(.66, colorAccent, self.backgroundColorCurrent)

        self.gripColorIdle = onyx.OffsetColor(self.backgroundColorCurrent, 10)
        self.gripColorActive = colorAccent
        self.gripColorCurrent = onyx.CopyColor(self.gripColorIdle)
    end

    onyx.gui.Register('onyx.Toggler', PANEL)
end

do
    local PANEL = {}

    AccessorFunc(PANEL, 'm_iCheckContainerWidth', 'CheckContainerWidth')
    AccessorFunc(PANEL, 'm_bUnlockedTogglerSize', 'UnlockedTogglerSize')
    AccessorFunc(PANEL, 'm_iTextMargin', 'TextMargin')

    function PANEL:Init()
        self.lblText = self:Add('onyx.Label')
        self.lblText:SetText('Example Label')

        self.togglerContainer = self:Add('Panel')

        self.toggler = self.togglerContainer:Add('onyx.Toggler')

        self:SetTextMargin(onyx.ScaleTall(5))
        self:CombineMutator(self.toggler, 'Checked')
        self:CombineMutator(self.toggler, 'Value')
        self:CombineMutator(self.lblText, 'Text')
        self:CombineMutator(self.lblText, 'Font')
        self:Combine(self.lblText, 'Font')
        self:Combine(self.toggler, 'SetBackgroundColor')
        self:MakeDispatchFn(self.toggler, 'OnChange')
    end

    function PANEL:PerformLayout(w, h)
        local togglerContainerWidth = self.m_iCheckContainerWidth or h
        local margin = self.m_iTextMargin

        self.togglerContainer:SetWide(togglerContainerWidth)
        self.togglerContainer:Dock(LEFT)
        self.togglerContainer:DockMargin(0, 0, margin, 0)

        self.lblText:Dock(FILL)

        if (self.UnlockedTogglerSize) then
            self.toggler:SetWide(togglerContainerWidth)
        else
            self.toggler:SetWide(math.min(self.toggler:GetWide(), togglerContainerWidth))
        end

        self.toggler:SetTall(self.toggler:GetWide() * .5)
        self.toggler:Center()
    end

    function PANEL:GetContentWide()
        local togglerContainerWidth = self.m_iCheckContainerWidth or self:GetTall()
        local lblText = self.lblText
        local margin = self.m_iTextMargin
        local wide = togglerContainerWidth + lblText:GetContentWidth() + margin
        return wide
    end
    PANEL.GetContentWidth = PANEL.GetContentWide

    onyx.gui.Register('onyx.TogglerLabel', PANEL)
end

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     local iconlayout = self:Add('DIconLayout')
--     iconlayout:Dock(FILL)

--     for i = 1, 10 do
--         local panel = iconlayout:Add('onyx.TogglerLabel')
--         -- panel:Dock(TOP)
--         panel:SetChecked(true, true)
--         panel:SetText('Hello there')
--         panel:Font('Comfortaa@16')
--         panel:SetTall(ScreenScale(14))
--         panel:SetWide(panel:GetContentWide())
--     end
-- end)
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

onyx:Addon('f4', {
    color = Color(65, 162, 211),
    author = 'tochnonement',
    version = '1.2.6',
    licensee = '76561198196280105'
})

----------------------------------------------------------------

onyx.Include('sv_sql.lua')
onyx.IncludeFolder('onyx/modules/f4/languages/')
onyx.IncludeFolder('onyx/modules/f4/core/', true)
onyx.IncludeFolder('onyx/modules/f4/cfg/', true)
onyx.IncludeFolder('onyx/modules/f4/ui/')

onyx.f4:Print('Finished loading.')
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_turkish.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/core/stats/sh_stats.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/01/2024

--]]

netchunk.Register('onyx.f4:SendStats')
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/cfg/cl_actions.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/cfg/cl_tabs.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

onyx.f4.tabs = {}

onyx.f4:RegisterTab('dashboard', {
    order = 1,
    name = 'f4_dashboard_u',
    desc = 'f4_dashboard_desc',
    icon = 'https://i.imgur.com/L6Dbwjm.png',
    class = 'onyx.f4.Dashboard'
})

onyx.f4:RegisterTab('jobs', {
    order = 2,
    name = 'f4_jobs_u',
    desc = 'f4_jobs_desc',
    icon = 'https://i.imgur.com/B5jmfXa.png',
    class = 'onyx.f4.Jobs'
})

onyx.f4:RegisterTab('shop', {
    order = 3,
    name = 'f4_shop_u',
    desc = 'f4_shop_desc',
    icon = 'https://i.imgur.com/duyBVAS.png',
    class = 'onyx.f4.Shop'
})
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_german.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_icons.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_alerts.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

17/08/2024

--]]

local DURATION = 5

local hud = onyx.hud
local alerts = {}

local function addAlert( text )
    local useQueue = hud:GetOptionValue( 'alert_queue' )
    local data = {
        title = onyx.utf8.upper( onyx.lang:Get( 'message' ) ),
        text = text,
        duration = DURATION
    }

    if ( useQueue ) then
        table.insert( alerts, data )
    else
        alerts[ 1 ] = data
    end
end

local function drawAlerts( element, client, scrW, scrH )
    local alert = alerts[ 1 ]

    if ( not alert ) then return end
    if ( not alert.endtime ) then alert.endtime = CurTime() + alert.duration end

    local maxW = hud.ScaleWide( 500 )
    local font = hud.fonts.Small
    local roundness = hud.GetRoundness()
    local colorPrimary = hud:GetColor( 'primary' )
    local colorText = hud:GetColor( 'textPrimary' )
    local colorTitle = hud:GetColor( 'textSecondary' )
    local colorAccent = hud:GetColor( 'accent' )
    local alertSpace = hud.ScaleTall( 5 )
    local baseY = ScrH() * .25
    local posY = baseY

    if ( not alert.wrapText ) then
        alert.wrapText = DarkRP.textWrap( alert.text, font, maxW )
    end
    
    local text = alert.wrapText
    local title = alert.title

    surface.SetFont( font )
    local textW, textH = surface.GetTextSize( text )
    local titleH = hud.ScaleTall( 20 )

    local padding = hud.ScaleTall( 10 )
    local x0, y0 = scrW * .5, scrH * .5
    local w = textW + padding * 2
    local h = textH + titleH + padding * 2
    local x = x0 - w * .5
    local y = posY
    local lineH = hud.ScaleTall( 3 )
    local timeLeft = math.max( 0, ( alert.endtime - CurTime() ) )
    local lifeFraction = timeLeft / alert.duration
    local isExpired = lifeFraction <= 0
    
    alert.alpha = Lerp( FrameTime() * 8, alert.alpha or 0, isExpired and 0 or 1 )

    surface.SetAlphaMultiplier( alert.alpha )

        hud.DrawRoundedBox( x, y, w, h, colorPrimary )

        render.SetScissorRect( x, y + h - lineH, x + w, y + h, true )
            hud.DrawRoundedBox( x, y, w, h, onyx.LerpColor( .75, colorAccent, colorPrimary ) )
        render.SetScissorRect( x, y + h - lineH, x + w * lifeFraction, y + h, true )
            hud.DrawRoundedBox( x, y, w, h, colorAccent )
        render.SetScissorRect( 0, 0, 0, 0, false )

        draw.SimpleText( title, hud.fonts.TinyBold, x0, y + padding, colorTitle, 1 )

        draw.DrawText( text, font, x0, y + padding + titleH, colorText, 1 )

    surface.SetAlphaMultiplier( 1 )
    
    if ( isExpired and math.Round( alert.alpha, 1 ) == 0 ) then
        table.remove( alerts, 1 )
    end
end

net.Receive( 'onyx.hud::SendAlert', function()
    if ( onyx.hud.IsElementEnabled( 'alerts' ) ) then
        addAlert( net.ReadString() )
    end
end )

hook.Add( 'onyx.inconfig.Updated', 'onyx.hud.ClearAlerts', function( id, old, new )
    if ( id and id == 'hud_display_alerts' ) then
        alerts = {}
    end
end )

onyx.hud:RegisterElement( 'alerts', { drawFn = drawAlerts } )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_door_info.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_door_menu.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/08/2024

--]]

local MAX_DISTANCE = 128 ^ 2 -- DarkRP default is 200
local L = function( ... ) return onyx.lang:Get( ... ) end
local doorFrame

local function checkEntity( client, ent )
    if ( not IsValid( ent ) ) then return false end
    if ( not ent:isKeysOwnable() ) then return false end
    if ( ent:GetPos():DistToSqr( client:GetPos() ) > MAX_DISTANCE ) then return false end

    return true
end

local function safeClose( panel )
    if ( IsValid( panel ) ) then
        panel:Close()
    end
end

local function choosePlayer( ... )
    local colors = onyx.hud:GetCurrentTheme().colors
    local frame = onyx.ChoosePlayer( ... )

    frame.colorBG = onyx.OffsetColor( colors.primary, -5 )
    frame.lblDesc:SetTextColor( colors.textPrimary )
    frame.divHeader.colorBG = colors.secondary
    frame.divHeader.lblText:SetTextColor( colors.textPrimary )
    frame.divHeader.btnClose:SetColorIdle( colors.textPrimary )

    for _, button in ipairs( frame.buttons ) do
        button:SetColorIdle( colors.primary )
        button:SetColorHover( colors.secondary )
        button.lblTitle:SetTextColor( colors.textPrimary )
        button.colorTertiary = colors.tertiary
    end
end

local function openDoorMenu( client, setDoorOwnerAccess, canChangeSettings )
    local trace = client:GetEyeTrace()
    local ent = trace.Entity

    if ( not checkEntity( client, ent ) ) then return end

    local isClientOwner = ent:isKeysOwnedBy( client )
    local isOwned = ent:isKeysOwned()
    local isNonOwnable = ent:getKeysNonOwnable()
    local doorGroup = ent:getKeysDoorGroup()
    local doorTeams = ent:getKeysDoorTeams()
    local isAllowedToOwn = ent:isKeysAllowedToOwn( client )
    local entType = onyx.utf8.lower( L( ent:IsVehicle() and 'vehicle' or 'door' ) )
    local hasTeams = table.Count( doorTeams or {} ) > 0
    local colors = onyx.hud:GetCurrentTheme().colors

    local options = {}
    local insert = function( name, callback, wimgID )
        if ( isstring( callback ) ) then
            local cmd = tostring( callback )
            callback = function()
                RunConsoleCommand( 'darkrp', cmd )
            end
        end
        
        table.insert( options, {
            name = name,
            callback = callback,
            wimgID = wimgID
        } )
    end

    -- Buy door
    if ( not isOwned and ( not isNonOwnable and not doorGroup and not doorTeams ) or isAllowedToOwn ) then
        insert( L( 'door_purchase', { object = entType } ), 'toggleown', 'door_own' )
    end

    -- Sell door
    if ( isClientOwner ) then
        insert( L( 'door_sell', { object = entType } ), 'toggleown', 'door_sell' )

        table.insert( options, { 
            name = L( 'door_addowner' ),
            ignoreClose = true,
            wimgID = 'door_add_user',
            callback = function()
                choosePlayer( L( 'door_addowner' ), L( 'door_addowner_help' ), function(ply)
                    RunConsoleCommand( 'darkrp', 'ao', ply:SteamID() ) 
                end, false, function( ply )
                    return ( not ent:isKeysOwnedBy( ply ) and not ent:isKeysAllowedToOwn( ply ) )
                end )
            end
        } )

        table.insert( options, { 
            name = L( 'door_rmowner' ),
            ignoreClose = true,
            wimgID = 'door_remove_user',
            callback = function()
                choosePlayer( L( 'door_rmowner' ), L( 'door_rmowner_help' ), function( ply )
                    RunConsoleCommand( 'darkrp', 'ro', ply:SteamID() ) 
                end, false, function( ply )
                    return ( ( ent:isKeysOwnedBy( ply ) and not ent:isMasterOwner( ply ) ) or ent:isKeysAllowedToOwn( ply ) )
                end )
            end
        } )
    end

    -- Change title
    if ( canChangeSettings and ( isOwned or isNonOwnable or doorGroup or hasTeams ) or isClientOwner ) then
        local title = L( 'door_title' )
        insert( title, function()
            local frame = onyx.SimpleQuery( title, L( 'door_title_help' ), true, function( value )
                RunConsoleCommand( 'darkrp', 'title', value )
            end )

            frame.colorBG = onyx.OffsetColor( colors.primary, -5 )
            frame.divHeader.colorBG = colors.secondary
            frame.divHeader.lblText:SetTextColor( colors.textPrimary )

            frame.lblDesc:SetTextColor( colors.textPrimary )

            frame.textEntry:SetColorIdle( colors.primary )
            frame.textEntry:SetColorHover( onyx.OffsetColor( colors.primary, -10 ) )
            frame.textEntry:SetTextColor( colors.textPrimary )
            frame.textEntry:SetPlaceholderColor( colors.textTertiary )
            frame.textEntry.colors.accent = colors.accent
            frame.textEntry.colors.outline = colors.secondary
            frame.textEntry.currentOutlineColor = onyx.CopyColor( colors.secondary )
        end, 'door_title' )
    end
    
    -- Admin settings
    if ( canChangeSettings ) then
        insert( L( isNonOwnable and 'door_admin_allow' or 'door_admin_disallow' ):gsub( ' ', '\n' ), 'toggleownable', isNonOwnable and 'door_enable_own' or 'door_disable_own' )

        table.insert( options, {
            name = L( 'door_admin_edit' ),
            ignoreClose = true,
            wimgID = 'door_groups',
            callback = function( wheel )
                local dmenu = vgui.Create( 'onyx.Menu' )
                dmenu:ToCursor()
                dmenu.backgroundColor = colors.primary
                dmenu.outlineColor = colors.secondary
                dmenu.Think = function( this )
                    if ( not IsValid( wheel ) ) then
                        this:Close()
                    end
                end

                local groups = dmenu:AddSubMenu( L( 'door_groups' ) )
                local teams = dmenu:AddSubMenu( L( 'jobs' ) )
                local add = teams:AddSubMenu( L( 'add' ) )
                local remove = teams:AddSubMenu( L( 'remove' ) )
            
                dmenu:AddOption( L( 'none' ), function()
                    RunConsoleCommand( 'darkrp', 'togglegroupownable' )
                    safeClose( wheel )
                end )

                for name in pairs( RPExtraTeamDoors ) do
                    groups:AddOption( name, function()
                        RunConsoleCommand( 'darkrp', 'togglegroupownable', name )
                        safeClose( wheel )
                    end )
                end

                for index, data in ipairs( RPExtraTeams ) do
                    local which = ( not doorTeams or not doorTeams[ index ] ) and add or remove
                    which:AddOption( data.name, function()
                        RunConsoleCommand( 'darkrp', 'toggleteamownable', index )
                        safeClose( wheel )
                    end )
                end
            
                dmenu:Open()
            end
        } )
    end

    local amount = #options
    if ( amount == 1 ) then
        options[ 1 ].callback()
    elseif ( amount > 0 and not IsValid( doorFrame ) ) then
        local size = onyx.hud.ScaleTall( 512 )
    
        local choiceWheel = vgui.Create( 'onyx.hud.ChoiceWheel' )
        doorFrame = choiceWheel
        choiceWheel:SetSize( size, size )
        choiceWheel:SetShowLabel( true )
        choiceWheel:MakePopup()
        choiceWheel:Center()
        choiceWheel.OnRemove = function()
            doorFrame = nil
        end
        choiceWheel.PostThink = function( this )
            if ( not checkEntity( client, ent ) ) then
                this:Close()
            end
        end
        
        choiceWheel:AddChoice( { name = onyx.lang:Get( 'close' ), wimgID = 'radial_close' } )
    
        for _, data in ipairs( options ) do
            choiceWheel:AddChoice( data )
        end
    end
end

local function overrideDarkRP()
    local gmTable = GAMEMODE or GM
    
    DarkRP.openKeysMenu = function()
        local client = LocalPlayer()
        CAMI.PlayerHasAccess( client, 'DarkRP_SetDoorOwner', function( setDoorOwnerAccess )
            CAMI.PlayerHasAccess( client, 'DarkRP_ChangeDoorSettings', function( canChangeSettings )
                openDoorMenu( client, setDoorOwnerAccess, canChangeSettings )
            end )
        end )
    end

    gmTable.ShowTeam = DarkRP.openKeysMenu
    usermessage.Hook( 'KeysMenu', DarkRP.openKeysMenu )
end

onyx.hud.OverrideGamemode( 'onyx.hud.OverrideKeysMenu', overrideDarkRP )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_main.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_overhead.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

11/08/2024

--]]

local hud = onyx.hud
local nearest = {}
local statuses = {}

local MAX_DISTANCE = 400 ^ 2
local MAX_GLOBAL_DRAWS = 12

local CONVAR_MAX_DETAILED = CreateClientConVar( 'cl_onyx_hud_3d2d_max_details', '3', true, false, '', 1, 5 )

local COLOR_LOW_HP = Color( 255, 59, 59)
local COLOR_MAX_HP = Color( 115, 255, 49)
local COLOR_ARMOR = Color( 52, 130, 255)
local COLOR_RED = Color( 255, 52, 52)
local COLOR_BLUE = Color( 55, 52, 255)
local COLOR_SLIGHT_SHADOW = Color( 0, 0, 0, 150 )
local ICON_SIZE = 64
local WIMG_LICENSE = onyx.wimg.Create( 'hud_license', 'smooth mips' )

local FONT_NAME = onyx.hud.CreateFont3D2D( 'OverheadName', 'Comfortaa Bold', 72 )
local FONT_JOB = onyx.hud.CreateFont3D2D( 'OverheadJob', 'Comfortaa SemiBold', 40 )
local FONT_STATUS = onyx.hud.CreateFont3D2D( 'OverheadStatus', 'Comfortaa Bold', 64 )

local drawShadowText = onyx.hud.DrawShadowText

local getStatuses, hasStatus do
    local function createStatus( data )
        data.wimg = onyx.wimg.Create( data.icon, 'smooth mips' )
        table.insert( statuses, data )
    end

    function getStatuses( ply )
        local result = {}
        for _, status in ipairs( statuses ) do
            if ( status.func( ply ) ) then
                table.insert( result, status )
            end
        end
        return result
    end

    -- Quicker than checking by amount
    function hasStatus( ply )
        for _, status in ipairs( statuses ) do
            if ( status.func( ply ) ) then
                return true
            end
        end
        return false
    end

    createStatus( {
        id = 'wanted',
        icon = 'hud_wanted',
        big = true,
        func = function( ply )
            return ply:getDarkRPVar( 'wanted' )
        end,
        getColor = function()
            local fraction = math.abs( math.sin( CurTime() ) )
            local color = onyx.LerpColor( fraction, COLOR_RED, COLOR_BLUE )
            return color
        end
    } )

    createStatus( {
        id = 'speaking',
        icon = 'hud_microphone',
        func = function( ply )
            return ply:IsSpeaking()
        end
    } )

    createStatus( {
        id = 'typing',
        icon = 'hud_chat',
        func = function( ply )
            return ply:IsTyping()
        end
    } )
end

local function drawStatus( ply, y )
    local halfIconSize = ICON_SIZE * .5
    local iconSpace = 10
    local statuses = getStatuses( ply )
    local amount = #statuses
    local totalW = amount * ICON_SIZE + ( amount - 1 ) * iconSpace
    local iconX = -totalW * .5
    local isSingle = amount == 1

    -- Draw microphone
    for i = 1, amount do
        local status = statuses[ i ]
        local color = status.getColor and status.getColor() or ( status.color or hud:GetColor( 'accent' ) )

        if ( isSingle and status.big ) then
            status.text = status.text or onyx.lang:Get( 'hud_status_' .. status.id )
            local text = status.text

            if ( status.dots ) then
                text = text .. string.rep( '.', CurTime() % 4 )
            end
        
            surface.SetFont( FONT_STATUS )
            local textW, textH = surface.GetTextSize( text )
            
            iconX = iconX - ( textW + iconSpace ) * .5

            drawShadowText( text, FONT_STATUS, iconX + ICON_SIZE + iconSpace, y + ICON_SIZE * .5 - textH * .5, color )
        end

        status.wimg:Draw( iconX + 2, y + 2, ICON_SIZE, ICON_SIZE, COLOR_SLIGHT_SHADOW )
        status.wimg:Draw( iconX, y, ICON_SIZE, ICON_SIZE, color )
    
        iconX = iconX + ICON_SIZE + iconSpace
    end
end

local function drawQuickInfo( ply, client )
    drawStatus( ply, 0 )
end

local function drawInfo( ply, client )
    local playerName = ply:Name()
    local teamID = ply:Team()
    local teamName = team.GetName( teamID )
    local teamColor = team.GetColor( teamID )
    local hasLicense = ply:getDarkRPVar( 'HasGunLicense' )
    local shouldDrawHealth = hud.IsElementEnabled( 'overhead_health' )

    local currentY = 0

    drawStatus( ply, -ICON_SIZE )

    -- Draw name
    if ( hasLicense ) then
        local iconSize = 32
        local iconSpace = 15

        surface.SetFont( FONT_NAME )
        local nameTextW, nameTextH = surface.GetTextSize( playerName )
        
        local nameX = ( nameTextW + iconSize + iconSpace ) * -.5
        local iconY = currentY + nameTextH * .5 - iconSize * .5
        
        WIMG_LICENSE:Draw( nameX + nameTextW + iconSpace + 2, iconY + 2, iconSize, iconSize, COLOR_SLIGHT_SHADOW )
        WIMG_LICENSE:Draw( nameX + nameTextW + iconSpace, iconY, iconSize, iconSize )

        drawShadowText( playerName, FONT_NAME, nameX, currentY, color_white )
        currentY = currentY + 65
    else
        drawShadowText( playerName, FONT_NAME, 0, currentY, color_white, 1, 0 )
        currentY = currentY + 65
    end

    -- Draw team
    drawShadowText( teamName, FONT_JOB, 0, currentY, teamColor, 1, 0 )
    currentY = currentY + 40

    -- Draw health & armor
    if ( shouldDrawHealth ) then
        local healthInt = ply:Health()
        local healthFraction = math.Clamp( healthInt / ply:GetMaxHealth(), 0, 1 )
        local healthColor = onyx.LerpColor( healthFraction, COLOR_LOW_HP, COLOR_MAX_HP )
        
        local armorInt = ply:Armor()
        local shouldDrawArmor = armorInt > 0 and hud.IsElementEnabled( 'overhead_armor' )

        local healthText = healthInt .. ' HP'
        
        if ( shouldDrawArmor ) then
            healthText = healthText .. '  '
            local armorText = armorInt .. ' AP'

            surface.SetFont( FONT_JOB )
            local healthTextWidth = surface.GetTextSize( healthText )
            local armorTextWidth = surface.GetTextSize( armorText )
            local totalTextWidth = healthTextWidth + armorTextWidth
            local textX = -totalTextWidth * .5
        
            drawShadowText( healthText, FONT_JOB, textX, currentY, healthColor )
            drawShadowText( armorText, FONT_JOB, textX + healthTextWidth, currentY, COLOR_ARMOR )
        else
            drawShadowText( healthText, FONT_JOB, 0, currentY, healthColor, 1, 0 )
        end

        currentY = currentY + 30
    end
end

timer.Create( 'onyx.hud.CollectNearestPlayers', 1 / 10, 0, function()
    local client = LocalPlayer()
    if ( IsValid( client ) ) then
        nearest = {}

        -- Make sure that any random error (if there is any) won't break the timer
        ProtectedCall( function()
            local origin = client:GetPos()
            local aimVector = client:GetAimVector()
        
            for _, ply in ipairs( player.GetAll() ) do
                local playerPos = ply:GetPos()
                if ( ply ~= client and ply:Alive() and ply:GetColor().a > 50 and ply:Health() > 0 and not ply:GetNoDraw() and ply:GetRenderMode() ~= RENDERMODE_NONE and playerPos:DistToSqr( origin ) <= MAX_DISTANCE ) then
                    local dotProduct = aimVector:Dot( ( playerPos - origin ):GetNormalized() )
                    if ( dotProduct > .6 ) then
                        table.insert( nearest, {
                            ply = ply,
                            dot = dotProduct
                        } )
                    end
                end
            end

            table.sort( nearest, function( a, b )
                return a.dot > b.dot
            end )
        end )
    end
end )

hook.Add( 'PostDrawTranslucentRenderables', 'onyx.hud.DrawOverheadInfo', function()
    local client = LocalPlayer()
    local index = 0

    for _, object in ipairs( nearest ) do
        local ply = object.ply
        if ( IsValid( ply ) ) then
            index = index + 1
            if ( index > MAX_GLOBAL_DRAWS ) then break end

            local detailed = index <= CONVAR_MAX_DETAILED:GetInt()
            local shouldDraw = detailed or hasStatus( ply )

            if ( shouldDraw ) then
                local _, maxs = ply:GetRenderBounds()
                local jobTable = ply:getJobTable() or {}
                local heightOffset = jobTable.onyxOverheadOffset or ( maxs.z + 10 )
                local pos = ply:GetPos() + Vector( 0, 0, heightOffset )
                local ang = Angle( 0, client:EyeAngles().y - 90, 90 )
                
                cam.Start3D2D( pos, ang, 0.075 )
                    if ( detailed ) then
                        drawInfo( ply, client )
                    else
                        drawQuickInfo( ply, client )
                    end
                cam.End3D2D()
            end
        end
    end
end )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_own_info.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/08/2024

--]]

local L = function( ... ) return onyx.lang:Get( ... ) end
local MAX_RANGE = 128 ^ 2

local hud = onyx.hud

local traceEntity = NULL
local showFraction = 0
local traceData

timer.Create( 'onyx.hud.CatchTraceVehicle', 1 / 6, 0, function()
    local client = LocalPlayer()
    if ( IsValid( client ) ) then
        local origin = client:GetPos()
        local trace = client:GetEyeTrace()
        local ent = trace.Entity

        if ( IsValid( ent ) and ent:IsVehicle() and not client:InVehicle() and ent:GetPos():DistToSqr( origin ) <= MAX_RANGE ) then
            local class = ent:GetVehicleClass()
            local vehTable = list.Get( 'Vehicles' )[ class ]
            if ( not vehTable and simfphys ) then
                vehTable = list.Get( "simfphys_vehicles" )[ class ]
            end

            local name = vehTable and ( vehTable.Name or class ) or class
        
            local owner = ent:getDoorOwner()
            local group = ent:getKeysDoorGroup()
            local info = L( 'hud_door_owner', { name = IsValid( owner ) and owner:Name() or L( 'unknown' ) } )

            if ( group ) then
                info = group
            end

            if ( traceEntity ~= ent ) then showFraction = 0 end
            
            traceEntity = ent

            -- it will be set to nil when the animation's fraction reaches 0
            traceData = {
                name = name,
                owner = owner,
                info = info
            }
        else
            traceEntity = NULL
        end
    end
end )

local function drawOwnInfo( element, client, scrW, scrH )
    local validTarget = IsValid( traceEntity )

    showFraction = math.Approach( showFraction, validTarget and 1 or 0, FrameTime() * 8 )
    
    if ( showFraction <= 0 or not traceData ) then 
        traceData = nil
        return 
    end

    local x0 = scrW * .5
    local y0 = scrH * .85

    local theme = hud:GetCurrentTheme()
    local colors = theme.colors
    local infoW = hud.ScaleWide( 200 )
    local infoH = hud.ScaleTall( 50 )    
    local infoX, infoY = x0 - infoW * .5, y0 - infoH * .5

    hud.OverrideAlpha( showFraction, function()

        hud.DrawRoundedBox( infoX, infoY, infoW, infoH, colors.primary )
        draw.SimpleText( traceData.name, hud.fonts.SmallBold, x0, y0, colors.textPrimary, 1, 4 )
        draw.SimpleText( traceData.info, hud.fonts.Tiny, x0, y0, colors.textSecondary, 1, 0 )

    end )
end

onyx.hud:RegisterElement( 'owner_info', { drawFn = drawOwnInfo } )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_pickup_history.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_votes.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

18/08/2024

--]]

onyx.hud.popups = onyx.hud.popups or {}

local L = function( ... ) return onyx.lang:Get( ... ) end
local hud = onyx.hud

local function startFadeAnimation( panel, target, callback )
    panel.animAlpha = panel:GetAlpha() / 255
    
    onyx.anim.Create( panel, .2, {
        index = 1,
        target = { animAlpha = target },
        easing = 'inOutSine',
        think = function( _, panel )
            panel:SetAlpha( panel.animAlpha * 255 )
        end,
        onFinished = function( _, panel )
            if ( callback ) then
                callback( panel )
            end
        end
    } )
end

local function movePopups()
    local padding = hud.GetScreenPadding()
    local space = hud.ScaleTall( 5 )
    local baseX = padding
    local baseY = padding
    local posY = baseY
    
    for _, popup in ipairs( onyx.hud.popups ) do
        popup.animY = popup.animY or posY

        popup:SetVisible( true )

        onyx.anim.Create( popup, .2, {
            index = 2,
            target = { animY = posY },
            easing = 'inOutSine',
            think = function( _, panel )
                panel:SetPos( baseX, panel.animY )
            end
        } )

        posY = posY + popup:GetTall() + space
    end
end

local function createPopup( title, desc, duration, acceptCallback, denyCallback, onRemove )
    local padding = hud.ScaleTall( 10 )
    local w = hud.ScaleWide( 200 )
    local titleFont = hud.fonts.TinyBold
    local descFont = hud.fonts.Tiny
    local isDark = onyx.hud:IsDark()

    desc = DarkRP.textWrap( desc, descFont, w - padding * 2 )

    local duration = duration or 5
    local endtime = CurTime() + duration

    surface.SetFont( titleFont )
    local _, titleH = surface.GetTextSize( title )

    surface.SetFont( descFont )
    local _, descH = surface.GetTextSize( desc )

    local buttonHeight = hud.ScaleTall( 20 )
    local elementSpace = hud.ScaleTall( 10 )
    local titleSpace = hud.ScaleTall( 5 )
    local totalHeight = padding * 2 + buttonHeight + descH + titleH + elementSpace + titleSpace

    local screenPadding = hud.GetScreenPadding()
    local h = totalHeight
    
    local popup = vgui.Create( 'Panel' )
    popup:SetSize( w, h )
    popup:SetAlpha( 0 )
    popup:SetVisible( false )
    popup:DockPadding( padding, padding, padding, padding )
    popup.Paint = function( panel, w, h )
        hud.DrawRoundedBox( 0, 0, w, h, hud:GetColor( 'primary' ) )
    end
    popup.Close = function( panel )
        startFadeAnimation( panel, 0, function( this )
            this:Remove()
        end )
    end
    popup.OnRemove = function( panel )
        for index, popup2 in ipairs( onyx.hud.popups ) do
            if ( panel == popup2 ) then
                table.remove( onyx.hud.popups, index )
                break
            end
        end
    
        movePopups()

        if ( onRemove ) then
            onRemove( panel )
        end
    end
    popup.Think = function( panel )
        if ( CurTime() > endtime and not panel.closed ) then
            panel.closed = true
            panel:Close()
        end
    end

    table.insert( onyx.hud.popups, popup )
    movePopups()

    startFadeAnimation( popup, 1 )

    local lblTitle = popup:Add( 'DLabel' )
    lblTitle:SetText( onyx.utf8.upper( title ) )
    lblTitle:SetFont( titleFont )
    lblTitle:SetTall( titleH )
    lblTitle:SetTextColor( hud:GetColor( 'textSecondary' ) )
    lblTitle:Dock( TOP )
    lblTitle:DockMargin( 0, 0, 0, titleSpace )
    lblTitle.Paint = function( panel, w, h )
        local timeLeft = math.max( 0, endtime - CurTime() )

        draw.SimpleText( math.Round( timeLeft ), panel:GetFont(), w, h * .5, panel:GetTextColor(), 2, 1 )
    end
    popup.lblTitle = lblTitle

    local lblDesc = popup:Add( 'DLabel' ) 
    lblDesc:SetText( desc )
    lblDesc:SetFont( descFont )
    lblDesc:SetTextColor( hud:GetColor( 'textPrimary' ) )
    lblDesc:SetContentAlignment( 7 )
    lblDesc:Dock( FILL )
    lblDesc:DockMargin( 0, 0, 0, elementSpace )
    popup.lblDesc = lblDesc

    local conButtons = popup:Add( 'Panel' )
    conButtons:SetTall( buttonHeight )
    conButtons:Dock( BOTTOM )
    conButtons.PerformLayout = function( panel, w, h )
        local space = hud.ScaleTall( 5 )
        local wide = math.Round( ( w - space ) / 2 )
        for _, child in ipairs( panel:GetChildren() ) do
            child:SetWide( wide )
            child:DockMargin( 0, 0, space, 0 )
            child:Dock( LEFT )
        end
    end

    local btnAccept = conButtons:Add( 'onyx.Button' )
    btnAccept:SetText( L( 'accept' ) )
    btnAccept:SetFont( hud.fonts.TinyBold )
    btnAccept:SetMasking( true )
    btnAccept:SetColorIdle( hud:GetColor( not isDark and 'tertiary' or 'accent' ) )
    btnAccept:SetColorHover( onyx.OffsetColor( btnAccept:GetColorIdle(), -20 ) )
    btnAccept:SetGradientColor( onyx.OffsetColor( btnAccept:GetColorIdle(), -20 ) )
    btnAccept:SetGradientDirection( TOP )
    btnAccept.DoClick = function()
        popup:Close()
        if ( acceptCallback ) then
            acceptCallback()
        end
    end
    popup.btnAccept = btnAccept

    local btnDeny = conButtons:Add( 'onyx.Button' )
    btnDeny:SetText( L( 'deny' ) )
    btnDeny:SetFont( hud.fonts.TinyBold )
    btnDeny:SetMasking( true )
    btnDeny:SetColorIdle( hud:GetColor( 'tertiary' ) )
    btnDeny:SetColorHover( onyx.OffsetColor( hud:GetColor( 'tertiary' ), -10 ) )
    btnDeny:SetGradientColor( onyx.OffsetColor( btnDeny:GetColorIdle(), -20 ) )
    btnDeny:SetGradientDirection( TOP )
    btnDeny.DoClick = function()
        popup:Close()
        if ( denyCallback ) then
            denyCallback()
        end
    end
    popup.btnDeny = btnDeny

    hook.Add( 'onyx.hud.OnChangedTheme', popup, function( this )
        this.lblTitle:SetTextColor( hud:GetColor( 'textSecondary' ) )
        this.lblDesc:SetTextColor( hud:GetColor( 'textPrimary' ) )

        this.btnAccept:SetColorIdle( hud:GetColor( not isDark and 'tertiary' or 'accent' ) )
        this.btnAccept:SetColorHover( onyx.OffsetColor( this.btnAccept:GetColorIdle(), -20 ) )
        this.btnAccept:SetGradientColor( onyx.OffsetColor( this.btnAccept:GetColorIdle(), -20 ) )

        this.btnDeny:SetColorIdle( hud:GetColor( 'tertiary' ) )
        this.btnDeny:SetColorHover( onyx.OffsetColor( hud:GetColor( 'negative' ), -20 ) )
        this.btnDeny:SetGradientColor( onyx.OffsetColor( this.btnDeny:GetColorIdle(), -20 ) )
    end )

    return popup
end

local function overrideDarkRP()
    usermessage.Hook( 'DoVote', function( msg )
        local text = msg:ReadString()
        local voteID = msg:ReadShort()
        local duration = msg:ReadFloat()
    
        if ( duration == 0 ) then
            duration = 100
        end

        local popup = createPopup( L( 'vote' ), text, duration, function()
            LocalPlayer():ConCommand( 'vote ' .. voteID .. ' yea\n' )
        end, function()
            LocalPlayer():ConCommand( 'vote ' .. voteID .. ' nay\n' )
        end )

        popup.voteID = voteID
    end )

    usermessage.Hook( 'DoQuestion', function( msg )
        local text = msg:ReadString()
        local questionID = msg:ReadString()
        local duration = msg:ReadFloat()
    
        if ( duration == 0 ) then
            duration = 100
        end

        local popup = createPopup( L( 'question' ), text, duration, function()
            LocalPlayer():ConCommand( 'ans ' .. questionID .. ' 1\n' )
        end, function()
            LocalPlayer():ConCommand( 'ans ' .. questionID .. ' 2\n' )
        end )

        popup.questionID = questionID
    end )

    usermessage.Hook( 'KillVoteVGUI', function( msg )
        local id = msg:ReadShort()
        for _, popup in ipairs( hud.popups ) do
            if ( popup.voteID == id ) then
                popup:Close()
                break
            end
        end
    end )

    usermessage.Hook( 'KillQuestionVGUI', function( msg )
        local id = msg:ReadString()    
        for _, popup in ipairs( hud.popups ) do
            if ( popup.questionID == id ) then
                popup:Close()
                break
            end
        end
    end )

    concommand.Add( 'rp_vote', function( ply, cmd, args )
        local value = string.lower( args[ 1 ] or '' )
        local vote = 0
        if ( tonumber( value ) == 1 ) or ( value == 'yes' ) or ( value == 'true' ) then vote = 1 end
    
        for _, popup in ipairs( hud.popups ) do
            if ( popup.questionID ) then
                popup:Close()
                RunConsoleCommand( 'ans', popup.questionID, vote )
                break
            elseif ( popup.voteID ) then
                popup:Close()
                RunConsoleCommand( 'vote', popup.voteID, vote )
                break
            end
        end
    end )
end

onyx.hud.OverrideGamemode( 'onyx.hud.OverrideVoteMenus', overrideDarkRP )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/ui/cl_settings.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/ui/cl_settings.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local COLOR_PRIMARY = onyx:Config( 'colors.primary' )
local COLOR_SECONDARY = onyx:Config( 'colors.secondary' )
local COLOR_TERTIARY = onyx:Config( 'colors.tertiary' )
local COLOR_ACCENT = onyx:Config( 'colors.accent' )
local COLOR_GRAY = Color( 150, 150, 150)
local COLOR_BUTTON_HOVER = onyx.LerpColor( .5, COLOR_TERTIARY, COLOR_ACCENT )
local FONT_NAME = onyx.Font( 'Comfortaa Bold@16' )
local FONT_DESC = onyx.Font( 'Comfortaa@14' )
local FONT_BUTTON = onyx.Font( 'Comfortaa Bold@32' )

local PANEL = {}

function PANEL:Init()
    self.list = self:Add( 'onyx.ScrollPanel' )
    self.list:Dock( FILL )

    self.grid = self.list:Add( 'onyx.Grid' )
    self.grid:Dock( FILL )
    self.grid:SetColumnCount( 2 )
    self.grid:SetSpace( onyx.ScaleTall( 5 ) )

    self:LoadOptions()
end

function PANEL:LoadOptions()
    if ( not onyx.hud:GetOptionValue( 'restrict_themes' )) then
        local themeOptions = {}

        for id, theme in pairs( onyx.hud.themes ) do
            table.insert( themeOptions, {
                name = onyx.lang:Get( string.format( 'hud.theme.%s.name', id ) ),
                key = id
            } )
        end

        self:AddOption( 'combo', 'theme', 'cl_onyx_hud_theme_id', {
            options = themeOptions
        } )
    end

    self:AddOption( 'int', 'scale', 'cl_onyx_hud_scale' )
    self:AddOption( 'int', 'roundness', 'cl_onyx_hud_roundness', { step = 4 } )
    self:AddOption( 'int', 'margin', 'cl_onyx_hud_screen_padding', { step = 5 } )
    self:AddOption( 'int', '3d2d_max_details', 'cl_onyx_hud_3d2d_max_details', { step = 1 } )

    self:AddOption( 'bool', 'compact', 'cl_onyx_hud_compact' )
    self:AddOption( 'bool', 'speedometer_blur', 'cl_onyx_hud_speedometer_blur' )
    self:AddOption( 'bool', 'wpnsel_sounds', 'cl_onyx_hud_wpnsel_sounds' )

    if ( onyx.hud:GetOptionValue( 'main_avatar_mode' ) == 1 ) then
        self:AddOption( 'bool', 'icons_3d', 'cl_onyx_hud_3d_models' )
    end
end

function PANEL:AddOption( optionType, id, convarName, data )
    local text = onyx.lang:Get( 'hud.' .. id .. '.name' )
    local desc = onyx.lang:Get( 'hud.' .. id .. '.desc' )
    local convarObject = GetConVar( convarName )
    local data = data or {}
    local field = self:CreateField( text, desc )
    local height = field:GetTall() - field.padding * 2
    
    if ( optionType == 'bool' ) then
        field.centerChild = false

        field.togglerContainer = field:Add('Panel')
        field.togglerContainer:SetWide( onyx.ScaleWide( 50 ) )
        field.togglerContainer:Dock( RIGHT )
        field.togglerContainer.PerformLayout = function( panel, w, h )
            local child = panel:GetChild( 0 )
            if ( IsValid( child ) ) then
                child:SetTall( child:GetWide() * .5 )
                child:Center()
            end
        end

        field.toggler = field.togglerContainer:Add('onyx.Toggler')
        field.toggler:SetBackgroundColor( COLOR_TERTIARY )
        field.toggler:SetChecked( convarObject:GetBool(), true )
        field.toggler.OnChange = function( panel, newBool )
            convarObject:SetBool( newBool )
        end
    elseif ( optionType == 'combo' ) then
        local value = convarObject:GetString()
        
        local combo = field:Add( 'onyx.ComboBox' )
        combo:SetWide( onyx.ScaleWide( 175 ) )
        combo:Dock( RIGHT )
        combo.OnSelect = function( panel, index, text, data )
            convarObject:SetString( data )
        end

        for i, opt in ipairs( data.options or {} ) do
            local key = opt.key

            combo:AddOption( opt.name, key )

            if ( key == value ) then
                combo:ChooseOptionID( i )
            end
        end
    elseif ( optionType == 'int' ) then
        local lblValue
        local min = convarObject:GetMin()
        local max = convarObject:GetMax()
        local step = data.step or 5

        local btnAdd = field:Add( 'DButton' )
        btnAdd:SetText( '' )
        btnAdd:SetWide( height )
        btnAdd:Dock( RIGHT )
        btnAdd.Paint = function( panel, w, h )
            draw.RoundedBoxEx( 8, 0, 0, w, h, panel:IsHovered() and COLOR_BUTTON_HOVER or COLOR_TERTIARY, false, true, false, true )
            draw.SimpleText( '+', FONT_BUTTON, w * .5, h * .5, color_white, 1, 1 )
        end
        btnAdd.DoClick = function( panel )
            local newValue = math.floor( math.Clamp( convarObject:GetInt() + step, min, max ) / step ) * step

            surface.PlaySound('onyx/ui/on_click/footfall_click.wav')
            convarObject:SetInt( newValue )
            
            lblValue:SetText( newValue )
        end

        lblValue = field:Add( 'onyx.Label' )
        lblValue:SetWide( onyx.ScaleWide( 50 ) )
        lblValue:SetContentAlignment( 5 )
        lblValue:SetText( convarObject:GetInt() )
        lblValue:Dock( RIGHT )
        lblValue:Font( 'Comfortaa SemiBold@20' )
        lblValue.Paint = function( panel, w, h )
            draw.RoundedBox( 0, 0, 0, w, h, COLOR_PRIMARY )
        end

        local btnDecrease = field:Add( 'DButton' )
        btnDecrease:SetText( '' )
        btnDecrease:SetWide( height )
        btnDecrease:Dock( RIGHT )
        btnDecrease.Paint = function( panel, w, h )
            draw.RoundedBoxEx( 8, 0, 0, w, h, panel:IsHovered() and COLOR_BUTTON_HOVER or COLOR_TERTIARY, true, false, true )
            draw.SimpleText( '-', FONT_BUTTON, w * .5, h * .5, color_white, 1, 1 )
        end
        btnDecrease.DoClick = function( panel )
            local newValue = math.floor( math.Clamp( convarObject:GetInt() - step, min, max ) / step ) * step

            surface.PlaySound('onyx/ui/on_click/footfall_click.wav')
            convarObject:SetInt( newValue )
            
            lblValue:SetText( newValue )
        end
    end
end

function PANEL:CreateField( text, desc )
    local padding = onyx.ScaleTall(7.5)

    local field = self.grid:Add( 'DPanel' )
    field:SetTall( onyx.ScaleTall(45) )
    field:DockPadding( padding, padding, padding, padding )
    field.centerChild = true
    field.padding = padding
    field.Paint = function( p, w, h )
        draw.RoundedBox( 8, 0, 0, w, h, COLOR_SECONDARY )
        draw.SimpleText( text, FONT_NAME, padding, h * .5, COLOR_ACCENT, 0, 4 )
        draw.SimpleText( desc, FONT_DESC, padding, h * .5, COLOR_GRAY, 0, 0 )
    end
    field.PerformLayout = function( panel, w, h )
        local child = panel:GetChild( 0 )
        if ( IsValid( child ) and panel.centerChild ) then
            
        end
    end

    return field
end

onyx.gui.Register( 'onyx.hud.ClientSettings', PANEL )
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_spanish.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/cfg/cl_actions.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

--[[------------------------------
**WARNING**
This is an advanced config.
Most of the things you need should be configurable through the game.
Do not edit anything if you do not understand what you are doing.
--------------------------------]]

onyx.scoreboard.Buttons = {}
onyx.scoreboard.adminHandler = nil

local adminHandlers = {}

local TYPE_NAME = 1
local TYPE_STEAMID64 = 2
local TYPE_STEAMID32 = 3

local function adminModeHandler(uniqueID, priority, validator, data)
    table.insert(adminHandlers, {
        uniqueID = uniqueID,
        priority = priority,
        validator = validator,
        data = data
    })
end

local function registerAdminButton(cmd, icon, cmdData)
    onyx.scoreboard:RegisterButton(cmd, {
        icon = icon,
        callback = function(ply)
            local handler = onyx.scoreboard.adminHandler
            local data = handler.data
            local command = cmdData.getCommand and cmdData.getCommand(ply) or cmd

            local targetID
            if (data.idFormat == TYPE_STEAMID32) then
                targetID = ply:SteamID()
            elseif (data.idFormat == TYPE_STEAMID64) then
                targetID = ply:SteamID64()
            else
                targetID = ply:Name()
            end

            RunConsoleCommand(handler.uniqueID, command, targetID)
        end,
        getVisible = function(client)
            local handler = onyx.scoreboard.adminHandler
            if (not handler) then return false end

            local data = handler.data
            return data.hasPermission(client, cmd)
        end
    })
end

--[[------------------------------
Common actions
--------------------------------]]
onyx.scoreboard:RegisterButton('profile', {
    icon = 'https://i.imgur.com/ojNCwan.png',
    callback = function(ply)
        gui.OpenURL('https://steamcommunity.com/profiles/' .. ply:SteamID64())
    end
})

--[[------------------------------
FSpectate
--------------------------------]]
onyx.scoreboard:RegisterButton('spectate', {
    icon = 'https://i.imgur.com/kGncVTG.png',
    callback = function(ply)
        if (ply ~= LocalPlayer()) then
            net.Start("FSpectateTarget")
                net.WriteEntity(ply)
            net.SendToServer()
        end
    end,
    getVisible = function(client)
        local success, bHasAccess = pcall(CAMI.PlayerHasAccess, client, 'FSpectate')
        if (not success) then
            bHasAccess = client:IsSuperAdmin()
        end
        return (FSpectate ~= nil and (success and bHasAccess))
    end
})

--[[------------------------------
Admin actions
--------------------------------]]
registerAdminButton('freeze', 'https://i.imgur.com/4l3z6vi.png', {
    getCommand = function(target)
        return (target:IsFlagSet(FL_FROZEN) and 'unfreeze' or 'freeze')
    end
})

registerAdminButton('goto', 'https://i.imgur.com/qtWhznQ.png', {})
registerAdminButton('bring', 'https://i.imgur.com/e2Jut95.png', {})
registerAdminButton('return', 'https://i.imgur.com/xY56yG2.png', {})
registerAdminButton('respawn', 'https://i.imgur.com/ymwK6lH.png', {})
registerAdminButton('slay', 'https://i.imgur.com/GOuu3BA.png', {})

--[[------------------------------
Admin modes
--------------------------------]]
adminModeHandler('sam', 100, function()
    return sam
end, {
    idFormat = TYPE_STEAMID64,
    hasPermission = function(client, cmd)
        return client:HasPermission(cmd)
    end
})

adminModeHandler('sa', 100, function()
    return sAdmin
end, {
    idFormat = TYPE_NAME,
    hasPermission = function(client, cmd)
        return sAdmin.hasPermission( cmd )
    end
})

do
    local DISABLED = {
        ['respawn'] = true,
    }

    adminModeHandler('ulx', 100, function()
        return ulx
    end, {
        idFormat = TYPE_NAME,
        hasPermission = function(client, cmd)
            return (client:query('ulx ' .. cmd) == true and not DISABLED[cmd])
        end
    })
end

do
    local DISABLED = {
        ['respawn'] = true,
        ['return'] = true,
    }

    adminModeHandler('fadmin', 1, function()
        return FAdmin
    end, {
        idFormat = TYPE_STEAMID32,
        hasPermission = function(client, cmd)
            return (client:IsAdmin() and not DISABLED[cmd])
        end
    })
end

--[[------------------------------
Fetch admin mode
--------------------------------]]
onyx.WaitForGamemode('onyx.scoreboard.InitButtons', function()
    table.sort(adminHandlers, function(a, b)
        return a.priority > b.priority
    end)

    for _, handler in ipairs(adminHandlers) do
        if (handler.validator()) then
            onyx.scoreboard.adminHandler = handler
            break
        end
    end

    if (onyx.scoreboard.adminHandler) then
        onyx.scoreboard:PrintSuccess('Found admin handler: ' .. onyx.scoreboard.adminHandler.uniqueID)
    else
        onyx.scoreboard:PrintWarning('Admin handler has not been found.')
    end
end)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_player_list.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

local COLOR_PRIMARY = onyx:Config('colors.primary')
local COLOR_SECONDARY = onyx:Config('colors.secondary')
local COLOR_TERTIARY = onyx:Config('colors.tertiary')
local COLOR_ACCENT = onyx:Config('colors.accent')
local COLOR_GRAY = Color(149, 149, 149)
local COLOR_GRAY_LIGHT = Color(198, 198, 198)

local WIMG_ARROW = onyx.wimg.Simple('https://i.imgur.com/oOoWQAG.png', 'smooth mips')

local function parseString(str)
    return onyx.utf8.lower(str)
end

local function processSearch(prompt, parentList)
    local prompt = string.lower(prompt):Trim()
    local categories = parentList:GetItems()

    for _, category in ipairs(categories) do
        if (category.ClassName ~= 'onyx.Category') then continue end

        for _, panel in ipairs(category:GetItems()) do
            local line = panel.button:GetChild(0)
            local name = line.parsedName
            local steamID32 = line.steamID32

            if (string.find(name, prompt, nil, true) or steamID32 == prompt or (prompt == '^' and line.isLocalPlayer)) then
                panel:Show()
                category:SetExpanded(true)
            else
                panel:Hide()
            end
        end

        category:Update()
    end
end

--[[------------------------------
// PANEL
--------------------------------]]
local PANEL = {}

function PANEL:Init()
    local toolbarPadding = onyx.ScaleTall(5)
    local elementSpace = onyx.ScaleTall(10)
    local playerLineHeight = onyx.ScaleTall(30)
    local playerLinePadding = onyx.ScaleTall(5)
    local playerLineRealHeight = playerLineHeight - playerLinePadding * 2

    self.toolbarPadding = toolbarPadding
    self.playerLineHeight = playerLineHeight
    self.playerLinePadding = playerLinePadding

    self.toolbar = self:Add('Panel')
    self.toolbar.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, COLOR_SECONDARY)
    end
    self.toolbar.PerformLayout = function(panel, w, h)
        local contentMarginLeft = toolbarPadding * 3 + playerLineRealHeight * 2
        local scroll = self.list.scroll

        if (scroll:IsVisible()) then
            contentMarginLeft = contentMarginLeft + scroll:GetWide() + select(1, scroll:GetDockMargin())
        end

        panel:DockPadding(toolbarPadding, toolbarPadding, contentMarginLeft, toolbarPadding)
        panel:DockMargin(0, 0, 0, elementSpace)
    end

    self.search = self.toolbar:Add('onyx.TextEntry')
    self.search:SetPlaceholderText(onyx.lang:Get('scoreboard_search'))
    self.search:SetPlaceholderIcon('https://i.imgur.com/Nk3IUJT.png', 'smooth mips')
    self.search:SetUpdateOnType(true)
    self.search:Dock(LEFT)
    self.search:SetWide(onyx.ScaleWide(175))
    self.search:SetCursor('beam')
    self.search.OnValueChange = function(panel, value)
        processSearch(value, self.list)
    end

    self.search.textEntry:SetTabbingDisabled(true)
    self.search.textEntry:SetMouseInputEnabled(false) -- this one is required to get access to parent, which triggers SetKeyboardInputEnabled on parent
    self.search.OnMousePressed = function(panel)
        onyx.scoreboard.Frame:SetKeyboardInputEnabled(true)
        onyx.scoreboard.Frame:ShowCloseButton(true)
        onyx.scoreboard.Frame.closeDisabled = true

        panel.textEntry:SetMouseInputEnabled(true)
        panel.textEntry:RequestFocus()
    end

    self.columns = self.toolbar:Add('onyx.Scoreboard.ColumnsRow')
    self.columns:Dock(FILL)
    self.columns:DockMargin(toolbarPadding, 0, 0, 0)
    self.columns:SetFont(onyx.Font('Comfortaa Bold@16'))
    self.columns:SetHeader(true)
    self.columns:InitColumns()

    self:AddSorting(self.columns)

    self.list = self:Add('onyx.ScrollPanel')
    self.list:SetSpace(onyx.ScaleTall(1))
    self.list.canvas:On('OnContainerTallUpdated', function()
        self.toolbar:InvalidateLayout()
    end)

    self.players = {}
    self:LoadPlayers()
end

function PANEL:PerformLayout(w, h)
    self.toolbar:Dock(TOP)
    self.toolbar:SetTall(onyx.ScaleTall(35))

    self.list:Dock(FILL)
end

do
    function PANEL:FetchCategory(ply)
        if (DarkRP and onyx.scoreboard:GetOptionValue('group_teams')) then
            local jobData = RPExtraTeams[ply:Team()]
            if (jobData) then
                return jobData.category
            end
         end

        if (onyx.scoreboard.IsTTT()) then
            local _, name, color = onyx.scoreboard.GetTeamTTT(ply)
            return name, color
        end

        return team.GetName(ply:Team()), team.GetColor(ply:Team())
    end
end

function PANEL:LoadPlayers()
    local categories = {}
    local players = {}

    -- add players
    for _, ply in ipairs(player.GetAll()) do
        local bShouldHide = hook.Run('onyx.scoreboard.ShouldHidePlayer', ply) -- for possible custom integrations
        if (bShouldHide ~= true) then
            table.insert(players, ply)
        end
    end

    -- default sorting
    table.sort(players, function(a, b)
        return a:Team() < b:Team()
    end)

    for _, ply in ipairs(players) do
        local catName, catColor = self:FetchCategory(ply)
        local foundIndex

        for index, category in ipairs(categories) do
            if (category.name == catName) then
                foundIndex = index
                break
            end
        end

        if (not foundIndex) then
            local panel = self:AddCategory(onyx.utf8.upper(catName), catColor) -- utf-8 support

            foundIndex = table.insert(categories, {
                panel = panel,
                name = catName,
                color = catColor, -- might be nil
                players = {}
            })
        end

        table.insert(categories[foundIndex].players, ply)
    end

    self.queue = {}
    for _, category in ipairs(categories) do
        for _, ply in ipairs(category.players) do
            table.insert(self.queue, {
                category = category.panel,
                ply = ply
            })
        end
    end
end

function PANEL:Think()
    local queue = self.queue
    if (queue) then
        local object = queue[1]
        if (object) then
            local ply = object.ply
            local cat = object.category

            table.remove(queue, 1)

            if (IsValid(ply)) then
                self:AddPlayer(ply, cat)
                cat:Update()
            end
        end
    end
end

function PANEL:AddSorting(panel)
    for index, column in ipairs(panel.columns) do
        panel:SetClickFunc(index, function()
            self:SortByColumn(index, column)
        end)

        column.arrowAngle = 0
        column.PaintOver = function(panel, w, h)
            if (not panel.active) then return end

            local text = panel:GetText()
            local xOffset = -ScreenScale(3)
            local size = math.min(h, onyx.ScaleTall(12))
            local xPosOverride

            if (text ~= '') then
                local textW = panel:GetContentSize()
                if (panel.TextLeft) then
                    xPosOverride = textW + size * .5 - xOffset
                else
                    xOffset = xOffset - textW * .5
                end
            else
                xOffset = xOffset - size * .5
            end

            local targetAngle = panel.ascending and 90 or -90
            column.arrowAngle = Lerp(FrameTime() * 16, column.arrowAngle, targetAngle)

            DisableClipping(true)
                WIMG_ARROW:DrawRotated(xPosOverride or (w * .5 + xOffset - size * .5), h * .5, size, size, column.arrowAngle)
            DisableClipping(false)
        end
    end
end

function PANEL:SortByColumn(index, column)
    local oldColumn = self.currentColumn
    local data = column.data
    local resorted = {}

    if (IsValid(oldColumn)) then
        oldColumn:SetTextColor(COLOR_GRAY)
        oldColumn.hoverBlocked = false
        oldColumn.active = false
    end

    column.hoverBlocked = true
    column.ascending = not column.ascending
    column.active = true
    column:SetTextColor(COLOR_ACCENT)

    self.currentColumn = column

    -- sort
    table.sort(self.players, function(aPlayer, bPlayer)
        local aColumn = aPlayer.content.columns[index]
        local bColumn = bPlayer.content.columns[index]

        local aValue = aColumn.Value
        local bValue = bColumn.Value

        if (column.ascending) then
            return aValue > bValue
        else
            return aValue < bValue
        end
    end)

    -- rearrange elements
    for index, playerLine in ipairs(self.players) do
        local parent = playerLine.category
        local parentCategory = parent:GetParent():GetParent()

        parent:SetZPos(index)

        if (not resorted[parentCategory]) then
            parentCategory:SetZPos(index)
            parentCategory:SetAlpha(0)
            parentCategory:AlphaTo(255, .1)

            resorted[parentCategory] = index
        end
    end

    self.list:InvalidateLayout()
end

function PANEL:AddPlayer(ply, parentCategory)
    if (not IsValid(ply)) then return end

    -- create fake category
    local cat = parentCategory:Add('onyx.Category')
    cat:SetCategoryHeight(self.playerLineHeight)
    cat:SetTall(cat:GetCategoryHeight())
    cat:SetInset(onyx.ScaleTall(10))
    cat:SetSpace(0)
    cat:DockMargin(0, 0, 0, onyx.ScaleTall(2.5))
    cat:Dock(TOP)

    -- keep size up to date
    cat:InjectEventHandler('PerformLayout')
    cat:On('PerformLayout', function(panel)
        if (panel.onyxAnims and panel.onyxAnims[1]) then -- fixes unpleasant view glitch
            parentCategory:Update()
        end
    end)

    -- reset inside
    cat.button:Clear()
    cat.button.Paint = nil
    cat.button:DockPadding(0, 0, 0, 0)

    cat.canvas:SetTall(0)
    cat.canvas.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, onyx.LerpColor(.025, COLOR_PRIMARY, color_black), false, false, true, true)
    end

    local profile = cat:Add('onyx.scoreboard.PlayerInspector')
    profile:Dock(TOP)
    profile:SetupPlayer(ply)

    -- create actual playerLine
    local playerLine = cat.button:Add('onyx.Scoreboard.PlayerLine')
    playerLine:SetupPlayer(ply)
    playerLine:Dock(FILL)
    playerLine:Import('click')
    playerLine.DoClick = function()
        cat.button:DoClick()
    end
    playerLine.DoRightClick = function(panel)
        if ( cat:GetExpanded() ) then return end

        local x, y = panel:LocalToScreen(0, 0)
    
        local dmenu = vgui.Create('onyx.Menu')
        dmenu:SetPos(input.GetCursorPos())
        dmenu.Think = function(panel)
            if ( cat:GetExpanded() ) then
                panel:Close()
            end
        end

        for _, buttonTable in ipairs(onyx.scoreboard.Buttons) do
            local getVisible = buttonTable.getVisible
            if (getVisible and getVisible(LocalPlayer()) == false) then continue end
            if (buttonTable.icon) then
                buttonTable.wimg = buttonTable.wimg or onyx.wimg.Simple( buttonTable.icon, 'smooth mips' )
            end

            local option = dmenu:AddOption(onyx.lang:Get('scoreboard_btn_' .. buttonTable.name), function()
                if (IsValid(ply)) then
                    buttonTable.callback(ply)
                end
            end)
            option.wimage = buttonTable.wimg
        end

        dmenu:Open(panel)
    end

    -- to perfectly align UI elements
    playerLine.firstElementWidth = self.search:GetWide()
    playerLine.paddingX = self.toolbarPadding
    playerLine.padding = self.playerLinePadding

    -- link to other panels
    playerLine.category = cat
    playerLine.list = self.list

    -- for search
    playerLine.parsedName = parseString(ply:Name())
    playerLine.steamID32 = parseString(ply:SteamID())
    playerLine.isLocalPlayer = LocalPlayer() == ply

    table.insert(self.players, playerLine)
end

function PANEL:AddCategory(name, color)
    local cat = self.list:Add('onyx.Category')
    cat:Dock(TOP)
    cat:SetTitle(name)
    cat:SetSpace(onyx.ScaleTall(5))
    cat:SetInset(0)
    cat:SetTextMargin(self.toolbarPadding + 2)
    cat:DockMargin(0, 0, 0, onyx.ScaleTall(5))

    cat:SetExpanded(true)
    cat:UpdateInTick()

    if (color) then
        cat.button.PaintOver = function(panel, w, h)
            local x, y = panel:LocalToScreen(0, 0)
            local lineWidth = 2

            render.SetScissorRect(x, y, x + lineWidth, y + h, true)
            -- render.SetScissorRect(x, y + h - lineWidth, x + w, y + h, true)
                draw.RoundedBox(8, 0, 0, w, h, color)
            render.SetScissorRect(0, 0, 0, 0, false)
        end
    end

    return cat
end

onyx.gui.Register('onyx.Scoreboard.PlayerList', PANEL)

--[[------------------------------
--//ANCHOR onyx.scoreboard.PlayerInspector
--------------------------------]]
local COLOR_GOLD = Color(255, 224, 101)
local COLOR_FRIEND = Color(134, 249, 124)
local wimgCopy = onyx.wimg.Simple('https://i.imgur.com/OolNq4H.png', 'smooth mips')

local function setTextColor(label, color)
    label.colorIdle = color
    label:SetTextColor(color)
end

local PANEL = {}

AccessorFunc(PANEL, 'm_ePlayer', 'Player')

function PANEL:Init()
    self.buttonHeight = onyx.ScaleTall(20)

    local avatarOutline = 2
    local avatarRoundness = 16

    self._avatar = self:Add('Panel')
    self._avatar.PerformLayout = function(panel, w, h)
        local size = math.min(h, self._avatar:GetWide()) - avatarOutline * 2

        self.avatar:SetSize(size, size)
        self.avatar:Center()

        local x, y = self.avatar:GetPos()

        panel.poly = onyx.CalculateRoundedBox(avatarRoundness, x, y, size, size)
    end
    self._avatar.Paint = function(panel, w, h)
        local x, y = self.avatar:GetPos()
        local size = self.avatar:GetWide() + avatarOutline * 2

        draw.RoundedBox(avatarRoundness, x - avatarOutline, y - avatarOutline, size, size, color_white)

        onyx.DrawWithPolyMask(panel.poly, function()
            self.avatar:PaintManual()
        end)
    end

    self.avatar = self._avatar:Add('AvatarImage')
    self.avatar:SetPaintedManually(true)

    self.buttons = self:Add('onyx.Grid')
    self.buttons:SetColumnCount(3)
    self.buttons:SetSpace(onyx.ScaleTall(5))

    self.info = self:Add('Panel')

    for _, buttonTable in ipairs(onyx.scoreboard.Buttons) do
        local getVisible = buttonTable.getVisible

        if (getVisible and getVisible(LocalPlayer()) == false) then continue end

        if ( buttonTable.icon ) then
            buttonTable.wimg = buttonTable.wimg or onyx.wimg.Simple( buttonTable.icon, 'smooth mips' )
        end

        self:AddButton(onyx.lang:Get('scoreboard_btn_' .. buttonTable.name), buttonTable.wimg, function()
            local ply = self:GetPlayer()
            if (IsValid(ply)) then
                buttonTable.callback(ply)
            end
        end)
    end

    self.labels = {}
    self:AddLabel('name', 'Name')
    self:AddLabel('rank', 'Rank')
    self:AddLabel('steamid32', 'SteamID32')
    self:AddLabel('steamid64', 'SteamID64')

    self:UpdateHeight()
end

function PANEL:UpdateHeight()
    local infoHeight = 0

    -- this one should be pairs
    for _, label in pairs(self.labels) do
        infoHeight = infoHeight + label:GetParent():GetTall()
    end

    self:SetTall(math.max(self.buttons:GetContentHeight(), infoHeight))
end

function PANEL:PerformLayout(w, h)
    self._avatar:Dock(LEFT)
    self._avatar:SetWide(h * .75)
    self._avatar:DockMargin(0, 0, onyx.ScaleTall(10), 0)

    self.buttons:SetWide(w * .5)
    self.buttons:Dock(RIGHT)

    self.info:Dock(FILL)
end

function PANEL:SetupPlayer(ply)
    local yourself = ply == LocalPlayer()
    local name = ply:Name()
    local formattedName = name

    self.avatar:SetPlayer(ply, 128)

    if (yourself) then
        formattedName = formattedName .. ' (' .. onyx.lang:Get('you') .. ')'
        setTextColor(self.labels.name, COLOR_GOLD)
    elseif (ply:GetFriendStatus() == 'friend') then
        formattedName = formattedName .. ' (' .. onyx.lang:Get('friend') .. ')'
        setTextColor(self.labels.name, COLOR_FRIEND)
    end

    self:SetPlayer(ply)

    self:SetLabelValue('name', formattedName, name)
    self:SetLabelValue('rank', ply:GetUserGroup())
    self:SetLabelValue('steamid32', ply:SteamID())
    self:SetLabelValue('steamid64', ply:SteamID64())
end

function PANEL:SetLabelValue(id, value, rawValue)
    self.labels[id]:SetText(value)
    self.labels[id]:SizeToContentsX()
    self.labels[id].Value = rawValue or value
end

function PANEL:AddLabel(id, title)
    local row = self.info:Add('Panel')
    row:SetTall(onyx.ScaleTall(20))
    row:Dock(TOP)
    row:DockMargin(0, 0, 0, 0)

    local lblTitle = row:Add('onyx.Label')
    lblTitle:SetText(title .. ': ')
    lblTitle:SetTextColor(COLOR_GRAY_LIGHT)
    lblTitle:Dock(LEFT)
    lblTitle:SizeToContentsX()
    lblTitle:SetContentAlignment(7)

    local lblValue = row:Add('onyx.Label')
    lblValue:SetText('Example')
    lblValue:SetContentAlignment(7)
    lblValue:Dock(LEFT)
    lblValue:Font('Comfortaa Bold@16')
    lblValue:SizeToContentsX()
    lblValue:Import('click')
    lblValue.Value = 'Example'
    setTextColor(lblValue, color_white)
    lblValue.Think = function(panel)
        panel:SetTextColor(panel:IsHovered() and COLOR_ACCENT or panel.colorIdle)
    end
    lblValue.Paint =function(panel, w, h)
        if (not panel:IsHovered()) then return end

        local size = h * .66
        local space = onyx.ScaleTall(5)
        DisableClipping(true)
            wimgCopy:Draw(w + space, h * .5 - size * .5, size, size, COLOR_ACCENT)
        DisableClipping(false)
    end
    lblValue.DoClick = function(panel)
        SetClipboardText(panel.Value)
        notification.AddLegacy(onyx.lang:Get('copied_clipboard'), 0, 5)
    end

    self.labels[id] = lblValue
end

function PANEL:AddButton(text, wimgObject, func)
    local space = onyx.ScaleTall(7.5)
    local padding = onyx.ScaleTall(5)

    local button = self.buttons:Add('onyx.Button')
    button:SetText('')
    button:SetTall(onyx.ScaleTall(25))
    button:SetColorIdle(COLOR_SECONDARY)
    button:SetColorHover(COLOR_TERTIARY)
    button:AddHoverSound()
    button:AddClickEffect()
    button:Font('Comfortaa SemiBold@16')
    button.iconRotation = 0
    button.Think = function(panel)
        panel:SetTextColor(panel:IsHovered() and color_white or COLOR_GRAY_LIGHT)
    end
    button.DoClick = func
    button:On('PaintOver', function(panel, w, h)
        local size = h * .66

        panel.iconRotation = Lerp(FrameTime() * 8, panel.iconRotation, 0)
    
        if (wimgObject) then
            wimgObject:DrawRotated(padding + size * .5, h * .5, size, size, panel.iconRotation, panel:GetTextColor())
        end

        draw.SimpleText(text, panel:GetFont(), padding + size + space , h * .5, panel:GetTextColor(), 0, 1)
    end)
    button:On('OnCursorEntered', function(panel)
        panel.iconRotation = 15
    end)

    self.buttons:AddItem(button)
end

onyx.gui.Register('onyx.scoreboard.PlayerInspector', PANEL)

--[[------------------------------
// ANCHOR Debug
--------------------------------]]
-- onyx.gui.Test('onyx.Scoreboard.Frame', .6, .6, function(self)
--     onyx.scoreboard.Frame = self
--     self:Center()
--     self:MakePopup()
-- end)
--PATH lua/openpermissions/sh.lua:
function OpenPermissions:CreatePermissionsRegistry()
	local registry = {}
	for _, enum in pairs(OpenPermissions.ACCESS_GROUP) do registry[enum] = {} end
	return registry
end

OpenPermissions.REGISTRY = {}
OpenPermissions.REGISTRY.NETWORKED = 0
OpenPermissions.REGISTRY.FLAT_FILE = 1
function OpenPermissions:SerializeRegistry(dataType)
	if (dataType == OpenPermissions.REGISTRY.NETWORKED) then

		if (file.Exists("openpermissions_v2.dat", "DATA")) then
			-- Lazy but still probably quicker
			local data = file.Read("openpermissions_v2.dat", "DATA")
			net.WriteUInt(#data, 32)
			net.WriteData(data, #data)
		else
			net.WriteUInt(0, 32)
		end

	elseif (dataType == OpenPermissions.REGISTRY.FLAT_FILE) then

		local f = file.Open("openpermissions_v2.dat", "wb", "DATA")

		-- Write file header
		f:Write("OPENPERMISSIONS")

		local ids = {}
		local id = 0
		local ids_pos = f:Tell()
		f:Seek(ids_pos + (32 / 8)) -- Allocate a UShort for seeker position of IDs

		-- Write permissions registry
		local access_group_count = 0
		local access_group_pos = f:Tell()
		f:Seek(access_group_pos + (32 / 8))
		for access_group, accessors in pairs(OpenPermissions.PermissionsRegistry) do
			f:WriteUShort(access_group)
			access_group_count = access_group_count + 1

			local accessors_count = 0
			local accessors_pos = f:Tell()
			f:Seek(accessors_pos + (32 / 8))
			for accessor, permissions in pairs(accessors) do
				if (isnumber(accessor)) then
					f:WriteBool(false)
					f:WriteULong(accessor)
				elseif (isstring(accessor)) then
					f:WriteBool(true)
					f:WriteUShort(#accessor)
					f:Write(accessor)
				else
					error("Invalid accessor key type! (" .. type(accessor) .. ")")
				end
				accessors_count = accessors_count + 1

				local permissions_count = 0
				local permissions_pos = f:Tell()
				f:Seek(permissions_pos + (32 / 8))
				for permission_id, access in pairs(permissions) do
					if (not ids[permission_id]) then
						id = id + 1
						ids[permission_id] = id
					end
					f:WriteUShort(ids[permission_id])
					f:WriteBool(access == OpenPermissions.CHECKBOX.INHERIT)
					f:WriteBool(access == OpenPermissions.CHECKBOX.TICKED)
					permissions_count = permissions_count + 1
				end
				local pos = f:Tell()
				f:Seek(permissions_pos)
				f:WriteULong(permissions_count)
				f:Seek(pos)
			end
			local pos = f:Tell()
			f:Seek(accessors_pos)
			f:WriteULong(accessors_count)
			f:Seek(pos)
		end
		local pos = f:Tell()
		f:Seek(access_group_pos)
		f:WriteULong(access_group_count)
		f:Seek(pos)

		-- Write IDs
		local count = 0
		local countPos = f:Tell()
		f:Seek(countPos + (32 / 8)) -- We can seek back and write the count here
		for str, id in pairs(ids) do
			f:WriteUShort(#str)
			f:Write(str)
			f:WriteUShort(id)
			count = count + 1
		end
		f:Seek(countPos)
		f:WriteULong(count)

		f:Seek(ids_pos)
		f:WriteULong(countPos)

		f:Close()

		file.Write("openpermissions_v2.dat", util.Compress(file.Read("openpermissions_v2.dat", "DATA")))

	end
end
function OpenPermissions:DeserializeRegistry(dataType, stream)
	if (dataType == OpenPermissions.REGISTRY.NETWORKED) then
		
		-- Lazy but still probably quicker
		local data_len = net.ReadUInt(32)
		if (data_len == 0) then return end

		local data = net.ReadData(data_len)

		file.Write("openpermissions_networked.dat", data)
		OpenPermissions:DeserializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE, "openpermissions_networked.dat")
		file.Delete("openpermissions_networked.dat")

	elseif (dataType == OpenPermissions.REGISTRY.FLAT_FILE) then
		
		local data = file.Read(stream or "openpermissions_v2.dat", "DATA")
		file.Write("openpermissions_stream.dat", util.Decompress(data))
		local f = file.Open("openpermissions_stream.dat", "rb", "DATA")

		assert(f:Read(#("OPENPERMISSIONS")) == "OPENPERMISSIONS", "Error! OpenPermissions data corrupted!")

		OpenPermissions.IDs = { Int = {}, Str = {} }
		OpenPermissions.PermissionsRegistry = OpenPermissions:CreatePermissionsRegistry()

		local ids = {}

		local pointer = f:ReadULong()
		local pos = f:Tell()
		f:Seek(pointer)

		-- Read permission IDs
		for i = 1, f:ReadULong() do
			local permission_str = f:Read(f:ReadUShort())
			local permission_id = f:ReadUShort()
			ids[permission_id] = permission_str
		end
		
		f:Seek(pos)

		-- Read permission registry
		for i = 1, f:ReadULong() do
			local access_group = f:ReadUShort()
			OpenPermissions.PermissionsRegistry[access_group] = {}
			
			for j = 1, f:ReadULong() do
				local accessor = f:ReadBool() and f:Read(f:ReadUShort()) or f:ReadULong()
				OpenPermissions.PermissionsRegistry[access_group][accessor] = {}

				for k = 1, f:ReadULong() do
					OpenPermissions.PermissionsRegistry[access_group][accessor][ids[f:ReadUShort()]] = f:ReadBool() and OpenPermissions.CHECKBOX.INHERIT or (f:ReadBool() and OpenPermissions.CHECKBOX.TICKED or OpenPermissions.CHECKBOX.CROSSED)
				end
			end
		end

		f:Close()
		file.Delete("openpermissions_stream.dat")

		return OpenPermissions.PermissionsRegistry

	end
end

function OpenPermissions:SerializeTable(tbl)
	return OpenPermissions.pon.encode(tbl)
end

function OpenPermissions:DeserializeTable(tbl)
	return OpenPermissions.pon.decode(tbl)
end

local NetworkedTblCache = {}
function OpenPermissions:ClearNetworkCache(tbl)
	NetworkedTblCache[tostring(tbl)] = nil
end
function OpenPermissions:StartNetworkTable(tbl, cache, clear_cache)
	if (tbl == OpenPermissions.PermissionsRegistry) then
		return OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.NETWORKED)
	end

	local tbl_enc
	if (cache and not clear_cache and NetworkedTblCache[tostring(tbl)] ~= nil) then
		tbl_enc = NetworkedTblCache[tostring(tbl)]
	else
		tbl_enc = util.Compress(OpenPermissions:SerializeTable(tbl))
		if (cache) then
			NetworkedTblCache[tostring(tbl)] = tbl_enc
		end
	end
	net.WriteUInt(#tbl_enc, 32)
	net.WriteData(tbl_enc, #tbl_enc)
end
function OpenPermissions:ReceiveNetworkTable()
	local tbl_enc_len = net.ReadUInt(32)
	local tbl_dec = OpenPermissions:DeserializeTable(util.Decompress(net.ReadData(tbl_enc_len)))
	return tbl_dec
end

--## SteamIDs ##--

function OpenPermissions:SteamID64ToAccountID(steamid64)
	return OpenPermissions:SteamIDToAccountID(util.SteamIDFrom64(steamid64))
end

function OpenPermissions:SteamIDToAccountID(steamid)
	local acc32 = tonumber(steamid:sub(11))
	return (acc32 * 2) + tonumber(steamid:sub(9,9))
end

function OpenPermissions:AccountIDToSteamID(account_id)
	local sid32 = tonumber(account_id) / 2
	if (sid32 % 1 > 0) then
		return "STEAM_0:1:" .. math.floor(sid32)
	else
		return "STEAM_0:0:" .. sid32
	end
end

function OpenPermissions:AccountIDToSteamID64(account_id)
	return util.SteamIDTo64(OpenPermissions:AccountIDToSteamID(account_id))
end

--## Usergroup Management ##--

function OpenPermissions:IsUserGroup(ply, ...)
	local vararg = {...}
	if (#vararg == 1) then
		return ply:IsUserGroup(vararg[1]) or (not ply:IsBot() and hook.Run("OpenPermissions:IsUserGroup", ply, vararg[1]) == true) or false
	else
		for _,ug in ipairs(vararg) do
			if (ply:IsUserGroup(ug) or (not ply:IsBot() and hook.Run("OpenPermissions:IsUserGroup", ply, ug) == true)) then
				return true
			end
		end
		return false
	end
end

function OpenPermissions:IsUsergroups(ply, usergroups)
	local ply_usergroups = OpenPermissions:GetUserGroups(ply)
	for _,usergroup in ipairs(usergroups) do
		if (ply_usergroups[usergroup]) then
			return true
		end
	end
	return false
end

function OpenPermissions:GetUserGroups(ply)
	local usergroups_tbl = {[ply:GetUserGroup()] = true}
	if (not ply:IsBot()) then
		hook.Run("OpenPermissions:GetUserGroups", ply, usergroups_tbl)
	end
	return usergroups_tbl
end

--## Internal Operators Indexing ##--
OpenPermissions.IndexedOperators = {}
for _,_s in ipairs(OpenPermissions.Operators.SteamIDs) do
	local s = string.Trim(_s)
	if (s:find("^STEAM_%d:%d:%d+$")) then
		OpenPermissions.IndexedOperators[OpenPermissions:SteamIDToAccountID(s)] = true
	elseif (s:find("^7656119%d+$")) then
		OpenPermissions.IndexedOperators[OpenPermissions:SteamID64ToAccountID(s)] = true
	else
		OpenPermissions:Print("Invalid SteamID in config file; not a SteamID/SteamID64: \"" .. _s .. "\"", "[ERROR]", OpenPermissions.COLOR_RED)
	end
end

function OpenPermissions:IsOperator(ply)
	if (ply:IsBot()) then return false end
	if (OpenPermissions.IndexedOperators[ply:AccountID()]) then
		return true
	end
	for _,u in ipairs(OpenPermissions.Operators.Usergroups) do
		if (OpenPermissions:IsUserGroup(ply, u)) then
			return true
		end
	end
	if (hook.Run("OpenPermissions:IsOperator", ply) == true) then
		return true
	end
	return false
end

--## HasPermission, GetPermission ##--

function OpenPermissions:GetPermission(ply, permission_id, is_operator)
	if (type(ply) ~= "Player" or ply:AccountID() == nil) then
		OpenPermissions:Print("Tried to do a permission check on a non-player or a player without an assigned account ID?", "[ERROR]", OpenPermissions.COLOR_RED)
		debug.Trace()
		return false
	end
	if (ply:IsBot()) then return false end
	if (is_operator == true or (is_operator ~= false and OpenPermissions:IsOperator(ply))) then return true end
	
	local has_permission = OpenPermissions.CHECKBOX.INHERIT

	if (type(permission_id) == "table") then
		for _,v in ipairs(permission_id) do
			local r = OpenPermissions:GetPermission(ply, v)
			if (r ~= OpenPermissions.CHECKBOX.INHERIT) then
				return r
			end
		end
		return OpenPermissions.CHECKBOX.INHERIT
	end

	for usergroup in pairs(OpenPermissions:GetUserGroups(ply)) do
		local ply_usergroup_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.USERGROUP][usergroup]
		if (ply_usergroup_registry) then
			if (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_usergroup_registry[permission_id] == true) then
				has_permission = OpenPermissions.CHECKBOX.TICKED
			elseif (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return OpenPermissions.CHECKBOX.CROSSED
			end
		end
	end

	local ply_steamid_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.STEAMID][ply:AccountID()]
	if (ply_steamid_registry) then
		if (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_steamid_registry[permission_id] == true) then
			has_permission = OpenPermissions.CHECKBOX.TICKED
		elseif (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
			return OpenPermissions.CHECKBOX.CROSSED
		end
	end

	if (ply:Team()) then
		local ply_team_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.TEAM][OpenPermissions:GetTeamIdentifier(ply:Team())]
		if (ply_team_registry) then
			if (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_team_registry[permission_id] == true) then
				has_permission = OpenPermissions.CHECKBOX.TICKED
			elseif (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return OpenPermissions.CHECKBOX.CROSSED
			end
		end

		if (OpenPermissions.IsDarkRP and RPExtraTeams[ply:Team()]) then
			local ply_category_name = RPExtraTeams[ply:Team()].category
			local ply_category
			for i,category in ipairs(DarkRP.getCategories().jobs) do
				if (category.name == ply_category_name) then
					ply_category = i
					break
				end
			end
			if (ply_category) then
				local ply_category_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY][OpenPermissions:DarkRP_GetCategoryIdentifier(ply_category)]
				if (ply_category_registry) then
					if (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_category_registry[permission_id] == true) then
						has_permission = OpenPermissions.CHECKBOX.TICKED
					elseif (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
						return OpenPermissions.CHECKBOX.CROSSED
					end
				end
			end
		end
	end

	for name, func in pairs(OpenPermissions.LuaFunctions) do
		local lua_function_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.LUA_FUNCTION][name]
		if (lua_function_registry) then
			if (func(ply, permission_id) == true) then
				if (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or lua_function_registry[permission_id] == true) then
					has_permission = OpenPermissions.CHECKBOX.TICKED
				elseif (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
					return OpenPermissions.CHECKBOX.CROSSED
				end
			end
		end
	end

	if (has_permission == OpenPermissions.CHECKBOX.INHERIT and OpenPermissions.DefaultPermissions[permission_id] == OpenPermissions.CHECKBOX.TICKED) then
		has_permission = OpenPermissions.CHECKBOX.TICKED
	end

	return has_permission
end

function OpenPermissions:HasPermission(ply, permission_id, is_operator)
	if (type(ply) ~= "Player" or ply:AccountID() == nil) then
		OpenPermissions:Print("Tried to do a permission check on a non-player or a player without an assigned account ID?", "[ERROR]", OpenPermissions.COLOR_RED)
		debug.Trace()
		return false
	end
	if (ply:IsBot()) then return false end
	if (is_operator == true or (is_operator ~= false and OpenPermissions:IsOperator(ply))) then return true end

	local has_permission = false

	if (type(permission_id) == "table") then
		for _,v in ipairs(permission_id) do
			if (OpenPermissions:HasPermission(ply, v)) then
				return true
			end
		end
		return false
	end

	for usergroup in pairs(OpenPermissions:GetUserGroups(ply)) do
		local ply_usergroup_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.USERGROUP][usergroup]
		if (ply_usergroup_registry) then
			if (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_usergroup_registry[permission_id] == true) then
				has_permission = true
			elseif (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return false
			end
		end
	end

	local ply_steamid_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.STEAMID][ply:AccountID()]
	if (ply_steamid_registry) then
		if (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_steamid_registry[permission_id] == true) then
			has_permission = true
		elseif (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
			return false
		end
	end

	if (ply:Team()) then
		local ply_team_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.TEAM][OpenPermissions:GetTeamIdentifier(ply:Team())]
		if (ply_team_registry) then
			if (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_team_registry[permission_id] == true) then
				has_permission = true
			elseif (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return false
			end
		end

		if (OpenPermissions.IsDarkRP and RPExtraTeams[ply:Team()]) then
			local ply_category_name = RPExtraTeams[ply:Team()].category
			local ply_category
			for i,category in ipairs(DarkRP.getCategories().jobs) do
				if (category.name == ply_category_name) then
					ply_category = i
					break
				end
			end
			if (ply_category) then
				local ply_category_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY][OpenPermissions:DarkRP_GetCategoryIdentifier(ply_category)]
				if (ply_category_registry) then
					if (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_category_registry[permission_id] == true) then
						has_permission = true
					elseif (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
						return false
					end
				end
			end
		end
	end

	for name, func in pairs(OpenPermissions.LuaFunctions) do
		local lua_function_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.LUA_FUNCTION][name]
		if (lua_function_registry) then
			if (func(ply, permission_id) == true) then
				if (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or lua_function_registry[permission_id] == true) then
					has_permission = true
				elseif (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
					return false
				end
			end
		end
	end

	if (has_permission == false and OpenPermissions.DefaultPermissions[permission_id] == OpenPermissions.CHECKBOX.TICKED) then
		has_permission = true
	end

	return has_permission
end

--## Teams ##--

local team_identifier_index = {}
function OpenPermissions:GetTeamIdentifier(team_index)
	local team_identifier = hook.Run("OpenPermissions:GetTeamIdentifier", team_index)
	if (team_identifier) then
		team_identifier_index[team_identifier] = team_index
		return team_identifier
	end
	if (OpenPermissions.IsDarkRP and RPExtraTeams and team_index ~= 0) then
		if (RPExtraTeams[team_index]) then
			local team_identifier = RPExtraTeams[team_index].OPENPERMISSIONS_IDENTIFIER or RPExtraTeams[team_index].GAS_IDENTIFIER or RPExtraTeams[team_index].command
			team_identifier_index[team_identifier] = team_index
			return team_identifier
		end
	else
		local team_identifier = team.GetName(team_index)
		team_identifier_index[team_identifier] = team_index
		return team_identifier
	end
end

function OpenPermissions:GetTeamFromIdentifier(team_identifier)
	if (team_identifier == "Joining/Connecting") then return TEAM_CONNECTING end
	if (team_identifier == "Unassigned") then return TEAM_UNASSIGNED end
	if (team_identifier == "Spectator") then return TEAM_SPECTATOR end
	if (team_identifier_index[team_identifier]) then return team_identifier_index[team_identifier] end

	local team_index = hook.Run("OpenPermissions:GetTeamFromIdentifier", team_identifier)
	if (team_index) then
		team_identifier_index[team_identifier] = team_index
		return team_index
	end
	if (OpenPermissions.IsDarkRP and RPExtraTeams) then
		for _,job in ipairs(RPExtraTeams) do
			if (job.OPENPERMISSIONS_IDENTIFIER == team_identifier or job.command == team_identifier) then
				team_identifier_index[team_identifier] = job.team
				return job.team
			end
		end
	else
		for i,t in ipairs(team.GetAllTeams()) do
			if (t.Name == team_identifier) then
				team_identifier_index[team_identifier] = i
				return i
			end
		end
	end
end

local category_identifier_index = {}
function OpenPermissions:DarkRP_GetCategoryIdentifier(category_index)
	local category_identifier = hook.Run("OpenPermissions:DarkRP_GetCategoryIdentifier", category_index)
	if (category_identifier) then
		category_identifier_index[category_identifier] = category_index
		return category_identifier
	end

	local category = DarkRP.getCategories().jobs[category_index]
	local category_identifier = category.OPENPERMISSIONS_IDENTIFIER or category.GAS_IDENTIFIER or category.name

	category_identifier_index[category_identifier] = category_index
	return category_identifier
end

function OpenPermissions:DarkRP_GetCategoryFromIdentifier(category_identifier)
	if (category_identifier_index[category_identifier]) then return category_identifier_index[category_identifier] end

	local category_index = hook.Run("OpenPermissions:DarkRP_GetCategoryFromIdentifier", category_identifier)
	if (category_index) then
		category_identifier_index[category_index] = category_identifier
		return category_index
	end

	for i,category in pairs(DarkRP.getCategories().jobs) do
		local category_id = category.OPENPERMISSIONS_IDENTIFIER or category.GAS_IDENTIFIER or category.name
		if (category_id == category_identifier) then
			category_identifier_index[category_id] = i
			return i
		end
	end
end

--## Misc ##--

function OpenPermissions:table_IsEmpty(tbl)
	return next(tbl) == nil
end

function OpenPermissions:table_IsIdentical(tbl1, tbl2)
	local function r(tbl1, tbl2)
		for key, val in pairs(tbl1) do
			if (tbl2[key] == nil) then
				return false
			elseif (type(val) == "table") then
				if (r(val, tbl2[key]) == false) then
					return false
				end
			elseif (tbl2[key] ~= val) then
				return false
			end
		end
		for key, val in pairs(tbl2) do
			if (tbl1[key] == nil) then
				return false
			elseif (type(val) == "table") then
				if (r(val, tbl1[key]) == false) then
					return false
				end
			elseif (tbl1[key] ~= val) then
				return false
			end
		end
	end
	return r(tbl1, tbl2) ~= false
end

--## Enums ##--

OpenPermissions.ADDON = 0
OpenPermissions.PERMISSION = 1
OpenPermissions.CATEGORY = 2
OpenPermissions.SUBPERMISSION = 3

OpenPermissions.PermissionsRegistry = OpenPermissions:CreatePermissionsRegistry()
OpenPermissions.DefaultPermissions = {}

--## Networking ##--

if (SERVER) then
	-- Convert old file format to new
	if (file.Exists("openpermissions.dat", "DATA") and not file.Exists("openpermissions_v2.dat", "DATA")) then
		local read_file = file.Read("openpermissions.dat", "DATA")
		if (not read_file) then
			OpenPermissions:Print("Failed to read saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)
		else
			read_file = util.Decompress(read_file)
			if (not read_file) then
				OpenPermissions:Print("Failed to decompress saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)
			else
				local no_errors, deserialized = pcall(OpenPermissions.pon.decode, read_file)
				if (not no_errors) then
					OpenPermissions:Print("Failed to deserialize decompressed saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)
				else
					--OpenPermissions:Print("Saved permissions data successfully loaded", "[INFO]", OpenPermissions.COLOR_GREEN)

					-- Restructure
					for access_group_str, permissions in pairs(deserialized) do
						local access_group, accessor = access_group_str:match("(%d) (.+)")
						OpenPermissions.PermissionsRegistry[access_group] = OpenPermissions.PermissionsRegistry[access_group] or {}
						OpenPermissions.PermissionsRegistry[access_group][accessor] = {}
						for permission_id_str, permission in pairs(permissions) do
							OpenPermissions.PermissionsRegistry[access_group][accessor][permission_id_str] = permission
						end
					end

					-- Save new data
					OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE)

					file.Rename("openpermissions.dat", "openpermissions_v1.dat")
				end
			end
		end
	end

	if (file.Exists("openpermissions_v2.dat", "DATA")) then
		local no_errors = xpcall(OpenPermissions.DeserializeRegistry, function(err)
			OpenPermissions:Print("Failed to deserialize decompressed saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)

			print(err)
			debug.Trace()
		end, OpenPermissions, OpenPermissions.REGISTRY.FLAT_FILE)

		if (no_errors) then
			OpenPermissions:Print("Saved permissions data successfully loaded", "[INFO]", OpenPermissions.COLOR_GREEN)
		end
	end
	net.Receive("OpenPermissions.SavePermissions", function(_, ply)
		if (not OpenPermissions:IsOperator(ply)) then return end
		OpenPermissions:DeserializeRegistry(OpenPermissions.REGISTRY.NETWORKED)
		OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE)

		net.Start("OpenPermissions.PermissionsRegistry")
			OpenPermissions:StartNetworkTable(OpenPermissions.PermissionsRegistry, true, true)
			OpenPermissions:StartNetworkTable(OpenPermissions.DefaultPermissions, true)
		net.SendOmit(ply)
	end)
	net.Receive("OpenPermissions.PermissionsRegistry", function(_, ply)
		net.Start("OpenPermissions.PermissionsRegistry")
			OpenPermissions:StartNetworkTable(OpenPermissions.PermissionsRegistry, true)
			OpenPermissions:StartNetworkTable(OpenPermissions.DefaultPermissions, true)
		net.Send(ply)
	end)
else
	net.Receive("OpenPermissions.PermissionsRegistry", function()
		OpenPermissions:DeserializeRegistry(OpenPermissions.REGISTRY.NETWORKED)
		OpenPermissions.DefaultPermissions = OpenPermissions:ReceiveNetworkTable()
		OpenPermissions:Print("Received permissions registry", "[INFO]")
	end)
	if (OpenPermissions_PermissionsRegistry_InitPostEntity) then
		net.Start("OpenPermissions.PermissionsRegistry")
		net.SendToServer()
	else
		hook.Add("InitPostEntity", "OpenPermissions.PermissionsRegistry", function()
			OpenPermissions_PermissionsRegistry_InitPostEntity = true
			net.Start("OpenPermissions.PermissionsRegistry")
			net.SendToServer()
		end)
	end
end
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/derma/cl_config.lua:
-- This whole file is a little less than ideal. I find it hard to keep derma clean, especially when it can get so big so quickly.
-- I tried my best to keep consistent and to the point, but it gets a mind of its own in some places.
-- On the plus side, this menu will be used like twice, so its not the end of the world. Right?

-- Function cache
local color = Color
local draw_simpletext = draw.SimpleText
local draw_notexture = draw.NoTexture
local draw_roundedboxex = draw.RoundedBoxEx
local draw_roundedbox = draw.RoundedBox
local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local surface_setdrawcolor = surface.SetDrawColor
local surface_setmaterial = surface.SetMaterial
local surface_drawtexturedrect = surface.DrawTexturedRect
-- Color cache
local mainBlack = color(38, 38, 38)
local bodyBlack = color(40, 40, 40)
local textWhite = color(220, 220, 220)
local mainRed = color(155, 50, 50)
local lineBreak = color(255, 255, 255, 10)
local scrollBackground = color(0, 0, 0, 100)

-- Material cache
local gradientDown = Material("gui/gradient_down")
local gradientMain = Material("gui/gradient")

-- Pre config stuff
local comboOptions = {}
comboOptions["pcasino_slot_machine"] = {
	"anything",
	"bell",
	"berry",
	"cherry",
	"clover",
	"diamond",
	"dollar",
	"melon",
	"seven"
}
comboOptions["pcasino_wheel_slot_machine"] = {
	"anything",
	"gold",
	"coins",
	"emerald",
	"bag",
	"bar",
	"coin",
	"vault",
	"chest"
}

PerfectCasino.UI.ConfigMenu = nil
PerfectCasino.UI.CurrentSettings = PerfectCasino.UI.CurrentSettings or {}
function PerfectCasino.UI.Config()
	if IsValid(PerfectCasino.UI.ConfigMenu) then PerfectCasino.UI.ConfigMenu:Show() return end

	local frame = vgui.Create("DFrame")
	PerfectCasino.UI.ConfigMenu = frame
	frame:SetSize(ScrW() * 0.6, ScrH() * 0.6)
	frame:SetTitle("")
	frame:Center()
	frame:MakePopup()
	frame:ShowCloseButton(false)
	frame:SetDraggable(false)
	frame:DockPadding(0, 0, 0, 0)
	frame.Paint = function(self, w, h)
		-- We drop the 40 to allow for rounded edges on the header
		surface_setdrawcolor(bodyBlack)
		surface_drawrect(0, 40, w, h-40)
	end
	frame.fullScreen = false
	frame.centerX, frame.centerY = frame:GetPos()

	local header = vgui.Create("DPanel", frame)
	header:Dock(TOP)
	header:SetTall(40)
	header:DockMargin(0, 0, 0, 0)
	header.Paint = function(self, w, h)
		draw_roundedboxex(frame.fullScreen and 0 or 5, 0, 0, w, 40, mainBlack, true, true)
		draw_simpletext(PerfectCasino.Translation.ConfigMenu.Title, "pCasino.Header.Static", 10, 20, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

		-- Header buttons
		local close = vgui.Create("DButton", header)
		close:Dock(RIGHT)
		close:SetSize(header:GetTall(), header:GetTall())
		close:SetText("")
		close.animationLerp = 0
		close.Paint = function(self, w, h)
			if self:IsHovered() then
				self.animationLerp = math.Approach(self.animationLerp or 0, 1, 5*FrameTime())
			else
				self.animationLerp = math.Approach(self.animationLerp or 1, 0, 5*FrameTime())
			end

			draw_notexture()
			surface_setdrawcolor(200 - (self.animationLerp*55), 0, 0, 255)
			PerfectCasino.UI.DrawCircle(w*0.5, h*0.5, w*0.2, 1)
		end
		close.DoClick = function()
			frame:Hide()
		end

		local scale = vgui.Create("DButton", header)
		scale:Dock(RIGHT)
		scale:SetSize(header:GetTall(), header:GetTall())
		scale:SetText("")
		scale.animationLerp = 0
		scale.Paint = function(self, w, h)
			if self:IsHovered() then
				self.animationLerp = math.Approach(self.animationLerp or 0, 1, 5*FrameTime())
			else
				self.animationLerp = math.Approach(self.animationLerp or 1, 0, 5*FrameTime())
			end

			draw_notexture()
			surface_setdrawcolor(255, 165 - (self.animationLerp*25), 0, 255)
			PerfectCasino.UI.DrawCircle(w*0.5, h*0.5, w*0.2, 1)
		end
		scale.DoClick = function()
			if frame.fullScreen then
				frame:SizeTo(ScrW()*0.6, ScrH()*0.6, 0.5)
				frame:MoveTo(frame.centerX, frame.centerY, 0.5)
			else
				frame:SizeTo(ScrW(), ScrH(), 0.5)
				frame:MoveTo(0, 0, 0.5)
			end

			frame.fullScreen = not frame.fullScreen
		end

	-- Used to apply padding as DScrollPanel doesn't allow it
	local shellParent = vgui.Create("DPanel", frame)
	shellParent:Dock(FILL)
	shellParent:DockPadding(5, 5, 5, 5)
	shellParent.Paint = function(self, w, h)
		surface_setdrawcolor(0, 0, 0, 155)
		-- Header shadow
		surface_setmaterial(gradientDown)
		surface_drawtexturedrect(0, 0, w, 10)
		-- Navbar shadow
		surface_setmaterial(gradientMain)
		surface_drawtexturedrect(0, 0, 10, h)
	end
	local shell = vgui.Create("DScrollPanel", shellParent)
	shell:Dock(FILL)
	shell.Paint = function() end
	local sbar = shell:GetVBar()
	sbar:SetWide(sbar:GetWide()*0.5)
	sbar:SetHideButtons(true)
	function sbar:Paint(w, h)
		draw_roundedbox(10, 0, 0, w, h, scrollBackground)
	end
	function sbar.btnGrip:Paint(w, h)
		draw_roundedbox(10, 0, 0, w, h, mainRed)
	end



	local navBar = vgui.Create("DScrollPanel", frame)
	navBar:Dock(LEFT)

	local buttonX, buttonY = 0, 0
	local barPos = 0
	navBar.Paint = function(self, w, h)
		surface_setdrawcolor(mainBlack)
		surface_drawrect(0, 0, w, h)

		surface_setdrawcolor(lineBreak)
		surface_drawrect(0, 0, w, 2)

		if not self.currentFocus then return end

		buttonX, buttonY = self.currentFocus:GetPos()
		barPos = Lerp(0.1, barPos, buttonY)
		barPos = math.Approach(barPos, buttonY, 5*FrameTime())

		surface_setdrawcolor(mainRed)
		surface_drawrect(0, barPos, 4, 40)
	end
	navBar:SetSize(frame:GetWide()*0.2)
	navBar:GetVBar():SetWide(0)
	navBar.open = true

	function navBar:AddTab(name, callback)
		local button = vgui.Create("DButton", self)
		button:Dock(TOP)
		button:SetTall(40)
		button:SetText("")

		button.Paint = function(me, w, h)
			draw_simpletext(name, "pCasino.Nav.Static", 12, h*0.5, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			surface_setdrawcolor(lineBreak)
			surface_drawrect(5, h-2, w-10, 2)
		end

		button.DoClick = function()
			shell:Clear()
			self.currentFocus = button
			callback(shell, button, self)
		end

		if not self.currentFocus then
			timer.Simple(0.1, function()
				if not IsValid(button) then return end
				button.DoClick()
			end)
			self.currentFocus = button
		end

		return button
	end

	local entityToConfig = vgui.Create("DPanel", shell)
	entityToConfig:SetTall(65)
	entityToConfig:Dock(TOP)
	entityToConfig.Paint = function(self, w, h)
		draw_simpletext(PerfectCasino.Translation.ConfigMenu.EntityToConfig, "pCasino.Title.Static", 10, 0, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		surface_setdrawcolor(lineBreak)
		surface_drawrect(5, h-2, w-10, 2)
	end

	local entry = vgui.Create("DComboBox", entityToConfig)
	frame.entitySelectBox = entry
	entry:Dock(BOTTOM)
	entry:DockMargin(10, 0, 10, 5)
	entry:SetValue(PerfectCasino.Translation.ConfigMenu.EntityToConfigComboBox)
	for k, v in pairs(PerfectCasino.Core.Entites) do
		entry:AddChoice(PerfectCasino.Translation.Entities[k] or k, k)
	end
	entry.OnSelect = function(self, index, name, class)
		local configData = PerfectCasino.Core.GetEntityConfigOptions(class)
		local allSettings = (PerfectCasino.UI.CurrentSettings.Entity == class) and PerfectCasino.UI.CurrentSettings.Settings or {}
		for k, v in pairs(configData) do
			allSettings[k] = allSettings[k] or {}
			if k == "combo" then
				navBar:AddTab(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, function(shell)
					local title = vgui.Create("DPanel", shell)
					title:Dock(TOP)
					title:DockMargin(0, 0, 0, 5)
					title:SetTall(57.5)
					title.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, "pCasino.Title.Static", 10, 0, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Desc or "", "pCasino.SubTitle.Static", 10, h, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
					end

					local function addComboCard(data, key)
						local base = vgui.Create("DPanel", shell)
						base:SetTall(135)
						base:Dock(TOP)
						base.Paint = function(self, w, h)
							surface_setdrawcolor(lineBreak)
							surface_drawrect(5, h-2, w-10, 2)
						end
						local entryBar = vgui.Create("DPanel", base)
						entryBar:Dock(BOTTOM)
						entryBar:SetTall(20)
						entryBar:DockMargin(5, 0, 5, 5)
						entryBar.Paint = function() end
							local multiplier = vgui.Create("DPanel", entryBar)
							multiplier:Dock(LEFT)
							multiplier:SetWide(275)
							multiplier:DockMargin(0, 0, 0, 0)
							multiplier:SetTall(20)
							multiplier.Paint = function(self, w, h)
								draw_simpletext(PerfectCasino.Translation.ConfigMenu.TakeoutBonusMultiplier, "pCasino.Textbox.Static", 10, h*0.5, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
							end
								local entry = vgui.Create("pCasinoEntry", multiplier)
								entry:Dock(RIGHT)
								entry:DockMargin(5, 0, 5, 0)
								entry.OnChange = function()
									allSettings[k][base.key].p = entry:GetValue()
								end
								entry:SetDisplayText("0.5")
								entry:SetNumeric(true)
								entry:SetValue(data and data.p or 0.5)

							local jackpot = vgui.Create("DPanel", entryBar)
							jackpot:Dock(LEFT)
							jackpot:SetWide(140)
							jackpot:DockMargin(0, 0, 0, 0)
							jackpot:SetTall(20)
							jackpot.Paint = function(self, w, h)
								draw_simpletext(PerfectCasino.Translation.ConfigMenu.IsJackpot, "pCasino.Textbox.Static", 10, h*0.5, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
							end
								local toggle = vgui.Create("pCasinoSwitch", jackpot)
								toggle:Dock(RIGHT)
								toggle:SetWide(40)
								toggle:SetToggle(data and data.j or false)
								toggle.DoClick = function()
									toggle:Toggle()
									allSettings[k][base.key].j = toggle:GetToggle()
								end

							local delete = vgui.Create("DButton", entryBar)
							delete:Dock(RIGHT)
							delete:SetWide(75)
							delete:SetText("")
							delete:DockMargin(5, 0, 0, 0)
							delete.animationLerp = 0
							delete.Paint = function(self, w, h)
								if self:IsHovered() then
									self.animationLerp = math.Approach(self.animationLerp or 0, 1, 5*FrameTime())
								else
									self.animationLerp = math.Approach(self.animationLerp or 1, 0, 5*FrameTime())
								end
								draw_roundedbox(0+(5*self.animationLerp), 0, 0, w, h, mainRed)
								draw_simpletext(PerfectCasino.Translation.ConfigMenu.Delete, "pCasino.Button.Micro", w*0.5, (h*0.5), textWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
							end
							delete.DoClick = function()
								allSettings[k][base.key] = nil
								base:Remove()
							end

						local btnBar = vgui.Create("DPanel", base)
						btnBar:Dock(BOTTOM)
						btnBar:SetTall(20)
						btnBar:DockMargin(5, 0, 5, 5)
						btnBar.Paint = function() end

						for i=1, 3 do
							local icon = vgui.Create("DImage", base)	-- Add image to Frame
							icon:Dock(LEFT)
							icon:SetWide(75)
							icon:DockMargin(5, 5, 0, 5)
							icon:SetMaterial(PerfectCasino.Icons["anything"].mat)

							local nextIcon = vgui.Create("DButton", btnBar)
							nextIcon:Dock(LEFT)
							nextIcon:SetWide(75)
							nextIcon:SetText("")
							nextIcon:DockMargin(5, 0, 0, 0)
							nextIcon.CurState = 1
							if data then
								for k, v in pairs(comboOptions[class]) do
									if v == data.c[i] then
										nextIcon.CurState = k
										icon:SetMaterial(PerfectCasino.Icons[comboOptions[class][nextIcon.CurState]].mat)
										break
									end
								end
							end
							nextIcon.animationLerp = 0
							nextIcon.Paint = function(self, w, h)
								if self:IsHovered() then
									self.animationLerp = math.Approach(self.animationLerp or 0, 1, 5*FrameTime())
								else
									self.animationLerp = math.Approach(self.animationLerp or 1, 0, 5*FrameTime())
								end
								draw_roundedbox(0+(5*self.animationLerp), 0, 0, w, h, mainRed)
								draw_simpletext(PerfectCasino.Icons[comboOptions[class][self.CurState]].name, "pCasino.Button.Micro", w*0.5, (h*0.5), textWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
							end
							nextIcon.DoClick = function()
								nextIcon.CurState = nextIcon.CurState + 1

								if not comboOptions[class][nextIcon.CurState] then
									nextIcon.CurState = 1
								end

								icon:SetMaterial(PerfectCasino.Icons[comboOptions[class][nextIcon.CurState]].mat)
								
								allSettings[k][base.key].c = allSettings[k][base.key].c or {}
								allSettings[k][base.key].c[i] = comboOptions[class][nextIcon.CurState]
							end
						end

						local icons = {}
						for k, v in pairs(btnBar:GetChildren()) do
							icons[k] = comboOptions[class][v.CurState]
						end
						if key then
							base.key = key
						else
							base.key = table.insert(allSettings[k], {c = {icons[1], icons[2], icons[3]}, p = entry:GetValue(), j = toggle:GetToggle()})
						end
					end

					local newCombo = vgui.Create("DButton", shell)
					newCombo:SetText("")
					newCombo:Dock(TOP)
					newCombo:SetTall(25)
					newCombo:DockMargin(10, 5, 10, 5)
					newCombo.animationLerp = 0
					newCombo.Paint = function(self, w, h)
						if self:IsHovered() then
							self.animationLerp = math.Approach(self.animationLerp or 0, 1, 5*FrameTime())
						else
							self.animationLerp = math.Approach(self.animationLerp or 1, 0, 5*FrameTime())
						end
						draw_roundedbox(0+(5*self.animationLerp), 0, 0, w, h, mainRed)
						draw_simpletext(PerfectCasino.Translation.ConfigMenu.AddComboButton, "pCasino.Main.Static", w*0.5, (h*0.5), textWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					end
					newCombo.DoClick = function()
						addComboCard(data)
						shell:GetVBar():AnimateTo(150*(#allSettings[k] + 1), 1)
					end

					-- PerfectCasino.Icons

					local tableHeaders = vgui.Create("DPanel", shell)
					tableHeaders:Dock(TOP)
					tableHeaders:SetTall(30)
					tableHeaders.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.ConfigMenu.TableHeaderChance, "pCasino.Main.Static", 10, h*0.5, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
						surface_setdrawcolor(lineBreak)
						surface_drawrect(10, h-2, w-15, 2)
					end

						local useSettings = false
						if not table.IsEmpty(allSettings[k]) then
							useSettings = true
						end
						for n, m in pairs(useSettings and allSettings[k] or v) do
							addComboCard(m, useSettings and n or nil)
						end
				end)
			elseif k == "wheel" then
				navBar:AddTab(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, function(shell)
					local title = vgui.Create("DPanel", shell)
					title:Dock(TOP)
					title:DockMargin(0, 0, 0, 5)
					title:SetTall(57.5)
					title.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, "pCasino.Title.Static", 10, 0, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Desc or "", "pCasino.SubTitle.Static", 10, h, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
					end

					for n, m in pairs(v) do
						allSettings[k][n] = allSettings[k][n] or m
						local setting = vgui.Create("DPanel", shell)
						setting:SetTall(80)
						setting:Dock(TOP)
						setting.Paint = function(self, w, h)
							--draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k][n] or string.upper(n), "pCasino.SubTitle.Static", 10, 0, k == "chance" and colorCache[n] or textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
							surface_setdrawcolor(lineBreak)
							surface_drawrect(5, h-2, w-10, 2)
						end
	
						local icon = vgui.Create("DImageButton", setting)	-- Add image to Frame
						icon:Dock(LEFT)
						icon:SetWide(80)
						icon:DockMargin(5, 5, 0, 5)
						icon.CurState = 1
						icon:SetMaterial(PerfectCasino.Icons[PerfectCasino.IconsList[icon.CurState]].mat)
						for z, x in pairs(PerfectCasino.IconsList) do
							if x == allSettings[k][n].p then
								icon.CurState = z
								icon:SetMaterial(PerfectCasino.Icons[PerfectCasino.IconsList[icon.CurState]].mat)
								break
							end
						end
						icon.DoClick = function()
							icon.CurState = icon.CurState + 1

							if not PerfectCasino.IconsList[icon.CurState] then
								icon.CurState = 1
							end

							icon:SetMaterial(PerfectCasino.Icons[PerfectCasino.IconsList[icon.CurState]].mat)
							
							allSettings[k][n].p = PerfectCasino.IconsList[icon.CurState]
						end

						local inputValue = vgui.Create("pCasinoEntry", setting)
						inputValue:Dock(BOTTOM)
						inputValue:DockMargin(5, 0, 10, 5)
						inputValue.OnChange = function()
							allSettings[k][n].i = inputValue:GetValue() == "" and m.i or inputValue:GetValue()
						end
						inputValue:SetDisplayText(m.i)
						inputValue:SetText((not (allSettings[k][n].i == m.i)) and allSettings[k][n].i or m.i)

						local rewardType = vgui.Create("DComboBox", setting)
						rewardType:Dock(BOTTOM)
						rewardType:DockMargin(5, 5, 10, 5)
						rewardType:SetValue(PerfectCasino.Translation.ConfigMenu.RewardComboBox)
						for o, p in pairs(PerfectCasino.Config.RewardsFunctions) do
							local key = rewardType:AddChoice(PerfectCasino.Translation.Rewards[o] or o, o)
							if allSettings[k][n].f == o then
								rewardType:ChooseOptionID(key)
							end
						end
						rewardType.OnSelect = function(self, index, name, class)
							allSettings[k][n].f = class
						end

						local name = vgui.Create("pCasinoEntry", setting)
						name:Dock(BOTTOM)
						name:DockMargin(5, 0, 10, 0)
						name.OnChange = function()
							allSettings[k][n].n = name:GetValue() == "" and m.n or name:GetValue()
						end
						name:SetDisplayText(m.n)
						name:SetText((not (allSettings[k][n].n == m.n)) and allSettings[k][n].n or m.n)

					end
				end)
			elseif k == "chance" then
				navBar:AddTab(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, function(shell)
					local title = vgui.Create("DPanel", shell)
					title:Dock(TOP)
					title:DockMargin(0, 0, 0, 5)
					title:SetTall(57.5)
					title.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, "pCasino.Title.Static", 10, 0, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Desc or "", "pCasino.SubTitle.Static", 10, h, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
					end
	
					local colorCache = {}
					local chanceBar = vgui.Create("DPanel", shell)
					chanceBar:Dock(TOP)
					chanceBar:DockMargin(0, 0, 0, 5)
					chanceBar:SetTall(60)
					chanceBar.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.Config.chance.Bar, "pCasino.Title.Static", 10, 0, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
						surface_setdrawcolor(lineBreak)
						surface_drawrect(10, (h*0.5)+5, w-20, (h*0.5)-10)
	
						-- (hudW-10) * math_clamp(localPly:Health(), 0, 100)/100
						local total = 0
						for n, m in pairs(allSettings[k]) do
							total = total+m
						end
						-- I know, the same loop twice... Ugly :/
						local curPos = 10
						for n, m in pairs(allSettings[k]) do
							if m == 0 then continue end
							if not colorCache[n] then
								colorCache[n] = Color(math.random(100, 255), math.random(100, 255), math.random(100, 255))
							end
	
							local width = (w-20) * (m/total)
							surface_setdrawcolor(colorCache[n])
							surface_drawrect(curPos, (h*0.5)+5, width, (h*0.5)-10)
	
							curPos = curPos + width
						end
					end
	
					for n, m in pairs(v) do
						allSettings[k][n] = allSettings[k][n] or m.d
						local setting = vgui.Create("DPanel", shell)
						setting:SetTall(50)
						setting:Dock(TOP)
						setting.Paint = function(self, w, h)
							draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k][n] or string.upper(n), "pCasino.SubTitle.Static", 60, 0, k == "chance" and colorCache[n] or textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
							surface_setdrawcolor(lineBreak)
							surface_drawrect(5, h-2, w-10, 2)
						end

						local icon = vgui.Create("DImageButton", setting)	-- Add image to Frame
						icon:Dock(LEFT)
						icon:SetWide(45)
						icon:DockMargin(5, 5, 0, 5)
						icon.CurState = 1
						icon:SetMaterial(PerfectCasino.Icons[n].mat)

						local entry = vgui.Create("pCasinoEntry", setting)
						entry:Dock(BOTTOM)
						entry:DockMargin(10, 0, 10, 5)
						entry.OnChange = function()
							allSettings[k][n] = entry:GetValue() == "" and m.d or entry:GetValue()
						end
						entry:SetDisplayText(m.d)
						entry:SetText((not (allSettings[k][n] == m.d)) and allSettings[k][n] or "")
						entry:SetNumeric(true)
					end
				end)
			else
				navBar:AddTab(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, function(shell)
					local title = vgui.Create("DPanel", shell)
					title:Dock(TOP)
					title:DockMargin(0, 0, 0, 5)
					title:SetTall(57.5)
					title.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, "pCasino.Title.Static", 10, 0, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Desc or "", "pCasino.SubTitle.Static", 10, h, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
					end
	
					for n, m in pairs(v) do
						-- allSettings[k][n] = allSettings[k][n] or m.d
						if allSettings[k][n] == nil then
							allSettings[k][n] = m.d
						end
						local setting = vgui.Create("DPanel", shell)
						setting:SetTall(50)
						setting:Dock(TOP)
						setting.Paint = function(self, w, h)
							draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k][n] or string.upper(n), "pCasino.SubTitle.Static", 10, 0, k == "chance" and colorCache[n] or textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
							surface_setdrawcolor(lineBreak)
							surface_drawrect(5, h-2, w-10, 2)
						end
	
						if m.t == "bool" then
							local toggle = vgui.Create("pCasinoSwitch", setting)
							toggle:SetPos(10, setting:GetTall()-toggle:GetTall()-5)
							toggle:SetWide(40)
							toggle:SetToggle(allSettings[k][n])
							toggle.DoClick = function()
								toggle:Toggle()
								allSettings[k][n] = toggle:GetToggle()
							end
						else
							local entry = vgui.Create("pCasinoEntry", setting)
							entry:Dock(BOTTOM)
							entry:DockMargin(10, 0, 10, 5)
							entry.OnChange = function()
								allSettings[k][n] = entry:GetValue() == "" and m.d or entry:GetValue()
							end
							entry:SetDisplayText(m.d)
							entry:SetText((not (allSettings[k][n] == m.d)) and allSettings[k][n] or "")
							if m.t == "num" then
								entry:SetNumeric(true)
							end
						end
					end
				end)
			end
		end

		navBar:AddTab(PerfectCasino.Translation.ConfigMenu.SpawnEntity, function(shell)
			local defaults = PerfectCasino.Core.GetEntityConfigOptions(class)
			for k, v in pairs(allSettings) do
				if table.IsEmpty(v) then
					for n, m in pairs(defaults[k]) do
						v[n] = m.d or m
					end
				end
			end

			PerfectCasino.UI.CurrentSettings.Entity = class
			PerfectCasino.UI.CurrentSettings.Settings = allSettings

			PerfectCasino.UI.ConfigMenu:Hide()
		end)

		-- Allow them to reset the options. Essentially hard reloads the menu
		navBar:AddTab(PerfectCasino.Translation.ConfigMenu.ResetButton, function(shell)
			PerfectCasino.UI.ConfigMenu:Close()
			PerfectCasino.UI.ConfigMenu = nil
			PerfectCasino.UI.CurrentSettings = {}
			PerfectCasino.UI.Config()
		end)
	end
end
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/sh_cooldown.lua:
return gluapack()()
--PATH lua/autorun/prison_npc.lua:
local NPC = {
	Name = "Human Prisoner (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Coruscant Prisoners",
	Model = "models/human1/npc_prisoner_human1_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_prisoner_human1_f", NPC )


local NPC = {
	Name = "Human Prisoner (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Coruscant Prisoners",
	Model = "models/human1/npc_prisoner_human1_h.mdl",
}
list.Set( "NPC", "npc_prisoner_human1_h", NPC )

local NPC = {
	Name = "Human Alt Prisoner (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Coruscant Prisoners",
	Model = "models/human3/npc_prisoner_human3_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_prisoner_human3_f", NPC )


local NPC = {
	Name = "Human Alt Prisoner (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Coruscant Prisoners",
	Model = "models/human3/npc_prisoner_human3_h.mdl",
}
list.Set( "NPC", "npc_prisoner_human3_h", NPC )

local NPC = {
	Name = "Clone Prisoner (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Coruscant Prisoners",
	Model = "models/clone/npc_prisoner_clone_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_prisoner_clone_f", NPC )


local NPC = {
	Name = "Clone Prisoner (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Coruscant Prisoners",
	Model = "models/clone/npc_prisoner_clone_h.mdl",
}
list.Set( "NPC", "npc_prisoner_clone_h", NPC )

local NPC = {
	Name = "Pantoran Prisoner (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Coruscant Prisoners",
	Model = "models/pantoran/npc_prisoner_pantoran_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_prisoner_pantoran_f", NPC )


local NPC = {
	Name = "Pantoran Prisoner (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Coruscant Prisoners",
	Model = "models/pantoran/npc_prisoner_pantoran_h.mdl",
}
list.Set( "NPC", "npc_prisoner_pantoran_h", NPC )

local NPC = {
	Name = "Rodian Prisoner (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Coruscant Prisoners",
	Model = "models/rodian/npc_prisoner_rodian_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_prisoner_rodian_f", NPC )


local NPC = {
	Name = "Rodian Prisoner (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Coruscant Prisoners",
	Model = "models/rodian/npc_prisoner_rodian_h.mdl",
}
list.Set( "NPC", "npc_prisoner_rodian_h", NPC )

local NPC = {
	Name = "Trandoshan Prisoner (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Coruscant Prisoners",
	Model = "models/trandoshan/npc_prisoner_trandoshan_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_prisoner_trandoshan_f", NPC )


local NPC = {
	Name = "Trandoshan Prisoner (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Coruscant Prisoners",
	Model = "models/trandoshan/npc_prisoner_trandoshan_h.mdl",
}
list.Set( "NPC", "npc_prisoner_trandoshan_h", NPC )

local NPC = {
	Name = "Quarren Prisoner (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Coruscant Prisoners",
	Model = "models/quarren/npc_prisoner_quarren_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_prisoner_quarren_f", NPC )


local NPC = {
	Name = "Quarren Prisoner (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Coruscant Prisoners",
	Model = "models/quarren/npc_prisoner_quarren_h.mdl",
}
list.Set( "NPC", "npc_prisoner_quarren_h", NPC )

--PATH lua/autorun/prone_init.lua:
return gluapack()()
--PATH lua/autorun/r5.lua:
return gluapack()()
--PATH lua/autorun/rb655_legacy_addon_props.lua:

AddCSLuaFile()

if ( SERVER ) then return end

language.Add( "spawnmenu.category.addonslegacy", "Addons - Legacy" )
language.Add( "spawnmenu.category.downloads", "Downloads" )

local function AddRecursive( pnl, folder )
	local files, folders = file.Find( folder .. "*", "MOD" )

	for k, v in pairs( files or {} ) do
		if ( !string.EndsWith( v, ".mdl" ) ) then continue end

		local cp = spawnmenu.GetContentType( "model" )
		if ( cp ) then
			local mdl = folder .. v
			mdl = string.sub( mdl, string.find( mdl, "models/" ), string.len( mdl ) )
			mdl = string.gsub( mdl, "models/models/", "models/" )
			cp( pnl, { model = mdl } )
		end
	end

	for k, v in pairs( folders or {} ) do AddRecursive( pnl, folder .. v .. "/" ) end
end

local function CountRecursive( folder )
	local files, folders = file.Find( folder .. "*", "MOD" )
	local val = 0

	for k, v in pairs( files or {} ) do if ( string.EndsWith( v, ".mdl" ) ) then val = val + 1 end end
	for k, v in pairs( folders or {} ) do val = val + CountRecursive( folder .. v .. "/" ) end
	return val
end

hook.Add( "PopulateContent", "LegacyAddonProps", function( pnlContent, tree, node )

	if ( !IsValid( node ) or !IsValid( pnlContent ) ) then
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR LEGACY ADDONS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR LEGACY ADDONS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR LEGACY ADDONS!!!" )
		return
	end

	local ViewPanel = vgui.Create( "ContentContainer", pnlContent )
	ViewPanel:SetVisible( false )

	local addons = {}

	local _files, folders = file.Find( "addons/*", "MOD" )
	for _, f in pairs( folders ) do

		if ( !file.IsDir( "addons/" .. f .. "/models/", "MOD" ) ) then continue end

		local count = CountRecursive( "addons/" .. f .. "/models/", "MOD" )
		if ( count == 0 ) then continue end

		table.insert( addons, {
			name = f,
			count = count,
			path = "addons/" .. f .. "/models/"
		} )

	end

	local LegacyAddons = node:AddNode( "#spawnmenu.category.addonslegacy", "icon16/folder_database.png" )
	for _, f in SortedPairsByMemberValue( addons, "name" ) do

		local models = LegacyAddons:AddNode( f.name .. " (" .. f.count .. ")", "icon16/bricks.png" )
		models.DoClick = function()
			ViewPanel:Clear( true )
			AddRecursive( ViewPanel, f.path )
			pnlContent:SwitchPanel( ViewPanel )
		end

	end

	--[[ -------------------------- DOWNLOADS -------------------------- ]]

	local fi, fo = file.Find( "download/models", "MOD" )
	if ( !fi && !fo ) then return end

	local Downloads = node:AddFolder( "#spawnmenu.category.downloads", "download/models", "MOD", false, false, "*.*" )
	Downloads:SetIcon( "icon16/folder_database.png" )

	Downloads.OnNodeSelected = function( self, selectedNode )
		ViewPanel:Clear( true )

		local path = selectedNode:GetFolder()

		if ( !string.EndsWith( path, "/" ) && string.len( path ) > 1 ) then path = path .. "/" end
		local path_mdl = string.sub( path, string.find( path, "/models/" ) + 1 )

		for k, v in pairs( file.Find( path .. "/*.mdl", selectedNode:GetPathID() ) ) do

			local cp = spawnmenu.GetContentType( "model" )
			if ( cp ) then
				cp( ViewPanel, { model = path_mdl .. "/" .. v } )
			end

		end

		pnlContent:SwitchPanel( ViewPanel )
	end

end )

--[[ -------------------------------------------------------------------------- The addon info -------------------------------------------------------------------------- ]]

concommand.Add( "extsm_addoninfo", function()
	local frame = vgui.Create( "DFrame" )
	frame:SetSize( ScrW() - 100, ScrH() - 100 )
	frame:Center()
	frame:MakePopup()

	local sp = frame:Add( "DScrollPanel" )
	sp:Dock( FILL )

	sp:Add( "rb655_addonInfo" )
end )

hook.Add( "AddToolMenuCategories", "LegacyAddonPropsInfoCategory", function()
	spawnmenu.AddToolCategory( "Utilities", "Robotboy655", "#Robotboy655" )
end )

hook.Add( "PopulateToolMenu", "LegacyAddonPropsInfoThing", function()
	spawnmenu.AddToolMenuOption( "Utilities", "Robotboy655", "LegacyInfoPanel", "Addon Information", "", "", function( panel )
		panel:ClearControls()
		panel:Button( "Open addon data window", "extsm_addoninfo" )
	end )
end )

----------------------------------

function ScreenScaleH( size )
	return size * ( ScrH() / 480.0 )
end

surface.CreateFont( "AddonInfo_Header", {
	font	= "Helvetica",
	size	= ScreenScaleH( 24 ),
	weight	= 1000
} )

surface.CreateFont( "AddonInfo_Text", {
	font	= "Helvetica",
	size	= ScreenScaleH( 9 ),
	weight	= 1000
} )

surface.CreateFont( "AddonInfo_Small", {
	font	= "Helvetica",
	size	= ScreenScaleH( 8 )
} )

local function GetWorkshopLeftovers()

	local subscriptions = {}

	for id, t in pairs( engine.GetAddons() ) do
		subscriptions[ tonumber( t.wsid ) ] = true
	end

	local t = {}
	for id, fileh in pairs( file.Find( "addons/*.gma", "MOD" ) ) do
		local a = string.StripExtension( fileh )
		a = string.Explode( "_", a )
		a = tonumber( a[ #a ] )
		if ( !subscriptions[ a ] ) then
			table.insert( t, fileh )
		end
	end

	return t

end

local function GetSize( b )
	b = b / 1000

	if ( b < 1000 ) then
		return math.floor( b * 10 ) / 10 .. " KB"
	end

	b = b / 1000

	if ( b < 1000 ) then
		return math.floor( b * 10 ) / 10 .. " MB"
	end

	b = b / 1000

	return math.floor( b * 10 ) / 10 .. " GB"
end

local function DrawText( txt, font, x, y, clr )
	draw.SimpleText( txt, font, x, y, clr )

	surface.SetFont( font )
	return surface.GetTextSize( txt )
end

local PANEL = {}

function PANEL:Init()
	self.Computed = false
end

function PANEL:Compute()

	self.WorkshopSize = 0
	for id, fle in pairs( file.Find( "addons/*.gma", "MOD" ) ) do
		self.WorkshopSize = self.WorkshopSize + ( file.Size( "addons/" .. fle, "MOD" ) or 0 )
	end

	self.WorkshopWaste = 0
	self.WorkshopWasteFiles = {}
	for id, fle in pairs( GetWorkshopLeftovers() ) do
		self.WorkshopWaste = self.WorkshopWaste + ( file.Size( "addons/" .. fle, "MOD" ) or 0 )
		table.insert( self.WorkshopWasteFiles, { "addons/" .. fle, ( file.Size( "addons/" .. fle, "MOD" ) or 0 ) } )
	end

	-- -------------------------------------------

	local _files, folders = file.Find( "addons/*", "MOD" )

	self.LegacyAddons = {}
	for k, v in pairs( folders or {} ) do
		self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed"

		if ( file.IsDir( "addons/" .. v .. "/models/", "MOD" ) ) then
			self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed (Has Models)"
		end

		local _fi, fo = file.Find( "addons/" .. v .. "/*", "MOD" )
		if ( table.Count( fo or {} ) < 1 ) then
			self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed (Empty)"
		end

		if ( !file.IsDir( "addons/" .. v .. "/models/", "MOD" ) && !file.IsDir(  "addons/" .. v .. "/materials/", "MOD" ) && !file.IsDir(  "addons/" .. v .. "/lua/", "MOD" ) && !file.IsDir(  "addons/" .. v .. "/sound/", "MOD" ) ) then
			self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed Incorrectly!"
		end
	end

	-- -------------------------------------------

	local luaFiles = file.Find( "cache/lua/*", "MOD" )  -- Too many files to count actual size!
	self.LuaCacheSize = #luaFiles * 1400
	self.LuaCacheFiles = #luaFiles

	local wsFiles = file.Find( "cache/workshop/*", "MOD" )
	self.WSCacheSize = 0
	for id, fle in pairs( wsFiles ) do
		self.WSCacheSize = self.WSCacheSize + ( file.Size( "cache/workshop/" .. fle, "MOD" ) or 0 )
	end
	self.WSCacheFiles = #wsFiles

	self.Computed = true

end

function PANEL:Paint( w, h )

	if ( !self.Computed ) then
		self:Compute()
	end

	local txtW = self:GetParent():GetWide()
	local txtH = 0

	-- -----------------------

	local tW, tH = DrawText( "Cache Sizes", "AddonInfo_Header", 0, txtH, color_white )
	txtH = txtH + tH

	local localH = 0
	local localW = 0

	-- -----------------------

	tW, tH = DrawText( "~" .. GetSize( self.LuaCacheSize or 0 ) .. " (" .. self.LuaCacheFiles .. " files)", "AddonInfo_Small", 0, txtH + localH, Color( 220, 220, 220 ) )
	localH = localH + tH
	localW = math.max( localW, tW )

	tW, tH = DrawText( "~" .. GetSize( self.WSCacheSize or 0 ) .. " (" .. self.WSCacheFiles .. " files)", "AddonInfo_Small", 0, txtH + localH, Color( 220, 220, 220 ) )
	localH = localH + tH
	localW = math.max( localW, tW )

	-- -----------------------

	localW = localW + 25

	tW, tH = DrawText( "Server Lua cache", "AddonInfo_Small", localW, txtH, color_white )
	txtH = txtH + tH

	tW, tH = DrawText( "Workshop download cache", "AddonInfo_Small", localW, txtH, color_white )
	txtH = txtH + tH

	-- -------------------------------------------

	txtH = txtH + ScreenScaleH( 8 )
	tW, tH = DrawText( "Workshop Subscriptions", "AddonInfo_Header", 0, txtH, color_white )
	txtH = txtH + tH

	-- -------------------------------------------

	tW, tH = DrawText( "Used Size:  ", "AddonInfo_Text", 0, txtH, color_white )
	local maxW = tW
	txtH = txtH + tH

	tW, tH = DrawText( "Wasted Space:  ", "AddonInfo_Text", 0, txtH, color_white )
	maxW = math.max( maxW, tW )
	txtH = txtH + tH

	tW, tH = DrawText( "Total Size:  ", "AddonInfo_Text", 0, txtH, color_white )
	maxW = math.max( maxW, tW )
	txtH = txtH - tH * 2

	-- -------------------------------------------

	tW, tH = DrawText( GetSize( ( self.WorkshopSize - self.WorkshopWaste ) or 0 ), "AddonInfo_Text", maxW, txtH, Color( 220, 220, 220 ) )
	txtH = txtH + tH

	tW, tH = DrawText( GetSize( self.WorkshopWaste or 0 ), "AddonInfo_Text", maxW, txtH, Color( 220, 220, 220 ) )
	txtH = txtH + tH

	tW, tH = DrawText( GetSize( self.WorkshopSize or 0 ), "AddonInfo_Text", maxW, txtH, Color( 220, 220, 220 ) )
	txtH = txtH + tH * 2

	-- -------------------------------------------

	tW, tH = DrawText( "Files that aren't used: ( Safe to delete )", "AddonInfo_Text", 0, txtH, color_white )
	txtH = txtH + tH

	localH = 0
	localW = 0
	for id, t in pairs( self.WorkshopWasteFiles or {} ) do
		tW, tH = DrawText( GetSize( t[ 2 ] ) .. "    ", "AddonInfo_Small", 0, txtH + localH, Color( 220, 220, 220 ) )
		localH = localH + tH
		localW = math.max( localW, tW )
	end

	for id, t in pairs( self.WorkshopWasteFiles or {} ) do
		tW, tH = DrawText( t[ 1 ], "AddonInfo_Small", localW, txtH, color_white )
		txtH = txtH + tH
	end

	-- -------------------------------------------

	tW, tH = DrawText( "Legacy Addons", "AddonInfo_Header", 0, txtH + ScreenScaleH( 8 ), color_white )
	txtH = txtH + tH + ScreenScaleH( 8 )

	-- -------------------------------------------

	tW, tH = DrawText( "Legacy Addons with models:", "AddonInfo_Text", 0, txtH, color_white )
	txtH = txtH + tH

	if ( table.Count( self.LegacyAddons or {} ) > 0 ) then
		local maxNameW = 0
		local oldH = txtH
		for path, status in pairs( self.LegacyAddons or {} ) do
			tW, tH = DrawText( path, "AddonInfo_Small", 0, txtH, color_white )
			maxNameW = math.max( maxNameW, tW )
			txtH = txtH + tH
		end

		maxNameW = maxNameW + 25
		txtH = oldH

		for path, status in pairs( self.LegacyAddons or {} ) do
			tW, tH = DrawText( status, "AddonInfo_Small", maxNameW, txtH, Color( 220, 220, 220 ) )
			txtH = txtH + tH
		end
	else
		tW, tH = DrawText( "None.", "AddonInfo_Small", 0, txtH, color_white )
		txtH = txtH + tH
	end

	if ( !system.IsWindows() ) then
		txtH = txtH + tH

		tW, tH = DrawText( "OSX AND LINUX USERS BEWARE:", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
		tW, tH = DrawText( "MAKE SURE ALL FILE AND FOLDER NAMES", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
		tW, tH = DrawText( "IN ALL ADDONS ARE LOWERCASE ONLY", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
		tW, tH = DrawText( "INCLUDING ALL SUB FOLDERS", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
	end

	txtH = txtH + tH

	-- -------------------------------------------

	self:SetSize( txtW, txtH )
end

vgui.Register( "rb655_addonInfo", PANEL, "Panel" )

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

-- I spent too much time on this than I care to admit
hook.Add( "PopulatePropMenu", "rb655_LoadLegacySpawnlists", function()

	local sid = 0 --table.Count( spawnmenu.GetPropTable() )

	--local added = false

	for id, spawnlist in pairs( file.Find( "settings/spawnlist/*.txt", "MOD" ) ) do
		local content = file.Read( "settings/spawnlist/" .. spawnlist, "MOD" )
		if ( !content ) then continue end

		--[[local is = string.find( content, "TableToKeyValues" )
		if ( is != nil ) then continue end

		for id, t in pairs( spawnmenu.GetPropTable() ) do -- This somehow freezes the game when opening Q menu => FUCK THIS SHIT
			if ( t.name == "Legacy Spawnlists" ) then
				added = true
				sid = t.id
			end
		end

		if ( !added ) then
			spawnmenu.AddPropCategory( "rb655_legacy_spawnlists", "Legacy Spawnlists", {}, "icon16/folder.png", sid, 0 )
			added = true
		end]]

		content = util.KeyValuesToTable( content )

		if ( !content.entries or content.contents ) then continue end

		local contents = {}

		for eid, entry in pairs( content.entries ) do
			if ( type( entry ) == "table" ) then entry = entry.model end
			table.insert( contents, { type = "model", model = entry } )
		end

		if ( !content.information ) then content.information = { name = spawnlist } end

		spawnmenu.AddPropCategory( "settings/spawnlist/" .. spawnlist, content.information.name, contents, "icon16/page.png", sid + id, sid )

	end

end )

--PATH lua/reality_development/client/cl_imgur.lua:
return gluapack()()
--PATH lua/reality_development/client/vgui/cl_dbutton_category.lua:
return gluapack()()
--PATH lua/reality_development/client/vgui/cl_nframe.lua:
surface.CreateFont( "RDV_LIB_FRAME_TITLE", {
	font = "Bebas Neue", --  Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = ScrW() * 0.0135,
} )

local blur = Material("pp/blurscreen")

local function DrawBlur(panel, amount)
    local x, y = panel:LocalToScreen(0, 0)

    local scrW, scrH = ScrW(), ScrH()

    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(blur)

    for i = 1, 3 do
        blur:SetFloat("$blur", (i / 3) * (amount or 6))
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
    end
end

local PANEL = {}

PANEL.Paint = function(s, w, h)
    DrawBlur(s, 6)
    
    surface.SetDrawColor( Color(0,0,0, 250) )
    surface.DrawRect( 0, 0, w, h )

    surface.SetDrawColor( RDV.LIBRARY.GetConfigOption("LIBRARY_outlineTheme") )
    surface.DrawOutlinedRect( 0, 0, w, h )
end

PANEL.Init = function(s)
    local FRAME = s

    s.Header = vgui.Create("Panel", s)
    s.Header:Dock(TOP)
    s.Header:PaintManual(true)
    s.Header.Paint = function(_, w, h)
        surface.SetDrawColor( RDV.LIBRARY.GetConfigOption("LIBRARY_outlineTheme") )
        surface.DrawOutlinedRect( 0, 0, w, h )

        draw.SimpleText((FRAME:GetTitle() or ""), "RDV_LIB_FRAME_TITLE", w * 0.01, h * 0.5, COL_2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    local w, h = s.Header:GetSize()

    s.CloseButton = vgui.Create("DButton", s.Header)
    s.CloseButton:SetWide(w * 0.4)
    s.CloseButton:Dock(RIGHT)
    s.CloseButton:SetText("X")
    s.CloseButton:SetFont("RD_FONTS_CORE_LABEL_LOWER")
    s.CloseButton:SetTextColor(Color(255,0,0))
    
    s.CloseButton.DoClick = function(pnl)
        s:Remove()
    end

    s.CloseButton.Paint = function(pnl, w ,h)
        if pnl:IsHovered() then
            pnl:SetTextColor(Color(255,0,0))
        else
            pnl:SetTextColor(Color(255,255,255))
        end
    end
end

AccessorFunc(PANEL, "m_rd_titletext", "Title", FORCE_STRING)

vgui.Register("RDV_LIBRARY_FRAME", PANEL, "EditablePanel")
--PATH lua/reality_development/client/vgui/cl_textentry.lua:
return gluapack()()
--PATH lua/reality_development/client/vgui/sh_uioptions.lua:
return gluapack()()
--PATH lua/reality_development/client/vgui/sh_uioptions.lua:
hook.Add("RDV_LIB_Loaded", "RDV_LIB_UIOptions", function()
    local CAT = "Library"

    --[[
    --  Interface Sounds
    --]]

    RDV.LIBRARY.AddConfigOption("LIBRARY_clickSound", { 
        TYPE = RDV.LIBRARY.TYPE.ST, 
        CATEGORY = CAT, 
        DESCRIPTION = "Click", 
        DEFAULT = "rdv/new/activate.mp3",
        SECTION = "Interface Sounds",
    })

    RDV.LIBRARY.AddConfigOption("LIBRARY_hoverSound", { 
        TYPE = RDV.LIBRARY.TYPE.ST, 
        CATEGORY = CAT, 
        DESCRIPTION = "Hover", 
        DEFAULT = "rdv/new/slider.mp3",
        SECTION = "Interface Sounds",
    })

    --[[
    --  Interface Colors
    --]]

    RDV.LIBRARY.AddConfigOption("LIBRARY_outlineTheme", { 
        TYPE = RDV.LIBRARY.TYPE.CO, 
        CATEGORY = CAT, 
        DESCRIPTION = "Default Outline", 
        DEFAULT = Color(122,132,137, 180),
        SECTION = "Interface Theme",
    })

    RDV.LIBRARY.AddConfigOption("LIBRARY_hoverTheme", { 
        TYPE = RDV.LIBRARY.TYPE.CO, 
        CATEGORY = CAT, 
        DESCRIPTION = "Hover Outline", 
        DEFAULT = Color(252,180,9,255),
        SECTION = "Interface Theme",
    })
end)
--PATH lua/reality_development/functions/cl_truncate.lua:
function RDV.LIBRARY.TruncateString(s,w)
    local ellipsis = "…"
    local n_ellipsis = utf8.len(ellipsis)

    if utf8.len(s) > w then
        return s:sub(1, utf8.offset(s, w - n_ellipsis + 1) - 1) .. ellipsis
    end
    return s
end
--PATH lua/reality_development/functions/sh_functions.lua:
local plyMeta = FindMetaTable("Player")

--[[

	Job Category

--]]

function plyMeta:RD_GetJobCategory()
    if not RPExtraTeams or not RPExtraTeams[self:Team()] then
        return "N/A"
    end
    
    return RPExtraTeams[self:Team()].category
end

function plyMeta:EPS_GetPlayersJobCategory()
	return self:RD_GetJobCategory()
end

--[[

	Cooldowns

--]]

function RD_Cooldown_Get(ID)
    if not ID then
        return
    end

    RD_CoolDowns = RD_CoolDowns or {}

    if RD_CoolDowns[ID] and RD_CoolDowns[ID] > 0 then
        return true, RD_CoolDowns[ID]
    end
end

function RD_Cooldown_Add(ID, TIME)
    if not ID or not TIME then
        return
    end

    RD_CoolDowns = RD_CoolDowns or {}

    RD_CoolDowns[ID] = tonumber(TIME)

    return true
end

local last_think = 0

hook.Add("Think", "ST_UPDATE_COOLDOWNS", function()
    if last_think < CurTime() then
    	RD_CoolDowns = RD_CoolDowns or {}
    	
        for k, v in pairs(RD_CoolDowns) do
            if v - 1 < 0 then
                RD_CoolDowns[k] = nil
                goto skip 
            end

            RD_CoolDowns[k] = RD_CoolDowns[k] - 1

            ::skip::
        end
        last_think = CurTime() + 1
    end
end)

--[[

	Get User from String

--]]


function EPS_GetUserFromString(text)
	return RD_GetUserFromString(text)
end

function RD_GetUserFromString(text)
    local target
    local playerCount = 0

    for _, ply in ipairs(player.GetAll()) do
        if string.find(string.lower(ply:Nick()), string.lower(text)) then
            target = ply
            playerCount = playerCount + 1
        end

        if string.find(ply:SteamID(), text) then
            target = ply
            playerCount = playerCount + 1
        end
    end

    if playerCount == 0 then
        return false
    elseif playerCount == 1 then
        return target
    else
        return false
    end

    return false
end

--[[
local INITS = {}
function RDV.LIBRARY.Initialize(callback)
    table.insert(INITS, callback)
end

hook.Add("Initialize", "RDV.LIBRARY.INITIALIZE.CALLBACKS", function()
    for k, v in ipairs(INITS) do
        if !isfunction(v) then continue end

        v()
    end

    INITS = {}
end )
--]]
--PATH lua/reality_development/functions/timer/sh_functions.lua:
RDV = RDV or {}
RDV.LIBRARY = RDV.LIBRARY or {}
RDV.LIBRARY.TIMERS = RDV.LIBRARY.TIMERS or {}

local DELAY = CurTime()

hook.Add("Think", "RDV.LIBRARY.TIMERS", function()
    if DELAY > CurTime() then
        return
    end    

    RDV.LIBRARY.TIMERS = RDV.LIBRARY.TIMERS or {}

    for k, v in pairs(RDV.LIBRARY.TIMERS) do
        if v.START + v.SECONDS < SysTime() then
            if v.ITERATIONS and v.ITERATIONS >= 1 then
                v.START = SysTime()

                v.ITERATIONS = v.ITERATIONS - 1

                if v.ITERATIONS <= 0 then
                    RDV.LIBRARY.TIMERS[k] = nil
                end
            else
                RDV.LIBRARY.TIMERS[k] = nil

                continue
            end

            v.CALLBACK()
        end
    end

    DELAY = CurTime() + engine.TickInterval()
end)

local SIMPLE_COUNT = 0

function RDV.LIBRARY.TimerSimple(SECONDS, CALLBACK)
    if not SECONDS or not CALLBACK then
        return
    end

    SIMPLE_COUNT = SIMPLE_COUNT + 1

    RDV.LIBRARY.TIMERS[SIMPLE_COUNT] = {
        START = SysTime(),
        SECONDS = SECONDS,
        CALLBACK = CALLBACK
    }
end

function RDV.LIBRARY.Timer(IDENTIFIER, SECONDS, ITERATIONS, CALLBACK)
    if not SECONDS or not CALLBACK then
        return
    end

    if tonumber(ITERATIONS) == 0 then
        ITERATIONS = math.huge
    end

    RDV.LIBRARY.TIMERS[IDENTIFIER] = {
        START = SysTime(),
        SECONDS = SECONDS,
        ITERATIONS = ITERATIONS,
        CALLBACK = CALLBACK
    }
end

function RDV.LIBRARY.TimerExists(IDENTIFIER)
    if RDV.LIBRARY.TIMERS[IDENTIFIER] then
        return true
    else
        return false
    end
end

function RDV.LIBRARY.TimerRemove(IDENTIFIER)
    if RDV.LIBRARY.TIMERS[IDENTIFIER] then
        RDV.LIBRARY.TIMERS[IDENTIFIER] = nil

        return true
    else
        return false
    end
end
--PATH lua/reality_development/libs/config/sh_config.lua:
local SAVED = {} 

RDV.LIBRARY.CONFIG = RDV.LIBRARY.CONFIG or {
    SOPTIONS = {},
    OPTIONS = {},
    SAVED = {},
    BUTTONS = {},
    SBUTTONS = {},
}

function RDV.LIBRARY.AddConfigButton(ADDON, SECTION, NW, FUNC) -- ADDON NAME, SECTION (Misc, Options, etc), Network (should it be sent to the server.), Callback function.
    RDV.LIBRARY.CONFIG.BUTTONS[ADDON] = RDV.LIBRARY.CONFIG.BUTTONS[ADDON] or {}

    local TAB = {
        ADDON = ADDON,
        SECTION = SECTION,
        NW = NW,
        CB = ( FUNC.Callback or false ),
        CA = ( FUNC.CanAccess or false ),
    }

    table.insert(RDV.LIBRARY.CONFIG.BUTTONS[ADDON], TAB)
    table.insert(RDV.LIBRARY.CONFIG.SBUTTONS, TAB)
end

RDV.LIBRARY.TYPE = {
    BL = "BOOL", -- Bool
    ST = "STRING", -- String
    CO = "COLOR", -- COLOR
    SE = "SELECT", -- Select
    SM = "SELECTMULT", -- Select Multiple
    NM = "NUMBER",
    BN = "BIND",
}

function RDV.LIBRARY.CanChangeConfig(ply)
    if !IsValid(ply) then return false end

    return ply:IsSuperAdmin()
end

function RDV.LIBRARY.SaveConfigOptions()
    local SAVED = {}

    for k, v in pairs(RDV.LIBRARY.CONFIG.OPTIONS) do
        if CLIENT and !v.noNetwork then continue end

        if isbool(v.VALUE) then v.VALUE = tonumber(v.VALUE) end

        if v.VALUE and ( v.DEFAULT and (v.VALUE ~= v.DEFAULT ) or !v.DEFAULT ) then
            table.insert(SAVED, {
                UID = k,
                VALUE = v.VALUE,
            })
        end
    end
    
    local PATH = "rdv/library/config"

    file.CreateDir(PATH)

    if SERVER then
        PATH = PATH.."/config.json"
    else
        PATH = PATH.."/config_"..LocalPlayer():SteamID64()..".json"
    end

    file.Write(PATH, util.TableToJSON(SAVED))
end

function RDV.LIBRARY.AddConfigOption(uid, tab)
    if !tab.TYPE or !tab.CATEGORY then return end

    uid = string.lower(uid)

    local D = tab.DEFAULT

    if isbool(D) then
        tab.DEFAULT = (D and 1) or 0
    end

    local VAL = RDV.LIBRARY.CONFIG.OPTIONS[uid]

    if VAL and VAL.VALUE then
        tab.VALUE = VAL.VALUE
    end

    RDV.LIBRARY.CONFIG.OPTIONS[uid] = tab
    
    --[[
        Make things load in order, good fucking god.
    --]]

    local UPDATE = false

    for k, v in ipairs(RDV.LIBRARY.CONFIG.SOPTIONS) do
        if ( uid ~= v.UID ) then
            continue
        end

        UPDATE = k

        break
    end

    tab.UID = uid

    if UPDATE then
        RDV.LIBRARY.CONFIG.SOPTIONS[UPDATE] = tab
    else
        table.insert(RDV.LIBRARY.CONFIG.SOPTIONS, tab)
    end

    RDV.LIBRARY.LoadConfigOption(uid)
end

function RDV.LIBRARY.GetConfigOption(uid)
    uid = string.lower(uid)

    local TAB = RDV.LIBRARY.CONFIG.OPTIONS

    if !TAB[uid] then return end

    TAB = TAB[uid]

    local VAL

    if TAB.VALUE then 
        VAL = TAB.VALUE
    elseif TAB.DEFAULT then 
        VAL = TAB.DEFAULT 
    end

    if ( TAB.TYPE == RDV.LIBRARY.TYPE.BL ) then
        VAL = tobool(VAL)
    end

    return (VAL and VAL) or false
end

function RDV.LIBRARY.SetConfigOption(uid, val)
    uid = string.lower(uid)

    local TAB = RDV.LIBRARY.CONFIG.OPTIONS

    if !TAB[uid] then return end
    TAB = TAB[uid]

    if isbool(val) then
        val = (val and 1) or 0
    end

    TAB.VALUE = val

    if SERVER then
        net.Start("RDV.LIBRARY.SendConfig")
            net.WriteBool(false)
            net.WriteUInt(1, 16)
            net.WriteString(uid)
            net.WriteType(val)
        net.Broadcast()
    else
        RDV.LIBRARY.SaveConfigOptions()
    end
end

function RDV.LIBRARY.LoadConfigOption(uid)
    uid = string.lower(uid)

    if SAVED[uid] then
        local V = SAVED[uid]

        local TAB = RDV.LIBRARY.CONFIG.OPTIONS[uid]
        if !TAB then return end

        TAB.VALUE = V.VALUE

        hook.Run("RDV_LIB_ConfigOptionLoaded", uid, RDV.LIBRARY.GetConfigOption(uid))
    end
end

local function Load()
    local PATH = "rdv/library/config"

    file.CreateDir(PATH)

    if SERVER then
        PATH = PATH.."/config.json"
    else
        PATH = PATH.."/config_"..LocalPlayer():SteamID64()..".json"
    end

    if file.Exists(PATH, "DATA") then 
        local F = file.Read(PATH, "DATA")
        local T = util.JSONToTable(F)

        for k, v in ipairs(T) do
            SAVED[v.UID] = v

            RDV.LIBRARY.LoadConfigOption(v.UID)
        end
    end
end

if SERVER then
    Load()
else
    hook.Add("InitPostEntity", "RDV.CONFIG.LOAD", Load)
end
--PATH lua/reality_development/libs/currencies/sh_register.lua:
return gluapack()()
--PATH lua/reality_development/libs/currencies/list/sh_nmoney2.lua:
return gluapack()()
--PATH lua/reality_development/libs/currencies/list/sh_santos.lua:
local OBJ = RDV.LIBRARY.RegisterCurrency("santos")

function OBJ:AddMoney(p, amount)
    p:AddMoney(amount)
end

function OBJ:CanAfford(p, amount)
    if not p:CanAfford(amount) then
        return false
    else
        return true
    end
end

function OBJ:FormatMoney(amount)
    return "$"..string.Comma(amount)
end
--PATH addons/[admin] sam-160/lua/sam/libs/sh_types.lua:
if SAM_LOADED then return end

-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function sam.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		sam["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function sam.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
sam.IsEntity = sam.isentity

local type = sam.type
function sam.istable(value)
	return type(value) == "table"
end
--PATH addons/[admin] sam-160/lua/sam/libs/message_pack/sh_messagepack.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/sh_util.lua:
if SAM_LOADED then return end

local sam = sam

function sam.parse_args(str)
	local args = {}
	local tmp, in_quotes = "", false
	for i = 1, #str do
		local char = str:sub(i, i)
		if char == "\"" then
			-- i could use string.find to find the next double quotes but thats gonna be overkill
			in_quotes = not in_quotes
			if tmp ~= "" or not in_quotes then
				args[#args + 1], tmp = tmp, ""
			end
		elseif char ~= " " or in_quotes then
			tmp = tmp .. char
		elseif tmp ~= "" then
			args[#args + 1], tmp = tmp, ""
		end
	end
	if tmp ~= "" then
		args[#args + 1] = tmp
	end
	return args, #args
end

function sam.get_targets_list(targets)
	if sam.isstring(targets) then
		return {Color(244, 67, 54), targets}
	end

	local len = #targets

	if len == player.GetCount() and len > 1 then
		return {Color(244, 67, 54), sam.language.get("Everyone")}
	end

	local admin = targets.admin
	local result = {}
	local white = Color(236, 240, 241)
	for i = 1, len do
		local target = targets[i]

		if CLIENT and LocalPlayer() == target then
			table.insert(result, Color(255, 215, 0))
			if admin ~= LocalPlayer() then
				table.insert(result, sam.language.get("You"))
			else
				table.insert(result, sam.language.get("Yourself"))
			end
		elseif admin ~= target then
			local name
			if sam.isentity(target) and target.Name then
				name = target:Name()
			else
				name = "Unknown"
				table.insert(result, white)
				table.insert(result, "*")
			end

			table.insert(result, Color(244, 67, 54))
			table.insert(result, name)
		else
			table.insert(result, Color(255, 215, 0))
			table.insert(result, sam.language.get("Themself"))
		end

		if i ~= len then
			table.insert(result, white)
			table.insert(result, ",")
		end
	end

	return result
end

function sam.is_steamid(id, err) -- https://stackoverflow.com/questions/6724268/check-if-input-matches-steam-id-format
	if sam.isstring(id) and id:match("^STEAM_[0-5]:[0-1]:[0-9]+$") ~= nil then
		return true
	else
		return err and error("invalid steamid", 2) or false
	end
end

function sam.is_steamid64(id, err)
	if sam.isstring(id)
		and tonumber(id)
		and id:sub(1, 7) == "7656119"
		and (#id == 17 or #id == 18) then
		return true
	else
		return err and error("invalid steamid64", 2) or false
	end
end

do
	local console = {}

	do
		local return_console = function()
			return "Console"
		end
		for _, v in ipairs({"SteamID", "SteamID64", "Name", "Nick", "Name"}) do
			console[v] = return_console
		end
		setmetatable(console, {
			__tostring = return_console,
			MetaName = "console"
		})
	end

	function console.IsAdmin()
		return true
	end

	function console.IsSuperAdmin()
		return true
	end

	function console:IsUserGroup(name)
		return name == "superadmin"
	end

	function console.GetUserGroup()
		return "superadmin"
	end

	function console.HasPermission()
		return true
	end

	function console.CanTarget()
		return true
	end

	function console.CanTargetRank()
		return true
	end

	function console.GetBanLimit()
		return 0
	end

	function console.SetUserGroup()
	end

	function sam.isconsole(v)
		return v == console
	end

	sam.console = console
end

do
	local times = {
		"year"; 525600,
		"month"; 43800,
		"week"; 10080,
		"day"; 1440,
		"hour"; 60,
		"minute"; 1
	}

	for i = 1, #times, 2 do
		times[i] = " " .. times[i]
	end

	local floor = math.floor
	function sam.format_length(mins) -- Thanks to this guide https://stackoverflow.com/a/21323783
		if mins <= 0 then
			return "Indefinitely"
		elseif mins <= 1 then
			return "1 minute"
		end

		local str = ""
		for i = 1, #times, 2 do
			local n1, n2 = times[i + 1]
			n2, mins = floor(mins / n1), mins % n1

			if n2 > 0 then
				if str ~= "" then
					if mins == 0 then
						str = str .. " and "
					else
						str = str .. ", "
					end
				end
				str = str .. n2 .. times[i]
				if n2 > 1 then
					str = str .. "s"
				end
			end

			if mins == 0 then
				break
			end
		end
		return str
	end
end

do
	local times = {
		m = 1,
		h = 60,
		d = 1440,
		w = 10080,
		mo = 43800,
		y = 525600
	}

	function sam.parse_length(length)
		local time, found = tonumber(length), false
		if sam.isnumber(length) then
			time, found = length, true
		elseif time then
			found = true
		else
			time = 0
			for t, u in length:gmatch("(%d+)(%a+)") do
				u = times[u]
				if u then
					time = time + (u * t)
					found = true
				end
			end
		end
		if not found then return false end
		return math.Clamp(time, 0, 31536000)
	end

	local times2 = {}
	for k, v in SortedPairsByValue(times, true) do
		table.insert(times2, k)
		table.insert(times2, v)
	end

	local floor = math.floor
	function sam.reverse_parse_length(mins) -- Thanks to this guide https://stackoverflow.com/a/21323783
		if mins <= 0 then
			return "0"
		elseif mins <= 1 then
			return "1m"
		end

		local str = ""
		for i = 1, #times2, 2 do
			local n1, n2 = times2[i + 1]
			n2, mins = floor(mins / n1), mins % n1

			if n2 > 0 then
				if str ~= "" then
					str = str .. " "
				end
				str = str .. n2 .. times2[i]
			end

			if mins == 0 then
				break
			end
		end
		return str
	end
end

do
	if SERVER then
		function sam.hook_call(event, ...)
			hook.Call(event, nil, ...)
			sam.netstream.Start(nil, "HookCall", event, ...)
		end

		function sam.client_hook_call(event, ...)
			sam.netstream.Start(nil, "HookCall", event, ...)
		end
	else
		local function hook_call(event, ...)
			hook.Call(event, nil, ...)
		end
		sam.netstream.Hook("HookCall", hook_call)
	end
end

if SERVER then
	local maps = {}

	for k, v in ipairs(file.Find("maps/*.bsp", "GAME")) do
		maps[k] = v:sub(1, -5):lower()
	end

	sam.set_global("Maps", maps)
end

function sam.is_valid_map(name)
	local maps = sam.get_global("Maps", {})
	if name:sub(-4) == ".bsp" then
		name = name:sub(1, -5)
	end
	name = name:lower()
	for i = 1, #maps do
		if maps[i] == name then
			return name
		end
	end
	return false
end

function sam.is_valid_gamemode(name)
	name = name:lower()
	local gamemodes = engine.GetGamemodes()
	for i = 1, #gamemodes do
		local gamemode = gamemodes[i]
		if sam.isstring(gamemode.name) and gamemode.name:lower() == name then
			return true
		end
	end
	return false
end

function sam.hook_first(event, name, func)
	if HOOK_HIGH then
		return hook.Add(event, name, func, HOOK_HIGH)
	end

	return hook.Add(event, name, func)
end

function sam.hook_last(event, name, func)
	if HOOK_LOW then
		return hook.Add(event, name, func, HOOK_LOW)
	end

	return hook.Add(event, name, func)
end

do
	local byte = string.byte
	local gsub = string.gsub
	local char = string.char
	local format = string.format
	local tonumber = tonumber

	local hex_encode = function(c)
		return format("%02X", byte(c))
	end

	function sam.to_hex(text)
		-- gsub returns more than one value, fucking glualint can't stop complaining about using ()
		local hex = gsub(text, ".", hex_encode)
		return hex
	end

	local hex_decode = function(d)
		return char(tonumber(d, 16))
	end

	function sam.from_hex(hex)
		local text = (gsub(hex, "%x%x", hex_decode))
		return text
	end
end

--PATH addons/[admin] sam-160/lua/sam/sh_lang.lua:
if SAM_LOADED then return end

local lang = sam.load_file("sam_language.lua", "sh")

local original = lang
if not isstring(lang) then
	lang = "english"
end

local lang_path = "sam_languages/" .. lang .. ".lua"

if not file.Exists(lang_path, "LUA") then
	lang_path = "sam_languages/english.lua"
	if not file.Exists(lang_path, "LUA") then
		-- maybe they deleted english lang????
		sam.print("SAM is broken!")
		sam.print("Language '" .. tostring(original) .. "' doesn't exist and 'english' language file doesn't exist")
		return false
	else
		sam.print("Language '" .. tostring(original) .. "' doesn't exist falling back to english")
	end
end

local Language = sam.load_file(lang_path, "sh_")

local sub, find = string.sub, string.find

local white_color = Color(236, 240, 241)

do
	local args = {}
	function sam.add_message_argument(arg, func)
		if isstring(arg) and isfunction(func) then
			args[arg] = func
		end
	end

	local insert = function(t, v)
		t.__cnt = t.__cnt + 1
		t[t.__cnt] = v
	end

	function sam.format_message(msg, tbl, result, result_n)
		msg = Language[msg] or msg

		result = result or {}
		result.__cnt = result_n or 0

		local pos = 0
		local start, _end, arg, arg2 = nil, 0, nil, nil

		while true do
			start, _end, arg, arg2 = find(msg, "%{ *([%w_%#]+)([^%{}]-) *%}", _end)
			if not start then break end

			if pos ~= start then
				local txt = sub(msg, pos, start - 1)
				if txt ~= "" then
					insert(result, white_color)
					insert(result, txt)
				end
			end

			local ma = args[sub(arg, 1, 1)]
			if not ma then
				insert(result, "{" .. arg .. " " .. arg2 .. "}")
			else
				ma(result, tbl and tbl[arg], arg, unpack(arg2:Trim():Split(" ")))
			end

			pos = _end + 1
		end

		if pos <= #msg then
			insert(result, white_color)
			insert(result, sub(msg, pos))
		end

		return result
	end

	/*
		Admin
	*/
	sam.add_message_argument("A", function(result, admin)
		if sam.isconsole(admin) then
			-- we need to show that it's the real console!!!!!
			insert(result, Color(236, 240, 241))
			insert(result, "*")
			insert(result, Color(13, 130, 223))
			insert(result, "Console")
		else
			if sam.type(admin) == "Player" then
				if CLIENT and LocalPlayer() == admin then
					insert(result, Color(255, 215, 0))
					insert(result, sam.language.get("You"))
				else
					insert(result, Color(13, 130, 223))
					insert(result, admin:Name())
				end
			else
				insert(result, Color(13, 130, 223))
				insert(result, admin)
			end
		end
	end)

	/*
		Target(s)
	*/
	sam.add_message_argument("T", function(result, targets)
		for k, v in ipairs(sam.get_targets_list(targets)) do
			insert(result, v)
		end
	end)

	/*
		Value(s)
	*/
	sam.add_message_argument("V", function(result, value)
		insert(result, Color(0, 230, 64))
		insert(result, tostring(value))
	end)

	/*
		Text(s)
	*/
	sam.add_message_argument("S", function(result, text, _, color)
		insert(result, sam.get_color(color) or white_color)
		insert(result, tostring(text))
	end)

	-- https://gist.github.com/fernandohenriques/12661bf250c8c2d8047188222cab7e28
	local hex_rgb = function(hex)
		local r, g, b
		if #hex == 4 then
			r, g, b = tonumber(hex:sub(2, 2), 16) * 17, tonumber(hex:sub(3, 3), 16) * 17, tonumber(hex:sub(4, 4), 16) * 17
		else
			r, g, b = tonumber(hex:sub(2, 3), 16), tonumber(hex:sub(4, 5), 16), tonumber(hex:sub(6, 7), 16)
		end

		if not r or not g or not b then
			return color_white
		end

		return Color(r, g, b)
	end

	/*
		Colored Text(s)
	*/
	sam.add_message_argument("#", function(result, _, color, ...)
		local text = table.concat({...}, " ")
		insert(result, hex_rgb(color))
		insert(result, text)
	end)
end

function sam.get_message(msg)
	msg = Language[msg]
	if not msg then
		return false
	else
		return {Color(236, 240, 241), msg}
	end
end

function sam.language.get(key)
	return Language[key]
end

function sam.language.Add(key, value)
	Language[key] = value
end
--PATH addons/[admin] sam-160/lua/sam/config/cl_config.lua:
if SAM_LOADED then return end

local sam = sam
local sfs = sam.sfs
local config = sam.config
local type = sam.type

local encoders = sfs.Encoder.encoders

function config.set(key, value, force)
	if not sam.isstring(key) then
		error("invalid setting name")
	end

	if not encoders[type(value)] then
		error("not supported value type")
	end

	if not force and config.get(key) == value then return end
	sam.netstream.Start("Config.Set", key, value)
end

function config.get(key, default)
	local value = sam.get_global("Config", {})[key]
	if value ~= nil then
		return value
	end
	return default
end

local menu_settings = {}
function config.add_menu_setting(title, func)
	local i = #menu_settings + 1
	for k, v in ipairs(menu_settings) do
		if v.title == title then
			i = k
			break
		end
	end
	menu_settings[i] = {
		title = title,
		func = func,
	}
end

function config.get_menu_settings()
	return menu_settings
end

hook.Add("SAM.ChangedGlobalVar", "SAM.CheckLoadedConfig", function(key, value)
	if key == "Config" then
		config.loaded = true
		hook.Call("SAM.LoadedConfig", nil, value)
		hook.Remove("SAM.ChangedGlobalVar", "SAM.CheckLoadedConfig")
	end
end)

--PATH addons/[admin] sam-160/lua/sam/command/arguments/dropdown.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("dropdown")
    :OnExecute(function(arg, input, ply, _, result)
        if not arg.options or table.Empty(arg.options) then
            ply:sam_send_message("no data", {S = "dropdown", S_2 = input})
            return
        end

        table.insert(result, input)
    end)
    :Menu(function(set_result, body, buttons, arg)
        local default = arg.hint or "select"

        local cbo = buttons:Add("SAM.ComboBox")
        cbo:SetValue(default)
		cbo:SetTall(25)

        function cbo:OnSelect(_, value)
            set_result(value)
            default = value
        end

        function cbo:DoClick()
            if self:IsMenuOpen() then
                return self:CloseMenu()
            end

            self:Clear()
            self:SetValue(default)

            if not arg.options then
                LocalPlayer():sam_send_message("dropdown has no options data")
                return
            end

            for k, v in pairs(arg.options) do
                self:AddChoice(v)
            end

            self:OpenMenu()
        end

        return cbo
    end)
:End()
--PATH addons/[admin] sam-160/lua/sam/command/arguments/length.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local get_length = function(arg, input)
	if (input == "" or input == nil) and arg.optional then
		if arg.default ~= nil then
			return arg.default
		end

		return ""
	end

	return sam.parse_length(input)
end

command.new_argument("length")
	:OnExecute(function(arg, input, ply, _, result, i)
		local length = get_length(arg, input)
		if length == "" then
			result[i] = nil
		elseif not length then
			ply:sam_send_message("invalid", {
				S = "length", S_2 = input
			})
			return false
		else
			if arg.min and length ~= 0 then
				length = math.max(length, arg.min)
			end

			if arg.max then
				if length == 0 then
					length = arg.max
				else
					length = math.min(length, arg.max)
				end
			end

			result[i] = length
		end
	end)

	:Menu(function(set_result, body, buttons, argument)
		local length_input = buttons:Add("SAM.TextEntry")
		length_input:SetTall(25)

		length_input:SetCheck(function(new_limit)
			new_limit = get_length(argument, new_limit) or nil
			set_result(new_limit)
			return new_limit or false
		end)

		local hint = argument.hint or "length"
		if argument.default then
			hint = hint .. " = " .. tostring(argument.default)
		end

		length_input:SetPlaceholder(hint)
		return length_input
	end)
:End()
--PATH addons/[admin] sam-160/lua/sam/command/arguments/text.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/libs/gif_loader.lua:
local byte = string.byte
local sub = string.sub
local lshift = bit.lshift
local rshift = bit.rshift
local bor = bit.bor
local band = bit.band

local GIFDecoder = {}
local GIFDecoderMethods = {}
local GIFDecoder_meta = {__index = GIFDecoderMethods}

function GIFDecoder.new(buf)
	local buf_n = #buf
	local this = setmetatable({
		p = 1,
		buf = buf
	}, GIFDecoder_meta)

	local version = this:read(6)
	assert(version == "GIF89a" or version == "GIF87a", "wrong file format")

	this.width = this:word()
	this.height = this:word()

	local pf0 = this:byte()
	local global_palette_flag = rshift(pf0, 7)
	local num_global_colors_pow2 = band(pf0, 0x7)
	local num_global_colors = lshift(1, num_global_colors_pow2 + 1)
	this:skip(2)

	local global_palette_offset = nil
	local global_palette_size = nil

	if global_palette_flag > 0 then
		global_palette_offset = this.p
		this.global_palette_offset = global_palette_offset
		global_palette_size = num_global_colors
		this:skip(num_global_colors * 3)
	end

	local no_eof = true

	local frames = {}

	local delay = 0
	local transparent_index = nil
	local disposal = 1

	while no_eof and this.p <= buf_n do
		local b = this:byte()
		if b == 0x3b then
			no_eof = false
		elseif b == 0x2c then
			local x, y, w, h = this:word(), this:word(), this:word(), this:word()
			local pf2 = this:byte()
			local local_palette_flag = rshift(pf2, 7)
			local interlace_flag = band(rshift(pf2, 6), 1)
			local num_local_colors_pow2 = band(pf2, 0x7)
			local num_local_colors = lshift(1, num_local_colors_pow2 + 1)
			local palette_offset = global_palette_offset
			local palette_size = global_palette_size
			local has_local_palette = false
			if local_palette_flag ~= 0 then
				has_local_palette = true
				palette_offset = this.p
				palette_size = num_local_colors
				this:skip(num_local_colors * 3)
			end

			local data_offset = this.p

			this:skip(1)
			this:skip_eob()

			table.insert(frames, {
				x = x,
				y = y,
				width = w,
				height = h,
				has_local_palette = has_local_palette,
				palette_offset = palette_offset,
				palette_size = palette_size,
				data_offset = data_offset,
				data_length = this.p - data_offset,
				transparent_index = transparent_index,
				interlaced = interlace_flag > 0,
				delay = delay,
				disposal = disposal
			})
		elseif b == 0x21 then
			local b2 = this:byte()
			if b2 == 0xf9 then
				local len, flags = this:bytes(2)
				delay = this:word()
				local transparent, terminator = this:bytes(2)

				assert(len == 4 and terminator == 0, "Invalid graphics extension block.")

				if flags % 2 == 1 then
					transparent_index = transparent
				else
					transparent_index = nil
				end

				disposal = math.floor(flags / 4) % 8
			elseif b2 == 0xff then
				this:read(this:byte())
				this:skip_eob()
			else
				this:skip_eob()
			end
		end
	end

	this.frames = frames

	return this
end

function GIFDecoderMethods:skip(offset)
	self.p = self.p + offset
end

-- skip to end of block
function GIFDecoderMethods:skip_eob()
	repeat
		local size = self:byte()
		self:skip(size)
	until size == 0
end

function GIFDecoderMethods:byte()
	local b = byte(self.buf, self.p)
	self:skip(1)
	return b
end

function GIFDecoderMethods:bytes(len)
	local _p = self.p
	self:skip(len)
	return byte(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:read(len)
	local _p = self.p
	self:skip(len)
	return sub(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:word()
	return bor(self:byte(), lshift(self:byte(), 8))
end

local GifReaderLZWOutputIndexStream = function(this, output, output_length)
	local min_code_size = this:byte()
	local clear_code = lshift(1, min_code_size)
	local eoi_code = clear_code + 1
	local next_code = eoi_code + 1
	local cur_code_size = min_code_size + 1

	local code_mask = lshift(1, cur_code_size) - 1
	local cur_shift = 0
	local cur = 0
	local op = 0

	local subblock_size = this:byte()

	local code_table = {}

	local prev_code = nil

	while true do
		while cur_shift < 16 do
			if subblock_size == 0 then break end

			cur = bor(cur, lshift(this:byte(), cur_shift))
			cur_shift = cur_shift + 8

			if subblock_size == 1 then
				subblock_size = this:byte()
			else
				subblock_size = subblock_size - 1
			end
		end

		if cur_shift < cur_code_size then break end

		local code = band(cur, code_mask)
		cur = rshift(cur, cur_code_size)
		cur_shift = cur_shift - cur_code_size

		if code == clear_code then
			next_code = eoi_code + 1
			cur_code_size = min_code_size + 1
			code_mask = lshift(1, cur_code_size) - 1

			prev_code = null
			continue
		elseif code == eoi_code then
			break
		end

		local chase_code = code < next_code and code or prev_code
		local chase_length = 0
		local chase = chase_code
		while chase > clear_code do
			chase = rshift(code_table[chase], 8)
			chase_length = chase_length + 1
		end

		local k = chase
		local op_end = op + chase_length + (chase_code ~= code and 1 or 0)
		if op_end > output_length then
			Error("Warning, gif stream longer than expected.")
			return
		end

		output[op] = k; op = op + 1
		op = op + chase_length

		local b = op

		if chase_code ~= code then
			output[op] = k; op = op + 1
		end
		chase = chase_code

		while chase_length > 0 do
			chase_length = chase_length - 1
			chase = code_table[chase]
			b = b - 1
			output[b] = band(chase, 0xff)

			chase = rshift(chase, 8)
		end

		if prev_code ~= nil and next_code < 4096 then
			code_table[next_code] = bor(lshift(prev_code, 8), k)
			next_code = next_code + 1

			if next_code >= code_mask + 1 and cur_code_size < 12 then
				cur_code_size = cur_code_size + 1
				code_mask = bor(lshift(code_mask, 1), 1)
			end
		end

		prev_code = code
	end

	if op ~= output_length then
		Error("Warning, gif stream shorter than expected.")
	end

	return output
end

function GIFDecoderMethods:decode_and_blit_frame_RGBA(frame_num, pixels)
	local frame = self.frames[frame_num]
	local num_pixels = frame.width * frame.height
	local index_stream = {}

	self.p = frame.data_offset
	GifReaderLZWOutputIndexStream(self, index_stream, num_pixels)
	local palette_offset = frame.palette_offset

	local trans = frame.transparent_index
	if trans == nil then
		trans = 256
	end

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local buf = self.buf
	while i < num_pixels do
		local index = index_stream[i]

		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		if index ~= trans then
			index = palette_offset + index * 3
			pixels[op + 0] = byte(buf, index)
			pixels[op + 1] = byte(buf, index + 1)
			pixels[op + 2] = byte(buf, index + 2)
			pixels[op + 3] = 255
		end

		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:clear_frame(frame_num, pixels)
	local frame = self.frames[frame_num]

	self.p = frame.data_offset

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local num_pixels = frame.width * frame.height
	while i < num_pixels do
		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		pixels[op + 0] = 0
		pixels[op + 1] = 0
		pixels[op + 2] = 0
		pixels[op + 3] = 0
		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:get_frames()
	local num_pixels = self.width * self.height * 4 + 4
	local frames = {}
	local numFrames = #self.frames
	local last_frame
	local restore_from
	for i = 1, numFrames do
		local frame = self.frames[i]

		local data = {}

		if last_frame then
			local _data = last_frame.data
			for k = 0, num_pixels do
				data[k] = _data[k]
			end
		end

		if i > 1 then
			local last_disposal = last_frame.disposal
			if last_disposal == 3 then
				if restore_from then
					for k = 0, num_pixels do
						data[k] = restore_from[k]
					end
				else
					self:clear_frame(i - 1, data)
				end
			end

			if last_disposal == 2 then
				self:clear_frame(i - 1, data)
			end
		end

		self:decode_and_blit_frame_RGBA(i, data)

		local delay = frame.delay
		if delay < 2 then
			delay = 10
		end

		local disposal = frame.disposal
		last_frame = {
			data = data,
			delay = delay,
			disposal = disposal
		}
		frames[i] = last_frame

		if disposal ~= 3 then
			restore_from = data
		end
	end

	return frames
end

return GIFDecoder.new
--PATH addons/[lib] sui/lua/sui/vgui/sui_number_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local NUMBER_SLIDER_FONT = SUI.CreateFont("NumberSlider", "Roboto Regular", 14)

local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()

	local slider = vgui.Create(NAME .. ".Slider", self, "NumberSlider")
	slider:Dock(FILL)

	self.slider = slider

	local label = self:Add(NAME .. ".Label")
	label:Dock(RIGHT)
	label:DockMargin(3, 0, 0, 0)
	label:SetFont(NUMBER_SLIDER_FONT)
	self.label = label

	function label:Think()
		self:SetText(slider:GetValue())

		self:SizeToContents()
	end

	self:SetSize(100, 12)
	self:InvalidateLayout(true)
end

sui.register("NumberSlider", PANEL, "Panel")

--PATH addons/[lib] sui/lua/sui/vgui/sui_zbutton.lua:
local draw = draw
local render = render

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local BUTTON_FONT = SUI.CreateFont("Button", "Roboto Medium", 16)

local color_white = color_white
local color_transparent = Color(0, 0, 0, 0)

local PANEL = {}

AccessorFunc(PANEL, "m_Background", "Background")
AccessorFunc(PANEL, "m_bContained", "Contained", FORCE_BOOL)

sui.TDLib.Install(PANEL)
sui.scaling_functions(PANEL)

PANEL:ClearPaint()
PANEL:SetContained(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local IsMouseInputEnabled = Panel.IsMouseInputEnabled
local SetCursor = Panel.SetCursor
local SetContentAlignment = Panel.SetContentAlignment
function PANEL:Init()
	self:ScaleInit()

	self.vertices, self.vertices_2 = {}, {}

	SetMouseInputEnabled(self, true)
	SetCursor(self, "hand")
	SetContentAlignment(self, 5)

	self:SetSize(90, 30)
	self:SetFont(BUTTON_FONT)

	self:CircleClick(nil, 7)

	self.OldPaint, self.Paint = self.Paint, self.Paint2

	self.cur_col = Color(0, 0, 0, 0)
end

function PANEL:SetEnabled(b)
	SetMouseInputEnabled(self, b)
end

function PANEL:IsEnabled()
	return IsMouseInputEnabled(self)
end

function PANEL:ContainedPaint(w, h)
	local enabled = self:IsEnabled()
	local col
	if enabled then
		col = self:GetBackground() or SUI.GetColor("button")
		self:SetTextColor(SUI.GetColor("button_text"))
	else
		col = SUI.GetColor("button_disabled")
		self:SetTextColor(SUI.GetColor("button_disabled_text"))
	end
	self:RoundedBox("Background", 4, 0, 0, w, h, col)

	if not enabled then return end

	self.circle_click_color = SUI.GetColor("button_click")

	if self.Hovered or self.Selected then
		self:RoundedBox("Hover", 4, 0, 0, w, h, SUI.GetColor("button_hover"))
	end
end

function PANEL:SetColors(hover_color, text_color)
	self.hover = hover_color
	self.text_color = text_color
end

function PANEL:Paint2(w, h)
	if self:GetContained() then
		self:ContainedPaint(w, h)
		self:OldPaint(w, h)
		return
	end

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_ZERO)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(1)

	TDLib.RoundedBox(self.vertices, 4, 0, 0, w, h, color_white)

	render.SetStencilFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(1)

	local cur_col = self.cur_col
	if self.Selected then
		lerp_color(cur_col, SUI.GetColor("button2_selected"))
	elseif self.Hovered then
		lerp_color(cur_col, self.hover or SUI.GetColor("button2_hover"))
	else
		lerp_color(cur_col, color_transparent)
	end

	TDLib.RoundedBox(self.vertices_2, 4, 0, 0, w, h, cur_col)

	if self.text_color then
		self.circle_click_color = self.text_color
		self:SetTextColor(self.text_color)
	else
		local col = contrast_color(cur_col)
		self.circle_click_color = col
		self:SetTextColor(col)
	end

	self:OldPaint(w, h)

	render.SetStencilEnable(false)
	render.ClearStencil()
end

sui.register("Button", PANEL, NAME .. ".Label")
--PATH addons/[admin] sam-160/lua/sam/modules/chat.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Chat")

command.new("pm")
	:SetPermission("pm", "user")

	:AddArg("player", {allow_higher_target = true, single_target = true, cant_target_self = true})
	:AddArg("text", {hint = "message", check = function(str)
		return str:match("%S") ~= nil
	end})

	:GetRestArgs()

	:Help("pm_help")

	:OnExecute(function(ply, targets, message)
		if ply:sam_get_pdata("unmute_time") then
			return ply:sam_send_message("you_muted")
		end

		local target = targets[1]

		ply:sam_send_message("pm_to", {
			T = targets, V = message
		})

		if ply ~= target then
			target:sam_send_message("pm_from", {
				A = ply, V = message
			})
		end
	end)
:End()

do
	sam.permissions.add("see_admin_chat", nil, "admin")

	local reports_enabled = sam.config.get_updated("Reports", true)
	command.new("asay")
		:SetPermission("asay", "user")

		:AddArg("text", {hint = "message"})
		:GetRestArgs()

		:Help("asay_help")

		:OnExecute(function(ply, message)
			if reports_enabled.value and not ply:HasPermission("see_admin_chat") then
				local success, time = sam.player.report(ply, message)
				if success == false then
					ply:sam_send_message("You need to wait {S Red} seconds.", {
						S = time
					})
				else
					ply:sam_send_message("to_admins", {
						A = ply, V = message
					})
				end
				return
			end

			local targets = {ply}

			local players = player.GetHumans()
			for i = 1, #players do
				local v = players[i]
				if v:HasPermission("see_admin_chat") and v ~= ply then
					table.insert(targets, v)
				end
			end

			sam.player.send_message(targets, "to_admins", {
				A = ply, V = message
			})
		end)
	:End()

	if SERVER then
		sam.hook_last("PlayerSay", "SAM.Chat.Asay", function(ply, text)
			if text:sub(1, 1) == "@" then
				ply:Say("!asay " .. text:sub(2))
				return ""
			end
		end)
	end
end

do
	command.new("mute")
		:SetPermission("mute", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("mute_help")

		:OnExecute(function(ply, targets, length, reason)
			local current_time = SysTime()

			for i = 1, #targets do
				local target = targets[i]
				target:sam_set_pdata("unmute_time", length ~= 0 and (current_time + length * 60) or 0)
			end

			sam.player.send_message(nil, "mute", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("unmute")
		:SetPermission("unmute", "admin")
		:AddArg("player", {optional = true})
		:Help("unmute_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i]:sam_set_pdata("unmute_time", nil)
			end

			sam.player.send_message(nil, "unmute", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		sam.hook_first("PlayerSay", "SAM.Chat.Mute", function(ply, text)
			local unmute_time = ply:sam_get_pdata("unmute_time")
			if not unmute_time then return end

			if text:sub(1, 1) == "!" and text:sub(2, 2):match("%S") ~= nil then
				local args = sam.parse_args(text:sub(2))

				local cmd_name = args[1]
				if not cmd_name then return end

				local cmd = command.get_command(cmd_name)
				if cmd then
					return
				end
			end

			if unmute_time == 0 or unmute_time > SysTime() then
				return ""
			else
				ply:sam_set_pdata("unmute_time", nil)
			end
		end)
	end
end

do
	command.new("gag")
		:SetPermission("gag", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("gag_help")

		:OnExecute(function(ply, targets, length, reason)
			for i = 1, #targets do
				local target = targets[i]
				target.sam_gagged = true
				if length ~= 0 then
					timer.Create("SAM.UnGag" .. target:SteamID64(), length * 60, 1, function()
						RunConsoleCommand("sam", "ungag", "#" .. target:EntIndex())
					end)
				end
			end

			sam.player.send_message(nil, "gag", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("ungag")
		:SetPermission("ungag", "admin")

		:AddArg("player", {optional = true})
		:Help("ungag_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local target = targets[i]
				target.sam_gagged = nil
				timer.Remove("SAM.UnGag" .. target:SteamID64())
			end

			sam.player.send_message(nil, "ungag", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		hook.Add("PlayerCanHearPlayersVoice", "SAM.Chat.Gag", function(_, ply)
			if ply.sam_gagged then
				return false
			end
		end)

		hook.Add("SAM.AuthedPlayer", "SAM.Gag", function(ply)
			local gag_time = ply:sam_get_pdata("gagged")
			if gag_time then
				ply:sam_set_pdata("gagged", nil)
				RunConsoleCommand("sam", "gag", "#" .. ply:EntIndex(), gag_time / 60, "LTAP")
			end
		end)

		hook.Add("PlayerDisconnected", "SAM.Gag", function(ply)
			if ply.sam_gagged then
				ply:sam_set_pdata("gagged", timer.TimeLeft("SAM.UnGag" .. ply:SteamID64()) or 0)
			end
		end)
	end
end

--PATH addons/[admin] sam-160/lua/sam/modules/teleport.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/user.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_image.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_property_sheet.lua:
local draw = draw
local surface = surface
local vgui = vgui

local TYPE_MATERIAL = TYPE_MATERIAL

local RealFrameTime = RealFrameTime
local IsValid = IsValid
local Lerp = Lerp
local pairs = pairs
local TypeID = TypeID

local TDLib_Classes = sui.TDLib.LibClasses
local TextColor = TDLib_Classes.TextColor
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local PROPERTY_SHEET_FONT = SUI.CreateFont("PropertySheet", "Roboto Regular", 18)

local PANEL = {}

AccessorFunc(PANEL, "m_FontName", "Font", FORCE_STRING)

function PANEL:Init()
	self.tabs = {}

	self:SetFont(PROPERTY_SHEET_FONT)

	local tab_scroller = self:Add("DHorizontalScroller")
	tab_scroller:Dock(TOP)

	self.tabs_tall = 26
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self.tab_scroller:SetTall(SUI.Scale(self.tabs_tall))

	for k, v in pairs(self.tab_scroller.Panels) do
		if v:IsValid() then
			if v.Material then
				v:SetWide(self.tab_scroller:GetTall())
			else
				v:SizeToContentsX()
			end
		end
	end

	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, self.tab_scroller:GetTall(), SUI.GetColor("property_sheet_bg"))
end

function PANEL:PaintOver(w, h)
	local active_tab = self:GetActiveTab()
	if not IsValid(active_tab) then return end

	local tab_scroller = self.tab_scroller
	local offset = tab_scroller:GetTall() - SUI.Scale(1)

	local x = active_tab:LocalToScreen(0) - self:LocalToScreen(0)

	if not self.activeTabX then
		self.activeTabX = x
		self.activeTabW = active_tab:GetWide()
	end

	local delta = RealFrameTime() * 6
	if delta then
		self.activeTabX = Lerp(delta, self.activeTabX, x)
		self.activeTabW = Lerp(delta, self.activeTabW, active_tab:GetWide())
	end

	self:RoundedBox("Background2", 1, self.activeTabX, tab_scroller.y + offset, self.activeTabW, SUI.Scale(1), SUI.GetColor("property_sheet_tab_active"))
end

local tab_Paint = function(s, w, h)
	s.circle_click_color = SUI.GetColor("property_sheet_tab_click")
	if s.property_sheet:GetActiveTab() == s then
		TextColor(s, SUI.GetColor("property_sheet_tab_active"))
	else
		TextColor(s, SUI.GetColor("property_sheet_tab"))
	end
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local image_paint = function(s, w, h)
	surface.SetDrawColor(color_white)
	surface.SetMaterial(s.Material)
	surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, w - 10, h - 10, 0)
end

function PANEL:AddSheet(name, load_func)
	local tab = vgui.Create("DButton")
	if TypeID(name) == TYPE_MATERIAL then
		tab:SetText("")
		tab.Material = name
		tab.Paint = image_paint
		tab:SetWide(self.tab_scroller:GetTall())
	else
		tab:SetFont(self:GetFont())
		tab:SetText(name)
		tab:SetTextInset(10, 0)
		tab:SizeToContentsX()

		tab.Paint = tab_Paint
	end

	tab.parent = self
	tab.DoClick = tab_DoClick

	tab.load_func = load_func
	tab.property_sheet = self

	tab.On = TDLib_Classes.On
	TDLib_Classes.CircleClick(tab)

	self.tab_scroller:AddPanel(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function PANEL:GetActiveTab()
	return self.active_tab
end

function PANEL:SetActiveTab(new_tab)
	if IsValid(new_tab) and not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	if self.active_tab and IsValid(self.active_tab.panel) then
		self.active_tab.panel:SetVisible(false)
	end

	if IsValid(new_tab) then
		new_tab.panel:SetVisible(true)
	end

	self.active_tab = new_tab
end

sui.register("PropertySheet", PANEL, "EditablePanel")
--PATH addons/[lib] sui/lua/sui/vgui/sui_threegrid.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/libs/sh_types.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/settings/tabs/emojis.lua:
if SCB_LOADED then return end

local scb = scb
local SUI = scb.SUI
local language = scb.language

scb.emojis = include("scb/cl_emojis_data.lua")

do
	local set_material = surface.SetMaterial
	local i = 0
	for name in pairs(scb.emojis) do
		timer.Simple(i * 0.001, function()
			set_material(SUI.Material("scb/emojis/" .. name .. ".png"))
		end)
		i = i + 1
	end
end

net.Receive("SCB.SendEmojis", function()
	local emojis = net.ReadData(net.ReadUInt(17))
	emojis = util.Decompress(emojis)

	for k, v in pairs(scb.mp.unpack(emojis)) do
		scb.emojis[k] = v
	end

	hook.Call("SCB.EmojisModified")
end)

net.Receive("SCB.AddEmoji", function()
	local emoji = net.ReadString()
	local url = net.ReadString()
	scb.emojis[emoji] = url

	local old = net.ReadString()
	if old ~= "" then
		scb.emojis[old] = nil
	end

	hook.Call("SCB.EmojisModified")
end)

net.Receive("SCB.RemoveEmoji", function()
	scb.emojis[net.ReadString()] = nil
	hook.Call("SCB.EmojisModified")
end)

local emoji_menu = function(title, emoji_name, emoji_url)
	emoji_name = emoji_name or ""

	local options = sui.valid_options()

	local querybox = vgui.Create("SCB.QueryBox")
	querybox:SetTitle(title)
	querybox:SetWide(300)

	local name = querybox:Add("SCB.TextEntry")
	name:Dock(TOP)
	name:SetPlaceholder(language.emoji_name)
	name:SetValue(emoji_name)
	name:SetCheck(function(_name)
		if _name == "" or (scb.emojis[_name] and emoji_name ~= _name) then
			return false
		end
	end)

	function name:AllowInput(c)
		return not c:find("[%w_]")
	end

	options.Add(name)

	local url = querybox:Add("SCB.TextEntry")
	url:Dock(TOP)
	url:DockMargin(0, 4, 0, 0)
	url:SetPlaceholder(language.emoji_url)
	url:SetValue(emoji_url or "")
	url:SetCheck(function(_url)
		if not _url:find("^https?://") then
			_url = "http://" .. _url
		end

		if scb.find_url(_url) ~= 1 then
			return false
		end
	end)

	function url:AllowInput(c)
		return c:find("%s") and true or false
	end

	options.Add(url)

	querybox:SetCallback(function()
		local _name = name:GetText():lower()
		local _url = url:GetText()

		if not _url:find("^https?://") then
			_url = "http://" .. _url
		end

		net.Start("SCB.AddEmoji")
			net.WriteString(_name)
			net.WriteString(_url)
			net.WriteString(_name ~= emoji_name and emoji_name or "")
		net.SendToServer()
	end)

	querybox:Done()
	querybox.save:SetEnabled(true)

	function querybox.save:Think()
		self:SetEnabled(options.IsValid())
	end
end

return {
	title = language.emojis_title,
	pos = 3,
	func = function(parent)
		local body = parent:Add("Panel")
		body:Dock(FILL)
		body:DockMargin(0, 1, 0, 0)
		body:InvalidateParent(true)

		SUI.OnScaleChanged(body, function()
			body:Remove()
		end)

		local top_body = body:Add("Panel")
		top_body:Dock(FILL)
		top_body:InvalidateParent(true)

		local search_field = top_body:Add("SCB.TextEntry")
		search_field:Dock(TOP)
		search_field:SetPlaceholder(language.search)

		local emojis_list = top_body:Add("SCB.ThreeGrid")
		emojis_list:Dock(FILL)
		emojis_list:DockMargin(3, 3, 3, 3)
		emojis_list:InvalidateLayout(true)
		emojis_list:InvalidateParent(true)

		emojis_list:SetColumns(3)
		emojis_list:SetHorizontalMargin(2)
		emojis_list:SetVerticalMargin(2)

		top_body.Paint, emojis_list.Paint = emojis_list.Paint, nil

		local load_emojis = function(search_key)
			emojis_list:Clear()

			search_key = search_key:lower()

			for emoji_name, v in pairs(scb.emojis) do
				if not scb.is_custom_emoji(v) then
					continue
				end

				if not string.find(emoji_name:lower(), search_key, 1, true) then
					continue
				end

				local pnl = vgui.Create("DButton")
				pnl:SetText("")
				pnl:SetTall(SUI.Scale(30))
				pnl:SUI_TDLib()
					:ClearPaint()
					:FadeHover()

				function pnl:DoClick()
					emoji_menu(language.edit .. " '" .. emoji_name .. "'", emoji_name, v)
				end

				function pnl:DoRightClick()
					local d_menu = DermaMenu()

					d_menu:AddOption(language.remove, function()
						net.Start("SCB.RemoveEmoji")
							net.WriteString(emoji_name:lower())
						net.SendToServer()
					end)

					d_menu:Open()
					d_menu:MakePopup()

					function pnl:OnRemove()
						d_menu:Remove()
					end
				end

				local emoji = pnl:Add("SCB.ChatLine")
				emoji:Dock(NODOCK)
				emoji.x = 2

				emoji:NewEmoji(emoji_name, v, 26)
				emoji:Center()
				emoji:SetMouseInputEnabled(false)

				local name = pnl:Add("SCB.Label")
				name:Dock(FILL)
				name:DockMargin(SUI.ScaleEven(26) + 8, 0, 0, 0)
				name:SetFont(SCB_16)
				name:SetText(emoji_name)

				emojis_list:AddCell(pnl)
			end
		end
		load_emojis("")

		hook.Add("SCB.EmojisModified", emojis_list, function()
			load_emojis(search_field:GetValue())
		end)

		function search_field:OnValueChange(v)
			load_emojis(v)
		end

		local add_emoji = body:Add("SCB.Button")
		add_emoji:Dock(BOTTOM)
		add_emoji:DockMargin(0, 4, 0, 0)
		add_emoji:SetText(language.add_emoji:upper())

		add_emoji:On("DoClick", function()
			emoji_menu(language.add_emoji)
		end)

		return body
	end
}
--PATH addons/[chat] scb-29/lua/scb/cl_emojis_data.lua:
return gluapack()()
--PATH lua/arc9/common/localization/font_en.lua:
return gluapack()()
--PATH lua/arc9/common/localization/content_base_en.lua:
L = {}

//////// Folders
L["folder.arc9"] = "ARC9"
L["folder.arc9.community"] = "Community"

L["attachment.sticker"] = "Sticker"

//////// Flat Camo
L["camo_arc9_base_flat_od.printname"] = "Olive Drab"
L["camo_arc9_base_flat_od.compactname"] = "OD"
L["camo_arc9_base_flat_od.description"] = "Standard Olive Drab camouflage."

L["camo_arc9_base_flat_deserttan.printname"] = "Desert Tan"
L["camo_arc9_base_flat_deserttan.compactname"] = "Tan"
L["camo_arc9_base_flat_deserttan.description"] = "Standard Desert Tan camouflage."

L["camo_arc9_base_flat_arctic.printname"] = "Arctic White"
L["camo_arc9_base_flat_arctic.compactname"] = "Arctic"
L["camo_arc9_base_flat_arctic.description"] = "Standard Arctic White camouflage."

L["camo_arc9_base_flat_black.printname"] = "Factory Black"
L["camo_arc9_base_flat_black.compactname"] = "Black"
L["camo_arc9_base_flat_black.description"] = "Standard Factory Issue Black."

L["camo_arc9_base_flat_urbangray.printname"] = "Urban Gray"
L["camo_arc9_base_flat_urbangray.compactname"] = "Urban"
L["camo_arc9_base_flat_urbangray.description"] = "Standard Urban Gray camouflage."

L["camo_arc9_base_flat_forestgreen.printname"] = "Forest Green"
L["camo_arc9_base_flat_forestgreen.compactname"] = "Forest"
L["camo_arc9_base_flat_forestgreen.description"] = "Standard Forest Green camouflage."

L["camo_arc9_base_flat_navy.printname"] = "Navy Blue"
L["camo_arc9_base_flat_navy.compactname"] = "Navy"
L["camo_arc9_base_flat_navy.description"] = "Standard Navy Blue color."

L["camo_arc9_base_flat_mountbattenpink.printname"] = "Mountbatten Pink"
L["camo_arc9_base_flat_mountbattenpink.compactname"] = "MP"
L["camo_arc9_base_flat_mountbattenpink.description"] = "Standard Mountbatten Pink camouflage.\nShockingly effective in desert conditions."

L["camo_arc9_base_flat_fde.printname"] = "Flat Dark Earth"
L["camo_arc9_base_flat_fde.compactname"] = "FDE"
L["camo_arc9_base_flat_fde.description"] = "Standard Flat Dark Earth camouflage."

//////// Flat Colour
L["camo_arc9_base_flat_red.printname"] = "Red"
L["camo_arc9_base_flat_red.compactname"] = "Red"
L["camo_arc9_base_flat_red.description"] = "Basic red color."

L["camo_arc9_base_flat_orange.printname"] = "Orange"
L["camo_arc9_base_flat_orange.compactname"] = "Orange"
L["camo_arc9_base_flat_orange.description"] = "Basic orange color."

L["camo_arc9_base_flat_yellow.printname"] = "Yellow"
L["camo_arc9_base_flat_yellow.compactname"] = "Yellow"
L["camo_arc9_base_flat_yellow.description"] = "Basic yellow color."

L["camo_arc9_base_flat_green.printname"] = "Green"
L["camo_arc9_base_flat_green.compactname"] = "Green"
L["camo_arc9_base_flat_green.description"] = "Basic green color."

L["camo_arc9_base_flat_blue.printname"] = "Blue"
L["camo_arc9_base_flat_blue.compactname"] = "Blue"
L["camo_arc9_base_flat_blue.description"] = "Basic blue color."

L["camo_arc9_base_flat_purple.printname"] = "Purple"
L["camo_arc9_base_flat_purple.compactname"] = "Purple"
L["camo_arc9_base_flat_purple.description"] = "Basic purple color."

L["camo_arc9_base_flat_pink.printname"] = "Pink"
L["camo_arc9_base_flat_pink.compactname"] = "Pink"
L["camo_arc9_base_flat_pink.description"] = "Eye searingly bright pink color."

L["camo_arc9_base_flat_arc9orange.printname"] = "ARC9 Orange"
L["camo_arc9_base_flat_arc9orange.compactname"] = "ARC9 Orange"
L["camo_arc9_base_flat_arc9orange.description"] = "The perfect shade of orange for that cute little ARC9 Logo sticker."

//////// Charms
L["charm_gs_killcounter.printname"] = "Kill Counter"
L["charm_gs_killcounter.compactname"] = "KILL"
L["charm_gs_killcounter.description"] = "Device for tracking your weapon's kill stats."

L["charm_gs_clock.printname"] = "Basic Clock"
L["charm_gs_clock.compactname"] = "CLOCK"
L["charm_gs_clock.description"] = "Device that displays the real-world time."

L["charm_gs_sticker.printname"] = "Sticker Panel"
L["charm_gs_sticker.compactname"] = "STICKER"
L["charm_gs_sticker.description"] = "Device that allows a custom sticker to be applied onto its screen."

//////// Stickers, Base
L["sticker_spray.printname"] = "Player Spray"
L["sticker_spray.compactname"] = "Spray"
L["sticker_spray.description"] = [[Your own spray as a sticker!
You will only be able to see your own and not ones from other players.

Sticker included in the ARC9 Base.]]

L["sticker_arc9.printname"] = "ARC9 Logo (Low Vis.)"
L["sticker_arc9.compactname"] = "ARC9"
L["sticker_arc9.description"] = [[Dark version of the ARC9 logo.
Design by The Villain.

Sticker included in the ARC9 Base.]]

L["sticker_arc9_lowvis.printname"] = "ARC9 Logo"
L["sticker_arc9_lowvis.compactname"] = "ARC9"
L["sticker_arc9_lowvis.description"] = [[Here's to you.
Design by The Villain.

Sticker included in the ARC9 Base.]]

L["sticker_a9k.printname"] = "ARCTICTHRON 9.000 WEAPON BASE"
L["sticker_a9k.compactname"] = "A9K"
L["sticker_a9k.description"] = [[this is what "arc9" actually means

Sticker included in the ARC9 Base.]]

L["sticker_a9cylo.printname"] = "ARC9 Concept logo by CyloWalker"
L["sticker_a9cylo.compactname"] = "A9 Cylo"
L["sticker_a9cylo.description"] = [[One of the first concepts for ARC9 logo/icon by CyloWalker (he's cool!)

Sticker included in the ARC9 Base.]]

L["sticker_sus9.printname"] = "Sus 9"
L["sticker_sus9.compactname"] = "Sus 9"
L["sticker_sus9.description"] = [[The impostor could be anywhere among us...
Design by Darsu.

Sticker included in the ARC9 Base.]]

//////// Stickers, Com. Wave 1
L["sticker_alien_lean.printname"] = "Legalize Alien Lean"
L["sticker_alien_lean.compactname"] = "Alien Lean"
L["sticker_alien_lean.description"] = [[Hop down to Agartha with the white boys for a cup of alien lean and... other things.
Design by Opt1ca.

Sticker included in the ARC9 Base.]]

L["sticker_tomatocat.printname"] = "Tomato Cat"
L["sticker_tomatocat.compactname"] = "Tomato Cat"
L["sticker_tomatocat.description"] = [[Sometimes people ask whether tomatoes are fruits or vegetables... This one might be a tougher question.
Design by Ender2Point0.

Sticker included in the ARC9 Base.]]

L["sticker_actionbird.printname"] = "Action Bird"
L["sticker_actionbird.compactname"] = "Action Bird"
L["sticker_actionbird.description"] = [[This is what Arctic looks like in real life.
Design by CyloWalker.

Sticker included in the ARC9 Base.]]

L["sticker_warcrimes.printname"] = "War Crimes"
L["sticker_warcrimes.compactname"] = "War Crimes"
L["sticker_warcrimes.description"] = [[You're already doing them, so why not shout it out loud? Who's gonna stop you, the UN?
Design by Rimuchii. Made using Project Sekai sticker base.

Sticker included in the ARC9 Base.]]

L["sticker_sillycat.printname"] = "Silly Cat"
L["sticker_sillycat.compactname"] = "Silly Cat"
L["sticker_sillycat.description"] = [[imsillyimsillyimsillyimsillyimsillyimsillyimsillyimsilly
Design by Stan_Jacobs.

Sticker included in the ARC9 Base.]]

L["sticker_muertosskull.printname"] = "Dia De Los Muertos Calavera"
L["sticker_muertosskull.compactname"] = "Los Muertos"
L["sticker_muertosskull.description"] = [["this should be my final version i think, unless anyone gives me suggestions to change it, the name: "Dia de los muertos calavera" the description: i cant think of one, something about day of the dead skull mexico blah blah blah"
Design by rooneyviz.

Sticker included in the ARC9 Base.]]

L["sticker_bandaid.printname"] = "Band-Aid"
L["sticker_bandaid.compactname"] = "Band-Aid"
L["sticker_bandaid.description"] = [[Put it on your boo-boo and kiss it all better.
Design by Itzal.

Sticker included in the ARC9 Base.]]

L["sticker_peacedove.printname"] = "Peace Through Superior Firepower"
L["sticker_peacedove.compactname"] = "PTSF"
L["sticker_peacedove.description"] = [[The dove brings peace, but the gun brings peace through superior firepower.
Design by Xipil.

Sticker included in the ARC9 Base.]]

L["sticker_borntomodify.printname"] = "Born To Modify"
L["sticker_borntomodify.compactname"] = "BTM"
L["sticker_borntomodify.description"] = [[Another sight - another scope - a grenade launcher, here and there...
Design by Duck.

Sticker included in the ARC9 Base.]]

L["sticker_cad.printname"] = "cad"
L["sticker_cad.compactname"] = "cad"
L["sticker_cad.description"] = [[cad
Design by Opt1ca.

Sticker included in the ARC9 Base.]]

L["sticker_fumo.printname"] = "Fumo"
L["sticker_fumo.compactname"] = "Fumo"
L["sticker_fumo.description"] = [[D-don't look at me like that, raifu-kun...
Design by Itzal.

Sticker included in the ARC9 Base.]]

L["sticker_hotlead.printname"] = "Hot Lead"
L["sticker_hotlead.compactname"] = "Hot Lead"
L["sticker_hotlead.description"] = [[Careful! It's hot!
Design by Arqu.

Sticker included in the ARC9 Base.]]

L["sticker_steamhappy.printname"] = ":steamhappy:"
L["sticker_steamhappy.compactname"] = ":steamhappy:"
L["sticker_steamhappy.description"] = [[Happy about it
Design from Steam.

Sticker included in the ARC9 Base.]]

L["sticker_amidstus.printname"] = "Amidstus"
L["sticker_amidstus.compactname"] = "Amidstus"
L["sticker_amidstus.description"] = [[Why settle for the original when you could have a cheap knockoff?!
Design from Optica.

Sticker included in the ARC9 Base.]]

L["sticker_arcglory.printname"] = "Glory!"
L["sticker_arcglory.compactname"] = "Glory!"
L["sticker_arcglory.description"] = [[Took nine brain cells to scribble this
Design from Optica.

Sticker included in the ARC9 Base.]]

L["sticker_wp.printname"] = "World Peace!"
L["sticker_wp.compactname"] = "World Peace!"
L["sticker_wp.description"] = [[A delusion!
Design from Fidget.

Sticker included in the ARC9 Base.]]

L["sticker_tonkr.printname"] = "Send It"
L["sticker_tonkr.compactname"] = "Send It"
L["sticker_tonkr.description"] = [[Yeah, it's that heavy. Yeah, it's that powerful.
Design from CyloWalker.

Sticker included in the ARC9 Base.]]

L["sticker_s6amblem.printname"] = "Section 6"
L["sticker_s6amblem.compactname"] = "Section 6"
L["sticker_s6amblem.description"] = [[Reach for the stars. Forward to Glory!
Design from CyloWalker.

Sticker included in the ARC9 Base.]]

L["sticker_babies.printname"] = "Baby Hazard"
L["sticker_babies.compactname"] = "Baby Hazard"
L["sticker_babies.description"] = [[Children ages 0-3 should be kept away from this.. firearm.
Design from Itzal.

Sticker included in the ARC9 Base.]]

L["sticker_drawberf.printname"] = "Berf"
L["sticker_drawberf.compactname"] = "Berf"
L["sticker_drawberf.description"] = [[Draw Berf.
Design by The Villain.

Sticker included in the ARC9 Base.]]

L["sticker_arcbird.printname"] = "Arc Bird"
L["sticker_arcbird.compactname"] = "Arc Bird"
L["sticker_arcbird.description"] = [[Arc Bird.
Design by Nori/Chewable.

Sticker included in the ARC9 Base.]]

--PATH lua/arc9/common/localization/font_en.lua:
return gluapack()()
--PATH lua/arc9/common/localization/content_base_en.lua:
return gluapack()()
--PATH lua/arc9/common/localization/base_de.lua:
L = {}

/////////////////////////////////////// Font
////////////////////// See "font_en" file

/////////////////////////////////////// General
////////////////////// Units of measurement
L["unit.second"] = "s"
L["unit.meter"] = "m"
L["unit.millimeter"] = "mm"
L["unit.meterpersecond"] = "m/s"
L["unit.hammerunit"] = "HU"
L["unit.decibel"] = "dB"
L["unit.rpm"] = "SPM"
L["unit.moa"] = "MOA"
L["unit.dmg"] = "DMG"
L["unit.projectiles"] = "PROJ"

L["unit.inch"] = "in"
L["unit.foot"] = "ft"
L["unit.footpersecond"] = "ft/s"
L["unit.yard"] = "yd"

////////////////////// Ammo types
L["ammo.pistol"] = "Pistolen-Munition"
L["ammo.357"] = "Magnum-Munition"
L["ammo.smg1"] = "Carbine-Munition"
L["ammo.ar2"] = "Gewehr-Munition"
L["ammo.buckshot"] = "Shotgun-Munition"
L["ammo.sniperpenetratedround"] = "Sniper-Munition"
L["ammo.smg1_grenade"] = "Rifle-Granaten"
-- L["ammo.xbowbolt"] = "Crossbow Bolts"
-- L["ammo.rpg_round"] = "Rockets"
-- L["ammo.grenade"] = "Grenades"
-- L["ammo.slam"] = "SLAM"
-- L["ammo.alyxgun"] = "Alyx's Gun Ammo"

/////////////////////////////////////// HUD
L["hud.version"] = "ARCTIC SYSTEME UI v"
L["hud.jammed"] = "EINGEKLEMMT!"
L["hud.therm_deco"] = "LAUF-TEMP"

L["hud.firemode.single"] = "EINZEL"
L["hud.firemode.burst"] = "BURST"
L["hud.firemode.auto"] = "AUTO"
L["hud.firemode.safe"] = "SICHER"

L["hud.hint.bash"] = "Schlagen"
-- L["hud.hint.bipod"] = "Toggle Bipod"
L["hud.hint.breath"] = "Atem anhalten"
L["hud.hint.customize"] = "Anpassen"
L["hud.hint.cycle"] = "Repetieren"
L["hud.hint.firemode"] = "Feuermodus ändern"
L["hud.hint.inspect"] = "Inspizieren"
L["hud.hint.lean"] = "Lehnen"
L["hud.hint.peek"] = "Spähen"
L["hud.hint.reload"] = "Nachladen"
L["hud.hint.safe"] = "Sicherung"
L["hud.hint.switchsights"] = "Visierung umschalten"
L["hud.hint.toggleatts"] = "Aufsätze umschalten"
L["hud.hint.ubgl"] = "Umschalten"
-- L["hud.hint.unjam"] = "Unjam"
L["hud.hint.zoom"] = "Zoom ändern"
-- L["hud.hint.quicknade"] = "Quickthrow "

-- L["hud.hint.lowammo"] = "Low Ammo"
-- L["hud.hint.noammo"] = "No Ammo"

-- L["hud.error.missingbind"] = "No button bound to %s"
-- L["hud.error.missingbind_zoom"] = "Bind \"Suit Zoom\" in settings!"
-- L["hud.error.missingbind_context"] = "Bind \"Open Context Menu\" in settings!"

/////////////////////////////////////// Customization menu
L["customize.panel.customize"] = "ANPASSEN"
L["customize.panel.personalize"] = "PERSONALISIEREN"
L["customize.panel.stats"] = "STATS & BALLISTIK"
L["customize.panel.trivia"] = "TRIVIA"
L["customize.panel.inspect"] = "INSPIZIEREN"
L["customize.panel.presets"] = "Presets"

L["customize.stats.aimtime"] = "Zielvorrichtungs-Zeit"
L["customize.stats.ammo"] = "Munitionstyp"
L["customize.stats.armorpiercing"] = "Schutzdurchdringen"
L["customize.stats.burstdelay"] = "Burst-Verzögerung"
L["customize.stats.capacity"] = "Kapazität"
L["customize.stats.cyclic"] = "Zyklische Feuerrate"
L["customize.stats.explosive"] = "Explosivschaden"
L["customize.stats.firemodes"] = "Feuermodi"
L["customize.stats.firepower"] = "Feuerkraft"
L["customize.stats.freeaim"] = "Freiziel-Radius"
L["customize.stats.muzzlevelocity"] = "Mündungsgeschwindigkeit"
L["customize.stats.noise"] = "Schwanken-Noise"
L["customize.stats.penetration"] = "Penetration"
L["customize.stats.precision"] = "Präzision"
L["customize.stats.range"] = "Reichweite"
L["customize.stats.ricochet"] = "Abprallchance"
L["customize.stats.rof"] = "Feuerrate"
L["customize.stats.speed"] = "Bewegungsgeschwindigkeit"
L["customize.stats.sprinttofire"] = "Sprint-bis-Feuer-Zeit"
L["customize.stats.supplylimit"] = "Nachschublimit"
L["customize.stats.sway"] = "Schwanken"
L["customize.stats.triggerdelay"] = "Abzugs-Verzögerung"

L["customize.hint.attach"] = "Anhängen"
L["customize.hint.controller"] = "Controller-Modus ist an."
L["customize.hint.cursor"] = "Zeiger"
L["customize.hint.cycle"] = "Nächster Slot"
L["customize.hint.delete"] = "Entfernen"
L["customize.hint.deselect"] = "Deselektieren"
L["customize.hint.expand"] = "Erweitern"
L["customize.hint.export"] = "Exportieren"
L["customize.hint.favorite"] = "Favorisieren"
L["customize.hint.import"] = "Importieren"
L["customize.hint.install"] = "Installieren"
L["customize.hint.last"] = "Letzter Slot"
L["customize.hint.lastmode"] = "Letzter Modus"
L["customize.hint.nextmode"] = "Nächster Modus"
L["customize.hint.open"] = "Öffnen"
L["customize.hint.pan"] = "Verschieben"
L["customize.hint.quicksave"] = "Schnellspeichern"
-- L["customize.hint.randomize"] = "Attach Random"
L["customize.hint.recalculate"] = "Rekalkuliere"
L["customize.hint.recenter"] = "Zentrieren"
L["customize.hint.rotate"] = "Drehen"
L["customize.hint.save"] = "Speichern"
L["customize.hint.select"] = "Auswählen"
L["customize.hint.unattach"] = "Anhang entfernen"
L["customize.hint.unfavorite"] = "Entfavorisieren"
L["customize.hint.zoom"] = "Zoomen"

L["customize.trivia.description"] = "Beschreibung"

-- L["customize.stats.explain.firepower"] = "The damage potential at point-blank range."
-- L["customize.stats.explain.rof"] = "The weapon's rate of fire."
-- L["customize.stats.explain.cyclic"] = "The weapon's cyclic rate of fire. Ignores factors like burst delay or reload requirements."
-- L["customize.stats.explain.capacity"] = "How much ammo the gun can hold in the magazine + chamber."
-- L["customize.stats.explain.range"] = "The range at which the gun deals minimum damage."
-- L["customize.stats.explain.precision"] = "The weapon's accuracy. Measured in Minutes of Accuracy (MOA)."
-- L["customize.stats.explain.muzzlevelocity"] = "The muzzle velocity of bullets fired from this gun."
-- L["customize.stats.explain.ammo"] = "The type of ammo this gun uses."
-- L["customize.stats.explain.penetration"] = "Amount of material this gun can penetrate."
-- L["customize.stats.explain.ricochet"] = "Maximum chance for bullets from this gun to ricochet."
-- L["customize.stats.explain.armorpiercing"] = "Amount of damage from this gun that completely ignores most damage resistances."
-- L["customize.stats.explain.explosive"] = "Amount of explosive damage this gun will do."
-- L["customize.stats.explain.speed"] = "Speed at which you can move while using this gun."
-- L["customize.stats.explain.aimtime"] = "How long it takes to aim down sights from hip fire."
-- L["customize.stats.explain.sprinttofire"] = "How long it takes to exit sprint and begin shooting."
-- L["customize.stats.explain.firemodes"] = "Which fire modes this gun has access to."
-- L["customize.stats.explain.burstdelay"] = "Amount of time after firing a burst before the gun can fire again."
-- L["customize.stats.explain.triggerdelay"] = "Delay between pulling the trigger and firing a shot."
-- L["customize.stats.explain.noise"] = "How loud the gun's gunshots are."
-- L["customize.stats.explain.sway"] = "Amount of sway applied to the gun."
-- L["customize.stats.explain.freeaim"] = "Maximum free aim angle. Lower is better."
-- L["customize.stats.explain.supplylimit"] = "Amount of ammo that the gun can receive from ARC9 ammo sources."

L["customize.bench.dummy"] = "BALLISTIK-ATTRAPPEN-TEST"
L["customize.bench.effect"] = "EFFEKT AUF DISTANZ"
L["customize.bench.ballistics"] = "TERMINAL-BALLISTIK LEISTUNGS-EVALUATION"
L["customize.bench.precision"] = "MECHANISCHER PRÄZISIONSTEST"

L["folder.back"] = "Zurück"
L["folder.deselect"] = "Deselektieren"
L["folder.favorites"] = "Favoriten"
L["folder.select"] = "Auswählen"

////////////////////// Automatic stats
L["autostat.enable.pre"] = "Aktivierungen"
L["autostat.disable.pre"] = "Deaktivierungen"
L["autostat.enable.post"] = ""
L["autostat.disable.post"] = ""

L["autostat.aimdownsightstime"] = "Zielvorrichtungs-Zeit"
L["autostat.alwaysphysbullet"] = "Nutze immer Projketile"
L["autostat.ammopershot"] = "Munitionsverbrauch pro Schuss"
L["autostat.armdamage"] = "Armschaden"
L["autostat.armorpiercing"] = "Schutzdurchdringen"
L["autostat.autoburst"] = "Automatisches Burst-Feuer"
L["autostat.autoreload"] = "Automatisches Nachladen"
L["autostat.bash"] = "Nahkampfattacken"
L["autostat.bashdamage"] = "Nahkampfschaden"
L["autostat.bashlungerange"] = "Nahkampfsturz-Entfernung"
L["autostat.bashrange"] = "Nahkampfentfernung"
L["autostat.bashspeed"] = "Nahkampfgeschwindigkeit"
L["autostat.bipod"] = "Zweibein"
L["autostat.bottomlessclip"] = "Bodenloses Magazin"
L["autostat.breathholdtime"] = "Fokus-Zeit"
L["autostat.bulletguidance"] = "Gesteuerte Projektile"
L["autostat.bulletguidanceamount"] = "Steuerungsfaktor"
L["autostat.canfireunderwater"] = "Schießen unter Wasser"
-- L["autostat.cantpeek"] = "Disables Peeking"
L["autostat.chambersize"] = "Verschlussanzahl"
L["autostat.chestdamage"] = "Brustschaden"
L["autostat.clipsize"] = "Magazinkapazität"
L["autostat.cycletime"] = "Repetier-Zeit"
L["autostat.damagemax"] = "Maximalschaden"
L["autostat.damagemin"] = "Minimalschaden"
L["autostat.damagerand"] = "Damage Variance"
L["autostat.deploytime"] = "Zücke-Zeit"
L["autostat.distance"] = "Projektilentfernung"
L["autostat.entitymuzzlevelocity"] = "Projektil-Mündungsgeschwindigkeit"
L["autostat.explosiondamage"] = "Explosionsschaden"
L["autostat.explosionradius"] = "Explosionsradius"
L["autostat.fixtime"] = "Entklemm-Zeit"
L["autostat.freeaimradius"] = "Freies-Zielen-Radius"
L["autostat.headshotdamage"] = "Kopfschussschaden"
L["autostat.heatcapacity"] = "Hitzekapazität"
L["autostat.heatdissipation"] = "Hitzeverfall"
L["autostat.heatpershot"] = "Hitze pro Schuss"
L["autostat.hybridreload"] = "Hybrides Individuelles Nachladen"
L["autostat.infiniteammo"] = "Unendlich Munition"
L["autostat.legdamage"] = "Beinschaden"
L["autostat.malfunction"] = "Einklemmen"
L["autostat.malfunctionmeanshotstofail"] = "Durchs. Schüsse zwischen Fehlfunktionen"
L["autostat.malfunctionwait"] = "Fehlfunktion-Wartezeit"
L["autostat.manualaction"] = "Manuelle Bedienung"
L["autostat.manualactionchamber"] = "Schussanzahl per Repetition"
L["autostat.neverphysbullet"] = "Nutze nie Projektile"
L["autostat.noflash"] = "Kein Mündungsfeuer"
L["autostat.num"] = "Projektilanzahl"
L["autostat.overheat"] = "Überhitzen"
L["autostat.overheattime"] = "Überhitzungs-Zeit"
L["autostat.pelletspread"] = "Kügelchenstreuung"
L["autostat.penetration"] = "Materialpenetration"
-- L["autostat.penetrationdelta"] = "Damage After Penetration"
L["autostat.physbulletdrag"] = "Projektilverzug"
L["autostat.physbulletgravity"] = "Projektilschwerkraft"
L["autostat.physbulletmuzzlevelocity"] = "Mündungsgeschwindigkeit"
L["autostat.postburstdelay"] = "Burst-Verzögerung"
L["autostat.pushbackforce"] = "Pushback-Kraft"
L["autostat.rangemax"] = "Maximale Reichweite"
L["autostat.rangemin"] = "Minimale Reichweite"
L["autostat.recoil"] = "Rückstoß"
L["autostat.recoilautocontrol"] = "Rückstoßkontrolle"
L["autostat.recoildissipationrate"] = "Rückstoß-Ausschweifungsrate"
L["autostat.recoilkick"] = "Gefühlter Rückstoß"
-- L["autostat.recoilmodifiercap"] = "Maximum Cumulative Recoil"
L["autostat.recoilpatterndrift"] = "Rückstoß-Drift"
-- L["autostat.recoilpershot"] = "Recoil per Shot"
L["autostat.recoilrandomside"] = "Horizontaler Rückstoß-Streuung"
L["autostat.recoilrandomup"] = "Vertikaler Rückstoß-Streuung"
L["autostat.recoilresettime"] = "Rückstoß-Resetzeit"
L["autostat.recoilside"] = "Horizontaler Rückstoß"
L["autostat.recoilup"] = "Vertikaler Rückstoß"
L["autostat.reloadtime"] = "Nachlade-Zeit"
L["autostat.ricochetanglemax"] = "Abprallwinkel"
L["autostat.ricochetchance"] = "Abprallwahrscheinlichkeit"
L["autostat.rpm"] = "Feuerrate"
L["autostat.runawayburst"] = "Runaway-Burst"
L["autostat.secondarysupplylimit"] = "Reserve-Sekundärmunition"
L["autostat.shootvolume"] = "Report-Volumen"
L["autostat.shootwhilesprint"] = "Schießen während Sprint"
L["autostat.shotgunreload"] = "Individuelles Nachladen"
L["autostat.speed"] = "Bewegungsgeschwindigkeit"
L["autostat.spread"] = "Streuung"
L["autostat.sprinttofiretime"] = "Sprint-bis-Feuer-Zeit"
L["autostat.stomachdamage"] = "Bauchschaden"
L["autostat.supplylimit"] = "Reserve-Magazine"
L["autostat.sway"] = "Schwanken"
L["autostat.triggerdelay"] = "Abzugsverzögerung"
-- L["autostat.triggerdelaytime"] = "Trigger Delay Time"
L["autostat.visualrecoil"] = "Visueller Rückstoß"
L["autostat.visualrecoilpunch"] = "Visueller Rückstoß-Schlag"
L["autostat.visualrecoilroll"] = "Visuelle Rückstoß-Drehung"
L["autostat.visualrecoilside"] = "Horizontaler Visueller Rückstoß"
L["autostat.visualrecoilup"] = "Vertikaler Visueller Rückstoß"

L["autostat.secondary._beforephrase"] = false
-- if true, secondary stat phrasing comes before the stat
L["autostat.secondary._divider"] = " "
-- space between the secondary phrase from the stat phrase. set true to use empty string

-- L["autostat.secondary.blindfire"] = "while Blind-Firing"
-- L["autostat.secondary.bipod"] = "on Bipod"
L["autostat.secondary.crouch"] = "während des Kriechen"
L["autostat.secondary.empty"] = "beim letzen Schuss im Magazin"
L["autostat.secondary.evenreload"] = "jeden geraden Reload"
L["autostat.secondary.evenshot"] = "jeden geraden Schuss"
L["autostat.secondary.first"] = "beim letzen Schuss"
L["autostat.secondary.firstshot"] = "beim ersten Schuss"
-- L["autostat.secondary.heated"] = "while Heated"
L["autostat.secondary.hipfire"] = "im Hüftfeuer"
-- L["autostat.secondary.hot"] = "from Heat"
L["autostat.secondary.last"] = "beim letzen Schuss im Magazin"
L["autostat.secondary.lastshot"] = "beim letzen Schuss im Magazin"
L["autostat.secondary.midair"] = "in der Luft"
L["autostat.secondary.move"] = "während Bewegung"
L["autostat.secondary.oddreload"] = "jeden ungeraden Reload"
L["autostat.secondary.oddshot"] = "jeden ungeraden Schuss"
L["autostat.secondary.recoil"] = "vom Rückstoß" --"With Each Shot"
L["autostat.secondary.shooting"] = "während des Schießens"
-- L["autostat.secondary.sighted"] = "while Sighted"
L["autostat.secondary.sights"] = "im Visier"
L["autostat.secondary.silenced"] = "wenn Schallgedämpft"
L["autostat.secondary.sprint"] = "während Sprint"
L["autostat.secondary.true"] = "wenn TrueNames an ist"
L["autostat.secondary.ubgl"] = "im UBGL"

////////////////////// Blacklist menu
-- L["blacklist.title"] = "ARC9 Attachment Blacklist"
-- L["blacklist.desc"] = "Attachments checked here will be blocked from use"
-- L["blacklist.blisted"] = "BLACKLISTED"
-- L["blacklist.all"] = "ALL"
-- L["blacklist.id"] = "ID"
-- L["blacklist.name"] = "NAME"
-- L["blacklist.filter"] = "FILTER"

////////////////////// Incompatible addons
L["incompatible.title"] = "ARC9: INKOMPATIBLE ADDONS"
L["incompatible.line1"] = "Wenn du Add-Ons hast, die mit ARC9 nicht funktionieren, dann"
L["incompatible.line2"] = "deaktiviere sie oder erwarte fehlerhaftes Verhalten!"
L["incompatible.confirm"] = "Bestätige"
L["incompatible.wait"] = "Warte {time}s"
L["incompatible.never"] = "Warne mich nicht erneut"
L["incompatible.never.hover"] = "Bist du dir absolut sicher, dass du die Auswirkungen verstehst?"
L["incompatible.never.confirm"] = "Du hast Inkompatibilitätswarnungen ausgeschaltet; Wenn etwas schiefläuft, ist das deine eigene Schuld."

////////////////////// Warning panel
-- L["badconf.title"] = "ARC9: BAD GMOD SETTINGS WARNING"
-- L["badconf.line1"] = "It appears some Garry's Mod settings are causing problems."
-- L["badconf.line2"] = "Listed below are problems which have been detected, and solutions to fix them."
-- L["badconf.confirm"] = "Acknowledge"
-- L["badconf.wait"] = "Wait {time}s"

-- L["badconf.directx.title"] = "Outdated DirectX version"
-- L["badconf.directx.desc"] = "You are currently running DirectX 8 or 8.1. Modern GMod isn't meant for this, you might not be able to see models on most weapon packs. (dx9 was introduced 21 years ago!)"
-- L["badconf.directx.solution"] = "Solution: Go to Garry's Mod's launch options and insert \"-dxlevel 95\" into the launch parameters. If \"-dxlevel 70/80/85\" is listed there, remove it."

-- L["badconf.tickrate.title"] = "Too low server tickrate"
-- L["badconf.tickrate.desc"] = "The server you are on is running on very low tickrate. ARC9 runs best if you run a minimum of 20 tickrate (66+ is recommended)."
-- L["badconf.tickrate.solution"] = "Solution: If you are a server owner, then insert \"-tickrate 33\", or whichever value you want, in the server launch configurations."

-- L["badconf.matbumpmap.title"] = "mat_bumpmap is disabled"
-- L["badconf.matbumpmap.desc"] = "You have bumpmaps disabled, which makes weapons look worse. It also breaks certain ARC9 optics."
-- L["badconf.matbumpmap.solution"] = "Solution: In the console, type \"mat_bumpmap 1\". If you are using an FPS config of any kind, then find and delete mat_bumpmap 0 line from \"autoexec.cfg\"."

-- L["badconf.addons.title"] = "Too many addons! Lua file limit exceeded!"
-- L["badconf.addons.desc"] = "You have installed way too many addons and have reached the Lua file limit. ARC9 has therefore not been able to initialize properly, meaning attachments might not work."
-- L["badconf.addons.solution"] = "Solution: Uninstall heavy addons through the in-game Addons menu, or through the Steam workshop (for example other weapon bases, JMod, Entity Packs, and so on)."

-- L["badconf.warning"] = "Warning! Your performance is not optimal! - Hover over to view details."
-- L["badconf.warning.desc"] = "More FPS is always good. Especially on weapon bases like this one.\n\nHover cursor over items below to see solution."

-- L["badconf.x64.title"] = "► Slow 32-Bit branch Detected"
-- L["badconf.x64.desc"] = [[You are currently running Garry's Mod in 32-bit. This restricts the amount of performance you can obtain drastically.

-- Solution: In Garry's Mod's launch options, go to "Betas" and change to "x86-64 - Chromium + 64-bit binaries".

-- Google "gmod x64" to find a tutorial online.]]

-- L["badconf.multicore.title"] = "► No Multicore Rendering commands"
-- L["badconf.multicore.desc"] = [[Certain multicore rendering settings are currently disabled. This results in worsened in-game performance.

-- Solution: You need to put certain commands into autoexec.cfg

-- Google "gmod multicore" to find a tutorial online.

-- All commands that can increase performance:
-- gmod_mcore_test 1
-- mat_queue_mode 2
-- cl_threaded_bone_setup 1
-- cl_threaded_client_leaf_system 1
-- r_threaded_client_shadow_manager 1
-- r_threaded_renderables 1]]

////////////////////// Presets
L["customize.presets.atts"] = " Aufsätze"
L["customize.presets.back"] = "Zurück"
L["customize.presets.cancel"] = "Abbrechen"
L["customize.presets.code"] = "Preset-Code (In der Zwischenablage)"
L["customize.presets.default"] = "Standard"
L["customize.presets.default.long"] = "Standard-Preset"
L["customize.presets.dumb"] = "Bist du dumm"
L["customize.presets.import"] = "Import"
L["customize.presets.invalid"] = "Ungültiger String!"
L["customize.presets.new"] = "Neuer Preset-Name"
L["customize.presets.paste"] = "Preset-Code hier einfügen"
L["customize.presets.random"] = "Zufall"
L["customize.presets.save"] = "Speichern"
L["customize.presets.unnamed"] = "Unbenannt"
-- L["customize.presets.deldef"] = "Are you sure you want to delete \"{name}\" default preset?"´
-- L["customize.presets.deldef2"] = "You would have to reset weapon in developer settings to return it."
L["customize.presets.yes"] = "Ja"

////////////////////// Tips
-- L["tips.arc-9"] = "It's ARC9, not ARC-9, not Arc9."
-- L["tips.blacklist"] = "You can blacklist attachments! See the ARC9 Workshop description for more information."
-- L["tips.bugs"] = "Report bugs on the official Discord server, or better yet, open a Github issue."
-- L["tips.custombinds"] = "ARC9 key combos can be replaced with custom binds. Start typing +arc9_ to find the available binds!"
-- L["tips.cyberdemon"] = "To kill the terrorist, shoot him until he is dead."
-- L["tips.description"] = "We advise you to read the descriptions of addons before commenting."
-- L["tips.development"] = "Keen to develop ARC9 content? The official Discord server has plenty of resources to help!"
-- L["tips.discord"] = "Join Diamond Doves on Discord! The link is in the ARC9 description and in top of settings."
-- L["tips.external"] = "If using the Github version of ARC9, make sure to update frequently!"
-- L["tips.hints"] = "Keep ARC9's HUD on to see control hints."
-- L["tips.lean"] = "To manually lean, bind keys to +alt1 and +alt2."
-- L["tips.love"] = "Feel free to tell the devs you appreciate their work! It really helps us keep going."
-- L["tips.m9k"] = "Check out M9K guns!."
-- L["tips.official"] = "Only download ARC9 from official sources. Third party uploads may be malicious or outdated!"
-- L["tips.presets"] = "Share your favorite presets with your friends by exporting them!"
-- L["tips.settings"] = "You can turn these tips off, and much more, in the ARC9 settings. Click the button in the top left corner!"
-- L["tips.tacrp"] = "Have you tried Tactical RP base yet?"
-- L["tips.tips"] = "Tips have a fixed order. Keep reading and you'll eventually see them all."
-- L["tips.tolerance"] = "All weapon bases work fine together. There's no need for favoritism."

////////////////////// Other
L["atts.favourites"] = "Favoriten"
L["atts.filter"] = "Filter"

/////////////////////////////////////// Settings menu
-- Use this method to localize convars in settings menu:
-- settings.convar.title = "Convar Title"
-- settings.convar.desc = "Convar Description"

L["settings.title"] = "ARC9 Einstellungen"
L["settings.desc"] = "Beschreibung"

-- L["settings.default_convar"] = "Default value"
-- L["settings.convar_server"] = "Server variable"
-- L["settings.convar_client"] = "Client variable"

////////////////////// General
-- L["settings.tabname.general"] = "General"

-- L["settings.general.client"] = "Client"
L["settings.language_id.title"] = "Sprache"
L["settings.language_id.desc"] = "Sprachpaket für ARC9."
-- L["settings.truenames.title"] = "True Names"
-- L["settings.truenames.desc"] = "Set whether to use weapons' real names or fictional names made by the developers. Not all weapons utilize this."
-- L["settings.resetsettings.cl.title"] = "Reset all CLIENT settings"

-- L["settings.general.server"] = "Server"
-- L["settings.truenames_default.title"] = "Default True Names"
-- L["settings.truenames_default.desc"] = "Set the default true names mode on the server. All players using \"Default\" in preference will use this."
-- L["settings.truenames_enforced.title"] = "Default True Names Enforced"
-- L["settings.truenames_enforced.desc"] = "Set to force all players to use the server setting for true names."

-- L["settings.resetsettings.sv.title"] = "Reset all SERVER settings"

-- L["settings.reset"] = "Reset!"

////////////////////// Performance
L["settings.tabname.performance"] = "Leistung"

L["settings.performance.important"] = "Wichtig"
L["settings.cheapscopes.title"] = "Billige Visiere"
L["settings.cheapscopes.desc"] = "Eine billige Visier-Implementation die deine gesamte Sicht reinzoomt, anstatt die Welt im Visier erneut zu rendern. Verbessert Leistung sehr stark auf großen Maps."
L["settings.tpik.title"] = "TPIK"
L["settings.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) ist ein System, mit dem Waffen die gleichen Nachlade- und Feueranimationen in 3.Person und 1.Person haben können.\n\nKonfiguriere es im Visuals-Reiter."
L["settings.allflash.title"] = "Alle Taschenlampen"
L["settings.allflash.desc"] = "Rendere alle Taschenlampen von anderen Spielern\n\nSehr leistungsintensiv auf Servern."

L["settings.performance.blur.title"] = "Verschwemmen"
L["settings.cust_blur.title"] = "Anpassungs-Hintergrund"
L["settings.cust_blur.desc"] = "Verschwemmt den Anpassungs-Hintergrund."
L["settings.fx_reloadblur.title"] = "Beim Nachladen"
L["settings.fx_reloadblur.desc"] = "Verschwemmt die Welt beim Nachladen."
L["settings.fx_animblur.title"] = "Beim Zücken"
L["settings.fx_animblur.desc"] = "Verschwemmt die Welt beim ersten Einsatz einer Waffe."
L["settings.fx_rtblur.title"] = "In Visieren"
L["settings.fx_rtblur.desc"] = "Verschwemmt die Welt beim Einsatz eines Zielvisiers."
L["settings.fx_adsblur.title"] = "In Zielvorrichtung"
L["settings.fx_adsblur.desc"] = "Verschwemmt die Welt beim Zielen."
-- L["settings.fx_rtvm.title"] = "Render Weapon through RT Scopes"
-- L["settings.fx_rtvm.desc"] = "! EXPERIMENTAL !\nRenders the weapon and its attachments through RT scopes. Requires \"Cheap Scopes\" to be disabled.\nSignificantly reduces performance."

L["settings.performance.shelleject.title"] = "Hülsenauswurf"
L["settings.eject_fx.title"] = "Raucheffekte"
L["settings.eject_fx.desc"] = "Erzeuge Raucheffekte aus ausgeworfenen Patronenhülsen, sofern die Waffe diese Funktion unterstützt."
L["settings.eject_time.title"] = "Mehr Lebenszeit"
L["settings.eject_time.desc"] = "Lass Patronenhülsen länger in der Welt bleiben. Kann Leistungsintensiv werden."

L["settings.performance.fx.title"] = "Effekte"
L["settings.muzzle_light.title"] = "Mündungs-Leuchten"
L["settings.muzzle_light.desc"] = "Aktiviere das Aufleuchten des Mündungsfeuers beim Feuern einer Waffe."
L["settings.muzzle_others.title"] = "Andere Mündungs-Einstellungen"
L["settings.muzzle_others.desc"] = "Aktiviere Mündungs-Effekte für Waffen von anderen Spielern."

////////////////////// Optics
L["settings.tabname.optics"] = "Optiken"

L["settings.optics.control"] = "Steuerung"
-- L["settings.optics.sensmult.title"] = "Multiply ADS Sensitivity"
-- L["settings.optics.sensmult.desc"] = "Multiply the look sensitivity by this amount when aiming.\nThe lower the value, the lower the sensitivity.\nUseful when using controllers, or if the user just wants lower aiming sensitivity."
L["settings.optics.compensate_sens.title"] = "Kompensierungs-Sensitivität"
L["settings.optics.compensate_sens.desc"] = "Kompensierungs-Sensitivität für Vergrößerung."
L["settings.optics.toggleads.title"] = "Zielvorr. umschalten"
L["settings.optics.toggleads.desc"] = "Zielen wird die Visierung umschalten."

-- L["settings.optics.dtap_sights.title"] = "Double-Tap to Switch Sights"
-- L["settings.optics.dtap_sights.desc"] = "Allows double-tapping the USE key to switch sights."

L["settings.optics.color"] = "Farbe"
L["settings.optics.reflex.title"] = "Reflexvisiere"
L["settings.optics.reflex.desc"] = "Farbe für Reflex- oder Holovisiere.\n\nNicht all Visiere unterstützen dieses Feature."
L["settings.optics.scope.title"] = "Visiere"
L["settings.optics.scope.desc"] = "Farbe für Visiere.\n\nNicht all Visiere unterstützen dieses Feature."

////////////////////// Crosshair
L["settings.tabname.crosshair"] = "Fadenkreuz"

L["settings.crosshair.crosshair"] = "Fadenkreuz"
L["settings.crosshair.cross_enable.title"] = "Aktiviere Fadenkreuz"
L["settings.crosshair.cross_enable.desc"] = "Aktiviere Fadenkreuz. Manche Waffen erlauben es nicht, das Fadenkreuz zu aktivieren."
L["settings.crosshair.cross.title"] = "Fadenkreuz-Farbe"
L["settings.crosshair.cross.desc"] = "Die Farbe deines Fadenkreuzes."
L["settings.crosshair.cross_size_mult.title"] = "Fadenkreuz-Größe"
L["settings.crosshair.cross_size_mult.desc"] = "Multiply the size of your crosshair."
L["settings.crosshair.cross_size_dot.title"] = "Punkt-Größe"
L["settings.crosshair.cross_size_dot.desc"] = "Multipliziere die Größe des mittleren Punktes."
L["settings.crosshair.cross_size_prong.title"] = "Zacken-Größe"
L["settings.crosshair.cross_size_prong.desc"] = "Multipliziere die Größe der äußeren Zacken."
L["settings.crosshair.crosshair_static.title"] = "Festes Fadenkreuz"
L["settings.crosshair.crosshair_static.desc"] = "Aktiviert ein festes Fadenkreuz, welches sich nicht beim Feuern bewegt."
L["settings.crosshair.crosshair_force.title"] = "Fadenkreuz erzwingen"
L["settings.crosshair.crosshair_force.desc"] = "Erzwinge das Fadenkreuz auch bei Waffen, die nicht möchten, dass du es siehst.\n\nServereinstellung."
-- L["settings.crosshair.crosshair_target.title"] = "Red Crosshair on Target"
-- L["settings.crosshair.crosshair_target.desc"] = "Make the crosshair red when aiming on a target.\nAlso activates aim assist if it is turned on."
-- L["settings.crosshair.crosshair_peeking.title"] = "Display Crosshair when Peeking"
-- L["settings.crosshair.crosshair_peeking.desc"] = "Displays the crosshair when aiming and using the peek function."

////////////////////// Customization
L["settings.tabname.hud_cust"] = "Anpassung"

L["settings.hud_cust.hud"] = "HUD"
L["settings.hud_cust.hud_scale.title"] = "UI-Skalierung"
L["settings.hud_cust.hud_scale.desc"] = "Skalierungsmultiplikator für die Oberfläche von ARC9."
-- L["settings.hud_cust.hud_deadzonex.title"] = "HUD Width Deadzone"
-- L["settings.hud_cust.hud_deadzonex.desc"] = "Horizontal \"deadzone\" for customization menu and HUD panel.\nUseful for ultrawide monitors."
L["settings.hud_cust.hud_color.title"] = "UI-Farbe"
L["settings.hud_cust.hud_color.desc"] = "Hervorhebungsfarbe für das HUD.\nDie Akzentfarbe."
-- L["settings.hud_cust.hud_holiday.title"] = "Holiday Themes"
-- L["settings.hud_cust.hud_holiday.desc"] = "Themes that activate during certain holidays.\nWill override highlight color"
-- L["settings.hud_cust.hud_darkmode.title"] = "Dark Theme"
-- L["settings.hud_cust.hud_darkmode.desc"] = "Enables dark colors in HUD instead of light gray and disables vignette effect in background."
L["settings.hud_cust.cust_light.title"] = "Licht akt."
L["settings.hud_cust.cust_light.desc"] = "Aktiviert die Waffenbeleuchtung im Anpassungsmenü.\n\nDasselbe wie der Knopf neben dem Einstellungs-Button."
L["settings.hud_cust.cust_light_brightness.title"] = "Helligkeit"
L["settings.hud_cust.cust_light_brightness.desc"] = "Wie hell das Licht im Anpassungsfeld sein wird.\n\nVergiss aber nicht, es zuerst einzuschalten!"

L["settings.hud_cust.customization"] = "Anpassung"
L["settings.hud_cust.cust_hints.title"] = "Hinweise"
L["settings.hud_cust.cust_hints.desc"] = "Aktiviere Hinweise im Anpassungsmenü."
-- L["settings.hud_cust.cust_tips.title"] = "Tips"
-- L["settings.hud_cust.cust_tips.desc"] = "Tips about ARC9 base near hints."
L["settings.hud_cust.cust_exit_reset_sel.title"] = "Verlassen setzt Auswahl zurück"
L["settings.hud_cust.cust_exit_reset_sel.desc"] = "Das Verlassen des Anpassungsmenüs setzt die Auswahl des aktiven Slots zurück."
-- L["settings.hud_cust.imperial.title"] = "Imperial Measurement"
-- L["settings.hud_cust.imperial.desc"] = "Replaces various measurement systems to their Imperial variants.\nOnly affects the \"Stats & Ballistics\" customization screen."

////////////////////// Game HUD
L["settings.tabname.hud_game"] = "Spieloberfläche"

L["settings.hud_game.lcd"] = "LCD-Panel"
L["settings.hud_game.hud_arc9.title"] = "HUD aktivieren"
L["settings.hud_game.hud_arc9.desc"] = "HUD für ARC9-Waffen aktivieren."
L["settings.hud_game.hud_always.title"] = "Auf allen Waffen"
L["settings.hud_game.hud_always.desc"] = "Aktiviere das HUD bei allen Waffen."
L["settings.hud_game.hud_compact.title"] = "Kompaktmodus"
L["settings.hud_game.hud_compact.desc"] = "Kompaktes Erscheinungsbild für das HUD-Panel."
-- L["settings.hud_game.hud_nohints.title"] = "Disable Hints"
-- L["settings.hud_game.hud_nohints.desc"] = "Disable hints completely. They will not show up in the 3D HUD, nor in the 2D HUD."
L["settings.hud_game.hud_keephints.title"] = "Hinweise behalten"
L["settings.hud_game.hud_keephints.desc"] = "Zeige die ARC9-Steuerungshinweise oben auf dem HUD-Panel."
-- L["settings.hud_game.hud_force_disable.title"] = "Force Disable HUD"
-- L["settings.hud_game.hud_force_disable.desc"] = "Disable ARC9 HUD for all players. Does not affect hints."

L["settings.hud_game.killfeed"] = "Killfeed"
L["settings.hud_game.killfeed_enable.title"] = "Killfeed-Symbole"
L["settings.hud_game.killfeed_enable.desc"] = "Automatische Generierung von Killfeed-Symbolen für ARC9-Waffen aktivieren."
L["settings.hud_game.killfeed_dynamic.title"] = "Dynamische Aktualisierung"
L["settings.hud_game.killfeed_dynamic.desc"] = "Killfeed-Symbole werden nach jedem Kill neu generiert.\n\nDeaktiviere dies, wenn du 0,1 FPS mehr haben willst."
-- L["settings.hud_game.killfeed_colour.title"] = "Full Color Icons"
-- L["settings.hud_game.killfeed_colour.desc"] = "Dynamically generated icons are fully colored."

L["settings.hud_game.breath"] = "Atmen"
L["settings.hud_game.breath_hud.title"] = "Atem-HUD"
L["settings.hud_game.breath_hud.desc"] = "Zeige einen Balken, der dir verbleibenden Atem anzeigt, während du deine Waffe im Visier stabilisierst."
L["settings.hud_game.breath_pp.title"] = "Atem-Post-Process"
L["settings.hud_game.breath_pp.desc"] = "Beim Anhalten vom Atem werden Post-Processing-Effekte abgespielt."
L["settings.hud_game.breath_sfx.title"] = "Atem-Effekte"
L["settings.hud_game.breath_sfx.desc"] = "Wenn du den Atem anhälst, werden die zugehörigen Soundeffekte abgespielt."

-- L["settings.hud_game.centerhint"] = "Tooltips"
-- L["settings.hud_game.centerhint_reload.title"] = "Display Reload Tip"
-- L["settings.hud_game.centerhint_reload.desc"] = "Display a reload tip when low on ammunition."
-- L["settings.hud_game.centerhint_reload_percent.title"] = "Magazine Percentage"
-- L["settings.hud_game.centerhint_reload_percent.desc"] = "Display the reload tip when the current magazine is at this percentage value."
-- L["settings.hud_game.centerhint_bipod.title"] = "Display Toggle Bipod"
-- L["settings.hud_game.centerhint_bipod.desc"] = "Display a tip when the bipod can be toggled."
-- L["settings.hud_game.centerhint_jammed.title"] = "Display Jammed Tip"
-- L["settings.hud_game.centerhint_jammed.desc"] = "Display a tip when your weapon is jammed."

-- L["settings.hud_game.centerhint_firemode.title"] = "Display Firemode Tip"
-- L["settings.hud_game.centerhint_firemode.desc"] = "Display a tip when you swap firing mode or toggle your safety."
-- L["settings.hud_game.centerhint_firemode_time.title"] = "Display Firemode Time"
-- L["settings.hud_game.centerhint_firemode_time.desc"] = "How long the firing mode should be displayed."

-- L["settings.hud_game.centerhint_overheat.title"] = "Display Overheat Tip"
-- L["settings.hud_game.centerhint_overheat.desc"] = "Displays an overlayed tip showing how close the weapon is to overheating.\n\nNot displayed if ARC9 HUD is enabled or the weapon does not support overheat."

-- L["settings.hud_game.hud_glyph"] = "Glyph Type"

-- L["settings.hud_game.hud_glyph_type_hud.title"] = "HUD"
-- L["settings.hud_game.hud_glyph_type_hud.desc"] = "Change which family of glyphs to use.\nThis affects the HUD tips."

-- L["settings.hud_game.hud_glyph_type_cust.title"] = "Customization Menu"
-- L["settings.hud_game.hud_glyph_type_cust.desc"] = "Change which family of glyphs to use.\nThis affects the customization menu tips.\nChanges apply next time the customization menu is opened."

-- L["settings.hud_game.hud_glyph_light"] = "Light"
-- L["settings.hud_game.hud_glyph_dark"] = "Dark"
-- L["settings.hud_game.hud_glyph_knockout"] = "Knockout"

////////////////////// NPCs
L["settings.tabname.npc"] = "NPCs"

L["settings.npc.weapons"] = "NPC-Waffen"
L["settings.npc.npc_equality.title"] = "Schadensgleichheit"
L["settings.npc.npc_equality.desc"] = "NPCs richten genauso viel Schaden an wie Spieler.\n\nDies ist eine Server-Variable."
L["settings.npc.npc_spread.title"] = "NPC-Streuung"
L["settings.npc.npc_spread.desc"] = "Multiplikator für wie ungenau NPCs beim Feuern sein sollen."
L["settings.npc.npc_atts.title"] = "Anhänge geben"
L["settings.npc.npc_atts.desc"] = "Gespawnte oder gegebene ARC9-Waffen erhalten einen zufälligen Satz von Anhängen.\n\nDies ist eine Server-Variable."
L["settings.npc.npc_autoreplace.title"] = "NPC-Waffen ersetzen"
L["settings.npc.npc_autoreplace.desc"] = "NPC-Waffen werden durch zufällig ausgewählte ARC9-Waffen ersetzt.\n\nDies ist eine Server-Variable."
L["settings.npc.replace_spawned.title"] = "Bodenwaffen ersetzen"
L["settings.npc.replace_spawned.desc"] = "Map- oder manuell gespawnte HL2-Waffen werden durch zufällig ausgewählte ARC9-Waffen ersetzt.\n\nDies ist eine Server-Variable."
L["settings.npc.npc_give_weapons.title"] = "Spieler können Waffen geben"
L["settings.npc.npc_give_weapons.desc"] = "Spieler können bei NPCs E drücken, um ihnen ihre Waffe zu geben.\n\nDies ist eine Server-Variable."

////////////////////// Gameplay
L["settings.tabname.gameplay"] = "Gameplay"

L["settings.gameplay.controls"] = "Steuerung"
L["settings.gameplay.toggleads.title"] = "ADS umschalten"
L["settings.gameplay.toggleads.desc"] = "Durch das Zielen wird das Visier umgeschaltet."
L["settings.gameplay.autolean.title"] = "Automatisches Lehnen"
L["settings.gameplay.autolean.desc"] = "Beim Zielen wird versuchen, sich automatisch zu lehnen, wenn dies möglich ist."
L["settings.gameplay.autoreload.title"] = "Automatisches Nachladen"
L["settings.gameplay.autoreload.desc"] = "Leere ARC9-Waffen werden automatisch nachgeladen."
L["settings.gameplay.togglelean.title"] = "Lehnen umschalten"
L["settings.gameplay.togglelean.desc"] = "Das Drücken der Lehnen-Tasten schaltet die Lehn-Richtung um, anstatt gedrückt gehalten werden zu müssen.\n\nFunktioniert nicht perfekt zusammen mit Auto-Lehnen. Du solltest Auto-Lehnen deaktivieren, solange du \"Lehnen umschalten\" benutzt."
L["settings.gameplay.togglepeek.title"] = "Spähen umschalten"
L["settings.gameplay.togglepeek.desc"] = "Das Drücken der Spähen-Taste schaltet das Spähen um, anstatt gedrückt gehalten werden zu müssen."
-- L["settings.gameplay.togglepeek_reset.title"] = "Reset Peek State After Aiming"
-- L["settings.gameplay.togglepeek_reset.desc"] = "(Only if Toggle Peek is on)\nPeek state will not be retained when exiting aim down sights."
-- L["settings.gameplay.togglebreath.title"] = "Toggle Holding Breath"
-- L["settings.gameplay.togglebreath.desc"] = "Pressing the Holding Breath key will toggle Holding Breath instead of needing to be held down."

L["settings.gameplay.mechanics"] = "Spielemechaniken"
L["settings.gameplay.infinite_ammo.title"] = "Unbegrenzte Munition"
L["settings.gameplay.infinite_ammo.desc"] = "Waffen haben unendlich Munition.\n\nDies ist eine Server-Variable."
L["settings.gameplay.realrecoil.title"] = "Physischer visueller Rückstoß"
L["settings.gameplay.realrecoil.desc"] = "Ausgewählte Waffen, die für diese Funktion eingerichtet wurden, erfahren einen physischen Mündungsanstieg, was bedeutet,\ndass sie dorthin feuern, wo das Viewmodel hin zeigt, und nicht in die Mitte des Bildschirms. Sehr wichtig für das Balancing einiger Waffenpakete.\n\nDies ist eine Server-Variable."
L["settings.gameplay.lean.title"] = "Lehnen"
L["settings.gameplay.lean.desc"] = "Ob Spieler mit +alt1 und +alt2 lehnen können, inklusive automatischem Lehnen.\n\nDies ist eine Server-Variable."
L["settings.gameplay.mod_sway.title"] = "Schwanken"
L["settings.gameplay.mod_sway.desc"] = "Waffen schwanken, wenn sie dafür eingerichtet sind.\n\nDies ist eine Server-Variable."
L["settings.gameplay.mod_freeaim.title"] = "Freies Zielen"
L["settings.gameplay.mod_freeaim.desc"] = "Waffen können frei zielen und schießen nicht immer in die Mitte des Bildschirms.\n\nDies ist eine Server-Variable."
L["settings.gameplay.mod_bodydamagecancel.title"] = "Körperschaden ignorieren"
L["settings.gameplay.mod_bodydamagecancel.desc"] = "ARC9-Körperschadensmultiplikator ignorieren. Nur deaktivieren, wenn ein anderer Mod verwendet wird, der diese Art von Funktionalität bietet.\nz.B. Mods, die die Standard-Gliedmaßen-Multiplikatoren ändern.\n\nDies ist eine Server-Variable."
L["settings.gameplay.breath_slowmo.title"] = "Slow-Mo-Atem"
L["settings.gameplay.breath_slowmo.desc"] = "Atem anhalten verlangsamt die Zeit.\n\nNur Einzelspieler."
L["settings.gameplay.manualbolt.title"] = "Manuelles Repetieren"
L["settings.gameplay.manualbolt.desc"] = "Repetierwaffen, die für diese Funktion konfiguriert sind, schießen nur, wenn R gedrückt wird, und nicht, wenn die Angriffstaste losgelassen wird."
L["settings.gameplay.never_ready.title"] = "Keine \"Ready\"-Animationen."
L["settings.gameplay.never_ready.desc"] = "Deaktiviere \"Ready\"-Animationen beim zücken einer Waffe."
-- L["settings.gameplay.recoilshake.title"] = "Recoil FOV Shake"
-- L["settings.gameplay.recoilshake.desc"] = "Snaps field of view when shooting"
-- L["settings.gameplay.equipment_generate_ammo.title"] = "Unique Ammo Types for Equipment"
-- L["settings.gameplay.equipment_generate_ammo.desc"] = "There is a limit of 255 ammo types, and disabling this option may help fix some problems if you have lots of addons.\n\nThis is a server variable.\n\nRequires restart."

-- ??
-- L["settings.gameplay.mult_defaultammo.title"] = "Default Reserve Ammo"
-- L["settings.gameplay.mult_defaultammo.desc"] = "How many magazines/grenades/equipment give to player when he takes weapon for first time?\n\nThis is a server variable."
L["settings.gameplay.nearwall.title"] = "Wandnähe"
L["settings.gameplay.nearwall.desc"] = "Schießen verbieten, wenn du zu nahe an einer Wand oder einem Hindernis stehst."

////////////////////// Visuals
L["settings.tabname.visuals"] = "Visuals"

L["settings.visuals.viewmodel"] = "Viewmodel"
L["settings.visuals.vm_bobstyle.title"] = "Bob-Stil"
L["settings.visuals.vm_bobstyle.desc"] = "Wähle zwischen verschiedenen Bob-Stilen aus, je nach Geschmack verschiedener Mitglieder des ARC9-Teams (und Valve)."
L["settings.visuals.fov.title"] = "FOV"
L["settings.visuals.fov.desc"] = "Viewmodel-FOV verändern. Vergrößert oder verkleinert das Viewmodel. Verwende diese Einstellung verantwortungsbewusst!"
L["settings.visuals.vm_addx.title"] = "X hinzufügen"
L["settings.visuals.vm_addx.desc"] = "Verschiebe das Viewmodel nach rechts oder links."
L["settings.visuals.vm_addy.title"] = "Y hinzufügen"
L["settings.visuals.vm_addy.desc"] = "Verschiebe das Viewmodel vorwärts und rückwärts."
L["settings.visuals.vm_addz.title"] = "Z hinzufügen"
L["settings.visuals.vm_addz.desc"] = "Verschiebe das Viewmodel nach oben und unten."

-- L["settings.visuals.cambob"] = "View Bobbing"
-- L["settings.visuals.vm_cambob.title"] = "Sprint View Bobbing"
-- L["settings.visuals.vm_cambob.desc"] = "Makes your camera move when you sprinting"
-- L["settings.visuals.vm_cambobwalk.title"] = "Walk View Bobbing"
-- L["settings.visuals.vm_cambobwalk.desc"] = "Makes your camera slightly move when you walking around (requires sprint bobbing)"
-- L["settings.visuals.vm_cambobintensity.title"] = "Intensity"
-- L["settings.visuals.vm_cambobintensity.desc"] = "How intense bobbing will be"

L["settings.visuals.tpik"] = "TPIK"
L["settings.visuals.tpik.title"] = "TPIK aktivieren"
L["settings.visuals.tpik.desc"] = "TPIK (Third Person Inverse Kinematics) ist ein System, das es den meisten Waffen ermöglicht, Nachlade- und Feueranimationen aus der Ego-Perspektive in der Third-Person-Perspektive zu zeigen."
L["settings.visuals.tpik_others.title"] = "TPIK für andere Spieler"
L["settings.visuals.tpik_others.desc"] = "TPIK für andere Spieler als dich selbst anzeigen. Beeinflusst die Leistung negativ."
L["settings.visuals.tpik_framerate.title"] = "TPIK-Framerate"
L["settings.visuals.tpik_framerate.desc"] = "Maximale Framerate, mit der TPIK ausgeführt werden kann. Für unbegrenzt auf 0 setzen."

////////////////////// Bullet Physics
L["settings.tabname.bullets"] = "Projektil-Physik"

L["settings.bullets.bullets"] = "Projektilphysik"
L["settings.bullets.bullet_physics.title"] = "Projektile"
L["settings.bullets.bullet_physics.desc"] = "Waffen, die diese Funktion unterstützen, feuern physische Kugeln ab, die Fall, Dauer und Widerstand haben.\n\nDies ist eine Server-Variable."
L["settings.bullets.bullet_gravity.title"] = "Schwerkraft"
L["settings.bullets.bullet_gravity.desc"] = "Multiplikator für die Schwerkraft des Projektil.\n\nDies ist eine Server-Variable."
L["settings.bullets.bullet_drag.title"] = "Widerstand"
L["settings.bullets.bullet_drag.desc"] = "Multiplikator für Projektilwiderstand.\n\nDies ist eine Server-Variable."
L["settings.bullets.ricochet.title"] = "Abprall"
L["settings.bullets.ricochet.desc"] = "Kugeln, die von ausgewählten Waffen abgefeuert werden, können manchmal von Oberflächen abprallen und weiterfliegen und Schaden anrichten.\n\nDies ist eine Server-Variable."
L["settings.bullets.mod_penetration.title"] = "Penetration"
L["settings.bullets.mod_penetration.desc"] = "Von ausgewählten Waffen abgefeuerte Kugeln können Oberflächen durchdringen und allem, was sich auf der anderen Seite befindet, Schaden zufügen.\n\nDies ist eine Server-Variable."
L["settings.bullets.bullet_lifetime.title"] = "Lebensdauer"
L["settings.bullets.bullet_lifetime.desc"] = "Zeit in Sekunden, nach der ein Projektil gelöscht wird.\n\nDies ist eine Server-Variable."
L["settings.bullets.bullet_imaginary.title"] = "Imaginäre Projektile"
L["settings.bullets.bullet_imaginary.desc"] = "Kugeln scheinen in die Skybox zu wandern, jenseits der Grenzen der Map."

////////////////////// Attachments
L["settings.tabname.attachments"] = "Aufsätze"

L["settings.attachments.customization"] = "Anpassung"
L["settings.attachments.atts_nocustomize.title"] = "Keine Anpassung"
L["settings.attachments.atts_nocustomize.desc"] = "Alle Anpassungen über das Anpassungsmenü verbieten.\n\nDies ist eine Server-Variable."
L["settings.attachments.atts_max.title"] = "Maximale Aufsätze"
L["settings.attachments.atts_max.desc"] = "Die maximale Anzahl an Aufsätzen, die an einer Waffe angebracht werden können, einschließlich kosmetischer Aufsätze.\n\nDies ist eine Server-Variable."
L["settings.attachments.autosave.title"] = "Auto-Speichern"
L["settings.attachments.autosave.desc"] = "Deine letzten Waffenanpassungsoptionen werden gespeichert und automatisch angewendet, wenn du diese Waffe das nächste Mal spawnst."
-- L["settings.attachments.blacklist.title"] = "Blacklist Menu"
-- L["settings.attachments.blacklist.open"] = "Open"

L["settings.attachments.inventory"] = "Inventar"
L["settings.attachments.free_atts.title"] = "Freie Auswahl"
L["settings.attachments.free_atts.desc"] = "Aufsätze können verwendet werden, ohne vorher aufgehoben zu werden.\n\nDies ist eine Server-Variable."
L["settings.attachments.atts_lock.title"] = "Einer für Alle"
L["settings.attachments.atts_lock.desc"] = "Wenn du eine Instanz eines Aufsatzes aufhebst, kannst du diesen unendlich oft für alle Ihre Waffen verwenden.\n\nDies ist eine Server-Variable."
L["settings.attachments.atts_loseondie.title"] = "Beim Tod verlieren"
L["settings.attachments.atts_loseondie.desc"] = "Dein Aufsatz-Inventar geht verloren, wenn du stirbst.\n\nDies ist eine Server-Variable."
L["settings.attachments.atts_generateentities.title"] = "Entities generieren"
L["settings.attachments.atts_generateentities.desc"] = "Generiere Entities, mit denen du Aufsätze abrufen kannst, wenn Freie Auswahl deaktiviert ist.\n\nKönnte die Ladezeit erhöhen.\n\nDies ist eine Server-Variable."

////////////////////// Modifiers
L["settings.tabname.modifiers"] = "Modifiers"

L["settings.modifiers.quick.title"] = "Schnell-Stats-Modifier"
L["settings.modifiers.quick.desc"] = " "

L["settings.mod_damage.title"] = "Schaden"
L["settings.mod_spread.title"] = "Streuung"
L["settings.mod_recoil.title"] = "Rückstoß"
L["settings.mod_visualrecoil.title"] = "Visueller Rückstoß"
L["settings.mod_adstime.title"] = "Zielvorrichtungs-Zeit"
L["settings.mod_sprinttime.title"] = "Sprint-bis-Feuer-Zeit"
L["settings.mod_damagerand.title"] = "Schadens-Spanne"
L["settings.mod_muzzlevelocity.title"] = "Mündungsgeschwindigkeit"
L["settings.mod_rpm.title"] = "Feuerrate"
L["settings.mod_headshotdamage.title"] = "Kopfschuss-Schaden"
-- L["settings.mod_malfunction.title"] = "Malfunction Chance"

////////////////////// Controller
L["settings.tabname.controller"] = "Controller"

L["settings.controller.misc"] = "Gemischtes"
L["settings.controller.misc.desc"] = "Es sollte hier einen Knopf geben, der das erweiterte Controller-Konfigurationspanel öffnet, aber bis jetzt befindet es sich in  spawnmenu > Options > ARC9 > Controller."
L["settings.controller.controller.title"] = "Controller-Symbole"
L["settings.controller.controller.desc"] = "Aktiviere Controller-kompatible Symbole, und zeige anstatt von Tastatursymbolen Controllerknöpfe."
-- L["settings.controller.controller_rumble.title"] = "Rumble"
-- L["settings.controller.controller_rumble.desc"] = "Enable controller rumble as long as Fesiug's DLL mod is loaded.\n\ngithub.com/Fesiug/\ngmod-sinput"
L["settings.controller.controller_config.title"] = "Erweiterte Konfiguration"
L["settings.controller.controller_config.content"] = "Öffne Panel"
L["settings.controller.controller_config.desc"] = "Öffne das erweiterte Controller-Konfigurationspanel."

-- L["settings.controller.glyphs.title"] = "Glyph Type"
-- L["settings.controller.glyphs.desc"] = "Choose which family of glyphs you want to use.\nSet up glyphs in \"Spawnmenu\" > Options > ARC9 > Controller."

////////////////////// Aim Assist
-- L["settings.tabname.aimassist"] = "Aim Assist"
-- L["settings.tabname.aimassist.desc"] = "You can enable aim assistance if you might have trouble keeping your aim on your target, or if you just prefer to not put effort into shooting your targets."

-- L["settings.aimassist.enable.title"] = "Enable Aim Assist"
-- L["settings.aimassist.enable.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nThis is a server variable.\n\nRequires Aim Assist to be enabled on CLIENT."

-- L["settings.aimassist.enable_general.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nConfigure it in the \"Aim Assist\" tab."

-- L["settings.aimassist.enable_client.desc"] = "Enables an aim assistance feature that moves your aim towards a target when aiming near them.\n\nRequires Aim Assist to be enabled on SERVER."

-- L["settings.aimassist.intensity.title"] = "Intensity"
-- L["settings.aimassist.intensity.desc"] = "How intense the aim assist is.\n\nThis is a server variable."

-- L["settings.aimassist.cone.title"] = "Cone"
-- L["settings.aimassist.cone.desc"] = "How close or far away you need to look towards a target before the aim assist engages.\n\nThis is a server variable."

-- L["settings.aimassist.head.title"] = "Lock onto head"
-- L["settings.aimassist.head.desc"] = "If the aim assist should lock onto the target's head instead of its chest.\n\nThis is a server variable."

-- L["settings.aimassist.sensmult.desc"] = "Multiply the look sensitivity by this amount when hovering over a valid target.\nThe lower the value, the lower the sensitivity."

////////////////////// Asset Caching
-- L["settings.tabname.caching"] = "Asset Caching"
-- L["settings.caching.title"] = "Asset Caching"
-- L["settings.caching.desc"] = "You can cache some ARC9 assets (save in memory without loading while playing) to prevent stutters for comfort gameplay!\n\nYou surely should enable some stuff if your gmod running on HDD."

-- L["settings.caching.precache_sounds_onfirsttake.title"] = "On first equip: Cache gun sounds"
-- L["settings.caching.precache_sounds_onfirsttake.desc"] = "Caches all sounds only from gun you just took in hands (except reload sounds).\n\nNot any impactful, rather helpful to prevent stutters while firing."

-- L["settings.caching.precache_attsmodels_onfirsttake.title"] = "On first equip: Cache all attachments"
-- L["settings.caching.precache_attsmodels_onfirsttake.desc"] = "Caches all ARC9 attachments models when any ARC9 weapon was first equipped.\n\nCauses pretty big freeze, especially when you have lots of weapons."
-- L["settings.caching.precache_wepmodels_onfirsttake.title"] = "On first equip: Cache all weapon models"
-- L["settings.caching.precache_wepmodels_onfirsttake.desc"] = "Caches all ARC9 weapons viewmodels when any ARC9 weapon was first equipped.\n\nCauses REALLY BIG freeze, especially when you have lots of weapons."

-- L["settings.caching.precache_allsounds_onstartup.title"] = "On game start: Cache all guns sounds"
-- L["settings.caching.precache_allsounds_onstartup.desc"] = "Caches all sounds from all guns on server start-up. (except reload sounds).\n\nNot so impactful, but anyway you better use first option here."
-- L["settings.caching.precache_attsmodels_onstartup.title"] = "On game start: Cache all attachments"
-- L["settings.caching.precache_attsmodels_onstartup.desc"] = "Caches all ARC9 attachments models on server start-up.\n\nCauses pretty big load time increase, especially when you have lots of weapons."
-- L["settings.caching.precache_wepmodels_onstartup.title"] = "On game start: Cache all weapon models"
-- L["settings.caching.precache_wepmodels_onstartup.desc"] = "Caches all ARC9 weapons viewmodels on server start-up.\n\nCauses REALLY BIG load time increase, especially when you have lots of weapons."

-- L["settings.caching.precache_allsounds.title"] = "All weapon sounds"
-- L["settings.caching.precache_wepmodels.title"] = "All weapon models"
-- L["settings.caching.precache_attsmodels.title"] = "All attachments models"

-- L["settings.developer.cache"] = "Cache"

////////////////////// Developer
L["settings.tabname.developer"] = "Entwickler"

L["settings.developer.developer"] = "Entwickleroptionen"
L["settings.developer.dev_always_ready.title"] = "Immer bereit"
L["settings.developer.dev_always_ready.desc"] = "Spiele immer die \"ready\" Animation, wenn eine Waffe gezückt wird.\n\nDies ist eine Server-Variable."
L["settings.developer.dev_benchgun.title"] = "Benchgun"
L["settings.developer.dev_benchgun.desc"] = "Lasse die Waffe dort wo sie gerade ist."
-- L["settings.developer.dev_crosshair.title"] = "Dev Crosshair"
-- L["settings.developer.dev_crosshair.desc"] = "Funky looking crosshair showing the exact point of aim and some useful numbers.\n\nThis is a server variable, and only works for admins - don't get cheaty with this!"
-- L["settings.developer.dev_show_affectors.title"] = "Display Affectors"
-- L["settings.developer.dev_show_affectors.desc"] = "Displays which current affectors are currently applied.\n\nRequires \"Dev Crosshair\"."
L["settings.developer.dev_show_shield.title"] = "Schild zeigen"
L["settings.developer.dev_show_shield.desc"] = "Zeige das Modell vom Schild des Spielers."
L["settings.developer.dev_greenscreen.title"] = "Green-Screen"
L["settings.developer.dev_greenscreen.desc"] = "Zeigt einen Green-Screen-Hintergrund im Menü.\n\nFalls du HDR benutzt, vergiss nicht, mat_bloom_scalefactor_scalar auf 0 zu setzen!"
L["settings.developer.reloadatts.title"] = "Aufsätze neu laden"
L["settings.developer.reloadlangs.title"] = "Sprachen neu laden"
-- L["settings.developer.dev_listmyatts.title"] = "List My Attachments"
L["settings.developer.dev_listanims.title"] = "Animationen auflisten"
L["settings.developer.dev_listbones.title"] = "Knochen auflisten"
L["settings.developer.dev_listbgs.title"] = "Bodygroups auflisten"
L["settings.developer.dev_listatts.title"] = "QCAttach. auflisten"
L["settings.developer.dev_export.title"] = "Export-Code holen"
L["settings.developer.dev_getjson.title"] = "Weapon-JSON holen"

L["settings.developer.presets_clear.title"] = "Waffen-Daten löschen"
L["settings.developer.presets_clear.desc"] = "Lösche Voreinstellungen, alle Icons und Standardvoreinstellungen für Waffen, die du gerade hältst.\n\nWarnung: Wenn das Menü ohne eine ARC9-Waffe in den Händen geöffnet wird, werden alle vorhandenen ARC9-Voreinstellungen und -Icons gelöscht!"

L["settings.developer.clear"] = "Löschen"
L["settings.developer.print"] = "In die Konsole schreiben"
L["settings.developer.reload"] = "Neu laden"

////////////////////// ARC9 Premium
L["premium.title"] = "ARC9 Premium"
L["premium.desc"] = "ARC9 Premium ermöglicht zusätzliche Anpassungen als großes Dankeschön für die finanzielle Unterstützung des Addons."

L["premium.requires"] = "Erfordert <color=255,106,0>ARC9 Premium</color>."
L["premium.acquire"] = "Abonnieren Sie <color=255,106,0>ARC9 Premium</color>"

L["premium.ownedno"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Nicht vorhanden</color>"
L["premium.owned"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100>Besitzt</color>"

L["premium.help"] = "Was ist ARC9 Premium?"
L["premium.help.header"] = "Anleitung zu ARC9 Premium"
L["premium.help.desc"] = "Die Erstellung von Addons erfordert Zeit und Ressourcen. ARC9 war schon immer kostenlos, und das wird auch so bleiben. Wenn du jedoch die Basis finanziell unterstützen möchtest, kannst du das tun und wirst dafür belohnt!"

L["premium.help.ownedbutnoaccess"] = "Haben Sie vor kurzem ARC9 Premium gekauft, haben aber keinen automatischen Zugang dazu? Kontaktieren Sie uns auf dem Diamond Doves Discord Server für Hilfe.\nStellen Sie sicher, dass Sie einen Kaufnachweis erbringen können, bevor Sie uns kontaktieren. Einfach zu sagen „Ich kaufe, jetzt geben“ ist nicht gut genug."

L["premium.content"] = "Enthalten in <color=255,106,0>ARC9 Premium</color>:"
L["premium.content.list"] = [[
- Unbegrenzte Anpassungs-Slots (erhöht von 32)
- Unbegrenzte Voreinstellungs-Slots (erhöht von 10 pro Waffe)
- Zugang zu Supermodifier-Einstellungen*
- Zugang zu einem exklusiven dunklen UI-Modus
- Möglichkeit, optische Fadenkreuze, UI und mehr einzufärben
- Exklusive Tarnungen, die über die Basis verfügbar sind
- Exklusiver Support-Kanal auf Discord

*Erfordert einen Administrator, wenn auf einem Server
]]

L["premium.payment.month"] = [[
$%s
Erwerben Sie ARC9 Premium für 1 Monat.
]]

L["premium.payment.months"] = [[
$%s
Erwerben Sie ARC9 Premium für %s Monate und erhalten Sie einen <color=100,255,100>Rabatt von %s%%</color>!
]]

L["premium.payment.info"] = [[
Mit dem Erwerb von ARC9 Premium erhalten Sie sofortigen Zugriff auf alle oben aufgeführten Inhalte für die erworbene Zeit.
Die Zeit kann durch den erneuten Kauf einer der Optionen verlängert werden, und die Zeit wird automatisch aktualisiert, sobald die ursprüngliche Zeit abgelaufen ist.
Sobald die Zeit abgelaufen ist und keine weitere Zahlung erfolgt ist, wird der Zugang zu ARC9 Premium entfernt.

Alle mit ARC9 Premium erstellten Anpassungsoptionen, einschließlich der Aufsatzslots, Voreinstellungen und farbigen Absehen, bleiben verfügbar, aber Sie können sie nicht ändern oder zusätzliche hinzufügen.
]]

L["premium.purchased"] = "<color=255,106,0>ARC9 Premium</color> gekauft!"
L["premium.purchased.desc"] = [[
Vielen Dank, dass Sie ARC9 Premium gekauft haben! Sie haben dem Vogel eine große Freude gemacht!

Eine Quittung wird Ihnen an die von Ihnen angegebene E-Mail-Adresse gesendet.

Wenn Sie nicht sofort Zugang zu den ARC9 Premium-Boni erhalten haben, verbinden Sie sich bitte erneut mit dem Server oder starten Sie Ihr Spiel neu.

Wenn Sie immer noch Probleme damit haben, oder wenn Sie immer noch keinen Premium-Zugang erhalten haben, dann besuchen Sie den Diamond Doves Discord Server und geben Sie einen gültigen Kaufnachweis an, und wir werden das Problem für Sie lösen.
]]

--PATH lua/arc9/common/localization/content_base_sv-se.lua:
return gluapack()()
--PATH lua/arc9/common/sh_config.lua:
return gluapack()()
--PATH lua/arc9/shared/sh_ammo.lua:
-- arccw code lol
function ARC9:AddGrenadeAmmo()
    if GetConVar("arc9_equipment_generate_ammo"):GetBool() then
        for i, k in pairs(weapons.GetList()) do
            local class = k.ClassName
            local wpntbl = weapons.Get(class)
            if !wpntbl.ARC9 then continue end

            if (wpntbl.Throwing or wpntbl.Disposable) and !wpntbl.DoNotEquipmentAmmo then
                -- ammoid check will cause inconsistency between SV/CL on map change
                -- Initialize is only run once anyways, so it should be fine
                --local ammoid = game.GetAmmoID(class)
                --if ammoid == -1 then
                    -- if ammo type does not exist, build it
                    game.AddAmmoType({
                        name = class,
                    })
                    print("ARC9 adding ammo type " .. class)
                    if CLIENT then
                        language.Add(class .. "_ammo", wpntbl.PrintName)
                    end
                    ARC9.PhraseTable["en"]["ammo." .. class] = wpntbl.PrintName
                --end

                k.Ammo = class
                k.OldAmmo = class
            end
        end
    end
end

hook.Add("Initialize", "ARC9_AddGrenadeAmmo", ARC9.AddGrenadeAmmo)
--PATH lua/arc9/shared/sh_atts.lua:
return gluapack()()
--PATH lua/arc9/client/cl_move.lua:
local arc9_lean_direction = nil

local arc9_autoreload = GetConVar("arc9_autoreload")
local arc9_autolean = GetConVar("arc9_autolean")

ARC9.ReloadAmount = 0

hook.Add("CreateMove", "ARC9_CreateMove", function(cmd)
    local wpn = LocalPlayer():GetActiveWeapon()
    local ply = LocalPlayer()

    if !IsValid(wpn) then return end
    if !wpn.ARC9 then return end

    if (arc9_autoreload:GetBool() or wpn:GetRequestReload()) and
        !wpn:GetCustomize() and
        !wpn:GetCustomize() and
        wpn:CanReload() and
        cmd:TickCount() % 2 == 0
    then
        if wpn:GetUBGL() then
            if !LocalPlayer():KeyDown(IN_USE) and wpn:Clip2() == 0 and wpn:Ammo2() > 0 then
                cmd:AddKey(IN_RELOAD)
            end
        else
            if !LocalPlayer():KeyDown(IN_USE) and wpn:Clip1() == 0 and wpn:Ammo1() > 0 then
                cmd:AddKey(IN_RELOAD)
            end
        end
    end

    if ARC9.KeyPressed_Menu then
        cmd:AddKey(IN_WEAPON1)
    end

    if ARC9.KeyPressed_Melee then
        cmd:AddKey(ARC9.IN_MELEE)
    end

    if ARC9.KeyPressed_UBGL then
        cmd:AddKey(ARC9.IN_UBGL)
    end

    if ARC9.KeyPressed_Inspect then
        cmd:AddKey(ARC9.IN_INSPECT)
    end

    if ARC9.KeyPressed_SwitchSights then
        cmd:AddKey(ARC9.IN_SWITCHSIGHTS)
    end

    if GetConVar("arc9_cruelty_reload"):GetBool() then
        local buttons = cmd:GetButtons()

        local shouldreload = false

        // reload like in cruelty squad!

        if bit.band(cmd:GetButtons(), IN_RELOAD) == IN_RELOAD then
            local mouseY = cmd:GetMouseY()

            if mouseY > 0 then
                ARC9.ReloadAmount = ARC9.ReloadAmount + (mouseY / ScrH())
            end

            cmd:SetMouseY(0)
            if lastviewangles then
                cmd:SetViewAngles(lastviewangles)
            end

            buttons = bit.band(buttons, bit.bnot(IN_RELOAD))
        else
            lastviewangles = cmd:GetViewAngles()
        end

        if ARC9.ReloadAmount >= 1 then
            shouldreload = true
        end

        // deny reload unless shouldreload is true

        if shouldreload then
            buttons = bit.bor(buttons, IN_RELOAD)
        else
            buttons = bit.band(buttons, bit.bnot(IN_RELOAD))

            if bit.band(cmd:GetButtons(), IN_USE) == IN_USE then
                buttons = bit.bor(buttons, ARC9.IN_INSPECT)
            end
        end

        cmd:SetButtons(buttons)
    end

    if arc9_autolean:GetBool() then
        if cmd:KeyDown(IN_ATTACK2) or (wpn:ToggleADS() and arc9_lean_direction != nil and arc9_lean_direction != 0) then
            if arc9_lean_direction != nil and arc9_lean_direction != 0 then
                if wpn:ToggleADS() then
                    local eyepos = ply:EyePos()
                    local forward = ply:EyeAngles():Forward()

                    local covertrace = util.TraceHull({
                        start = eyepos,
                        endpos = eyepos + forward * 32,
                        filter = ply,
                        mins = Vector(-1, -1, -1) * 4,
                        maxs = Vector(1, 1, 1) * 4
                    })

                    if !covertrace.Hit then
                        arc9_lean_direction = 0
                        return
                    end
                end

                if arc9_lean_direction > 0 then
                    cmd:AddKey(IN_ALT2)
                elseif arc9_lean_direction < 0 then
                    cmd:AddKey(IN_ALT1)
                end
            elseif arc9_lean_direction == nil and cmd:KeyDown(IN_ATTACK2) then
                local eyepos = ply:EyePos()
                local right = ply:EyeAngles():Right()
                local forward = ply:EyeAngles():Forward()

                local covertrace = util.TraceHull({
                    start = eyepos,
                    endpos = eyepos + forward * 32,
                    filter = ply,
                    mins = Vector(-1, -1, -1) * 4,
                    maxs = Vector(1, 1, 1) * 4
                })

                if covertrace.Hit then
                    -- See if it's valid to lean left

                    arc9_lean_direction = 0

                    local leftleanamt = 0
                    local rightleanamt = 0

                    local leftleantrace = util.TraceLine({
                        start = eyepos,
                        endpos = eyepos + right * -wpn.MaxLeanOffset,
                        filter = ply,
                    })

                    if !leftleantrace.Hit then
                        -- see if it's possible to lean in this direction

                        local leftleantrace2 = util.TraceLine({
                            start = leftleantrace.HitPos,
                            endpos = leftleantrace.HitPos + (forward * 96),
                            filter = ply,
                        })

                        if !leftleantrace2.Hit then
                            local leftleantrace3 = util.TraceLine({
                                start = leftleantrace2.HitPos,
                                endpos = leftleantrace2.HitPos + (right * wpn.MaxLeanOffset),
                                filter = ply,
                            })

                            leftleanamt = leftleantrace3.Fraction * wpn.MaxLeanOffset
                        end
                    end

                    -- See if it's valid to lean right

                    local rightleantrace = util.TraceLine({
                        start = eyepos,
                        endpos = eyepos + right * wpn.MaxLeanOffset,
                        filter = ply,
                    })

                    if !rightleantrace.Hit then
                        -- see if it's possible to lean in this direction

                        local rightleantrace2 = util.TraceLine({
                            start = rightleantrace.HitPos,
                            endpos = rightleantrace.HitPos + (forward * 96),
                            filter = ply,
                        })

                        if !rightleantrace2.Hit then
                            local rightleantrace3 = util.TraceLine({
                                start = rightleantrace2.HitPos,
                                endpos = rightleantrace2.HitPos + (right * -wpn.MaxLeanOffset),
                                filter = ply,
                            })

                            rightleanamt = rightleantrace3.Fraction * wpn.MaxLeanOffset
                        end
                    end

                    if leftleanamt > rightleanamt then
                        arc9_lean_direction = -1
                    elseif rightleanamt > leftleanamt then
                        arc9_lean_direction = 1
                    else
                        arc9_lean_direction = 0
                    end
                end
            end
        else
            arc9_lean_direction = nil
        end
    end
end)

local performedAprilFoolsCheck = false

hook.Add("Think", "ARC9_cruelty_think_client_reload", function()
    if !performedAprilFoolsCheck then
        -- is it april fools today
        local date = os.date("*t")

        local day = date.day
        local month = date.month

        if day == 1 and month == 4 then
            if !GetConVar("arc9_cruelty_reload_april_fools"):GetBool() then
                RunConsoleCommand("arc9_cruelty_reload_april_fools", "1")
                RunConsoleCommand("arc9_cruelty_reload", "1")
            end
        else
            if GetConVar("arc9_cruelty_reload_april_fools"):GetBool() then
                RunConsoleCommand("arc9_cruelty_reload_april_fools", "0")
                RunConsoleCommand("arc9_cruelty_reload", "0")
            end
        end

        performedAprilFoolsCheck = true
    end

    if !GetConVar("arc9_cruelty_reload"):GetBool() then return end

    ARC9.ReloadAmount = ARC9.ReloadAmount - (FrameTime() * 2)

    ARC9.ReloadAmount = math.Clamp(ARC9.ReloadAmount, 0, 1.5)
end)
--PATH lua/arc9/client/cl_rendertarget.lua:
return gluapack()()
--PATH lua/arc9/client/cl_warnings.lua:
ARC9.IncompatibleAddons = {
    -- My Hands 8.1
    ["847269692"] = "Causes viewmodel flickering, double viewmodel, may crash when customization menu opens",
    -- My Hands 8
    ["1890577397"] = "Causes viewmodel flickering, double viewmodel, may crash when customization menu opens",
    -- Quick Weapon Menu
    ["306149085"] = "Makes the customize menu mouse unable to appear.",
    -- Neurotec
    ["541434990"] = "Neurotec is ancient, half the base is missing, and it flat-out doesn't work. Causes all sorts of problems. For the love of god, let go.",
    -- Improved Combine NPCs
    ["476997621"] = "Causes issues with arms.",
    -- Realistic Bullet Overhaul
    ["1588705429"] = "Causes damage calculation to not work properly.",
    -- Quake/Half Life View bobbing
    ["378401390"] = "Causes most animations to not play properly.",
    -- Thirteen's Physgun Glow
    ["111249028"] = "Causes LHIK animations to flicker and not work properly.",
    -- Viewmodel Lagger
    ["1146104662"] = "Misaligns viewmodel in sights.",
    -- Viewmodel Lagger (fixed)
    ["2566560460"] = "Misaligns viewmodel in sights.",
    -- VTools
    ["DisplayDistancePlane"] = "Tool contains faulty hook. You have probably installed VTools/other scenebuilding related addon through garrysmod/addons/ folder.",
    -- TFA's Tactical Lean
    ["TacticalLean"] = "Mod is old, laggy and interferes with ARC9 lean. Use relaxtakesnotes's \"Leaning\" mod steamcommunity.com/sharedfiles/filedetails/?id=3138563659 OR integrated leaning system.",
    -- fixed maybe     SLVBase 2  -- ["1516699044"] = "Causes black screen", -- Minecraft drops
    ["2879200766"] = "Teleports viewmodel to any dropped gun",
    -- Advanced color tool
    ["692778306"] = "Incompatible, breaks every addon in existence",
    -- TF2 Killstreak Weapon Sheen
    ["973050319"] = "Fucks up model rendering and other shit",
    -- View Model Bump
    ["1308077613"] = "Causes broken ADS/Sights position.",
    -- Improved Air To Surface Missile
    ["2384413050"] = "Breaks viewmodels for ARC9 and many other addons.",
    -- GLORY KILLS 2
    ["2301721246"] = "Breaks stickers for ARC9 and many other addons.",



    -- Perhaps we should not express personal opinions here in incompat list? Those addons aren't incompatible, literally just shitty stickers 
    -- Workshop is open for everyone, if this is truly "hate speech" then complain to steam/facepunch support

    -- This is literally just a troll and hatred fuel towards people behind arc9 for "censoring" addons
    -- You would not be able to change opinions of people who use those addons through restrictions (it will only make them more anger), but some day they will grow up anyway
    -- so should you, stop caring about meaningless shit and take this a bit more serious :-)


    -- -- ARC9 Anti-Furry Pack "Sigma Edition"
    -- ["3287204618"] = "The values expressed by this mod are not compatible with ARC9. We suggest going outside and touching grass.",
    -- -- ARC9 dudebros' Ultimate Anti-Furry Pack
    -- ["3288589622"] = "The values expressed by this mod are not compatible with ARC9. We suggest going outside and touching grass.",
}

-- -- ZINV Zombie/NPC Invasion and variants.
-- -- Original by Jason
-- ["179517028"] = "Breaks pretty much everything.",
-- -- ZINV++ by Gus "Sussy Gussy" Fring
-- ["2550261416"] = "Breaks pretty much everything.",
-- -- ZINV+ by moomoohk
-- ["597017711"] = "Breaks pretty much everything.",
-- -- ZINV++ by snorts
-- ["2757203958"] = "Breaks pretty much everything.",
local ScreenScaleMulti = ARC9.ScreenScale

function ARC9.MakeIncompatibleWindow(tbl)
    surface.PlaySound("buttons/combine_button_locked.wav")
    local startTime = CurTime()
    local window = vgui.Create("DFrame")
    window:SetSize(ScrW() * 0.6, ScrH() * 0.6)
    window:Center()
    window:SetTitle("")
    window:SetDraggable(false)
    window:SetVisible(true)
    window:ShowCloseButton(false)
    window:MakePopup()

    window.Paint = function(self, w, h)
        surface.SetDrawColor(0, 0, 0, 200)
        surface.DrawRect(0, 0, w, h)
    end

    local title = vgui.Create("DLabel", window)
    title:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(26))
    title:Dock(TOP)
    title:SetFont("ARC9_24")
    title:SetText(ARC9:GetPhrase("incompatible.title"))
    title:DockMargin(ScreenScaleMulti(16), 0, ScreenScaleMulti(16), ScreenScaleMulti(8))
    local desc = vgui.Create("DLabel", window)
    desc:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc:Dock(TOP)
    desc:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), 0)
    desc:SetFont("ARC9_12")
    desc:SetText(ARC9:GetPhrase("incompatible.line1"))
    desc:SetContentAlignment(5)
    local desc2 = vgui.Create("DLabel", window)
    desc2:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc2:Dock(TOP)
    desc2:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), ScreenScaleMulti(4))
    desc2:SetFont("ARC9_12")
    desc2:SetText(ARC9:GetPhrase("incompatible.line2"))
    desc2:SetContentAlignment(5)
    local neverAgain = vgui.Create("DButton", window)
    neverAgain:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(20))
    neverAgain:SetText("")
    neverAgain:Dock(BOTTOM)
    neverAgain:DockMargin(ScreenScaleMulti(48), ScreenScaleMulti(2), ScreenScaleMulti(48), ScreenScaleMulti(2))

    neverAgain.OnMousePressed = function(spaa, kc)
        if CurTime() > startTime + 10 then
            local simpleTbl = {}

            for _, v in pairs(tbl) do
                simpleTbl[tostring(v.wsid)] = true
            end

            file.Write("ARC9_incompatible.txt", util.TableToJSON(simpleTbl))
            window:Close()
            window:Remove()
            chat.AddText(Color(255, 0, 0), ARC9:GetPhrase("incompatible.never.confirm"))
            surface.PlaySound("buttons/lever1.wav")
        end
    end

    neverAgain.Paint = function(spaa, w, h)
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 200)

        if CurTime() > startTime + 10 and spaa:IsHovered() then
            Bbg_col = Color(255, 100, 100, 100)
            Bfg_col = Color(255, 255, 255, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (CurTime() > startTime + 10) and (spaa:IsHovered() and ARC9:GetPhrase("incompatible.never.hover") or ARC9:GetPhrase("incompatible.never")) or ARC9:GetPhrase("incompatible.wait", {
            time = math.ceil(startTime + 10 - CurTime())
        })

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(8), ScreenScaleMulti(2))
        surface.SetFont("ARC9_12")
        surface.DrawText(txt)
    end

    local addonList = vgui.Create("DScrollPanel", window)
    addonList:SetText("")
    addonList:Dock(FILL)
    addonList.Paint = function(span, w, h) end
    local sbar = addonList:GetVBar()
    sbar.Paint = function() end
    sbar.btnUp.Paint = function(span, w, h) end
    sbar.btnDown.Paint = function(span, w, h) end

    sbar.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(0, 0, w, h)
    end

    local accept = vgui.Create("DButton", window)
    accept:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(20))
    accept:SetText("")
    accept:Dock(BOTTOM)
    accept:DockMargin(ScreenScaleMulti(48), ScreenScaleMulti(2), ScreenScaleMulti(48), ScreenScaleMulti(2))

    accept.OnMousePressed = function(spaa, kc)
        if CurTime() > startTime + 5 then
            window:Close()
            window:Remove()
        end
    end

    accept.Paint = function(spaa, w, h)
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 200)

        if CurTime() > startTime + 5 and spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = ARC9:GetPhrase("incompatible.confirm") .. ((CurTime() > startTime + 5) and "" or (" - " .. ARC9:GetPhrase("incompatible.wait", {
            time = math.ceil(startTime + 5 - CurTime())
        })))

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(8), ScreenScaleMulti(2))
        surface.SetFont("ARC9_12")
        surface.DrawText(txt)
    end

    for _, addon in pairs(tbl) do
        local addonBtn = vgui.Create("DButton", window)
        addonBtn:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(28))
        addonBtn:Dock(TOP)
        addonBtn:DockMargin(ScreenScaleMulti(36), ScreenScaleMulti(2), ScreenScaleMulti(36), ScreenScaleMulti(2))
        addonBtn:SetFont("ARC9_12")
        addonBtn:SetText("")
        addonBtn:SetContentAlignment(5)

        addonBtn.Paint = function(spaa, w, h)
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 200)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)
            local txt = addon.title
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(18), ScreenScaleMulti(2))
            surface.SetFont("ARC9_12")
            surface.DrawText(txt)
            local txt2 = ARC9.IncompatibleAddons[tostring(addon.wsid)]
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(18), ScreenScaleMulti(16))
            surface.SetFont("ARC9_8")
            surface.DrawText(txt2)
        end

        addonBtn.OnMousePressed = function(spaa, kc)
            if addon.nourl then return end
            gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=" .. tostring(addon.wsid))
        end
    end
end

function ARC9.DoCompatibilityCheck()
    local shouldopenincompat, shouldopenconfig = false, false
    local incompatList, warningsList = {}, {}

    for _, addon in pairs(ARC9.BadConfigStuff) do
        if addon.cause() then
            table.insert(warningsList, addon)
        end
    end

    shouldopenconfig = !table.IsEmpty(warningsList)

    if game.SinglePlayer() then -- incompat addons only in sp
        local addons = engine.GetAddons()

        for _, addon in pairs(addons) do
            if ARC9.IncompatibleAddons[tostring(addon.wsid)] and addon.mounted then
                incompatList[tostring(addon.wsid)] = addon
            end
        end

        local predrawvmhooks = hook.GetTable().PreDrawViewModel

        -- vtools lua breaks ARC9 with stupid return in vm hook, ya dont need it if you going to play with guns
        if predrawvmhooks and (predrawvmhooks.DisplayDistancePlaneLS or predrawvmhooks.DisplayDistancePlane) then
            hook.Remove("PreDrawViewModel", "DisplayDistancePlane")
            hook.Remove("PreDrawViewModel", "DisplayDistancePlaneLS")

            incompatList["DisplayDistancePlane"] = {
                title = "Light Sprayer / Scenic Dispenser tool - most likely from VTools",
                wsid = "DisplayDistancePlane",
                nourl = true,
            }
        end

        local playerspawnhooks = hook.GetTable().PlayerSpawn

        if playerspawnhooks and playerspawnhooks.PlayerSpawn then
            incompatList["TacticalLean"] = {
                title = "Tactical Leaning",
                wsid = "TacticalLean",
                nourl = true,
            }
        end

        local shouldDo = true

        -- If never show again is on, verify we have no new addons
        if file.Exists("arc9_incompatible.txt", "DATA") then
            shouldDo = false
            local oldTbl = util.JSONToTable(file.Read("arc9_incompatible.txt"))

            for id, addon in pairs(incompatList) do
                local num_id = tonumber(id) or ""
                if not oldTbl[num_id] then
                    shouldDo = true
                    break
                end
            end

            if shouldDo then
                file.Delete("arc9_incompatible.txt")
            end
        end

        shouldopenincompat = shouldDo and not table.IsEmpty(incompatList)

        if !shouldopenincompat and not table.IsEmpty(incompatList) then
            print("ARC9 ignored " .. table.Count(incompatList) .. " incompatible addons. If things break, it's your fault.")
        end
    end

    if shouldopenconfig then
        ARC9.MakeBadConfigWindow(warningsList, shouldopenincompat, incompatList)
    elseif shouldopenincompat then
        ARC9.MakeIncompatibleWindow(incompatList)
    end
end

concommand.Add("arc9_dev_showwarnings", ARC9.DoCompatibilityCheck)

hook.Add("InitPostEntity", "ARC9_CheckContent", function()
    for _, k in pairs(weapons.GetList()) do
        if weapons.IsBasedOn(k.ClassName, "arc9_base") and k.ClassName ~= "arc9_base" then return end
    end

    chat.AddText(Color(255, 255, 255), "You have installed the ARC9 base but have no weapons installed. Search the workshop for some!")
end)





ARC9.BadConfigStuff = {
    dx = {
        title = ARC9:GetPhrase("badconf.directx.title"),
        desc = ARC9:GetPhrase("badconf.directx.desc"),
        solution = ARC9:GetPhrase("badconf.directx.solution"),
        cause = function() return render.GetDXLevel() != 95 and render.GetDXLevel() != 90 end
    },
    tickrate = {
        title = ARC9:GetPhrase("badconf.tickrate.title"),
        desc = ARC9:GetPhrase("badconf.tickrate.desc"),
        solution = ARC9:GetPhrase("badconf.tickrate.solution"),
        cause = function() return game.IsDedicated() and 1 / engine.TickInterval() < 20 and LocalPlayer():IsAdmin() end
    },
    -- could be annoying, only packs that have issues are classic cod packs
    -- matbumpmap = {
    --     title = ARC9:GetPhrase("badconf.matbumpmap.title"),
    --     desc = ARC9:GetPhrase("badconf.matbumpmap.desc"),
    --     solution = ARC9:GetPhrase("badconf.matbumpmap.solution"),
    --     cause = function() return GetConVar("mat_bumpmap"):GetInt() == 0 end
    -- },
    addons = {
        title = ARC9:GetPhrase("badconf.addons.title"),
        desc = ARC9:GetPhrase("badconf.addons.desc"),
        solution = ARC9:GetPhrase("badconf.addons.solution"),
        cause = function() return ARC9.AllLuaFilesLoaded != true end -- zzz_cl_lualoadcheck.lua
    },
}



function ARC9.MakeBadConfigWindow(tbl, openincompatafter, incompattable)
    surface.PlaySound("buttons/weapon_cant_buy.wav")
    local startTime = CurTime()
    local window = vgui.Create("DFrame")
    window:SetSize(ScrW() * 0.6, ScrH() * 0.6)
    window:Center()
    window:SetTitle("")
    window:SetDraggable(false)
    window:SetVisible(true)
    window:ShowCloseButton(false)
    window:MakePopup()

    window.Paint = function(self, w, h)
        surface.SetDrawColor(0, 0, 0, 200)
        surface.DrawRect(0, 0, w, h)
    end

    local title = vgui.Create("DLabel", window)
    title:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(26))
    title:Dock(TOP)
    title:SetFont("ARC9_24")
    title:SetText(ARC9:GetPhrase("badconf.title"))
    title:DockMargin(ScreenScaleMulti(16), 0, ScreenScaleMulti(16), ScreenScaleMulti(8))
    local desc = vgui.Create("DLabel", window)
    desc:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc:Dock(TOP)
    desc:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), 0)
    desc:SetFont("ARC9_12")
    desc:SetText(ARC9:GetPhrase("badconf.line1"))
    desc:SetContentAlignment(5)
    local desc2 = vgui.Create("DLabel", window)
    desc2:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc2:Dock(TOP)
    desc2:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), ScreenScaleMulti(4))
    desc2:SetFont("ARC9_12")
    desc2:SetText(ARC9:GetPhrase("badconf.line2"))
    desc2:SetContentAlignment(5)

    local addonList = vgui.Create("DScrollPanel", window)
    addonList:SetText("")
    addonList:Dock(FILL)
    addonList.Paint = function(span, w, h) end
    local sbar = addonList:GetVBar()
    sbar.Paint = function() end
    sbar.btnUp.Paint = function(span, w, h) end
    sbar.btnDown.Paint = function(span, w, h) end

    sbar.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(0, 0, w, h)
    end

    local accept = vgui.Create("DButton", window)
    accept:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(20))
    accept:SetText("")
    accept:Dock(BOTTOM)
    accept:DockMargin(ScreenScaleMulti(48), ScreenScaleMulti(2), ScreenScaleMulti(48), ScreenScaleMulti(2))

    accept.OnMousePressed = function(spaa, kc)
        if CurTime() > startTime + 5 then
            window:Close()
            window:Remove()

            if openincompatafter then
                ARC9.MakeIncompatibleWindow(incompattable)
            end
        end
    end

    accept.Paint = function(spaa, w, h)
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 200)

        if CurTime() > startTime + 5 and spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        -- local txt = ARC9:GetPhrase("badconf.confirm") .. ((CurTime() > startTime + 5) and "" or (" - " .. ARC9:GetPhrase("badconf.wait", {
        --     time = math.ceil(startTime + 5 - CurTime())
        -- })))
        local txt = ARC9:GetPhrase("badconf.confirm") .. ((CurTime() > startTime + 5) and "" or (" - " .. ARC9:GetPhrase("badconf.wait", {
            time = math.ceil(startTime + 5 - CurTime())
        })))

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(8), ScreenScaleMulti(2))
        surface.SetFont("ARC9_12")
        surface.DrawText(txt)
    end

    for _, addon in pairs(tbl) do
        local addonBtn = vgui.Create("DButton", window)
        addonBtn:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(38))
        addonBtn:Dock(TOP)
        addonBtn:DockMargin(ScreenScaleMulti(36), ScreenScaleMulti(2), ScreenScaleMulti(36), ScreenScaleMulti(2))
        addonBtn:SetFont("ARC9_12")
        addonBtn:SetText("")
        addonBtn:SetContentAlignment(5)

        addonBtn.Paint = function(spaa, w, h)
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 200)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)
            local txt = addon.title
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(18), ScreenScaleMulti(2))
            surface.SetFont("ARC9_12")
            surface.DrawText(txt)
            local txt2 = addon.desc
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(18), ScreenScaleMulti(16))
            surface.SetFont("ARC9_8")
            surface.DrawText(txt2)
            local txt3 = addon.solution
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(18), ScreenScaleMulti(26))
            surface.SetFont("ARC9_8")
            surface.DrawText(txt3)
        end

        addonBtn.OnMousePressed = function(spaa, kc)
            surface.PlaySound("npc/stalker/go_alert2.wav")
        end
    end
end

-- ARC9.MakeBadConfigWindow(ARC9.BadConfigStuff)
--PATH lua/pixelui/sh_config.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

--[[
    Should we override the default derma popups for the PIXEL UI reskins?
    0 = No - forced off.
    1 = No - but users can opt in via convar (pixel_ui_override_popups).
    2 = Yes - but users can opt out via convar.
    3 = Yes - forced on.
]]
PIXEL.OverrideDermaMenus = 0

--[[
    The Image URL of the progress image you want to appear when image content is loading.
]]
PIXEL.ProgressImageURL = "https://pixel-cdn.lythium.dev/i/47qh6kjjh"

--[[
    The location at which downloaded assets should be stored (relative to the data folder).
]]
PIXEL.DownloadPath = "pixel/images/"

--[[
    Colour definitions.
]]
PIXEL.Colors = {
    Background = Color(22, 22, 22),
    Header = Color(28, 28, 28),
    Scroller = Color(61, 61, 61),

    PrimaryText = Color(255, 255, 255),
    SecondaryText = Color(220, 220, 220),
    DisabledText = Color(40, 40, 40),

    Primary = Color(47, 128, 200),
    Disabled = Color(180, 180, 180),
    Positive = Color(66, 134, 50),
    Negative = Color(164, 50, 50),

    Gold = Color(214, 174, 34),
    Silver = Color(192, 192, 192),
    Bronze = Color(145, 94, 49),

    Transparent = Color(0, 0, 0, 0)
}

--PATH lua/pixelui/core/cl_fonts.lua:
return gluapack()()
--PATH lua/pixelui/drawing/cl_misc.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

function PIXEL.DrawRoundedTextBox(text, font, x, y, xAlign, textCol, boxRounding, boxPadding, boxCol)
    local boxW, boxH = PIXEL.GetTextSize(text, font)

    local dblPadding = boxPadding * 2
    if xAlign == TEXT_ALIGN_CENTER then
        PIXEL.DrawRoundedBox(boxRounding, x - boxW / 2 - boxPadding, y - boxPadding, boxW + dblPadding, boxH + dblPadding, boxCol)
    elseif xAlign == TEXT_ALIGN_RIGHT then
        PIXEL.DrawRoundedBox(boxRounding, x - boxW - boxPadding, y - boxPadding, boxW + dblPadding, boxH + dblPadding, boxCol)
    else
        PIXEL.DrawRoundedBox(boxRounding, x - boxPadding, y - boxPadding, boxW + dblPadding, boxH + dblPadding, boxCol)
    end

    PIXEL.DrawText(text, font, x, y, textCol, xAlign)
end

function PIXEL.DrawFixedRoundedTextBox(text, font, x, y, xAlign, textCol, boxRounding, w, h, boxCol, textPadding)
    PIXEL.DrawRoundedBox(boxRounding, x, y, w, h, boxCol)

    if xAlign == TEXT_ALIGN_CENTER then
        PIXEL.DrawSimpleText(text, font, x + w / 2, y + h / 2, textCol, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        return
    end

    if xAlign == TEXT_ALIGN_RIGHT then
        PIXEL.DrawSimpleText(text, font, x + w - textPadding, y + h / 2, textCol, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
        return
    end

    PIXEL.DrawSimpleText(text, font, x + textPadding, y + h / 2, textCol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

local blurPassesCvar = CreateClientConVar("pixel_ui_blur_passes", "4", true, false, "Amount of passes to draw blur with. 0 to disable blur entirely.", 0, 15)
local blurPassesNum = blurPassesCvar:GetInt()

cvars.AddChangeCallback("pixel_ui_blur_passes", function(_, _, passes)
    blurPassesNum = math.floor(tonumber(passes) + 0.05)
end )

local blurMat = Material("pp/blurscreen")
local scrW, scrH = ScrW, ScrH
function PIXEL.DrawBlur(panel, localX, localY, w, h)
    if blurPassesNum == 0 then return end
    local x, y = panel:LocalToScreen(localX, localY)
    local scrw, scrh = scrW(), scrH()

    surface.SetMaterial(blurMat)
    surface.SetDrawColor(255, 255, 255)

    for i = 0, blurPassesNum do
        blurMat:SetFloat("$blur", i * .33)
        blurMat:Recompute()
    end
    render.UpdateScreenEffectTexture()
    surface.DrawTexturedRect(x * -1, y * -1, scrw, scrh)
end
--PATH lua/pixelui/drawing/cl_text.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_image_button.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "ImageURL", "ImageURL", FORCE_STRING)
AccessorFunc(PANEL, "ImageSize", "ImageSize", FORCE_NUMBER)
AccessorFunc(PANEL, "NormalColor", "NormalColor")
AccessorFunc(PANEL, "HoverColor", "HoverColor")
AccessorFunc(PANEL, "ClickColor", "ClickColor")
AccessorFunc(PANEL, "DisabledColor", "DisabledColor")

function PANEL:Init()
    self.ImageCol = PIXEL.CopyColor(color_white)
    self:SetImageURL(PIXEL.ProgressImageURL)

    self:SetNormalColor(color_white)
    self:SetHoverColor(color_white)
    self:SetClickColor(color_white)
    self:SetDisabledColor(color_white)

    self:SetImageSize(1)
end

function PANEL:PaintBackground(w, h) end

function PANEL:Paint(w, h)
    self:PaintBackground(w, h)

    local imageSize = h * self:GetImageSize()
    local imageOffset = (h - imageSize) / 2

    if not self:IsEnabled() then
        PIXEL.DrawImage(imageOffset, imageOffset, imageSize, imageSize, self:GetImageURL(), self:GetDisabledColor())
        return
    end

    local col = self:GetNormalColor()

    if self:IsHovered() then
        col = self:GetHoverColor()
    end

    if self:IsDown() or self:GetToggle() then
        col = self:GetClickColor()
    end

    self.ImageCol = PIXEL.LerpColor(FrameTime() * 12, self.ImageCol, col)

    PIXEL.DrawImage(imageOffset, imageOffset, imageSize, imageSize, self:GetImageURL(), self.ImageCol)
end

vgui.Register("PIXEL.ImageButton", PANEL, "PIXEL.Button")
--PATH lua/pixelui/elements/cl_property_sheet.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_slider.lua:
return gluapack()()
--PATH lua/pixelui/menus/cl_query_popup.lua:
return gluapack()()
--PATH lua/autorun/sh_republic_conquest.lua:
return gluapack()()
--PATH addons/[misc] siadanie/lua/autorun/sitanywhere.lua:
if SERVER then
	AddCSLuaFile("sitanywhere/client/sit.lua")
	AddCSLuaFile("sitanywhere/helpers.lua")
	include("sitanywhere/helpers.lua")
	include("sitanywhere/server/sit.lua")

	AddCSLuaFile("sitanywhere/ground_sit.lua")
	include("sitanywhere/server/unstuck.lua")
	include("sitanywhere/ground_sit.lua")
else
	include("sitanywhere/helpers.lua")
	include("sitanywhere/client/sit.lua")

	include("sitanywhere/ground_sit.lua")
end
--PATH addons/[misc] siadanie/lua/sitanywhere/ground_sit.lua:
return gluapack()()
--PATH lua/autorun/slib_loader.lua:
local function slibInit()
    print("[slib] Loading")

    if SERVER then
        AddCSLuaFile("slib/sh_util.lua")
        include("slib/sv_storage.lua")
        include("slib/sh_util.lua")
    else
        include("slib/sh_util.lua")
    end
end

hook.Add("slib:loadBase", "slib.loadVGUI", function()
    slib.loadFolder("slib/vgui/", false, {{"slib/vgui/", "cl_sframe.lua"}})
end)

slibInit()
--PATH lua/slib/vgui/cl_splayerpanel.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 15)
local textcolor, maincolor_7 = slib.getTheme("textcolor"), slib.getTheme("maincolor", 7)

function PANEL:Init()
    local tall = slib.getScaledSize(25, "y")
    self:SetTall(tall)
    self:Dock(TOP)

    self.playerImage = vgui.Create("AvatarImage", self)
    self.playerImage:SetSize(tall, tall)

    self:DockMargin(0, 0, 0, slib.getTheme("margin"))
    self:GetParent():DockPadding(slib.getTheme("margin"), slib.getTheme("margin"), slib.getTheme("margin"), slib.getTheme("margin"))
end

function PANEL:addButton(title, func)
    local bttn = vgui.Create("SButton", self)
    bttn:setTitle(title)
    :Dock(RIGHT)
    :DockMargin(0,slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))

    bttn.DoClick = func

    return self
end

function PANEL:setPlayer(ply)
    self.ply = ply
    self.name = self.ply:Nick()
    self.playerImage:SetPlayer(ply, 64)

    return self
end

function PANEL:Paint(w,h)
    if !self.ply then self:Remove() end

    surface.SetDrawColor(maincolor_7)
    surface.DrawRect(0, 0, w, h)

    if self.ply then
        draw.SimpleText(self.name, font, slib.getScaledSize(25, "y") + slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end
end

vgui.Register("SPlayerPanel", PANEL, "EditablePanel")
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_util.lua:
gProtect.returnStatements = function(fallback, bad, ...)
    local args = {...}

    for k, v in pairs(args) do
        if isfunction(v) then v = v() end
        if v == bad then return bad end
    end

    return fallback
end

--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/languages/sh_polish.lua:
if SERVER then
	slib.setLang("gprotect", "pl", "colliding-too-much", "%s's entities za bardzo się zderzają!	")
	slib.setLang("gprotect", "pl", "too-many-obstructs", "%s's entity blokuje zbyt wiele złych istot!")
	slib.setLang("gprotect", "pl", "blacklisted-multiple", "Pomyślnie dodałeś modele %s do zablokowanych modeli!")
	slib.setLang("gprotect", "pl", "unblacklisted-multiple", "Usunąłeś pomyślnie %s modele z zablokowanych modeli!")
	slib.setLang("gprotect", "pl", "blacklisted-multiple-ent", "Dodałeś pomyślnie %s ents do podmiotów z czarnej listy!")
	slib.setLang("gprotect", "pl", "unblacklisted-multiple-ent", "Pomyślnie usunąłeś %s ents z czarnej listy!")
	slib.setLang("gprotect", "pl", "added-blacklist", "Pomyślnie dodałeś %s do zablokowanych modeli!")
	slib.setLang("gprotect", "pl", "removed-blacklist", "Usunąłeś pomyślnie %s z zablokowanych modeli!")
	slib.setLang("gprotect", "pl", "added-blacklist-ent", "Pomyślnie dodałeś %s do czarnej listy jednostek!")
	slib.setLang("gprotect", "pl", "removed-blacklist-ent", "Usunąłeś pomyślnie	%s z czarnej listy podmiotów!")
	slib.setLang("gprotect", "pl", "attempted-unfreeze-all", "%s próbował odblokować wszystko po spawnowaniu dupe!")
	slib.setLang("gprotect", "pl", "attempted-upscaled-ent", "%s próbował odrodzić skalowany byt za pomocą adv dupe 2!")
	slib.setLang("gprotect", "pl", "attempted-rope-spawning", "%s próbował spawnować liny używając adv dupe 2!")
	slib.setLang("gprotect", "pl", "attempted-no-gravity", "%s próbował stworzyć rekwizyty bez grawitacji, używając Adv Dupe 2!")

	slib.setLang("gprotect", "pl", "model-restricted", "Ten model został objęty ograniczeniami!")
	slib.setLang("gprotect", "pl", "classname-restricted", "Ta klasa encji została ograniczona!")
	slib.setLang("gprotect", "pl", "attempted-blackout", "%s próbował wykorzystać exploit blackout!")
	slib.setLang("gprotect", "pl", "spam-spawning", "%s próbuje spamować spawnowaniem bytów / rekwizytów.")

	slib.setLang("gprotect", "pl", "too-complex-model", "Ten model został ograniczony, jest zbyt skomplikowany!")
	slib.setLang("gprotect", "pl", "too-big-prop", "Twój rekwizyt jest za duży, więc go usunęliśmy!")
	slib.setLang("gprotect", "pl", "successfull-fpp-blockedmodels", "Udało Ci się przenieść zablokowane modele z FPP do gProtect!")
	slib.setLang("gprotect", "pl", "successfull-fpp-grouptools", "Pomyślnie przeniosłeś grouptools z FPP do gProtect!")
	slib.setLang("gprotect", "pl", "unsuccessfull-transfer", "Wydaje się, że wystąpił problem podczas przesyłania danych! (MySQL nie jest obsługiwany)")

	slib.setLang("gprotect", "pl", "you-ghosted-props", "Masz upiorne %s's rekwizyty!")
	slib.setLang("gprotect", "pl", "you-frozen-props", "Zamarzłeś %s's rekwizyty!")
	slib.setLang("gprotect", "pl", "you-removed-props", "Usunąłeś %s's rekwizyty!")

	slib.setLang("gprotect", "pl", "props-ghosted", "Twoje rekwizyty zostały zniszczone!")
	slib.setLang("gprotect", "pl", "props-frozen", "Twoje rekwizyty zostały zamrożone!")
	slib.setLang("gprotect", "pl", "props-removed", "Twoje rekwizyty zostały usunięte!")

	slib.setLang("gprotect", "pl", "everyones-props-ghosted", "Someone has ghosted everyones props!")
	slib.setLang("gprotect", "pl", "everyones-props-frozen", "Ktoś zamroził wszystkie rekwizyty!")
	slib.setLang("gprotect", "pl", "disconnected-ents-removed", "Usunąłeś wszystkie odłączone podmioty graczy!")

	slib.setLang("gprotect", "pl", "insufficient-permission", "Nie masz takiego przywileju!")
	slib.setLang("gprotect", "pl", "spawn-to-close", "Twój rekwizyt nie może zostać odrodzony w kimś!")
	slib.setLang("gprotect", "pl", "entity-ghosted", "Twoja istota została zniszczona!")
elseif CLIENT then
	slib.setLang("gprotect", "pl", "title", "gProtect - Ustawienia")
	slib.setLang("gprotect", "pl", "buddies-title", "gProtect - Kumple")

	slib.setLang("gprotect", "pl", "world", "Świat")
	slib.setLang("gprotect", "pl", "disconnected", "Bezładny")
	slib.setLang("gprotect", "pl", "toolgun-name", "Rekwizyty czarnej listy")
	slib.setLang("gprotect", "pl", "toolgun-desc", "Zarządzaj zablokowanymi modelami")
	slib.setLang("gprotect", "pl", "toolgun-leftclick", "Dodaj do modeli na czarnej liście")
	slib.setLang("gprotect", "pl", "toolgun-rightclick", "Usuń z modeli na czarnej liście")
	slib.setLang("gprotect", "pl", "toolgun-help", "Strzelaj do rekwizytu za pomocą narzędzia")
	slib.setLang("gprotect", "pl", "remove-on-blacklist", "Usuń prop z czarnej listy")
	slib.setLang("gprotect", "pl", "player-list", "Lista graczy")

	slib.setLang("gprotect", "pl", "toolgun", "Toolgun")
	slib.setLang("gprotect", "pl", "physgun", "Physgun")
	slib.setLang("gprotect", "pl", "gravity-gun", "Gravity Gun")
	slib.setLang("gprotect", "pl", "canproperty", "Moga własność")

	slib.setLang("gprotect", "pl", "add-blocked-models", "Dodaj do zablokowanych modeli")
	slib.setLang("gprotect", "pl", "remove-blocked-models", "Usuń z zablokowanych modeli")

	slib.setLang("gprotect", "pl", "add-blacklisted-ents", "Dodaj do obiektów na czarnej liścies")
	slib.setLang("gprotect", "pl", "remove-blacklisted-ents", "Usuń z czarnej listy")
	slib.setLang("gprotect", "pl", "copy-clipboard", "Skopiuj do schowka")

	slib.setLang("gprotect", "pl", "general", "Generał")
	slib.setLang("gprotect", "pl", "ghosting", "Ghosting")
	slib.setLang("gprotect", "pl", "damage", "Uszkodzić")
	slib.setLang("gprotect", "pl", "anticollide", "Anti Collide")
	slib.setLang("gprotect", "pl", "spamprotection", "Ochrona przed spamem")
	slib.setLang("gprotect", "pl", "spawnrestriction", "Ograniczenie odradzania")
	slib.setLang("gprotect", "pl", "toolgunsettings", "Toolgun Ustawienia")
	slib.setLang("gprotect", "pl", "physgunsettings", "Physgun Ustawienia")
	slib.setLang("gprotect", "pl", "gravitygunsettings", "Gravgun Ustawienia")
	slib.setLang("gprotect", "pl", "canpropertysettings", "Can Property Ustawienia")
	slib.setLang("gprotect", "pl", "advdupe2", "Adv Dupe 2")
	slib.setLang("gprotect", "pl", "miscs", "Miscs")

	slib.setLang("gprotect", "pl", "ghost-props", "Duchowe rekwizyty")
	slib.setLang("gprotect", "pl", "remove-props", "Usun rekwizyty")
	slib.setLang("gprotect", "pl", "freeze-props", "Zatrzymaj rekwizyty")
	slib.setLang("gprotect", "pl", "highlight-ents", "Podświetl elementy")
	slib.setLang("gprotect", "pl", "unhighlight-ents", "Odznacz jednostki")

	slib.setLang("gprotect", "pl", "ghost-everyones-props", "Duchy wszystkich rekwizytów")
	slib.setLang("gprotect", "pl", "freeze-everyones-props", "Zamrozić wszystkie rekwizyty")
	slib.setLang("gprotect", "pl", "remove-disconnected-props", "Usuń rekwizyty odłączonych graczy")

	slib.setLang("gprotect", "pl", "general_remDiscPlyEnt", "Usuń odłączone jednostki graczy")
	slib.setLang("gprotect", "pl", "general_remDiscPlyEnt_tooltip", "Spowoduje to usunięcie odłączonych graczy na liczniku (jeśli -1 zostanie wyłączone).")
	slib.setLang("gprotect", "pl", "general_blacklist", "Czarna lista")
	slib.setLang("gprotect", "pl", "general_blacklist_tooltip", "W tym miejscu dodaje się nazwy klas, które powinny być chronione przez wszystkie moduły.")
	slib.setLang("gprotect", "pl", "general_protectedFrozenEnts", "Chronione zamrożone jednostki")
	slib.setLang("gprotect", "pl", "general_protectedFrozenEnts_tooltip", "To jest lista podmiotów, które należy chronić po zamrożeniu")
	slib.setLang("gprotect", "pl", "general_protectedFrozenGroup", "Grupa chroniona zamrożona")
	slib.setLang("gprotect", "pl", "general_protectedFrozenGroup_tooltip", "To jest grupa kolizji, w której umieszczane są zamrożone obiekty!")

	slib.setLang("gprotect", "pl", "ghosting_enabled", "Włączone")
	slib.setLang("gprotect", "pl", "ghosting_enabled_tooltip", "Włączyć moduł ghosting?")
	slib.setLang("gprotect", "pl", "ghosting_ghostColor", "Kolor zjawy")
	slib.setLang("gprotect", "pl", "ghosting_ghostColor_tooltip", "Wybierz kolor dla obiektów widmowych")
	slib.setLang("gprotect", "pl", "ghosting_antiObscuring", "Anti-obscuring")
	slib.setLang("gprotect", "pl", "ghosting_antiObscuring_tooltip", "Zapobiegnie to unghosted rekwizytów podczas zasłaniania obiektu. Po prostu dodaj elementy, które nie powinny być zasłaniane!")
	slib.setLang("gprotect", "pl", "ghosting_onPhysgun", "Ghost on physgun?")
	slib.setLang("gprotect", "pl", "ghosting_onPhysgun_tooltip", "Spowoduje to pojawienie się bytów duchów podczas strzelania fizycznego.")
	slib.setLang("gprotect", "pl", "ghosting_useBlacklist", "Użyj czarnej listy")
	slib.setLang("gprotect", "pl", "ghosting_useBlacklist_tooltip", "Ta opcja spowoduje usunięcie elementów z czarnej listy z czarnej listy, jeśli moduł jest włączony.")
	slib.setLang("gprotect", "pl", "ghosting_entities", "Entities")
	slib.setLang("gprotect", "pl", "ghosting_entities_tooltip", "Nazwy klas na tej liście będą widmowe, nie zmieni to czarnej listy używanej przez inne moduły.")

	slib.setLang("gprotect", "pl", "damage_enabled", "Włączone")
	slib.setLang("gprotect", "pl", "damage_enabled_tooltip", "Włączyć moduł uszkodzeń?")
	slib.setLang("gprotect", "pl", "damage_useBlacklist", "Użyj czarnej listy")
	slib.setLang("gprotect", "pl", "damage_useBlacklist_tooltip", "Ta opcja potraktuje ogólną czarną listę jako wpis na czarnej liście w tym module!")
	slib.setLang("gprotect", "pl", "damage_entities", "Elementy na czarnej liście")
	slib.setLang("gprotect", "pl", "damage_entities_tooltip", "Nazwy klas na tej liście nie będą zadawać obrażeń, jeśli zaznaczono opcję wyłączenia obrażeń, nie zmieni to czarnej listy używanej przez inne moduły.")
	slib.setLang("gprotect", "pl", "damage_blacklistedEntPlayerDamage", "Wyłącz uszkodzenia ents na czarnej liście")
	slib.setLang("gprotect", "pl", "damage_blacklistedEntPlayerDamage_tooltip", "Jeśli ta opcja jest zaznaczona, gracze nie będą otrzymywać obrażeń od podmiotów z czarnej listy.")
	slib.setLang("gprotect", "pl", "damage_vehiclePlayerDamage", "Wyłącz uszkodzenia pojazdów")
	slib.setLang("gprotect", "pl", "damage_vehiclePlayerDamage_tooltip", "Jeśli ta opcja jest zaznaczona, gracze nie otrzymają obrażeń od pojazdów.")
	slib.setLang("gprotect", "pl", "damage_worldPlayerDamage", "Wyłącz obrażenia świata")
	slib.setLang("gprotect", "pl", "damage_worldPlayerDamage_tooltip", "Jeśli ta opcja jest zaznaczona, gracze mogą otrzymywać obrażenia od podmiotów z czarnej listy.")
	slib.setLang("gprotect", "pl", "damage_immortalEntities", "Immortal Entities")
	slib.setLang("gprotect", "pl", "damage_immortalEntities_tooltip", "Nazwy klas na tej liście nie odnoszą obrażeń, chyba że gracz znajduje się w grupie obejścia!")
	slib.setLang("gprotect", "pl", "damage_bypassGroups", "Pomijaj grupy")
	slib.setLang("gprotect", "pl", "damage_bypassGroups_tooltip", "Dodaj grupy użytkowników do tej listy, aby ominąć ograniczenia szkód, '*' oznacza wszystkich!")
	slib.setLang("gprotect", "pl", "damage_canDamageWorldEntities", "Może uszkadzać byty świata")
	slib.setLang("gprotect", "pl", "damage_canDamageWorldEntities_tooltip", "Grupy znajdujące się na tej liście mogą uszkadzać byty świata, '*' oznacza każdego!")

	slib.setLang("gprotect", "pl", "anticollide_enabled", "Włączono")
	slib.setLang("gprotect", "pl", "anticollide_enabled_tooltip", "Włączyć moduł antykolizyjny?")
	slib.setLang("gprotect", "pl", "anticollide_notifyStaff", "Powiadom personel")
	slib.setLang("gprotect", "pl", "anticollide_notifyStaff_tooltip", "Czy wykrycie powinno powiadomić personel? Uwaga: można to wykorzystać do sikania personelu.")
	slib.setLang("gprotect", "pl", "anticollide_protectDarkRPEntities", "Chroń podmioty DarkRP")
	slib.setLang("gprotect", "pl", "anticollide_protectDarkRPEntities_tooltip", "Czy powinniśmy chronić podmioty DarkRP? (0 = wyłączone, 1 = duch, 2 = zablokuj, 3 = usuń, 4 = usuń i zwrot)")
	slib.setLang("gprotect", "pl", "anticollide_DRPentitiesThreshold", "Próg jednostek DRP")
	slib.setLang("gprotect", "pl", "anticollide_DRPentitiesThreshold_tooltip", "Ile kolizji może mieć rekwizyt, zanim zostanie wywołany w ciągu 1 sekundy?")
	slib.setLang("gprotect", "pl", "anticollide_DRPentitiesException", "Wyjątek jednostek DRP")
	slib.setLang("gprotect", "pl", "anticollide_DRPentitiesException_tooltip", "Jakie kolizje ignorujemy? (0 = brak, 1 = inny właściciel, 2 = brak właściciela)")
	slib.setLang("gprotect", "pl", "anticollide_protectSpawnedEntities", "Chroń spawnowane byty")
	slib.setLang("gprotect", "pl", "anticollide_protectSpawnedEntities_tooltip", "Czy powinniśmy chronić spawnowane byty? (0 = wyłączone, 1 = duch, 2 = zatrzymaj, 3 = usuń")
	slib.setLang("gprotect", "pl", "anticollide_entitiesThreshold", "Próg odrodzonych bytów")
	slib.setLang("gprotect", "pl", "anticollide_entitiesThreshold_tooltip", "Ile kolizji może mieć rekwizyt, zanim zostanie wywołany w ciągu 1 sekundy?")
	slib.setLang("gprotect", "pl", "anticollide_entitiesException", "Wyjątek od wygenerowanych bytów")
	slib.setLang("gprotect", "pl", "anticollide_entitiesException_tooltip", "Jakie kolizje ignorujemy? (0 = brak, 1 = inny właściciel, 2 = brak właściciela)")
	slib.setLang("gprotect", "pl", "anticollide_protectSpawnedProps", "Chroń rozmnożone rekwizyty")
	slib.setLang("gprotect", "pl", "anticollide_protectSpawnedProps_tooltip", "Czy powinniśmy chronić rozmnożone rekwizyty? (0 = wyłączone, 1 = duch, 2 = zatrzymaj, 3 = usuń")
	slib.setLang("gprotect", "pl", "anticollide_propsThreshold", "Próg odrodzonych rekwizytów")
	slib.setLang("gprotect", "pl", "anticollide_propsThreshold_tooltip", "Ile kolizji może mieć rekwizyt, zanim zostanie wywołany w ciągu 1 sekundy?")
	slib.setLang("gprotect", "pl", "anticollide_propsException", "Wyjątek od wygenerowanych rekwizytów")
	slib.setLang("gprotect", "pl", "anticollide_propsException_tooltip", "Jakie kolizje ignorujemy? (0 = brak, 1 = inny właściciel, 2 = brak właściciela)")
	slib.setLang("gprotect", "pl", "anticollide_useBlacklist", "Użyj czarnej listy")
	slib.setLang("gprotect", "pl", "anticollide_useBlacklist_tooltip", "Elementy na czarnej liście będą widmowe, jeśli kolidują za dużo, jeśli ta opcja jest włączona")
	slib.setLang("gprotect", "pl", "anticollide_ghostEntities", "Podmioty")
	slib.setLang("gprotect", "pl", "anticollide_ghostEntities_tooltip", "Nazwy klas na tej liście będą widmowe, jeśli będą się zbytnio zderzać.")

	slib.setLang("gprotect", "pl", "spamprotection_enabled", "Enabled")
	slib.setLang("gprotect", "pl", "spamprotection_enabled_tooltip", "Włączyć moduł ochrony przed spamem?")
	slib.setLang("gprotect", "pl", "spamprotection_threshold", "Próg")
	slib.setLang("gprotect", "pl", "spamprotection_threshold_tooltip", "Jeśli stworzysz te wiele rekwizytów naraz, włączy się, chyba że zdefiniowane poniżej opóźnienie zniknie.")
	slib.setLang("gprotect", "pl", "spamprotection_delay", "Delay")
	slib.setLang("gprotect", "pl", "spamprotection_delay_tooltip", "Ten licznik czasu wyczyści powyższy próg.")
	slib.setLang("gprotect", "pl", "spamprotection_action", "Punishment")
	slib.setLang("gprotect", "pl", "spamprotection_action_tooltip", "To zadecyduje, jak postępować ze spamerami! (1 = nie zezwalaj na tworzenie się, 2 = obiekt widmo / atrybut)")
	slib.setLang("gprotect", "pl", "spamprotection_notifyStaff", "Powiadom personel")
	slib.setLang("gprotect", "pl", "spamprotection_notifyStaff_tooltip", "Czy wykrycie powiadamia personel? Uwaga: można to wykorzystać do wkurzenia pracowników.")
	slib.setLang("gprotect", "pl", "spamprotection_protectProps", "Chroń rekwizyty")
	slib.setLang("gprotect", "pl", "spamprotection_protectProps_tooltip", "Dzięki temu rekwizyty będą chronione przed spamowaniem.")
	slib.setLang("gprotect", "pl", "spamprotection_protectEntities", "Chroń jednostki")
	slib.setLang("gprotect", "pl", "spamprotection_protectEntities_tooltip", "To ochroni jednostki przed pojawieniem się spamu.")
	
	slib.setLang("gprotect", "pl", "spawnrestriction_enabled", "Enabled")
	slib.setLang("gprotect", "pl", "spawnrestriction_enabled_tooltip", "Włączyć moduł spawnrestriction?")
	slib.setLang("gprotect", "pl", "spawnrestriction_propSpawnPermission", "Uprawnienia spawn Prop")
	slib.setLang("gprotect", "pl", "spawnrestriction_propSpawnPermission_tooltip", "Spowoduje to całkowite ograniczenie tworzenia się rekwizytów! (Dodaj tutaj grupy użytkowników, aby na nie zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "spawnrestriction_SENTSpawnPermission", "SENT spawn permissions")
	slib.setLang("gprotect", "pl", "spawnrestriction_SENTSpawnPermission_tooltip", "Spowoduje to całkowite ograniczenie spawnowania SENTS! (Dodaj tutaj grupy użytkowników, aby na nie zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "spawnrestriction_SWEPSpawnPermission", "Uprawnienia do spawnowania SWEP")
	slib.setLang("gprotect", "pl", "spawnrestriction_SWEPSpawnPermission_tooltip", "Spowoduje to całkowite ograniczenie tworzenia SWEP! (Dodaj tutaj grupy użytkowników, aby im zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "spawnrestriction_vehicleSpawnPermission", "Uprawnienia do odradzania pojazdów")
	slib.setLang("gprotect", "pl", "spawnrestriction_vehicleSpawnPermission_tooltip", "Spowoduje to całkowite ograniczenie pojawiających się pojazdów! (Dodaj tutaj grupy użytkowników, aby na nie zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "spawnrestriction_NPCSpawnPermission", "Uprawnienia do odradzania NPC")
	slib.setLang("gprotect", "pl", "spawnrestriction_NPCSpawnPermission_tooltip", "To całkowicie ograniczy pojawiające się NPC! (Dodaj tutaj grupy użytkowników, aby im zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "spawnrestriction_ragdollSpawnPermission", "Uprawnienia do spawn Ragdoll")
	slib.setLang("gprotect", "pl", "spawnrestriction_ragdollSpawnPermission_tooltip", "Spowoduje to całkowite ograniczenie tworzenia ragdoll! (Dodaj tutaj grupy użytkowników, aby im zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "spawnrestriction_effectSpawnPermission", "Uprawnienia do odradzania efektów")
	slib.setLang("gprotect", "pl", "spawnrestriction_effectSpawnPermission_tooltip", "Spowoduje to całkowite ograniczenie efektów odradzania! (Dodaj tutaj grupy użytkowników, aby na nie zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "spawnrestriction_blockedEntities", "Blocked SENTs")
	slib.setLang("gprotect", "pl", "spawnrestriction_blockedEntities_tooltip", "Umieść tutaj nazwy klas bytów, które nigdy nie powinny się pojawiać!")
	slib.setLang("gprotect", "pl", "spawnrestriction_blockedEntitiesIsBlacklist", "Zablokowane klasy to czarna lista")
	slib.setLang("gprotect", "pl", "spawnrestriction_blockedEntitiesIsBlacklist_tooltip", "Zaznaczenie tej opcji spowoduje, że klasy z listy będą blokowane przed tworzeniem, w przeciwnym razie możesz tworzyć tylko te klasy.")
	slib.setLang("gprotect", "pl", "spawnrestriction_blockedModels", "Zablokowane modele")
	slib.setLang("gprotect", "pl", "spawnrestriction_blockedModels_tooltip", "Umieść nazwy modeli, aby rekwizyty z nazwą modelu nie pojawiały się!")
	slib.setLang("gprotect", "pl", "spawnrestriction_blockedModelsisBlacklist", "Zablokowane modele to czarna lista")
	slib.setLang("gprotect", "pl", "spawnrestriction_blockedModelsisBlacklist_tooltip", "Zaznaczenie tej opcji spowoduje, że modele z listy zostaną zablokowane przed tworzeniem, w przeciwnym razie możesz tworzyć tylko te modele.")
	slib.setLang("gprotect", "pl", "spawnrestriction_bypassGroups", "Pomijaj grupy")
	slib.setLang("gprotect", "pl", "spawnrestriction_bypassGroups_tooltip", "Te grupy będą mogły pomijać zablokowane wysyłanie i modele.")
	slib.setLang("gprotect", "pl", "spawnrestriction_maxModelSize", "Maksymalny rozmiar modelu")
	slib.setLang("gprotect", "pl", "spawnrestriction_maxModelSize_tooltip", "Jeśli jest powyżej 0, spowoduje to usunięcie większych rekwizytów zaraz po ich pojawieniu się.")

	slib.setLang("gprotect", "pl", "toolgunsettings_enabled", "Włączone")
	slib.setLang("gprotect", "pl", "toolgunsettings_enabled_tooltip", "Włączyć moduł toolgunsettings?")
	slib.setLang("gprotect", "pl", "toolgunsettings_targetWorld", "Może kierować reklamy na obiekty świata")
	slib.setLang("gprotect", "pl", "toolgunsettings_targetWorld_tooltip", "Oznacza to, że mogą kierować reklamy na obiekty świata i rekwizyty! (Dodaj tutaj grupy użytkowników, aby im zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "toolgunsettings_targetPlayerOwned", "Może kierować reklamy na podmioty należące do gracza")
	slib.setLang("gprotect", "pl", "toolgunsettings_targetPlayerOwned_tooltip", "Oznacza to, że mogą kierować reklamy na elementy i rekwizyty graczy! (Dodaj tutaj grupy użytkowników, aby im zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "toolgunsettings_restrictTools", "Narzędzia z ograniczeniami")
	slib.setLang("gprotect", "pl", "toolgunsettings_restrictTools_tooltip", "Te narzędzia nie będą dostępne dla nikogo oprócz tych, które są w opcji bypassGroups poniżej.")
	slib.setLang("gprotect", "pl", "toolgunsettings_groupToolRestrictions", "Ograniczenia dotyczące narzędzi grupowych")
	slib.setLang("gprotect", "pl", "toolgunsettings_groupToolRestrictions_tooltip", "Konfiguruj ograniczenia narzędzi według narzędzia.")
	slib.setLang("gprotect", "pl", "toolgunsettings_entityTargetability", "Element docelowy")
	slib.setLang("gprotect", "pl", "toolgunsettings_entityTargetability_tooltip", "To jest fajne, aby ludzie mogli używać pistoletu narzędziowego tylko na przykład na swoich rekwizytach!")
	slib.setLang("gprotect", "pl", "toolgunsettings_bypassGroups", "Pomijaj grupy")
	slib.setLang("gprotect", "pl", "toolgunsettings_bypassGroups_tooltip", "Grupy tutaj będą omijać listę ograniczeń narzędzi z góry!")
	
	slib.setLang("gprotect", "pl", "physgunsettings_enabled", "Enabled")
	slib.setLang("gprotect", "pl", "physgunsettings_enabled_tooltip", "Włączyć moduł ustawień physgun?")
	slib.setLang("gprotect", "pl", "physgunsettings_targetWorld", "Może kierować na obiekty świata")
	slib.setLang("gprotect", "pl", "physgunsettings_targetWorld_tooltip", "Oznacza to, że mogą kierować reklamy na obiekty świata i rekwizyty! (Dodaj tutaj grupy użytkowników, aby im zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "physgunsettings_targetPlayerOwned", "Może kierować reklamy na podmioty należące do gracza")
	slib.setLang("gprotect", "pl", "physgunsettings_targetPlayerOwned_tooltip", "Oznacza to, że mogą kierować reklamy na elementy i rekwizyty graczy! (Dodaj tutaj grupy użytkowników, aby im zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "physgunsettings_DisableReloadUnfreeze", "Wyłącz ponowne ładowanie unreeze")
	slib.setLang("gprotect", "pl", "physgunsettings_DisableReloadUnfreeze_tooltip", "Zapobiegnie to odblokowywaniu rekwizytów przez przeładowanie.")
	slib.setLang("gprotect", "pl", "physgunsettings_PickupVehiclePermission", "Uprawnienie do odbioru pojazdu")
	slib.setLang("gprotect", "pl", "physgunsettings_PickupVehiclePermission_tooltip", "Jeśli ludzie znajdują się w grupach użytkowników na tej liście, mogą odbierać pojazdy!")
	slib.setLang("gprotect", "pl", "physgunsettings_StopMotionOnDrop", "Zatrzymaj ruch przy upuszczaniu")
	slib.setLang("gprotect", "pl", "physgunsettings_StopMotionOnDrop_tooltip", "Zapobiegnie to podsadzaniu / podsadzaniu.")
	slib.setLang("gprotect", "pl", "physgunsettings_maxDropObstructs", "Maksymalny próg obstrukcji")
	slib.setLang("gprotect", "pl", "physgunsettings_maxDropObstructs_tooltip", "To jest próg liczby obsctructów z czarnej listy do momentu wyzwolenia!")
	slib.setLang("gprotect", "pl", "physgunsettings_maxDropObstructsAction", "Maksymalne działanie wyzwalacza obstrukcji")
	slib.setLang("gprotect", "pl", "physgunsettings_maxDropObstructsAction_tooltip", "To jest sposób na zagrożenie wyzwalaczami (1 = Ghost, 2 = Freeze, 3 = Remove)")
	slib.setLang("gprotect", "pl", "physgunsettings_blockedEntities", "Zablokowane elementy")
	slib.setLang("gprotect", "pl", "physgunsettings_blockedEntities_tooltip", "Dodaj do tego elementy, a nikt, kto nie należy do grupy obejściowej, nie będzie mógł tego fizycznie przechwycić.")
	slib.setLang("gprotect", "pl", "physgunsettings_bypassGroups", "Pomijaj grupy")
	slib.setLang("gprotect", "pl", "physgunsettings_bypassGroups_tooltip", "Dodaj grupy użytkowników do tej listy, aby ominąć zablokowane elementy, * oznacza wszystkich!")

	slib.setLang("gprotect", "pl", "gravitygunsettings_enabled", "Enabled")
	slib.setLang("gprotect", "pl", "gravitygunsettings_enabled_tooltip", "Włączyć moduł ustawień pistoletu grawitacyjnego?")
	slib.setLang("gprotect", "pl", "gravitygunsettings_targetWorld", "Może kierować na obiekty świata")
	slib.setLang("gprotect", "pl", "gravitygunsettings_targetWorld_tooltip", "Oznacza to, że mogą kierować reklamy na obiekty świata i rekwizyty! (Dodaj tutaj grupy użytkowników, aby im zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "gravitygunsettings_targetPlayerOwned", "Może kierować reklamy na podmioty należące do gracza")
	slib.setLang("gprotect", "pl", "gravitygunsettings_targetPlayerOwned_tooltip", "Oznacza to, że mogą kierować reklamy na podmioty i rekwizyty graczy! (Dodaj tutaj grupy użytkowników, aby im zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "gravitygunsettings_DisableGravityGunPunting", "Wyłącz dziurkowanie działem grawitacyjnym")
	slib.setLang("gprotect", "pl", "gravitygunsettings_DisableGravityGunPunting_tooltip", "To jest rzucany atak pistoletu grawitacyjnego.")
	slib.setLang("gprotect", "pl", "gravitygunsettings_blockedEntities", "Zablokowane elementy")
	slib.setLang("gprotect", "pl", "gravitygunsettings_blockedEntities_tooltip", "Dodaj elementy do tego, a nikt, kto nie należy do grupy obejściowej, nie będzie mógł tego fizycznie przechwycić.")
	slib.setLang("gprotect", "pl", "gravitygunsettings_bypassGroups", "Pomijaj grupy")
	slib.setLang("gprotect", "pl", "gravitygunsettings_bypassGroups_tooltip", "Dodaj grupy użytkowników do tej listy, aby ominąć zablokowane elementy,„ * oznacza wszystkich!")
		
	slib.setLang("gprotect", "pl", "canpropertysettings_enabled", "Enabled")
	slib.setLang("gprotect", "pl", "canpropertysettings_enabled_tooltip", "Włączyć moduł ustawień właściwości can?")
	slib.setLang("gprotect", "pl", "canpropertysettings_targetWorld", "Może kierować na obiekty świata")
	slib.setLang("gprotect", "pl", "canpropertysettings_targetWorld_tooltip", "Oznacza to, że mogą kierować reklamy na obiekty świata i rekwizyty! (Dodaj tutaj grupy użytkowników, aby im zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "canpropertysettings_targetPlayerOwned", "Może kierować reklamy na podmioty należące do gracza")
	slib.setLang("gprotect", "pl", "canpropertysettings_targetPlayerOwned_tooltip", "Oznacza to, że mogą kierować reklamy na elementy i rekwizyty graczy! (Dodaj tutaj grupy użytkowników, aby im zezwolić, * oznacza wszystkich!)")
	slib.setLang("gprotect", "pl", "canpropertysettings_blockedProperties", "Zablokowane właściwości")
	slib.setLang("gprotect", "pl", "canpropertysettings_blockedProperties_tooltip", "Dodaj właściwości do tej listy")
	slib.setLang("gprotect", "pl", "canpropertysettings_blockedPropertiesisBlacklist", "Zablokowane właściwości to czarna lista")
	slib.setLang("gprotect", "pl", "canpropertysettings_blockedPropertiesisBlacklist_tooltip", "Zaznaczenie tej opcji spowoduje, że właściwości z listy nie będą mogły być używane, w przeciwnym razie możesz używać tylko tych właściwości.")
	slib.setLang("gprotect", "pl", "canpropertysettings_blockedEntities", "Zablokowane jednostki")
    slib.setLang("gprotect", "pl", "canpropertysettings_blockedEntities_tooltip", "Dodaj do tego elementy, a nikt poza osobami z grupy obejścia nie będzie mógł go kierować!")
	slib.setLang("gprotect", "pl", "canpropertysettings_bypassGroups", "Pomijaj grupy")
	slib.setLang("gprotect", "pl", "canpropertysettings_bypassGroups_tooltip", "Grupy w tym miejscu pomijają powyższą listę ograniczeń właściwości can!")
		
	slib.setLang("gprotect", "pl", "advdupe2_enabled", "Włączone")
	slib.setLang("gprotect", "pl", "advdupe2_enabled_tooltip", "Czy detekcje powinny powiadamiać personel? NB: Można to wykorzystać do wkurzenia pracowników.")
	slib.setLang("gprotect", "pl", "advdupe2_notifyStaff", "Powiadom personel")
	slib.setLang("gprotect", "pl", "advdupe2_notifyStaff_tooltip", "Czy detekcje powinny powiadamiać personel? NB: Można to wykorzystać do sikania pracowników.")
	slib.setLang("gprotect", "pl", "advdupe2_PreventRopes", "Zapobiegaj pojawianiu się liny")
	slib.setLang("gprotect", "pl", "advdupe2_PreventRopes_tooltip", "Zapobiegaj pojawianiu się lin! (1 = Zapobiegaj powstawaniu, 2 = Stwórz, ale napraw)")
	slib.setLang("gprotect", "pl", "advdupe2_PreventScaling", "Zapobiegaj skalowaniu")
	slib.setLang("gprotect", "pl", "advdupe2_PreventScaling_tooltip", "Zapobiegaj pojawianiu się zwiększonych rekwizytów. (1 = Zapobiegaj tworzeniu się, 2 = Stwórz, ale napraw)")
	slib.setLang("gprotect", "pl", "advdupe2_PreventNoGravity", "Zapobiegaj braku grawitacji")
	slib.setLang("gprotect", "pl", "advdupe2_PreventNoGravity_tooltip", "Zapobiegaj spawnowaniu rekwizytów bez grawitacji. (1 = Zapobiegaj tworzeniu się, 2 = Odradzaj, ale napraw)")
	slib.setLang("gprotect", "pl", "advdupe2_PreventUnfreezeAll", "Zapobiegaj odblokowaniu wszystkich")
	slib.setLang("gprotect", "pl", "advdupe2_PreventUnfreezeAll_tooltip", "Zapobiegaj odblokowywaniu wszystkich rekwizytów. (1 = Zapobiegaj tworzeniu się, 2 = Stwórz, ale napraw)")
	slib.setLang("gprotect", "pl", "advdupe2_BlacklistedCollisionGroups", "Grupy kolizji na czarnej liście")
	slib.setLang("gprotect", "pl", "advdupe2_BlacklistedCollisionGroups_tooltip", "Chroni to przed rekwizytami, na które nie możesz kierować. Uwaga: wartości muszą być kolizjami ENUM")
	slib.setLang("gprotect", "pl", "advdupe2_WhitelistedConstraints", "Biała lista ograniczeń")
	slib.setLang("gprotect", "pl", "advdupe2_WhitelistedConstraints_tooltip", "Ma to na celu zapobieżenie powstawaniu niechcianych ograniczeń.")

	slib.setLang("gprotect", "pl", "miscs_enabled", "Enabled")
	slib.setLang("gprotect", "pl", "miscs_enabled_tooltip", "Włączyć moduł miscs?")
	slib.setLang("gprotect", "pl", "miscs_ClearDecals", "Wyczyść licznik kalkomanii")
	slib.setLang("gprotect", "pl", "miscs_ClearDecals_tooltip", "Licznik czasu w sekundach, to wyczyści oznaczenia wszystkich graczy na liczniku :)")
	slib.setLang("gprotect", "pl", "miscs_NoBlackoutGlitch", "Zapobiegaj exploitom blackout")
	slib.setLang("gprotect", "pl", "miscs_NoBlackoutGlitch_tooltip", "Int to zapobiegnie exploitowi 'pp / copy' (1 = Notify, 2 = kick, 3 = ban).")
	slib.setLang("gprotect", "pl", "miscs_FadingDoorLag", "Zapobiegaj zanikaniu opóźnienia drzwi")
	slib.setLang("gprotect", "pl", "miscs_FadingDoorLag_tooltip", "Zapobiegnie to awariom serwera przy użyciu narzędzia fading door.")
	slib.setLang("gprotect", "pl", "miscs_DisableMotion", "Wyłącz ruch")
	slib.setLang("gprotect", "pl", "miscs_DisableMotion_tooltip", "Spowoduje to wyłączenie ruchu dla wszystkich obiektów na czarnej liście.")
	slib.setLang("gprotect", "pl", "miscs_freezeOnSpawn", "Zatrzymaj przy spawn")
	slib.setLang("gprotect", "pl", "miscs_freezeOnSpawn_tooltip", "To zamrozi rekwizyty przy spawn")
	slib.setLang("gprotect", "pl", "miscs_preventFadingDoorAbuse", "Zapobiegaj nadużyciom związanym z zanikaniem drzwi")
	slib.setLang("gprotect", "pl", "miscs_preventFadingDoorAbuse_tooltip", "Zapobiegnie to zasłanianiu ludzi w zanikających drzwiach")
	slib.setLang("gprotect", "pl", "miscs_preventSpawnNearbyPlayer", "Zapobiegaj spawnowaniu gracza w pobliżu")
	slib.setLang("gprotect", "pl", "miscs_preventSpawnNearbyPlayer_tooltip", "Jeśli ktoś jest bliżej miejsca odrodzenia niż ta wartość, nie spowoduje to odrodzenia rekwizytu (0 oznacza wyłączone)")
	slib.setLang("gprotect", "pl", "miscs_DRPEntForceOwnership", "Wymuś własność jednostek DarkRP")
    slib.setLang("gprotect", "pl", "miscs_DRPEntForceOwnership_tooltip", "Wymusi to własność podmiotów kupionych w menu F4")
end
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/plugins/sh_notify.lua:
return gluapack()()
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/plugins/cl_derma.lua:
//
/*
	Smart's Derma Script
	Date: 1/24/2018
	Time: 2:24pm
	Author: Smart Like My Shoe 
	Defines a bunch of functions that make my Derma life easier 
*/

///////////
// Vars 
///////////

local smart = {
	blur = Material( "pp/blurscreen" ),
	
	defaultFont = "Default",
	
	cornerRadius = 6,
	backGroundColor = Color(20, 20, 20, 200),
	panelColor = Color(30, 30, 30, 200),
	buttonTextColor = Color(255, 255, 255, 255),
	buttonColor = Color(100, 100, 100, 255),
	buttonColorHovered = Color(120, 120, 120, 255),
	buttonSuccessSound = "buttons/button3.wav",
	buttonErrorSound = "buttons/button2.wav",
	transitionDuration = 0.5,
};

/////////////
// Accessor methods 
/////////////

function smart:SetCornerRadius(radius)
	self.cornerRadius = radius;
end

function smart:SetBackgroundColor(color)
	self.backGroundColor = color;
end 

function smart:SetButtonTextColor(color)
	self.buttonTextColor = color;
end 

function smart:SetButtonColor(color)
	self.buttonColor = color;
end 

function smart:SetColorHovered(color)
	self.buttonColorHovered = color;
end 

function smart:SetSuccessSound(path)
	self.buttonSuccessSound = path;
end 

function smart:SetTransitionDuration(duration)
	self.transitionDuration = duration;
end

function smart:SetDefaultFont(font)
	self.defaultFont = font;
end

function smart:SetPanelColor(color)
	self.panelColor = color;
end

////////////
// Methods 
////////////

/*
	GenerateFont 
	Parameters: string
	Returns: void 
	Description: Calls surface.createfont method
*/
function smart:GenerateFont(name, font, size, weight)

	weight = weight || 500;

	surface.CreateFont(name, {
		font = font,
		extended = false,
		size = size,
		weight = weight,
		blursize = 0,
		scanlines = 0,
		antialias = true,
		underline = false,
		italic = false,
		strikeout = false,
		symbol = false,
		rotary = false,
		shadow = false,
		additive = false,
		outline = false,
	});
	
	if (self.defaultFont == "Default") then 
		self.defaultFont = name;
	end 
	print("Generating font", name, size)
end

/*
	Blur 
	Parameters: panel, integer, integer, integer 
	Returns: void 
	Description: Draws a nice blur effect 
*/

function smart:Blur(panel, layers, density, alpha)
	local x, y = panel:LocalToScreen(0, 0);

	surface.SetDrawColor(255, 255, 255, alpha);
	surface.SetMaterial(self.blur);

	for i = 1, 3 do
		self.blur:SetFloat("$blur", ( i / layers ) * density);
		self.blur:Recompute();
		render.UpdateScreenEffectTexture();
		surface.DrawTexturedRect(-x, -y, ScrW(), ScrH());
	end
end

/*
	Slide 
	Parameters: panel, integer, integer
	Returns: void 
	Description: Slides a panel to an absolute position over time (seconds)
*/
function smart:Slide(p, x, y)

	// Calculate differences 
	local pX, pY = p:GetPos();
	local diffX = x - pX;
	local diffY = y - pY;
	
	local startTime = CurTime();
	
	// Hook the think method to run our animation
	local oldThink = p.Think || function(_p) end;
	
	p.Think = function(_p)
		oldThink(p);
		
		local timeElapsed = CurTime() - startTime;
		local progress = (timeElapsed/self.transitionDuration);
		
		p:SetPos(pX + (diffX*progress), pY + (diffY*progress));
		
		if (progress >= 1) then // Unhook the think method
			p.Think = oldThink;
			p:SetPos(x, y);
		end
	end 
end 

/*
	Frame 
	Parameters: integer, integer, integer (optional), integer (optional), string (optional)
	Returns: panel
	Description: Generates a custom derma frame 
*/
function smart:Frame(x, y, width, height, title, closeButton)

	x = x || ScrW()/2-width/2;
	y = y || ScrH()/2-height/2;
	title = title || "";
	if (closeButton == nil) then 
		closeButton = true;
	end

	local frame = vgui.Create("DFrame");
	frame:SetSize(width, height);
	frame:SetPos(x, y);
	frame:ShowCloseButton(false);
	frame:SetDraggable(false);
	frame:SetTitle(title);
	frame._x = x;
	frame._y = y;
	frame.Paint = function(p)
		self:Blur(frame, 1, 2, 255);
		draw.RoundedBox(self.cornerRadius, 0, 0, p:GetWide(), p:GetTall(), self.backGroundColor);
	end
	
	if (closeButton) then 
		frame.close = vgui.Create("DImageButton");
		frame.close:SetParent(frame);
		frame.close:SetIcon("icon16/cancel.png");
		frame.close:SetPos(frame:GetWide() - 21, 5);
		frame.close:SetSize(16, 16);
		frame.close.DoClick = function(p)
			
			surface.PlaySound(self.buttonSuccessSound);
			frame.Dismiss();
		end
	end
	
	frame.Request = function(x2, y2, x3, y3)
		
		local centerX = ScrW() / 2 - frame:GetWide() / 2;
		local centerY = ScrH() / 2 - frame:GetTall() / 2;
		
		x2 = x2 || centerX;
		y2 = y2 || -frame:GetTall();
		x3 = x3 || centerX;
		y3 = y3 || centerY;
		
		frame:SetPos(x2, y2);
		self:Slide(frame, x3, y3);
	end
	
	frame.Dismiss = function(x2, y2)
		x2 = x2 || x;
		y2 = y2 || ScrH();
		
		self:Slide(frame, x2, y2);
		timer.Simple(self.transitionDuration, function()
			if (IsValid(frame)) then 
				frame:Close();
			end
		end);
	end
	
	return frame;
end

/*
	Panel 
	Parameters: int, int 
	Returns: panel 
*/
function smart:Panel(w, h)

	local panel = vgui.Create("DPanel");
	panel:SetSize(w, h);
	panel.Paint = function(s)
	
		draw.RoundedBox(self.cornerRadius, 0, 0, s:GetWide(), s:GetTall(), self.panelColor);
	end
	
	return panel;
end

/*
	List 
	Parameters: panel (optional), boolean (optional)
	Returns: panel 
*/
function smart:List(parent, bHorizontal)

	bHorizontal = bHorizontal || false;
	
	local dList = vgui.Create("DPanelList");
	dList:SetSpacing(2);
	dList:EnableVerticalScrollbar(true);
	dList:EnableHorizontal(bHorizontal);
	
	if (parent) then 
		dList:SetParent(parent);
		dList:SetPos(5, 25);
		dList:SetSize(parent:GetWide() - 10, parent:GetTall() - 30);
	end 
	
	return dList;
end

/*
	CollapsibleCategoryList
	Parameters: int, int
	Returns: panel 
*/
function smart:CollapsibleCategoryList(w, h, color)

	color = color || Color(20, 20, 20, 255);

	local cat = vgui.Create("DCollapsibleCategory");
	cat:SetWide(w);
	cat.Paint = function() end
	cat.Header:SetFont(self.defaultFont);
	cat.Header.Paint = function(s)
		draw.RoundedBox(4, 0, 0, s:GetWide(), s:GetTall(), color);
	end
	
	local internalList = self:List(nil, false);
	
	cat.internalList = internalList;
	cat:SetContents(internalList);
	
	cat.AddItem = function(s, p)
		internalList:AddItem(p);
	end
	
	return cat;
end

/*
	Button
	Parameters: string, function 
	Returns: panel
*/
function smart:Button(text, func)

	func = func || function() end

	local button = vgui.Create("DButton");
	button:SetText(text);
	button:SetTextColor(self.buttonTextColor);
	button.DoClick = function() 
		surface.PlaySound(self.buttonSuccessSound);
		func();
	end
	button.Paint = function(p)
		
		local color;
		if (button:IsHovered()) then 
			color = self.buttonColorHovered;
		else
			color = self.buttonColor;
		end 
		
		local highLightColor = Color(color.r + 5, 
									color.g + 5,
									color.b + 5,
									color.a);
									
		local highLightCornerRadius = self.cornerRadius - 2;
		if (highLightCornerRadius < 0) then 
			highLightCornerRadius = 0;
		end
									
		draw.RoundedBox(self.cornerRadius, 0, 0, p:GetWide(), p:GetTall(), color);
		draw.RoundedBox(highLightCornerRadius, 0, 0, p:GetWide(), p:GetTall()/2, highLightColor);
	end 

	return button;
end

/*
	Label 
	Parameters: string, string 
	Return: panel 
*/
function smart:Label(text, font, color)

	color = color || Color(255,255,255,255);

	local lab = vgui.Create("DLabel");
	lab:SetFont(font);
	lab:SetText(text);
	lab:SetTextColor(color);
	lab:SizeToContents();
	
	return lab;
end

/*
	SpawnIcon
	Parameters: string 
	Return: panel
*/
function smart:SpawnIcon(model, size)

	local spawnIcon = vgui.Create("SpawnIcon");
	spawnIcon:SetModel(model);
	spawnIcon:SetSize(size, size);
	
	/* Unneccesary?
	if (self.BuiltSpawnIcons[model] == nil) then
		spawnIcon:RebuildSpawnIcon();
		self.BuiltSpawnIcons[model] = true;
	end
	*/
	
	return spawnIcon;
end


/*
	DPropertySheet 
	Parameters: void 
	Return: panel
*/
function smart:PropertySheet()

	local propertySheet = vgui.Create("DPropertySheet");
	propertySheet.Paint = function(s)
		draw.RoundedBox(0, 0, 0, s:GetWide(), s:GetTall(), Color(0, 0, 0, 200));
	end
	
	propertySheet.DoPaintSetup = function(s)
	
		for k, v in pairs(s.Items) do
			if (!v.Tab) then 
				continue;
			end
		
			v.Tab.Paint = function(self,w,h)
		
				if (s:GetActiveTab() == v.Tab) then 
					draw.RoundedBox(4, 0, 0, w, h-5, Color(80, 80, 80, 200));
				else 
			
					draw.RoundedBox(4, 0, 0, w, h, Color(50, 50, 50, 200));
				end
			end
		end
	end 
	
	return propertySheet;
end

/*
	Dropdown sheet
	Parameters: void 
	Return: panel
*/
function smart:DropDownSheet(txt, options, defaultOption, width, height, onSelectOption)

	local parent = vgui.Create("DPanel");
	parent:SetSize(width, height);
	parent.Paint = function() end

	local lab = self:Label(txt, "Trebuchet18");
	lab:SetPos(0, 0);
	lab:SetParent(parent);
	lab:SizeToContents();

	local combo = vgui.Create("DComboBox", parent);
	combo:SetSize(100, 20);
	combo:SetPos(width - 140, 0);
	combo.OnSelect = onSelectOption;

	for k,v in next, options do 
		combo:AddChoice(v);
	end

	combo:SetText(options[defaultOption]);

	return parent;
end

/*
	Notification
	Parameters: string, int 
	Return: Panel
*/
local iconMaterial = Material("icon16/exclamation.png");
function smart:Notification(text, duration, index)
	
	local label = self:Label(text, "Trebuchet24");
	local width = label:GetWide() + 31;
	local height = label:GetTall() + 5;
	
	local x = ScrW() - width;
	local y = ScrH() / 2 - height / 2 + index * height;
	
	local frame = self:Frame(x, y, width, height, "", false);
	label:SetParent(frame);
	label:SetPos(21, 2.5);
	
	local iconMat
	local icon = vgui.Create("DPanel", frame);
	icon:SetPos(3, height/2 - 8);
	icon:SetSize(16, 16);
	icon.Paint = function()
		
		surface.SetDrawColor(color_white);
		surface.SetMaterial(iconMaterial);
		surface.DrawTexturedRect(0, 0, icon:GetWide(), icon:GetTall());
	end
	
	frame.Request(ScrW(), y, x, y); 
	
	timer.Simple(duration, function()
		frame.Dismiss(ScrW(), y);
	end);
end

/*
	NumSlider
	Parameters: Int, Int, Int, String
*/
function smart:NumSlider(min, max, decimals, conVar)

	local dSlider = vgui.Create("DNumSlider");
	dSlider:SetMin(min);
	dSlider:SetMax(max);
	dSlider:SetDecimals(decimals);
	if (conVar != nil) then 
		dSlider:SetConVar(conVar);
	end
	
	dSlider.Label:SetFont("Trebuchet18");
	dSlider.Label:SetTextColor(Color(255, 255, 255, 255));
	
	dSlider.Slider.Knob.Paint = function(self, w, h)
		draw.RoundedBox(6, 0, 0, w, h, Color(80, 80, 80, 255));
	end
	dSlider.Slider.Paint = function(self, w, h)
		draw.RoundedBox(6, 0, 0, w, h, Color(255, 255, 255, 100));
	end
	dSlider.TextArea.Paint = function(self)
		draw.SimpleText(self:GetText(), "Trebuchet18", 6, 3, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT);
	end
	
	return dSlider;
end

/*
	Graph Plot Point 
	Parameters: String
*/
function smart:PlotPoint(txt)
	
	local tLab = self:Label(txt, "Trebuchet18", color_black);

	local point = self:Panel();
	point:SetSize(8, 8);
	point.Paint = function(s)
		draw.RoundedBox(2, 0, 0, s:GetWide(), s:GetTall(), Color(255, 255, 255, 200));
	end
	
	point:SetTooltipPanel(tLab);
	
	return point;
end

/*
	Line Graph
	Parameters: String, String, Int, Int, Int, Table, Int, Int
*/
function smart:LineGraph(title, xAxisLabel, w, h, axisPadding, dataPoints, xInterval, yInterval)
	
	local plottedPoints = {};
	local thresholds = {};
	
	local graph = self:Panel()
	graph:SetSize(w, h);
	graph.Paint = function(s) 
	
		local yOrigin = s:GetTall();
		local yPadded = yOrigin - axisPadding;

		surface.SetDrawColor(color_white);
		surface.DrawLine(axisPadding, yPadded, s:GetWide(), yPadded); // X Axis
		surface.DrawLine(axisPadding, yPadded, axisPadding, 0); // Y Axis
		
		// X Axis Label 
		draw.SimpleText(xAxisLabel, "Trebuchet18", s:GetWide()/2, s:GetTall() - axisPadding - 5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	
		
		local maxX = #dataPoints;
		//local minX = 0;
		local maxY = math.Round(math.max(unpack(dataPoints)));
		local minY = math.Round(math.min(unpack(dataPoints)));
		
		local diffY = math.max((maxY - minY) + yInterval, yInterval);	
		local scaleX = w / 10;
		local scaleY = (h-axisPadding*2) / diffY;
		
		local xCounter = 0;
		for x = maxX - 10, maxX do // Draw the numbers on the x axis
			
			if (x < 0) then continue end
		
			local text = tostring(x * xInterval);
			draw.SimpleText(text, "Trebuchet18", axisPadding + scaleX * xCounter, yPadded + 10, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
			
			xCounter = xCounter + 1;
		end
	
		for y = minY, diffY, yInterval do // Draw the text along the y axis
			local text = tostring(y);
			draw.SimpleText(text, "Trebuchet18", axisPadding - 12, yPadded - y * scaleY, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		end
		
		// Plots the line graph 
		surface.SetDrawColor(color_white);
		xCounter = 0;
		for x = maxX - 10, maxX do 
			local y1 = dataPoints[x];
			local y2 = dataPoints[x + 1];
			if (!y1 || !y2) then continue end 
		
			local y1Unscaled = y1;
			y1 = y1 * scaleY;
			y2 = y2 * scaleY;
			local x1 = axisPadding + scaleX * xCounter;
			local x2 = axisPadding + scaleX * (xCounter + 1);
			
			surface.DrawLine(x1, yPadded - y1, x2, yPadded - y2);
			
			if (plottedPoints[x] == nil) then 
					
				local point = self:PlotPoint(tostring(math.Round(y1Unscaled)));
				point:SetParent(graph);
				point:SetPos(x1 - point:GetWide()/2, (yPadded - y1) - point:GetTall()/2);
				plottedPoints[x] = true;
			end
			
			
			xCounter = xCounter + 1;
		end
		
		// Plot thresholds 
		for k,v in next, thresholds do 
		
			if (diffY > v.y) then 
				
				local y = yPadded - v.y * scaleY;
				surface.SetDrawColor(v.color);
				surface.DrawLine(axisPadding, y, w, y);
				draw.SimpleText(tostring(v.y) .. " - " .. v.text, "Trebuchet18", w/2, y - 7, v.color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
			end
		end
		
		// Draw title 
		draw.SimpleText(title, "Trebuchet18", w/2, 10, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
	end
	
	function graph:AddThreshold(y, text, color)
	
		thresholds[#thresholds+1] = {
			y = y,
			text = text,
			color = color,
		};
	end
	
	return graph;
end

return smart;
--PATH lua/autorun/soldier_addon.lua:
player_manager.AddValidModel( "Pirate soldier", "models/player/ohanak_gang/pm_pirate_soldier.mdl" );
list.Set( "PlayerOptionsModel",  "Pirate soldier", "models/player/ohanak_gang/pm_pirate_soldier.mdl" );


--PATH addons/[misc] sreward_1.6.31/lua/s_reward/core/sh_sreward.lua:
sReward.config["indexToName"] = {} --- Ignore this! Used for optimization.

sReward.RegisterReward = function(name, func, ico)
    sReward.Rewards = sReward.Rewards or {}
    sReward.Rewards[name] = SERVER and func or ico or true
end

sReward.HasPermission = function(ply, perm)
    if !IsValid(ply) then return false end
    
    return (CAMI and isfunction(CAMI.PlayerHasAccess) and CAMI.PlayerHasAccess(ply, perm, function() end)) or (sReward.config["permissions"][perm] and sReward.config["permissions"][perm][ply:GetUserGroup()])
end

timer.Simple(3, function()
    if !CAMI then return end

    for k,v in pairs(sReward.config["permissions"]) do
        CAMI.RegisterPrivilege({Name = k, hasAccess = false, callback = function() end})
    end
end)
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/modules/sh_playtime.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_coupon.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_essentialpacks.lua:
sReward.RegisterReward("essentials_level", function(ply, levels)
    if !isfunction(ply.AddLevel) then return end
    ply:AddLevel(levels)
end, Material("sreward/level-up.png", "smooth"))

sReward.RegisterReward("essentials_xp", function(ply, xp)
    if !isfunction(ply.AddExperience) then return end
    ply:AddExperience(xp, "")
end)
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_vrondakisleveling.lua:
return gluapack()()
--PATH lua/autorun/streamradio_loader.lua:
return gluapack()()
--PATH lua/streamradio_core/_include.lua:
return gluapack()()
--PATH lua/streamradio_core/string.lua:
return gluapack()()
--PATH lua/streamradio_core/string.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.String = StreamRadioLib.String or {}
local LIB = StreamRadioLib.String

local table = table
local table_insert = table.insert

function LIB.NormalizeNewlines(text, nl)
	nl = tostring(nl or "")
	text = tostring(text or "")

	local replacemap = {
		["\r\n"] = true,
		["\r"] = true,
		["\n"] = true,
	}

	if not replacemap[nl] then
		nl = "\n"
	end

	replacemap[nl] = nil

	for k, v in pairs(replacemap) do
		replacemap[k] = nl
	end

	text = string.gsub(text, "([\r]?[\n]?)", replacemap)

	return text
end

function LIB.IndentTextBlock(text, count, tab)
	text = tostring(text or "")
	tab = tostring(tab or "")
	count = count or 0

	if text == "" then
		return ""
	end

	if tab == "" then
		tab = "    "
	end

	if count <= 0 then
		tab = ""
	else
		tab = string.rep(tab, count)
	end

	local lines = string.Explode("\n", text, false)
	local tmp = {}

	for i, v in ipairs(lines) do
		table_insert(tmp, tab)
		table_insert(tmp, v)
		table_insert(tmp, "\n")
	end

	text = table.concat(tmp)

	return text
end

function LIB.IsVirtualPath(vpath)
	vpath = vpath or ""

	if vpath == "" then
		return false
	end

	if not string.match(vpath, "^%:") then
		return false
	end

	return true
end

local g_sanitized_filenames_cache = {}
local g_sanitized_filepaths_cache = {}

function LIB.SanitizeFilename(filenameInput)
	filenameInput = tostring(filenameInput or "")

	if filenameInput == "" then
		return ""
	end

	if g_sanitized_filenames_cache[filenameInput] then
		return g_sanitized_filenames_cache[filenameInput]
	end

	g_sanitized_filenames_cache[filenameInput] = nil

	local filename = LIB.NormalizeSlashes(filenameInput)

	filename = string.gsub(filename, "%:", '-')
	filename = string.gsub(filename, "%/", '-')

	filename = LIB.SanitizeFilepath(filename)

	g_sanitized_filenames_cache[filenameInput] = filename
	g_sanitized_filenames_cache[filename] = filename

	return filename
end

local g_invalidReplaceMap = {
	["*"] = "-",
	[":"] = "-",
	["?"] = "-",
	[">"] = "-",
	["<"] = "-",
	["|"] = "-",
	["´"] = "-",
	["`"] = "-",
	["~"] = "-",
	["'"] = "-",
	['"'] = "-",
	['#'] = "-",
}

function LIB.SanitizeFilepath(filepathInput)
	filepathInput = tostring(filepathInput or "")

	if filepathInput == "" then
		return ""
	end

	if g_sanitized_filepaths_cache[filepathInput] then
		return g_sanitized_filepaths_cache[filepathInput]
	end

	g_sanitized_filepaths_cache[filepathInput] = nil

	local filepath = LIB.NormalizeSlashes(filepathInput)

	if LIB.IsVirtualPath(filepath) then
		g_sanitized_filepaths_cache[filepathInput] = filepath
		g_sanitized_filepaths_cache[filepath] = filepath

		return filepath
	end

	filepath = string.Trim(filepath)

	filepath = LIB.StripAccents(filepath, true)

	filepath = string.gsub(filepath, ".", g_invalidReplaceMap)

	filepath = string.gsub(filepath, "[^%g%s]", '')
	filepath = string.Trim(filepath)

	filepath = string.gsub(filepath, "%s+", '_')
	filepath = string.lower(filepath)

	g_sanitized_filepaths_cache[filepathInput] = filepath
	g_sanitized_filepaths_cache[filepath] = filepath

	return filepath
end

function LIB.NormalizeSlashes(filepath)
	filepath = tostring(filepath or "")

	if filepath == "" then
		return ""
	end

	filepath = string.gsub(filepath, "[%/%\\]+", '/')
	filepath = string.gsub(filepath, "%.%.%/", '/')
	filepath = string.gsub(filepath, "%.%/", '/')
	filepath = string.gsub(filepath, "%/+", '/')

	return filepath
end

function LIB.IsValidFilepath(filepath)
	filepath = tostring(filepath or "")
	filepath = LIB.NormalizeSlashes(filepath)
	filepath = string.lower(filepath)
	filepath = string.Trim(filepath)

	local sanitizeFilepath = LIB.SanitizeFilepath(filepath)
	if sanitizeFilepath ~= filepath then
		return false
	end

	return true
end

function LIB.IsValidFilename(filename)
	filename = tostring(filename or "")
	filename = string.lower(filename)
	filename = string.Trim(filename)

	local sanitizeFilename = LIB.SanitizeFilename(filename)
	if sanitizeFilename ~= filename then
		return false
	end

	if string.Trim(string.StripExtension(" " .. filename) or "") == "" then
		return false
	end

	return true
end

function LIB.StreamMetaStringToTable(meta)
	meta = tostring(meta or "")
	meta = string.Trim(meta or "")

	local result = {}

	for k, v in string.gmatch(meta, "([%w_]+)%s*=%s*([^;]*)[;]?") do
		k = string.lower(k)
		if k == "" then
			continue
		end

		v = string.gsub(v, "^'(.*)'$", "%1")
		v = string.Trim(v or "")

		result[k] = v
	end

	return result
end

return true


--PATH lua/streamradio_core/convar.lua:
return gluapack()()
--PATH lua/streamradio_core/language.lua:
return gluapack()()
--PATH lua/streamradio_core/lib.lua:
return gluapack()()
--PATH lua/streamradio_core/enum.lua:
return gluapack()()
--PATH lua/streamradio_core/models.lua:
return gluapack()()
--PATH lua/streamradio_core/models/hl2_radio.lua:
return gluapack()()
--PATH lua/streamradio_core/models/hl2_radio.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- HL2 Citizen Radio
RADIOMDL.model = "models/props_lab/citizenradio.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(8.6, 0, 7.4)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                               --     F,     R,     U
RADIOMDL.DisplayOffset    = Vector(8.60, -5.65, 15.25) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(8.60, 11.15, 11.82) -- Bottom Right

RADIOMDL.DisplayWidth = 1337
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(
	RADIOMDL.DisplayOffset,
	RADIOMDL.DisplayOffsetEnd,
	RADIOMDL.DisplayWidth,
	RADIOMDL.DISPLAY_POS_FRONT
)


RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {23,	1000},
	Error	= {17,	700},
	Default	= {22,	700},
	Tooltip	= {22,	1000},
	Big		= {23,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Error)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Error)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Error)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Error)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 35)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 35)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 3, y = 4})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 4})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 3
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/hl2_speaker.lua:
return gluapack()()
--PATH lua/streamradio_core/models/plasma_tv.lua:
return gluapack()()
--PATH lua/streamradio_core/models/sw_ghettoblaster.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- SligWolf's Ghetto Blaster
RADIOMDL.model = "models/sligwolf/grocel/radio/ghettoblaster.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(1.5, 0, 4.5)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,     R,    U
RADIOMDL.DisplayOffset    = Vector(1.85, -6.48, 9.18) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(1.85,  6.48, 4.92) -- Bottom Right

RADIOMDL.DisplayWidth = 768
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)


RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {20,	1000},
	Default	= {19,	700},
	Tooltip	= {15,	800},
	Big		= {22,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 4})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 4})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

function RADIOMDL:Initialize(ent)
	if CLIENT then
		ent:InvalidateBoneCache()
		return
	end

	if ent._mdl_skinset then return end

	local color = ColorRand()
	ent:SetColor( color )

	ent._mdl_skinset = true
end

function RADIOMDL:AnimReset(ent)
	if SERVER then return end

	ent:SetPoseParameter("speakers", 0)
	ent:InvalidateBoneCache()
end

function RADIOMDL:WhileLoading(ent)
	if SERVER then return end

	ent:SetPoseParameter("speakers", 0)
	ent:InvalidateBoneCache()
end

RADIOMDL.SpeakerMinFRQ = 20
RADIOMDL.SpeakerMaxFRQ = 2000
RADIOMDL.SpeakerFRQResolution = 12

function RADIOMDL:Speaker(ent, speakerlevel)
	if SERVER then return end

	speakerlevel = speakerlevel or 0

	local soundlevel = 0

	if IsValid(ent.StreamObj) then
		soundlevel = ent.StreamObj:GetAverageLevel() ^ 0.25
	end

	local vol = ent:GetVolume()

	speakerlevel = speakerlevel * vol * 1.5 * soundlevel
	speakerlevel = math.Clamp(speakerlevel, -1, 1)

	ent:SetPoseParameter("speakers", speakerlevel)
	ent:InvalidateBoneCache()
end

return true


--PATH lua/streamradio_core/models/wire_speaker1.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Wire Speaker 1
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=160250458
RADIOMDL.model = "models/cheeze/wires/speaker.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false

return true


--PATH lua/streamradio_core/models/wire_speaker3.lua:
return gluapack()()
--PATH lua/streamradio_core/models/wire_subwoofer_small.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/base.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local LIBUtil = StreamRadioLib.Util

local emptyTableSafe = LIBUtil.EmptyTableSafe

function CLASS:Create()
	self.Valid = true
	self._cache = {}
	self.Name = ""

	StreamRadioLib.Timedcall(function()
		if not self.Valid then return end
		if self._markedforremove then return end

		self.Created = true

		if self.Initialize then
			self:Initialize()
		end
	end)
end

function CLASS:Initialize()
	-- override me
end

function CLASS:Remove()
	self._markedforremove = true
	self:CallHook("OnRemove")

	StreamRadioLib.Timedcall(function()
		if not self then
			return
		end

		self.Valid = false
		self.Created = false

		emptyTableSafe(self._cache)
	end)
end

function CLASS:IsValid()
	return self.Valid or false
end

function CLASS:GetName()
	return self.Name or ""
end

function CLASS:SetName(name)
	name = tostring(name or "")
	name = string.gsub(name, "[%/%s]", "_")

	self.Name = name
end

function CLASS:GetCacheValue(key)
	return self._cache[tostring(key or "")]
end

function CLASS:GetCacheValues(key)
	local value = self:GetCacheValue(key)
	if not value then return nil end
	return unpack(value)
end

function CLASS:SetCacheValue(key, value)
	self._cache[tostring(key or "")] = value
	return value
end

function CLASS:SetCacheValues(key, ...)
	local args = {...}
	self:SetCacheValue(key, args)
	return unpack(args)
end

function CLASS:DelCacheValue(key)
	self._cache[tostring(key or "")] = nil
end

function CLASS:GetFunction(name)
	if isfunction(name) then
		return name
	end

	name = tostring(name or "")

	local func = self[name]
	if not isfunction(func) then
		return nil
	end

	return func
end

function CLASS:CallHook(name, ...)
	local func = self:GetFunction(name)
	if not func then
		return nil
	end

	return func(self, ...)
end

local g_string_format = string.format

function CLASS:_ToStringFailback()
	local classname = self.classname
	if not classname then
		classname = "!unknown_class!"
	end

	if not self.Valid then
		return g_string_format("[%s][removed]", classname)
	end

	local id = self.ID
	if not id then
		return g_string_format("[%s][unknown_id]", classname)
	end

	local name = self.Name or ""
	if name == "" then
		return g_string_format("[%s][%i]", classname, id)
	end

	return g_string_format("[%s][%i][%s]", classname, id, name)
end

function CLASS:ToString()
	return self:_ToStringFailback()
end

function CLASS:__tostring()
	local called = self._tostringcall
	if called then
		return self:_ToStringFailback()
	end

	self._tostringcall = true
	local _, result = pcall(self.ToString, self)
	self._tostringcall = nil

	local r = result or self:_ToStringFailback()
	return r
end

function CLASS:__gc()
	if not self.Valid then return end
	self:Remove()
end

function CLASS:__eg(other)
	if not other then return false end
	return self:GetID() ~= other:GetID()
end

return true


--PATH lua/streamradio_core/classes/ui/panel.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local LIBUtil = StreamRadioLib.Util

local emptyTableSafe = LIBUtil.EmptyTableSafe

local BASE = CLASS:GetBaseClass()

function CLASS:AssignToListenGroup()
	local superparent = self:GetSuperParent()

	if IsValid(superparent) and superparent ~= self then
		local group = superparent:AssignToListenGroup()

		if group then
			return group
		end
	end

	local group = tonumber(self:GetGlobalVar("gui_controller_listengroup")) or self:GetID()
	return group
end

function CLASS:Create()
	BASE.Create(self)

	self.Pos = self:CreateListener({
		x = 0,
		y = 0,
	}, function()
		self:InvalidateLayout(true)
		self:CallHook("OnPositionChanged")
	end)

	self.Size = self:CreateListener({
		w = 0,
		h = 0,
	}, function()
		self:InvalidateLayout(true)
		self:CallHook("OnResize")
	end)

	local updateothers = function(this, panel)
		if panel == self then return end
		panel:InvalidateLayout(false, true)
	end

	local recache = function(this)
		emptyTableSafe(this._ChildrenPanelsSorted)

		this:DelCacheValue("IsVisible")
		this:DelCacheValue("GetClickPanel")
		this:DelCacheValue("GetPanelsAtCursor")
		this:DelCacheValue("GetTopmostPanelAtCursor")
	end

	self.SkinMap = {}

	self.Layout = self:CreateListener({
		Disabled = false,
		Padding = 0,
		Margin = 5,
		ZIndex = 0,
		Visible = true,
		PaintBackground = true,
		Tooltip = "",
	}, function(this, k, v)
		self:InvalidateLayout()

		if k == "Disabled" then
			if v then
				self:ReleaseClick()
			end
		end

		if k == "ZIndex" or k == "Visible" then
			recache(self)

			local parent = self:GetParent()
			if not IsValid(parent) then return end

			recache(parent)
			parent:ForEachChild(updateothers)
		end

		if k == "Visible" then
			if v then
				self:ApplyNetworkedMode()

				self:CallHook("OnOpen")
				self:StartListenRecursive()
			else
				self:CallHook("OnClose")
				self:ReleaseClick()
				self:StopListenRecursive()
			end
		end

		if k == "Tooltip" then
			self:UpdateTooltip(v)
		end
	end)

	self._ChildrenPanels = {}
	self._ChildrenPanelsSorted = {}

	self.Parent = nil
	self.SuperParent = self

	self.Clickable = true
	self.IsPressed = false
	self.SkinAble = false

	self.SkinMap["color"] = {
		set = "SetColor",
		get = "GetColor",
	}

	if CLIENT then
		self.Colors = self:CreateListener({
			Main = Color(255,255,255),
			DrawAlpha = 1,
		}, function(...)
			self:QueueCall("PerformRerender")
		end)
	end

	self:Clear()
	self:InvalidateLayout()
end

function CLASS:Initialize()
	BASE.Initialize(self)

	self:DelCacheValue("GetAbsolutePos")
	self:DelCacheValue("GetRenderPos")
	self:DelCacheValue("IsVisible")
	self:DelCacheValue("GetClickPanel")
	self:DelCacheValue("GetPanelsAtCursor")
	self:DelCacheValue("GetTopmostPanelAtCursor")

	self:ApplyHierarchy()
end

function CLASS:Remove(childmode)
	self:ForEachChild(function(this, panel)
		panel:Remove(true)
	end)

	emptyTableSafe(self._ChildrenPanels)
	emptyTableSafe(self._ChildrenPanelsSorted)

	if childmode then
		BASE.Remove(self)
		return
	end

	self:SetParent(nil)
	BASE.Remove(self)
end

function CLASS:InvalidateLayout(layoutnow, nochildren)
	if layoutnow then
		self:PerformLayout(nochildren)
		return
	end

	self:QueueCall("PerformLayout", nochildren)
end

function CLASS:PerformRerender(force)
	if not force and not self._rendered then return end
	self._rendered = false

	self:GetSuperParent():CallHook("OnContentChanged")
end

local function CursorChangedInternalFunc(this, panel)
	if not panel.Clickable then return end
	if not panel:IsVisible() then return end
	panel:CursorChangedInternal()
end

function CLASS:CursorChangedInternal(nochildren)
	self:DelCacheValue("IsVisible")
	self:DelCacheValue("GetClickPanel")
	self:DelCacheValue("GetPanelsAtCursor")
	self:DelCacheValue("GetTopmostPanelAtCursor")

	self:_OpenTooltipPanel()

	if nochildren then return end

	if not self:IsCursorInBounds() or not self.Clickable or not self:IsVisible() then
		self._CursorChangedInternalOutCount = (self._CursorChangedInternalOutCount or 0) - 1

		if self._CursorChangedInternalOutCount <= 0 then
			return
		end
	else
		self._CursorChangedInternalOutCount = 2
	end

	self:ForEachChild(CursorChangedInternalFunc)
end

local function PerformLayoutFunc(this, panel)
	panel:InvalidateLayout(true)
end

function CLASS:PerformLayout(nochildren)
	self:DelCacheValue("GetAbsolutePos")
	self:DelCacheValue("GetRenderPos")
	self:DelCacheValue("IsVisible")
	self:DelCacheValue("GetClickPanel")
	self:DelCacheValue("GetPanelsAtCursor")
	self:DelCacheValue("GetTopmostPanelAtCursor")

	self:ForEachChild(PerformLayoutFunc)
	self:CursorChangedInternal(true)
	self:PerformRerender(true)

	self:DelCacheValue("GetAbsolutePos")
	self:DelCacheValue("GetRenderPos")
	self:DelCacheValue("IsVisible")
	self:DelCacheValue("GetClickPanel")
	self:DelCacheValue("GetPanelsAtCursor")
	self:DelCacheValue("GetTopmostPanelAtCursor")

	self:CallHook("OnPerformLayout")
end

local function RenderInternalPanel(this, panel)
	if not panel._RenderInternal then return end
	panel:_RenderInternal()
end

function CLASS:_RenderInternal()
	if SERVER then return end
	if not self.Valid then return end

	if not self:IsVisibleSimple() then
		self._rendered = true
		return
	end

	local currentRenderAlpha = surface.GetAlphaMultiplier()
	local drawAlpha = self:GetDrawAlpha()
	local alpha = drawAlpha * currentRenderAlpha
	local isTransparent = drawAlpha < 1

	if isTransparent then
		surface.SetAlphaMultiplier(alpha)
	end

	if self:GetPaintBackground() then
		self:Render()
	end

	self:ForEachChild(RenderInternalPanel, true)

	if isTransparent then
		surface.SetAlphaMultiplier(currentRenderAlpha)
	end

	self._rendered = true
end

local g_colDebug = Color(0,0,0,200)

function CLASS:Render()
	if not self.debugborders then return end

	local x, y = self:GetRenderPos()
	local w, h = self:GetSize()

	surface.SetDrawColor( g_colDebug:Unpack() )
	surface.DrawOutlinedRect(x, y, w, h)
	surface.DrawOutlinedRect(x + 1, y + 1, w - 2, h - 2)
end

local function StartListenRecursiveFunc(this, panel)
	panel:StartListenRecursive()
end

local function StopListenRecursiveFunc(this, panel)
	panel:StopListenRecursive()
end

function CLASS:StartListenRecursive()
	self.CanListen = true
	self:ForEachChild(StartListenRecursiveFunc)
	self:StartListen()
end

function CLASS:StopListenRecursive()
	self.CanListen = false
	self:ForEachChild(StopListenRecursiveFunc)
	self:StopListen()
end

function CLASS:_SortPanels()
	if not self.Valid then
		return
	end

	local childrenPanels = self._ChildrenPanels
	local childrenPanelsSorted = self._ChildrenPanelsSorted

	if not childrenPanels or table.IsEmpty(childrenPanels) then
		-- we don't have child panels

		if not childrenPanelsSorted or #childrenPanelsSorted <= 0 then
			-- we already "sorted" the empty table
			return
		end

		-- we "sort" the empty table

		emptyTableSafe(childrenPanelsSorted)

		local superparent = self:GetSuperParent()
		if IsValid(superparent) then
			superparent:QueueCall("OnPanelElementLoaded")
		end

		return
	end

	if childrenPanelsSorted and #childrenPanelsSorted > 0 then
		-- we have child panels and we sorted them already
		return
	end

	-- we have child panels, but we didn't sorted them yet

	local tmp = {}
	for _, panel in pairs(childrenPanels) do
		if not IsValid(panel) then continue end
		if panel == self then continue end
		if panel:GetParent() ~= self then continue end

		table.insert(tmp, panel)
	end

	table.sort(tmp, function(a, b)
		local a_strong_composition = a._strong_composition and 1 or -1
		local b_strong_composition = b._strong_composition and 1 or -1

		if a_strong_composition ~= b_strong_composition then
			return a_strong_composition < b_strong_composition
		end

		local a_zindex = a:GetZPos()
		local b_zindex = b:GetZPos()

		if a_zindex ~= b_zindex then
			return a_zindex > b_zindex
		end

		return a:GetID() > b:GetID()
	end)

	emptyTableSafe(childrenPanelsSorted)
	for _, panel in pairs(tmp) do
		table.insert(childrenPanelsSorted, panel)
	end

	local superparent = self:GetSuperParent()
	if IsValid(superparent) then
		superparent:QueueCall("OnPanelElementLoaded")
	end
end

function CLASS:AddPanel(panel, strong_composition)
	if not IsValid(panel) then return end
	if panel == self then return end

	local id = tostring(panel)
	if IsValid(self._ChildrenPanels[id]) then return self._ChildrenPanels[id] end

	self._ChildrenPanels[id] = panel
	emptyTableSafe(self._ChildrenPanelsSorted)

	panel:SetParent(self)
	panel:ApplyHierarchy()
	panel._strong_composition = strong_composition or false

	panel:InvalidateLayout()
	self:InvalidateLayout()

	self:QueueCall("_SetSkinAfterAddedPanel")
	self:QueueCall("_SetModelSetupAfterAddedPanel")

	return panel
end

function CLASS:AddPanelByClassname(name, ...)
	local panel = StreamRadioLib.CreateOBJ("ui/" .. name)
	return self:AddPanel(panel, ...)
end

function CLASS:RemovePanel(panel)
	if not IsValid(panel) then return end
	if panel == self then return end

	local id = tostring(panel)
	if not self._ChildrenPanels[id] then return panel end

	panel:SetParent(nil)
	panel:ApplyHierarchy()

	self._ChildrenPanels[id] = nil
	emptyTableSafe(self._ChildrenPanelsSorted)

	if panel._strong_composition then
		panel:Remove()

		self:InvalidateLayout()
		return nil
	end

	self:InvalidateLayout()
	panel:InvalidateLayout()

	return panel
end

function CLASS:Clear()
	self:ForEachChild("RemovePanel")

	emptyTableSafe(self._ChildrenPanels)
	emptyTableSafe(self._ChildrenPanelsSorted)

	self:InvalidateLayout(true)
end

function CLASS:ClearInvisible()
	self:ForEachChild(function(this, panel)
		if not IsValid(panel) then return end
		if panel:IsVisible() then return end

		self:RemovePanel(panel)
	end)

	emptyTableSafe(self._ChildrenPanelsSorted)
	self:InvalidateLayout(true)
end

function CLASS:ForEachParent(func)
	func = self:GetFunction(func)
	if not func then
		return nil
	end

	local once = {}
	local curparent = self:GetParent()

	while true do
		if not IsValid(curparent) then break end
		if once[curparent] then break end
		once[curparent] = true

		local rv = func(self, curparent)
		if rv ~= nil then
			return rv
		end

		curparent = curparent:GetParent()
	end

	return nil
end

function CLASS:ForEachChild(func, reverse)
	self:_SortPanels()
	local children = self._ChildrenPanelsSorted

	func = self:GetFunction(func)
	if not func then
		return nil
	end

	if not children then
		return nil
	end

	local invalid = false
	local len = #children

	if len <= 0 then
		return nil
	end

	if reverse then
		for i = len, 1, -1 do
			local panel = children[i]
			if not IsValid(panel) then
				invalid = true
				continue
			end

			local rv = func(self, panel)
			if rv ~= nil then
				return rv
			end
		end
	else
		for i = 1, len do
			local panel = children[i]
			if not IsValid(panel) then
				invalid = true
				continue
			end

			local rv = func(self, panel)
			if rv ~= nil then
				return rv
			end
		end
	end

	if invalid then
		emptyTableSafe(self._ChildrenPanelsSorted)
		self:_SortPanels()
	end

	return nil
end

function CLASS:ForEachChildRecursive(func, reverse)
	func = self:GetFunction(func)
	if not func then
		return
	end

	local nodouble = {}

	local function recursive(this, child)
		local cid = child:GetID()

		if nodouble[cid] then
			return
		end

		local rv = func(self, child)
		nodouble[cid] = true

		if rv ~= nil then
			return rv
		end

		return child:ForEachChild(recursive, reverse)
	end

	return self:ForEachChild(recursive, reverse)
end

function CLASS:GetPanelByName(name)
	name = StreamRadioLib.GetHierarchy(name)
	local maxlevel = #name

	local panel = self

	for level, v in ipairs(name) do
		if not IsValid(panel) then break end

		if not panel._panelmap then break end
		if not panel._panelmap.names then break end

		panel = panel._panelmap.names[v]

		if level >= maxlevel then
			return panel
		end
	end

	return nil
end

function CLASS:GetPanelsBySkinIdentifyer(name)
	name = StreamRadioLib.GetHierarchy(name)
	local maxlevel = #name
	local panels = {}

	local function recursive(thispanel, level)
		if not IsValid(thispanel) then return end

		local thisname = name[level] or ""

		if level > maxlevel then
			table.insert(panels, thispanel)
			return
		end

		if not thispanel._panelmap then return end
		if not thispanel._panelmap.skin then return end

		for k, panel in pairs(thispanel._panelmap.skin[thisname] or {}) do
			recursive(panel, level + 1)
		end
	end

	recursive(self, 1)

	return panels
end

function CLASS:ReleaseClick()
	if not self.IsPressed then
		return
	end

	self.IsPressed = false
	self:CallHook("OnMouseReleased")
end

function CLASS:Click(pressed)
	if not pressed then
		local sp = self:GetSuperParent()
		local LastClickedPanel = sp.LastClickedPanel

		if IsValid(LastClickedPanel) then
			LastClickedPanel:ReleaseClick()
			sp.LastClickedPanel = nil
		end

		self:ReleaseClick()
		return
	end

	local panel = self:GetClickPanel()
	if not IsValid(panel) then return end

	if panel ~= self then
		panel:Click(pressed)
		return
	end

	if self:IsInputDisabled() then return end
	if self:IsDisabled() then return end

	local sp = self:GetSuperParent()
	local LastClickedPanel = sp.LastClickedPanel

	if IsValid(LastClickedPanel) and LastClickedPanel ~= self then
		LastClickedPanel:ReleaseClick()
	end

	self.IsPressed = pressed

	if pressed then
		sp.LastClickedPanel = self

		local lastclicktime = self.LastClickTime or 0
		self.LastClickTime = RealTime()

		local clickdistance = self.LastClickTime - lastclicktime

		if clickdistance < 0.5 and isfunction(self.DoDoubleClick) then
			self:DoDoubleClick()
		end

		self:CallHook("DoClick")
	else
		sp.LastClickedPanel = nil
		self:CallHook("OnMouseReleased")
	end
end

local function GetFirstClickableChildPanel(this, panel)
	if not panel.Clickable then return end
	if not panel:IsVisible() then return end
	if not panel:IsCursorInBounds() then return end

	return panel
end

function CLASS:GetClickPanel()
	if not self:IsVisible() then return end
	if not self:IsCursorInBounds() then return end

	local chpanel = self:GetCacheValue("GetClickPanel")
	if IsValid(chpanel) then
		return chpanel
	end

	local panel = self:ForEachChild(GetFirstClickableChildPanel)

	if not IsValid(panel) then
		panel = GetFirstClickableChildPanel(self, self) or self
	end

	return self:SetCacheValue("GetClickPanel", panel)
end

function CLASS:IsCursorInBounds()
	local cxr, cyr = self:GetCursorRelative()
	return self:IsInBounds(cxr, cyr)
end

function CLASS:IsCursorOnPanel()
	local parent = self:GetParent()

	local self_onself = self:GetClickPanel() == self
	if not IsValid(parent) then
		return self_onself
	end

	return self_onself and parent:GetClickPanel() == self
end

function CLASS:IsInBounds(x, y)
	local w, h = self:GetSize()

	if x < 0 then return false end
	if x > w then return false end
	if y < 0 then return false end
	if y > h then return false end

	return true
end

function CLASS:GetPanelsAtCursor()
	local chpanels = self:GetCacheValue("GetPanelsAtCursor")
	if IsValid(chpanels) then
		return chpanels
	end

	local cx, cy = self:GetCursor()
	local panels = self:GetPanelsAtPos(cx, cy)

	return self:SetCacheValue("GetPanelsAtCursor", panels)
end

function CLASS:GetPanelsAtPos(x, y)
	local panels = {}

	local function func(this, panel)
		if not panel:IsVisible() then return end

		local px, py = panel:GetAbsolutePos()
		if not panel:IsInBounds(x - px, y - py) then return end

		table.insert(panels, panel)
	end

	func(self, self)
	self:ForEachChildRecursive(func)

	return panels
end

function CLASS:GetTopmostPanelAtCursor()
	local chpanel = self:GetCacheValue("GetTopmostPanelAtCursor")
	if IsValid(chpanel) then
		return chpanel
	end

	local panels = self:GetPanelsAtCursor()

	local area = nil
	local panel = nil

	for i, v in ipairs(panels) do
		local w, h = v:GetSize()
		local a = w * h

		if not area or area >= a then
			area = a
			panel = v
		end
	end

	return self:SetCacheValue("GetTopmostPanelAtCursor", panel)
end

function CLASS:GetAbsolutePos()
	local chx, chy = self:GetCacheValues("GetAbsolutePos")
	if chx then
		return chx, chy
	end

	local getpos = self.GetClientPos or self.GetPos
	local x, y = getpos(self)

	local parent = self:GetParent()
	if not IsValid(parent) then
		return self:SetCacheValues("GetAbsolutePos", x, y)
	end

	local px, py = parent:GetAbsolutePos()

	return self:SetCacheValues("GetAbsolutePos", px + x, py + y)
end

function CLASS:GetRenderPos()
	local chx, chy = self:GetCacheValues("GetRenderPos")
	if chx then
		return chx, chy
	end

	local getpos = self.GetClientPos or self.GetPos
	local x, y = getpos(self)

	local parent = self:GetParent()
	if not IsValid(parent) then
		return self:SetCacheValues("GetRenderPos", x, y)
	end

	local px, py = parent:GetRenderPos()

	return self:SetCacheValues("GetRenderPos", px + x, py + y)
end

function CLASS:GetArea()
	local x, y = self:GetPos()
	local w, h = self:GetSize()

	return x, y, x + w, y + h
end

function CLASS:SetPos(x, y)
	self.Pos.x = x or 0
	self.Pos.y = y or 0
end

function CLASS:GetPos()
	return self.Pos.x or 0, self.Pos.y or 0
end

function CLASS:SetPosX(x)
	self.Pos.x = x or 0
end

function CLASS:GetPosX()
	return self.Pos.x or 0
end

function CLASS:SetPosY(y)
	self.Pos.y = y or 0
end

function CLASS:GetPosY()
	return self.Pos.y or 0
end

function CLASS:GetClientPos()
	local x, y = self:GetPos()
	local parent = self:GetParent()

	if not IsValid(parent) then return x, y end
	local p = parent:GetPadding()

	return x + p, y + p
end

function CLASS:SetSize(w, h)
	w = w or 0
	h = h or 0

	if w < 0 then
		w = 0
	end

	if h < 0 then
		h = 0
	end

	local size = self.Size

	size.w = w
	size.h = h
end

function CLASS:SetWidth(w)
	w = w or 0

	if w < 0 then
		w = 0
	end

	self.Size.w = w
end

function CLASS:SetHeight(h)
	h = h or 0

	if h < 0 then
		h = 0
	end

	self.Size.h = h
end

function CLASS:GetSize()
	local size = self.Size

	return size.w or 0, size.h or 0
end

function CLASS:GetWidth()
	return self.Size.w or 0
end

function CLASS:GetHeight()
	return self.Size.h or 0
end

function CLASS:GetClientSize()
	local w, h = self:GetSize()
	local p = 2 * self:GetPadding()

	w = w - p
	h = h - p

	if w < 0 then
		w = 0
	end

	if h < 0 then
		h = 0
	end

	return w, h
end

function CLASS:GetClientWidth()
	local w = self:GetWidth()
	local p = 2 * self:GetPadding()

	w = w - p

	if w < 0 then
		w = 0
	end

	return w
end

function CLASS:GetClientHeight()
	local h = self:GetHeight()
	local p = 2 * self:GetPadding()

	h = h - p

	if h < 0 then
		h = 0
	end

	return h
end

function CLASS:GetSquareSize()
	local w, h = self:GetClientSize()

	local square = w

	if square > h then
		square = h
	end

	return square
end

function CLASS:SetColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Main = color
end

function CLASS:GetColor()
	if SERVER then return end

	local col = self.Colors.Main
	return col
end

function CLASS:SetDrawAlpha(alpha)
	if SERVER then return end

	alpha = math.Clamp(alpha, 0, 1)
	self.Colors.DrawAlpha = alpha
end

function CLASS:GetDrawAlpha()
	if SERVER then return end
	local alpha = self.Colors.DrawAlpha

	return alpha or 0
end

function CLASS:SetParent(panel)
	local oldpanel = self:GetParent()

	if oldpanel == panel then return end
	if panel == self then
		error("Do not set the parent to self!", 2)
	end

	self.Parent = panel

	if IsValid(oldpanel) then
		oldpanel:RemovePanel(self)
	end

	if IsValid(panel) then
		panel:AddPanel(self)
	end
end

function CLASS:GetParent()
	return self.Parent
end

function CLASS:GetSuperParent()
	return self.SuperParent
end

function CLASS:CalcSuperParent()
	local superparent = self

	self:ForEachParent(function(this, parent)
		superparent = parent
	end)

	self.SuperParent = superparent
	return superparent
end

function CLASS:SetTooltip(text)
	if SERVER then return end
	self.Layout.Tooltip = tostring(text or "")
end

function CLASS:GetTooltip()
	if SERVER then return "" end
	return self.Layout.Tooltip or ""
end

function CLASS:GetTooltipPanel()
	if SERVER then return nil end

	local sp = self:GetSuperParent()
	return sp.Tooltip
end

function CLASS:UpdateTooltip(text)
	if SERVER then return nil end

	local sp = self:GetSuperParent()
	if not IsValid(sp) then return end
	if not IsValid(sp.Tooltip) then return end
	if not sp.Tooltip:IsVisible() then return end
	if not sp.UpdateTooltip then return end

	local onpanel = self:IsCursorOnPanel()
	if not onpanel then return end

	return sp:UpdateTooltip(text)
end

function CLASS:_OpenTooltipPanel()
	if SERVER then return end

	local text = self:GetTooltip()
	if text == "" then return end

	local sp = self:GetSuperParent()
	if not IsValid(sp) then return end
	if not IsValid(sp.Tooltip) then return end
	if not sp.OpenTooltipDelay then return end

	local onpanel = self:IsCursorOnPanel()

	local oldonpanel = self._oldonpanel
	self._oldonpanel = onpanel

	if onpanel == oldonpanel then return end

	if not onpanel then
		sp:CloseTooltip()
		return
	end


	sp:CloseTooltip()
	sp:OpenTooltipDelay(text, 0.75, function()
		local text = self:GetTooltip()
		if text == "" then return false end

		local onpanel = self:IsCursorOnPanel()

		if not onpanel then
			sp:CloseTooltip()
		end

		return onpanel
	end)
end

function CLASS:IsDisabled()
	return self.Layout.Disabled or false
end

function CLASS:IsEnabled()
	return not self.Layout.Disabled
end

function CLASS:SetEnabled(bool)
	self.Layout.Disabled = not bool
end

function CLASS:SetDisabled(bool)
	self.Layout.Disabled = bool or false
end

function CLASS:IsInputDisabled()
	return CLIENT and self.Network.Active
end

function CLASS:SetPadding(padding)
	padding = padding or 0

	if padding < 0 then
		padding = 0
	end

	self.Layout.Padding = padding or 0
end

function CLASS:GetPadding()
	return self.Layout.Padding or 0
end

function CLASS:SetMargin(margin)
	margin = margin or 0

	if margin < 0 then
		margin = 0
	end

	self.Layout.Margin = margin or 0
end

function CLASS:GetMargin()
	return self.Layout.Margin or 0
end

function CLASS:HasChildren()
	self:_SortPanels()

	local childrenPanelsSorted = self._ChildrenPanelsSorted
	if not childrenPanelsSorted then
		return false
	end

	if #childrenPanelsSorted <= 0 then
		return false
	end

	return true
end

function CLASS:IsSeen()
	local superparent = self:GetSuperParent()

	if superparent == self then
		return true
	end

	if superparent:IsSeen() then
		return true
	end

	return false
end

function CLASS:IsVisible()
	local isvisible = self:GetCacheValue("IsVisible")
	if isvisible ~= nil then
		return isvisible
	end

	if not self:IsVisibleSimple() then
		return self:SetCacheValue("IsVisible", false)
	end

	local parent = self:GetParent()
	if IsValid(parent) then
		return self:SetCacheValue("IsVisible", parent:IsVisible())
	end

	return self:SetCacheValue("IsVisible", true)
end

function CLASS:IsVisibleSimple()
	local w, h = self:GetSize()

	if w <= 0 then
		return false
	end

	if h <= 0 then
		return false
	end

	return self.Layout.Visible
end

function CLASS:SetVisible(bool)
	self.Layout.Visible = bool or false
end

function CLASS:IsVisibleSimple()
	local w, h = self:GetSize()

	if w <= 0 then
		return false
	end

	if h <= 0 then
		return false
	end

	return self.Layout.Visible
end

function CLASS:SetPaintBackground(bool)
	self.Layout.PaintBackground = bool or false
end

function CLASS:GetPaintBackground()
	return self.Layout.PaintBackground
end

function CLASS:GetZPos()
	return self.Layout.ZIndex or 0
end

function CLASS:SetZPos(zindex)
	self.Layout.ZIndex = zindex or 0
end

function CLASS:Close()
	self:SetVisible(false)
end

function CLASS:Open()
	self:SetVisible(true)
end

function CLASS:Hide()
	self:SetVisible(false)
end

function CLASS:Show()
	self:SetVisible(true)
end

function CLASS:_GetCursorInternal()
	return -1, -1
end

function CLASS:GetCursor()
	local sp = self:GetSuperParent()
	return sp:_GetCursorInternal()
end

function CLASS:GetCursorRelative()
	local cx, cy = self:GetCursor()
	local posx, posy = self:GetAbsolutePos()

	return cx - posx, cy - posy
end

function CLASS:CalcHierarchy(func)
	local thisfunc = self:GetFunction(func)
	if not thisfunc then return end

	local hierarchy = {}
	table.insert(hierarchy, thisfunc(self))

	self:ForEachParent(function(this, parent)
		local thisfunc = parent:GetFunction(func)
		if not thisfunc then return end

		table.insert(hierarchy, thisfunc(parent))
	end)

	hierarchy = table.Reverse(hierarchy)
	return hierarchy
end

function CLASS:ApplyHierarchy()
	self:CalcSuperParent()
	self:CalcName()
	self:CalcNWName()
	self:CalcSkinIdentifyer()
end

function CLASS:GetReferenceClassobjsNWRegister()
	local superparent = self:GetSuperParent()
	return superparent.entityClassobjsNwRegister
end

function CLASS:SetReferenceClassobjsNWRegister(nwRegister)
	if not istable(nwRegister) then
		return
	end

	local superparent = self:GetSuperParent()
	superparent.entityClassobjsNwRegister = nwRegister
end

function CLASS:GetEntity()
	local superparent = self:GetSuperParent()
	return superparent.Entity
end

function CLASS:GetEntityTable()
	local superparent = self:GetSuperParent()

	if not superparent._entityTableGetter then
		return nil
	end

	return superparent._entityTableGetter()
end

function CLASS:SetEntity(ent)
	self:ApplyHierarchy()

	local superparent = self:GetSuperParent()

	if not IsValid(ent) then
		superparent.Entity = nil
		superparent._entityTableGetter = nil

		superparent:RemoveFromNwRegister(superparent.entityClassobjsNwRegister)

		self:ApplyNetworkedMode()
		return
	end

	superparent.Entity = ent
	local entTable = ent:GetTable()

	superparent._entityTableGetter = function()
		-- avoid storing the entity table directly, so we dont leak memory
		return entTable
	end

	superparent:SetReferenceClassobjsNWRegister(entTable._3dstraemradio_classobjs_nw_register)

	self:ApplyNetworkedMode()
end

function CLASS:SetName(name)
	self:ApplyHierarchy()

	name = tostring(name or "")
	name = string.gsub(name, "[%/%\\%s]", "_")

	local oldname = self:GetName()

	self.Name = name
	self:CalcName()

	local parent = self:GetParent()
	if IsValid(parent) then
		parent._panelmap = parent._panelmap or {}
		parent._panelmap.names = parent._panelmap.names or {}
		parent._panelmap.names[oldname] = nil
		parent._panelmap.names[name] = self
	end
end

function CLASS:GetNameWithoutHierarchy()
	return self.Name or ""
end

function CLASS:GetName()
	return self.HierarchyName or ""
end

function CLASS:SetNWName(nwname)
	self:ApplyHierarchy()

	nwname = tostring(nwname or "")
	nwname = string.gsub(nwname, "[%/%\\%s]", "_")

	self.NWName = nwname
	self:CalcNWName()

	local parent = self:GetParent()
	if IsValid(parent) then
		parent._panelmap = parent._panelmap or {}
		parent._panelmap.nwnames = parent._panelmap.nwnames or {}
		parent._panelmap.nwnames[nwname] = self
	end

	self:ApplyNetworkedMode()
end

function CLASS:GetNWNameWithoutHierarchy()
	return self.NWName or ""
end

function CLASS:GetNWName()
	return self.HierarchyNWName or ""
end

function CLASS:SetSkinIdentifyer(name)
	name = tostring(name or "")
	name = string.gsub(name, "[%/%\\%s]", "_")

	local parent = self:GetParent()
	if IsValid(parent) then
		parent._panelmap = parent._panelmap or {}
		parent._panelmap.skin = parent._panelmap.skin or {}
		parent._panelmap.skin[name] = parent._panelmap.skin[name] or {}

		table.insert(parent._panelmap.skin[name], self)
	end

	self.SkinName = name
	self:CalcSkinIdentifyer()
end

function CLASS:GetSkinIdentifyerHierarchy()
	if not self.HierarchySkinIdentifyer then
		return self:CalcSkinIdentifyer()
	end

	return self.HierarchySkinIdentifyer
end

function CLASS:GetSkinIdentifyer(name)
	return self.SkinName or ""
end

function CLASS:CalcName()
	local hierarchy = self:CalcHierarchy("GetNameWithoutHierarchy")
	local name = table.concat(hierarchy, "/")

	self.HierarchyName = name
	return self.HierarchyName
end

function CLASS:CalcNWName()
	local hierarchy = self:CalcHierarchy("GetNWNameWithoutHierarchy")
	local name = table.concat(hierarchy, "/")

	self.HierarchyNWName = name
	return self.HierarchyNWName
end

function CLASS:CalcSkinIdentifyer()
	local hierarchy = self:CalcHierarchy("GetSkinIdentifyer")
	table.remove(hierarchy, 1)

	local name = table.concat(hierarchy, "/")

	self.HierarchySkinIdentifyer = name
	return self.HierarchySkinIdentifyer
end

function CLASS:IsSkinAble()
	if self:GetSkinIdentifyer() == "" then return false end
	if not self.SkinAble then return false end
	if not self.SkinMap then return false end

	return true
end

function CLASS:SetSkinAble(bool)
	self.SkinAble = bool or false
end

function CLASS:_SetSkinAfterAddedPanel()
	if not self._skindata then return end
	self:SetSkin(self._skindata)
end

function CLASS:_SetModelSetupAfterAddedPanel()
	if not self._modelsetupdata then return end
	self:SetModelSetup(self._modelsetupdata)
end

function CLASS:SetSkin(skindata)
	if SERVER then return end

	skindata = skindata or {}
	self._skindata = skindata

	local thisdata = skindata.data
	local childrendata = skindata.children

	if thisdata and self:IsSkinAble() then
		if self.SkinMap then
			for k, v in pairs(thisdata) do
				if not self.SkinMap[k] then continue end

				local setter = self:GetFunction(self.SkinMap[k].set)
				if not setter then continue end

				setter(self, v)
			end
		end

		self:CallHook("OnSkin", thisdata)
	end

	if childrendata then
		self:ForEachChild(function(this, panel)
			local name = panel:GetSkinIdentifyer()

			local childdata = childrendata[name]
			if not childdata then return end

			panel:SetSkin(childdata)
		end)
	end
end

function CLASS:GetSkinValue(key, ...)
	key = tostring(key or "")

	if not self.SkinMap then return nil end
	if not self.SkinMap[key] then return nil end

	local getter = self:GetFunction(self.SkinMap[key].get)
	if not getter then return nil end

	return getter(self, ...)
end

function CLASS:GetSkinValues(...)
	local tmp = {}

	for k, v in pairs(self.SkinMap or {}) do
		local getter = self:GetFunction(v.get)
		if not getter then continue end

		tmp[k] = getter(self, ...)
	end

	return tmp
end

function CLASS:SetModelSetup(setupdata)
	setupdata = setupdata or {}
	local thisdata = setupdata.data
	local childrendata = setupdata.children

	if thisdata then
		self:CallHook("OnModelSetup", thisdata)
	end

	if childrendata then
		self:ForEachChild(function(this, panel)
			local name_id = panel:GetNameWithoutHierarchy()
			local name_skin = panel:GetSkinIdentifyer()


			local childdata = childrendata[name_id or ""] or childrendata[name_skin or ""]
			if not childdata then return end

			panel:SetModelSetup(childdata)
		end)
	end

	self._modelsetupdata = setupdata
	self:InvalidateLayout(false, true)
end

function CLASS:OnModelSetup(setup)
	if setup.margin then
		self:SetMargin(setup.margin)
	end

	if setup.padding then
		self:SetPadding(setup.padding)
	end

	if setup.visible ~= nil then
		self:SetVisible(setup.visible or false)
	end

	if setup.size then
		local s = setup.size
		local w = s.width or s.w or s.x or s[1] or 0
		local h = s.height or s.y or s[2] or 0

		self:SetSize(w, h)
	end

	if setup.pos then
		local p = setup.pos
		local x = p.x or p[1] or 0
		local y = p.y or p[2] or 0

		self:SetPos(x, y)
	end


	if setup.sizex or setup.sizew then
		local w = setup.sizex or setup.sizew
		self:SetWidth(w)
	end

	if setup.sizey or setup.sizeh then
		local h = setup.sizex or setup.sizeh
		self:SetHeight(h)
	end

	if setup.posx then
		local x = setup.posx
		self:SetPosX(x)
	end

	if setup.posy then
		local x = setup.posy
		self:SetPosY(x)
	end
end

return true


--PATH lua/streamradio_core/classes/ui/highlighter.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/round_panel.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.Layout.CornerSize = 16
	self.Layout.Padding = 5

	self.SkinAble = true
end

function CLASS:Render()
	local x, y = self:GetRenderPos()
	local w, h = self:GetSize()

	draw.RoundedBox( self.Layout.CornerSize, x, y, w, h, self.Colors.Main )

	BASE.Render(self)
end

function CLASS:GetCornerSize()
	return self.Layout.CornerSize or 0
end

function CLASS:SetCornerSize(size)
	self.Layout.CornerSize = size or 0
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.cornersize then
		self:SetCornerSize(setup.cornersize)
	end
end

return true


--PATH lua/streamradio_core/classes/ui/label.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/list.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local LIBNet = StreamRadioLib.Net
local LIBNetwork = StreamRadioLib.Network
local LIBUtil = StreamRadioLib.Util

local emptyTableSafe = LIBUtil.EmptyTableSafe

local BASE = CLASS:GetBaseClass()

local g_listcache = StreamRadioLib.Util.CreateCacheArray(256)

StreamRadioLib.Hook.Add("PostCleanupMap", "reset_cache_list", function()
	g_listcache:Empty()
end)

function CLASS:Create()
	BASE.Create(self)

	self.ScrollBar = self:AddPanelByClassname("scrollbar", true)
	self.ScrollBar:SetName("scrollbar")
	self.ScrollBar:SetNWName("sbar")
	self.ScrollBar:SetSkinIdentifyer("scrollbar")
	self.ScrollBar:SetSize(30, 30)

	self.ScrollBar.OnScroll = function()
		self:UpdateButtons()
	end

	self.Hash = self:CreateListener({
		value = "",
	}, function(this, k, v, oldv)
		self:SetNWString("Hash", v)

		if SERVER then return end
		self:NetworkButtons()
	end)

	self.Buttons = {}
	self.Data = {}
	self.IconIDs = {}
	self.NetworkPlayerList = {}

	self.Layout.IsHorizontal = false
	self.Layout.ListGridX = 2
	self.Layout.ListGridY = 6

	self.Layout = self.Layout + function(this, k, v)
		if k == "ListGridX" then
			self:RecreateButtons()
			self:SetNWInt("ListGridX", v)
		end

		if k == "ListGridY" then
			self:RecreateButtons()
			self:SetNWInt("ListGridY", v)
		end

		if k == "Margin" then
			self:UpdateButtons()
		end

		if k == "IsHorizontal" then
			self:UpdateButtons()
			self:SetNWBool("IsHorizontal", v)
		end

		if k == "Visible" then
			if v then
				self:NetworkButtons()
			end
		end
	end

	self.Size = self.Size + function(this, k, v)
		self:UpdateButtons()
	end

	self:RecreateButtons()

	if CLIENT then
		self:NetReceive("data", function(this, id, len, ply)
			local count = net.ReadUInt(16)
			local newdata = {}

			for index = 1, count do
				local text, icon = LIBNet.ReceiveListEntry()

				table.insert(newdata, {
					text = text,
					icon = icon,
				})
			end

			local newhash = LIBNet.ReceiveHash()

			-- Store the result of our request for later use
			g_listcache:Set(newhash, newdata)
			self:SetData(newdata)
		end)
	else
		LIBNetwork.AddNetworkString("data")
		LIBNetwork.AddNetworkString("datarequest")

		self:NetReceive("datarequest", function(this, id, len, ply)
			self.NetworkPlayerList[ply] = ply

			self:NetworkButtons()
		end)
	end
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	local scrollbar = self.ScrollBar

	if not IsValid(scrollbar) then
		return
	end

	local ishorizontal = self:GetHorizontal()
	local w, h = self:GetClientSize()

	if ishorizontal then
		local barwidth = scrollbar:GetHeight()
		scrollbar:SetSize(w, barwidth)
		scrollbar:SetPos(0, h - barwidth)
	else
		local barwidth = scrollbar:GetWidth()
		scrollbar:SetSize(barwidth, h)
		scrollbar:SetPos(w - barwidth, 0)
	end

	scrollbar:AutoSetHorizontal()
end

function CLASS:ClearButtons()
	for k, v in pairs(self.Buttons or {}) do
		if not v then
			continue
		end

		v:Remove()
	end

	self.Buttons = {}

	local scrollbar = self.ScrollBar
	if IsValid(scrollbar) then
		scrollbar:SetVisible(false)
	end
end

function CLASS:GetButton(buttonindex)
	if not self.Buttons then
		return nil
	end

	return self.Buttons[buttonindex]
end

function CLASS:GetOrCreateButton(buttonindex)
	self.Buttons = self.Buttons or {}
	local button = self.Buttons[buttonindex]

	if not IsValid(button) then
		button = self:AddPanelByClassname("button", true)
		button:SetName("button" .. buttonindex)
		button:SetNWName("but" .. buttonindex)
		button:SetSkinIdentifyer("button")

		self:CallHook("OnItemCreate", button, buttonindex)
		self.Buttons[buttonindex] = button
	end

	return button
end

function CLASS:RecreateButtons()
	self:ClearButtons()
	self:UpdateButtons()
end

function CLASS:UpdateButtons()
	self:QueueCall("UpdateButtonsInternal")
end

function CLASS:NetworkButtons()
	self:QueueCall("NetworkButtonsInternal")
end

function CLASS:NetworkButtonsInternal()
	if not self:IsVisible() then
		return
	end

	if CLIENT then
		local hash = self:GetHash()

		if hash ~= "" then
			local cache = g_listcache:Get(hash)

			if cache then
				self:SetData(cache)
				return
			end
		end

		self:NetSend("datarequest")
		return
	end

	self:NetSendToPlayers("data", function()
		local data = self.Data
		local hash = self:GetHashFromData(data)

		net.WriteUInt(#data, 16)

		for i, v in ipairs(data) do
			LIBNet.SendListEntry(v.text, v.icon)
		end

		LIBNet.SendHash(hash)
	end, self.NetworkPlayerList)

	emptyTableSafe(self.NetworkPlayerList)
end

function CLASS:UpdateButtonsInternal()
	local scrollbar = self.ScrollBar
	local data = self.Data or {}
	local ListSizeX = self.Layout.ListGridX
	local ListSizeY = self.Layout.ListGridY

	self:CalcHash()

	if not IsValid(scrollbar) then
		self:ClearButtons()
		return
	end

	if ListSizeX <= 0 then
		self:ClearButtons()
		return
	end

	if ListSizeY <= 0 then
		self:ClearButtons()
		return
	end

	local listsize = #data

	if listsize <= 0 then
		self:ClearButtons()
		return
	end

	local ishorizontal = scrollbar:GetHorizontal()
	local listviewsize = ListSizeX * ListSizeY
	local startindex = 0
	local scroll = 0
	local maxscroll = 0
	local barwidth = 0

	local w, h = self:GetClientSize()
	local margin = self:GetMargin()

	local buttonarea_w = w
	local buttonarea_h = h

	if ishorizontal then
		maxscroll = listsize / ListSizeY - ListSizeX
		maxscroll = math.ceil(maxscroll)

		scrollbar:SetMaxScroll(maxscroll)
		scroll = scrollbar:GetScroll()

		startindex = listviewsize / ListSizeX * scroll
		barwidth = scrollbar:GetHeight() + margin
		buttonarea_h = buttonarea_h - barwidth
	else
		maxscroll = listsize / ListSizeX - ListSizeY
		maxscroll = math.ceil(maxscroll)

		scrollbar:SetMaxScroll(maxscroll)
		scroll = scrollbar:GetScroll()

		startindex = listviewsize / ListSizeY * scroll
		barwidth = scrollbar:GetWidth() + margin
		buttonarea_w = buttonarea_w - barwidth
	end

	local hasscrollbar = scrollbar:GetMaxScroll() > 0
	scrollbar:SetVisible(hasscrollbar)

	if not hasscrollbar then
		if ishorizontal then
			barwidth = scrollbar:GetHeight() + margin
			buttonarea_h = buttonarea_h + barwidth
		else
			barwidth = scrollbar:GetWidth() + margin
			buttonarea_w = buttonarea_w + barwidth
		end
	end

	local endindex = startindex + listviewsize
	local buttonindex = 0

	local buttonsize_w = (buttonarea_w - (margin * (ListSizeX - 1))) / ListSizeX
	local buttonsize_h = (buttonarea_h - (margin * (ListSizeY - 1))) / ListSizeY

	for i = startindex + 1, endindex do
		local buttonposindex = buttonindex
		buttonindex = buttonindex + 1

		local button = self:GetOrCreateButton(buttonindex)
		if not IsValid(button) then
			continue
		end

		local v = data[i] or {}

		local text = v.text or ""
		local icon = v.icon or -1
		local value = v.value
		local hasdata = text ~= "" or value ~= nil

		if not hasdata then
			button:Remove()
			continue
		end

		local ListX = 0
		local ListY = 0

		if ishorizontal then
			ListX = buttonposindex % ListSizeY
			ListY = buttonposindex / ListSizeY
		else
			ListX = buttonposindex % ListSizeX
			ListY = buttonposindex / ListSizeX
		end

		ListX = math.floor(ListX)
		ListY = math.floor(ListY)

		button:SetText(text)
		button:SetIcon(self:GetIDIcon(icon))
		button:SetAlign(TEXT_ALIGN_RIGHT)
		button:SetTextAlign(TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		button:SetSize(buttonsize_w, buttonsize_h)

		local buttonsizemargin_w = buttonsize_w + margin
		local buttonsizemargin_h = buttonsize_h + margin

		if ishorizontal then
			button:SetPos(buttonsizemargin_w * ListY, buttonsizemargin_h * ListX)
		else
			button:SetPos(buttonsizemargin_w * ListX, buttonsizemargin_h * ListY)
		end

		button._listvaluedata = v

		button.DoClick = function(this)
			self:CallHook("OnItemClickInternal", this, value, buttonindex, ListX, ListY, i)
			self:CallHook("OnItemClick", this, value, buttonindex, ListX, ListY, i)
		end

		self:CallHook("OnItemUpdate", button, value, buttonindex, ListX, ListY, i)
	end
end

function CLASS:GetHashFromData(data)
	data = data or {}
	local datastring = {}

	for i, v in ipairs(data) do
		local text = v.text or ""
		local icon = v.icon or -1

		table.insert(datastring, string.format("{[%s][%d][%d]}", text, icon, i))
	end

	table.insert(datastring, string.format("[%d]", #data))
	datastring = table.concat(datastring, "\n")

	local hash = LIBNetwork.Hash(datastring)
	return hash
end

function CLASS:CalcHash()
	if CLIENT then return end
	if not self.Network.Active then return end

	local hash = self:GetHashFromData(self.Data)
	self.Hash.value = hash or ""
end

function CLASS:SetData(data)
	emptyTableSafe(self.Data)

	for k, v in pairs(data or {}) do
		self:AddData(v, true)
	end

	self:UpdateButtons()
end

function CLASS:AddData(data, noupdate)
	local v = {
		text = data.text or "",
		value = data.value,
		icon = data.icon or -1,
	}

	table.insert(self.Data, v)

	if not noupdate then
		self:UpdateButtons()
	end
end

function CLASS:UpdateData(index, data, noupdate)
	if not self.Data then return end
	if not self.Data[index] then return end

	self.Data[index] = {
		text = data.text or "",
		value = data.value,
		icon = data.icon or -1,
	}

	if not noupdate then
		self:UpdateButtons()
	end
end

function CLASS:ClearData()
	emptyTableSafe(self.Data)
	self:RecreateButtons()
end

function CLASS:SetHorizontal(horizontal)
	self.Layout.IsHorizontal = horizontal or false
end

function CLASS:GetHorizontal()
	return self.Layout.IsHorizontal or false
end

function CLASS:GetScrollBar()
	return self.ScrollBar
end

function CLASS:ForEachButton(func, ...)
	self:ForEachChild(function(this, panel)
		if panel == self.ScrollBar then return end
		func(this, panel)
	end, ...)
end

function CLASS:SetGridSize(x, y)
	x = x or 0
	y = y or 0

	if x < 0 then
		x = 0
	end

	if y < 0 then
		y = 0
	end

	self.Layout.ListGridX = x
	self.Layout.ListGridY = y
end

function CLASS:GetGridSize()
	return self.Layout.ListGridX or 0, self.Layout.ListGridY or 0
end

function CLASS:GetMaxButtonCount()
	return self.Layout.ListGridX * self.Layout.ListGridY
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)
	self.ScrollBar:ActivateNetworkedMode()

	if SERVER then
		self:SetNWInt("ListGridX", self.Layout.ListGridX)
		self:SetNWInt("ListGridY", self.Layout.ListGridY)
		self:SetNWBool("IsHorizontal", self:GetHorizontal())

		self:CalcHash()
		return
	end

	self:SetGridSize(self:GetNWInt("ListGridX", 0), self:GetNWInt("ListGridY", 0))
	self:SetHorizontal(self:GetNWBool("IsHorizontal", false))

	local hash = self:GetNWString("Hash", "")
	self.Hash.value = hash

	self:SetNWVarCallback("ListGridX", "Int", function(this, nwkey, oldvar, newvar)
		self.Layout.ListGridX = newvar
	end)

	self:SetNWVarCallback("ListGridY", "Int", function(this, nwkey, oldvar, newvar)
		self.Layout.ListGridY = newvar
	end)

	self:SetNWVarCallback("IsHorizontal", "Bool", function(this, nwkey, oldvar, newvar)
		self:SetHorizontal(newvar)
	end)

	self:SetNWVarCallback("Hash", "String", function(this, nwkey, oldvar, newvar)
		self.Hash.value = newvar or ""
	end)

	self:NetworkButtons()
	self:UpdateButtons()
end

function CLASS:SetIDIcon(ID, icon)
	ID = ID or -1
	if ID < 0 then return end

	self.IconIDs[ID] = icon or ID
	self:UpdateButtons()
end

function CLASS:GetIDIcon(ID)
	ID = ID or -1
	if ID < 0 then return end

	return self.IconIDs[ID]
end

function CLASS:GetHash()
	local curhash = self.Hash.value or ""

	if CLIENT and self.Network.Active then
		curhash = self:GetNWString("Hash", "")
	end

	return curhash
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.gridsize then
		local s = setup.gridsize
		local w = s.width or s.w or s.x or s[1] or 0
		local h = s.height or s.y or s[2] or 0

		self:SetGridSize(w, h)
	end
end

return true


--PATH lua/streamradio_core/classes/ui/radio/gui_player_controls.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/rendertarget.lua:
if SERVER then
	CLASS = nil
	return true
end

local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()
local g_classname = CLASS:GetClassname()

local catchAndErrorNoHaltWithStack = StreamRadioLib.Util.CatchAndErrorNoHaltWithStack

local g_RenderTargetsCache = {}

local function next2power(value)
	value = value or 0
	if value <= 0 then return 0 end

	return math.ceil(2 ^ math.ceil(math.log(value) / math.log(2)))
end

local function GetRenderTargetMaterial(tex)
	if not tex then
		return nil
	end

	if tex:IsError() then
		return nil
	end

	local name = tex:GetName()

	local materialParameters = {
		["$basetexture"] = name,
		["$vertexcolor"] = 1,
		["$vertexalpha"] = 1,
		["$nocull"] = 1,
		["$nolod"] = 1,
		["$selfillum"] = 1,
		["$translucent"] = 1,
	}

	local mat = CreateMaterial( name, "UnlitGeneric", materialParameters )

	if not mat then
		return nil
	end

	mat:Recompute()
	return mat
end

local function GetCacheForSize(w, h)
	w = w or 0
	h = h or 0

	if w <= 0 then
		return nil
	end

	if h <= 0 then
		return nil
	end

	g_RenderTargetsCache[w] = g_RenderTargetsCache[w] or {}
	g_RenderTargetsCache[w][h] = g_RenderTargetsCache[w][h] or {}

	return g_RenderTargetsCache[w][h]
end

local function GetCacheCountForSize(w, h)
	local cache = GetCacheForSize(w, h)

	if not cache then
		return 0
	end

	return #cache
end

local function FreeCache(w, h, index)
	local cache = GetCacheForSize(w, h)
	if not cache then return end
	if not cache[index] then return end

	cache[index].free = true
end

local function UnfreeCache(w, h, index)
	local cache = GetCacheForSize(w, h)
	if not cache then return end
	if not cache[index] then return end

	cache[index].free = false
end

local function GetRendertargetName(w, h, index)
	w = w or 0
	h = h or 0

	if w <= 0 then
		return nil
	end

	if h <= 0 then
		return nil
	end

	index = index or GetCacheCountForSize(w, h)

	local name = string.format("3dstreamradio-rt_cls-%s_%ix%i_id-%i", g_classname, w, h, index)
	name = string.lower(name or "")
	name = string.Trim(name)
	name = string.gsub(name, "[%s\\.]", "_" )

	return name
end

function CLASS:Create()
	BASE.Create(self)

	local CreateRendertarget = function(this, key, value)
		if key == "Framerate" then return end

		if key == "Disabled" and value then
			self:Free()
			self._RT = nil

			self:CallHook("OnRendertargetRemove")
			return
		end

		self._RT = self:CreateRendertarget()

		if self._RT then
			self:CallHook("OnRendertargetCreate")
		else
			self:CallHook("OnRendertargetRemove")
		end
	end

	self.Size = self:CreateListener({
		w = 0,
		h = 0,
	}, CreateRendertarget)

	self.Pos = self:CreateListener({
		x = 0,
		y = 0,
	}, function()
		self:CallHook("OnPosChange")
	end)

	self.Settings = self:CreateListener({
		Framerate = 0,
		Disabled = false,
	}, CreateRendertarget)
end

function CLASS:Initialize()
	BASE.Initialize(self)

	self._RT = self:CreateRendertarget()

	if self._RT then
		self:CallHook("OnRendertargetCreate")
	else
		self:CallHook("OnRendertargetRemove")
	end

	self:Update()
end

function CLASS:GetCache()
	local w, h = self:GetSize()
	local cache = GetCacheForSize(w, h)

	if not cache then
		return nil
	end

	for i, v in ipairs(cache) do
		if not v.free then continue end
		if not v.tex then continue end
		if not v.mat then continue end

		local out = {
			mat = v.mat,
			tex = v.tex,
			index = i
		}

		return out
	end

	return nil
end

function CLASS:SetCache(mat, tex)
	if not mat then return nil end
	if not tex then return nil end

	local w, h = self:GetSize()
	local cache = GetCacheForSize(w, h)

	if not cache then
		return nil
	end

	local rt = {}

	rt.mat = mat
	rt.tex = tex
	rt.free = true

	table.insert(cache, rt)

	local out = {
		mat = mat,
		tex = tex,
		index = #cache
	}

	return out
end

function CLASS:GetCacheCount()
	local w, h = self:GetSize()
	return GetCacheCountForSize(w, h)
end

function CLASS:Free()
	local w, h = self:GetSize()
	self:Clear()

	local rt = self._RT
	if not rt then return end

	FreeCache(w, h, rt.index)
end

function CLASS:GetMaxCacheCount()
	return self:GetGlobalVar("rendertarget_MaxCacheCount", 0)
end

function CLASS:SetMaxCacheCount(value)
	value = value or 0

	if value <= 0 then
		value = 0
	end

	return self:SetGlobalVar("rendertarget_MaxCacheCount", value)
end


function CLASS:CreateRendertarget()
	if not self.Valid then
		return nil
	end

	if not self.Created then
		return nil
	end

	if self:IsDisabled() then
		return nil
	end

	local w, h = self:GetSize()

	if w <= 0 then
		return nil
	end

	if h <= 0 then
		return nil
	end

	local rt = self:GetCache()
	if rt then
		UnfreeCache(w, h, rt.index)
		return rt
	end

	local name = GetRendertargetName(w, h)
	if not name then return nil end

	local maxcount = self:GetMaxCacheCount()
	if maxcount > 0 and self:GetCacheCount() > maxcount then
		return nil
	end

	-- No ENUMS for thise values are available in the game.
	-- https://wiki.facepunch.com/gmod/Enums/TEXTUREFLAGS
	local textureFlags = bit.bor(
		4,    -- TEXTUREFLAGS_CLAMPS
		8,    -- TEXTUREFLAGS_CLAMPT
		16,   -- TEXTUREFLAGS_ANISOTROPIC
		32,   -- TEXTUREFLAGS_HINT_DXT5
		512,  -- TEXTUREFLAGS_NOLOD
		8192, -- TEXTUREFLAGS_EIGHTBITALPHA
		32768 -- TEXTUREFLAGS_RENDERTARGET
	)

	local tex = GetRenderTargetEx(
		name, w, h,
		RT_SIZE_NO_CHANGE,
		MATERIAL_RT_DEPTH_SEPARATE,
		textureFlags,
		0,
		IMAGE_FORMAT_RGBA8888
	)

	local mat = GetRenderTargetMaterial(tex)

	rt = self:SetCache(mat, tex)
	if not rt then
		return nil
	end

	render.PushRenderTarget( tex )
		render.Clear( 0, 0, 0, 0, true )
	render.PopRenderTarget( )

	UnfreeCache(w, h, rt.index)
	return rt
end

function CLASS:Update()
	if not self._RT then return false end
	if self:IsDisabled() then return false end

	local now = SysTime()
	local framerate = self.Settings.Framerate or 0
	local min_rtframetime = 1 / math.max(framerate, 2)
	local renderNextTime = self._renderNextTime or 0

	if renderNextTime > now then
		return false
	end

	local w, h = self:GetSize()

	self:ProfilerStart("Render")
	render.PushRenderTarget(self._RT.tex, 0, 0, w, h)
		render.Clear(0, 0, 0, 0, true)
		cam.Start2D()
			catchAndErrorNoHaltWithStack(self.CallHook, self, "OnRender")
		cam.End2D()
	render.PopRenderTarget()
	self:ProfilerEnd("Render")

	self._renderNextTime = now + min_rtframetime
	return true
end

function CLASS:Remove()
	self:Free()
	self._RT = nil
	self:CallHook("OnRendertargetRemove")

	BASE.Remove(self)
end

function CLASS:Clear()
	if not self._RT then return end
	if self:IsDisabled() then return end

	local rt = self._RT
	local tex = rt.tex

	render.PushRenderTarget( tex )
		render.Clear( 0, 0, 0, 0, true )
	render.PopRenderTarget( )
end

function CLASS:Render()
	if not self._RT then return end
	if self:IsDisabled() then return end

	local rt = self._RT
	local mat = rt.mat

	local x, y = self:GetPos()
	local w, h = self:GetSize()

	surface.SetMaterial(mat)
	surface.DrawTexturedRectUV(x, y, w, h, 0, 0, 1, 1)
end

function CLASS:SetSize(w, h)
	self.Size.w = next2power(w)
	self.Size.h = next2power(h)
end

function CLASS:GetSize()
	if not self.Size then return 0, 0 end
	return self.Size.w or 0, self.Size.h or 0
end

function CLASS:GetWidth()
	return self.Size.w or 0
end

function CLASS:GetHeight()
	return self.Size.h or 0
end

function CLASS:SetPos(x, y)
	self.Pos.x = x or 0
	self.Pos.y = y or 0
end

function CLASS:GetPos()
	return self.Pos.x or 0, self.Pos.y or 0
end

function CLASS:SetPosX(x)
	self.Pos.x = x or 0
end

function CLASS:GetPosX()
	return self.Pos.x or 0
end

function CLASS:SetPosY(y)
	self.Pos.y = y or 0
end

function CLASS:GetPosY()
	return self.Pos.y or 0
end

function CLASS:GetRendertargetName()
	local rt = self._RT

	if not rt then
		return nil
	end

	local w, h = self:GetSize()

	return GetRendertargetName(w, h, rt.index)
end

function CLASS:HasRendertarget()
	if not self.Valid then return false end
	if self:IsDisabled() then return false end
	if self._RT then return true end
	return false
end

function CLASS:GetRendertarget()
	if not self.Valid then return nil end
	if self:IsDisabled() then return nil end
	return self._RT
end

function CLASS:GetTexture()
	if not self.Valid then return nil end
	if self:IsDisabled() then return nil end
	if not self._RT then return nil end
	return self._RT.tex
end

function CLASS:GetMaterial()
	if not self.Valid then return nil end
	if self:IsDisabled() then return nil end
	if not self._RT then return nil end
	return self._RT.mat
end

function CLASS:IsDisabled()
	if not self.Settings then return true end
	return self.Settings.Disabled or false
end

function CLASS:IsEnabled()
	if not self.Settings then return false end
	return not self.Settings.Disabled
end

function CLASS:SetEnabled(bool)
	if not self.Settings then return end
	self.Settings.Disabled = not bool
end

function CLASS:SetDisabled(bool)
	if not self.Settings then return end
	self.Settings.Disabled = bool or false
end

function CLASS:GetFramerate()
	if not self.Settings then return 0 end
	return self.Settings.Framerate or 0
end

function CLASS:SetFramerate(rate)
	if not self.Settings then return end
	self.Settings.Framerate = rate or 0
end

function CLASS:__tostring()
	local name = self:GetRendertargetName() or "no rendertarget"
	if not self:HasRendertarget() then
		name = "no rendertarget"
	end

	return string.format("[%s][%s]", self.classname, name)
end

function CLASS:__eg(other)
	if self:GetRendertargetName() ~= other:GetRendertargetName() then
		return false
	end

	return true
end

return true


--PATH lua/streamradio_core/classes/clientconvar.lua:
return gluapack()()
--PATH lua/streamradio_core/wire.lua:
return gluapack()()
--PATH lua/streamradio_core/interfaces/file.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/addon-mx-radio.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

local g_addonname = "MX-Radio"
local g_addonid = ""

RADIOFS.name = g_addonname
RADIOFS.type = g_addonname
RADIOFS.icon = StreamRadioLib.GetPNGIcon("format_radio", true)

RADIOFS.addonname = g_addonname
RADIOFS.addonid = g_addonid

RADIOFS.priority = 100
RADIOFS.nocreate = true
RADIOFS.loadToWhitelist = true

RADIOFS._filepath = "mxradio.txt"
RADIOFS._filename = g_addonname
RADIOFS._filenamelower = string.lower(RADIOFS._filename)

function RADIOFS:IsInFolder(vpath)
	local levels = self:GetPathLevels(vpath)
	local firstlevel = levels[1] or ""

	if firstlevel ~= ":addons" then
		return false
	end

	return true
end

function RADIOFS:IsAddonFile(vpath)
	if not self:IsInFolder(vpath) then
		return false
	end

	vpath = string.lower(string.GetFileFromFilename(vpath))

	if vpath ~= self._filenamelower then
		return false
	end

	return true
end

function RADIOFS:IsInstalled()
	if CLIENT then
		return true
	end

	if self._isInstalled ~= nil then
		return self._isInstalled
	end

	if not isfunction(SetUpStationTable) then
		self._isInstalled = false
		return self._isInstalled
	end

	if not file.Exists(self._filepath, "DATA") then
		self._isInstalled = false
		return self._isInstalled
	end

	self._isInstalled = true
	return self._isInstalled
end

function RADIOFS:IsType(globalpath, vpath)
	return self:IsAddonFile(vpath)
end

function RADIOFS:Find(globalpath, vfolder, callback)
	if not self:IsInstalled() then
		callback(false, nil, nil)
		return false
	end

	if vfolder == "" then
		callback(true, nil, {":addons"})
		return true
	end

	if not self:IsInFolder(vfolder) then
		callback(false, nil, nil)
		return false
	end

	callback(true, {self._filename}, nil)
	return true
end

function RADIOFS:Exists(globalpath, vpath)
	if not self:IsInstalled() then
		return false
	end

	if not self:IsAddonFile(vpath) then
		return false
	end

	return true
end

RADIOFS.Delete = nil

local function decodeAddonfile(RawPlaylist)
	local RawPlaylistTab = string.Split( RawPlaylist, "\n" )
	local Playlist = {}

	for i = 1, #RawPlaylistTab, 2 do
		local url = string.Trim( RawPlaylistTab[i] or "" )
		local name = string.Trim( RawPlaylistTab[i + 1] or "" )

		if name == "" then
			name = url
		end

		if url == "" then
			continue
		end

		Playlist[#Playlist + 1] = {
			name = name,
			url = url
		}
	end

	return Playlist
end

function RADIOFS:Read(globalpath, vpath, callback)
	globalpath = self._filepath

	file.AsyncRead(globalpath, "DATA", function(fileName, gamePath, status, data)
		if status ~= FSASYNC_OK then
			callback(false, nil)
			return
		end

		local RawPlaylist = string.Trim(data or "")
		if RawPlaylist == "" then
			callback(true, {})
			return
		end

		local Playlist = decodeAddonfile(RawPlaylist)
		if not Playlist then
			callback(false, nil)
			return
		end

		callback(true, Playlist)
	end)

	return true
end

function RADIOFS:Write(globalpath, vpath, data, callback)
	globalpath = self._filepath
	if not self:CreateDirectoryForFile(globalpath) then
		callback(false)
		return false
	end

	local f = file.Open(globalpath, "w", "DATA")
	if not f then
		callback(false)
		return false
	end

	local dataOut = {}
	local Seperator = "\n"

	for i, v in ipairs(data) do
		local name = string.Trim( string.Replace( v.name, Seperator, "" ) )
		local url = string.Trim( string.Replace( v.url, Seperator, "" ) )

		dataOut[#dataOut + 1] = string.format( "%s" .. Seperator .. "%s\n", url, name )
	end

	local DataString = table.concat(dataOut, "")

	DataString = string.Trim(DataString)
	DataString = DataString .. "\n\n"

	f:Write(DataString)
	f:Close()

	-- Telling the MX-Radio addon to update its playlist.
	self:SavePCall(SetUpStationTable)

	callback(true)
	return true
end

return true


--PATH lua/streamradio_core/filesystem/json.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

RADIOFS.name = "JSON"
RADIOFS.type = "json"
RADIOFS.extension = "json"
RADIOFS.icon = StreamRadioLib.GetPNGIcon("table_sound", true)

RADIOFS.priority = 2000
RADIOFS.loadToWhitelist = true

function RADIOFS:Read(globalpath, vpath, callback)
	file.AsyncRead(globalpath, "DATA", function(fileName, gamePath, status, data)
		if status ~= FSASYNC_OK then
			callback(false, nil)
			return
		end

		local RawPlaylist = string.Trim(data or "")
		if RawPlaylist == "" then
			callback(true, {})
			return
		end

		local Playlist = StreamRadioLib.JSON.Decode(RawPlaylist) or {}

		callback(true, Playlist)
	end)

	return true
end

function RADIOFS:Write(globalpath, vpath, data, callback)
	if not self:CreateDirectoryForFile(globalpath) then
		callback(false)
		return false
	end

	local f = file.Open(globalpath, "w", "DATA")
	if not f then
		callback(false)
		return false
	end

	local DataString = StreamRadioLib.JSON.Encode(data)
	DataString = string.Trim(DataString)
	DataString = DataString .. "\n\n"

	f:Write(DataString)
	f:Close()

	callback(true)
	return true
end

return true


--PATH lua/autorun/sv_tracer_count.lua:
CreateConVar("rw_sw_bit_amount", "10", 8192, "change the amount of bit particle of the reworked impact effects")
CreateConVar("rw_sw_smoke_amount", "5", 8192, "change the amount of smoke particle of the reworked impact effects")
CreateConVar("rw_sw_impact_duration", "4", 8192, "change the duration of the impact color particle of the reworked impact effects")
CreateConVar("rw_sw_impact_size", "16", 8192, "change the size of the impact color particle of the reworked impact effects")

CreateConVar("cl_dynamic_tracer", "0", 8192, "#OVERRIDE# To disable by default the light on tracer to reduce potential crash, you can reactivate it with replace the 0 to 1.")
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_german.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------s

local LANGUAGE = {}
LANGUAGE["General"] = "General"
LANGUAGE["Theme"] = "Theme"
LANGUAGE["Modes"] = "Modi"
LANGUAGE["Whisper"] = "Flüstern"
LANGUAGE["Whisper_Desc"] = "Wie weit hört man Flüstern?"
LANGUAGE["Yell"] = "Schreien"
LANGUAGE["Yell_Desc"] = "Wie weit hört man Schreien?"
LANGUAGE["Talk"] = "Sprechen"
LANGUAGE["Talk_Desc"] = "Wie weit hört man Sprechen?"
LANGUAGE["3D Voice"] = "3D Effekt"
LANGUAGE["3D Voice_Desc"] = "Soll der 3D Effekt aktiviert sein?"
LANGUAGE["Language"] = "Übersetzung"
LANGUAGE["Language_Desc"] = "Welche Übersetzung soll verwendet werden?"
LANGUAGE["Selection Key"] = "Auswahlmenü Keybind"
LANGUAGE["Selection Key_Desc"] = "Welcher Key soll das Auswahlmenü öffnen?"
LANGUAGE["Talking Dead"] = "Sprechende Tote"
LANGUAGE["Talking Dead_Desc"] = "Können tote Spieler sprechen?"
LANGUAGE["Selection Menu Position"] = "Position des Selektionsmenü"
LANGUAGE["Selection Menu Position_Desc"] = "Wo soll sich das Menü befinden?"
LANGUAGE["Save"] = "Speichern"
LANGUAGE["Reset"] = "Zurücksetzen"
LANGUAGE["Preview"] = "Vorschau"
LANGUAGE["PreviewHeader"] = "DRÜCKE [%s] UM DIE VORSCHAU ZU SCHLIEẞEN"
LANGUAGE["PreviewText"] = "´ZURZEITIGE REICHWEITE: %s UNITS"
LANGUAGE["Background"] = "Hintergrund"
LANGUAGE["Background_Desc"] = "Welche Farbe soll für den Hintergrund verwendet werden?"
LANGUAGE["Foreground"] = "Vordergrund"
LANGUAGE["Foreground_Desc"] = "Welche Farbe soll für den Vordergrund verwendet werden?"
LANGUAGE["Hover"] = "Akzentfarbe"
LANGUAGE["Hover_Desc"] = "Welche Akzentfarbe soll verwendet werden?"
LANGUAGE["White"] = "Weiß"
LANGUAGE["White_Desc"] = "Welche Farbe soll als Weiß verwendet werden?"
LANGUAGE["Gray"] = "Grau"
LANGUAGE["Gray_Desc"] = "Welche Farbe soll als Grau verwendet werden?"
LANGUAGE["WelcomeMessage"] = "Dieser Server benutzt Talk Modes, halte %s um deinen Sprachmodus zu ändern!"
LANGUAGE["Turn Off"] = "Ausschalten"
LANGUAGE["Using Mode"] = "Nutze Modus"
LANGUAGE["Auto-Hide"] = "Automatisch ausblenden"
LANGUAGE["Auto-Hide_Desc"] = "Soll die Auswahl bei inaktivität automatisch ausgeblendet werden?"
LANGUAGE["Mode Change Message"] = "Mode Notification"
LANGUAGE["Mode Change Message_Desc"] = "Should players be notified when their talk mode is changed?"

TalkModes.Languages:Register("Deutsch", LANGUAGE)
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_spanish.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_turkish.lua:
local LANGUAGE = {}
LANGUAGE["General"] = "Genel"
LANGUAGE["Theme"] = "Temalar"
LANGUAGE["Modes"] = "Modelar"
LANGUAGE["Whisper"] = "Fısıldama"
LANGUAGE["Whisper_Desc"] = "Fısıldaman ne kadar mesafeye kadar duyulabilsin?"
LANGUAGE["Yell"] = "Bağırma"
LANGUAGE["Yell_Desc"] = "Bağırman ne kadar mesafeye kadar duyulabilsin?"
LANGUAGE["Talk"] = "Konuşma"
LANGUAGE["Talk_Desc"] = "Konuşman ne kadar mesafeye kadar duyulabilsin?"
LANGUAGE["3D Voice"] = "3 Boyutlu Ses"
LANGUAGE["3D Voice_Desc"] = "3 Boyutlu ses aktifleştirilsin mi?"
LANGUAGE["Language"] = "Dil"
LANGUAGE["Language_Desc"] = "Hangi dil kullanilsin?"
LANGUAGE["Selection Key"] = "Secim Tusu"
LANGUAGE["Selection Key_Desc"] = "Hangi tuş seçim menüsünü açsın?"
LANGUAGE["Talking Dead"] = "Konuşan Ölü"
LANGUAGE["Talking Dead_Desc"] = "Ölüler konuşabilsinler mi?"
LANGUAGE["Selection Menu Position"] = "Menü Pozisyonunun Ayari"
LANGUAGE["Selection Menu Position_Desc"] = "Menü nerede bulunsun?"
LANGUAGE["Save"] = "Kaydet"
LANGUAGE["Reset"] = "Sıfırla"
LANGUAGE["Preview"] = "Ön İzleme"
LANGUAGE["PreviewHeader"] = "[%s] TUSUNA BASARAK ÖN İZLENİMDEN CİK"
LANGUAGE["PreviewText"] = "MEVZUT ÖNİZLEME ARALİĞİ: %s BİRİM"
LANGUAGE["Background"] = "Arka Plan"
LANGUAGE["Background_Desc"] = "Arka plan için hangi renk kullanılsın?"
LANGUAGE["Foreground"] = "Ön Plan"
LANGUAGE["Foreground_Desc"] = "Ön plan için hangi renk kullanılsın?"
LANGUAGE["Hover"] = "Vurgu"
LANGUAGE["Hover_Desc"] = "Vurgulanacak olan rengi seciniz?"
LANGUAGE["White"] = "Beyaz"
LANGUAGE["White_Desc"] = "Hangi renk beyaz olarak kullanılsın?"
LANGUAGE["Gray"] = "Gri"
LANGUAGE["Gray_Desc"] = "Hangi renk gri olarak kullanılsın?"
LANGUAGE["WelcomeMessage"] = "Bu sunucu konuşma modu kullanıyor, %s tuşuna basarak konuşma modunu seç!"
LANGUAGE["Turn Off"] = "Kapat"
LANGUAGE["Using Mode"] = "Kullanılan Mod"
LANGUAGE["Auto-Hide"] = "Otomatik Gizle"
LANGUAGE["Auto-Hide_Desc"] = "Seçim menüsü kullanılmadığında otomatik olarak gizlensin mi?"
LANGUAGE["Mode Change Message"] = "Konusma Modu Bildirimi"
LANGUAGE["Mode Change Message_Desc"] = "Konusma modu degistiginde oyunculara bildirilsin mi?"

TalkModes.Languages:Register("Türk", LANGUAGE)
--PATH addons/[chat] talk-modes/lua/talk_modes/core/sh_core.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
local PLAYER = FindMetaTable("Player")

function TalkModes:IsValidMode(strMode)
    local bValid = false

    for i, v in pairs(self.Config:GetTable("Modes")) do 
        if i == strMode then bValid = true end
    end

    return bValid
end

function TalkModes:GetDistance(strMode)
    return self.Config:GetTable("Modes")[strMode] || 0
end

function PLAYER:SetTalkMode(strMode)
    if (SERVER) then 
        if !TalkModes:IsValidMode(strMode) then return end

        self:SetNWString("TalkMode", strMode)
    end
end

function PLAYER:GetTalkMode()
    return self:GetNWString("TalkMode") || "Talk"
end



--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_colorpicker.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_modes.lua:
local PANEL = {}
function PANEL:Init()
    self:SetPageName("Modes")
    self.tblDefaultSettings = {
        ["Whisper"] = {
            strDesc = "Whisper_Desc",
            strType = "tSlider"
        },
        ["Talk"] = {
            strDesc = "Talk_Desc",
            strType = "tSlider"
        },
        ["Yell"] = {
            strDesc = "Yell_Desc",
            strType = "tSlider"
        }
    }
    self:RefreshSettings()
end
vgui.Register("TalkModes.ModesSettings", PANEL, "TalkModes.SettingsBase")

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_navbar.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_settingsbase.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_switch.lua:
local THEME = TalkModes.Client.ActiveTheme
local circles = include("talk_modes/vgui/libs/cl_circles.lua")

local PANEL = {}
AccessorFunc(PANEL, "Value", "Value", FORCE_BOOL)

function PANEL:Init()
    self:SetSize(100, 32)
    self:SetText("")
    self:SetValue(false)

    self.circle = self:Add("DButton")
    self.circle:SetSize(20, 20)
    self.circle:SetPos(0, 5)
    self.circle:SetText("")
    self.circle.func = circles.New(CIRCLE_FILLED, 10, 10, 10)
    self.circle.func:SetDistance(2)
    self.circle.Paint = function()
        draw.NoTexture()
        surface.SetDrawColor((self:GetValue() && self.colGreen) || self.colRed)
        self.circle.func()
    end

    self.circle.DoClick = function()
        self:SetValue(!self:GetValue())
    end

    self.colGreen = Color(39, 174, 96)
    self.colRed = Color(192, 57, 43)
    self.intOffsetX = 0
end

function PANEL:Paint(intW, intH)
    draw.RoundedBox(10, 0, 6, 60, 20, THEME["Background"])
    draw.SimpleText(self:GetValue() && "ON" || "OFF", "TalkModes:Small", intW, intH/2, THEME["White"], TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

    self.intOffsetX = Lerp(FrameTime() * 10, self.intOffsetX, self:GetValue() && 60 - 20 || 0)
    self.circle:SetPos(self.intOffsetX, 5)
end

vgui.Register("TalkModes.Switch", PANEL, "EditablePanel")

--PATH lua/tfa/modules/tfa_ammo.lua:
--[[Bow Ammo]]
--
game.AddAmmoType({
	name = "tfbow_arrow",
	dmgtype = DMG_CLUB,
	tracer = 0,
	minsplash = 5,
	maxsplash = 5
})

game.AddAmmoType({
	name = "tfbow_bolt",
	dmgtype = DMG_CLUB,
	tracer = 0,
	minsplash = 5,
	maxsplash = 5
})

--PATH lua/tfa/modules/tfa_darkrp.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_keyvalues.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_melee_autorun.lua:
local vector_origin = Vector()

local timed_blocking_cv = GetConVar("sv_tfa_melee_blocking_timed")
local angle_mult_cv = GetConVar("sv_tfa_melee_blocking_anglemult")
local deflect_cv = GetConVar("sv_tfa_melee_blocking_deflection")
local stun_cv = GetConVar("sv_tfa_melee_blocking_stun_enabled")
local stuntime_cv = GetConVar("sv_tfa_melee_blocking_stun_time")

local bul = {
	HullSize = 5,
	Num = 1,
	Tracer = 1,
	AmmoType = "",
	TracerName = "Tracer",
	Spread = Vector(0.05,0.05,0),
	Distance = 56756
}

local function CanDeflect()
	return true
end

local function DeflectBullet( ent, dmginfo, olddmg )
	if dmginfo:IsDamageType( DMG_BULLET ) and CanDeflect() and ent.FireBullets then
		bul.Src = ent:GetShootPos()
		bul.Dir = ent:EyeAngles():Forward()
		bul.Damage = olddmg
		bul.Force = olddmg / 10
		local atk = dmginfo:GetAttacker()
		if IsValid( atk ) and atk.TFALastTracer then
			bul.Tracer = atk.TFALastTracer
		end
		ent:FireBullets( bul, false )
		dmginfo:ScaleDamage(0)
	end
end

local stuntime = 0.65

local function StunNPC( npc, ply )
	if stun_cv and not stun_cv:GetBool() then return end
	if ( not IsValid( npc ) ) or ( not npc:IsNPC() ) then
		return
	end
	if npc.ClearSchedule then
		npc:ClearSchedule()
	end
	if npc.SetEnemy then
		npc:SetEnemy(nil)
	end
	if npc.AddEntityRelationship and IsValid(ply) then
		local oldrel = npc.GetRelationship and npc:GetRelationship(ply) or D_HT
		npc:AddEntityRelationship( ply, D_NU, 99)
		stuntime = stuntime_cv:GetFloat()
		timer.Simple( stuntime , function()
			if IsValid(npc) and npc:IsNPC() and IsValid(ply) then
				npc:AddEntityRelationship( ply, oldrel, 99)
			end
		end)
	end
	if npc.ClearEnemyMemory then
		npc:ClearEnemyMemory()
	end
end

local function BlockDamageNew( ent, dmginfo )
	if not ent:IsPlayer() then return end
	if dmginfo:IsDamageType( DMG_DROWNRECOVER ) or dmginfo:IsDamageType(DMG_DIRECT) then return end
	local wep
	wep = ent:GetActiveWeapon()

	if (wep.IsTFAWeapon and wep.BlockDamageTypes and wep:GetStatus() == TFA.Enum.STATUS_BLOCKING) then
		local canblock = false
		for _,v in ipairs(wep.BlockDamageTypes) do
			if dmginfo:IsDamageType(v) then canblock = true end
		end

		local retVal = hook.Run("TFA_MeleeCanBlockDamage", wep, ent, dmginfo, canblock)
		if retVal ~= nil then
			canblock = retVal
		end

		if canblock then
			local damageinflictor, blockthreshold
			damageinflictor = dmginfo:GetInflictor()

			if (not IsValid(damageinflictor)) then
				damageinflictor = dmginfo:GetAttacker()
			end

			blockthreshold = ( wep.BlockCone or 135 ) / 2
			if angle_mult_cv then
				blockthreshold = blockthreshold * angle_mult_cv:GetFloat()
			end
			if ( IsValid(damageinflictor) and ( math.abs(math.AngleDifference( ent:EyeAngles().y, ( damageinflictor:GetPos() - ent:GetPos() ):Angle().y )) <= blockthreshold)) then
				local fac = math.Clamp( ( CurTime() - wep:GetBlockStart() - wep.BlockTimeWindow ) / wep.BlockTimeFade, 0, 1)
				local dmgscale
				if ( not timed_blocking_cv ) or timed_blocking_cv:GetBool() then
					dmgscale = Lerp(fac, wep.BlockDamageMaximum, wep.BlockDamageMinimum)
				else
					dmgscale = wep.BlockDamageMaximum
				end
				local olddmg = dmginfo:GetDamage()
				dmgscale = math.min( dmgscale, wep.BlockDamageCap / dmginfo:GetDamage() )
				--print(fac)
				dmginfo:ScaleDamage(dmgscale)
				dmginfo:SetDamagePosition(vector_origin)
				dmginfo:SetDamageType( bit.bor( dmginfo:GetDamageType(), DMG_DROWNRECOVER ) )
				wep:EmitSound(wep.BlockSound or "")

				if wep.ChooseBlockAnimation then
					wep:ChooseBlockAnimation()
				end

				if deflect_cv and deflect_cv:GetInt() == 2 then
					DeflectBullet( ent, dmginfo, olddmg )
				end

				if dmginfo:GetDamage() < 1 then
					if deflect_cv and deflect_cv:GetInt() == 1 and wep.BlockCanDeflect then
						DeflectBullet( ent, dmginfo, olddmg )
					end
					StunNPC( dmginfo:GetAttacker(), ent )
					return true
				end
				return
			end
		end
	end
end


hook.Add("EntityFireBullets","TFA_Melee_LogTracer",function(ent,bulv) --Record tracer for blocking
	ent.TFALastTracer = bulv.TracerName or ""
end)

local npc_dmg_scale_cv = GetConVar("sv_tfa_melee_damage_npc")
local ply_dmg_scale_cv = GetConVar("sv_tfa_melee_damage_ply")

hook.Add("EntityTakeDamage", "TFA_Melee_Scaling", function( ent, dmginfo )
	local wep = dmginfo:GetInflictor()
	if not IsValid(wep) then return end

	if wep:IsPlayer() then wep = wep:GetActiveWeapon() end
	if not IsValid(wep) or not wep:IsWeapon() or not wep.IsTFAWeapon or not wep.IsMelee then return end

	if ent:IsNPC() then
		dmginfo:ScaleDamage( npc_dmg_scale_cv:GetFloat() )
	elseif ent:IsPlayer() then
		dmginfo:ScaleDamage( ply_dmg_scale_cv:GetFloat() )
	end
end) --Cancel
hook.Add("EntityTakeDamage", "aaa_TFA_Melee_Block", function( ent, dmginfo )
	return BlockDamageNew( ent, dmginfo )
end) --Cancel
hook.Add("ScalePlayerDamage", "aaa_TFA_Melee_Block", function( ent, _, dmginfo ) --Cancel
	return BlockDamageNew( ent, dmginfo )
end)

game.AddAmmoType({
	name = "TFMSwordHitGenericSlash",
	dmgtype = DMG_SLASH,
	tracer = TRACER_NONE
})

local function TFMPlayerSpawn(ply)
	ply:SetNW2Vector("TFM_SwordPosition", Vector(1, 1, 1))
	ply:SetNW2Vector("TFM_SwordNormal", Vector(1, 1, 1))
	ply:SetNW2Bool("TFM_IsSprinting", false)
	ply:SetNW2Bool("TFM_IsBlocking", false)
	ply:SetNW2Bool("TFM_IsSwinging", false)
	ply:SetNW2Float("TFM_SwingStart", CurTime())
end

hook.Add("PlayerSpawn", "TFM_PlayerSpawn", TFMPlayerSpawn)

hook.Add("EntityTakeDamage", "TFM_Block", function(ent, dmginfo) --Legacy
	if ent:IsPlayer() then
		local wep
		wep = ent:GetActiveWeapon()

		if (wep.IsTFAWeapon and wep.BlockAngle) and (dmginfo:IsDamageType(DMG_SLASH) or dmginfo:IsDamageType(DMG_CLUB) or (wep.NinjaMode and wep.NinjaMode == true and (dmginfo:IsDamageType(DMG_CRUSH) or dmginfo:IsDamageType(DMG_BULLET)))) and wep:GetIronSights() then
			local damageinflictor, blockthreshold
			damageinflictor = dmginfo:GetInflictor()

			if (not IsValid(damageinflictor)) then
				damageinflictor = dmginfo:GetAttacker()
			end

			blockthreshold = wep.BlockAngle / 2 or 90

			if (IsValid(damageinflictor) and (math.abs((ent:GetAimVector():Angle() - (damageinflictor:GetPos() - ent:GetPos()):Angle()).y) <= blockthreshold)) or (math.abs((ent:GetAimVector():Angle() - (dmginfo:GetDamagePosition() - ent:GetPos()):Angle()).y) <= blockthreshold) then
				local fac = math.Clamp((CurTime() - wep:GetBlockStart() - wep.BlockWindow) / wep.BlockFadeTime, 0, 1)
				local dmgscale
				if ( not timed_blocking_cv ) or timed_blocking_cv:GetBool() then
					dmgscale = Lerp(fac, wep.BlockMaximum, wep.BlockMinimum)
				else
					dmgscale = wep.BlockMaximum
				end
				--print(fac)
				dmginfo:ScaleDamage(dmgscale)
				dmginfo:SetDamagePosition(vector_origin)
				wep:EmitSound(wep.Primary.Sound_Impact_Metal)

				if wep.BlockAnim then
					wep:BlockAnim()
				end
			end
		end
	end
end)
--Getting the position and angle of an attachment and sending it back to the server is wayyy too laggy.  Must be pre-coded.
--[[
if SERVER then
	util.AddNetworkString( "TFM_SAPacket" )
	net.Receive("TFM_SAPacket", function()
		local ply;
		ply = net.ReadEntity()
		local pos;
		pos = net.ReadVector()
		local norm;
		norm = net.ReadNormal()
		if IsValid(ply) then
			if pos and norm then
				ply:SetNW2Vector("TFM_SwordPosition",pos)
				ply:SetNW2Vector("TFM_SwordNormal",norm)
			end
		end
	end)
end
]]
--
--PATH lua/tfa/modules/tfa_npc_teamcolor.lua:
local ENTMETA = FindMetaTable("Entity")
local PLYMETA = FindMetaTable("Player")
local NPCMETA = FindMetaTable("NPC")

local IsValid = ENTMETA.IsValid

local Alive = PLYMETA.Alive
local GetActiveWeapon = PLYMETA.GetActiveWeapon
local GetAimVector = PLYMETA.GetAimVector
local GetShootPos = PLYMETA.GetShootPos

local Disposition = NPCMETA.Disposition

local util_TraceLine = util.TraceLine
local MASK_SHOT = MASK_SHOT

if SERVER then
	util.AddNetworkString("TFA_NPC_DISP")

	local NPCDispCacheSV = {}
	local function PlayerPostThink(ply)
		if not Alive(ply) then return end

		local wep = GetActiveWeapon(ply)
		if not IsValid(wep) or not wep.IsTFAWeapon then return end

		if not NPCDispCacheSV[ply] then
			NPCDispCacheSV[ply] = {}
		end

		local tr = {}
		tr.start = GetShootPos(ply)
		tr.endpos = tr.start + GetAimVector(ply) * 0xffff
		tr.filter = ply
		tr.mask = MASK_SHOT
		local targent = util_TraceLine(tr).Entity

		if IsValid(targent) and type(targent) == "NPC" then
			local disp = Disposition(targent, ply)

			if not NPCDispCacheSV[ply][targent] or NPCDispCacheSV[ply][targent] ~= disp then
				NPCDispCacheSV[ply][targent] = disp

				net.Start("TFA_NPC_DISP")
				net.WriteEntity(targent)
				net.WriteUInt(disp, 3)
				net.Send(ply)
			end
		end
	end

	hook.Add("PlayerPostThink", "TFA_NPCDispositionSync", PlayerPostThink)
else
	local NPCDispCacheSV = {}
	net.Receive("TFA_NPC_DISP", function()
		local ent = net.ReadEntity()
		local disp = net.ReadUInt(3)

		NPCDispCacheSV[ent] = disp
	end)

	function TFA.GetNPCDisposition(ent)
		return NPCDispCacheSV[ent]
	end
end
--PATH lua/tfa/modules/tfa_nzombies.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_snd_timescale.lua:
local sv_cheats_cv = GetConVar("sv_cheats")
local host_timescale_cv = GetConVar("host_timescale")
local ts

local en_cvar = GetConVar("sv_tfa_soundscale")

hook.Add("EntityEmitSound", "zzz_TFA_EntityEmitSound", function(soundData)
	local ent = soundData.Entity
	local modified
	local weapon

	if ent:IsWeapon() then
		weapon = ent
	elseif ent:IsNPC() or ent:IsPlayer() then
		weapon = ent:GetActiveWeapon()
	end

	if IsValid(weapon) and weapon.IsTFA and weapon.IsTFAWeapon then
		if weapon.GonnaAdjuctPitch then
			soundData.Pitch = soundData.Pitch * weapon.RequiredPitch
			weapon.GonnaAdjuctPitch = false
			modified = true
		end

		if weapon.GonnaAdjustVol then
			soundData.Volume = soundData.Volume * weapon.RequiredVolume
			weapon.GonnaAdjustVol = false
			modified = true
		end
	end

	if not en_cvar then return modified end
	if not en_cvar:GetBool() then return modified end
	ts = game.GetTimeScale()

	if sv_cheats_cv:GetBool() then
		ts = ts * host_timescale_cv:GetFloat()
	end

	if engine.GetDemoPlaybackTimeScale then
		ts = ts * engine.GetDemoPlaybackTimeScale()
	end

	if ts ~= 1 then
		soundData.Pitch = math.Clamp(soundData.Pitch * ts, 0, 255)
		return true
	end

	return modified
end)

--PATH lua/tfa/modules/tfa_tttpatch.lua:
return gluapack()()
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1, band(rshift(state, 27), 1) == 0 and 0 or 1, band(rshift(state, 28), 1) == 0 and 0 or 1, band(rshift(state, 29), 1) == 0 and 0 or 1		end
	
--PATH lua/tfa/modules/cl_tfa_hitmarker.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_inspection.lua:
if CLIENT then
	local doblur = GetConVar("cl_tfa_inspection_bokeh")
	local blurdist = GetConVar("cl_tfa_inspection_bokeh_radius")
	local tfablurintensity = 0
	local blur_mat = Material("pp/bokehblur")
	local tab = {}
	tab["$pp_colour_addr"] = 0
	tab["$pp_colour_addg"] = 0
	tab["$pp_colour_addb"] = 0
	tab["$pp_colour_brightness"] = 0
	tab["$pp_colour_contrast"] = 1
	tab["$pp_colour_colour"] = 1
	tab["$pp_colour_mulr"] = 0
	tab["$pp_colour_mulg"] = 0
	tab["$pp_colour_mulb"] = 0

	local function MyDrawBokehDOF()
		render.UpdateScreenEffectTexture()
		render.UpdateFullScreenDepthTexture()
		blur_mat:SetTexture("$BASETEXTURE", render.GetScreenEffectTexture())
		blur_mat:SetTexture("$DEPTHTEXTURE", render.GetResolvedFullFrameDepth())
		blur_mat:SetFloat("$size", tfablurintensity * 6)
		blur_mat:SetFloat("$focus", 0)
		blur_mat:SetFloat("$focusradius", blurdist:GetFloat())
		render.SetMaterial(blur_mat)
		render.DrawScreenQuad()
	end

	local cv_dxlevel = GetConVar("mat_dxlevel")

	local function Render()
		tfablurintensity = 0

		if cv_dxlevel:GetInt() < 90 then return end
		if TFA.DrawingRenderTarget then return end

		local ply = LocalPlayer()
		if not IsValid(ply) then return end

		local wep = ply:GetActiveWeapon()
		if not IsValid(wep) or not wep.IsTFAWeapon then return end

		tfablurintensity = wep:GetInspectingProgress()

		if tfablurintensity > 0.01 then
			if doblur and doblur:GetBool() then
				MyDrawBokehDOF()
			end

			tab["$pp_colour_brightness"] = -tfablurintensity * 0.02
			tab["$pp_colour_contrast"] = 1 - tfablurintensity * 0.1

			DrawColorModify(tab)
		end
	end

	local function InitTFABlur()
		hook.Add("PreDrawViewModels", "PreDrawViewModels_TFA_INSPECT", Render)

		local pp_bokeh = GetConVar( "pp_bokeh" )
		hook.Remove("NeedsDepthPass","NeedsDepthPass_Bokeh")
		hook.Add("NeedsDepthPass", "aaaaaaaaaaaaaaaaaaNeedsDepthPass_TFA_Inspect", function()
			if not ( doblur and doblur:GetBool() ) then return end

			if tfablurintensity > 0.01 or ( pp_bokeh and pp_bokeh:GetBool() ) then
				DOFModeHack(true)

				return true
			end
		end)
	end

	hook.Add("InitPostEntity","InitTFABlur",InitTFABlur)

	InitTFABlur()
end
--PATH lua/tfa/modules/cl_tfa_materials.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_vm_blur.lua:
local supports
local cl_tfa_fx_dof, cl_tfa_fx_dof_hd
local fmat = CreateMaterial("TFA_DOF_Material4", "Refract", {
	["$model"] = "1",
	["$alpha"] = "1",
	["$alphatest"] = "1",
	["$normalmap"] = "effects/flat_normal",
	["$refractamount"] = "0.1",
	["$vertexalpha"] = "1",
	["$vertexcolor"] = "1",
	["$translucent"] = "1",
	["$forcerefract"] = "0",
	["$bluramount"] = "1.5",
	["$nofog"] = "1"
})

local fmat2 = CreateMaterial("TFA_DOF_Material5", "Refract", {
	["$model"] = "1",
	["$alpha"] = "1",
	["$alphatest"] = "1",
	["$normalmap"] = "effects/flat_normal",
	["$refractamount"] = "0.1",
	["$vertexalpha"] = "1",
	["$vertexcolor"] = "1",
	["$translucent"] = "1",
	["$forcerefract"] = "0",
	["$bluramount"] = "0.9",
	["$nofog"] = "1"
})

local fmat3 = CreateMaterial("TFA_DOF_Material16", "Refract", {
	["$model"] = "1",
	["$alpha"] = "1",
	["$alphatest"] = "1",
	["$normalmap"] = "effects/flat_normal",
	["$refractamount"] = "0.1",
	["$vertexalpha"] = "1",
	["$vertexcolor"] = "1",
	["$translucent"] = "1",
	["$forcerefract"] = "0",
	["$bluramount"] = "0.8",
	["$nofog"] = "1"
})

local white = CreateMaterial("TFA_DOF_White", "UnlitGeneric", {
	["$alpha"] = "0",
	["$basetexture"] = "models/debug/debugwhite"
})

TFA.LastRTUpdate = TFA.LastRTUpdate or UnPredictedCurTime()

hook.Add("PreDrawViewModel", "TFA_DrawViewModel", function(vm, plyv, wep)
	if not vm or not plyv or not wep then return end
	if not wep.IsTFAWeapon then return end

	if supports == nil then
		supports = render.SupportsPixelShaders_1_4() and render.SupportsPixelShaders_2_0() and render.SupportsVertexShaders_2_0()

		if not supports then
			print("[TFA] Your videocard does not support pixel shaders! DoF of Iron Sights is disabled!")
		end
	end

	if not supports then return end

	if not cl_tfa_fx_dof then
		cl_tfa_fx_dof = GetConVar("cl_tfa_fx_ads_dof")
	end

	if not cl_tfa_fx_dof or not cl_tfa_fx_dof:GetBool() then return end
	if not wep.AllowIronSightsDoF then return end
	local aimingDown = wep:GetIronSightsProgress() > 0.4
	local scoped = TFA.LastRTUpdate > UnPredictedCurTime() or wep:GetStatL("Scoped")

	if aimingDown and not scoped then
		if hook.Run("TFA_AllowDoFDraw", wep, plyv, vm) == false then return end
		wep.__TFA_AimDoFFrame = FrameNumber()
		render.ClearStencil()
		render.SetStencilEnable(true)
		render.SetStencilTestMask(0)
		render.SetStencilWriteMask(1)
		render.SetStencilReferenceValue(1)
		render.SetStencilCompareFunction(STENCIL_ALWAYS)
		render.OverrideColorWriteEnable(true, true)
		render.SetStencilZFailOperation(STENCIL_KEEP)
		render.SetStencilPassOperation(STENCIL_REPLACE)
		render.SetStencilFailOperation(STENCIL_KEEP)
	end
end)

local transparent = Color(0, 0, 0, 0)
local color_white = Color(255, 255, 255)
local STOP = false

local function DrawDOF(muzzledata,fwd2)
	local w, h = ScrW(), ScrH()
	render.SetMaterial(fmat)
	cam.Start2D()
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(fmat)
	surface.DrawTexturedRect(0, 0, w, h)
	cam.End2D()

	if muzzledata then
		-- :POG:
		render.SetMaterial(fmat2)

		for i = 28, 2, -1 do
			render.UpdateScreenEffectTexture()
			render.DrawSprite(muzzledata.Pos - fwd2 * i * 3, 200, 200, color_white)
		end
	end

	render.SetMaterial(fmat3)
	cam.Start2D()
	surface.SetMaterial(fmat3)

	for i = 0, 32 do
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(0, h / 1.6 + h / 2 * i / 32, w, h / 2)
	end

	cam.End2D()
end

hook.Add("PostDrawViewModel", "TFA_DrawViewModel", function(vm, plyv, wep)
	if not wep.IsTFAWeapon then return end

	if not supports then
		wep:ViewModelDrawnPost()
		return
	end

	if not cl_tfa_fx_dof then
		cl_tfa_fx_dof = GetConVar("cl_tfa_fx_ads_dof")
	end

	if not cl_tfa_fx_dof_hd then
		cl_tfa_fx_dof_hd = GetConVar("cl_tfa_fx_ads_dof_hd")
	end

	if not cl_tfa_fx_dof or not cl_tfa_fx_dof:GetBool() then
		wep:ViewModelDrawnPost()
		return
	end

	if not wep:GetStatL("AllowIronSightsDoF") then
		wep:ViewModelDrawnPost()
		return
	end

	local aimingDown = wep:GetIronSightsProgress() > 0.4
	local eangles = EyeAngles()
	local fwd2 = vm:GetAngles():Forward()
	local scoped = TFA.LastRTUpdate > UnPredictedCurTime()

	if aimingDown and not scoped and wep.__TFA_AimDoFFrame == FrameNumber() then
		fmat:SetFloat("$alpha", wep:GetIronSightsProgress())

		local muzzle = wep:GetStatL("IronSightsDoF_FocusAttachment")
		if not muzzle then
			wep:UpdateMuzzleAttachment()
			wep:SetStatRawL("IronSightsDoF_FocusAttachment", wep.MuzzleAttachmentRaw)

			muzzle = wep:GetStatL("IronSightsDoF_FocusAttachment")
		end

		muzzle = hook.Run("TFA_GetDoFMuzzleAttachmentID", wep, plyv, vm, muzzle) or muzzle

		local muzzledata
		if muzzle and muzzle ~= 0 then
			muzzledata = vm:GetAttachment(muzzle)
		end

		local hands = plyv:GetHands()

		if IsValid(hands) and wep.UseHands then
			render.OverrideColorWriteEnable(true, false)
			STOP = true
			local candraw = hook.Run("PreDrawPlayerHands", hands, vm, plyv, wep)
			STOP = false
			if candraw ~= true then
				if wep.ViewModelFlip then
					render.CullMode(MATERIAL_CULLMODE_CW)
				end

				hands:DrawModel()

				if wep.ViewModelFlip then
					render.CullMode(MATERIAL_CULLMODE_CCW)
				end
			end

			render.OverrideColorWriteEnable(false, false)
		end

		if muzzledata then
			render.SetStencilPassOperation(STENCIL_ZERO)
			render.SetMaterial(white)
			render.DrawSprite(muzzledata.Pos - fwd2 * 6 + eangles:Up() * 4, 30, 30, transparent)
			render.SetStencilPassOperation(STENCIL_REPLACE)
		end

		render.SetStencilTestMask(1)
		render.SetStencilWriteMask(2)
		render.SetStencilCompareFunction(STENCIL_EQUAL)
		render.SetStencilPassOperation(STENCIL_REPLACE)
		render.UpdateScreenEffectTexture()
		render.PushFilterMin(TEXFILTER.ANISOTROPIC)
		render.PushFilterMag(TEXFILTER.ANISOTROPIC)
		if cl_tfa_fx_dof_hd and cl_tfa_fx_dof_hd:GetBool() then
			DrawDOF(muzzledata,fwd2)
		else
			DrawToyTown(3,ScrH() * 2 / 3 )
		end
		render.PopFilterMin()
		render.PopFilterMag()
		--render.PopRenderTarget()
		render.SetStencilEnable(false)
	end

	wep:ViewModelDrawnPost()
end)

hook.Add("PreDrawPlayerHands", "TFA_DrawViewModel", function(hands, vm, plyv, wep)
	if STOP then return end
	if not wep.IsTFAWeapon then return end
	if not supports then return end

	if not cl_tfa_fx_dof then
		cl_tfa_fx_dof = GetConVar("cl_tfa_fx_ads_dof")
	end

	if not cl_tfa_fx_dof or not cl_tfa_fx_dof:GetBool() then return end
	if not wep.AllowIronSightsDoF then return end
	if TFA.LastRTUpdate > UnPredictedCurTime() then return end
	if wep:GetIronSightsProgress() > 0.4 then return true end
end)

hook.Add("PostDrawPlayerHands", "TFA_DrawViewModel", function(hands, vm, plyv, wep)
	if not wep.IsTFAWeapon then return end

	wep:ViewModelDrawnPostFinal()
end)

--PATH lua/tfa/att/mod_stun20_servius.lua:
return gluapack()()
--PATH lua/autorun/twk_slave_addon.lua:
player_manager.AddValidModel( "Twi'lek Slave", "models/player/slave/twilek_slave_male.mdl" );
list.Set( "PlayerOptionsModel",  "Twi'lek Slave", "models/player/slave/twilek_slave_male.mdl" );


--PATH lua/autorun/venator_bacta.lua:
return gluapack()()
--PATH lua/autorun/venator_colorchange.lua:
// Created by Airfox aka. Konsti
// Huge thanks to him!

if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end

local nextTick = nextTick or 0
local materialHull = Material("kingpommes/starwars/venator/hull_red")
local materialHullPanel = Material("kingpommes/starwars/venator/hull_panels_red")
local materialPropperHull = Material("kingpommes/starwars/venator/hull_red")
local materialPropperHullPanel = Material("models/kingpommes/starwars/venator/propper/hull_red")
local materialPropperInsignia = Material("models/kingpommes/starwars/venator/propper/venator_insignia")
local republicLook = true

materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/venator_insignia")

if SERVER then
	util.AddNetworkString("Venator_Ext_ColorNet")

	-- Networks current state to every new player that joins the server.
	hook.Add("PlayerInitialSpawn", "Venator_Ext_ColorConnectSync", function(ply)
		net.Start("Venator_Ext_ColorNet")
			net.WriteBool(republicLook)
		net.Send(ply)
	end)
end

hook.Add("Think", "Venator_Ext_ColorThink", function()
	if nextTick > CurTime() then return end

	nextTick = CurTime() + 1
	
	if SERVER then
		-- Finds all entities with this name.
		local entities = ents.FindByName("colorchange_target")

		-- Checks if an entity has been found and alarm is on. Also if the network has already been sent.
		if #entities >= 1 and republicLook then
			republicLook = false
			net.Start("Venator_Ext_ColorNet")
				net.WriteBool(republicLook)
			net.Broadcast()

			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull_red" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/invis")
			end
		elseif #entities == 0 and not republicLook then
			republicLook = true
			net.Start("Venator_Ext_ColorNet")
				net.WriteBool(republicLook)
			net.Broadcast()

			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/venator_insignia")
			end
		end
	elseif CLIENT then
		-- Checks if alarm is on. 
		if not republicLook then
			-- Changes between textured.
			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull_red" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/invis")
			end
		else
			-- Resets the texture to default, when the border should be visible.
			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/venator_insignia")
			end
		end
	end
end)

if CLIENT then
	-- Receives current state.
	net.Receive("Venator_Ext_ColorNet", function(len)
		republicLook = net.ReadBool()
	end)
end
--PATH lua/autorun/vj_convars.lua:
return gluapack()()
--PATH lua/autorun/vj_controls.lua:
/*--------------------------------------------------
	=============== VJ Controls ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ VJ Spawnmenu Controls ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
local killIconColor = Color(255, 80, 0, 255)

if !VJ then VJ = {} end -- If VJ isn't initialized, initialize it!

-- Variables ----------------------------------------------------------------------------------------------------
if !VJ.Plugins then VJ.Plugins = {} end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers the addon to the VJ plugin list
		- name = Addon name
		- type = Type of addon | EX: NPC, Weapon, etc.
-----------------------------------------------------------]]
VJ.AddAddonProperty = function(name, type)
	table.insert(VJ.Plugins, {Name = name, Type = type})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers spawn menu category information
		- name = Category name
		- options = Table that holds all possible options
			- Icon = Category icon
-----------------------------------------------------------]]
VJ.AddCategoryInfo = function(category, options)
	list.Set("VJBASE_CATEGORY_INFO", category, {
		icon = options.Icon or "icon16/monkey.png",
	})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC = function(name, class, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a human NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- weapons = Default weapon list for this NPC
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC_HUMAN = function(name, class, weapons, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Weapons = weapons, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the NPC weapon override list
		- name = Weapon's name
		- class = Weapon's class
		- category = The category group it should be in
-----------------------------------------------------------]]
VJ.AddNPCWeapon = function(name, class, category)
	local property = {title = name, class = class, category = category or "VJ Base"}
	list.Add("NPCUsableWeapons", property)
	list.Add("VJBASE_SPAWNABLE_NPC_WEAPON", property)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the weapon spawn list
		- name = Weapon's name
		- class = Weapon's class
		- adminOnly = Is this an admin only weapon?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddWeapon = function(name, class, adminOnly, category, customFunc)
	local property = {PrintName = name, ClassName = class, Category = category, AdminOnly = adminOnly, Spawnable = true}
	if (customFunc) then customFunc(property) end
	list.Set("Weapon", class, property)
	list.Set("VJBASE_SPAWNABLE_WEAPON", class, property)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an entity to the weapon spawn list
		- name = Entity's name
		- class = Entity's class
		- author = Author's name
		- adminOnly = Is this an admin only entity?
		- offset = Spawn offset
		- dropToFloor = Should it drop to the floor on spawn?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddEntity = function(name, class, author, adminOnly, offset, dropToFloor, category, customFunc)
	local Ent = {PrintName = name, ClassName = class, Author = author, AdminOnly = adminOnly, NormalOffset = offset, DropToFloor = dropToFloor, Category = category, Spawnable = true}
	if (customFunc) then customFunc(Ent) end
	list.Set("SpawnableEntities", class, Ent)
	list.Set("VJBASE_SPAWNABLE_ENTITIES", class, Ent)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds and registers a particle file
		- fileName = Addon name | EX: "particles/explosion.pcf"
		- particleList = List of particles to precache from the given particle file
-----------------------------------------------------------]]
VJ.AddParticle = function(fileName, particleList)
	game.AddParticles(fileName)
	for _, name in ipairs(particleList) do
		PrecacheParticleSystem(name)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a ConVar
		- name = Convar name
		- defValue = Default value
		- flags = Convar's flags | Can be a bitflag or a table | Flag List: https://wiki.facepunch.com/gmod/Enums/FCVAR
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddConVar = function(name, defValue, flags, helpText, min, max)
	if !ConVarExists(name) then
		CreateConVar(name, defValue, flags or FCVAR_NONE, helpText or "", min, max)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a client ConVar
		- name = ConVar name
		- defValue = Default value
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddClientConVar = function(name, defValue, helpText, min, max)
	if !ConVarExists(name) then
		CreateClientConVar(name, defValue, true, true, helpText or "", min, max)
	end
end

/*
if CLIENT then
local gmod_npcweapon = CreateConVar("gmod_npcweapon","",{FCVAR_ARCHIVE})
spawnmenu.AddContentType( "vjbase_npc", function( container, obj )
	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end
	if ( !obj.weapon ) then obj.weapon = { "" } end
	local icon = vgui.Create( "ContentIcon", container )
		icon:SetContentType( "vjbase_npc" )
		icon:SetSpawnName( obj.spawnname )
		icon:SetName( obj.nicename )
		icon:SetMaterial( obj.material )
		icon:SetAdminOnly( obj.admin )
		icon:SetNPCWeapon( obj.weapon )
		icon:SetColor(Color(244,164,96,255))
		icon.DoClick = function() 
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			RunConsoleCommand( "vjbase_spawnnpc", obj.spawnname, weapon ) 
			surface.PlaySound( "ui/buttonclickrelease.wav" )
		end
		icon.OpenMenu = function( icon ) 
			local menu = DermaMenu()
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			menu:AddOption( "Copy to Clipboard", function() SetClipboardText( obj.spawnname ) end )
			menu:AddOption( "Spawn Using Toolgun", function() RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "2" ) RunConsoleCommand( "creator_name", obj.spawnname ) RunConsoleCommand( "creator_arg", weapon ) end )
			menu:AddSpacer()
			menu:AddOption( "Delete", function() icon:Remove() hook.Run( "SpawnlistContentChanged", icon ) end )
			menu:Open()
		end
	if (IsValid(container)) then
		container:Add(icon)
	end
	return icon
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseWeapons","AddVJBaseSpawnMenu_weapon",function(pnlContent,tree,node)
	local weapontree = tree:AddNode("Weapons", "icon16/gun.png")
	local Weapons = list.Get("VJBASE_SPAWNABLE_WEAPON")  -- Get a list of available Weapons
	local WeaponCatagory = {}
	for k, weapon in pairs( Weapons ) do
		if ( !weapon.Spawnable ) then continue end
		WeaponCatagory[ weapon.Category ] = WeaponCatagory[ weapon.Category ] or {}
		table.insert( WeaponCatagory[ weapon.Category ], weapon )
	end
	Weapons = nil
	for CategoryName, v in SortedPairs(WeaponCatagory) do -- Create an icon for each one and put them on the panel
		local node = weapontree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.ClassName,
					material	= "entities/"..ent.ClassName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	weapontree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseEntities","AddVJBaseSpawnMenu_Entity",function(pnlContent,tree,node)
	local entitytree = tree:AddNode("Entities", "icon16/bricks.png")
	local EntitiesCategories = {}
	local EntitiesList = list.Get("VJBASE_SPAWNABLE_ENTITIES") -- Get a list of available Entities
	if (EntitiesList) then
		for k, v in pairs(EntitiesList) do
			v.SpawnName = k
			v.Category = v.Category or "Other"
			EntitiesCategories[ v.Category ] = EntitiesCategories[ v.Category ] or {}
			table.insert( EntitiesCategories[ v.Category ], v )
		end
	end
	for CategoryName, v in SortedPairs(EntitiesCategories) do -- Create an icon for each one and put them on the panel
		local node = entitytree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= "entities/"..ent.SpawnName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	entitytree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseNPC","AddVJBaseSpawnMenu_NPC",function(pnlContent,tree,node)
	local npctree = tree:AddNode("NPCs", "icon16/monkey.png")
	local NPCList = list.Get("VJBASE_SPAWNABLE_NPC") -- Get a list of available NPCs
	local NPCCategories = {} -- Categorize them
	for k, v in pairs(NPCList) do
		local Category = v.Category or "Other"
		local Tab = NPCCategories[Category] or {}
		Tab[ k ] = v
		NPCCategories[Category] = Tab
	end
	for CategoryName, v in SortedPairs(NPCCategories) do -- Create an icon for each one and put them on the panel
		local node = npctree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for name, ent in SortedPairsByMemberValue( v, "Name" ) do
				spawnmenu.CreateContentIcon( "vjbase_npc", self.PropPanel, 
				{ 
					nicename	= ent.Name or name,
					spawnname	= name,
					material	= "entities/"..name..".png",
					weapon		= ent.Weapons,
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel(self.PropPanel)
		end	
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if (IsValid(FirstNode)) then
		//FirstNode:InternalDoClick()
	//end
	npctree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
spawnmenu.AddCreationTab("VJ Base",function()
	local ctrl = vgui.Create("SpawnmenuContentPanel")
	ctrl:CallPopulateHook("PopulateVJBaseWeapons")
	ctrl:CallPopulateHook("PopulateVJBaseEntities")
	ctrl:CallPopulateHook("PopulateVJBaseNPC")
	return ctrl
end, "icon16/plugin.png", 60 )
*/
--PATH lua/autorun/vj_sbd1_autorun.lua:
/*--------------------------------------------------
	=============== Autorun File ===============
	*** Copyright (c) 2012-2018 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/

local VJExists = file.Exists("lua/autorun/vj_base_autorun.lua","GAME")
if VJExists == true then
	include('autorun/vj_controls.lua')

	local vCat = "[HC] SBD Edit" -- Category, you can also set a category individually by replacing the vCat with a string value

	VJ.AddNPC("B3Ultra","npc_vj_sbdnew1",vCat)
	VJ.AddNPC("B3NoArmor","npc_vj_sbdnew2",vCat)





-- !!!!!! DON'T TOUCH ANYTHING BELOW THIS !!!!!! -------------------------------------------------------------------------------------------------------------------------
	AddCSLuaFile(AutorunFile)
	VJ.AddAddonProperty(AddonName,AddonType)
else
	if (CLIENT) then
		chat.AddText(Color(0,200,200),PublicAddonName,
		Color(0,255,0)," was unable to install, you are missing ",
		Color(255,100,0),"VJ Base!")
	end
	timer.Simple(1,function()
		if not VJF then
			if (CLIENT) then
				VJF = vgui.Create("DFrame")
				VJF:SetTitle("ERROR!")
				VJF:SetSize(790,560)
				VJF:SetPos((ScrW()-VJF:GetWide())/2,(ScrH()-VJF:GetTall())/2)
				VJF:MakePopup()
				VJF.Paint = function()
					draw.RoundedBox(8,0,0,VJF:GetWide(),VJF:GetTall(),Color(200,0,0,150))
				end
				
				local VJURL = vgui.Create("DHTML",VJF)
				VJURL:SetPos(VJF:GetWide()*0.005, VJF:GetTall()*0.03)
				VJURL:Dock(FILL)
				VJURL:SetAllowLua(true)
				VJURL:OpenURL("https://sites.google.com/site/vrejgaming/vjbasemissing")
			elseif (SERVER) then
				timer.Create("VJBASEMissing",5,0,function() print("VJ Base is Missing! Download it from the workshop!") end)
			end
		end
	end)
end
--PATH addons/[fix] wiltos_animation_fix/lua/autorun/wiltos_animbase_loader.lua:
-- "addons\\wosanim_fixes\\lua\\autorun\\wiltos_animbase_loader.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal

--[[-------------------------------------------------------------------
	Animation Base:
		Create your own animations, mount animations from other games, and more!
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--


if SERVER then
	AddCSLuaFile( "wos/anim_extension/loader/loader.lua" )
end

include( "wos/anim_extension/loader/loader.lua" )
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_customtaunt.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_riddick.lua:
-- "addons\\wosanim_fixes\\lua\\wos\\anim_extension\\extensions\\wos_riddick.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Riddick" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Riddick\n" )
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/vgui/wiltos_anim_viewer.lua:

--[[-------------------------------------------------------------------

	wiltOS Animation Viewer:

		A Supplement to the animation base, it allows you to view more than	

					2000 animations/sequences with it's model viewer

			Powered by

						  _ _ _    ___  ____  

				__      _(_) | |_ / _ \/ ___| 

				\ \ /\ / / | | __| | | \___ \ 

				 \ V  V /| | | |_| |_| |___) |

				  \_/\_/ |_|_|\__|\___/|____/ 

											  

 _____         _                 _             _           

|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 

  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|

  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \

  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/

                                         |___/             

-------------------------------------------------------------------]]--[[

							  

	Lua Developer: King David

	Contact: http://steamcommunity.com/groups/wiltostech

		

----------------------------------------]]--

wOS = wOS or {}



local w, h = ScrW(), ScrH()



surface.CreateFont( "wOS.Anim.TitleFont", {

	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name

	extended = false,

	size = 24*(h/1200),

	weight = 1000,

	blursize = 0,

	scanlines = 0,

	antialias = true,

	underline = false,

	italic = false,

	strikeout = false,

	symbol = false,

	rotary = false,

	shadow = false,

	additive = false,

	outline = false,

} )



surface.CreateFont( "wOS.Anim.DescFont",{

	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name

	extended = false,

	size = 18*(h/1200),

	weight = 500,

	blursize = 0,

	scanlines = 0,

	antialias = true,

	underline = false,

	italic = false,

	strikeout = false,

	symbol = false,

	rotary = false,

	shadow = false,

	additive = false,

	outline = false,

} )



list.Add( "DesktopWindows", {

	icon = "wos/anim_extension/emblem.png",

	title = "wiltOS Viewer",

	init = function() wOS:OpenAnimationMenu() end,

})



function wOS:OpenAnimationMenu()



	if self.OverFrame then 

		self.OverFrame:Remove()

		self.OverFrame = nil

		gui.EnableScreenClicker( false )

		return 

	end



	self.OverFrame = vgui.Create( "DFrame" )

	self.OverFrame:SetSize( w, h )

	self.OverFrame:Center()

	self.OverFrame.Paint = function() end

	self.OverFrame:SetTitle( "" )

	self.OverFrame:ShowCloseButton( false )

	self.OverFrame:SetDraggable( false )

	

	gui.EnableScreenClicker( true )

	self.AnimMenu = vgui.Create( "DFrame", self.OverFrame )

	self.AnimMenu:SetSize( w*0.5, h*0.5 )

	self.AnimMenu:Center()

	self.AnimMenu.Display = LocalPlayer():GetModel()

	self.AnimMenu:MakePopup()

	self.AnimMenu:SetTitle( "" )

	self.AnimMenu:ShowCloseButton( false )

	self.AnimMenu:SetDraggable( false )

	

	local fw, fh = self.AnimMenu:GetSize()

	local padx = fh*0.025

	local pady = padx

	

	local modelmenu = vgui.Create( "DAdjustableModelPanel", self.AnimMenu )

	modelmenu:SetPos( padx, pady )

	modelmenu:SetSize( fw/2 - padx - padx/2, fh - 2*pady )

	modelmenu.LayoutEntity = function() local ent = modelmenu:GetEntity() ent:SetEyeTarget( modelmenu:GetCamPos() ) ent:FrameAdvance( FrameTime() ) end

	

	self.AnimMenu.Paint = function( pan, ww, hh )

		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end

		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )

		--draw.SimpleText( "Animation Viewer", "wOS.Anim.TitleFont", ww/2, hh*0.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	

		surface.SetDrawColor( Color( 0, 155, 155, 255 ) )

		surface.DrawOutlinedRect( padx, pady, modelmenu:GetWide(), modelmenu:GetTall() )

	end 

		

	local lister = vgui.Create( "DListView", self.AnimMenu )

	lister:SetPos( fw/2 + padx/2, pady )

	lister:SetSize( fw/2 - padx - padx/2, fh*0.77 - pady)	

	lister:AddColumn( "Name" )

	lister:SetMultiSelect( false )

	lister:SetHideHeaders( true )

	lister.Pages = {}

	lister.CurrentPage = 1

	

	function lister:Think()

		if wOS.AnimMenu.Display != modelmenu:GetModel() then

			modelmenu:RebuildModel()

		end	

	end

	

	function lister:RebuildCache( ent )

		lister:Clear()

		lister.BasePages = {} // SUPERIOR JACOBS EDIT // https://steamcommunity.com/id/AwesomeJacob/

		lister.Pages = {}

		lister.CurrentPage = 1

		local max = 500

		local count = 0

		local curpage = 1

		for k, v in SortedPairsByValue( ent:GetSequenceList() ) do

			if not lister.BasePages[ curpage ] then lister.BasePages[ curpage ] = {} end

			if count < max then

				table.insert( lister.BasePages[ curpage ], string.lower( v ) )

				if curpage == 1 then

					local line = lister:AddLine( string.lower( v ) )

					line.OnSelect = function()

						ent:ResetSequence( v )

						ent:SetCycle( 0 )

					end

				end

				count = count + 1

			else

				curpage = curpage + 1

				count = 0

			end

		end



		lister.Pages = lister.BasePages

	end



	// SUPERIOR JACOBS EDIT

	// https://steamcommunity.com/id/AwesomeJacob/

	function lister:RebuildToLines( ent, lines )

		lister:Clear()

		lister.Pages = {}

		lister.CurrentPage = 1

		local max = 500

		local count = 0

		local curpage = 1

		for k, v in SortedPairsByValue( lines ) do

			if not lister.Pages[ curpage ] then lister.Pages[ curpage ] = {} end

			if count < max then

				table.insert( lister.Pages[ curpage ], string.lower( v ) )

				if curpage == 1 then

					local line = lister:AddLine( string.lower( v ) )

					line.OnSelect = function()

						ent:ResetSequence( v )

						ent:SetCycle( 0 )

					end

				end

				count = count + 1

			else

				curpage = curpage + 1

				count = 0

			end

		end

	end

	//



	function lister:ChangePage( page )

		lister:Clear()

		if not page then return end	

		if not lister.Pages[ page ] then return end

		local ent = modelmenu:GetEntity()

		for k, v in pairs( lister.Pages[ page ] ) do

			local line = lister:AddLine( string.lower( v ) )

			line.OnSelect = function()

				ent:ResetSequence( v )

				ent:SetCycle( 0 )

			end

		end



		lister:SelectFirstItem()

	end



	function modelmenu:RebuildModel()

		modelmenu:SetModel( wOS.AnimMenu.Display )

		local ent = modelmenu:GetEntity()

		local pos = ent:GetPos()

		local campos = pos + Vector( -150, 0, 0 )

		modelmenu:SetCamPos( campos )

		modelmenu:SetFOV( 45 )

		modelmenu:SetLookAng( ( campos * -1 ):Angle() )

		lister:RebuildCache( modelmenu:GetEntity() )

	end



	local nextbutt = vgui.Create( "DButton", self.AnimMenu )

	nextbutt:SetSize( fw*0.15, fh*0.05 )

	nextbutt:SetPos( fw*0.85 - padx, fh*0.95 - pady*1.5 - nextbutt:GetTall() )

	nextbutt:SetText( "" )

	nextbutt.Paint = function( pan, ww, hh )

		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )

		draw.SimpleText( "NEXT PAGE", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	nextbutt.DoClick = function( pan )

		lister.CurrentPage = math.Clamp( lister.CurrentPage + 1, 1, #lister.Pages )

		lister:ChangePage( lister.CurrentPage )

	end

	

	// SUPERIOR JACOBS EDIT

	// https://steamcommunity.com/id/AwesomeJacob/

	local pagedisplay = vgui.Create( "DLabel", self.AnimMenu )

	pagedisplay:SetSize( fw*0.15, fh*0.05 )

	pagedisplay:SetPos( fw/2 + padx/2, fh*0.95 - pady*2 - nextbutt:GetTall() - pagedisplay:GetTall() )

	pagedisplay:SetText( "" )

	pagedisplay.Paint = function( pan, ww, hh )

		draw.RoundedBox( 5, 0, 0, ww, hh, Color( 155, 155, 155, 155 ) )

		draw.SimpleText( "PAGE: "..lister.CurrentPage.."/"..#lister.Pages, "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end



	local searchbar = vgui.Create( "DTextEntry", self.AnimMenu )

	searchbar:SetSize( fw*0.15 * 1.5, fh*0.05 * 0.8 )

	searchbar:SetPos( fw*0.85 - padx + fw*0.15 - searchbar:GetWide(), fh*0.95 - pady*2 - nextbutt:GetTall() - fh*0.05/2 - searchbar:GetTall()/2 )

	searchbar:SetFont("wOS.Anim.DescFont")

	searchbar:SetText( "" )



	local searchtext = vgui.Create( "DButton", self.AnimMenu )

	searchtext:SetSize( fw*0.15 * 0.5, fh*0.05 )

	searchtext:SetPos( fw/2 + padx/2 + fw*0.15 + padx, fh*0.95 - pady*2 - nextbutt:GetTall() - searchtext:GetTall() )

	searchtext:SetText( "" )

	searchtext.Paint = function( pan, ww, hh )

		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )

		draw.SimpleText( "SEARCH", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	searchtext.DoClick = function( pan )

		local var = string.lower(searchbar:GetValue())

		local page = 1

		local line = 0



		if (var == "") then

			lister.Pages = lister.BasePages

			lister:ChangePage( page )

		else

			local found = {}

									

			for i = 1, #lister.BasePages do

				for _, v in ipairs( lister.BasePages[i] ) do

					if (string.find(v, var)) then

						table.insert(found, v)

					end

				end

			end



			lister:RebuildToLines( modelmenu:GetEntity(), found )

		end

	end

	//



	local prevbutt = vgui.Create( "DButton", self.AnimMenu )

	prevbutt:SetSize( fw*0.15, fh*0.05 )

	prevbutt:SetPos( fw/2 + padx/2, fh*0.95 - pady*1.5 - prevbutt:GetTall() )

	prevbutt:SetText( "" )

	prevbutt.Paint = function( pan, ww, hh )

		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )

		draw.SimpleText( "PREVIOUS PAGE", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	prevbutt.DoClick = function( pan )

		lister.CurrentPage = math.Clamp( lister.CurrentPage - 1, 1, #lister.Pages )

		lister:ChangePage( lister.CurrentPage )

	end

	

	local replaybutt = vgui.Create( "DButton", self.AnimMenu )

	replaybutt:SetSize( fw*0.15, fh*0.05 )

	replaybutt:SetPos( fw/2 + padx/2 + replaybutt:GetWide() + padx, fh*0.95 - pady*1.5 - replaybutt:GetTall() )

	replaybutt:SetText( "" )

	replaybutt.Paint = function( pan, ww, hh )

		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )

		draw.SimpleText( "REPLAY SELECTION", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	replaybutt.DoClick = function( pan )

		local selected = lister:GetSelectedLine()

		if not selected then return end

		local ent = modelmenu:GetEntity()

		ent:ResetSequence( lister:GetLines()[ selected ]:GetValue( 1 ) )

		ent:SetCycle( 0 )		

	end

	

	local closebutt = vgui.Create( "DButton", self.AnimMenu )

	closebutt:SetSize( fw*0.3, fh*0.05 )

	closebutt:SetPos( fw/2 + fw*0.1, fh*0.95 - pady )

	closebutt:SetText( "" )

	closebutt.Paint = function( pan, ww, hh )

		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )

		draw.SimpleText( "CLOSE MENU", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	closebutt.DoClick = function( pan )

		wOS:OpenAnimationMenu()	

	end

	

	local mw, mh = modelmenu:GetSize()

	

	local infoframe = vgui.Create( "DPanel", modelmenu )

	infoframe:SetSize( mw, mh*0.2 )

	infoframe:SetPos( 0, mh*0.8 )

	infoframe.Paint = function( pan, ww, hh )

		if not lister:GetLines()[ lister:GetSelectedLine() ] then return end

		local title = lister:GetLines()[ lister:GetSelectedLine() ]:GetValue( 1 )

		local ent = modelmenu:GetEntity()

		local act = ent:LookupSequence( title )

		draw.SimpleText( "SEQUENCE: " .. title, "wOS.Anim.DescFont", ww/2, hh*0.25, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

		if act then

			local actn = ent:GetSequenceActivityName( act )

			act = ent:GetSequenceActivity( act )

			if not act then 

				draw.SimpleText( "ACT ID: NONE", "wOS.Anim.DescFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

			else

				draw.SimpleText( "ACT ID: " .. act, "wOS.Anim.DescFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

			end

			if not actn then 

				draw.SimpleText( "ACT NAME: N/A", "wOS.Anim.DescFont", ww/2, hh*0.75, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

			else

				draw.SimpleText( "ACT NAME: " .. actn, "wOS.Anim.DescFont", ww/2, hh*0.75, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

			end

		end	

	end

	

	local holdframe = vgui.Create( "DFrame", self.OverFrame )

	holdframe:SetSize( fw*0.3, fh*0.1 )

	holdframe:SetPos( fw*1.5 + fw*0.01, fh - fh/2 )

	holdframe:SetText( "" )

	holdframe:SetTitle( "" )

	holdframe:ShowCloseButton( false )

	holdframe:SetDraggable( false )

	holdframe.Paint = function( pan, ww, hh )

		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )

	end

	holdframe.Think = function( pan )

		local endy = fh*0.1

		if pan.Expand then

			endy = fh

		end

		pan:SetTall( math.Approach( pan:GetTall(), endy, 15 ) )

	end

	holdframe.Expand = false

	holdframe:MakePopup()

	

	local iw, ih = holdframe:GetSize()

	

	local togglebutt = vgui.Create( "DButton", holdframe )

	togglebutt:SetSize( iw*0.9, fh*0.05 )

	togglebutt:SetPos( iw*0.05, ih - fh*0.075 )

	togglebutt:SetText( "" )

	togglebutt.Paint = function( pan, ww, hh )

		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )

		draw.SimpleText( ( holdframe.Expand and "Close Holdtype Creator" ) or "Open Holdtype Creator", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	

	local ACTS = { 

		[ "Idle Standing" ] = "ACT_MP_STAND_IDLE", 

		[ "Slow Walk" ] = "ACT_MP_WALK", 

		[ "Running" ] = "ACT_MP_RUN", 

		[ "Sprinting" ] = "ACT_MP_SPRINT",

		[ "Idle Crouching" ] = "ACT_MP_CROUCH_IDLE", 

		[ "Walk Crouching" ] = "ACT_MP_CROUCHWALK", 

		[ "Attack Standing" ] = "ACT_MP_ATTACK_STAND_PRIMARYFIRE",

		[ "Attack Crouching" ] = "ACT_MP_ATTACK_CROUCH_PRIMARYFIRE",

		[ "Reload Standing" ] = "ACT_MP_RELOAD_STAND",

		[ "Reload Crouching" ] = "ACT_MP_RELOAD_CROUCH",

		[ "Swimming" ] = "ACT_MP_SWIM",

		[ "Jumping" ] = "ACT_MP_JUMP",

		[ "Landing" ] = "ACT_LAND",

	}

	

	local title = vgui.Create( "DLabel", holdframe )

	title:SetSize( iw*0.8, fh*0.05 )

	title:SetPos( iw*0.05, ih )

	title:SetText( "Base Holdtype:" )

	title:SetFont( "wOS.Anim.TitleFont" )

	

	local basetype = vgui.Create( "DTextEntry", holdframe )

	basetype:SetSize( iw*0.8, fh*0.03 )

	basetype:SetPos( iw*0.05, ih + fh*0.05 )

	

	local baselist = vgui.Create( "DImageButton", holdframe )

	baselist:SetSize( fh*0.03, fh*0.03 )

	baselist:SetPos( iw*0.86, ih + fh*0.05 )

	baselist:SetImage( "icon16/application_view_list.png" )	

	baselist.DoClick = function( pan )

		if pan.ItemIconOptions then pan.ItemIconOptions:Remove() pan.ItemIconOptions = nil end

		pan.ItemIconOptions = DermaMenu( baselist )

		pan.ItemIconOptions:MakePopup()

		pan.ItemIconOptions:SetPos( gui.MouseX(), gui.MouseY() )

		pan.ItemIconOptions.Think = function( self )

			if not pan then self:Remove() end

		end

		local holdlist = { "pistol", "smg", "grenade", "ar2", "shotgun", "rpg", "physgun", "crossbow", "melee", "slam", "normal", "fist", "melee2", "passive", "knife", "duel", "camera", "magic", "revolver" }

		for name, _ in pairs( wOS.AnimExtension.TranslateHoldType ) do

			table.insert( holdlist, name )

		end

		for _, typ in ipairs( holdlist ) do

			pan.ItemIconOptions:AddOption( typ, function( self ) 

				basetype:SetText( typ )

				self:Remove()

			end )

		end			

	end

	

	local title = vgui.Create( "DLabel", holdframe )

	title:SetSize( iw*0.9, fh*0.05 )

	title:SetPos( iw*0.05, ih + fh*0.09 )

	title:SetText( "Holdtype Name:" )

	title:SetFont( "wOS.Anim.TitleFont" )

	

	local nametext = vgui.Create( "DTextEntry", holdframe )

	nametext:SetSize( iw*0.9, fh*0.03 )

	nametext:SetPos( iw*0.05, ih + fh*0.15 )

	

	local title = vgui.Create( "DLabel", holdframe )

	title:SetSize( iw*0.9, fh*0.05 )

	title:SetPos( iw*0.05, ih + fh*0.19 )

	title:SetText( "Holdtype Code:" )

	title:SetFont( "wOS.Anim.TitleFont" )

	

	local prefix = vgui.Create( "DTextEntry", holdframe )

	prefix:SetSize( iw*0.9, fh*0.03 )

	prefix:SetPos( iw*0.05, ih + fh*0.25 )

	prefix:SetText( "wos-custom-xxx" )

	

	local title2 = vgui.Create( "DLabel", holdframe )

	title2:SetSize( iw*0.9, fh*0.05 )

	title2:SetPos( iw*0.05, ih + fh*0.29 )

	title2:SetText( "Current Action:" )

	title2:SetFont( "wOS.Anim.TitleFont" )

	

	local DComboBox = vgui.Create( "DComboBox", holdframe )

	DComboBox:SetSize( iw*0.9, fh*0.03 )

	DComboBox:SetPos( iw*0.05, ih + fh*0.35 )

	DComboBox:SetValue( "Idle Standing" )

	for act, _ in pairs( ACTS ) do

		DComboBox:AddChoice( act )

	end

	

	local AddSeq = vgui.Create( "DButton", holdframe )

	AddSeq:SetSize( iw*0.9, fh*0.05 )

	AddSeq:SetPos( iw*0.05, fh*0.515 )

	AddSeq:SetText( "" )

	AddSeq.Paint = function( pan, ww, hh )

		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )

		draw.SimpleText( "Add Selected Sequence", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	

	local AppList = vgui.Create( "DListView", holdframe )

	AppList:SetSize( iw*0.9, fh*0.3 )

	AppList:SetPos( iw*0.05, fh*0.6 )

	AppList:SetMultiSelect( false )

	AppList:AddColumn( "Animation" )

	AppList:AddColumn( "Weight" )

	AppList.OnRowRightClick = function( pan, id, line )

		if pan.ItemIconOptions then pan.ItemIconOptions:Remove() pan.ItemIconOptions = nil end

		pan.ItemIconOptions = DermaMenu( AppList )

		pan.ItemIconOptions:MakePopup()

		pan.ItemIconOptions:SetPos( gui.MouseX(), gui.MouseY() )

		pan.ItemIconOptions.Think = function( self )

			if not pan then self:Remove() end

		end

		pan.ItemIconOptions:AddOption( "Change Weight", function( self ) 



			local Scratch = vgui.Create( "DNumberScratch", holdframe:GetParent() )

			Scratch:SetSize( 1, 1 )

			Scratch:Center()

			Scratch:MakePopup()

			Scratch:SetValue( pan.Selections[ pan.ActSelect ][ line:GetValue( 1 ) ]*100 or 100 )

			Scratch:SetMin( 0 )

			Scratch:SetMax( 100 )

			Scratch.OnMousePressed = function() end

			Scratch.OnMouseReleased = function() end

			Scratch.OnValueChanged = function( panz )

				pan.Selections[ pan.ActSelect ][ line:GetValue( 1 ) ] = math.Round( panz:GetFloatValue() )/100

			end

			Scratch.Think = function( panz )

				if input.IsMouseDown( MOUSE_LEFT ) or input.IsMouseDown( MOUSE_RIGHT ) then

					panz:Remove()

					AppList:ReloadAll()

					return

				end

				panz:SetActive( true )

				panz:MouseCapture( true )

				panz:LockCursor()

				if ( !system.IsLinux() ) then

					panz:SetCursor( "none" )

				end

				panz:SetShouldDrawScreen( true )

			end

			hook.Add( "DrawOverlay", "wOS.AnimExtension.ReallyFuckedUpWorkAround", function()

				if ( !IsValid( Scratch ) ) then hook.Remove( "DrawOverlay", "wOS.AnimExtension.ReallyFuckedUpWorkAround" ) return end

				Scratch:PaintScratchWindow()

			end )

			self:Remove()

		end )	

		pan.ItemIconOptions:AddOption( "Remove", function( self ) 

			pan.Selections[ pan.ActSelect ][ line:GetValue( 1 ) ] = nil

			pan:RemoveLine( id )

			self:Remove()

		end )	

	end

	AppList.Selections = {}

	AppList.ActSelect = DComboBox:GetValue()

	AppList.ReloadAll = function( pan ) 

		pan:Clear()

		if pan.Selections[ pan.ActSelect ] then

			for sequence, weight in pairs( pan.Selections[ pan.ActSelect ] ) do

				pan:AddLine( sequence, weight * 100 .. "%" )

			end

		end

	end

	AppList:ReloadAll()

	

	AddSeq.DoClick = function( pan )

		local l = lister:GetSelected()[1]

		if l then

			AppList:AddLine( l:GetValue(1), "100%" )

			if not AppList.Selections[ AppList.ActSelect ] then

				AppList.Selections[ AppList.ActSelect ] = {}

			end

			AppList.Selections[ AppList.ActSelect ][ l:GetValue(1) ] = 1

		end

	end

	

	DComboBox.OnSelect = function( panel, index, value )

		AppList.ActSelect = value

		AppList:ReloadAll()

	end

	

	togglebutt.DoClick = function( pan )

		holdframe.Expand = !holdframe.Expand

		if !holdframe.Expand then

			basetype:SetText( "" )

			nametext:SetText( "" )

			prefix:SetText( "wos-custom-xxx" )

			DComboBox:SetValue( "Idle Standing" )

			AppList.ActSelect = "Idle Standing"

			AppList.Selections = {}

			AppList:ReloadAll()

		end

	end

	

	local CreateHoldType = vgui.Create( "DButton", holdframe )

	CreateHoldType:SetSize( iw*0.9, fh*0.05 )

	CreateHoldType:SetPos( iw*0.05, fh*0.925 )

	CreateHoldType:SetText( "" )

	CreateHoldType.Paint = function( pan, ww, hh )

		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )

		draw.SimpleText( "Print Holdtype ( Console )", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	end

	CreateHoldType.DoClick = function( pan )

		chat.AddText( color_white, "[", Color( 0, 175, 255 ), "wOS", color_white, "] The Holdtype code has been printed into console!" )

		local name = ( nametext:GetText():len() > 0 and nametext:GetText() ) or "Rename Me" 

		local pref = ( prefix:GetText():len() > 0 and prefix:GetText() ) or "wos-custom-xxx" 

		local base = ( basetype:GetText():len() > 0 and basetype:GetText() ) or "normal"

		print( [[--=====================================================================]] )

		print( [[/*		My Custom Holdtype

			Created by ]] .. LocalPlayer():Nick() .. [[( ]] .. LocalPlayer():SteamID() .. [[ )*/]])

		print( [[

local DATA = {}

DATA.Name = "]] .. name .. [["

DATA.HoldType = "]] .. pref .. [["

DATA.BaseHoldType = "]] .. base .. [["

DATA.Translations = {} 

]])

		for slot, data in pairs( AppList.Selections ) do

			if table.Count( data ) > 0 then

				print( [[DATA.Translations[ ]] .. ACTS[slot] .. [[ ] = {]] )

				for seq, weight in pairs( data ) do

					print( [[	{ Sequence = "]] .. seq .. [[", Weight = ]] .. weight .. [[ },]])

				end

				print( [[}]] )

				print( "" )

			end

		end

		print( [[wOS.AnimExtension:RegisterHoldtype( DATA )]] )

		print( [[--=====================================================================]] )

	end

	

end
--PATH lua/wos/anim_extension/holdtypes/a_combo3.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/arrogant.lua:
local DATA = {}
DATA.Name = "TEST"
DATA.HoldType = "wos_arrogant_corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = -10 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "walk_knife", Weight = -100 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "phalanx_r_run", Weight = -10 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "ryoku_idle_lower", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================

--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/dualblade.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/form3.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/form5.lua:

local DATA = {}
DATA.Name = "form5"
DATA.HoldType = "form5_holdtype"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 
DATA.Translations[ ACT_MP_STAND_IDLE ] = "shienv2_idle"
DATA.Translations[ ACT_MP_WALK ] = "shienv2_run"
DATA.Translations[ ACT_MP_RUN ] = "run_shichoo"
wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH lua/wos/anim_extension/holdtypes/g_combo1.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_combo1"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "combo1" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "combo1" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH lua/wos/anim_extension/holdtypes/leap.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "leap"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "leap" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "leap" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/lscs_vader_holdtype.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/meleetestholdtype.lua:
local DATA = {}
DATA.Name = "melee2"
DATA.HoldType = "wos-meleeheavy-type"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "phalanx_h_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "phalanx_h_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "h_jump", Weight = 1 },
}


wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/saber_staff_dual.lua:
local DATA = {}
DATA.Name = "saberstaffdual"
DATA.HoldType = "wos-saber-staffdual"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "vanguard_f_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "balanced_jump", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================

--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/visigoth.lua:
return gluapack()()
--PATH lua/autorun/wiltos_dynabase_loader.lua:
return gluapack()()
--PATH lua/wos/dynabase/loader/loader.lua:
--[[-------------------------------------------------------------------
	wiltOS Dynamic Animation Base:
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}

local string = string
local file = file

local function _AddCSLuaFile( lua )

	if SERVER then
		AddCSLuaFile( lua )
	end
	
end

local function _include( load_type, lua )

	if load_type then
		include( lua )
	end
	
end

function wOS.DynaBase:Autoloader()

	_AddCSLuaFile( "wos/dynabase/core/sh_core.lua" )
	_include( SERVER, "wos/dynabase/core/sh_core.lua" )
	_include( CLIENT, "wos/dynabase/core/sh_core.lua" )

	_AddCSLuaFile( "wos/dynabase/core/sh_model_operations.lua" )
	_include( SERVER, "wos/dynabase/core/sh_model_operations.lua" )
	_include( CLIENT, "wos/dynabase/core/sh_model_operations.lua" )
	
	_AddCSLuaFile( "wos/dynabase/core/sh_mounting.lua" )
	_include( SERVER, "wos/dynabase/core/sh_mounting.lua" )
	_include( CLIENT, "wos/dynabase/core/sh_mounting.lua" )

	_AddCSLuaFile( "wos/dynabase/core/cl_net.lua" )
	_include( CLIENT, "wos/dynabase/core/cl_net.lua" )

	_AddCSLuaFile( "wos/dynabase/core/cl_core.lua" )
	_include( CLIENT, "wos/dynabase/core/cl_core.lua" )
	_include( SERVER, "wos/dynabase/core/sv_core.lua" )

	_AddCSLuaFile( "wos/dynabase/core/cl_local_copy.lua" )
	_include( CLIENT, "wos/dynabase/core/cl_local_copy.lua" )

	_AddCSLuaFile( "wos/dynabase/core/cl_config_menu.lua" )
	_include( CLIENT, "wos/dynabase/core/cl_config_menu.lua" )

	for _,source in pairs( file.Find( "wos/dynabase/registers/*", "LUA"), true ) do
		local lua = "wos/dynabase/registers/" .. source
		_AddCSLuaFile( lua )
		_include( SERVER, lua )
		_include( CLIENT, lua )
	end
	
end

wOS.DynaBase:Autoloader()
--PATH lua/wos/dynabase/core/cl_config_menu.lua:
wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}
wOS.DynaBase.WorkshopCache = wOS.DynaBase.WorkshopCache or {}

local w, h = ScrW(),  ScrH()

local male_mat = "icon16/male.png"
local female_mat = "icon16/female.png"
local zombie_mat = "icon16/bug.png"
local shared_mat = "icon16/group.png"

local reanim_mat = "icon16/application_edit.png"
local extend_mat = "icon16/application_add.png"

surface.CreateFont( "wOS.DynaBase.TitleFont", {
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 24*(h/1200),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.DynaBase.QuestionFont", {
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 108*(h/1200),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.DynaBase.DescFont",{
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 18*(h/1200),
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.DynaBase.URLFont",{
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 12*(h/1200),
	weight = 300,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = true,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

local function GetContainingAddon( mdl )
	mdl = mdl or "models/m_anm.mdl"
	for _, addon in pairs( engine.GetAddons() ) do
		local modelFound = file.Find(mdl, addon.title)
		if #modelFound != 0 then return addon end 
	end
end

local function GetWorkshopInfo( addon, callback )
	if not addon or not callback then return end
	if wOS.DynaBase.WorkshopCache[ addon.wsid ] then 
		callback( wOS.DynaBase.WorkshopCache[ addon.wsid ].Data, wOS.DynaBase.WorkshopCache[ addon.wsid ].Icon )
		return
	end

	steamworks.FileInfo( addon.wsid, function( result )
		if not result then return end
		wOS.DynaBase.WorkshopCache[ addon.wsid ] = {}
		wOS.DynaBase.WorkshopCache[ addon.wsid ].Data = result
		if not result.previewid then return end
		steamworks.Download( result.previewid, true, function( cache )
			if not cache then callback( result, nil ) return end
			local mat = AddonMaterial(cache)

			// Jazztronauts taught me not to trust this little material
			local baseTex = ( mat and mat:GetTexture("$basetexture") ) or nil
			if baseTex == nil then
				mat = AddonMaterial(cache)
			end			
			wOS.DynaBase.WorkshopCache[ addon.wsid ].Icon =  mat
			callback( result, mat )
		end ) 
	end )
end

function wOS.DynaBase:OpenConfigMenu()

	if self.OverFrame then 
		self.OverFrame:Remove()
		self.OverFrame = nil
		gui.EnableScreenClicker( false )
		return 
	end

	self.OverFrame = vgui.Create( "DFrame" )
	self.OverFrame:SetSize( w, h )
	self.OverFrame:Center()
	self.OverFrame.Paint = function() end
	self.OverFrame:SetTitle( "" )
	self.OverFrame:ShowCloseButton( false )
	self.OverFrame:SetDraggable( false )
	
	gui.EnableScreenClicker( true )
	self.AnimMenu = vgui.Create( "DFrame", self.OverFrame )
	self.AnimMenu:SetSize( w*0.4, h*0.5 )
	self.AnimMenu:Center()
	self.AnimMenu:MakePopup()
	self.AnimMenu:SetTitle( "wiltOS Dynamic Animation Manager" )
	self.AnimMenu:ShowCloseButton( true )
	self.AnimMenu:SetDraggable( true )
	self.AnimMenu.OnClose = function( pan )
		self:OpenConfigMenu()
	end

	local aw, ah  = self.AnimMenu:GetSize()

	local sheet = vgui.Create( "DPropertySheet", self.AnimMenu )
	sheet:SetSize(aw*0.9, ah*0.8)
	sheet:SetPos(aw*0.05, ah*0.05)

	////////////////////////////////////////////////////////////////// Server Menu
	local scroll = vgui.Create("DScrollPanel", sheet )
	scroll:SetSize(aw*0.9, ah*0.8)
	local sw, sh = scroll:GetSize()
	sheet:AddSheet( "Server Animations", scroll, "icon16/server.png" )

	//placehold
	local layout2 
	local layout = vgui.Create("DListLayout", scroll)
	layout:SetSize(sw, sh)
	layout:SetPaintBackground(true)
	layout:SetBackgroundColor(Color(100, 100, 100))

	local temp_loaded = {}
	local temp_count = 0
	local drop_check = WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() >= 2 and WOS_DYNABASE_LOADORDERENFORCE_CVAR:GetBool() 
	if !drop_check then
		layout:MakeDroppable( "WOS_DYNABASE_DROPPABLE" )
		layout.OnModified = function( pan, opnl )
			local opos = pan.DroppedPan.OrderPos
			local npos = opos
			local children = pan:GetChildren()
			for id, child in ipairs( children ) do
				if child != pan.DroppedPan then continue end
				npos = id
				break
			end

			if WOS_DYNABASE_LOADORDERENFORCE_CVAR:GetBool() and ( npos <= temp_count or opos <= temp_count ) then
				if IsValid( pan.DroppedPan.PreviousPanel ) and pan.DroppedPan.PreviousPanel != pan.DroppedPan then
					pan.DroppedPan:MoveToAfter( pan.DroppedPan.PreviousPanel )
				else
					pan.DroppedPan:MoveToBefore( pan.DroppedPan.ForwardPanel )
				end
				return
			end

			for id, child in ipairs( children ) do
				child.OrderPos = id
				child.PreviousPanel = children[id - 1]
				child.ForwardPanel = children[id + 1]
			end
		end
	end

	local lw, lh = layout:GetSize()
	local fw, fh = lw, lh*0.2
	local iw, ih = fh*0.9, fh*0.9

	local add_pad = lw*0.05

	local order_checker = {}
	local disabled_list = {}
	if WOS_DYNABASE_LOADORDERENFORCE_CVAR:GetBool() and self.EnforceCount >= 1 and self.EnforcedOrder then
		for cnt, name in ipairs( self.EnforcedOrder ) do
			local data = self:GetSource( name )
			if not data then continue end
			temp_loaded[ name ] = true
			temp_count = temp_count + 1
			table.insert( order_checker, data )
		end
	end

	if WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() < 2 then

		if self.PlayerOrder and self.PlayerCount > 1 then
			for _, dt in ipairs( self.PlayerOrder ) do
				local name = dt.Name
				local data = self:GetSource( name )
				if not data then continue end
				disabled_list[ name ] = dt.Toggled
				if temp_loaded[ name ] then continue end
				temp_loaded[ name ] = true
				table.insert( order_checker, data )
			end
		end

		for name, data in pairs( self:GetAllSources() ) do
			if temp_loaded[ name ] then continue end
			table.insert( order_checker, data )
		end

	end

	for order, data in ipairs( order_checker ) do
		if WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() >= 1 and not data.ServerValid then continue end
		local name  = data.Name
		local frame = vgui.Create( "DPanel", layout )
		local prev_child = layout:GetChild( order - 2 )
		if prev_child then
			frame.PreviousPanel = prev_child
			prev_child.ForwardPanel = frame
		end
		frame:SetSize( fw, fh )
		frame.Icon = data.IconOverwrite
		frame.RegisterName = name
		frame.PreventSort = order <= temp_count
		frame.OrderPos = order
		frame.Toggled = true
		if disabled_list[ name ] != nil then
			frame.Toggled = disabled_list[ name ]
		end

		frame.OnDrop = function( pan )
			layout.DroppedPan = pan
			return pan
		end
		frame.Paint = function( pan, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 0, 0, 0, 155 ) )
			draw.RoundedBox( 0, ww*0.005, 0, add_pad, hh, Color( 0, 0, 0, 200 ) )

			surface.SetDrawColor( Color( 255, 255, 255, 100 ) )
			surface.DrawOutlinedRect( 0, 0, ww, hh )
			

			if !drop_check and not pan.PreventSort then
				surface.SetDrawColor( color_white )
				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.32, add_pad*0.2, add_pad*0.2 )
				end

				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.5, add_pad*0.2, add_pad*0.2 )
				end

				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.68, add_pad*0.2, add_pad*0.2 )
				end
			end


			local tx, th = draw.SimpleText( pan.RegisterName, "wOS.DynaBase.TitleFont", hh*0.1 + add_pad + iw + ww*0.01, hh*0.06, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP  )
			tx, th = draw.SimpleText( pan.AddonTitle or "Local File", "wOS.DynaBase.DescFont", hh*0.1 + add_pad + iw + ww*0.01, hh*0.06 + th + hh*0.03, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP  )
				

			surface.SetDrawColor( color_white )
			if not pan.Icon then 
				surface.DrawOutlinedRect( hh*0.05 + add_pad , hh*0.05, iw, ih  )
				draw.SimpleText( "?", "wOS.DynaBase.QuestionFont", hh*0.05 + iw*0.5 + add_pad, hh*0.05 + ih*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER  )
			else
				surface.SetMaterial( pan.Icon )
				surface.DrawTexturedRect( hh*0.05 + add_pad, hh*0.05, iw, ih )
			end
			if pan.Toggled then return end
			draw.RoundedBox( 0, hh*0.05 + add_pad, hh*0.05, iw, ih, Color( 0, 0, 0, 215 ) )			

		end

		local url = vgui.Create( "DButton", frame )
		url:SetPos(fh*0.1 + fw*0.01 + iw + add_pad, fh - fh*0.15)
		url:SetSize(fw*0.43, fh*0.125)
		url:SetColor( color_white ) 
		url:SetFont( "wOS.DynaBase.URLFont" )
		url:SetText( "" )
		url.Paint = function( pan, ww, hh )
			local txt = pan.URL or "No Workshop URL"
			draw.SimpleText( txt, "wOS.DynaBase.URLFont", 0, hh*0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
		url:SetDisabled( true )
		url.DoClick = function( pan )
			if not pan.URL then return end
			gui.OpenURL( pan.URL )
		end

		local icon = vgui.Create("DImageButton", frame)
		icon:SetPos(lw*0.01 + add_pad, lw*0.01)
		icon:SetSize(iw, ih)

		local ix, iy = icon:GetPos()

		local validated = vgui.Create("DImage", icon)
		validated:SetPos( -8, -8 )
		validated:SetSize( 16, 16 )
		validated:NoClipping( true )
		validated.UpdateCast = function( pan )
			if !frame.Toggled then
				pan:SetImage( "icon16/delete.png" )
				icon:SetTooltip( "This item is currently disabled"  )
			else
				if data.ServerValid then
					pan:SetImage( "icon16/accept.png" )
					icon:SetTooltip( "This item is registered by the server and client"  )
				else
					pan:SetImage( "icon16/error.png" )		
					icon:SetTooltip( "This item is only registered by the client and may cause unpredictable issues"  )	
				end
			end
		end
		validated:UpdateCast()

		local dock_bar = vgui.Create( "DPanel", frame )
		dock_bar:SetPos(fh*0.1 + fw*0.01 + iw + add_pad , fh - fh*0.42)
		dock_bar:SetSize(fw*0.7, fh*0.2)
		dock_bar:SetPaintBackground( false )

		local thetype = vgui.Create("DImageButton", dock_bar)
		thetype:SetTall( fh*0.2 )
		thetype:SetWide( fh*0.2 )
		thetype:Dock( LEFT )

		if data.Type == WOS_DYNABASE.REANIMATION then
			thetype:SetImage( reanim_mat )
			thetype:SetTooltip( "This addon replaces existing animations" )	
		else
			thetype:SetImage( extend_mat )
			thetype:SetTooltip( "This addon includes new animations" )	
		end

		local div = vgui.Create("DPanel", dock_bar)
		div:SetWide( fh*0.22 )
		div:Dock( LEFT )
		div.Paint = function( pan, ww, hh )
			surface.SetDrawColor( color_white )
			surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
		end
		
		local shared = vgui.Create("DImageButton", dock_bar)
		shared:SetTall( fh*0.2 )
		shared:SetWide( fh*0.2 )
		shared:SetImage( shared_mat )
		shared:Dock( LEFT )
		if data.Shared then
			shared:SetTooltip( "Common / All Gender Animations" )
		else
			shared:SetColor(Color(135, 135, 135, 255))
		end

		local maled = vgui.Create("DImageButton", dock_bar)
		maled:SetTall( fh*0.2 )
		maled:SetWide( fh*0.2 )
		maled:Dock( LEFT )
		maled:SetImage( male_mat )
		if data.Male then
			maled:SetTooltip( "Male Animations" )
		else
			maled:SetColor(Color(125, 125, 125, 125))
		end

		local femaled = vgui.Create("DImageButton", dock_bar)
		femaled:SetTall( fh*0.2 )
		femaled:SetWide( fh*0.2 )
		femaled:Dock( LEFT )
		femaled:SetImage( female_mat )
		if data.Female then
			femaled:SetTooltip( "Female Animations" )
		else
			femaled:SetColor(Color(125, 125, 125, 125))
		end

		local zombied = vgui.Create("DImageButton", dock_bar)
		zombied:SetTall( fh*0.2 )
		zombied:SetWide( fh*0.2 )
		zombied:Dock( LEFT )
		zombied:SetImage( zombie_mat )
		if data.Zombie then
			zombied:SetTooltip( "Zombie Animations" )
		else
			zombied:SetColor(Color(125, 125, 125, 125))
		end

		local mdl = data.Shared
		if not mdl then mdl = data.Male end
		if not mdl then mdl = data.Female end
		if not mdl then mdl = data.Zombie end

		if mdl then
			local function UpdateContent( ndat, mat )
				if ndat and ndat.id then
					frame.AddonTitle = ndat.title
					frame.Description = ndat.description
					frame.ID = ndat.id

					url.URL = "https://steamcommunity.com/sharedfiles/filedetails/?id=" .. ndat.id 
					url:SetDisabled( false )
				end
				frame.Icon = mat
			end
			local addon = GetContainingAddon( mdl )
			GetWorkshopInfo( addon, UpdateContent )
		end


		local check1 = data.Type == WOS_DYNABASE.REANIMATION and WOS_DYNABASE_ENFORCEREANIMATE_CVAR:GetBool()
		local check2 = data.Type == WOS_DYNABASE.EXTENSION and WOS_DYNABASE_ENFORCEEXTENDERS_CVAR:GetBool()
		if !check1 and !check2 then
			local div2 = vgui.Create("DPanel", dock_bar)
			div2:SetWide( fh*0.22 )
			div2:Dock( LEFT )
			div2.Paint = function( pan, ww, hh )
				surface.SetDrawColor( color_white )
				surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
			end

			local toggle = vgui.Create("DButton", dock_bar)
			toggle:SetTall( fh*0.2 )
			if frame.Toggled then
				toggle:SetText( "Unmount Addon" )
			else
				toggle:SetText( "Mount Addon" )
			end
			toggle:SetWide( fw*0.15 )
			toggle:Dock( LEFT )
			toggle.DoClick = function( pan )
				frame.Toggled = !frame.Toggled
				if frame.Toggled then
					pan:SetText( "Unmount Addon" )
				else
					pan:SetText( "Mount Addon" )
				end
				validated:UpdateCast()
			end
		end

		layout:Add( frame )
	end


	////////////////////////////////////////////////////////////////// Local Menu

	-- if WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() > 0 then
	-- 	local err = vgui.Create( "DPanel", sheet )
	-- 	err:Dock( FILL )
	-- 	err.Paint = function( pan, ww, hh )
	-- 		draw.SimpleText( "SERVER HAS DISABLED LOCAL ANIMATION CONTENT", "wOS.DynaBase.TitleFont", ww/2, hh*0.4, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	-- 		draw.SimpleText( "USE THE SERVER TAB FOR AVAILABILITY", "wOS.DynaBase.TitleFont", ww/2, hh*0.6, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
	-- 	end
	-- 	sheet:AddSheet( "User Animations", err, "icon16/user.png" )
	-- else

	local core = vgui.Create( "DPanel", sheet )
	core:SetSize(aw*0.9, ah*0.8)
	sheet:AddSheet( "User Animations", core, "icon16/user.png" )

	local create_butt = vgui.Create( "DButton", core )
	create_butt:SetSize( aw*0.9, ah*0.05 )
	create_butt:Dock( TOP )
	create_butt:SetText( "Create User Mount" )

	local scroll2 = vgui.Create("DScrollPanel", core )
	scroll2:SetSize(aw*0.9, ah*0.69)
	scroll2:Dock( TOP )

	local function PopulateEntries()
		if layout2 then layout2:Remove() end

		local sw, sh = aw*0.9, ah*0.73
		layout2 = vgui.Create("DListLayout", scroll2)
		layout2:SetSize(sw, sh)
		layout2:SetPaintBackground(true)
		layout2:SetBackgroundColor(Color(100, 100, 100))
		layout2:MakeDroppable( "WOS_DYNABASE_DROPPABLE_LOCAL" )

		local local_temp_loaded = {}
		local lw, lh = layout2:GetSize()
		local fw, fh = lw, lh*0.13
		local iw, ih = 0, 0

		local add_pad = lw*0.05

		local local_order_checker = {}

		local read = file.Read( "wos/dynabase/usermounts/preference.txt", "DATA" ) or "{}"
		local local_order = util.JSONToTable( read )
		local enabled_check = {}

		if table.Count( local_order ) > 0 then
			for id, dd in ipairs( local_order ) do
				local name = dd.Name
				local data = self:GetUserMount( name )
				if not data then continue end
				local_temp_loaded[ name ] = true
				table.insert( local_order_checker, data )
				if dd.Toggled then enabled_check[ name ] = true end
			end
		end

		for name, data in pairs( self:GetAllUserMounts() ) do
			if local_temp_loaded[ name ] then continue end
			table.insert( local_order_checker, data )
		end

		for order, data in ipairs( local_order_checker ) do
			local name  = data.Name
			local frame = vgui.Create( "DPanel", layout2 )
			frame:SetSize( fw, fh )
			frame.RegisterName = name
			frame.Toggled = enabled_check[ name ]
			frame.Paint = function( pan, ww, hh )
				draw.RoundedBox( 0, 0, 0, ww, hh, Color( 0, 0, 0, 155 ) )
				draw.RoundedBox( 0, ww*0.005, 0, add_pad, hh, Color( 0, 0, 0, 200 ) )

				surface.SetDrawColor( Color( 255, 255, 255, 100 ) )
				surface.DrawOutlinedRect( 0, 0, ww, hh )
				
				surface.SetDrawColor( color_white )
				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.32, add_pad*0.2, add_pad*0.2 )
				end

				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.5, add_pad*0.2, add_pad*0.2 )
				end

				for i=0, 1 do
					surface.DrawRect( ww*0.005 + add_pad*0.2 + i*(add_pad*0.4), hh*0.68, add_pad*0.2, add_pad*0.2 )
				end

				local tx, th = draw.SimpleText( pan.RegisterName, "wOS.DynaBase.TitleFont", hh*0.1 + add_pad + iw + ww*0.01, hh*0.06, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP  )					
			end

			local dock_bar = vgui.Create( "DPanel", frame )
			dock_bar:SetPos(fh*0.1 + fw*0.01 + iw + add_pad , fh - fh*0.42)
			dock_bar:SetSize(fw*0.7, fh*0.35)
			dock_bar:SetPaintBackground( false )

			local validated = vgui.Create("DImageButton", dock_bar )
			validated:SetTall( fh*0.35 )
			validated:SetWide( fh*0.35 )
			validated:Dock( LEFT )
			validated.UpdateCast = function( pan )
				if !frame.Toggled then
					pan:SetImage( "icon16/delete.png" )
					pan:SetTooltip( "This item is currently disabled"  )
				else
					pan:SetImage( "icon16/accept.png" )
					pan:SetTooltip( "This item is currently enabled"  )
					pan:CheckModelValidity()
				end
			end
			validated.CheckModelValidity = function( pan )
				for _, mdl in ipairs( pan.Models ) do
					if file.Exists( mdl, "GAME" ) then continue end
					pan:SetImage( "icon16/error.png" )
					pan:SetTooltip( "This item is missing models"  )
					return
				end
			end

			local div = vgui.Create("DPanel", dock_bar)
			div:SetWide( fh*0.22 )
			div:Dock( LEFT )
			div.Paint = function( pan, ww, hh )
				surface.SetDrawColor( color_white )
				surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
			end
			
			local mdls = {}

			local shared = vgui.Create("DImageButton", dock_bar)
			shared:SetTall( fh*0.35 )
			shared:SetWide( fh*0.35 )
			shared:SetImage( shared_mat )
			shared:Dock( LEFT )
			if data.Shared then
				table.insert( mdls, data.Shared )
				shared:SetTooltip( "Common / All Gender Animations" )
			else
				shared:SetColor(Color(135, 135, 135, 255))
			end

			local maled = vgui.Create("DImageButton", dock_bar)
			maled:SetTall( fh*0.35 )
			maled:SetWide( fh*0.35 )
			maled:Dock( LEFT )
			maled:SetImage( male_mat )
			if data.Male then
				table.insert( mdls, data.Male )
				maled:SetTooltip( "Male Animations" )
			else
				maled:SetColor(Color(125, 125, 125, 125))
			end

			local femaled = vgui.Create("DImageButton", dock_bar)
			femaled:SetTall( fh*0.35 )
			femaled:SetWide( fh*0.35 )
			femaled:Dock( LEFT )
			femaled:SetImage( female_mat )
			if data.Female then
				table.insert( mdls, data.Female )
				femaled:SetTooltip( "Female Animations" )
			else
				femaled:SetColor(Color(125, 125, 125, 125))
			end

			local zombied = vgui.Create("DImageButton", dock_bar)
			zombied:SetTall( fh*0.35 )
			zombied:SetWide( fh*0.35 )
			zombied:Dock( LEFT )
			zombied:SetImage( zombie_mat )
			if data.Zombie then
				table.insert( mdls, data.Zombie )
				zombied:SetTooltip( "Zombie Animations" )
			else
				zombied:SetColor(Color(125, 125, 125, 125))
			end

			validated.Models = mdls
			validated:UpdateCast()

			local div2 = vgui.Create("DPanel", dock_bar)
			div2:SetWide( fh*0.22 )
			div2:Dock( LEFT )
			div2.Paint = function( pan, ww, hh )
				surface.SetDrawColor( color_white )
				surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
			end

			local toggle = vgui.Create("DButton", dock_bar)
			toggle:SetTall( fh*0.2 )
			if frame.Toggled then
				toggle:SetText( "Unmount" )
			else
				toggle:SetText( "Mount" )
			end
			toggle:SetWide( fw*0.1 )
			toggle:Dock( LEFT )
			toggle.DoClick = function( pan )
				frame.Toggled = !frame.Toggled
				if frame.Toggled then
					pan:SetText( "Unmount" )
				else
					pan:SetText( "Mount" )
				end
				validated:UpdateCast()
			end

			local div3 = vgui.Create("DPanel", dock_bar)
			div3:SetWide( fh*0.22 )
			div3:Dock( LEFT )
			div3.Paint = function( pan, ww, hh )
				surface.SetDrawColor( color_white )
				surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
			end

			local edit = vgui.Create("DButton", dock_bar)
			edit:SetTall( fh*0.2 )
			edit:SetWide( fw*0.1 )
			edit:Dock( LEFT )
			edit:SetText(  "Edit" )
			edit.DoClick = function( pan )
				if IsValid( pan.OverFrame ) then pan.OverFrame:Remove() pan.OverFrame = nil end
				pan.OverFrame = vgui.Create( "DPanel" )
				pan.OverFrame:SetPaintBackground( true )
				pan.OverFrame:SetBackgroundColor( Color( 0, 0, 0, 185  ) )
				pan.OverFrame:SetSize( w, h )
				pan.OverFrame:MakePopup()
				pan.OverFrame.RefreshList = function()
					PopulateEntries()
				end

				self:CreateLocalMenu( pan.OverFrame, data )
			end

			local div4 = vgui.Create("DPanel", dock_bar)
			div4:SetWide( fh*0.22 )
			div4:Dock( LEFT )
			div4.Paint = function( pan, ww, hh )
				surface.SetDrawColor( color_white )
				surface.DrawRect( ww*0.45, 0, ww*0.1, hh )
			end

			local delete = vgui.Create("DButton", dock_bar)
			delete:SetTall( fh*0.2 )
			delete:SetWide( fw*0.1 )
			delete:Dock( LEFT )
			delete:SetText(  "Delete" )
			delete.DoClick = function( pan )
				self:DeleteUserMount( name )
				PopulateEntries()
			end

			layout2:Add( frame )
		end
	end
	
	create_butt.DoClick = function(pan) 
		if IsValid( pan.OverFrame ) then pan.OverFrame:Remove() pan.OverFrame = nil end
		pan.OverFrame = vgui.Create( "DPanel" )
		pan.OverFrame:SetPaintBackground( true )
		pan.OverFrame:SetBackgroundColor( Color( 0, 0, 0, 185  ) )
		pan.OverFrame:SetSize( w, h )
		pan.OverFrame:MakePopup()
		pan.OverFrame.RefreshList = function()
			PopulateEntries()
		end

		self:CreateLocalMenu( pan.OverFrame )
	end

	PopulateEntries()


	////////////////////////////////////////////////////////////////// Helper Menu
	local scroll = vgui.Create("DScrollPanel", sheet )
	scroll:SetSize(aw*0.9, ah*0.8)
	scroll.ReloadAddons = function() PopulateEntries() end
	local sw, sh = scroll:GetSize()
	sheet:AddSheet( "Helper Functions", scroll, "icon16/heart.png" )

	local download_butt = vgui.Create( "DButton", scroll )
	download_butt:SetSize( aw*0.9, ah*0.05 )
	download_butt:Dock( TOP )
	download_butt:SetText( "Convert Server to User Mounts (Will overwrite mounts with the same name!)" )
	download_butt.DoClick = function(pan) 
		for name, data in pairs( self:GetAllSources() ) do
			if data.Core then continue end
			if data.PreventActivities then continue end
			self:CreateUserMount( data )
		end
		PopulateEntries()
		chat.AddText( color_white, "[", Color( 0, 175, 255 ), "wOS-DynaBase", color_white, "] All registered server mounts have been added to your user mount list!" )
	end
	hook.Call( "wOS.DynaBase.PopulateHelperFunctions", nil, scroll )


	local savebutt = vgui.Create("DButton", self.AnimMenu )
	savebutt:SetSize(aw*0.9, ah*0.04)
	savebutt:SetPos( aw*0.05, ah*0.86 )
	savebutt:SetText( "Save Animation Settings" )
	sheet.OnActiveTabChanged = function( pan, old, new )
		local txt = new:GetText()
		if txt:find( "User" ) then
			savebutt:SetText( "Save User Settings" )
			savebutt:Show()
		elseif txt:find( "Server" ) then
			savebutt:SetText( "Save Server Settings" )
			savebutt:Show()
		else
			savebutt:Hide()
		end
	end
	savebutt.DoClick = function( pan )
		if sheet:GetActiveTab():GetText():find( "User" ) then
			if not layout2 then return end
			local order = {}
			for _, child in ipairs( layout2:GetChildren() ) do
				table.insert( order, { Name = child.RegisterName, Toggled = child.Toggled } )
			end
			local pref = util.TableToJSON( order )
			file.Write( "wos/dynabase/usermounts/preference.txt", pref )
			self:ReloadLocalAnimations( order )
		else
			self.PlayerOrder = {}
			self.PlayerCount = 0
			for _, child in ipairs( layout:GetChildren() ) do
				table.insert( self.PlayerOrder, { Name = child.RegisterName, Toggled = child.Toggled } )
				self.PlayerCount = self.PlayerCount + 1
			end
			self:ProcessPlayerOrder()
		end
		self:ReloadAnimations()
	end

	local nobutt = vgui.Create("DButton", self.AnimMenu )
	nobutt:SetSize(aw*0.9, ah*0.04)
	nobutt:SetPos( aw*0.05, ah*0.91 )
	nobutt:SetText( "Cancel" )
	nobutt.DoClick = function() self:OpenConfigMenu() end
	//toggle:SetText( "Cancel" )
end
--PATH lua/wos/dynabase/registers/prone_extend.lua:

wOS.DynaBase:RegisterSource({
    Name = "Prone Mod Extension",
    Type =  WOS_DYNABASE.EXTENSION,
    Shared = "models/player/wiltos/anim_extension_prone.mdl",
})

hook.Add( "PreLoadAnimations", "wOS.DynaBase.MountProne", function( gender )
    if gender != WOS_DYNABASE.SHARED then return end
    IncludeModel( "models/player/wiltos/anim_extension_prone.mdl" )
end )
--PATH lua/xeninui/libs/loader.lua:
XENINUI_SERVER = 1
XENINUI_CLIENT = 2
XENINUI_SHARED = 3

do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Loader",
    setName = function(self, name)
      self.name = name
      return self
    end,
    setAcronym = function(self, acronym)
      self.acronym = acronym
      return self
    end,
    setDirectory = function(self, directory)
      self.directory = directory
      return self
    end,
    setColor = function(self, color)
      self.color = color
      return self
    end,
    getName = function(self)
      return self.name
    end,
    getAcronym = function(self)
      return self.acronym
    end,
    getDirectory = function(self)
      return self.directory
    end,
    getColor = function(self)
      return self.color
    end,
    loadMessage = function(self, path, realm, col)
      if col == nil then col = self:getColor()
      end
      local __laux_type = (istable(path) and path.__type and path:__type()) or type(path)
      assert(__laux_type == "string", "Expected parameter `path` to be type `string` instead of `" .. __laux_type .. "`")
      if (XeninUI.DisableLoadMessages) then return end

      local name = self:getName()

      MsgC(self:getColor(), "[" .. tostring(name), col, " - " .. tostring(realm) .. "] ", color_white, "Loaded ", Color(0, 255, 0), tostring(path) .. "\n")
    end,
    loadFile = function(self, path, realm, func)
      local __laux_type = (istable(path) and path.__type and path:__type()) or type(path)
      assert(__laux_type == "string", "Expected parameter `path` to be type `string` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(realm) and realm.__type and realm:__type()) or type(realm)
      assert(__laux_type == "number", "Expected parameter `realm` to be type `number` instead of `" .. __laux_type .. "`")
      if (!string.EndsWith(path, ".lua")) then path = path .. ".lua"
      end

      local fullPath = self:getDirectory() .. "/" .. path
      if self.loadedFiles[path] then
        if (!self.suppressDuplicates and !XeninUI.DisableLoadMessages) then
          local name = self:getName()
          MsgC(XeninUI.Theme.Red, "[" .. tostring(name) .. "]", color_white, " " .. tostring(fullPath) .. " has already been loaded. Skipping\n")
        end

        return
      end

      local tbl = self.realms[realm]
      self:loadMessage(string.StripExtension(fullPath), tbl.name, tbl.color)
      func = func or tbl.func
      func(self, fullPath)

      self.loadedFiles[path] = true

      return self
    end,
    loadFileOrIgnore = function(self, ...)
      pcall(self:loadFile(...))

      return self
    end,
    load = function(self, dir, realm, recursive, options)
      if recursive == nil then recursive = false
      end
      if options == nil then options = {}
      end
      local __laux_type = (istable(dir) and dir.__type and dir:__type()) or type(dir)
      assert(__laux_type == "string", "Expected parameter `dir` to be type `string` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(realm) and realm.__type and realm:__type()) or type(realm)
      assert(__laux_type == "number" or __laux_type == "table", "Expected parameter `realm` to be type `number|table` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(recursive) and recursive.__type and recursive:__type()) or type(recursive)
      assert(__laux_type == "boolean", "Expected parameter `recursive` to be type `boolean` instead of `" .. __laux_type .. "`")
      local ignoreFiles = options.ignoreFiles or {}
      local overwriteRealm = options.overwriteRealm or {}
      local path = self:getDirectory()
      if (!string.EndsWith(path, "/")) then path = path .. "/"
      end
      if (!string.EndsWith(dir, "/")) then dir = dir .. "/"
      end

      local realmTbl = isnumber(realm) and self.realms[realm]
      local files, folders = file.Find(path .. dir .. "*", "LUA")
      for i, file in ipairs(files) do
        local name = string.StripExtension(file)
        if (ignoreFiles[name]) then continue end

        local fileRealm = realm
        local func = (realmTbl and realmTbl.func)
        local color = (realmTbl and realmTbl.color)
        local realmName = (realmTbl and realmTbl.name)
        if (istable(realm) or overwriteRealm[name]) then
          local realm = overwriteRealm[name] or realm[name]
          if realm then
            local tbl = self.realms[realm]
            func = tbl.func
            color = tbl.color
            realmName = tbl.name
            fileRealm = realm
          end
        end

        local filePath = dir .. file
        self:loadFile(filePath, fileRealm, func)
      end

      if recursive then
        for i, folder in ipairs(folders) do
          self:load(dir .. folder, realm, recursive, options)
        end
      end

      return self
    end,
    done = function(self)
      local time = math.Round(SysTime() - self.start, 4)
      local files = table.Count(self.loadedFiles)

      MsgC(self:getColor(), "[" .. self:getName() .. "]", color_white, " Finished loading " .. tostring(files) .. " files in " .. tostring(time) .. "s\n")
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, suppressDuplicates)
      self.realms = {
        [1] = {
          color = XeninUI.Theme.Blue,
          name = "SV",
          func = function(self, path)
            if (CLIENT) then return end

            return include(path)
          end
        },
        [2] = {
          color = XeninUI.Theme.Orange,
          name = "CL",
          func = function(self, path)
            if CLIENT then
              return include(path)
            end

            AddCSLuaFile(path)
          end
        },
        [3] = {
          color = XeninUI.Theme.Purple,
          name = "SH",
          func = function(self, path)
            self.realms[XENINUI_CLIENT].func(self, path)
            return self.realms[XENINUI_SERVER].func(self, path)
          end
        }
      }
      self.suppressDuplicates = suppressDuplicates or !XeninUI.Debug
      self.start = SysTime()
      self.loadedFiles = {}
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Loader = _class_0
end

--PATH lua/xeninui/libs/essentials_sh.lua:
return gluapack()()
--PATH lua/xeninui/libs/essentials_sh.lua:
function XeninUI:Ease(t, b, c, d)
	t = t / d
	local ts = t * t
	local tc = ts * t


	return b + c * (-2 * tc + 3 * ts)
end

function XeninUI:EaseInOutQuintic(t, b, c, d)
	t = t / d
	local ts = t * t
	local tc = ts * t


	return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc)
end

function XeninUI:RemoveDebounce(name)
	timer.Remove("_debounce." .. name)
end

function XeninUI:Debounce(name, wait, func)
	if timer.Exists("_debounce." .. name) then
		timer.Remove("_debounce." .. name)
	end

	timer.Create("_debounce." .. name, wait, 1, function()
		func()

		timer.Remove("_debounce." .. name)
	end)
end

if SERVER then
	util.AddNetworkString("XeninUI.FullClientInit")

	net.Receive("XeninUI.FullClientInit", function(len, p)
		if p.XeninUI_FullClientInit then
			return
		end

		hook.Run("Xenin.OnClientFullInit", p)

		p.XeninUI_FullClientInit = true
	end)
else
	hook.Add("SetupMove", "Xenin.FullClientInit", function()
		timer.Simple(15, function()
			net.Start("XeninUI.FullClientInit")
			net.SendToServer()
		end)

		hook.Remove("SetupMove", "Xenin.FullClientInit")
	end)
end

function XeninUI:LerpColor(fract, from, to)
	return Color(Lerp(fract, from.r, to.r), Lerp(fract, from.g, to.g), Lerp(fract, from.b, to.b), Lerp(fract, from.a or 255, to.a or 255))
end

function XeninUI:GetAngleBetweenTwoVectors(a, b)
	local vec = (a - b):GetNormalized()
	local ang = vec:Angle()

	return ang
end

function XeninUI:GetVector2DDistance(a, b)

	return math.sqrt((a.x - b.x) ^ 2 + (a.y - b.y) ^ 2)
end


function XeninUI:LerpVector(frac, from, to, ease)
	local newFract = ease and ease(frac, 0, 1, 1) or XeninUI:Ease(frac, 0, 1, 1)

	return LerpVector(newFract, from, to)
end

function XeninUI:LerpAngle(frac, from, to, ease)
	local newFract = ease and ease(frac, 0, 1, 1) or XeninUI:Ease(frac, 0, 1, 1)

	return LerpAngle(newFract, from, to)
end

if SERVER then
	util.AddNetworkString("XeninUI.OSTime")

	hook.Add("PlayerInitialSpawn", "XeninUI.OSTime", function(p)
		net.Start("XeninUI.OSTime")
		net.WriteFloat(os.time())
		net.WriteFloat(CurTime())
		net.Send(p)
	end)
else
	os._SVRDiff = 0

	net.Receive("XeninUI.OSTime", function()
		local ostime = net.ReadFloat()
		local ct = net.ReadFloat()

		os._SVRDiff = os.time() - ostime + ct - CurTime()
	end)

	function os.ServerTime()
		return os.time() - os._SVRDiff
	end

	local function TCMD()
		print(os.time(), os.ServerTime(), os.date("%I:%M %p", os.time()), os.date("%I:%M %p", os.ServerTime()))
	end
	concommand.Add("print_servertime", TCMD)
end

function XeninUI:Map(tbl, func)
	local newTbl = {}
	for i, v in pairs(tbl) do
		newTbl[i] = func(v, i)
	end

	return newTbl
end


function XeninUI:Hue2RGB(p, q, t)
	if t < 0 then t = t + 1 end
	if t > 1 then t = t - 1 end
	if t < 1 / 6 then return p + (q - p) * 6 * t end
	if t < 1 / 2 then return q end
	if t < 2 / 3 then return p + (q - p) * (2 / 3 - t) * 6 end
	return p
end


function XeninUI:HSLToColor(h, s, l, a)
	local r, g, b
	local t = h / (2 * math.pi)

	if s == 0 then
		r, g, b = l, l, l
	else
		local q
		if l < 0.5 then
			q = l * (1 + s)
		else
			q = l + s - l * s
		end
		local p = 2 * l - q

		r = self:Hue2RGB(p, q, t + 1 / 3)
		g = self:Hue2RGB(p, q, t)
		b = self:Hue2RGB(p, q, t - 1 / 3)
	end

	return Color(r * 255, g * 255, b * 255, (a or 1) * 255)
end


function XeninUI:ColorToHSL(col)
	local r = col.r / 255
	local g = col.g / 255
	local b = col.b / 255
	local max, min = math.max(r, g, b), math.min(r, g, b)
	local b = max + min
	local h = b / 2
	if max == min then return 0, 0, h end
	local s, l = h, h
	local d = max - min
	s = l > .5 and d / (2 - b) or d / b
	if max == r then h = (g - b) / d + (g < b and 6 or 0)
	elseif max == g then
		h = (b - r) / d + 2
	elseif max == b then
		h = (r - g) / d + 4
	end
	return h * .16667, s, l
end

function XeninUI:DecToHex(d, zeros)
	return string.format("%0" .. (zeros or 2) .. "x", d)
end

function XeninUI:RGBToHex(color)
	return "#" .. self:DecToHex(math.max(math.min(color.r, 255), 0)) .. self:DecToHex(math.max(math.min(color.g, 255), 0)) .. self:DecToHex(math.max(math.min(color.b, 255), 0))
end

function XeninUI:HexToRGB(hex)
	hex = hex:gsub("#", "")

	if (#hex == 3) then
		local r = hex:sub(1, 1)
		local g = hex:sub(2, 2)
		local b = hex:sub(3, 3)

		return Color(tonumber("0x" .. r .. r), tonumber("0x" .. g .. g), tonumber("0x" .. b .. b))
	end

	return Color(tonumber("0x" .. hex:sub(1, 2)), tonumber("0x" .. hex:sub(3, 4)), tonumber("0x" .. hex:sub(5, 6)))
end

--PATH lua/xeninui/libs/promises.lua:
return gluapack()()
--PATH lua/xeninui/libs/scripts/network/client.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/sidebar.lua:
local PANEL = {}

XeninUI:CreateFont("Xenin.Configurator.Admin.Sidebar", 20)

function PANEL:Init()
  self.Tabs = {}
  self.Panels = {}

  self:DockPadding(5, 8, 16, 16)

end

function PANEL:SetActiveByName(name)
  for i, v in ipairs(self.Tabs) do
    if (v.Name != name) then continue end

    self:SetActive(v.Id)
    break
  end
end

function PANEL:GetActivePanel()
  return self.Panels[self.Active]
end

function PANEL:SetActive(id)
  local active = self.Active
  self.Active = id

  local tab = self.Tabs[active]
  local pnl = self.Panels[active]
  if IsValid(tab) then
    tab:OnCursorExited()
  end
  if IsValid(pnl) then
    pnl:SetVisible(false)
  end

  tab = self.Tabs[id]
  pnl = self.Panels[id]
  if IsValid(tab) then
    tab:OnCursorEntered()
  end
  if IsValid(pnl) then
    pnl:SetVisible(true)
  end
end

function PANEL:AddTab(name, icon, color, panel, script, rawData)
  local btn = self:Add("DButton")
  btn:Dock(TOP)
  btn:DockMargin(0, 0, 0, -4)
  btn:SetText("")
  btn:SetTall(42)
  btn.Name = name
  btn.Color = color
  btn.TextColor = Color(208, 208, 208)
  XeninUI:DownloadIcon(btn, icon)
  btn.Paint = function(pnl, w, h)
    XeninUI:DrawIcon(11, 11, h - 22, h - 22, pnl, color, color)

    draw.SimpleText(pnl.Name, "Xenin.Configurator.Admin.Sidebar", h, h / 2, pnl.TextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  btn.OnCursorEntered = function(pnl)
    pnl:LerpColor("TextColor", pnl.Color)
  end
  btn.OnCursorExited = function(pnl)
    if (self.Active == pnl.Id) then return end

    pnl:LerpColor("TextColor", Color(208, 208, 208))
  end
  btn.DoClick = function(pnl)
    self:SetActive(pnl.Id)
  end

  local panel = self:GetParent():Add(panel)
  panel:Dock(FILL)
  panel:SetVisible(false)
  if panel.SetScript then
    panel:SetScript(script)
  end
  if panel.SetData then
    panel:SetData(rawData)
  end

  local id = table.insert(self.Tabs, btn)
  self.Tabs[id].Id = id
  self.Panels[id] = panel
  self.Panels[id].Id = id
end

function PANEL:Paint(w, h)
  XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Navbar, false, false, true, false)
end

vgui.Register("Xenin.Configurator.Admin.Sidebar", PANEL)

--PATH lua/xeninui/libs/configurator/ui/top.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/entities/entity_list.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/entities/row.lua:
local PANEL = {}

function PANEL:Init()
  self:SetText("")

  self.BackgroundColor = XeninUI.Theme.Navbar
  self.Name = "Common"
  self.Color = Color(180, 180, 180)
  self.Rotation = 0
  self.ArrowColor = self.Color
  self.State = false

  self.Delete = self:Add("DButton")
  self.Delete:SetVisible(false)
  self.Delete:SetText("")
  self.Delete.Color = ColorAlpha(XeninUI.Theme.Red, 150)
  self.Delete.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Color)

    surface.SetDrawColor(color_white)
    surface.SetMaterial(XeninUI.Materials.CloseButton)
    local margin = 8
    surface.DrawTexturedRect(margin, margin, w - (margin * 2), h - (margin * 2))
  end
  self.Delete.DoClick = function(pnl)
    local shiftDown = input.IsKeyDown(KEY_LSHIFT)
    if shiftDown then
      self.Entity:delete(true)
      self:Remove()
    else
      XeninUI:SimpleQuery("Delete", "Are you sure you want to delete this?", "Yes, delete", function()
        self.Entity:delete(true)
        self:Remove()
      end, "No", function()
        if (self:IsHovered()) then return end

        self.Delete:SetVisible(false)
      end)
    end
  end

  XeninUI:DownloadIcon(self, "2QGKAd6")
end

function PANEL:PerformLayout(w, h)
  self.Delete:SetPos(8, 8)
  local size = 48 - 16
  self.Delete:SetSize(size, size)
end

function PANEL:SetEntity(entity)
  self.Entity = entity
  self.Id = entity:getId()
  self.Name = entity.transformName and entity:transformName(entity:getName()) or entity:getName()
  if istable(self.Name) then
    local tbl = self.Name
    self.Name = tbl[1]
  end
  self.Color = entity.getColor and entity:getColor() or color_white
  if (type(self.Color) != "Color") then
    self.Color = color_white
  end

  timer.Simple(0.2, function()
    if (!IsValid(self)) then return end
    if (self.Id != 1) then return end


  end)
end

function PANEL:Paint(w, h)
  local name = self.Name
  local font = "Xenin.Configurator.Admin.Panel.Setting"
  if (!name or name == "") then
    name = "Unnamed"
    font = "Xenin.Configurator.Admin.Panel.Setting.Italic"
  end

  local x = self.Delete:IsVisible() and 8 + self.Delete:GetWide() + 8 or 8
  draw.SimpleText(name, font, x, 48 / 2, self.Color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

  surface.SetDrawColor(100, 100, 100)
  surface.DrawLine(0, 48 - 1, w, 48 - 1)

  local size = 48 / 3
  XeninUI:DrawIconRotated(w - size - 8, size + size / 2, size, size, self.Rotation, self, self.ArrowColor)
end

function PANEL:CreateSettings()
  self.Settings = self:Add("Xenin.Configurator.Admin.Entity.Row.Settings")
  self.Settings:AddSettings(self.Entity)
  self.Settings:SetTall(0)
  self.Settings.GetChildSize = function(pnl)
    local height = 0
    local size = 0
    for i, v in ipairs(pnl.Settings) do
      if (!v:IsVisible()) then continue end

      size = size + 1
      height = height + v:GetTall()
    end
    height = height - (size * 3)

    return height
  end
end

function PANEL:SetExpanded(state)
  self:Lerp("Rotation", state and 180 or 0, 0.4)

  if (!IsValid(self.Settings)) then
    self:CreateSettings()
  end

  local size = self.Settings:GetChildSize()
  self.Settings:LerpHeight(state and size or 0, 0.4)
end

function PANEL:DoClick()
  self.State = !self.State
  self:SetExpanded(self.State)
end

function PANEL:OnCursorEntered()
  if (!self.Delete:IsHovered()) then
    self.Delete:SetVisible(true)
  end

  self:LerpColor("ArrowColor", color_white)
end

function PANEL:OnCursorExited()
  if (!self.Delete:IsHovered()) then
    self.Delete:SetVisible(false)
  end

  if (self.State) then return end

  self:LerpColor("ArrowColor", Color(180, 180, 180))
end

vgui.Register("Xenin.Configurator.Admin.Entity.Row", PANEL, "DButton")

--PATH lua/xeninui/libs/configurator/ui/inputs/textentrywithlabel.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/toggle.lua:
local x

--PATH lua/xeninui/elements/checkbox_v2.lua:
return gluapack()()
--PATH lua/xeninui/elements/notifications.lua:
XeninUI.Notifications = XeninUI.Notifications or {}

XeninUI:CreateFont("XeninUI.Notification", 18)

local standardIcons = {
  [NOTIFY_GENERIC] = Material("vgui/notices/generic"),
  [NOTIFY_ERROR] = Material("vgui/notices/error"),
  [NOTIFY_UNDO] = Material("vgui/notices/undo"),
  [NOTIFY_HINT] = Material("vgui/notices/hint"),
  [NOTIFY_CLEANUP] = Material("vgui/notices/cleanup")
}

local PANEL = {}

AccessorFunc(PANEL, "m_progressColor", "Color")
AccessorFunc(PANEL, "m_animTime", "AnimTime")
AccessorFunc(PANEL, "m_iconColor", "IconColor")

function PANEL:Init()
  self.textColor = Color(225, 225, 225)
  self:SetAnimTime(0.2)
  self:SetColor(XeninUI.Theme.Accent)
  self:SetIconColor(color_white)

  self.icon = vgui.Create("Panel", self)
  self.icon.Paint = function(pnl, w, h)
    if (!self.img or type(self.img) != "IMaterial") then return end

    surface.SetDrawColor(self:GetIconColor())
    surface.SetMaterial(self.img)
    surface.DrawTexturedRect(0, 0, w, h)
  end

  self.label = vgui.Create("DLabel", self)
  self.label:SetText("")
  self.label:SetFont("XeninUI.Notification")
  self.label:SetTextColor(self.textColor)
end

function PANEL:SetIcon(icon)
  self.img = icon
end

function PANEL:SetAvatar(ply)
  self.icon = vgui.Create("XeninUI.Avatar", self)
  self.icon:DockMargin(8, 8, 8, 8)
  self.icon:SetVertices(90)
  self.icon:SetPlayer(ply, 32)

  self.icon:SetWide(self.icon:GetTall())

  self:InvalidateLayout()
end

function PANEL:SetTextColor(col)
  self.label:SetTextColor(col)
end

function PANEL:SetText(text)
  if istable(text) then
    self.markup = text
    self.label:SetVisible(false)
  else
    self.label:SetText(text)
    self.label:SizeToContents()
  end
end

function PANEL:Paint(w, h)
  draw.RoundedBox(h / 2, 0, 0, w, h, XeninUI.Theme.Primary)

  local start = self.startTime
  local current = SysTime()
  local timeLeft = current - start

  local width = timeLeft * (w / self.duration)

  local x, y = self:LocalToScreen()
  render.SetScissorRect(x, y, x + w - width, y + h, true)
  draw.RoundedBox(h / 2, 0, 0, w, h, self:GetColor())
  render.SetScissorRect(0, 0, 0, 0, false)

  if self.markup then
    self.markup:Draw(8 + (h - 4 - 8) + 4, h / 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
end

function PANEL:Close()
  local id = self.id
  table.remove(XeninUI.Notifications, id)
  hook.Run("XeninUI.NotificationRemoved")

  self:LerpMove(ScrW() + self:GetWide(), self.y, self:GetAnimTime(), function()
    if (!IsValid(self)) then return end

    self:Remove()
  end)
end

function PANEL:SetDuration(time)
  self.duration = time
  self.startTime = SysTime()

  timer.Simple(time, function()
    if (!IsValid(self)) then return end

    self:Close()
  end)
end

function PANEL:PerformLayout(w, h)
  self.icon:SetPos(8, 6)
  self.icon:SetWide(h - 4 - 8)
  self.icon:SetTall(self.icon:GetWide())

  self.label:SetWide(w - self.icon:GetWide() - 8)
  self.label:SetPos(self.icon.x + self.icon:GetWide() + 6, 8)
end

function PANEL:StartNotification()
  local text = self.label:GetText()
  surface.SetFont("XeninUI.Notification")
  local tw, th = surface.GetTextSize(text)
  local width = 8 + 24 + 8 + tw + 8
  if self.markup then
    width = width + self.markup:GetWidth()
  end
  local x = ScrW() + width
  local y = ScrH() - 200
  local offset = (self.id - 1) * 45
  y = y - offset

  self:SetSize(width, 36)
  self:SetPos(x, y)
  self:LerpMove(ScrW() - width - 20, y, self:GetAnimTime())
end

vgui.Register("XeninUI.Notification", PANEL, "Panel")

function XeninUI:Notify(text, icon, duration, progressColor, textColor)

  if XeninUI.DisableNotification then
    icon = isnumber(icon) and icon or NOTIFY_HINT

    notification.AddLegacy(text or "No Notification Text", icon, duration or 4)

    return
  end

  text = text or "No Notification Text"
  icon = icon or Material("xenin/logo.png", "noclamp smooth")
  duration = duration or 4
  progressColor = progressColor or XeninUI.Theme.Accent
  textColor = textColor or Color(215, 215, 215)
  iconColor = iconColor or color_white

  local panel = vgui.Create("XeninUI.Notification")
  panel.Start = SysTime()
  panel:SetSize(width, 36)
  panel:SetPos(x, y)
  panel:SetText(text)
  panel:SetColor(progressColor)
  if isnumber(icon) then
    panel:SetIcon(standardIcons[icon])
  elseif isstring(icon) then
    panel:SetIcon(Material(icon, "smooth"))
  elseif (IsValid(icon) and icon:IsPlayer()) then
    panel:SetAvatar(icon)
  else
    panel:SetIcon(icon)
  end
  panel:SetTextColor(textColor)
  panel:SetIconColor(iconColor)
  panel:SetDuration(duration)
  local id = table.insert(self.Notifications, panel)
  panel.id = id
  self.Notifications[id].id = id
  panel:StartNotification()
  surface.PlaySound("buttons/lightswitch2.wav")
end

hook.Add("Initialize", "NotificationOverride", function()
  local oldNotification = notification.AddLegacy
  function notification.AddLegacy(text, type, length)
    if XeninUI.DisableNotification then
      oldNotification(text, type, length)
    else
      XeninUI:Notify(text, type, length)
    end
  end
end)

hook.Add("XeninUI.NotificationRemoved", "Core", function()
  for i, v in ipairs(XeninUI.Notifications) do
    if (v == NULL) then
      XeninUI.Notifications[i] = nil
    end
    if (!IsValid(v)) then continue end
    if v.removing then continue end

    v.id = i

    local y = ScrH() - 200
    local offset = (v.id - 1) * 45
    y = y - offset

    v:LerpMoveY(y, v:GetAnimTime())
  end
end)

net.Receive("XeninUI.Notification", function(len)
  local ply = LocalPlayer()
  local tbl = net.ReadTable()
  if tbl.markup then
    tbl.str = markup.Parse(tbl.str)
  end

  XeninUI:Notify(tbl.str, tbl.icon, tbl.dur, tbl.progressCol, tbl.textCol)
end)

--PATH lua/xeninui/elements/popup.lua:
return gluapack()()
--PATH lua/xeninui/elements/wyvern_scrollpanel.lua:
return gluapack()()
--PATH lua/xeninui/core/ui/tab.lua:
XeninUI:CreateFont("Xenin.Framework.Config.Container.Name", 24)
XeninUI:CreateFont("Xenin.Framework.Config.Container.Desc", 18)
XeninUI:CreateFont("Xenin.Framework.Config.Tabs", 26)

local PANEL = {}

function PANEL:Init()
  self.Name = "No Name"

  self:DockMargin(0, 0, 8, 0)

  self.Text = self:Add("DPanel")
  self.Text:Dock(TOP)
  self.Text.Offset = draw.GetFontHeight("Xenin.Framework.Config.Container.Name") + 4
  self.Text.Paint = function(pnl, w, h)
    XeninUI:DrawShadowText(self.Name, "Xenin.Framework.Config.Container.Name", 0, 0, Color(231, 232, 235), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 150)
    XeninUI:DrawShadowText(self.Desc, "Xenin.Framework.Config.Container.Desc", 0, pnl.Offset, Color(156, 156, 156), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 150)
  end
  self.Text:SetTall(50)
end

function PANEL:Paint(w, h)
  draw.RoundedBox(6, 0, 0, w, h, XeninUI.Theme.Primary)
end

function PANEL:SetName(name)
  self.Name = name
end

function PANEL:SetDesc(desc)
  self.Desc = desc
end

function PANEL:PerformLayout(w, h) end

vgui.Register("Xenin.Framework.Config.Container", PANEL, "XeninUI.Panel")

local PANEL = {}

XeninUI:CreateFont("Xenin.Framework.Category", 22)

function PANEL:SetData(data, scriptId)
  self.Data = data
  self.Panels = {}
  self.Cats = {}

  self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)

  self.Tabs = self:Add("XeninUI.NavbarBody")
  self.Tabs:Dock(TOP)
  self.Tabs:DockMargin(-6, 0, -12, 8)
  self.Tabs:SetTall(32)
  self.Tabs:SetBody(self.Scroll)
  self.Tabs.Margin = 12

  self.Save = self:Add("XeninUI.ButtonV2")
  self.Save:SetVisible(false)
  self.Save:SetText("Save")
  self.Save:SetGradient(false)
  self.Save:SetSolidColor(XeninUI.Theme.GreenDark)
  self.Save.DoClick = function(pnl)
    local config = {}
    for i, v in pairs(self.Panels) do
      config[i] = v:GetValue()
    end
    for i, v in pairs(self.Cats) do
      config[i] = {}
    end

    XeninUI.Config:save(scriptId, config)
  end

  self:PostInit()
end

function PANEL:UpdateSaveVisibility()
  local difference
  local function recursiveCheck(tbl)
    for i, v in ipairs(tbl) do
      if (!v.children) then
        if (v.value != self.Panels[v.key]:GetValue()) then
          difference = true

          break
        end

        continue
      end

      recursiveCheck(v.children)
    end
  end

  for i, v in ipairs(self.Data) do
    recursiveCheck(v.children)
  end

  self.Save:SetVisible(difference)
  if difference then
    self:InvalidateLayout()
  end
end

function PANEL:PostInit()
  self:CreateConfigRecursive(self.Data)
end

PANEL.Types = {
  cat = function(self, tbl, parent)





    self.Tabs:AddTab(tbl.name, "Panel", {
    fill = TOP })
    local panel = self.Tabs.Tabs[#self.Tabs.Tabs].Panel
    panel:DockMargin(0, 0, 0, 8)
    self.Tabs:SetActive(1)

    self:CreateConfigRecursive(tbl.children, panel)

    return panel
  end,
  textentry = function(self, tbl, parent)
    local panel = parent:Add("Xenin.Framework.Config.Container")
    panel:Dock(TOP)
    panel:DockMargin(0, 0, 8, 8)
    panel:SetName(tbl.name)
    panel:SetDesc(tbl.desc)
    panel:SetTall(104)
    panel.GetValue = function(pnl)
      return panel.Content:GetText()
    end
    panel:DockPadding(8, 6, 8, 8)

    panel.Content = panel:Add("XeninUI.TextEntry")
    panel.Content:Dock(FILL)
    panel.Content:DockMargin(0, 4, 0, 0)
    panel.Content:SetText(XeninUI.Config:get(tbl.key) or tbl.value)
    panel.Content.textentry:SetUpdateOnType(true)
    panel.Content.textentry.OnValueChange = function(pnl, w, h)
      self:UpdateSaveVisibility()
    end

    if tbl.numeric then
      panel.Content.textentry:SetNumeric(true)
    end

    return panel
  end,
  checkbox = function(self, tbl, parent)
    local panel = parent:Add("Xenin.Framework.Config.Container")
    panel:Dock(TOP)
    panel:DockMargin(0, 0, 8, 8)
    panel:SetName(tbl.name)
    panel:SetDesc(tbl.desc)
    panel:SetTall(104)
    panel.GetValue = function(pnl)
      return panel.Content:GetState()
    end
    panel:DockPadding(8, 6, 8, 8)

    panel.Content = panel:Add("XeninUI.Checkbox")
    panel.Content:Dock(LEFT)
    panel.Content:DockMargin(0, 4, 0, 0)
    panel.Content:SetWide(100)
    panel.Content:SetState(tbl.value, true)
    panel.Content.OnStateChanged = function()
      self:UpdateSaveVisibility()
    end

    return panel
  end
}

function PANEL:CreateConfigRecursive(tbl, parent)
  if parent == nil then parent = self.Scroll
  end
  for i, v in ipairs(tbl) do
    local panel = self.Types[v.type](self, v, parent)
    if (v.type == "cat") then
      self.Cats[v.key] = v

      continue
    end

    self.Panels[v.key] = panel
  end
end

function PANEL:PerformLayout(w, h)
  self.Save:AlignRight(24)
  self.Save:AlignBottom(8)
  self.Save:SizeToContentsX(24)
  self.Save:SizeToContentsY(8)
  self.Save:SetRoundness(self.Save:GetTall() / 2)

  for i, v in ipairs(self.Tabs.Tabs) do
    local pnl = v.Panel
    local h = 0
    for i, v in ipairs(pnl:GetChildren()) do
      h = h + v:GetTall()
      local l, t, b, r = v:GetDockMargin()
      h = h + (t + b)
    end

    pnl:SetTall(h)
  end
end

vgui.Register("Xenin.Framework.Config", PANEL, "XeninUI.Panel")

local PANEL = {}

XeninUI:CreateFont("Xenin.Framework.Title", 26)
XeninUI:CreateFont("Xenin.Framework.Subtitle", 18)

function PANEL:OnSwitchedTo()
  if self.HaveSwitchedTo then return end

  self.HaveSwitchedTo = true
  self:PostInit()
end

function PANEL:PostInit()
  self:DockPadding(16, 16, 16, 16)

  local __lauxi0 = self.Data
  assert(__lauxi0 ~= nil, "cannot destructure nil value")
  local version, author, config, id, licensee, licenseeProof = __lauxi0.version, __lauxi0.author, __lauxi0.config, __lauxi0.id, __lauxi0.licensee, __lauxi0.licenseeProof
  local titleHeight = draw.GetFontHeight("Xenin.Framework.Title")
  local versionStr = version == "{{ script_version_name }}" and "DEV BUILD" or version
  self.Info = self:Add("DPanel")
  self.Info:Dock(TOP)
  self.Info:SetTall(48)
  self.Info.Paint = function(pnl, w, h)
    XeninUI:DrawShadowText("Version " .. tostring(versionStr), "Xenin.Framework.Title", 0, 0, color_white, nil, nil, 1, 150)
    XeninUI:DrawShadowText("Author: " .. tostring(author), "Xenin.Framework.Subtitle", 0, titleHeight, Color(183, 183, 183), nil, nil, 1, 150)
  end

  self.Tabs = self:Add("XeninUI.NavbarBody")
  self.Tabs:Dock(TOP)
  self.Tabs:DockMargin(-12, 8, -12, 0)
  self.Tabs:SetTall(40)
  self.Tabs.Font = "Xenin.Framework.Config.Tabs"
  self.Tabs:SetBody(self)
  if XeninUI.Debug then
    self.Tabs:AddTab("Updates")
    self.Tabs:AddTab("Config", "Xenin.Framework.Config", config, id)
    self.Tabs:SetActive(2)
  else
    self.Tabs:AddTab("License", "Xenin.Framework.Dev", {
      licensee = licensee,
      proof = licenseeProof
    })
    self.Tabs:SetActive(1)
  end
end

vgui.Register("Xenin.Framework.Tab", PANEL)

local PANEL = {}

XeninUI:CreateFont("Xenin.Framework.Dev.Licensee", 48)
XeninUI:CreateFont("Xenin.Framework.Dev", 20)

function PANEL:Paint(w, h)
  XeninUI:DrawShadowText("Licensed to " .. tostring(self.licensee), "Xenin.Framework.Dev.Licensee", w / 2, 16, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, 150)
  XeninUI:DrawShadowText("Proof: " .. tostring(self.proof), "Xenin.Framework.Dev", w / 2, 16 + draw.GetFontHeight("Xenin.Framework.Dev.Licensee") + 4, Color(242, 242, 242), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, 150)
  XeninUI:DrawShadowText("This menu is currently in development, check back later", "Xenin.Framework.Dev", w / 2, h / 2, Color(183, 183, 183), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, 150)
end

function PANEL:SetData(data)
  self.licensee = data.licensee
  self.proof = data.proof
end

vgui.Register("Xenin.Framework.Dev", PANEL)

local PANEL = {}
XeninUI:CreateFont("XeninUI.NavbarBody", 18)
AccessorFunc(PANEL, "m_body", "Body")

function PANEL:Init()
  self.Tabs = {}
  self.Options = {}

  self.Line = self:Add("DPanel")
  self.Line:SetMouseInputEnabled(false)
  self.Line:SetTall(2)
  self.Line.x = 12
  self.Line.Paint = function(pnl, w, h)
    surface.SetDrawColor(XeninUI.Theme.Accent)
    surface.DrawRect(0, 0, w, h)
  end
end

function PANEL:PerformLayout(w, h)
  self.Line:SetPos(self.Line.x, h - 2)
end

function PANEL:SetActive(id)
  if IsValid(self.Tabs[self.Active]) then
    self.Tabs[self.Active]:LerpColor("TextColor", Color(183, 183, 183))
    self.Tabs[self.Active].Panel:SetVisible(false)
  end

  self.Active = id

  if IsValid(self.Tabs[self.Active]) then
    local margin = self.Margin or 24
    local x = margin / 2
    for i = 1, id - 1 do
      x = x + self.Tabs[i]:GetWide()
    end

    self.Line:LerpMoveX(x, 0.3)
    self.Line:LerpWidth(self.Tabs[id]:GetWide() - margin, 0.3)

    self.Tabs[self.Active]:LerpColor("TextColor", color_white)
    self.Tabs[self.Active].Panel:SetVisible(true)
  end
end

function PANEL:SetOptions(options)
  self.Options = options
end

function PANEL:AddTab(name, panelClass, data, scriptId)
  if data == nil then data = {}
  end
  if scriptId == nil then scriptId = "none"
  end
  local margin = self.Margin or 24
  local btn = self:Add("DButton")
  btn:Dock(LEFT)
  btn:SetText(self.Options.upper and name:upper() or name)
  btn:SetFont(self.Font or "XeninUI.NavbarBody")
  btn:SizeToContentsX(margin)
  btn:SizeToContentsY()
  btn.TextColor = Color(183, 183, 183)
  btn.Paint = function(pnl, w, h)
    pnl:SetTextColor(pnl.TextColor)
  end
  btn.DoClick = function(pnl)
    self:SetActive(pnl.Id)
  end

  local id = table.insert(self.Tabs, btn)
  self.Tabs[id].Id = id

  if (id == 1) then
    self.Line:SetWide(btn:GetWide() - margin)
  end

  local panel = self:GetBody():Add(panelClass or "XeninUI.Panel")
  panel:Dock(data.fill or FILL)
  panel:SetVisible(false)
  if panel.SetData then
    panel:SetData(data, scriptId)
  end

  btn.Panel = panel
end

vgui.Register("XeninUI.NavbarBody", PANEL)

--PATH lua/xeninui/libs/units/classes/spec.lua:
return gluapack()()
--PATH lua/autorun/yularen.lua:
player_manager.AddValidModel( "navy yularen", 		"models/navy/gnavyyularen.mdl" );
list.Set( "PlayerOptionsModel", "navy yularen", 	"models/navy/gnavyyularen.mdl" );
--PATH lua/advdupe2/cl_ghost.lua:
return gluapack()()
--PATH lua/autorun/client/cl_alydusfortificationbuildertablet_meta.lua:
return gluapack()()
--PATH lua/permaprops/cl_drawent.lua:
return gluapack()()
--PATH lua/permaprops/cl_menu.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/

surface.CreateFont( "pp_font", {
	font = "Arial",
	size = 20,
	weight = 700,
	shadow = false
} )

local function pp_open_menu()

	local Len = net.ReadFloat()
	local Data = net.ReadData( Len )
	local UnCompress = util.Decompress( Data )
	local Content = util.JSONToTable( UnCompress )

 	local Main = vgui.Create( "DFrame" )
	Main:SetSize( 600, 355 )
	Main:Center()
	Main:SetTitle("")
	Main:SetVisible( true )
	Main:SetDraggable( true )
	Main:ShowCloseButton( true )
	Main:MakePopup()
	Main.Paint = function(self)

		draw.RoundedBox( 0, 0, 0, self:GetWide(), self:GetTall(), Color(155, 155, 155, 220) )
		surface.SetDrawColor( 17, 148, 240, 255 )
		surface.DrawOutlinedRect( 0, 0, self:GetWide(), self:GetTall() )	

		draw.RoundedBox( 0, 0, 0, self:GetWide(), 25, Color(17, 148, 240, 200) )
		surface.SetDrawColor( 17, 148, 240, 255 )
		surface.DrawOutlinedRect( 0, 0, self:GetWide(), 25 )
		draw.DrawText( "PermaProps Config", "pp_font", 10, 2.2, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT )

	end

	local BSelect
	local PSelect

	local MainPanel = vgui.Create( "DPanel", Main )
	MainPanel:SetPos( 190, 51 )
	MainPanel:SetSize( 390, 275 )
	MainPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
		surface.DrawOutlinedRect(0, 15, self:GetWide(), 40)
	end
	PSelect = MainPanel

	local MainLabel = vgui.Create("DLabel", MainPanel)
	MainLabel:SetFont("pp_font")
	MainLabel:SetPos(140, 25) 
	MainLabel:SetColor(Color(50, 50, 50, 255)) 
	MainLabel:SetText("Hey ".. LocalPlayer():Nick() .." !") 
	MainLabel:SizeToContents()

	local MainLabel2 = vgui.Create("DLabel", MainPanel)
	MainLabel2:SetFont("pp_font")
	MainLabel2:SetPos(80, 80) 
	MainLabel2:SetColor(Color(50, 50, 50, 255)) 
	MainLabel2:SetText("There are ".. ( Content.MProps or 0 ) .." props on this map.\n\nThere are ".. ( Content.TProps or 0 ) .." props in the DB.") 
	MainLabel2:SizeToContents()

	local RemoveMapProps = vgui.Create( "DButton", MainPanel )
	RemoveMapProps:SetText( " Clear map props " )
	RemoveMapProps:SetFont("pp_font")
	RemoveMapProps:SetSize( 370, 30)
	RemoveMapProps:SetPos( 10, 160 )
	RemoveMapProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	RemoveMapProps.DoClick = function()
		net.Start("pp_info_send")
			net.WriteTable({CMD = "CLR_MAP"})
		net.SendToServer()
	end
	RemoveMapProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local ClearMapProps = vgui.Create( "DButton", MainPanel )
	ClearMapProps:SetText( " Clear map props in the DB " )
	ClearMapProps:SetFont("pp_font")
	ClearMapProps:SetSize( 370, 30)
	ClearMapProps:SetPos( 10, 200 )
	ClearMapProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	ClearMapProps.DoClick = function()

		Derma_Query("Are you sure you want clear map props in the db ?\nYou can't undo this action !", "PermaProps 4.0", "Yes", function() net.Start("pp_info_send") net.WriteTable({CMD = "DEL_MAP"}) net.SendToServer() end, "Cancel")

	end
	ClearMapProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local ClearAllProps = vgui.Create( "DButton", MainPanel )
	ClearAllProps:SetText( " Clear all props in the DB " )
	ClearAllProps:SetFont("pp_font")
	ClearAllProps:SetSize( 370, 30)
	ClearAllProps:SetPos( 10, 240 )
	ClearAllProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	ClearAllProps.DoClick = function()

		Derma_Query("Are you sure you want clear all props in the db ?\nYou can't undo this action !", "PermaProps 4.0", "Yes", function() net.Start("pp_info_send") net.WriteTable({CMD = "DEL_ALL"}) net.SendToServer() end, "Cancel")

	end
	ClearAllProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local BMain = vgui.Create("DButton", Main)
	BSelect = BMain
	BMain:SetText("Main")
	BMain:SetFont("pp_font")
	BMain:SetSize(160, 50)
	BMain:SetPos(15, 27 + 25)
	BMain:SetTextColor( Color( 255, 255, 255, 255 ) )
	BMain.PaintColor = Color(17, 148, 240, 100)
	BMain.Paint = function(self)

		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())

	end
	BMain.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		MainPanel:Show()
		PSelect = MainPanel

	end

	local ConfigPanel = vgui.Create( "DPanel", Main )
	ConfigPanel:SetPos( 190, 51 )
	ConfigPanel:SetSize( 390, 275 )
	ConfigPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	ConfigPanel:Hide()

	local CheckCustom = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckCustom:SetPos( 5, 30 )
	CheckCustom:SetText( "Custom permissions" )
	CheckCustom:SetValue( 0 )
	CheckCustom:SizeToContents()
	CheckCustom:SetTextColor( Color( 0, 0, 0, 255) )
	CheckCustom:SetDisabled( true )

	local GroupsList = vgui.Create( "DComboBox", ConfigPanel )
	GroupsList:SetPos( 5, 5 )
	GroupsList:SetSize( 125, 20 )
	GroupsList:SetValue( "Select a group..." )

	local CheckBox1 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox1:SetPos( 150, 10 )
	CheckBox1:SetText( "Menu" )
	CheckBox1:SizeToContents()
	CheckBox1:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox1:SetDisabled( true )
	CheckBox1.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Menu", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox2 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox2:SetPos( 150, 30 )
	CheckBox2:SetText( "Edit permissions" )
	CheckBox2:SizeToContents()
	CheckBox2:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox2:SetDisabled( true )
	CheckBox2.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Permissions", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox3 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox3:SetPos( 150, 50 )
	CheckBox3:SetText( "Physgun permaprops" )
	CheckBox3:SizeToContents()
	CheckBox3:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox3:SetDisabled( true )
	CheckBox3.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Physgun", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox4 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox4:SetPos( 150, 70 )
	CheckBox4:SetText( "Tool permaprops" )
	CheckBox4:SizeToContents()
	CheckBox4:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox4:SetDisabled( true )
	CheckBox4.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Tool", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox5 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox5:SetPos( 150, 90 )
	CheckBox5:SetText( "Property permaprops" )
	CheckBox5:SizeToContents()
	CheckBox5:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox5:SetDisabled( true )
	CheckBox5.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Property", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox6 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox6:SetPos( 150, 110 )
	CheckBox6:SetText( "Save props" )
	CheckBox6:SizeToContents()
	CheckBox6:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox6:SetDisabled( true )
	CheckBox6.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Save", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox7 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox7:SetPos( 150, 130 )
	CheckBox7:SetText( "Delete permaprops" )
	CheckBox7:SizeToContents()
	CheckBox7:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox7:SetDisabled( true )
	CheckBox7.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Delete", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox8 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox8:SetPos( 150, 150 )
	CheckBox8:SetText( "Update permaprops" )
	CheckBox8:SizeToContents()
	CheckBox8:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox8:SetDisabled( true )
	CheckBox8.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Update", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	GroupsList.OnSelect = function( panel, index, value )
		
		CheckCustom:SetDisabled( false )
		CheckCustom:SetChecked( Content.Permissions[value].Custom )

		CheckBox1:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox1:SetChecked( Content.Permissions[value].Menu )
		CheckBox2:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox2:SetChecked( Content.Permissions[value].Permissions )
		CheckBox3:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox3:SetChecked( Content.Permissions[value].Physgun )
		CheckBox4:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox4:SetChecked( Content.Permissions[value].Tool )
		CheckBox5:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox5:SetChecked( Content.Permissions[value].Property )
		CheckBox6:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox6:SetChecked( Content.Permissions[value].Save )
		CheckBox7:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox7:SetChecked( Content.Permissions[value].Delete )
		CheckBox8:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox8:SetChecked( Content.Permissions[value].Update )

	end

	for k, v in pairs(Content.Permissions) do
		
		GroupsList:AddChoice(k)

	end

	CheckCustom.OnChange = function(Self, Value)

		CheckBox1:SetDisabled( !Value )
		CheckBox2:SetDisabled( !Value )
		CheckBox3:SetDisabled( !Value )
		CheckBox4:SetDisabled( !Value )
		CheckBox5:SetDisabled( !Value )
		CheckBox6:SetDisabled( !Value )
		CheckBox7:SetDisabled( !Value )
		CheckBox8:SetDisabled( !Value )

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Custom", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local BConfig = vgui.Create("DButton", Main)
	BConfig:SetText("Configuration")
	BConfig:SetFont("pp_font")
	BConfig:SetSize(160, 50)
	BConfig:SetPos(15, 71 + 55)
	BConfig:SetTextColor( Color( 255, 255, 255, 255 ) )
	BConfig.PaintColor = Color(0, 0, 0, 0)
	BConfig.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BConfig.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		ConfigPanel:Show()
		PSelect = ConfigPanel

	end

	local PropsPanel = vgui.Create( "DPanel", Main )
	PropsPanel:SetPos( 190, 51 )
	PropsPanel:SetSize( 390, 275 )
	PropsPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	PropsPanel:Hide()

	local PropsList = vgui.Create( "DListView", PropsPanel )
	PropsList:SetMultiSelect( false )
	PropsList:SetSize( 390, 275 )
	local ColID = PropsList:AddColumn( "ID" )
	local ColEnt = PropsList:AddColumn( "Entity" )
	local ColMdl = PropsList:AddColumn( "Model" )
	ColID:SetMinWidth(50)
	ColID:SetMaxWidth(50)
	PropsList.Paint = function( self )
		surface.SetDrawColor(17, 148, 240, 255)
	end

	PropsList.OnRowRightClick = function(panel, line)

		local MenuButtonOptions = DermaMenu()
	    MenuButtonOptions:AddOption("Draw entity", function() 

	    	if not LocalPlayer().DrawPPEnt or not istable(LocalPlayer().DrawPPEnt) then LocalPlayer().DrawPPEnt = {} end

	    	if LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:IsValid() then return end

		    local ent = ents.CreateClientProp( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Model ) 
			ent:SetPos( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Pos )
			ent:SetAngles( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Angle )

			LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = ent

		end )

		if LocalPlayer().DrawPPEnt and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] then
			
			MenuButtonOptions:AddOption("Stop Drawing", function() 

				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:Remove()
				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = nil

			end )

		end

		if LocalPlayer().DrawPPEnt != nil and istable(LocalPlayer().DrawPPEnt) and table.Count(LocalPlayer().DrawPPEnt) > 0 then

			MenuButtonOptions:AddOption("Stop Drawing All", function() 

				for k, v in pairs(LocalPlayer().DrawPPEnt) do
					
					LocalPlayer().DrawPPEnt[k]:Remove()
					LocalPlayer().DrawPPEnt[k] = nil

				end

			end )
			
		end

	    MenuButtonOptions:AddOption("Remove", function()

	    	net.Start("pp_info_send")
	    		net.WriteTable({CMD = "DEL", Val = PropsList:GetLine(line):GetValue(1)})
	    	net.SendToServer()

	    	if LocalPlayer().DrawPPEnt and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] != nil then

	    		LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:Remove()
				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = nil
				
	    	end

	    	PropsList:RemoveLine(line)


		end )
	    MenuButtonOptions:Open()
		
	end

	for k, v in pairs(Content.PropsList) do
		
		PropsList:AddLine(k, v.Class, v.Model)

	end

	local BProps = vgui.Create("DButton", Main)
	BProps:SetText("Props List")
	BProps:SetFont("pp_font")
	BProps:SetSize(160, 50)
	BProps:SetPos(15, 115 + 85)
	BProps:SetTextColor( Color( 255, 255, 255, 255 ) )
	BProps.PaintColor = Color(0, 0, 0, 0)
	BProps.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BProps.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		PropsPanel:Show()
		PSelect = PropsPanel

	end

end
net.Receive("pp_open_menu", pp_open_menu)

--PATH lua/autorun/client/vj_menu_main_client.lua:
/*--------------------------------------------------
	=============== Client Main Menu ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
include('autorun/client/vj_menu_plugins.lua')

local function VJ_INFORMATION(Panel)
	local client = LocalPlayer() -- Local Player
	Panel:AddControl("Label", {Text = "About VJ Base:"})
	Panel:ControlHelp("VJ Base is made by DrVrej. The main purpose of this base is for the sake of simplicity. It provides many types of bases including a very advanced artificial intelligent NPC base.")
	--
	--
	Panel:AddControl("Label", {Text = "User Information:"})
	Panel:ControlHelp("Date - "..os.date("%b %d, %Y - %I:%M %p")) -- Date
	Panel:ControlHelp("Name - "..client:Nick().." ("..client:SteamID()..")") -- Name + Steam ID
	Panel:ControlHelp("Session - "..(game.SinglePlayer() and "SinglePlayer" or "Multiplayer")..", "..gmod.GetGamemode().Name.." ("..game.GetMap()..")") -- Game Session
	Panel:ControlHelp("VJ Base - "..VJBASE_VERSION..", "..#VJ.Plugins.." plugins, "..GetConVar("vj_language"):GetString()) -- VJ Base Information
	Panel:ControlHelp("System - "..(system.IsLinux() and "Linux" or (system.IsOSX() and "OSX" or "Windows")).." ("..ScrW().."x"..ScrH()..")") // system.IsWindows() -- System
	--
	--
	Panel:AddControl("Label", {Text = "Mounted Games:"})
	Panel:ControlHelp("HL1S - "..tostring(IsMounted("hl1")))
	Panel:ControlHelp("HL2 - "..tostring(IsMounted("hl2")))
	Panel:ControlHelp("HL2Ep1 - "..tostring(IsMounted("episodic")))
	Panel:ControlHelp("HL2Ep2 - "..tostring(IsMounted("ep2")))
	Panel:ControlHelp("CSS - "..tostring(IsMounted("cstrike")))
	Panel:ControlHelp("DoD - "..tostring(IsMounted("dod")))
	Panel:ControlHelp("TF2 - "..tostring(IsMounted("tf")))
	--
	--
	Panel:AddControl("Label", {Text = "Command Information:"})
	Panel:ControlHelp("SNPC Configurations - 'vj_npc_*'")
	Panel:ControlHelp("Weapons - 'vj_wep_*'")
	Panel:ControlHelp("HUD - 'vj_hud_*'")
	Panel:ControlHelp("Crosshair - 'vj_hud_ch_*'")
	--
	--
	Panel:AddControl("Label", {Text = "Credits:"})
	Panel:ControlHelp("DrVrej(Me) - Everything, from coding to fixing models and materials to sound editing")
	Panel:ControlHelp("Black Mesa Source - Original non-edited gib models, blood pool texture, and glock 17 model")
	Panel:ControlHelp("Valve - AK-47, M16A1 and MP40 models")
	Panel:ControlHelp("Orion - Helped create first version of the base (2011-2012)")
	Panel:ControlHelp("Cpt. Hazama - Suggestions + testing")
	Panel:ControlHelp("Oteek - Bloodpool textures + testing")
	Panel:ControlHelp("China-Mandem - Original K-3 Model")
	
	Panel:ControlHelp("")
	Panel:ControlHelp("============================")
	
	Panel:ControlHelp("Copyright (c) "..os.date("20%y").." by DrVrej, All rights reserved.")
	Panel:ControlHelp("No parts of the code may be reproduced, copied, modified or adapted, without the prior written consent of the author.")
end
----=================================----
local function VJ_MAINMENU_CLIENT(Panel)
	Panel:AddControl("Label", {Text = "#vjbase.menu.clsettings.label"})
	
	-- Icons: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
	local vj_combo_box = vgui.Create("DComboBox")
	vj_combo_box:SetSize(100, 30)
	vj_combo_box:SetValue("#vjbase.menu.clsettings.labellang")
	vj_combo_box:AddChoice("English", "english", false, "flags16/us.png")
	vj_combo_box:AddChoice("简体中文", "schinese", false, "flags16/cn.png")
	vj_combo_box:AddChoice("ՀայերԷն *", "armenian", false, "flags16/am.png")
	vj_combo_box:AddChoice("Русский", "russian", false, "flags16/ru.png")
	vj_combo_box:AddChoice("Deutsche *", "german", false, "flags16/de.png")
	vj_combo_box:AddChoice("Français *", "french", false, "flags16/fr.png")
	vj_combo_box:AddChoice("Lietuvių", "lithuanian", false, "flags16/lt.png")
	vj_combo_box:AddChoice("Español (Latino Americano) *", "spanish_lt", false, "flags16/mx.png")
	vj_combo_box:AddChoice("Português (Brasileiro) *", "portuguese_br", false, "flags16/br.png")
	vj_combo_box.OnSelect = function(data, index, text)
		RunConsoleCommand("vj_language", vj_combo_box:GetOptionData(index))
		chat.AddText(Color(255, 215, 0), "#vjbase.menu.clsettings.notify.lang", " ", Color(30, 200, 255), text)
		timer.Simple(0.2, function() VJ_REFRESH_LANGUAGE(val) RunConsoleCommand("spawnmenu_reload") end) -- Bedke kichme espasenk minchevor command-e update ela
	end
	Panel:AddPanel(vj_combo_box)
	Panel:ControlHelp("* stands for unfinished translation!")
	Panel:AddControl("Checkbox", {Label = "#vjbase.menu.clsettings.lang.auto", Command = "vj_language_auto"})
	Panel:ControlHelp("#vjbase.menu.clsettings.lang.auto.label")
end
----=================================----
hook.Add("PopulateToolMenu", "VJ_ADDTOMENU_INFORMATION", function()
	spawnmenu.AddToolMenuOption("DrVrej", "Main Menu", "Information", "#vjbase.menu.info", "", "", VJ_INFORMATION, {})
	spawnmenu.AddToolMenuOption("DrVrej", "Main Menu", "Client Settings", "#vjbase.menu.clsettings", "", "", VJ_MAINMENU_CLIENT, {})
end)

--PATH lua/vgui/bvgui/colormixer.lua:
local matGradient = Material( "vgui/gradient-u" )
local matGrid = Material( "gui/alpha_grid.png", "nocull" )

local PANEL = {}

function PANEL:Init()
	self.ColorMixer = vgui.Create("DColorMixer", self)
	self.ColorMixer:SetPalette(false)

	self.ColorMixer.HSV.Knob.Paint = nil 
	self.ColorMixer.HSV.PaintOver = function(s,w,h)
		self.GottenRGB = s:GetRGB()
		self.ColorContrast = bVGUI.TextColorContrast(self.GottenRGB)

		local x,y = s.Knob:GetPos()
		local ww,hh = s.Knob:GetSize()
		surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
		surface.DrawOutlinedRect(0,0,w,h)
		draw.NoTexture()

		surface.DrawPoly({
			{x=x,y=y},
			{x=x+ww,y=y},
			{x=x+math.ceil(ww/2),y=y+math.ceil(hh/2)},
		})
		surface.DrawRect(x,y-hh,ww,hh)

		surface.SetDrawColor(self.ColorContrast)
		surface.DrawRect(x+2,y-hh+2,ww-4,hh-4)

		surface.SetDrawColor(self.GottenRGB)
		surface.DrawRect(x+3,y-hh+3,ww-6,hh-6)
	end

	self.ColorMixer.colPrev = self.ColorMixer.WangsPanel:Add( "DPanel" )
	self.ColorMixer.colPrev:SetTall( 20 )
	self.ColorMixer.colPrev:Dock( TOP )
	self.ColorMixer.colPrev:DockMargin( 0, 4, 0, 0 )
	self.ColorMixer.colPrev.Paint = function(s,w,h)
		if !self.GottenRGB then return end
		
		surface.SetDrawColor(self.GottenRGB)
		surface.DrawRect(0,0,w,h)
		surface.SetDrawColor(self.ColorContrast)
		surface.DrawOutlinedRect(0,0,w,h)
	end

	function self.ColorMixer.Alpha:Paint(w, h)
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(matGrid)
		local size = 128
	
		for i = 0, math.ceil(h / size) do
			surface.DrawTexturedRect(w / 2 - size / 2, i * size, size, size)
		end
	
		surface.SetDrawColor(self.m_BarColor)
		surface.SetMaterial(matGradient)

		surface.DrawTexturedRect(0, 0, w, h)
		surface.DrawTexturedRect(0, 0, w, h)

		surface.SetDrawColor(0, 0, 0, 250)
		self:DrawOutlinedRect()
		surface.DrawRect(2, (1 - self.m_Value) * h - 3, w - 4, 6)

		surface.SetDrawColor(255, 255, 255, 250)
		surface.DrawRect(4, (1 - self.m_Value) * h - 1, w - 8, 2)
	end
	
	function self.ColorMixer.RGB:Paint(w, h)
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(self.Material)

		surface.DrawTexturedRect(0, 0, w, h)
		
		surface.SetDrawColor(0, 0, 0, 250)
		self:DrawOutlinedRect()
		surface.DrawRect(2, self.LastY - 3, w - 4, 6)
		
		surface.SetDrawColor(255, 255, 255, 250)
		surface.DrawRect(4, self.LastY - 1, w - 8, 2)
	end
end

function PANEL:SetColor(col)
	self.ColorMixer:SetColor(col)
end
function PANEL:GetColor()
	return self.ColorMixer:GetColor()
end

function PANEL:SetLabel(text)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(text)
	self.Label:SizeToContentsX()
	self.Label:SetTall(21)
end

function PANEL:PerformLayout()
	self.ColorMixer:AlignBottom(0)
	if (IsValid(self.Label)) then
		self.ColorMixer:SetSize(self:GetTall() * 1.6, self:GetTall() - self.Label:GetTall())
	else
		self.ColorMixer:SetSize(self:GetTall() * 1.6, self:GetTall())
	end
end

derma.DefineControl("bVGUI.ColorMixer", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/bvgui/loadingpanel.lua:
return gluapack()()
--PATH lua/vgui/bvgui/tabs.lua:
return gluapack()()
--PATH lua/vgui/cl_fframe.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/vgui/gas_logging_advanced_search_item.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/vgui/gas_logging_entity_display.lua:
GAS_Logging_EntityDisplay_Networking = {}
GAS_Logging_EntityDisplay_Cache = {}

if (IsValid(GAS_Logging_EntityDisplay)) then
	GAS_Logging_EntityDisplay:Close()
end

local PANEL = {}

function PANEL:InfoInit()
	self.Shruggie = vgui.Create("DLabel", self)
	self.Shruggie:SetText("¯\\_(ツ)_/¯")
	self.Shruggie:SetFont("DermaLarge")
	self.Shruggie:SetTextColor(bVGUI.COLOR_WHITE)
	self.Shruggie:SizeToContents()
	self.Shruggie:SetVisible(false)

	self.LoadingPanel = vgui.Create("bVGUI.LoadingPanel", self)
	self.LoadingPanel:Dock(FILL)
	self.LoadingPanel:SetLoading(true)

	self.ModelPanel = vgui.Create("DModelPanel", self.LoadingPanel)
	self.ModelPanel:Dock(FILL)

	self.InfoContainer = vgui.Create("bVGUI.BlankPanel", self)

	self.LabelContainer = vgui.Create("bVGUI.BlankPanel", self.InfoContainer)
	self.LabelContainer:Dock(FILL)

	self.SpawnCategory = vgui.Create("DLabel", self.LabelContainer)
	self.SpawnCategory:Dock(BOTTOM)
	self.SpawnCategory:SetContentAlignment(3)
	self.SpawnCategory:SetTextColor(Color(160,160,160))
	self.SpawnCategory:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.SpawnCategory:SetText("")
	self.SpawnCategory:SetVisible(false)

	self.PrintName = vgui.Create("DLabel", self.LabelContainer)
	self.PrintName:SetText("")
	self.PrintName:SetTextColor(bVGUI.COLOR_WHITE)
	self.PrintName:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.PrintName:Dock(FILL)
	self.PrintName:SetContentAlignment(3)

	self.SpawnIcon = vgui.Create("DImage", self.InfoContainer)
	self.SpawnIcon:Dock(LEFT)
	self.SpawnIcon:DockMargin(0,0,10,0)
	self.SpawnIcon:SetSize(64,64)
	self.SpawnIcon:SetVisible(false)

	self.OldPerformLayout = self.PerformLayout
	function self:PerformLayout(w,h)
		self:OldPerformLayout(w,h)

		self.InfoContainer:SetSize(w - 20, 64)
		self.InfoContainer:AlignBottom(10)
		self.InfoContainer:AlignLeft(10)

		self.Shruggie:Center()
	end
end

function PANEL:FixCamera(scale)
	if (IsValid(self.ModelPanel.Entity)) then
		local PrevMins, PrevMaxs = self.ModelPanel.Entity:GetRenderBounds()
		self.ModelPanel:SetCamPos(PrevMins:Distance(PrevMaxs) * Vector(scale or 0.75, scale or 0.75,scale or 0.75))
		self.ModelPanel:SetLookAt((PrevMaxs + PrevMins) / 2)
	end
end

function PANEL:SetWeapon(weapon_class)
	self:SetTitle(weapon_class)

	local weapon_tbl = weapons.Get(weapon_class)
	if (weapon_tbl ~= nil and weapon_tbl.WorldModel ~= nil) then
		self.ModelPanel:SetModel(weapon_tbl.WorldModel)
		self:SetVisible(true)
		if (weapon_tbl.PrintName ~= nil and type(weapon_tbl.PrintName) == "string") then
			self.PrintName:SetText(weapon_tbl.PrintName)
		end
		if (weapon_tbl.Category ~= nil and type(weapon_tbl.Category)) then
			self.SpawnCategory:SetText(weapon_tbl.Category)
			self.SpawnCategory:SetVisible(true)
		end
	elseif (file.Exists("scripts/" .. weapon_class .. ".txt", "GAME")) then
		local weapon_script = file.Read("scripts/" .. weapon_class .. ".txt", "GAME")
		if (weapon_script) then
			local world_model = weapon_script:match('"playermodel"%s*"(.-)"')
			if (world_model ~= nil) then
				self.ModelPanel:SetModel(world_model)
				self:SetVisible(true)
			end
		end
		local weapon_info = list.Get("Weapon")[weapon_class]
		if (weapon_info) then
			if (weapon_info.PrintName ~= nil and type(weapon_info.PrintName) == "string") then
				self.PrintName:SetText(weapon_info.PrintName)
				self.PrintName:SizeToContents()
			end
			if (weapon_info.Category ~= nil and type(weapon_info.Category)) then
				self.SpawnCategory:SetText(weapon_info.Category)
				self.SpawnCategory:SetVisible(true)
			end
		end
	end

	if (file.Exists("materials/entities/" .. weapon_class .. ".png", "GAME")) then
		self.SpawnIcon:SetImage("entities/" .. weapon_class .. ".png")
		self.SpawnIcon:SetVisible(true)
	end

	self:FixCamera()
	self.LoadingPanel:SetLoading(false)
end

function PANEL:SetProp(model)
	self.ModelPanel:SetModel(model)
	self:SetTitle(model)
	self:SetVisible(true)

	self:FixCamera()
	self.LoadingPanel:SetLoading(false)
end

function PANEL:SetAmmo(ammo_type)
	local spawnmenu_item = list.Get("SpawnableEntities")[ammo_type]
	if (spawnmenu_item ~= nil and spawnmenu_item.PrintName ~= nil and type(spawnmenu_item) == "string") then
		self.PrintName:SetText(spawnmenu_item.PrintName)
	end
	if (file.Exists("materials/entities/" .. ammo_type .. ".png", "GAME")) then
		self.SpawnIcon:SetImage("entities/" .. ammo_type .. ".png")
		self.SpawnIcon:SetVisible(true)
	end

	self:SetVisible(true)

	if (GAS_Logging_EntityDisplay_Cache[ammo_type]) then
		self.ModelPanel:SetModel(GAS_Logging_EntityDisplay_Cache[ammo_type])
		self:SetVisible(true)
		self:FixCamera()
		self.LoadingPanel:SetLoading(false)
	else
		local net_msg_fire = GAS_Logging_EntityDisplay_Networking[ammo_type] == nil
		GAS_Logging_EntityDisplay_Networking[ammo_type] = GAS_Logging_EntityDisplay_Networking[ammo_type] or {}
		GAS_Logging_EntityDisplay_Networking[ammo_type][self] = true
		if (net_msg_fire) then
			GAS:netStart("logging:EntityDisplay:AmmoModel")
				net.WriteString(ammo_type)
			net.SendToServer()
		end
	end
end

function PANEL:SetVehicle(vehicle_class, mdl_str)
	self:SetTitle(vehicle_class)

	if (mdl_str ~= nil and not IsUselessModel(mdl_str)) then
		self.ModelPanel:SetModel(mdl_str)
		self:SetVisible(true)
		self:FixCamera()
		self.LoadingPanel:SetLoading(false)

		for _,spawnmenu_item in pairs(list.Get("Vehicles")) do
			if (spawnmenu_item.Class == vehicle_class and spawnmenu_item.Model == mdl_str) then
				if (spawnmenu_item.Name ~= nil and type(spawnmenu_item.Name) == "string") then
					self.PrintName:SetText(spawnmenu_item.Name)
					if (file.Exists("materials/entities/" .. spawnmenu_item.Name .. ".png", "GAME")) then
						self.SpawnIcon:SetImage("entities/" .. spawnmenu_item.Name .. ".png")
						self.SpawnIcon:SetVisible(true)
					end
				end
				return
			end
		end
		for _,spawnmenu_item in pairs(list.Get("Vehicles")) do
			if (spawnmenu_item.Model == mdl_str) then
				if (spawnmenu_item.Name ~= nil and type(spawnmenu_item.Name) == "string") then
					self.PrintName:SetText(spawnmenu_item.Name)
					if (file.Exists("materials/entities/" .. spawnmenu_item.Name .. ".png", "GAME")) then
						self.SpawnIcon:SetImage("entities/" .. spawnmenu_item.Name .. ".png")
						self.SpawnIcon:SetVisible(true)
					end
				end
				break
			end
		end
	else
		for _,spawnmenu_item in pairs(list.Get("Vehicles")) do
			if (spawnmenu_item.Class ~= vehicle_class) then continue end
			if (spawnmenu_item.Name ~= nil and type(spawnmenu_item.Name) == "string") then
				self.PrintName:SetText(spawnmenu_item.Name)
				if (file.Exists("materials/entities/" .. spawnmenu_item.Name .. ".png", "GAME")) then
					self.SpawnIcon:SetImage("entities/" .. spawnmenu_item.Name .. ".png")
					self.SpawnIcon:SetVisible(true)
				end
			end
			if (mdl_str == nil or IsUselessModel(mdl_str)) then
				if (spawnmenu_item.Model ~= nil and type(spawnmenu_item.Model) == "string") then
					self.ModelPanel:SetModel(spawnmenu_item.Model)
					self:SetVisible(true)
					self:FixCamera()
					self.LoadingPanel:SetLoading(false)
				end
			end
			break
		end
	end
end

function PANEL:SetEntity(class_name, mdl_str)
	if (class_name == "worldspawn") then return end

	self:SetTitle(class_name)

	local sent_tbl = scripted_ents.Get(class_name)
	if (sent_tbl ~= nil and sent_tbl.PrintName ~= nil and type(sent_tbl.PrintName) == "string") then
		self.PrintName:SetText(sent_tbl.PrintName)
	else
		local spawnmenu_item = list.Get("SpawnableEntities")[class_name]
		if (spawnmenu_item ~= nil and spawnmenu_item.PrintName ~= nil and type(spawnmenu_item.PrintName) == "string") then
			self.PrintName:SetText(spawnmenu_item.PrintName)
		end
	end
	if (file.Exists("materials/entities/" .. class_name .. ".png", "GAME")) then
		self.SpawnIcon:SetImage("entities/" .. class_name .. ".png")
		self.SpawnIcon:SetVisible(true)
	end

	if (mdl_str ~= nil and type(mdl_str) == "string") then
		if (not IsUselessModel(mdl_str)) then
			self.ModelPanel:SetModel(mdl_str)
			self:SetVisible(true)
			self:FixCamera()
			self.LoadingPanel:SetLoading(false)
		end
	elseif (GAS_Logging_EntityDisplay_Cache[class_name]) then
		self.ModelPanel:SetModel(GAS_Logging_EntityDisplay_Cache[class_name])
		self:SetVisible(true)
		self:FixCamera()
		self.LoadingPanel:SetLoading(false)
	else
		local found = false
		for _,ent in ipairs(ents.GetAll()) do
			if (not ent:IsWorld() and ent:GetClass() == class_name) then
				GAS_Logging_EntityDisplay_Cache[class_name] = ent:GetModel()
				self.ModelPanel:SetModel(ent:GetModel())
				self:SetVisible(true)
				self:FixCamera()
				self.LoadingPanel:SetLoading(false)
				found = true
				break
			end
		end
		if (not found) then
			local predefined_model = sent_tbl.model or sent_tbl.Model or sent_tbl.WorldModel
			if (predefined_model ~= nil and not IsUselessModel(predefined_model)) then
				GAS_Logging_EntityDisplay_Cache[class_name] = predefined_model
				self.ModelPanel:SetModel(predefined_model)
				self:SetVisible(true)
				self:FixCamera()
				self.LoadingPanel:SetLoading(false)
				return
			elseif (sent_tbl.Initialize ~= nil and type(sent_tbl.Initialize) == "function") then
				local debug_info = debug.getinfo(sent_tbl.Initialize)
				if (debug_info ~= nil and debug_info.short_src ~= nil) then
					local code
					if (file.Exists(debug_info.short_src, "LUA")) then
						code = file.Read(debug_info.short_src, "LUA")
					elseif (file.Exists(debug_info.short_src, "GAME")) then
						code = file.Read(debug_info.short_src, "GAME")
					end
					if (code ~= nil) then
						local mdl_str = code:match('function ENT:Initialize%(.-%)\n.-self:SetModel%("(.-)"%)[%s%S]-end')
						if (mdl_str ~= nil) then
							if (not IsUselessModel(mdl_str)) then
								GAS_Logging_EntityDisplay_Cache[class_name] = mdl_str
								self.ModelPanel:SetModel(mdl_str)
								self:SetVisible(true)
								self:FixCamera()
								self.LoadingPanel:SetLoading(false)
								return
							end
						end
						local relative_path = string.GetPathFromFilename(debug_info.short_src)
						for file_name in code:gmatch('include%("(.-%.lua)"%)') do
							local relative_file = relative_path .. file_name
							local code
							if (file.Exists(relative_file, "LUA")) then
								code = file.Read(relative_file, "LUA")
							elseif (file.Exists(relative_file, "GAME")) then
								code = file.Read(relative_file, "GAME")
							end
							if (code ~= nil) then
								for mdl_str in code:gmatch('self:SetModel%("(.-)"%)') do
									if (not IsUselessModel(mdl_str)) then
										GAS_Logging_EntityDisplay_Cache[class_name] = mdl_str
										self.ModelPanel:SetModel(mdl_str)
										self:SetVisible(true)
										self:FixCamera()
										self.LoadingPanel:SetLoading(false)
										return
									end
								end
								local mdl_str = code:match('"([^\n]-%.mdl)"')
								if (mdl_str ~= nil and not IsUselessModel(mdl_str)) then
									GAS_Logging_EntityDisplay_Cache[class_name] = mdl_str
									self.ModelPanel:SetModel(mdl_str)
									self:SetVisible(true)
									self:FixCamera()
									self.LoadingPanel:SetLoading(false)
									return
								end
							end
						end
					end
				end
			end

			self:SetVisible(true)
			local net_msg_fire = GAS_Logging_EntityDisplay_Networking[class_name] == nil
			GAS_Logging_EntityDisplay_Networking[class_name] = GAS_Logging_EntityDisplay_Networking[class_name] or {}
			GAS_Logging_EntityDisplay_Networking[class_name][self] = true
			if (net_msg_fire) then
				GAS:netStart("logging:EntityDisplay:SENTModel")
					net.WriteString(class_name)
				net.SendToServer()
			end
		end
	end
end

function PANEL:Init()
	self:InfoInit()
end

local DFRAME_PANEL = table.Copy(PANEL)

function PANEL:SetTitle() end

function DFRAME_PANEL:Init()
	self:SetDrawOnTop(true)

	self:ShowFullscreenButton(false)
	self:ShowPinButton(false)
	self:ShowCloseButton(false)

	self:SetVisible(false)

	self:SetMouseInputEnabled(false)
	self:SetKeyboardInputEnabled(false)
	self:SetSize(250,250)

	self:SetTitle("Entity")

	self:InfoInit()
end

function DFRAME_PANEL:Think()
	if (not system.HasFocus() or not IsValid(self.Creator) or vgui.GetHoveredPanel() ~= self.Creator) then
		self:Close()
		return
	end
	local x,y = gui.MousePos()
	self:SetPos(x + 20, y + 20)
end

function DFRAME_PANEL:SetCreator(creator_pnl)
	self.Creator = creator_pnl
end

function GAS_Logging_DisplayEntity(setup_func, creator, on_hover)
	if (not IsValid(creator)) then return end

	local function display()
		if (IsValid(GAS_Logging_EntityDisplay)) then
			GAS_Logging_EntityDisplay:Close()
		end

		GAS_Logging_EntityDisplay = vgui.Create("GAS.Logging.EntityDisplay")
		GAS_Logging_EntityDisplay:SetCreator(creator)
		setup_func(GAS_Logging_EntityDisplay)

		return GAS_Logging_EntityDisplay
	end

	if (on_hover == true) then
		creator.GAS_Logging_DisplayEntity_OnCursorEntered = creator.GAS_Logging_DisplayEntity_OnCursorEntered or creator.OnCursorEntered
		creator.GAS_Logging_DisplayEntity_OnCursorExited  = creator.GAS_Logging_DisplayEntity_OnCursorExited or creator.OnCursorExited
		function creator:OnCursorEntered(...)
			if (self.GAS_Logging_DisplayEntity_OnCursorEntered) then
				self:GAS_Logging_DisplayEntity_OnCursorEntered(...)
			end

			self.GAS_Logging_EntityDisplay = display()
		end
		function creator:OnCursorExited(...)
			if (self.GAS_Logging_DisplayEntity_OnCursorExited) then
				self:GAS_Logging_DisplayEntity_OnCursorExited(...)
			end

			if (IsValid(self.GAS_Logging_EntityDisplay)) then
				self.GAS_Logging_EntityDisplay:Close()
			end
		end
	else
		return display()
	end
end

GAS:netReceive("logging:EntityDisplay:SENTModel", function()
	local class_name = net.ReadString()
	local success = net.ReadBool()
	if (success) then
		local model = net.ReadString()
		if (GAS_Logging_EntityDisplay_Networking[class_name] ~= nil) then
			for pnl in pairs(GAS_Logging_EntityDisplay_Networking[class_name]) do
				if (not IsValid(pnl)) then continue end
				GAS_Logging_EntityDisplay_Cache[class_name] = model
				pnl.LoadingPanel:SetLoading(false)
				pnl.ModelPanel:SetModel(model)
				pnl:FixCamera()
			end
			GAS_Logging_EntityDisplay_Networking[class_name] = nil
		end
	else
		GAS:PlaySound("error")
		if (GAS_Logging_EntityDisplay_Networking[class_name] ~= nil) then
			for pnl in pairs(GAS_Logging_EntityDisplay_Networking[class_name]) do
				if (not IsValid(pnl)) then continue end
				pnl.LoadingPanel:SetLoading(false)
				pnl.Shruggie:SetVisible(true)
			end
			GAS_Logging_EntityDisplay_Networking[class_name] = nil
		end
	end
end)

derma.DefineControl("GAS.Logging.EntityDisplay", nil, DFRAME_PANEL, "bVGUI.Frame")
derma.DefineControl("GAS.Logging.Entity", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/openpermissions_tree.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/cl_init.lua:
hook.Run("DarkRPStartedLoading")

GM.Version = "1"
GM.Name = "starwarsrp"
GM.Author = "By FPtje Falco et al."

DeriveGamemode("sandbox")
DEFINE_BASECLASS("gamemode_sandbox")
GM.Sandbox = BaseClass


local function LoadModules()
    local root = GM.FolderName .. "/gamemode/modules/"
    local _, folders = file.Find(root .. "*", "LUA")

    for _, folder in SortedPairs(folders, true) do
        if DarkRP.disabledDefaults["modules"][folder] then continue end

        for _, File in SortedPairs(file.Find(root .. folder .. "/sh_*.lua", "LUA"), true) do
            if File == "sh_interface.lua" then continue end
            include(root .. folder .. "/" .. File)
        end

        for _, File in SortedPairs(file.Find(root .. folder .. "/cl_*.lua", "LUA"), true) do
            if File == "cl_interface.lua" then continue end
            include(root .. folder .. "/" .. File)
        end
    end
end

GM.Config = {} -- config table
GM.NoLicense = GM.NoLicense or {}

include("config/config.lua")
include("libraries/sh_cami.lua")
include("libraries/simplerr.lua")
include("libraries/fn.lua")
include("libraries/tablecheck.lua")
include("libraries/interfaceloader.lua")
include("libraries/disjointset.lua")
include("config/licenseweapons.lua")

include("libraries/modificationloader.lua")

hook.Call("DarkRPPreLoadModules", GM)

LoadModules()

DarkRP.DARKRP_LOADING = true
include("config/jobrelated.lua")
include("config/addentities.lua")
include("config/ammotypes.lua")
DarkRP.DARKRP_LOADING = nil

DarkRP.finish()

hook.Call("DarkRPFinishedLoading", GM)

--PATH gamemodes/starwarsrp/gamemode/libraries/simplerr.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/libraries/simplerr.lua:
local CompileFile = CompileFile
local CompileString = CompileString
local debug = debug
local error = error
local file = file
local hook = hook
local include = include
local isfunction = isfunction
local isstring = isstring
local math = math
local os = os
local string = string
local table = table
local tonumber = tonumber
local unpack = unpack
local xpcall = xpcall

-- Template for syntax errors
-- The [ERROR] start of it cannot be removed, because that would make the
-- error mechanism remove all square brackets. Only Garry can make that bullshit up.
local synErrTranslation = [=[[ERROR] Lua is unable to understand file "%s" because its author made a mistake around line number %i.
The best help I can give you is this:

%s

Hints:
%s

------- End of Simplerr error -------
]=] -- The end is a special string by which simplerr errors are internally recognised

-- Template for runtime errors
local runErrTranslation = [=[[ERROR] A runtime error has occurred in "%s" on line %i.
The best help I can give you is this:

%s

Hints:
%s

The responsibility for the error above lies with (the authors of) one (or more) of these files:
%s
------- End of Simplerr error -------
]=]

-- Structure that contains syntax errors and their translations. Catches only the most common errors.
-- Order is important: the structure with the first match is taken.
local synErrs = {
    {
        match = "'=' expected near '(.*)'",
        text = "Right before the '%s', Lua expected to read an '='-sign, but it didn't.",
        format = function(m) return m[1] end,
        hints = {
            "Did you simply forget the '='-sign?",
            "Did you forget a comma?",
            "Is this supposed to be a local variable?"
        }
    },
    {
        match = "'.' expected [(]to close '([{[(])' at line ([0-9-]+)[)] near '(.*)'",
        text = "There is an opening '%s' bracket at line %i, but this bracket is never closed or not closed in time. It was expected to be closed before the '%s' at line %i.",
        format = function(m, l) return m[1], m[2], m[3], l end,
        hints = {
            "Did you forget a comma?",
            "All open brackets ({, (, [) must have a matching closing bracket. Are you sure it's there?",
            "Brackets must be opened and closed in the right order. This will work: ({}), but this won't: ({)}."
        }
    },
    {
        match = "'end' expected [(]to close '(.*)' at line ([0-9-]+)[)] near '(.*)'",
        text = "An '%s' was started on line %i, but it was never ended or not ended in time. It was expected to be ended before the '%s' at line %i",
        format = function(m, l) return m[1], m[2], m[3], l end,
        hints = {
            "For every if/for/do/while/function there must be an 'end' that closes it."
        }
    },
    {
        match = "unfinished string near '(.*)'",
        text = "The string '%s' at line %i is opened, but not closed.",
        format = function(m, l) return m[1], l end,
        hints = {
            "A string is a different word for literal text.",
            "Strings must be in single or double quotation marks (e.g. 'example', \"example\")",
            "A third option for strings is for them to be in double square brackets.",
            "Whatever you use (quotations or square brackets), you must not forget that strings are enclosed within a pair of quotation marks/square brackets."
        }
    },
    {
        match = "unfinished long string near '(.*)'",
        text = "Lua expected to see the end of a multiline string somewhere before the '%s' at line %i.",
        format = function(m, l) return m[1], l end,
        hints = {
            "A string is a different word for literal text.",
            "Multiline strings are strings that span over multiple lines.",
            "Multiline strings must be enclosed by double square brackets.",
            "Whatever you use (quotations or square brackets), you must not forget that strings are enclosed within a pair of quotation marks/square brackets.",
            "If you used brackets, the source of the mistake may be somewhere above the reported line."
        }
    },
    {
        match = "unfinished long comment near '(.*)'",
        text = "Lua expected to see the end of a multiline comment somewhere before the '%s' at line %i.",
        format = function(m, l) return m[1], l end,
        hints = {
            "A comment is text ignored by Lua.",
            "Multiline comments are ones that span multiple lines.",
            "Multiline comments must be enclosed by either /* and */ or double square brackets.",
            "Whatever you use (/**/ or square brackets), you must not forget that once you start a comment, you must end it.",
            "The source of the mistake may be somewhere above the reported line."
        }
    },
    -- Generic error messages
    {
        match = "function arguments expected near '(.*)'",
        text = "A function is being called right before '%s', but its arguments are not given.",
        format = function(m) return m[1] end,
        hints = {
            "Did you write 'something:otherthing'? Try changing it to 'something:otherthing()'"
        }
    },
    {
        match = "unexpected symbol near '(.*)'",
        text = "Right before the '%s', Lua encountered something it could not make sense of.",
        format = function(m) return m[1] end,
        hints = {"Did you forget something here? (Perhaps a closing bracket)", "Is it a typo?"}
    },
    {
        match = "'(.*)' expected near '(.*)'",
        text = "Right before the '%s', Lua expected to read a '%s', but it didn't.",
        format = function(m) return m[2], m[1] end,
        hints = {"Did you forget a keyword?", "Did you forget a comma?"}
    },
    {
        match = "malformed number near '(.*)'",
        text = "Lua attempted to read '%s' as a number, but failed to do so.",
        format = function(m) return m[1] end,
        hints = {
            "Numbers starting with '0x' are hexidecimal.",
            "Lua can get confused when doing '<number>..\"some text\"'. Try inserting a space between the number and the '..'."
        }
    },
}

-- Similar structure for runtime errors. Catches only the most common errors.
-- Order is important: the structure with the first match is taken
local runErrs = {
    {
        match = "table index is nil",
        text = "A table is being indexed by something that does not exist (table index is nil).", -- Requires improvement
        format = function() end,
        hints = {
            "The thing between square brackets does not exist (is nil)."
        }
    },
    {
        match = "table index is NaN",
        text = "A table is being indexed by something that is not really a number (table index is NaN).",
        format = function() end,
        hints = {
            "Did you divide zero by zero thinking it would be funny?"
        }
    },
    {
        match = "attempt to index global '(.*)' [(]a nil value[)]",
        text = "'%s' is being indexed like it is a table, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You either have 'something.somethingElse', 'something[somethingElse]' or 'something:somethingElse(more)'. The 'something' here does not exist."
        }
    },
    {
        match = "attempt to index global '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being indexed like it is a table, but in reality it is a %s value.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You either have 'something.somethingElse' or 'something:somethingElse(more)'. The 'something' here is not a table."
        }
    },
    {
        match = "attempt to index a nil value",
        text = "Something is being indexed like it is a table, but in reality does not exist (is nil).",
        format = function() end,
        hints = {
            "You either have 'something.somethingElse', 'something[somethingElse]' or 'something:somethingElse(more)'. The 'something' here does not exist."
        }
    },
    {
        match = "attempt to index a (.*) value",
        text = "Something is being indexed like it is a table, but in reality it is a %s value.",
        format = function(m) return m[1] end,
        hints = {
            "You either have 'something.somethingElse', 'something[somethingElse]' or 'something:somethingElse(more)'. The 'something' here is not a table."
        }
    },
    {
        match = "attempt to call global '(.*)' [(]a nil value[)]",
        text = "'%s' is being called like it is a function, but in reality does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here does not exist."
        }
    },
    {
        match = "attempt to call a nil value",
        text = "Something is being called like it is a function, but in reality it does not exist (is nil).",
        format = function() end,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here does not exist."
        }
    },
    {
        match = "attempt to call global '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being called like it is a function, but in reality it is a %s.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here is not a function."
        }
    },
    {
        match = "attempt to call a (.*) value",
        text = "Something is being called like it is a function, but in reality it is a %s.",
        format = function(m) return m[1] end,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here is not a function."
        }
    },
    {
        match = "attempt to call field '(.*)' [(]a nil value[)]",
        text = "'%s' is being called like it is a function, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing either stuff.something(<otherstuff>) or stuff:something(<otherstuff>). The 'something' here does not exist."
        }
    },
    {
        match = "attempt to call field '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being called like it is a function, but in reality it is a %s.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You are doing either stuff.something(<otherstuff>) or stuff:something(<otherstuff>). The 'something' here is not a function."
        }
    },
    {
        match = "attempt to concatenate global '(.*)' [(]a nil value[)]",
        text = "'%s' is being concatenated to something else, but '%s' does not exist (is nil).",
        format = function(m) return m[1], m[1] end,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing does not exist."
        }
    },
    {
        match = "attempt to concatenate global '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being concatenated to something else, but %s values cannot be concatenated.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing is neither string nor number."
        }
    },
    {
        match = "attempt to concatenate a nil value",
        text = "Two (or more) things are being concatenated and one of them does not exist (is nil).",
        format = function() end,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing does not exist."
        }
    },
    {
        match = "attempt to concatenate a (.*) value",
        text = "Two (or more) things are being concatenated and one of them is neither string nor number, but a %s.",
        format = function(m) return m[1] end,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing is neither string nor number."
        }
    },
    {
        match = "stack overflow",
        text = "The stack of function calls has overflowed",
        format = function() end,
        hints = {
            "Most likely infinite recursion.",
            "Do you have a function calling itself?"
        }
    },
    {
        match = "attempt to compare two (.*) values",
        text = "A comparison is being made between two %s values. They cannot be compared.",
        format = function(m) return m[1] end,
        hints = {
            "This error usually occurs when two incompatible things are being compared.",
            "'comparison' in this context means one of <, >, <=, >= (smaller than, greater than, etc.)"
        }
    },
    {
        match = "attempt to compare (.*) with (.*)",
        text = "A comparison is being made between a %s and a %s. This is not possible.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "This error usually occurs when two incompatible things are being compared.",
            "'Comparison' in this context means one of <, >, <=, >= (smaller than, greater than, etc.)"
        }
    },
    {
        match = "attempt to perform arithmetic on a (.*) value",
        text = "Arithmetic operations are being performed on a %s. This is not possible.",
        format = function(m) return m[1] end,
        hints = {
            "'Arithmetic' in this context means adding, multiplying, dividing, etc."
        }
    },
    {
        match = "attempt to get length of global '(.*)' [(]a nil value[)]",
        text = "The length of '%s' is requested as if it is a table, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing #something. The 'something' here is does not exist."
        }
    },
    {
        match = "attempt to get length of global '(.*)' [(]a (.*) value[)]",
        text = "The length of '%s' is requested as if it is a table, but in reality it is a %s.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You are doing #something. The 'something' here is not a table."
        }
    },
    {
        match = "attempt to get length of a nil value",
        text = "The length of something is requested as if it is a table, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing #something. The 'something' here is does not exist."
        }
    },
    {
        match = "attempt to get length of a (.*) value",
        text = "The length of something is requested as if it is a table, but in reality it is a %s.",
        format = function(m) return m[1] end,
        hints = {
            "You are doing #something. The 'something' here is not a table."
        }
    },
}

module("simplerr")

-- Get a nicely formatted stack trace. Start is where to start numbering
-- stackMod allows the caller to modify the stack before it is numbered
local function getStack(i, start, stackMod)
    i = i or 1
    start = start or 1
    local stack = {}

    -- Invariant: stack level (i + count) >= 2 and <= last stack item
    for count = 1, math.huge do -- user visible count
        local info = debug.getinfo(i + count, "Sln")
        if not info then break end

        local line = info.currentline or "unknown"
        if line == -1 and info.name then
            table.insert(stack, string.format("function '%s'", info.name))
        else
            table.insert(stack, string.format("%s on line %s", info.short_src, line))
        end
    end

    -- Allow modification of the stack
    if stackMod then stack = stackMod(stack) end

    -- add the numbering
    for count = 1, #stack do
        local stackLevel = start + count - 1
        stack[count] = string.format("\t%i. %s", stackLevel, stack[count])
    end

    return table.concat(stack, "\n")
end

-- Translate a runtime error to simplerr format.
-- Decorate with e.g. wrapError to have it actually throw the error.
function runError(msg, stackNr, hints, path, line, stack)
    stackNr = stackNr or 1
    hints = hints or {"No hints, sorry."}
    hints = "\t- " .. table.concat(hints, "\n\t- ")

    if not path and not line then
        local info = debug.getinfo(stackNr + 1, "Sln") or debug.getinfo(stackNr, "Sln")
        path = info.short_src
        line = info.currentline
    end

    return false, string.format(runErrTranslation, path, line, msg, hints, stack or getStack(stackNr + 1))
end

-- Translate the message of an error
local function translateMsg(msg, path, line, errs)
    local res
    local hints = {"No hints, sorry."}

    for i = 1, #errs do
        local trans = errs[i]
        if not string.find(msg, trans.match) then continue end

        -- translate <eof>
        msg = string.Replace(msg, "<eof>", "end of the file")

        res = string.format(trans.text, trans.format({string.match(msg, trans.match)}, line, path))
        hints = trans.hints

        break
    end

    return res or msg, "\t- " .. table.concat(hints, "\n\t- ")
end

-- Translate an error into a language understandable by non-programmers
local function translateError(path, line, err, translation, errs, stack)
    -- Using .* instead of path because path may be wrong when error is called
    local msg, hints = translateMsg(string.match(err, ".*:[0-9-]+: (.*)"), path, line, errs)
    local res = string.format(translation, path, line, msg, hints, stack)
    return res
end


-- Trims the [C] functions at the beginning of the stack
local function trimStart(stack)
    while true do
        if string.StartWith(stack[1], "function ") then
            table.remove(stack, 1)
        else
            break
        end
    end

    return stack
end

-- safeCall uses xpcall, which has the downside that both xpcall and
-- the safeCall function itself end up in the stack trace.
-- This function removes them from the stack trace
local function removeXpcall(stack)
    for i = #stack - 1, 1, -1 do
        if stack[i] == "function 'xpcall'" and string.find(stack[i + 1], "simplerr") then
            table.remove(stack, i)
            table.remove(stack, i) -- also remove the simplerr safeCall call

            return stack
        end
    end

    return stack
end

-- Combines the two above functions
local function stackModAggregate(stack)
    stack = trimStart(stack)
    return removeXpcall(stack)
end

-- Used as the error handler in safeCall
local function errorHandler(err, func)
    -- Investigate the stack. Not using err matching because calls to error can give a different path and line
    local stack = getStack(func and 1 or 2, 1, stackModAggregate) -- add called func to stack

    -- Fetch the path and line number from the top of the stack
    local firstLine = string.sub(stack, 1, string.match(stack, "()\n") - 1)
    local path, line = string.match(firstLine, "\t[0-9-]+%. (.*) on line ([0-9-]+)")
    line = tonumber(line)

    return {err, path, line, stack}
end

-- Call a function and catch immediate runtime errors
function safeCall(f, ...)
    -- Use xpcall so fetching of debug info is in the stack of the error rather than after it is unwound
    local res = {xpcall(f, errorHandler, ...)}

    local succ, errInfo = res[1], res[2]

    if succ then return unpack(res) end

    -- This will only happen if the error is "not enough memory" or "error in error handling".
    -- The former tends to crash the game and the latter will mean it'll probably error in the next line.
    -- But we will try anyway.
    -- Note: stack trace will be less accurate.
    if isstring(errInfo) then errInfo = errorHandler(errInfo, f) end

    -- Skip translation if the error is already a simplerr error
    -- This prevents nested simplerr errors when runError is called by a file loaded by runFile
    local mustTranslate = not string.find(errInfo[1], "------- End of Simplerr error -------")
    return false, mustTranslate and translateError(errInfo[2], errInfo[3], errInfo[1], runErrTranslation, runErrs, errInfo[4]) or errInfo[1]
end

-- Run a file or explain its syntax errors in layman's terms
-- Returns bool succeed, [string error]
-- Do NOT use this on clientside files.
-- Clientside files sent by the server cannot be read using file.Read unless you're the host of a listen server
function runFile(path)
    if not file.Exists(path, "LUA") then error(string.format("Could not run file '%s' (file not found)", path)) end
    local contents = file.Read(path, "LUA")

    -- Files can make a comment containing #NoSimplerr# to disable simplerr (and thus enable autorefresh)
    if string.find(contents, "#NoSimplerr#") then include(path) return true end

    -- Catch syntax errors with CompileString
    local err = CompileString(contents, path, false)

    -- CompileString returns the following string whenever a file is empty: Invalid script - or too short.
    -- It also prints: Not running script <path> - it's too short.
    -- If so, do nothing.
    if err == "Invalid script - or too short." then return true end

    -- No syntax errors, check for immediate runtime errors using CompileFile
    -- Using the function CompileString returned leads to relative path trouble
    if isfunction(err) then return safeCall(CompileFile(path), path) end

    -- Fetch the line number from the error
    local line = string.match(err, ".*:([0-9-]+): .*")
    line = tonumber(line)

    return false, translateError(path, line, err, synErrTranslation, synErrs)
end

-- Error wrapper: decorator for runFile and safeCall that throws an error on failure.
-- Breaks execution. Must be the last decorator.
function wrapError(succ, err, ...)
    if succ then return succ, err, ... end

    error(err)
end

-- Hook wrapper: Calls a hook on error
function wrapHook(succ, err, ...)
    if not succ then hook.Call("onSimplerrError", nil, err) end

    return succ, err, ...
end

-- Logging wrapper: decorator for runFile and safeCall that logs failures.
local log = {}
function wrapLog(succ, err, ...)
    if succ then return succ, err, ... end

    local data = {
        err = err,
        time = os.time()
    }

    table.insert(log, data)

    return succ, err, ...
end

-- Retrieve the log
function getLog() return log end

-- Clear the log
function clearLog() log = {} end

--PATH gamemodes/starwarsrp/gamemode/libraries/tablecheck.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/police/sh_interface.lua:
DarkRP.PLAYER.isWanted = DarkRP.stub{
    name = "isWanted",
    description = "Whether this player is wanted",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is wanted",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getWantedReason = DarkRP.stub{
    name = "getWantedReason",
    description = "Get the reason why someone is wanted",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "The reason",
            type = "string"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.isArrested = DarkRP.stub{
    name = "isArrested",
    description = "Whether this player is arrested",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is arrested",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.isCP = DarkRP.stub{
    name = "isCP",
    description = "Whether this player is part of the police force (mayor, cp, chief).",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is part of the police force.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.isMayor = DarkRP.stub{
    name = "isMayor",
    description = "Whether this player is a mayor.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is a mayor.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.isChief = DarkRP.stub{
    name = "isChief",
    description = "Whether this player is a Chief.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is a Chief.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}


DarkRP.hookStub{
    name = "canRequestWarrant",
    description = "Whether someone can request a search warrant.",
    parameters = {
        {
            name = "target",
            description = "The player to get the search warrant for",
            type = "Player"
        },
        {
            name = "actor",
            description = "The player requesting the warrant",
            type = "Player"
        },
        {
            name = "reason",
            description = "The reason for the search warrant",
            type = "Player"
        }
    },
    returns = {
        {
            name = "canRequest",
            description = "A yes or no as to whether the search warrant can be requested",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when it can't",
            type = "string"
        }
    }
}

DarkRP.hookStub{
    name = "canWanted",
    description = "Whether someone can make a player wanted",
    parameters = {
        {
            name = "target",
            description = "The player to make wanted by the police",
            type = "Player"
        },
        {
            name = "actor",
            description = "The player requesting the wanted status",
            type = "Player"
        },
        {
            name = "reason",
            description = "The reason",
            type = "Player"
        }
    },
    returns = {
        {
            name = "canRequest",
            description = "A yes or no as to whether the wanted can be requested",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when it can't",
            type = "string"
        }
    }
}

DarkRP.hookStub{
    name = "canUnwant",
    description = "Whether someone can remove the wanted status from a player",
    parameters = {
        {
            name = "target",
            description = "The player to make wanted by the police",
            type = "Player"
        },
        {
            name = "actor",
            description = "The player requesting the wanted status",
            type = "Player"
        }
    },
    returns = {
        {
            name = "canUnwant",
            description = "A yes or no answer",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when the answer is no",
            type = "string"
        }
    }
}

DarkRP.hookStub{
    name = "lockdownStarted",
    description = "When a lockdown has started.",
    parameters = {
        {
            name = "actor",
            description = "The player who started the lockdown. Note: Can be the world entitity.",
            type = "Player"
        }
    },
    returns = {}
}

DarkRP.hookStub{
    name = "lockdownEnded",
    description = "When a lockdown has ended.",
    parameters = {
        {
            name = "actor",
            description = "The player who ended the lockdown. Note: Can be the world entitity.",
            type = "Player"
        }
    },
    returns = {}
}

DarkRP.hookStub{
    name = "playerGotLicense",
    description = "When a player got a gun license",
    parameters = {
        {
            name = "target",
            description = "The player who got the license",
            type = "Player"
        },
        {
            name = "actor",
            description = "The player who gave the license",
            type = "Player"
        }
    },
    returns = {}
}

--PATH gamemodes/starwarsrp/gamemode/modules/language/sh_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/chat/sh_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/chat/cl_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_interface.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_config/disabled_defaults.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/language/sh_english.lua:
--[[-----------------------------------------------------------------------
English (example) language file
---------------------------------------------------------------------------

This is the english language file. The things on the left side of the equals sign are the things you should leave alone
The parts between the quotes are the parts you should translate. You can also copy this file and create a new language.

= Warning =
Sometimes when DarkRP is updated, new phrases are added.
If you don't translate these phrases to your language, it will use the English sentence.
To fix this, join your server, open your console and enter darkp_getphrases yourlanguage
For English the command would be:
    darkrp_getphrases "en"
because "en" is the language code for English.

You can copy the missing phrases to this file and translate them.

= Note =
Make sure the language code is right at the bottom of this file

= Using a language =
Make sure the convar gmod_language is set to your language code. You can do that in a server CFG file.
---------------------------------------------------------------------------]]

local my_language = {
    -- Admin things
    need_admin = "You need admin privileges in order to be able to %s",
    need_sadmin = "You need super admin privileges in order to be able to %s",
    no_privilege = "You don't have the right privileges to perform this action",
    no_jail_pos = "No jail position",
    invalid_x = "Invalid %s! %s",

    -- F1 menu
    f1ChatCommandTitle = "Chat commands",
    f1Search = "Search...",

    -- Money things:
    price = "Price: %s%d",
    priceTag = "Price: %s",
    reset_money = "%s has reset all players' money!",
    has_given = "%s has given you %s",
    you_gave = "You gave %s %s",
    npc_killpay = "%s for killing an NPC!",
    profit = "profit",
    loss = "loss",
    Donate = "Donate",
    you_donated = "You have donated %s to %s!",
    has_donated = "%s has donated %s!",

    -- backwards compatibility
    deducted_x = "Deducted %s%d",
    need_x = "Need %s%d",

    deducted_money = "Deducted %s",
    need_money = "Need %s",

    payday_message = "Payday! You received %s!",
    payday_unemployed = "You received no salary because you are unemployed!",
    payday_missed = "Pay day missed! (You're Arrested)",

    property_tax = "Property tax! %s",
    property_tax_cant_afford = "You couldn't pay the taxes! Your property has been taken away from you!",
    taxday = "Tax Day! %s%% of your income was taken!",

    found_cheque = "You have found %s%s in a cheque made out to you from %s.",
    cheque_details = "This cheque is made out to %s.",
    cheque_torn = "You have torn up the cheque.",
    cheque_pay = "Pay: %s",
    signed = "Signed: %s",

    found_cash = "You have picked up %s%d!", -- backwards compatibility
    found_money = "You have picked up %s!",

    owner_poor = "The %s owner is too poor to subsidize this sale!",

    -- Police
    Wanted_text = "Wanted!",
    wanted = "Wanted by Police!\nReason: %s",
    youre_arrested = "You have been arrested. Time left: %d seconds!",
    youre_arrested_by = "You have been arrested by %s.",
    youre_unarrested_by = "You were unarrested by %s.",
    hes_arrested = "%s has been arrested for %d seconds!",
    hes_unarrested = "%s has been released from jail!",
    warrant_ordered = "%s ordered a search warrant for %s. Reason: %s",
    warrant_request = "%s requests a search warrant for %s\nReason: %s",
    warrant_request2 = "Search warrant request sent to Mayor %s!",
    warrant_approved = "Search warrant approved for %s!\nReason: %s\nOrdered by: %s",
    warrant_approved2 = "You are now able to search his house.",
    warrant_denied = "Mayor %s has denied your search warrant request.",
    warrant_expired = "The search warrant for %s has expired!",
    warrant_required = "You need a warrant in order to be able to open this door.",
    warrant_required_unfreeze = "You need a warrant in order to be able to unfreeze this prop.",
    warrant_required_unweld = "You need a warrant in order to be able to unweld this prop.",
    wanted_by_police = "%s is wanted by the police!\nReason: %s\nOrdered by: %s",
    wanted_by_police_print = "%s has made %s wanted, reason: %s",
    wanted_expired = "%s is no longer wanted by the Police.",
    wanted_revoked = "%s is no longer wanted by the Police.\nRevoked by: %s",
    cant_arrest_other_cp = "You cannot arrest other CPs!",
    must_be_wanted_for_arrest = "The player must be wanted in order to be able to arrest them.",
    cant_arrest_fadmin_jailed = "You cannot arrest a player who has been jailed by an admin.",
    cant_arrest_no_jail_pos = "You cannot arrest people since there are no jail positions set!",
    cant_arrest_spawning_players = "You cannot arrest players who are spawning.",

    suspect_doesnt_exist = "Suspect does not exist.",
    actor_doesnt_exist = "Actor does not exist.",
    get_a_warrant = "get a warrant",
    remove_a_warrant = "remove a warrant",
    make_someone_wanted = "make someone wanted",
    remove_wanted_status = "remove wanted status",
    already_a_warrant = "There already is a search warrant for this suspect.",
    not_warranted = "There is no search warrant for this person.",
    already_wanted = "The suspect is already wanted.",
    not_wanted = "The suspect is not wanted.",
    need_to_be_cp = "You have to be a member of the police force.",
    suspect_must_be_alive_to_do_x = "The suspect must be alive in order to %s.",
    suspect_already_arrested = "The suspect is already in jail.",

    -- Players
    health = "Health: %s",
    job = "Job: %s",
    salary = "Salary: %s%s",
    wallet = "Wallet: %s%s",
    weapon = "Weapon: %s",
    kills = "Kills: %s",
    deaths = "Deaths: %s",
    rpname_changed = "%s changed their RPName to: %s",
    disconnected_player = "Disconnected player",
    player = "player",

    -- Teams
    need_to_be_before = "You need to be %s first in order to be able to become %s",
    need_to_make_vote = "You need to make a vote to become a %s!",
    team_limit_reached = "Can not become %s as the limit is reached",
    wants_to_be = "%s\nwants to be\n%s",
    has_not_been_made_team = "%s has not been made %s!",
    job_has_become = "%s has been made a %s!",

    -- Disasters
    meteor_approaching = "WARNING: Meteor storm approaching!",
    meteor_passing = "Meteor storm passing.",
    meteor_enabled = "Meteor Storms are now enabled.",
    meteor_disabled = "Meteor Storms are now disabled.",
    earthquake_report = "Earthquake reported of magnitude %sMw",
    earthtremor_report = "Earth tremor reported of magnitude %sMw",

    -- Keys, vehicles and doors
    keys_allowed_to_coown = "You are allowed to co-own this\n(Press Reload with keys or press F2 to co-own)\n",
    keys_other_allowed = "Allowed to co-own:",
    keys_allow_ownership = "(Press Reload with keys or press F2 to allow ownership)",
    keys_disallow_ownership = "(Press Reload with keys or press F2 to disallow ownership)",
    keys_owned_by = "Owned by:",
    keys_unowned = "Unowned\n(Press Reload with keys or press F2 to own)",
    keys_everyone = "(Press Reload with keys or press F2 to enable for everyone)",
    door_unown_arrested = "You can not own or unown things while arrested!",
    door_unownable = "This door cannot be owned or unowned!",
    door_sold = "You have sold this for %s",
    door_already_owned = "This door is already owned by someone!",
    door_cannot_afford = "You can not afford this door!",
    door_hobo_unable = "You can not buy a door if you are a hobo!",
    vehicle_cannot_afford = "You can not afford this vehicle!",
    door_bought = "You've bought this door for %s%s",
    vehicle_bought = "You've bought this vehicle for %s%s",
    door_need_to_own = "You need to own this door in order to be able to %s",
    door_rem_owners_unownable = "You can not remove owners if a door is non-ownable!",
    door_add_owners_unownable = "You can not add owners if a door is non-ownable!",
    rp_addowner_already_owns_door = "%s already owns (or is already allowed to own) this door!",
    add_owner = "Add owner",
    remove_owner = "Remove owner",
    coown_x = "Co-own %s",
    allow_ownership = "Allow ownership",
    disallow_ownership = "Disallow ownership",
    edit_door_group = "Edit door group",
    door_groups = "Door groups",
    door_group_doesnt_exist = "Door group does not exist!",
    door_group_set = "Door group set successfully.",
    sold_x_doors_for_y = "You have sold %d doors for %s%d!", -- backwards compatibility
    sold_x_doors = "You have sold %d doors for %s!",
    no_doors_owned = "You don't own any doors!",

    -- Entities
    drugs = "drugs",
    Drugs = "Drugs",
    drug_lab = "Drug Lab",
    gun_lab = "Gun Lab",
    any_lab = "any lab",
    gun = "gun",
    microwave = "Microwave",
    food = "food",
    Food = "Food",
    money_printer = "Money Printer",
    tip_jar = "Tip Jar",

    sign_this_letter = "Sign this letter",
    signed_yours = "Yours,",

    money_printer_exploded = "Your money printer has exploded!",
    money_printer_overheating = "Your money printer is overheating!",

    contents = "Contents: ",
    amount = "Amount: ",

    picking_lock = "Picking lock",

    cannot_pocket_x = "You cannot put this in your pocket!",
    cannot_pocket_gravgunned = "You cannot put this in your pocket: it is being held by a gravgun.",
    object_too_heavy = "This object is too heavy.",
    pocket_full = "Your pocket is full!",
    pocket_no_items = "Your pocket contains no items.",
    drop_item = "Drop item",

    bonus_destroying_entity = "destroying this illegal entity.",

    switched_burst = "Switched to burst-fire mode.",
    switched_fully_auto = "Switched to fully automatic fire mode.",
    switched_semi_auto = "Switched to semi-automatic fire mode.",

    keypad_checker_shoot_keypad = "Shoot a keypad to see what it controls.",
    keypad_checker_shoot_entity = "Shoot an entity to see which keypads are connected to it",
    keypad_checker_click_to_clear = "Right click to clear.",
    keypad_checker_entering_right_pass = "Entering the right password",
    keypad_checker_entering_wrong_pass = "Entering the wrong password",
    keypad_checker_after_right_pass = "after having entered the right password",
    keypad_checker_after_wrong_pass = "after having entered the wrong password",
    keypad_checker_right_pass_entered = "Right password entered",
    keypad_checker_wrong_pass_entered = "Wrong password entered",
    keypad_checker_controls_x_entities = "This keypad controls %d entities",
    keypad_checker_controlled_by_x_keypads = "This entity is controlled by %d keypads",
    keypad_on = "ON",
    keypad_off = "OFF",
    seconds = "seconds",

    persons_weapons = "%s's weapons:",
    returned_persons_weapons = "Returned %s's confiscated weapons.",
    no_weapons_confiscated = "%s had no weapons confiscated!",
    no_illegal_weapons = "%s had no weapons.",
    confiscated_these_weapons = "Confiscated these weapons:",
    checking_weapons = "Confiscating weapons",

    shipment_antispam_wait = "Please wait before spawning another shipment.",
    createshipment = "Create a shipment",
    splitshipment = "Split this shipment",
    shipment_cannot_split = "Cannot split this shipment.",

    -- Talking
    hear_noone = "No-one can hear you %s!",
    hear_everyone = "Everyone can hear you!",
    hear_certain_persons = "Players who can hear you %s: ",

    whisper = "whisper",
    yell = "yell",
    broadcast = "[Broadcast!]",
    radio = "radio",
    request = "(REQUEST!)",
    group = "(group)",
    demote = "(DEMOTE)",
    ooc = "OOC",
    radio_x = "Radio %d",

    talk = "talk",
    speak = "speak",

    speak_in_ooc = "speak in OOC",
    perform_your_action = "perform your action",
    talk_to_your_group = "talk to your group",

    channel_set_to_x = "Channel set to %s!",
    channel = "channel",

    -- Notifies
    disabled = "%s has been disabled! %s",
    gm_spawnvehicle = "spawn vehicles",
    gm_spawnsent = "spawn scripted entities (SENTs)",
    gm_spawnnpc = "spawn Non-Player Characters (NPCs)",
    see_settings = "Please see the DarkRP settings.",
    limit = "You have reached the %s limit!",
    have_to_wait = "You need to wait another %d seconds before using %s!",
    must_be_looking_at = "You need to be looking at a %s!",
    incorrect_job = "You do not have the right job to %s",
    unavailable = "This %s is unavailable",
    unable = "You are unable to %s. %s",
    cant_afford = "You cannot afford this %s",
    created_x = "%s created a %s",
    cleaned_up = "Your %s were cleaned up.",
    you_bought_x = "You have bought %s for %s%d.", -- backwards compatibility
    you_bought = "You have bought %s for %s.",
    you_got_yourself = "You got yourself a %s.",
    you_received_x = "You have received %s for %s.",

    created_first_jailpos = "You have created the first jail position!",
    added_jailpos = "You have added one extra jail position!",
    reset_add_jailpos = "You have removed all jail positions and you have added a new one here.",
    created_spawnpos = "You have added a spawn position for %s.",
    updated_spawnpos = "You have removed all spawn positions for %s and added a new one here.",
    remove_spawnpos = "You have removed all spawn positions for %s.",
    do_not_own_ent = "You do not own this entity!",
    cannot_drop_weapon = "Can't drop this weapon!",
    job_switch = "Jobs switched successfully!",
    job_switch_question = "Switch jobs with %s?",
    job_switch_requested = "Job switch requested.",
    switch_jobs = "switch jobs",

    cooks_only = "Cooks only.",

    -- Misc
    unknown = "Unknown",
    arguments = "arguments",
    no_one = "no one",
    door = "door",
    vehicle = "vehicle",
    door_or_vehicle = "door/vehicle",
    driver = "Driver: %s",
    name = "Name: %s",
    locked = "Locked.",
    unlocked = "Unlocked.",
    player_doesnt_exist = "Player does not exist.",
    job_doesnt_exist = "Job does not exist!",
    must_be_alive_to_do_x = "You must be alive in order to %s.",
    banned_or_demoted = "Banned/demoted",
    wait_with_that = "Wait with that.",
    could_not_find = "Could not find %s",
    f3tovote = "Hit F3 to vote",
    listen_up = "Listen up:", -- In rp_tell or rp_tellall
    nlr = "New Life Rule: Do Not Revenge Arrest/Kill.",
    reset_settings = "You have reset all settings!",
    must_be_x = "You must be a %s in order to be able to %s.",
    agenda = "agenda",
    agenda_updated = "The agenda has been updated",
    job_set = "%s has set their job to '%s'",
    demote_vote = "demote",
    demoted = "%s has been demoted",
    demoted_not = "%s has not been demoted",
    demote_vote_started = "%s has started a vote for the demotion of %s",
    demote_vote_text = "Demotion nominee:\n%s", -- '%s' is the reason here
    cant_demote_self = "You cannot demote yourself.",
    i_want_to_demote_you = "I want to demote you. Reason: %s",
    tried_to_avoid_demotion = "You tried to escape demotion. You failed and have been demoted.", -- naughty boy!
    lockdown_started = "The mayor has initiated a Lockdown, please return to your homes!",
    lockdown_ended = "The lockdown has ended",
    gunlicense_requested = "%s has requested %s a gun license",
    gunlicense_granted = "%s has granted %s a gun license",
    gunlicense_denied = "%s has denied %s a gun license",
    gunlicense_question_text = "Grant %s a gun license?",
    gunlicense_remove_vote_text = "%s has started a vote for the gun license removal of %s",
    gunlicense_remove_vote_text2 = "Revoke gunlicense:\n%s", -- Where %s is the reason
    gunlicense_removed = "%s's license has been removed!",
    gunlicense_not_removed = "%s's license has not been removed!",
    vote_specify_reason = "You need to specify a reason!",
    vote_started = "The vote has been created",
    vote_alone = "You have won the vote since you are alone in the server.",
    you_cannot_vote = "You cannot vote!",
    x_cancelled_vote = "%s cancelled the last vote.",
    cant_cancel_vote = "Could not cancel the last vote as there was no last vote to cancel!",
    jail_punishment = "Punishment for disconnecting! Jailed for: %d seconds.",
    admin_only = "Admin only!", -- When doing /addjailpos
    chief_or = "Chief or ",-- When doing /addjailpos
    frozen = "Frozen.",
    recipient = "recipient",
    forbidden_name = "Forbidden name.",
    illegal_characters = "Illegal characters.",
    too_long = "Too long.",
    too_short = "Too short.",

    dead_in_jail = "You now are dead until your jail time is up!",
    died_in_jail = "%s has died in jail!",

    credits_for = "CREDITS FOR %s\n",
    credits_see_console = "DarkRP credits printed to console.",

    rp_getvehicles = "Available vehicles for custom vehicles:",

    data_not_loaded_one = "Your data has not been loaded yet. Please wait.",
    data_not_loaded_two = "If this persists, try rejoining or contacting an admin.",

    cant_spawn_weapons = "You cannot spawn weapons.",
    drive_disabled = "Drive disabled for now.",
    property_disabled = "Property disabled for now.",

    not_allowed_to_purchase = "You are not allowed to purchase this item.",

    rp_teamban_hint = "rp_teamban [player name/ID] [team name/id]. Use this to ban a player from a certain team.",
    rp_teamunban_hint = "rp_teamunban [player name/ID] [team name/id]. Use this to unban a player from a certain team.",
    x_teambanned_y_for_z = "%s has banned %s from being a %s for %s minutes.",
    x_teamunbanned_y = "%s has unbanned %s from being a %s.",

    -- Backwards compatibility:
    you_set_x_salary_to_y = "You set %s's salary to %s%d.",
    x_set_your_salary_to_y = "%s set your salary to %s%d.",
    you_set_x_money_to_y = "You set %s's money to %s%d.",
    x_set_your_money_to_y = "%s set your money to %s%d.",

    you_set_x_salary = "You set %s's salary to %s.",
    x_set_your_salary = "%s set your salary to %s.",
    you_set_x_money = "You set %s's money to %s.",
    x_set_your_money = "%s set your money to %s.",
    you_set_x_name = "You set %s's name to %s",
    x_set_your_name = "%s set your name to %s",

    someone_stole_steam_name = "Someone is already using your Steam name as their RP name so we gave you a '1' after your name.", -- Uh oh
    already_taken = "Already taken.",

    job_doesnt_require_vote_currently = "This job does not require a vote at the moment!",

    x_made_you_a_y = "%s has made you a %s!",

    cmd_cant_be_run_server_console = "This command cannot be run from the server console.",

    -- The lottery
    lottery_started = "There is a lottery! Participate for %s%d?", -- backwards compatibility
    lottery_has_started = "There is a lottery! Participate for %s?",
    lottery_entered = "You entered the lottery for %s",
    lottery_not_entered = "%s did not enter the lottery",
    lottery_noone_entered = "No-one has entered the lottery",
    lottery_won = "%s has won the lottery! They have won %s",
    lottery = "lottery",
    lottery_please_specify_an_entry_cost = "Please specify an entry cost (%s-%s)",
    too_few_players_for_lottery = "There are too few players to start a lottery. There need to be at least %d players",
    lottery_ongoing = "Cannot start a lottery, there is already a lottery ongoing",

    -- Animations
    custom_animation = "Custom animation!",
    bow = "Bow",
    sexy_dance = "Sexy dance",
    follow_me = "Follow me!",
    laugh = "Laugh",
    lion_pose = "Lion pose",
    nonverbal_no = "Non-verbal no",
    thumbs_up = "Thumbs up",
    wave = "Wave",
    dance = "Dance",

    -- Hungermod
    starving = "Starving!",

    -- AFK
    afk_mode = "AFK Mode",
    unable_afk_spam_prevention = "Please wait before going AFK again.",
    salary_frozen = "Your salary has been frozen.",
    salary_restored = "Welcome back, your salary has now been restored.",
    no_auto_demote = "You will not be auto-demoted.",
    youre_afk_demoted = "You were demoted for being AFK for too long. Next time use /afk.",
    hes_afk_demoted = "%s has been demoted for being AFK for too long.",
    afk_cmd_to_exit = "Type /afk to exit AFK mode.",
    player_now_afk = "%s is now AFK.",
    player_no_longer_afk = "%s is no longer AFK.",

    -- Hitmenu
    hit = "hit",
    hitman = "Hitman",
    current_hit = "Hit: %s",
    cannot_request_hit = "Cannot request hit! %s",
    hitmenu_request = "Request",
    player_not_hitman = "This player is not a hitman!",
    distance_too_big = "Distance too big.",
    hitman_no_suicide = "The hitman won't kill themself.",
    hitman_no_self_order = "A hitman cannot order a hit for themself.",
    hitman_already_has_hit = "The hitman already has a hit ongoing.",
    price_too_low = "Price too low!",
    hit_target_recently_killed_by_hit = "The target was recently killed by a hit,",
    customer_recently_bought_hit = "The customer has recently requested a hit.",
    accept_hit_question = "Accept hit from %s\nregarding %s for %s%d?", -- backwards compatibility
    accept_hit_request = "Accept hit from %s\nregarding %s for %s?",
    hit_requested = "Hit requested!",
    hit_aborted = "Hit aborted! %s",
    hit_accepted = "Hit accepted!",
    hit_declined = "The hitman declined the hit!",
    hitman_left_server = "The hitman has left the server!",
    customer_left_server = "The customer has left the server!",
    target_left_server = "The target has left the server!",
    hit_price_set_to_x = "Hit price set to %s%d.", -- backwards compatibility
    hit_price_set = "Hit price set to %s.",
    hit_complete = "Hit by %s complete!",
    hitman_died = "The hitman died!",
    target_died = "The target has died!",
    hitman_arrested = "The hitman was arrested!",
    hitman_changed_team = "The hitman changed team!",
    x_had_hit_ordered_by_y = "%s had an active hit ordered by %s",
    place_a_hit = "place a hit!",
    hit_cancel = "hit cancellation!",
    hit_cancelled = "The hit was cancelled!",
    no_active_hit = "You have no active hit!",

    -- Vote Restrictions
    hobos_no_rights = "Hobos have no voting rights!",
    gangsters_cant_vote_for_government = "Gangsters cannot vote for government things!",
    government_cant_vote_for_gangsters = "Government officials cannot vote for gangster things!",

    -- VGUI and some more doors/vehicles
    vote = "Vote",
    time = "Time: %d",
    yes = "Yes",
    no = "No",
    ok = "Okay",
    cancel = "Cancel",
    add = "Add",
    remove = "Remove",
    none = "None",

    x_options = "%s options",
    sell_x = "Sell %s",
    set_x_title = "Set %s title",
    set_x_title_long = "Set the title of the %s you are looking at.",
    jobs = "Jobs",
    buy_x = "Buy %s",

    -- F4menu
    ammo = "ammo",
    weapon_ = "weapon",
    no_extra_weapons = "This job has no extra weapons.",
    become_job = "Become job",
    create_vote_for_job = "Create vote",
    shipment = "shipment",
    Shipments = "Shipments",
    shipments = "shipments",
    F4guns = "Weapons",
    F4entities = "Miscellaneous",
    F4ammo = "Ammo",
    F4vehicles = "Vehicles",

    -- Tab 1
    give_money = "Give money to the player you're looking at",
    drop_money = "Drop money",
    change_name = "Change your DarkRP name",
    go_to_sleep = "Go to sleep/wake up",
    drop_weapon = "Drop current weapon",
    buy_health = "Buy health(%s)",
    request_gunlicense = "Request gunlicense",
    demote_player_menu = "Demote a player",

    searchwarrantbutton = "Make a player wanted",
    unwarrantbutton = "Remove the wanted status from a player",
    noone_available = "No one available",
    request_warrant = "Request a search warrant for a player",
    make_wanted = "Make someone wanted",
    make_unwanted = "Make someone unwanted",
    set_jailpos = "Set the jail position",
    add_jailpos = "Add a jail position",

    set_custom_job = "Set a custom job (press enter to activate)",

    set_agenda = "Set the agenda (press enter to activate)",

    initiate_lockdown = "Initiate a lockdown",
    stop_lockdown = "Stop the lockdown",
    start_lottery = "Start a lottery",
    give_license_lookingat = "Give <lookingat> a gun license",

    laws_of_the_land = "LAWS OF THE LAND",
    law_added = "Law added.",
    law_removed = "Law removed.",
    law_reset = "Laws reset.",
    law_too_short = "Law too short.",
    laws_full = "The laws are full.",
    default_law_change_denied = "You are not allowed to change the default laws.",

    -- Second tab
    job_name = "Name: ",
    job_description = "Description: ",
    job_weapons = "Weapons: ",

    -- Entities tab
    buy_a = "Buy %s: %s",

    -- Licenseweaponstab
    license_tab = [[License weapons

    Tick the weapons people should be able to get WITHOUT a license!
    ]],
    license_tab_other_weapons = "Other weapons:",
}

-- The language code is usually (but not always) a two-letter code. The default language is "en".
-- Other examples are "nl" (Dutch), "de" (German)
-- If you want to know what your language code is, open GMod, select a language at the bottom right
-- then enter gmod_language in console. It will show you the code.
-- Make sure language code is a valid entry for the convar gmod_language.
DarkRP.addLanguage("en", my_language)

--PATH gamemodes/starwarsrp/gamemode/modules/fspectate/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/chat/cl_chat.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_jobmodels.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/animations/sh_animations.lua:
local Anims = {}

-- Load animations after the languages for translation purposes
hook.Add("loadCustomDarkRPItems", "loadAnimations", function()
    Anims[ACT_GMOD_GESTURE_BOW] = DarkRP.getPhrase("bow")
    Anims[ACT_GMOD_TAUNT_MUSCLE] = DarkRP.getPhrase("sexy_dance")
    Anims[ACT_GMOD_GESTURE_BECON] = DarkRP.getPhrase("follow_me")
    Anims[ACT_GMOD_TAUNT_LAUGH] = DarkRP.getPhrase("laugh")
    Anims[ACT_GMOD_TAUNT_PERSISTENCE] = DarkRP.getPhrase("lion_pose")
    Anims[ACT_GMOD_GESTURE_DISAGREE] = DarkRP.getPhrase("nonverbal_no")
    Anims[ACT_GMOD_GESTURE_AGREE] = DarkRP.getPhrase("thumbs_up")
    Anims[ACT_GMOD_GESTURE_WAVE] = DarkRP.getPhrase("wave")
    Anims[ACT_GMOD_TAUNT_DANCE] = DarkRP.getPhrase("dance")
end)

function DarkRP.addPlayerGesture(anim, text)
    if not anim then DarkRP.error("Argument #1 of DarkRP.addPlayerGesture (animation/gesture) does not exist.", 2) end
    if not text then DarkRP.error("Argument #2 of DarkRP.addPlayerGesture (text) does not exist.", 2) end

    Anims[anim] = text
end

function DarkRP.removePlayerGesture(anim)
    if not anim then DarkRP.error("Argument #1 of DarkRP.removePlayerGesture (animation/gesture) does not exist.", 2) end

    Anims[anim] = nil
end

local function physGunCheck(ply)
    local hookName = "darkrp_anim_physgun_" .. ply:EntIndex()
    hook.Add("Think", hookName, function()
        if IsValid(ply) and
           ply:Alive() and
           ply:GetActiveWeapon():IsValid() and
           ply:GetActiveWeapon():GetClass() == "weapon_physgun" and
           ply:KeyDown(IN_ATTACK) and
           (ply:GetAllowWeaponsInVehicle() or not ply:InVehicle()) then
            local ent = ply:GetEyeTrace().Entity
            if IsValid(ent) and ent:IsPlayer() and not ply.SaidHi then
                ply.SaidHi = true
                ply:DoAnimationEvent(ACT_SIGNAL_GROUP)
            end
        else
            if IsValid(ply) then
                ply.SaidHi = nil
            end
            hook.Remove("Think", hookName)
        end
    end)
end

hook.Add("KeyPress", "darkrp_animations", function(ply, key)
    if key == IN_ATTACK then
        local weapon = ply:GetActiveWeapon()

        if weapon:IsValid() then
            local class = weapon:GetClass()

            -- Saying hi/hello to a player
            if class == "weapon_physgun" then
                physGunCheck(ply)

            -- Hobo throwing poop!
            elseif class == "weapon_bugbait" then
                local Team = ply:Team()
                if RPExtraTeams[Team] and RPExtraTeams[Team].hobo then
                    ply:DoAnimationEvent(ACT_GMOD_GESTURE_ITEM_THROW)
                end
            end
        end
    end
end)

if SERVER then
    local function CustomAnim(ply, cmd, args)
        if ply:EntIndex() == 0 then return end
        local Gesture = tonumber(args[1] or 0)
        if not Anims[Gesture] then return end

        local RP = RecipientFilter()
        RP:AddAllPlayers()

        umsg.Start("_DarkRP_CustomAnim", RP)
        umsg.Entity(ply)
        umsg.Short(Gesture)
        umsg.End()
    end
    concommand.Add("_DarkRP_DoAnimation", CustomAnim)
    return
end

local function KeysAnims(um)
    local ply = um:ReadEntity()
    local act = um:ReadString()

    if not IsValid(ply) then return end
    ply:AnimRestartGesture(GESTURE_SLOT_CUSTOM, act == "usekeys" and ACT_GMOD_GESTURE_ITEM_PLACE or ACT_HL2MP_GESTURE_RANGE_ATTACK_FIST, true)
end
usermessage.Hook("anim_keys", KeysAnims)

local function CustomAnimation(um)
    local ply = um:ReadEntity()
    local act = um:ReadShort()

    if not IsValid(ply) then return end
    ply:AnimRestartGesture(GESTURE_SLOT_CUSTOM, act, true)
end
usermessage.Hook("_DarkRP_CustomAnim", CustomAnimation)

local AnimFrame
local function AnimationMenu()
    if AnimFrame then return end

    local Panel = vgui.Create("Panel")
    Panel:SetPos(0,0)
    Panel:SetSize(ScrW(), ScrH())
    function Panel:OnMousePressed()
        AnimFrame:Close()
    end

    AnimFrame = AnimFrame or vgui.Create("DFrame", Panel)
    local Height = table.Count(Anims) * 55 + 32
    AnimFrame:SetSize(130, Height)
    AnimFrame:SetPos(ScrW() / 2 + ScrW() * 0.1, ScrH() / 2 - (Height / 2))
    AnimFrame:SetTitle(DarkRP.getPhrase("custom_animation"))
    AnimFrame.btnMaxim:SetVisible(false)
    AnimFrame.btnMinim:SetVisible(false)
    AnimFrame:SetVisible(true)
    AnimFrame:MakePopup()
    AnimFrame:ParentToHUD()

    function AnimFrame:Close()
        Panel:Remove()
        AnimFrame:Remove()
        AnimFrame = nil
    end

    local i = 0
    for k, v in SortedPairs(Anims) do
        i = i + 1
        local button = vgui.Create("DButton", AnimFrame)
        button:SetPos(10, (i - 1) * 55 + 30)
        button:SetSize(110, 50)
        button:SetText(v)

        button.DoClick = function()
            RunConsoleCommand("_DarkRP_DoAnimation", k)
        end
    end
    AnimFrame:SetSkin(GAMEMODE.Config.DarkRPSkin)
end
concommand.Add("_DarkRP_AnimationMenu", AnimationMenu)

--PATH gamemodes/starwarsrp/gamemode/config/ammotypes.lua:
DarkRP.createAmmoType("pistol", {
    name = "Pistol ammo",
    model = "models/Items/BoxSRounds.mdl",
    price = 30,
    amountGiven = 24
})

DarkRP.createAmmoType("buckshot", {
    name = "Shotgun ammo",
    model = "models/Items/BoxBuckshot.mdl",
    price = 50,
    amountGiven = 8
})

DarkRP.createAmmoType("smg1", {
    name = "Rifle ammo",
    model = "models/Items/BoxMRounds.mdl",
    price = 80,
    amountGiven = 30
})

DarkRP.createCategory{
    name = "Other",
    categorises = "ammo",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

--PATH addons/!jobs/lua/darkrp_customthings/shipments.lua:
--[[---------------------------------------------------------------------------
DarkRP custom shipments and guns
---------------------------------------------------------------------------

This file contains your custom shipments and guns.
This file should also contain shipments and guns from DarkRP that you edited.

Note: If you want to edit a default DarkRP shipment, first disable it in darkrp_config/disabled_defaults.lua
    Once you've done that, copy and paste the shipment to this file and edit it.

The default shipments and guns can be found here:
https://github.com/FPtje/DarkRP/blob/master/gamemode/config/addentities.lua

For examples and explanation please visit this wiki page:
https://darkrp.miraheze.org/wiki/DarkRP:CustomShipmentFields


Add shipments and guns under the following line:
---------------------------------------------------------------------------]]

--PATH addons/!jobs/lua/darkrp_customthings/entities.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_customthings/groupchats.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_customthings/categories.lua:
--[[-----------------------------------------------------------------------
Categories
---------------------------------------------------------------------------
The categories of the default F4 menu.

Please read this page for more information:
https://darkrp.miraheze.org/wiki/DarkRP:Categories

In case that page can't be reached, here's an example with explanation:






Add new categories under the next line!
---------------------------------------------------------------------------]]


DarkRP.createCategory{
    name = "Podstawowe",
    categorises = "jobs",
    startExpanded = true,
    color = Color(255, 255, 255, 255),
    canSee = function(ply) return true end,
    sortOrder = 1,
}
DarkRP.createCategory{
    name = "Republic Commando",
    categorises = "jobs",
    startExpanded = true,
    color = Color(130, 130, 130),
    canSee = function(ply) return true end,
    sortOrder = 2,
}
DarkRP.createCategory{
    name = "Sztab Wyższy",
    categorises = "jobs",
    startExpanded = true,
    color = Color(130, 130, 130),
    canSee = function(ply) return true end,
    sortOrder = 3,
}
DarkRP.createCategory{
    name = "104th Batalion Wilczego Stada",
    categorises = "jobs",
    startExpanded = true,
    color = Color(130, 116, 166),
    canSee = function(ply) return true end,
    sortOrder = 4,
}
DarkRP.createCategory{
    name = "501st Legion",
    categorises = "jobs",
    startExpanded = true,
    color = Color(48, 118, 230),
    canSee = function(ply) return true end,
    sortOrder = 5,
}
DarkRP.createCategory{
    name = "Gwardia Coruscant",
    categorises = "jobs",
    startExpanded = true,
    color = Color(170, 50, 50),
    canSee = function(ply) return true end,
    sortOrder = 6,
}
DarkRP.createCategory{
    name = "DOOM UNIT",
    categorises = "jobs",
    startExpanded = true,
    color = Color(4, 67, 19),
    canSee = function(ply) return true end,
    sortOrder = 7,
}
DarkRP.createCategory{
    name = "RSB",
    categorises = "jobs",
    startExpanded = true,
    color = Color(85, 19, 63),
    canSee = function(ply) return true end,
    sortOrder = 8,
}
DarkRP.createCategory{
    name = "Jedi",
    categorises = "jobs",
    startExpanded = true,
    color = Color(23, 192, 214),
    canSee = function(ply) return true end,
    sortOrder = 9,
}
DarkRP.createCategory{
    name = "Jedi Kanoniczni",
    categorises = "jobs",
    startExpanded = true,
    color = Color(23, 192, 214),
    canSee = function(ply) return true end,
    sortOrder = 10,
}
DarkRP.createCategory{
    name = "CIS",
    categorises = "jobs",
    startExpanded = true,
    color = Color(215, 201, 44),
    canSee = function(ply) return true end,
    sortOrder = 11,
}
DarkRP.createCategory{
    name = "Cywile",
    categorises = "jobs",
    startExpanded = true,
    color = Color(60, 150, 135),
    canSee = function(ply) return true end,
    sortOrder = 12,
}

DarkRP.createCategory{
    name = "Prace Prywatne",
    categorises = "jobs",
    startExpanded = true,
    color = Color(43, 43, 43),
    canSee = function(ply) return true end,
    sortOrder = 13,
}

DarkRP.createCategory{
    name = "Eventowe",
    categorises = "jobs",
    startExpanded = true,
    color = Color(192, 192, 192),
    canSee = function(ply) return true end,
    sortOrder = 14,
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_camera.lua:
SWEP.SmoothedMagnification = 1
SWEP.FOV = 90


-- local arc9_cheapscopes = GetConVar("arc9_cheapscopes")
local arc9_vm_cambob = GetConVar("arc9_vm_cambob")
local arc9_vm_cambobwalk = GetConVar("arc9_vm_cambobwalk")
local arc9_vm_cambobintensity = GetConVar("arc9_vm_cambobintensity")

local SmoothRecoilAmount = 0

function SWEP:CalcView(ply, pos, ang, fov)
    if self:GetOwner():ShouldDrawLocalPlayer() then return end

    local rec = (self:GetLastRecoilTime() + 0.25) - CurTime()

    local reckick = self:GetProcessedValue("RecoilKick")
    rec = rec * 3 * reckick

    if rec > 0 then
        ang.r = ang.r + (math.sin(CurTime() * self:GetProcessedValue("RecoilKickDamping", true)) * rec)
    end

    if self.RecoilKickAffectPitch then
        if !self:IsUsingRTScope() then
            local recam = math.min(self:GetRecoilAmount(), 15)
            SmoothRecoilAmount = Lerp(FrameTime() * 3, SmoothRecoilAmount, recam)
            local thing = SmoothRecoilAmount * reckick * self:GetProcessedValue("Recoil")
            ang.p = ang.p - 0.6 * thing
            self.VMZOffsetForCamera = -0.25 * thing
        end
    end

    local sightamount = self:GetSightAmount()

    -- does anybody knows what this part of code for? seems to be useless and breaks lean mods 
    -- if self:IsScoping() and arc9_cheapscopes:GetBool() then
    --     local shootang = self:GetShootDir()

    --     ang = LerpAngle(sightamount, ang, shootang)
    -- end

    fov = fov / self:GetSmoothedFOVMag()

    self.FOV = fov

    ang = ang + (self:GetCameraControl() or angle_zero)

    if arc9_vm_cambob:GetBool() then
        local sprintmult = arc9_vm_cambobwalk:GetBool() and 1 or Lerp(self:GetSprintAmount(), 0, 1)
        local totalmult = math.ease.InQuad(math.Clamp(self.ViewModelBobVelocity / 350, 0, 1) * Lerp(sightamount, 1, 0.65)) * sprintmult * arc9_vm_cambobintensity:GetFloat()
        ang:RotateAroundAxis(ang:Right(),   math.cos(self.BobCT * 6)    * totalmult * -0.5)
        ang:RotateAroundAxis(ang:Up(),      math.cos(self.BobCT * 3.3)  * totalmult * -0.5)
        ang:RotateAroundAxis(ang:Forward(), math.sin(self.BobCT * 6)    * totalmult * -0.36)
    end

    pos, ang = self:DoCameraLean(pos, ang)

    return pos, ang, fov
end

local mathapproach = math.Approach

function SWEP:GetSmoothedFOVMag()
    local mag = 1
    local speed = 20

    if self:GetInSights() then
        local target = self:GetMagnification()
        local sightdelta = self:GetSightAmount()
		local curTime = UnPredictedCurTime()
		local fuckingreloadprocess = math.Clamp(1 - (self:GetReloadFinishTime() - curTime) / (self.ReloadTime * self:GetAnimationTime("reload")), 0, 1)
		local reloadanim = self:GetAnimationEntry(self:TranslateAnimation("reload"))
		local shotgun = self:GetShouldShotgunReload()

        if self:GetInSights() then
            sightdelta = math.ease.OutQuart(sightdelta)
        else
            sightdelta = math.ease.InQuart(sightdelta)
        end
        sightdelta = math.ease.InOutQuad(sightdelta)

        if self.Peeking then
            target = self.IronSights.Magnification * 0.95
        end

		if !shotgun and fuckingreloadprocess < (reloadanim.PeekProgress or reloadanim.MinProgress or 0.9) then target = target * 0.95 end
			
		if shotgun and self:GetReloading() then target = target * 0.95 end
		
        mag = Lerp(sightdelta, 1, target)

        -- mag = target
        speed = Lerp(self:GetSightAmount(), speed, 10)
    end

    local diff = math.abs(self.SmoothedMagnification - mag)

    self.SmoothedMagnification = mathapproach(self.SmoothedMagnification, mag, FrameTime() * diff * speed)

    return self.SmoothedMagnification
end

SWEP.LastMuzzleAngle = Angle(0, 0, 0)
SWEP.MuzzleAngleVelocity = Angle(0, 0, 0)
SWEP.ProceduralViewOffset = Angle(0, 0, 0)
SWEP.ProceduralSpeedLimit = 5

function SWEP:GetCameraControl()
    local seqprox = self:GetSequenceProxy()
    if seqprox != 0 then
        local slottbl = self:LocateSlotFromAddress(seqprox)
        local atttbl = self:GetFinalAttTable(slottbl)
        local camqca = atttbl.IKCameraMotionQCA

        if !camqca then return end

        local mdl = slottbl.GunDriverModel

        mdl:SetPos(vector_origin)
        mdl:SetAngles(angle_zero)

        mdl:SetSequence(self:GetSequenceIndex())
        mdl:SetCycle(self:GetSequenceCycle())

        local ang = (mdl:GetAttachment(camqca) or {}).Ang

        if !ang then return end

        ang = mdl:WorldToLocalAngles(ang)
        ang:Sub(atttbl.IKCameraMotionOffsetAngle or angle_zero)
        ang:Mul(self:GetProcessedValue("CamQCA_Mult", true) or 1)

        return ang
    else
        local camqca = self:GetProcessedValue("CamQCA", true)

        if !camqca then return end

        local vm = self:GetVM()

        local ang = (vm:GetAttachment(camqca) or {}).Ang

        if !ang then return end

        ang = vm:WorldToLocalAngles(ang)
        ang:Sub(self.CamOffsetAng)

        if self:GetProcessedValue("CamCoolView", true) then
            local ft = FrameTime()

            self.ProceduralViewOffset:Normalize()
            
            ang:Normalize()
            local delta = self.LastMuzzleAngle - ang
            delta:Normalize()

            local targeting = self:GetNextPrimaryFire() - .1 > CurTime()
            local target = targeting and 1 or 0
            target = math.min(target, 1 - math.pow( vm:GetCycle(), 2 ) )
            local progress = Lerp(ft * 15, progress or 0, target)

            local mult = self:GetProcessedValue("CamQCA_Mult", true) or 1

            if self:GetAnimLockTime() < CurTime() and !self:GetInMeleeAttack() then
                mult = 0
            end

            self.MuzzleAngleVelocity = self.MuzzleAngleVelocity + delta * 2 * mult
            self.MuzzleAngleVelocity.p = mathapproach(self.MuzzleAngleVelocity.p, -self.ProceduralViewOffset.p * 2, ft * 20)
            self.MuzzleAngleVelocity.p = math.Clamp(self.MuzzleAngleVelocity.p, -self.ProceduralSpeedLimit, self.ProceduralSpeedLimit)
            self.ProceduralViewOffset.p = self.ProceduralViewOffset.p + self.MuzzleAngleVelocity.p * ft
            self.ProceduralViewOffset.p = math.Clamp(self.ProceduralViewOffset.p, -90, 90)
            self.MuzzleAngleVelocity.y = mathapproach(self.MuzzleAngleVelocity.y, -self.ProceduralViewOffset.y * 2, ft * 20)
            self.MuzzleAngleVelocity.y = math.Clamp(self.MuzzleAngleVelocity.y, -self.ProceduralSpeedLimit, self.ProceduralSpeedLimit)
            self.ProceduralViewOffset.y = self.ProceduralViewOffset.y + self.MuzzleAngleVelocity.y * ft
            self.ProceduralViewOffset.y = math.Clamp(self.ProceduralViewOffset.y, -90, 90)
            self.MuzzleAngleVelocity.r = mathapproach(self.MuzzleAngleVelocity.r, -self.ProceduralViewOffset.r * 2, ft * 20)
            self.MuzzleAngleVelocity.r = math.Clamp(self.MuzzleAngleVelocity.r, -self.ProceduralSpeedLimit, self.ProceduralSpeedLimit)
            self.ProceduralViewOffset.r = self.ProceduralViewOffset.r + self.MuzzleAngleVelocity.r * ft
            self.ProceduralViewOffset.r = math.Clamp(self.ProceduralViewOffset.r, -90, 90)

            self.ProceduralViewOffset.p = mathapproach(self.ProceduralViewOffset.p, 0, (1 - progress) * ft * -self.ProceduralViewOffset.p)
            self.ProceduralViewOffset.y = mathapproach(self.ProceduralViewOffset.y, 0, (1 - progress) * ft * -self.ProceduralViewOffset.y)
            self.ProceduralViewOffset.r = mathapproach(self.ProceduralViewOffset.r, 0, (1 - progress) * ft * -self.ProceduralViewOffset.r)

            self.LastMuzzleAngle = ang

            return self.ProceduralViewOffset
        else
            ang:Mul(self:GetProcessedValue("CamQCA_Mult", true) or 1)
            ang:Mul(1 - self:GetSightAmount() * (1 - (self:GetProcessedValue("CamQCA_Mult_ADS", true) or 0.5)))
        end

        return ang
    end
end

-- 100, 100 = 1
-- 100, 90 = 0.8
-- 100, 70 = 0.6
-- 100, 60 = 0.5
-- 100, 40 = 0.3

function SWEP:GetCorVal()
    local vmfov = self.ViewModelFOV
    local fov = self.FOV

    return vmfov / (fov * 1.333333)
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_bottombar.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_presets.lua:

local ARC9ScreenScale = ARC9.ScreenScale

local clicksound = "arc9/newui/uimouse_click_return.ogg"
local removesound = "arc9/newui/presets/preset_sound1-delete.ogg"
local savesound = "arc9/newui/presets/preset_sound3-save.ogg"
local applysound = "arc9/newui/presets/preset_sound2-apply.ogg"
local randomizesound = "arc9/newui/presets/shuffle_sound2.ogg"

local mat_default = Material("arc9/arc9_logo.png", "mips smooth")
local mat_random = Material("arc9/ui/random.png", "mips smooth")
local nextpreset = 0

local deadzonex = GetConVar("arc9_hud_deadzonex")

function SWEP:CreatePresetMenu(reload)
    if GetConVar("arc9_atts_nocustomize"):GetBool() then return end
    if reload and self.CustomizeHUD and self.CustomizeHUD.presetpanel then self.CustomizeHUD.presetpanel:Remove() end
    if !reload and self.CustomizeHUD and self.CustomizeHUD.presetpanel then self:ClosePresetMenu() return end

    -- self.CustomizeButtons[self.CustomizeTab + 1].func(self)
    if !self.CustomizeButtons[self.CustomizeTab + 1].inspect then
        self.CustomizeButtons[1].func(self)
        self.CustomizeTab = 0
    end

    local scrw, scrh = ScrW(), ScrH()
    local bg = self.CustomizeHUD

    local presetpanel = vgui.Create("DFrame", bg)
    self.CustomizeHUD.presetpanel = presetpanel
    presetpanel:SetPos(scrw - ARC9ScreenScale(130+19) - deadzonex:GetInt(), ARC9ScreenScale(45))
    presetpanel:SetSize(ARC9ScreenScale(130), scrh-ARC9ScreenScale(145))
    presetpanel:SetTitle("")
    -- presetpanel:SetDraggable(false)
    presetpanel:ShowCloseButton(false)
    presetpanel:SetAlpha(0)
    presetpanel:AlphaTo(255, 0.1, 0, nil)

    local cornercut = ARC9ScreenScale(3.5)
    presetpanel.Paint = function(self2, w, h) 
        draw.NoTexture()
        surface.SetDrawColor(ARC9.GetHUDColor("bg"))
        surface.DrawPoly({{x = cornercut, y = h},{x = 0, y = h-cornercut}, {x = 0, y = cornercut},{x = cornercut, y = 0}, {x = w-cornercut, y = 0},{x = w, y = cornercut}, {x = w, y = h-cornercut}, {x = w-cornercut, y = h}})
        -- thingy at bottom
        surface.SetDrawColor(ARC9.GetHUDColor("hi"))
        surface.DrawPoly({{x = cornercut, y = h}, {x = 0, y = h-cornercut}, {x = cornercut, y = h-cornercut*.5}})
        surface.DrawPoly({{x = w, y = h-cornercut}, {x = w-cornercut, y = h}, {x = w-cornercut, y = h-cornercut*.5}})
        surface.DrawPoly({{x = cornercut, y = h-cornercut*.5}, {x = w-cornercut, y = h-cornercut*.5}, {x = w-cornercut, y = h}, {x = cornercut, y = h}, })
        -- same thingy at top
        surface.DrawPoly({{x = 0, y = cornercut}, {x = cornercut, y = 0}, {x = cornercut, y = cornercut*.5}})
        surface.DrawPoly({{x = w-cornercut, y = 0}, {x = w, y = cornercut}, {x = w-cornercut, y = cornercut*.5}})
        surface.DrawPoly({{x = cornercut, y = 0}, {x = w-cornercut, y = 0}, {x = w-cornercut, y = cornercut*.5}, {x = cornercut, y = cornercut*.5}, })
    end

    local presetscroller = vgui.Create("ARC9ScrollPanel", presetpanel)
    presetscroller:SetSize(presetpanel:GetWide() - ARC9ScreenScale(4), presetpanel:GetTall()-ARC9ScreenScale(26))
    presetscroller:SetPos(ARC9ScreenScale(2), ARC9ScreenScale(4))
    -- presetscroller.Paint = function(self2, w, h) 
    --     surface.SetDrawColor(ARC9.GetHUDColor("bg"))
    --     surface.DrawRect(0, 0, w, h)
    -- end
    
    local savebtn = vgui.Create("ARC9TopButton", presetpanel)
    surface.SetFont("ARC9_12")
    local savetxt = ARC9:GetPhrase("customize.presets.save")
    local importtxt = ARC9:GetPhrase("customize.presets.import")
    local tw = surface.GetTextSize(savetxt)
    local tw2 = surface.GetTextSize(importtxt)
    local ih8l18n = (presetpanel:GetWide() - tw - tw2) > ARC9ScreenScale(70) and ARC9ScreenScale(10) or 0

    savebtn:SetPos(ARC9ScreenScale(5)+ih8l18n, presetpanel:GetTall() - ARC9ScreenScale(20))
    savebtn:SetSize(ARC9ScreenScale(22)+tw, ARC9ScreenScale(21*0.75))
    savebtn:SetButtonText(savetxt, "ARC9_12")
    savebtn:SetIcon(Material("arc9/ui/save.png", "mips smooth"))
    savebtn.DoClick = function(self2)
        surface.PlaySound(savesound)
        if nextpreset > CurTime() then return end
        nextpreset = CurTime() + 1

        self:CreatePresetName()
    end
    savebtn.Think = function(self2)
        if !IsValid(self) then return end
        if self2:IsHovered() then
            self.CustomizeHints["customize.hint.select"] = "customize.hint.save"
            self.CustomizeHints["customize.hint.deselect"] = "customize.hint.quicksave"
        end
    end
    savebtn.DoRightClick = function(self2)
        if nextpreset > CurTime() then return end
        nextpreset = CurTime() + 1

        -- local txt = os.date( "%I.%M%p", os.time() )
        -- if txt:Left(1) == "0" then txt = txt:Right( #txt-1 ) end
        local txt = "Preset "
        local num = 0

        for _, preset in ipairs(self:GetPresets()) do
            local psname = self:GetPresetName(preset)
            if string.StartWith(psname, txt) then
                local qsnum = tonumber(string.sub(psname, string.len(txt) + 1))

                -- print(string.sub(preset, string.len(txt) + 1))

                if qsnum and qsnum > num then
                    num = qsnum
                end
            end
        end

        txt = txt .. tostring(num + 1)

        self:SavePreset( txt )
        surface.PlaySound("arc9/shutter.ogg")

        timer.Simple(0.5, function()
            if IsValid(self) and IsValid(self:GetOwner()) then
                self:GetOwner():ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 127), 0.5, 0)
                if self:GetCustomize() then
                    self:CreateHUD_Bottom()
                    self:CreatePresetMenu(true)
                end
            end
        end)
    end

    local importbtn = vgui.Create("ARC9TopButton", presetpanel)
    importbtn:SetPos(presetpanel:GetWide()-(ARC9ScreenScale(22)+tw2) - ARC9ScreenScale(5) - ih8l18n , presetpanel:GetTall() - ARC9ScreenScale(20))
    importbtn:SetSize(ARC9ScreenScale(22)+tw2, ARC9ScreenScale(21*0.75))
    importbtn:SetButtonText(importtxt, "ARC9_12")
    importbtn:SetIcon(Material("arc9/ui/import.png", "mips smooth"))
    importbtn.DoClick = function(self2)
        self:CreateImportPreset()
        surface.PlaySound(clicksound)
    end
    importbtn.Think = function(self2)
        if !IsValid(self) then return end
        if self2:IsHovered() then
            self.CustomizeHints["customize.hint.select"] = "customize.hint.import"
        end
    end

    local function createpresetbtn(preset, undeletable)
        local filename = ARC9.PresetPath .. self:GetPresetBase() .. "/" .. preset .. "." .. ARC9.PresetIconFormat

        if preset != "random" and !file.Exists(filename, "DATA") then return end

        local presetbtn = vgui.Create("DButton", presetscroller)
        presetbtn:SetTall(ARC9ScreenScale(36))
        presetbtn:Dock(TOP)
        presetbtn:DockMargin(0, 0, 5, 5)
        presetbtn:SetText("")
        presetbtn.DoClick = function(self2)
            if GetConVar("arc9_atts_nocustomize"):GetBool() then return end
            self:LoadPreset(preset)
            surface.PlaySound(applysound)
        end

        if preset == "random" then 
            presetbtn.name = ARC9:GetPhrase("customize.presets.random")
            presetbtn.attcount = "?"
            presetbtn.icon = mat_random
            presetbtn.def = true
            presetbtn.DoClick = function(self2)
                if GetConVar("arc9_atts_nocustomize"):GetBool() then return end
                -- self:NPC_Initialize()        
                net.Start("arc9_randomizeatts")
                net.SendToServer()

                surface.PlaySound(randomizesound)

                timer.Simple(0.1, function() if IsValid(self) then self:CreateHUD_Bottom() end end)
            end
        else
            presetbtn.preset = preset
            presetbtn.name, presetbtn.attcount = self:GetPresetData(preset)
        end
        if presetbtn.name == "ignore" then presetbtn:Remove() return end

        if presetbtn.name == "default" then presetbtn.name = ARC9:GetPhrase("customize.presets.default") presetbtn.def = true end

        if file.Exists(filename, "DATA") then
            presetbtn.icon = Material("data/" .. filename, "smooth")
        end

        -- if presetbtn.name == "Default" then
        --     presetbtn.icon = Material("materials/arc9/arc9_sus.png")
        -- end

        presetbtn.Paint = function(self2, w, h) 
            surface.SetDrawColor(ARC9.GetHUDColor("bg"))
            surface.DrawRect(0, 0, w, h)
            if self2:IsHovered() then
                if self2:IsDown() then 
                    surface.SetDrawColor(ARC9.GetHUDColor("hi", 100))
                end
                if !GetConVar("arc9_atts_nocustomize"):GetBool() then
                    self.CustomizeHints["customize.hint.select"] = "customize.hint.install"
                end
                surface.DrawRect(0, 0, w, h)
            end
            surface.SetDrawColor(20, 20, 20, 120)
            surface.DrawRect(ARC9ScreenScale(1), ARC9ScreenScale(1), h*1.4, h - ARC9ScreenScale(2))

            surface.SetDrawColor(ARC9.GetHUDColor("fg"))
            surface.SetMaterial(presetbtn.icon or mat_default)
            surface.DrawTexturedRect(0, -h*0.2, h*1.4, h*1.4)
            -- surface.DrawTexturedRectUV(0, 0, h*1.4, h, 0, 0.2, 1, 0.8)

            surface.SetFont("ARC9_12")
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.SetTextPos(h*1.4 + ARC9ScreenScale(5), 0)
            surface.DrawText(self2.name)
            surface.SetFont("ARC9_8")
            surface.SetTextPos(h*1.4 + ARC9ScreenScale(5), ARC9ScreenScale(12))
            surface.DrawText(tostring(self2.attcount) .. ARC9:GetPhrase("customize.presets.atts"))

            if self2.def or undeletable and !self2:IsHovered() and !(self2.delbutton and self2.delbutton:IsHovered()) then
                surface.SetTextColor(ARC9.GetHUDColor("fg", 75))
                surface.SetTextPos(h*1.4 + ARC9ScreenScale(5), ARC9ScreenScale(20))
                surface.DrawText(ARC9:GetPhrase("customize.presets.default.long"))
            end
        end

        -- local preset_apply = vgui.Create("ARC9TopButton", presetbtn)
        -- surface.SetFont("ARC9_10")
        -- local tw3 = surface.GetTextSize("Install")
        -- preset_apply:SetPos(presetpanel:GetWide() - ARC9ScreenScale(22) - tw3 - ARC9ScreenScale(4), presetbtn:GetTall() - ARC9ScreenScale(15))
        -- preset_apply:SetSize(ARC9ScreenScale(17) + tw3, ARC9ScreenScale(21*0.625))
        -- preset_apply:SetButtonText("Install", "ARC9_10")
        -- preset_apply:SetIcon(Material("arc9/ui/apply.png", "mips smooth"))
        -- preset_apply.DoClick = function(self2)
        --     self:LoadPreset(preset)
        --     surface.PlaySound(clicksound)
        -- end
        -- preset_apply.Think = function(self2)
        --     if !IsValid(self) then return end
        --     if self2:IsHovered() then
        --         self.CustomizeHints["customize.hint.select"] = "Install"
        --     end
        -- end

        if !undeletable and !presetbtn.def  then
            local preset_share = vgui.Create("ARC9TopButton", presetbtn)
            preset_share:SetPos(ARC9ScreenScale(69), presetbtn:GetTall() - ARC9ScreenScale(15))
            preset_share:SetSize(ARC9ScreenScale(21*0.625), ARC9ScreenScale(21*0.625))
            preset_share:SetIcon(Material("arc9/ui/share.png", "mips smooth"))
            preset_share.DoClick = function(self2)
                surface.PlaySound(clicksound)

                local f = file.Open(ARC9.PresetPath .. self:GetPresetBase() .. "/" .. preset .. ".txt", "r", "DATA")
                if !f then return end
                local str = f:Read()

                local strs = string.Split(str, "\n")

                self:CreateExportPreset("["..string.Split(strs[1], "=")[2].."]"..strs[2])
                -- self:CreateExportPreset(self:GeneratePresetExportCode())
            end
            preset_share.Think = function(self2)
                if !IsValid(self) then return end
                if self2:IsHovered() then
                    self.CustomizeHints["customize.hint.select"] = "customize.hint.export"
                end
            end
        end
        
        if !undeletable and !presetbtn.def or undeletable and !presetbtn.def then
            local preset_delete = vgui.Create("ARC9TopButton", presetbtn)
            presetbtn.delbutton = preset_delete
            preset_delete:SetPos(ARC9ScreenScale(54), presetbtn:GetTall() - ARC9ScreenScale(15))
            preset_delete:SetSize(ARC9ScreenScale(21*0.625), ARC9ScreenScale(21*0.625))
            preset_delete:SetIcon(Material("arc9/ui/delete.png", "mips smooth"))
            preset_delete.DoClick = function(self2)
                if undeletable then
                    self:CreateDeleteDefPreset(preset)
                else
                    self:DeletePreset(preset)
                    presetbtn:Remove()
                    presetbtn = nil
                    -- self:CreatePresetMenu()
                    surface.PlaySound(removesound)
                end
            end
            preset_delete.Think = function(self2)
                if !IsValid(self) then return end
                if self2:IsHovered() then
                    self.CustomizeHints["customize.hint.select"] = "customize.hint.delete"
                end

                if undeletable then
                    if presetbtn:IsHovered() or self2:IsHovered() then
                        self2:SetSize(ARC9ScreenScale(21*0.625), ARC9ScreenScale(21*0.625))
                    else
                        self2:SetSize(0, 0)
                    end
                end
            end
        end
    end

    createpresetbtn("default", true) -- i want not only one default preset
    local presetlist = self:GetPresets()

    for _, preset in ipairs(presetlist) do
        if preset == "autosave" or preset == "default" then continue end
        createpresetbtn(preset, !tonumber(preset)) -- if preset is a number then it's a user generated, if no - standard
    end

    if GetConVar("arc9_free_atts"):GetBool() then
        createpresetbtn("random", true)
    end
end

function SWEP:ClosePresetMenu()
    if self.CustomizeHUD and self.CustomizeHUD.presetpanel then 
        self.CustomizeHUD.topright_panel.topright_presets:SetChecked(false)
        self.CustomizeHUD.presetpanel:AlphaTo(0, 0.1, 0, function()
            if self.CustomizeHUD.presetpanel then
                self.CustomizeHUD.presetpanel:Remove()
            end
            self.CustomizeHUD.presetpanel = nil
        end)
    end
end

local function createPopup(self, title, buttontext, typeable, inside, btnfunc, noinput, secondline)
    local scrw, scrh = ScrW(), ScrH()

    local bg = vgui.Create("DFrame")
    bg:SetPos(0, 0)
    bg:SetSize(scrw, scrh)
    bg:SetTitle("")
    bg:SetDraggable(false)
    bg:ShowCloseButton(false)
    bg:SetAlpha(0)
    bg:AlphaTo(255, 0.1, 0, nil)
    bg.Paint = function(self2, w, h)
        if !IsValid(self) then return end
        surface.SetDrawColor(31, 31, 31, 235)
        surface.DrawRect(0, 0, scrw, scrh)
        
        surface.SetFont("ARC9_20")
        local tw = surface.GetTextSize(title)
        surface.SetTextColor(ARC9.GetHUDColor("shadow"))
        surface.SetTextPos(w/2-tw/2+ARC9ScreenScale(1), h/2 - ARC9ScreenScale(71) + (noinput and ARC9ScreenScale(10) or 0))
        surface.DrawText(title)
        surface.SetTextColor(ARC9.GetHUDColor("fg"))
        surface.SetTextPos(w/2-tw/2, h/2 - ARC9ScreenScale(72) + (noinput and ARC9ScreenScale(10) or 0))
        surface.DrawText(title)

        if secondline then
            local tw = surface.GetTextSize(secondline)
            surface.SetTextColor(ARC9.GetHUDColor("shadow"))
            surface.SetTextPos(w/2-tw/2+ARC9ScreenScale(1), h/2 - ARC9ScreenScale(71-35))
            surface.DrawText(secondline)
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.SetTextPos(w/2-tw/2, h/2 - ARC9ScreenScale(72-35))
            surface.DrawText(secondline)
        end
    end
    bg:MakePopup()

    local textentry = nil

    if !noinput then
        textentry = vgui.Create("DTextEntry", bg)
        textentry:SetSize(scrw/3, ARC9ScreenScale(24))
        textentry:Center()
        textentry:SetY(scrh/2 - ARC9ScreenScale(48))
        textentry:RequestFocus()
        textentry:SetFont("ARC9_24")
        textentry:SetText("")

        textentry.OnEnter = function(spaa, kc)
            btnfunc(bg, textentry)
        end
    end

    local savebtn = vgui.Create("ARC9TopButton", bg)
    surface.SetFont("ARC9_16")
    local tw = surface.GetTextSize(buttontext)
    local tw2 = surface.GetTextSize(ARC9:GetPhrase("customize.presets.cancel"))
    savebtn:SetPos(scrw/3 + scrw/12 - (ARC9ScreenScale(29)+tw)/2, scrh/2 - ARC9ScreenScale(12))
    savebtn:SetSize(ARC9ScreenScale(29)+tw, ARC9ScreenScale(22))
    savebtn:SetButtonText(buttontext, "ARC9_16")
    savebtn:SetIcon(Material("arc9/ui/apply.png", "mips smooth"))
    savebtn.DoClick = function(self2)
        surface.PlaySound(clicksound)
        btnfunc(bg, textentry)
    end

    if typeable then
        local cancelbtn = vgui.Create("ARC9TopButton", bg)
        cancelbtn:SetPos(scrw/3 + scrw/4.5 - (ARC9ScreenScale(29)+tw2)/2, scrh/2 - ARC9ScreenScale(12))
        cancelbtn:SetSize(ARC9ScreenScale(29)+tw2, ARC9ScreenScale(22))
        cancelbtn:SetButtonText(ARC9:GetPhrase("customize.presets.cancel"), "ARC9_16")
        cancelbtn:SetIcon(Material("arc9/ui/close.png", "mips smooth"))
        cancelbtn.DoClick = function(self2)
            surface.PlaySound(clicksound)
            bg:AlphaTo(0, 0.1, 0, function()
                bg:Remove()
            end)
        end
    else
        savebtn:SetPos(scrw/3 + scrw/6 - (ARC9ScreenScale(29)+tw)/2, scrh/2 - ARC9ScreenScale(12))
        textentry:SetText(inside)
        textentry:SetEnabled(false)
        textentry:SelectAll()
        textentry:CopySelected()
        textentry:SelectNone()
    end
end

function SWEP:CreatePresetName()
    createPopup(self, ARC9:GetPhrase("customize.presets.new"), ARC9:GetPhrase("customize.presets.save"), true, nil, function(bg, textentry)
        local txt = textentry:GetText()
        txt = string.sub(txt, 0, 36)
        
        if txt == "" then txt = ARC9:GetPhrase("customize.presets.unnamed") end

        if txt != "autosave" and txt != "default" then
            self:SavePreset(txt)
            surface.PlaySound("arc9/shutter.ogg")

            timer.Simple(0.5, function()
                if IsValid(self) and IsValid(self:GetOwner()) then
                    self:GetOwner():ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 127), 0.5, 0)
                    if self:GetCustomize() then
                        self:CreateHUD_Bottom()
                        self:CreatePresetMenu(true)
                    end
                end
            end)

            bg:AlphaTo(0, 0.1, 0, function()
                bg:Remove()
            end)
        else
            textentry:SetText("")
            textentry:SetPlaceholderText("You are bad")
        end
    end)
end

function SWEP:CreateExportPreset(string)
    createPopup(self, ARC9:GetPhrase("customize.presets.code"), ARC9:GetPhrase("customize.presets.back"), false, string, function(bg, textentry)
        bg:AlphaTo(0, 0.1, 0, function()
            bg:Remove()
        end)
    end)
end

function SWEP:CreateDeleteDefPreset(preset)
    createPopup(self, ARC9:GetPhrase("customize.presets.deldef", {name=preset}), ARC9:GetPhrase("customize.presets.yes"), true, nil, function(bg, textentry)
        bg:AlphaTo(0, 0.1, 0, function()
            
            bg:Remove()
            surface.PlaySound(removesound)
            self:IgnorePreset(preset)
            self:CreatePresetMenu(true)
        end)
    end, true, ARC9:GetPhrase("customize.presets.deldef2"))
end

function SWEP:CreateImportPreset()
    createPopup(self, ARC9:GetPhrase("customize.presets.paste"), ARC9:GetPhrase("customize.presets.import"), true, nil, function(bg, textentry)
        local txt = textentry:GetText()

        if txt == "" then textentry:SetPlaceholderText(ARC9:GetPhrase("customize.presets.dumb")) return end
        
        if self:LoadPresetFromCode(txt) then 
            bg:AlphaTo(0, 0.1, 0, function()
                bg:Remove()
            end)
            self:CreatePresetMenu(true)
        else
            textentry:SetText("")
            textentry:SetPlaceholderText(ARC9:GetPhrase("customize.presets.invalid"))
        end
    end)
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_trivia.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_trivia.lua:
local ARC9ScreenScale = ARC9.ScreenScale

function SWEP:CreateHUD_Trivia()
    local lowerpanel = self.CustomizeHUD.lowerpanel

    self:ClearTabPanel()

    local descbg = vgui.Create("DPanel", lowerpanel)
    descbg:SetPos(ARC9ScreenScale(4), ARC9ScreenScale(19))
    descbg:SetSize(lowerpanel:GetWide()-ARC9ScreenScale(4), ARC9ScreenScale(100))
    descbg.Paint = function(self2, w, h)
    end

    descbg:SetAlpha(0)
    descbg:AlphaTo(255, 0.2, 0, nil)

    self.BottomBar = descbg

    local desc = vgui.Create("ARC9ScrollPanel", descbg)
    desc:SetPos(0, 0)
    desc:SetSize(descbg:GetWide() * 0.75, descbg:GetTall())
    desc.Paint = function(self2, w, h)
        -- surface.SetDrawColor(144, 0, 0, 100)
        -- surface.DrawRect(0, 0, w, h)
    end

    local desctitle = desc:Add("DPanel")
    desctitle:SetSize(desc:GetWide(), ARC9ScreenScale(7))
    desctitle:Dock(TOP)
    desctitle.title = "customize.trivia.description"
    desctitle.Paint = function(self2, w, h)
        if !IsValid(self) then return end

        surface.SetFont("ARC9_7_Slim")
        surface.SetTextPos(ARC9ScreenScale(2), ARC9ScreenScale(0))
        surface.SetTextColor(ARC9.GetHUDColor("fg"))
        surface.DrawText(ARC9:GetPhrase(self2.title) or self2.title)
    end

    local descmultiline = {}
    descmultiline = ARC9MultiLineText(self.Description, desc:GetWide() - ARC9ScreenScale(1), "ARC9_8")
    for i, text in ipairs(descmultiline) do
        local desc_line = vgui.Create("DPanel", desc)
        desc_line:SetSize(desc:GetWide(), ARC9ScreenScale(8))
        desc_line:Dock(TOP)
        desc_line.Paint = function(self2, w, h)
            if !IsValid(self) then return end
				markup.Parse("<font=ARC9_8>" .. text):Draw(ARC9ScreenScale(2), 0, TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT)
            -- surface.SetFont("ARC9_8")
            -- surface.SetTextColor(ARC9.GetHUDColor("fg"))
            -- surface.SetTextPos(ARC9ScreenScale(2), 0)
            -- surface.DrawText(text)
        end
    end


    -- credits
    local creditsscroll = vgui.Create("ARC9ScrollPanel", descbg)
    creditsscroll:SetPos(0, desc:GetTall())
    creditsscroll:SetSize(descbg:GetWide() * 0.75, ARC9ScreenScale(17)) -- descbg:GetTall()
    creditsscroll.Paint = function(self2, w, h)
        -- surface.SetDrawColor(0, 144, 0, 100)
        -- surface.DrawRect(0, 0, w, h)
    end

    local creditssorted = {}
    for title, credit in pairs(self:GetValue("Credits")) do
        if title == "BaseClass" then continue end
        local credittbl = {}
        credittbl.credit = credit
        if tonumber(title[#title]) then
            credittbl.order = title[#title]
            credittbl.title = string.sub(title, 0, #title-1)
        else
            credittbl.order = 0
            credittbl.title = title
        end

        table.insert(creditssorted, credittbl)
    end

    for _, credittbl in SortedPairsByMemberValue(creditssorted, "order", false) do
        local creditline = creditsscroll:Add("DPanel")

        local desctall = math.max(descbg:GetTall()*0.45, desc:GetTall()-ARC9ScreenScale(17)) - ARC9ScreenScale(2)
        local creditstall = math.min(creditsscroll:GetTall()+ARC9ScreenScale(17), descbg:GetTall()*0.55)
        desc:SetTall(desctall)
        creditsscroll:SetTall(creditstall)
        creditsscroll:SetPos(0, desc:GetTall() + ARC9ScreenScale(2))

        creditline:SetSize(creditsscroll:GetWide(), ARC9ScreenScale(17))
        creditline:Dock(TOP)
        creditline.title = credittbl.title
        creditline.credit = credittbl.credit
        creditline.Paint = function(self2, w, h)
            if !IsValid(self) then return end

            local titlestring = string.Replace(self2.title, "_", " ") 

            surface.SetFont("ARC9_7_Slim")
            surface.SetTextPos(ARC9ScreenScale(2), 0)
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.DrawText(titlestring)

            local major = self2.credit

            surface.SetFont("ARC9_9")
            surface.SetTextPos(ARC9ScreenScale(2), ARC9ScreenScale(6))
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.DrawText(major)
            -- self:DrawTextRot(self2, major, 0, 0, math.max(ARC9ScreenScale(1), 0), ARC9ScreenScale(6), w, true)
        end
    end

    -- trivia
    local triviascroll = vgui.Create("ARC9ScrollPanel", descbg)
    triviascroll:SetPos(descbg:GetWide() * 0.76, 0)
    triviascroll:SetSize(descbg:GetWide() * 0.24 - ARC9ScreenScale(4), descbg:GetTall() + ARC9ScreenScale(8))
    triviascroll.Paint = function(self2, w, h)
        -- surface.SetDrawColor(0, 0, 144, 100)
        -- surface.DrawRect(0, 0, w, h)
    end

    local triviasorted = {}
    for title, trivia in pairs(self:GetValue("Trivia")) do
        if title == "BaseClass" then continue end
        local triviatbl = {}
        triviatbl.trivia = trivia
        if tonumber(title[#title]) then
            triviatbl.order = title[#title]
            triviatbl.title = string.sub(title, 0, #title-1)
        else
            triviatbl.order = 0
            triviatbl.title = title
        end

        table.insert(triviasorted, triviatbl)
    end

    for _, triviatbl in SortedPairsByMemberValue(triviasorted, "order", false) do
        local trivialine = triviascroll:Add("DPanel")
        trivialine:SetSize(triviascroll:GetWide(), ARC9ScreenScale(17))
        trivialine:Dock(TOP)
        trivialine.title = triviatbl.title
        trivialine.trivia = triviatbl.trivia
        trivialine.Paint = function(self2, w, h)
            if !IsValid(self) then return end
            
            local titlestring = string.Replace(self2.title, "_", " ") 

            surface.SetFont("ARC9_7_Slim")
            local tw = surface.GetTextSize(titlestring)
            surface.SetTextPos(w-tw-ARC9ScreenScale(2), 0)
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.DrawText(titlestring)

            local major = self2.trivia

            surface.SetFont("ARC9_9")
            local tw = surface.GetTextSize(major)
            surface.SetTextPos(w-tw-ARC9ScreenScale(3), ARC9ScreenScale(6))
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.DrawText(major)
            -- self:DrawTextRot(self2, major, 0, 0, math.max(ARC9ScreenScale(1), 0), ARC9ScreenScale(6), w, true)
        end
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_devtools.lua:
local DevMode = false

local devselectedatt = 0
local devoffsetmode = false
local selectedbonename = "None"

SWEP.devlockeddrag = false

function SWEP:DevStuffMenu()
    print("Developers developers developers developers developers developers developers developers developers developers developers developers developers ")

    local DevFrame = vgui.Create("DFrame")
    DevFrame:SetPos(ScrW() - 1015, ScrH() - 315)
    DevFrame:SetSize(1000, 300)
    DevFrame:SetTitle("Dev stuff")
    DevFrame:SetVisible(true)
    DevFrame:SetDraggable(true)
    DevFrame:ShowCloseButton(true)
    DevFrame:MakePopup()

    self.DevFrame = DevFrame

    local LockDragToggle = DevFrame:Add("DCheckBoxLabel")
    LockDragToggle:SetPos(400, 273)
    LockDragToggle:SetText("Lock dragging")
    LockDragToggle.OnChange = function(non, val)
        self.devlockeddrag = val
    end


    local function makecoolslider(y, min, max, text, dec, func)
        local itis = vgui.Create("DNumSlider", DevFrame)
        itis:SetPos(10, y)
        itis:SetSize(1000, 50)
        itis:SetText(text)
        itis:SetMin(min)
        itis:SetMax(max)
        itis:SetDecimals(dec)

        itis.OnValueChanged = func

        return itis
    end

    local SliderX = makecoolslider(30, -25, 25, "X", 3, function(no, value) self:PostModify(true) if devoffsetmode then devselectedatt.Icon_Offset.x = value else devselectedatt.Pos.x = value end end)
    local SliderY = makecoolslider(60, -25, 25, "Y", 3, function(no, value) self:PostModify(true) if devoffsetmode then devselectedatt.Icon_Offset.y = value else devselectedatt.Pos.y = value end end)
    local SliderZ = makecoolslider(90, -25, 25, "Z", 3, function(no, value) self:PostModify(true) if devoffsetmode then devselectedatt.Icon_Offset.z = value else devselectedatt.Pos.z = value end end)

    local SliderPitch = makecoolslider(130, -180, 180, "P", 0, function(no, value) self:PostModify(true) devselectedatt.Ang.p = value end)
    local SliderYaw = makecoolslider(160, -180, 180, "Y", 0, function(no, value) self:PostModify(true) devselectedatt.Ang.y = value end)
    local SliderRoll = makecoolslider(190, -180, 180, "R", 0, function(no, value) self:PostModify(true) devselectedatt.Ang.r = value end)

    local OffsetModeToggle = DevFrame:Add("DCheckBoxLabel")
    OffsetModeToggle:SetPos(200, 273)
    OffsetModeToggle:SetText("Icon offset mode")
    OffsetModeToggle.OnChange = function(non, val)
        devoffsetmode = val

        if val then
            if !devselectedatt.Icon_Offset then devselectedatt.Icon_Offset = Vector() end

            SliderX:SetValue(devselectedatt.Icon_Offset.x)
            SliderY:SetValue(devselectedatt.Icon_Offset.y)
            SliderZ:SetValue(devselectedatt.Icon_Offset.z)
        else
            SliderX:SetValue(devselectedatt.Pos.x)
            SliderY:SetValue(devselectedatt.Pos.y)
            SliderZ:SetValue(devselectedatt.Pos.z)
        end
    end

    local AttSelector = vgui.Create("DComboBox", DevFrame)
    AttSelector:SetPos(15, 300-30)
    AttSelector:SetSize(150, 20)
    AttSelector:SetValue("Select att")
    for i, slot in ipairs(self:GetSubSlotList()) do
        AttSelector:AddChoice(i .. " - " .. slot .PrintName)
    end

    AttSelector.OnSelect = function(no, index, value)
        print(value .. " was selected")
        devselectedatt = self:GetSubSlotList()[tonumber(value[1] .. value[2])]

        if devoffsetmode then
            SliderX:SetValue(devselectedatt.Icon_Offset.x)
            SliderY:SetValue(devselectedatt.Icon_Offset.y)
            SliderZ:SetValue(devselectedatt.Icon_Offset.z)

            SliderX:SetMin(devselectedatt.Icon_Offset.x-5)
            SliderX:SetMax(devselectedatt.Icon_Offset.x+5)
            SliderY:SetMin(devselectedatt.Icon_Offset.y-5)
            SliderY:SetMax(devselectedatt.Icon_Offset.y+5)
            SliderZ:SetMin(devselectedatt.Icon_Offset.z-5)
            SliderZ:SetMax(devselectedatt.Icon_Offset.z+5)
        else
            SliderX:SetValue(devselectedatt.Pos.x)
            SliderY:SetValue(devselectedatt.Pos.y)
            SliderZ:SetValue(devselectedatt.Pos.z)

            SliderX:SetMin(devselectedatt.Pos.x-3)
            SliderX:SetMax(devselectedatt.Pos.x+3)
            SliderY:SetMin(devselectedatt.Pos.y-10)
            SliderY:SetMax(devselectedatt.Pos.y+10)
            SliderZ:SetMin(devselectedatt.Pos.z-8)
            SliderZ:SetMax(devselectedatt.Pos.z+8)
        end

        SliderPitch:SetValue(devselectedatt.Ang.p)
        SliderYaw:SetValue(devselectedatt.Ang.y)
        SliderRoll:SetValue(devselectedatt.Ang.r)
    end

    local function ExportAtt()
        if !devselectedatt.Icon_Offset then devselectedatt.Icon_Offset = Vector() end
        return string.format("Pos = Vector(%s, %s, %s),\nAng = Angle(%s, %s, %s),\nIcon_Offset = Vector(%s, %s, %s),", math.Round(devselectedatt.Pos.x, 3), math.Round(devselectedatt.Pos.y, 3), math.Round(devselectedatt.Pos.z, 3), math.Round(devselectedatt.Ang.p), math.Round(devselectedatt.Ang.y), math.Round(devselectedatt.Ang.r), math.Round(devselectedatt.Icon_Offset.x, 3), math.Round(devselectedatt.Icon_Offset.y, 3), math.Round(devselectedatt.Icon_Offset.z, 3))
    end

    local ConsoleButton = vgui.Create("DButton", DevFrame)
    ConsoleButton:SetText("To console")
    ConsoleButton:SetPos(640, 260)
    ConsoleButton:SetSize(100, 30)
    ConsoleButton.DoClick = function()
        print("---------\n\n")
        print(ExportAtt())
        print("\n\n---------")
    end

    local ClipboardButton = vgui.Create("DButton", DevFrame)
    ClipboardButton:SetText("To clipboard")
    ClipboardButton:SetPos(760, 260)
    ClipboardButton:SetSize(100, 30)
    ClipboardButton.DoClick = function()
        SetClipboardText(ExportAtt())
    end

    local ResetButton = vgui.Create("DButton", DevFrame)
    ResetButton:SetText("Reload atts")
    ResetButton:SetPos(880, 260)
    ResetButton:SetSize(100, 30)
    ResetButton.DoClick = function()
        RunConsoleCommand("arc9_reloadatts")
        timer.Simple(0, function() self:PostModify(true) end)
    end


    -- local AppList = vgui.Create("DListView", DevFrame)
    -- AppList:Dock(FILL)
    -- AppList:SetMultiSelect(false)
    -- AppList:AddColumn("Bone")

    -- local vm = self:GetVM()
    -- if !vm then return end

    -- for i = 0, (vm:GetBoneCount() - 1) do
    --     AppList:AddLine(vm:GetBoneName(i))
    -- end

    -- AppList.OnRowSelected = function(lst, index, pnl)
    --     print("Selected " .. pnl:GetColumnText(1) .. " at index " .. index)
    --     selectedbone = index
    --     selectedbonename = pnl:GetColumnText(1)
    -- end
end

local devplaybackmult = 1
local devplaybackcycle = 0

function SWEP:DevStuffAnims()
    local DevFrame = vgui.Create("DFrame")
    DevFrame:SetPos(ScrW()/2-(ScrW()-200)/2, 50)
    DevFrame:SetSize(ScrW()-200, 300)
    DevFrame:SetTitle("ARC9 Animation table editor - works only in singleplayer in pause menu")
    DevFrame:SetVisible(true)
    DevFrame:SetDraggable(true)
    DevFrame:ShowCloseButton(true)
    DevFrame:MakePopup()


    ----


    local Controls = DevFrame:Add("Panel")
    Controls:SetTall(20)
    Controls:Dock(BOTTOM)
    Controls:DockMargin(0, 8, 0, 4)
    Controls:MoveToBack()

    local AnimTrack = Controls:Add("DSlider")
    AnimTrack:Dock(FILL)
    AnimTrack:SetNotches(100)
    AnimTrack:SetTrapInside(true)
    AnimTrack:SetLockY(0.5)

    local SeqSelector = Controls:Add("DComboBox")
    SeqSelector:SetValue( "VM sequence" )
    SeqSelector:Dock(LEFT)
    SeqSelector:SetWide(128)

    SeqSelector.OnSelect = function(_, _, value)
        print("------\nHi you need to double press (with a little delay) escape key to apply anim")
        self:GetVM():SendViewModelMatchingSequence(self:GetVM():LookupSequence(value))
    end

    for k, v in ipairs(self:GetVM():GetSequenceList()) do
        SeqSelector:AddChoice(v)

        if v == self:GetVM():GetSequenceName(self:GetVM():GetSequence()) then
            SeqSelector:ChooseOptionID(k)
        end
    end

    local AnimPlay = Controls:Add("DImageButton")
    AnimPlay:SetImage("icon16/control_pause_blue.png")
    AnimPlay:SetStretchToFit(false)
    AnimPlay:SetPaintBackground(true)
    AnimPlay:SetIsToggle(true)
    AnimPlay:SetToggle(false)
    AnimPlay:Dock(LEFT)
    AnimPlay:SetWide(32)

    local PlaybackSpeedMultEntry = Controls:Add("DTextEntry")
    PlaybackSpeedMultEntry:SetPaintBackground(true)
    PlaybackSpeedMultEntry:Dock(RIGHT)
    PlaybackSpeedMultEntry:SetWide(64)
    PlaybackSpeedMultEntry:SetPlaceholderText("Speed mult")
    PlaybackSpeedMultEntry:SetNumeric(true)
    PlaybackSpeedMultEntry.OnEnter = function(no)
        devplaybackmult = no:GetValue()
    end

    local CurFrame = Controls:Add("DLabel")
    CurFrame:Dock(LEFT)
    CurFrame:SetWide(64)
    CurFrame:SetText("  " .. 0)


    ----

    local Animations = DevFrame:Add("Panel")
    Animations:SetTall(20)
    Animations:Dock(TOP)
    Animations:DockMargin(ScrW()/2.5, 0, ScrW()/2.5, 4)
    Animations:MoveToBack()

    local AnimSelector = Animations:Add("DComboBox")
    AnimSelector:SetValue("Select animation")
    AnimSelector:Dock(FILL)


    for k, v in pairs(self.Animations) do
        AnimSelector:AddChoice(k)
        AnimSelector:ChooseOptionID(1)
    end

    local AddAnimButton = Animations:Add("DImageButton")
    AddAnimButton:SetImage( "icon16/add.png" )
    AddAnimButton:SetSize( 20, 20 )
    AddAnimButton:Dock(RIGHT)
    AddAnimButton.DoClick = function()
        Derma_StringRequest("New animation", "What would you call it?", "", function(text) print("Added new anim to table: " .. text) end, nil, "Add")
    end


    ----

    local EditorPanel = DevFrame:Add("DPropertySheet")
    EditorPanel:Dock(FILL)

    EditorPanelEventTable = EditorPanel:Add("DPanel")
    -- EditorPanelEventTable.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 128, 255 ) ) end

    local Keyframes = EditorPanelEventTable:Add("DHorizontalScroller")
    Keyframes:Dock( FILL )
    Keyframes:SetOverlap( -8 )

    local KeyframesCount = 0

    local function makekf(time, path, pitch, volume)
        KeyframesCount = KeyframesCount + 1

        Keyframes[KeyframesCount] = Keyframes:Add("DFrame") -- dpanel maybe
        Keyframes[KeyframesCount]:SetDraggable(false)
        Keyframes[KeyframesCount]:ShowCloseButton(false)
        Keyframes[KeyframesCount]:SetWidth(128)

        Keyframes[KeyframesCount].TimeLabel = Keyframes[KeyframesCount]:Add("DLabel")
        Keyframes[KeyframesCount].TimeLabel:SetPos( 15, 25 )
        Keyframes[KeyframesCount].TimeLabel:SetText("Time")

        Keyframes[KeyframesCount].Time = Keyframes[KeyframesCount]:Add("DTextEntry")
        Keyframes[KeyframesCount].Time:SetPos(55, 25)
        Keyframes[KeyframesCount].Time:SetPlaceholderText("Time")
        Keyframes[KeyframesCount].Time:SetNumeric(true)
        Keyframes[KeyframesCount].Time:SetValue(time)

        Keyframes[KeyframesCount].SndLabel = Keyframes[KeyframesCount]:Add("DLabel")
        Keyframes[KeyframesCount].SndLabel:SetPos(15, 45)
        Keyframes[KeyframesCount].SndLabel:SetText("Sound path")

        Keyframes[KeyframesCount].Snd = Keyframes[KeyframesCount]:Add("DTextEntry")
        Keyframes[KeyframesCount].Snd:SetPos(4, 65)
        Keyframes[KeyframesCount].Snd:SetWidth(120)
        Keyframes[KeyframesCount].Snd:SetPlaceholderText("garrysmod/content_downloaded.wav")
        Keyframes[KeyframesCount].Snd:SetText(path)

        Keyframes[KeyframesCount].PitchWangLabel = Keyframes[KeyframesCount]:Add("DLabel")
        Keyframes[KeyframesCount].PitchWangLabel:SetPos( 15, 95 )
        Keyframes[KeyframesCount].PitchWangLabel:SetText("Pitch")

        Keyframes[KeyframesCount].PitchWang = Keyframes[KeyframesCount]:Add("DNumberWang")
        Keyframes[KeyframesCount].PitchWang:SetPos(55, 95)
        Keyframes[KeyframesCount].PitchWang:SetMin(0.5)
        Keyframes[KeyframesCount].PitchWang:SetValue(pitch)
        Keyframes[KeyframesCount].PitchWang:SetMax(1.5)
        Keyframes[KeyframesCount].PitchWang:SetInterval(0.05)

        Keyframes[KeyframesCount].VolumeWangLabel = Keyframes[KeyframesCount]:Add("DLabel")
        Keyframes[KeyframesCount].VolumeWangLabel:SetPos( 15, 120 )
        Keyframes[KeyframesCount].VolumeWangLabel:SetText("Volume")

        Keyframes[KeyframesCount].VolumeWang = Keyframes[KeyframesCount]:Add("DNumberWang")
        Keyframes[KeyframesCount].VolumeWang:SetPos(55, 120)
        Keyframes[KeyframesCount].VolumeWang:SetMin(0)
        Keyframes[KeyframesCount].VolumeWang:SetValue(volume)
        Keyframes[KeyframesCount].VolumeWang:SetMax(2)
        Keyframes[KeyframesCount].VolumeWang:SetInterval(0.05)

        Keyframes[KeyframesCount].DeleteButton = Keyframes[KeyframesCount]:Add("DButton")
        Keyframes[KeyframesCount].DeleteButton:SetText("Delete")
        Keyframes[KeyframesCount].DeleteButton:SetHeight(16)
        Keyframes[KeyframesCount].DeleteButton:Dock(BOTTOM)

        local nameexloded = string.Explode("/", path)

        Keyframes[KeyframesCount]:SetTitle(nameexloded[#nameexloded]) -- KeyframesCount .. ": " ..

        Keyframes:AddPanel(Keyframes[KeyframesCount])
    end

    -- makekf(0.1, "wawa/hi.wav", 1, 1)

    local function makekfsforanim(animname)
        Keyframes:Remove()
        Keyframes = EditorPanelEventTable:Add("DHorizontalScroller") -- resetting
        Keyframes:Dock( FILL )
        Keyframes:SetOverlap( -8 )

        local et = self.Animations[animname].EventTable

        if et then -- we will clear and just add a plus button if no eventtable
            for k, v in ipairs(et) do
                makekf(v.t, v.s, v.p or 1, v.v or 1)
            end
        end

        Keyframes.KeyframesAdd = Keyframes:Add("DButton")
        Keyframes.KeyframesAdd:SetText("+")
        Keyframes.KeyframesAdd:SetWidth(64)
        Keyframes:AddPanel(Keyframes.KeyframesAdd)
    end

    AnimSelector.OnSelect = function(_, _, value)
        print("------\nSelected "..value)
        makekfsforanim(value)
    end


    EditorPanel:AddSheet( "Event Table editor", EditorPanelEventTable)

    EditorPanelIKTable = EditorPanel:Add("DPanel")
    -- EditorPanelEventTable.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 128, 255 ) ) end
    EditorPanel:AddSheet( "LHIK/RHIK editor", EditorPanelIKTable)

    EditorPanelGeneral = EditorPanel:Add("DPanel")
    -- EditorPanelEventTable.Paint = function( self, w, h ) draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 128, 255 ) ) end
    EditorPanel:AddSheet( "Parameters", EditorPanelGeneral)

    Controls.Think = function(no)
        local vm = self:GetVM()
        local length = vm:SequenceDuration(vm:GetSequence()) * devplaybackmult

        if AnimTrack:GetDragging() then
            devplaybackcycle = AnimTrack:GetSlideX()
            AnimPlay:SetToggle(false)
        elseif AnimPlay:GetToggle() then
            devplaybackcycle = RealTime()/length%1
        end

        vm:SetCycle(devplaybackcycle)
        AnimTrack:SetSlideX(devplaybackcycle)

        local cursec = math.Round(length*devplaybackcycle/devplaybackmult, 2)
        local curfrac = math.Round(devplaybackcycle, 2)
        CurFrame:SetText("   " .. cursec .. " / ".. curfrac)
    end
end

concommand.Add("arc9_dev_togglemenu", function(ply, cmd, args)

    -- add here check for sv_cheats 1 or/and admin

    local wep = ply:GetActiveWeapon()

    if wep.ARC9 then
        DevMode = !DevMode
        if DevMode then ply:GetActiveWeapon():DevStuffMenu() elseif IsValid(wep.DevFrame) then wep.DevFrame:Close() end
    end
end)

concommand.Add("arc9_dev_toggleanimsmenu", function(ply, cmd, args)

    -- add here check for sv_cheats 1 or/and admin

    local wep = ply:GetActiveWeapon()

    if wep.ARC9 then
        -- DevMode = !DevMode
        ply:GetActiveWeapon():DevStuffAnims()
    end
end)

local gaA = 0
local function GetFOVAcc(deg)
    cam.Start3D()
    local lool = (EyePos() + EyeAngles():Forward() + (deg * EyeAngles():Up())):ToScreen()
    cam.End3D()
    local gau = (ScrH() / 2) - lool.y
    gaA = math.Approach(gaA, gau, (ScrH() / 2) * FrameTime() * 2)

    return gaA
end

local gaA2 = 0
local function GetFOVAcc2(deg)
    cam.Start3D()
    local lool = (EyePos() + EyeAngles():Forward() + (deg * EyeAngles():Up())):ToScreen()
    cam.End3D()
    local gau = (ScrH() / 2) - lool.y
    gaA2 = math.Approach(gaA2, gau, (ScrH() / 2) * FrameTime() * 2)

    return gaA2
end

surface.CreateFont( "ARC9_DevCrosshair", {
    font = ARC9:GetFont(),
    size = 32,
    weight = 0,
    antialias = true,
    extended = true, -- Required for non-latin fonts
} )

function SWEP:DevStuffCrosshair()
    if self:GetCustomize() then return end
    local time = CurTime()

    local owner = self:GetOwner()
    local x2, y2 = ScrW() / 2, ScrH() / 2

    local sp, sa = self:GetShootPos()
    local endpos = sp + (sa:Forward() * 4000)

    cam.Start3D()
    local toscreen = endpos:ToScreen()
    if EyePos():DistToSqr(owner:EyePos()) > 16 then
        local tr = util.TraceLine({
            start = sp,
            endpos = endpos,
            mask = MASK_SHOT,
            filter = owner
        })

        toscreen = tr.HitPos:ToScreen()
    end
    x, y = toscreen.x, toscreen.y
    cam.End3D()

    local tr_range = util.TraceLine({
        start = sp,
        endpos = sp + sa:Forward() * 50000,
        mask = MASK_SHOT,
        filter = owner
    })
    local dist = (tr_range.HitPos - sp):Length()

    local freeaim_val = GetConVar("arc9_mod_freeaim"):GetBool() and self:GetProcessedValue("FreeAimRadius") or 0
    -- local freeaim = ScreenScale(freeaim_val * math.pi * 1.4)
    -- surface.DrawCircle(x2, y2, freeaim, 255, 255, 0, 100)

    if freeaim_val > 0 then
        local len = Lerp(freeaim_val / 4, 0, 16)
        surface.SetDrawColor(255, 255, 0, 255)
        surface.DrawLine(x2, y2 - len, x2, y2 + len)
        surface.DrawLine(x2 - len, y2, x2 + len, y2)

        surface.SetDrawColor(255, 255, 255, 100)
        surface.DrawLine(x, y, x2, y2)
    end

    local len = 256
    surface.SetDrawColor(255, 50, 50, 200)
    surface.DrawLine(x, y - len + 24, x, y + len - 48)
    surface.DrawLine(x - len, y, x + len, y)

    local spread_val = math.max(0, self:GetProcessedValue("Spread"))
    local spread = GetFOVAcc(spread_val)
    surface.DrawCircle(x, y, spread, 255, 255, 255, 255)
    surface.DrawCircle(x, y, spread + 0.5, 255, 255, 255, 100)

    local range_txt = math.Round(dist * ARC9.HUToM, 1) .. "m"
    local range2_txt = math.Round(self:GetDamageDeltaAtRange(dist) * 100) .. "%"
    if self:GetProcessedValue("SweetSpot", true) then
        range2_txt = range2_txt .. " | " .. math.Round(self:GetSweetSpotDeltaAtRange(dist) * 100) .. "% (SweetSpot)"
    end
	
    local aa_txt = "AIM ASSIST (%s%% INTENSITY)"
    -- local aa_txt = "AIM ASSIST (%.2f)"
	local aa_text = string.format(aa_txt, math.Clamp( math.Round(100 - self:GetDamageDeltaAtRange(dist) * 200), 1, 100))
	
	local function animationtype()
		local text = "ANIMATION"
		local function animname(anim)
			return string.find(self:GetIKAnimation() or "", anim)
		end

		if animname("reload") then text = "RELOAD" end
		if animname("dryfire") then text = "DRYFIRE" end

		return text
	end

    local state_txt = "READY"
    local state2_txt = ""
    if self:GetHolsterTime() > 0 then
        state_txt = "HOLSTER"
        state2_txt = string.format("%dms", (self:GetHolsterTime() - time)*1000)
    elseif self:GetNextPrimaryFire() > time then
        state_txt = "FIRE"
        state2_txt = string.format("%.0fms", (self:GetNextPrimaryFire() - time)*1000)
    elseif self:GetNextSecondaryFire() > time then
        state_txt = "ALTFIRE"
        state2_txt = string.format("%dms", (self:GetNextSecondaryFire() - time)*1000)
    elseif self:GetPrimedAttack() then
        state_txt = "TRIGGER"
        state2_txt = string.format("%dms", math.max(0, self:GetTriggerDelay() - time)*1000)
    elseif self:GetAnimLockTime() > time then
        state_txt = animationtype()
        state2_txt = string.format("%dms", (self:GetAnimLockTime() - time)*1000)
    elseif self:GetNeedsCycle() then
        state_txt = "CYCLING"
        if self:GetCycleFinishTime() == 0 then
            state2_txt = "waiting..."
        else
            state2_txt = string.format("%dms", (self:GetCycleFinishTime() - time)*1000)
        end
    elseif self:GetSprintAmount() > 0 then
        state_txt = "SPRINT"
        state2_txt = string.format("%d%%", self:GetSprintAmount() * 100)
    elseif self:GetSightAmount() > 0 then
        state_txt = "SIGHT"
        state2_txt = string.format("%d%%", self:GetSightAmount() * 100)
    elseif self:GetGrenadePrimed() then
        state_txt = "PRIMED"
        local pt = time - self:GetGrenadePrimedTime()
        state2_txt = string.format("%.2f | %d%%", self:GetProcessedValue("FuseTimer") - pt, math.Clamp(pt / self:GetProcessedValue("ThrowChargeTime"), 0, 1) * 100)
    end

    local recoil_txt = "Recoil: " .. tostring(math.Round(math.min(self:GetProcessedValue("UseVisualRecoil") and math.huge or self:GetProcessedValue("RecoilModifierCap"), self:GetRecoilAmount()), 2))
    local spread_txt = "Cone: " .. math.Round(spread_val, 5)
    local sway_txt = string.format("%.2f", self:GetFreeSwayAmount()) .. " Sway"
    local num = math.floor(self:GetProcessedValue("Num"))
    local damage_txt = math.Round(self:GetDamageAtRange(dist)) .. (num > 1 and ("×" .. tostring(num)) or "") .. " DMG"

	local function activeaffectors()
	-- Which stat additives are currently active, for example "Moving", "Airborne", "Sight", etc.
		local text = ""
		local ENTITY = FindMetaTable("Entity")
		local PLAYER = FindMetaTable("Player")
		local playerCrouching = PLAYER.Crouching
		local playerGetWalkSpeed = PLAYER.GetWalkSpeed
		local playerSprinting = PLAYER.IsSprinting
		local entityOwner = ENTITY.GetOwner
		local entityOnGround = ENTITY.OnGround
		local entityIsValid = ENTITY.IsValid
		local entityGetMoveType = ENTITY.GetMoveType
		local entityIsPlayer = ENTITY.IsPlayer
		local entityGetAbsVelocity = ENTITY.GetAbsVelocity
		local WEAPON = FindMetaTable("Weapon")
		local weaponClip1 = WEAPON.Clip1
		local weaponClip2 = WEAPON.Clip2
		local weaponGetNextPrimaryFire = WEAPON.GetNextPrimaryFire
		local arcGetValue = self.GetValue
		local vectorLength = FindMetaTable("Vector").Length
        local ubgl = self.dt.UBGL
		local sightAmount = self.dt.SightAmount

		if not ownerIsNPC and entityIsValid(owner) then
            local ownerOnGround = entityOnGround(owner)

            if not ownerOnGround or entityGetMoveType(owner) == MOVETYPE_NOCLIP then
				text = text .. " MidAir"
            end

            if ownerOnGround and playerCrouching(owner) then
				text = text .. " Crouch"
            end
			
			if ownerOnGround and playerSprinting(owner) and !self:StillWaiting() then
				text = text .. " Sprint"
			end
        end
			
        if self.dt.Reloading then
			text = text .. " Reload"
        end

        if self.dt.BurstCount == 0 then
			text = text .. " FirstShot"
        end

        if self.dt.GrenadeTossing then
			text = text .. " Toss"
        end

        if weaponClip1(self) == 0 then
			text = text .. " Empty"
        end

        if not ubgl and arcGetValue(self, "Silencer") then
			text = text .. " Silenced"
        end

        if ubgl then
			text = text .. " UBGL"

            if weaponClip2(self) == 0 then
				text = text .. " EmptyUBGL"
            end
        end
		
        if self.dt.NthShot % 2 == 0 then
			text = text .. " EvenShot"
        else
			text = text .. " OddShot"
        end

        if self.dt.NthReload % 2 == 0 then
			text = text .. " EvenReload"
        else
			text = text .. " OddReload"
        end

        if self.dt.Bipod then
			text = text .. " Bipod"
        end

		if sightAmount >= 1 then
			text = text .. " Sights"
		else
			text = text .. " HipFire"
		end

		local getlastmeleetime = self.dt.LastMeleeTime
		if getlastmeleetime < CurTime() then
			local pft = CurTime() - getlastmeleetime
			local d = pft / (arcGetValue(self, "PreBashTime") + arcGetValue(self, "PostBashTime"))
			d = 1 - math.Clamp(d, 0, 1)
			
			if d > 0 then
				text = text .. " Melee"
			end
		end
		
		
		local spd = self.PV_Move
		local maxspd = entityIsPlayer(owner) and playerGetWalkSpeed(owner) or 250
		
		spd = math.min(vectorLength(entityGetAbsVelocity(owner)), maxspd) / maxspd
		self.PV_Move = spd
		
		if spd > 0 then
			text = text .. " Move"
		end
		
		return text
	end
	
    surface.SetFont("ARC9_DevCrosshair")
    local sway_w = surface.GetTextSize(sway_txt)
    local damage_w = surface.GetTextSize(damage_txt)
    local state_w = surface.GetTextSize(state_txt)
    local state2_w = surface.GetTextSize(state2_txt)
    local range_w = surface.GetTextSize(range_txt)
    local range2_w = surface.GetTextSize(range2_txt)
    local aa_w = surface.GetTextSize(aa_txt)

	local affectortext = "Active Affectors:" .. activeaffectors()
	local affectorcon = GetConVar("arc9_dev_show_affectors"):GetBool()

    surface.SetTextColor(0, 0, 0, 255)

    surface.SetTextPos(x - len + 2, y + 2)
    surface.DrawText(recoil_txt)
    surface.SetTextPos(x - len + 2, y - 34 + 2)
    surface.DrawText(spread_txt)
    surface.SetTextPos(x + len - sway_w + 2, y - 34 + 2)
    surface.DrawText(sway_txt)
    surface.SetTextPos(x + len - damage_w + 2, y + 2)
    surface.DrawText(damage_txt)
    surface.SetTextPos(x - state_w / 2 + 2, y + len - 40 + 2)
    surface.DrawText(state_txt)
    surface.SetTextPos(x - state2_w / 2 + 2, y + len - 8 + 2)
    surface.DrawText(state2_txt)
    surface.SetTextPos(x - range_w / 2 + 2, y - len - 40 + 2)
    surface.DrawText(range_txt)
    surface.SetTextPos(x - range2_w / 2 + 2, y - len - 12 + 2)
    surface.DrawText(range2_txt)
    surface.SetTextPos(x - aa_w / 2 + 2, y - len - 62 + 2)
	if owner.ARC9_AATarget != nil and GetConVar("arc9_crosshair_target"):GetBool() then
		surface.DrawText(aa_text)
	end
	
    surface.SetTextPos(x + 5, y - 240)
	if affectorcon then
		surface.DrawText(affectortext)
	end
	
    surface.SetTextColor(255, 255, 255, 255)

    surface.SetTextPos(x - len, y)
    surface.DrawText(recoil_txt)
    surface.SetTextPos(x - len, y - 34)
    surface.DrawText(spread_txt)
    surface.SetTextPos(x + len - sway_w, y - 34)
    surface.DrawText(sway_txt)
    surface.SetTextPos(x + len - damage_w, y)
    surface.DrawText(damage_txt)
    surface.SetTextPos(x - state_w / 2, y + len - 40)
    surface.DrawText(state_txt)
    surface.SetTextPos(x - state2_w / 2, y + len - 8)
    surface.DrawText(state2_txt)
    surface.SetTextPos(x - range_w / 2, y - len - 40)
    surface.DrawText(range_txt)
    surface.SetTextPos(x - range2_w / 2, y - len - 12)
    surface.DrawText(range2_txt)
    surface.SetTextPos(x - range2_w / 2, y - len - 12)
    surface.DrawText(range2_txt)
    surface.SetTextPos(x - aa_w / 2, y - len - 62)
	if owner.ARC9_AATarget != nil and GetConVar("arc9_crosshair_target"):GetBool() then
		surface.DrawText(aa_text)
	end

    surface.SetTextPos(x + 5 - 2, y - 240 - 2)
	if affectorcon then
		surface.DrawText(affectortext)
	end
	
    surface.SetTextPos(x + 5, y - 240 + 40 + 2)
    surface.SetTextColor(0, 0, 0, 255)
	surface.DrawText( "Mouse Sens: " .. string.format("%d%%", self:AdjustMouseSensitivity() * 100 ))
	
    surface.SetTextPos(x + 5 - 2, y - 240 + 40)
    surface.SetTextColor(255, 255, 255, 255)
	surface.DrawText( "Mouse Sens: " .. string.format("%d%%", self:AdjustMouseSensitivity() * 100 ))
	
    local sgspread_txt = ""
    if self:GetProcessedValue("UseDispersion") then
        local sgspread_val = math.max(0, self:GetProcessedValue("DispersionSpread"))
        local sgspread = GetFOVAcc2(sgspread_val)
        surface.DrawCircle(x, y, sgspread, 255, 255, 0, 255)
        surface.DrawCircle(x, y, sgspread + 0.5, 255, 255, 0, 100)
        
        sgspread_txt = self:GetProcessedValue("UseDispersion") and "SG Cone: " .. math.Round(sgspread_val, 5) or ""
    
        surface.SetTextColor(0, 0, 0, 255)
        surface.SetTextPos(x - len + 2, y - 64 + 2)
        surface.DrawText(sgspread_txt)
        surface.SetTextColor(255, 255, 255, 255)
        surface.SetTextPos(x - len, y - 64)
        surface.DrawText(sgspread_txt)
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_holosight.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_pipscope.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_elements.lua:
SWEP.ElementsCache = {}

function SWEP:GetElements(exclude)
    if !exclude and self.ElementsCache then
        local eles = self.ElementsCache

        if !ARC9.ModifyElementsOverrun then
            ARC9.ModifyElementsOverrun = true
            eles = self:RunHook("Hook_ModifyElements", eles) or eles
            ARC9.ModifyElementsOverrun = false
        end

        return eles
    end

    local eles = {}

    for _, slottbl in ipairs(self:GetSubSlotList()) do
        if exclude and exclude[slottbl.Address] then continue end
        if slottbl.Installed then
            table.Add(eles, slottbl.InstalledElements or {})
            table.insert(eles, slottbl.Installed)
        else
            table.Add(eles, slottbl.UnInstalledElements or {})
        end
    end

    table.Add(eles, self.DefaultElements or {})

    if !ARC9.Overrun then
        ARC9.Overrun = true

        for _, affector in ipairs(self:GetAllAffectors()) do
            table.Add(eles, affector.ActivateElements or {})

            local cat = affector.Category
            if !istable(cat) then
                cat = {cat}
            end

            table.Add(eles, cat)
        end

        ARC9.Overrun = false
    end

    local eles2 = {}

    for _, ele in pairs(eles) do
        eles2[ele] = true
    end

    if !exclude then
        self.ElementsCache = eles2
    end

    if !ARC9.ModifyElementsOverrun then
        ARC9.ModifyElementsOverrun = true
        eles2 = self:RunHook("Hook_ModifyElements", eles2) or eles2
        ARC9.ModifyElementsOverrun = false
    end

    return eles2
end

function SWEP:HasElement(ele)
    if !self.ElementsCache then self:GetElements() end
    return self.ElementsCache[ele] == true
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_init.lua:

function SWEP:OnReloaded()
    self:InvalidateCache()
end

local arc9_precache_sounds_onfirsttake = GetConVar("arc9_precache_sounds_onfirsttake")
local arc9_precache_wepmodels_onfirsttake = GetConVar("arc9_precache_wepmodels_onfirsttake")
local arc9_precache_attsmodels_onfirsttake = GetConVar("arc9_precache_attsmodels_onfirsttake")

function SWEP:Initialize()
    local owner = self:GetOwner()

    self.HoldTypeDefault = self.HoldType

    self:SetShouldHoldType()

    if owner:IsNPC() then
        self:PostModify()
        self:NPC_Initialize()
        return
    end


    self:SetLastMeleeTime(0)
    self:SetNthShot(0)

    self.SpawnTime = CurTime()
    self:SetSpawnEffect(false) -- lol gmod suck
    -- self:BuildAttachmentAddresses()

    self:InitTimers()

    self:ClientInitialize()

    -- local base = baseclass.Get(self:GetClass())

    -- PrintTable(base.Attachments)

    self.DefaultAttachments = table.Copy(self.Attachments)

    self:BuildSubAttachments(self.DefaultAttachments)

    if !IsValid(owner) then -- player is nil here sometimes
        self:PostModify()
    end

    self.LastClipSize = self:GetProcessedValue("ClipSize")
    self.Primary.Ammo = self:GetProcessedValue("Ammo")
    self.LastAmmo = self.Primary.Ammo

    local bottomless = self:GetProcessedValue("BottomlessClip", true)
    local clip = bottomless and self:GetProcessedValue("AmmoPerShot") or self.LastClipSize
    self.Primary.DefaultClip = self.ForceDefaultClip or (clip + (bottomless and 0 or (self:GetProcessedValue("ChamberSize") or 0)))
    -- self.Primary.DefaultClip = clip * math.max(1, self:GetProcessedValue("SupplyLimit") + (bottomless and 0 or 1))

    if self.Primary.DefaultClip == 1 then -- This specific value seems to be hard-coded to not give any ammo?
        self:SetClip1(1)
        self.Primary.DefaultClip = 0
    end

    if self:GetValue("UBGL") then
        self.Secondary.Ammo = self:GetValue("UBGLAmmo")
        self.Secondary.DefaultClip = self:GetValue("UBGLClipSize") * math.max(1, self:GetValue("SecondarySupplyLimit") + 1)
    end

    self:SetClip1(self.ClipSize > 0 and math.max(1, self.Primary.DefaultClip) or self.Primary.DefaultClip)
    self:SetClip2(self.Secondary.DefaultClip)

    self:SetLastLoadedRounds(self.LastClipSize)
    
    timer.Simple(0.4, function()
        if IsValid(self) then
            if self:LookupPoseParameter("sights") != -1 then self.HasSightsPoseparam = true end
            if self:LookupPoseParameter("firemode") != -1 then self.HasFiremodePoseparam = true end
            if SERVER then self:InitialDefaultClip() end
        end
    end)

    if arc9_precache_sounds_onfirsttake:GetBool() then
        ARC9.CacheWepSounds(self, self:GetClass())
    end

    if arc9_precache_wepmodels_onfirsttake:GetBool() then
        ARC9.CacheWeaponsModels()
    end
    
    if arc9_precache_attsmodels_onfirsttake:GetBool() then
        ARC9.CacheAttsModels()
    end
end

function SWEP:ClientInitialize()
    if game.SinglePlayer() and self:GetOwner():IsPlayer() then self:CallOnClient("ClientInitialize") end
    if SERVER then return end

    -- local base = baseclass.Get(self:GetClass())

    -- self:BuildSubAttachments(base.Attachments)

    self.DefaultAttachments = table.Copy(self.Attachments)

    self:BuildSubAttachments(self.DefaultAttachments)

    self:InitTimers()

    if self:GetOwner() == LocalPlayer() then
        if !file.Exists(ARC9.PresetPath .. (self.SaveBase or self:GetClass()) .. "/default.txt", "DATA") then -- im sorry for that
            self:PostModify()
            self:SavePreset("default", true)
        end

        self:CreateStandardPresets()
    end

    if LocalPlayer().ARC9_IncompatibilityCheck != true then
        LocalPlayer().ARC9_IncompatibilityCheck = true

        ARC9.DoCompatibilityCheck()
    end
end

function SWEP:SetBaseSettings()
    if game.SinglePlayer() and self:GetOwner():IsPlayer() and SERVER then
        self:CallOnClient("SetBaseSettings")
    end

    self.Primary.Automatic = true
    self.Secondary.Automatic = true

    self.Primary.ClipSize = self:GetValue("ClipSize")
    self.Primary.Ammo = self:GetValue("Ammo")

    self.Primary.DefaultClip = self.ForceDefaultClip or self.Primary.ClipSize

    if self:GetValue("UBGL") then
        self.Secondary.ClipSize = self:GetValue("UBGLClipSize")
        self.Secondary.Ammo = self:GetValue("UBGLAmmo")

        if SERVER then
            if self:Clip2() < 0 then
                self:SetClip2(0)
            end
        end
    else
        self.Secondary.ClipSize = -1
        self.Secondary.Ammo = nil

        self:SetUBGL(false)
    end
end

function SWEP:SetShouldHoldType()
    if self:GetOwner():IsNPC() then
        local htnpc = self:GetValue("HoldTypeNPC", true)

        if !htnpc then
            if self:GetProcessedValue("ManualAction", true) then
                self:SetHoldType("shotgun")
            else
                self:SetHoldType(self:GetValue("HoldTypeSights", true) or self:GetValue("HoldType", true))
            end
        else
            self:SetHoldType(self:GetValue("HoldTypeNPC", true))
        end

        return
    end

    if self:GetInSights() and !self:GetSafe() then
        if self:GetProcessedValue("HoldTypeSights", true) then
            self:SetHoldType(self:GetProcessedValue("HoldTypeSights", true))

            return
        end
    end

    if self:GetCustomize() then
        if self:GetProcessedValue("HoldTypeCustomize", true) then
            self:SetHoldType(self:GetProcessedValue("HoldTypeCustomize", true))

            return
        end
    end

    if self:GetSafe() then
        if self:GetProcessedValue("HoldTypeHolstered", true) then
            self:SetHoldType(self:GetProcessedValue("HoldTypeHolstered", true))

            return
        end
    end

    if self:GetIsSprinting() or self:GetSafe() then
        if self:GetProcessedValue("HoldTypeSprint", true) then
            self:SetHoldType(self:GetProcessedValue("HoldTypeSprint", true))

            return
        end
    end

    self:SetHoldType(self:GetProcessedValue("HoldTypeDefault", true) or self:GetValue("HoldType", true))
end

function SWEP:OnDrop()
    self:EndLoop()
    self:KillShield()
    self:InvalidateCache()
    self:SetReady(false)
end

function SWEP:OwnerChanged()
    if CLIENT then
        self:SetupModel(true) -- setups worldmodel offset properly
    end
end

function SWEP:OnRemove()
    self:EndLoop()

    if SERVER then
        self:KillShield()
    end
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_sights.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_subatts.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_timers.lua:
local tick = 0

-- Avoid using this system - it breaks prediction.
function SWEP:InitTimers()
    self.ActiveTimers = {} -- { { time, id, func } }
end

function SWEP:SetTimer(time, callback, id)
    if !IsFirstTimePredicted() then return end
    table.insert(self.ActiveTimers, {time + CurTime(), id or "", callback})
end

function SWEP:TimerExists(id)
    for _, v in pairs(self.ActiveTimers) do
        if v[2] == id then return true end
    end

    return false
end

function SWEP:KillTimer(id)
    local keeptimers = {}

    for _, v in pairs(self.ActiveTimers) do
        if v[2] != id then
            table.insert(keeptimers, v)
        end
    end

    self.ActiveTimers = keeptimers
end

function SWEP:KillSoundTable()
    if !IsFirstTimePredicted() then return end
    local keeptimers = {}

    for _, v in ipairs(self.ActiveTimers or {}) do
        if string.sub(v[2] or "", 1, 10) != "soundtable" then
            table.insert(keeptimers, v)
        end
    end

    self.ActiveTimers = keeptimers
end

function SWEP:KillTimers()
    self.ActiveTimers = {}
end

function SWEP:ProcessTimers()
    local keeptimers = {}
    local UCT = CurTime()

    if !self.ActiveTimers then
        self:InitTimers()
    end

    for _, v in pairs(self.ActiveTimers) do
        if v[1] <= UCT then
            v[3]()
        else
            table.insert(keeptimers, v)
        end
    end

    self.ActiveTimers = keeptimers
end

SWEP.SoundTableBodygroups = {}
SWEP.SoundTablePoseParams = {}

function SWEP:PlaySoundTable(soundtable, mult)
    if !IsFirstTimePredicted() then return end
    local owner = self:GetOwner()
    start = start or 0
    mult = mult

    self:KillSoundTable()

    for i, v in pairs(soundtable) do
        local ttime

        if v.t then
            ttime = v.t * mult
        else
            continue
        end

        if ttime < 0 then continue end
        if !(IsValid(self) and IsValid(owner)) then continue end

        self:SetTimer(ttime, function()
            if v.s then
                local soundtab = {
                    name = "soundtable",
                    sound = self:RandomChoice(v.s or ""),
                    level = v.l or 75,
                    pitch = v.p or 100,
                    volume = v.v or 1,
                    channel = v.c or CHAN_AUTO,
                    dsp = v.dsp,
                    flags = v.fl,
                }

                self:PlayTranslatedSound(soundtab)
            end

            if v.ind then
                self.SoundTableBodygroups[v.ind] = v.bg or nil
            end

            if v.shelleject then
                local index = 0
                local num = 1

                if isnumber(v.shelleject) then
                    index = v.shelleject
                elseif istable(v.shelleject) then
                    index = v.shelleject.index
                    if v.shelleject.upto then
                        num = self:GetLastLoadedRounds() >= v.shelleject.upto and (v.shelleject.num or 1) or 0
                    else
                        num = v.shelleject.num
                    end
                end

                for j = 1, (num == "clip" and self:GetLastLoadedRounds()) or num do
                    self:DoEject(index, v.att)
                end
            end

            if v.e then
                local fx = EffectData()
                fx:SetMagnitude(v.mag or 1)
                fx:SetAttachment(v.att or 1)
                fx:SetEntity(self)

                util.Effect(v.e, fx)
            end

            if v.hide != nil then
                self:SetHideBoneIndex(v.hide)
            end

            if v.ppi != nil then
                self:SetPoseParameterIndex(v.ppi)
            end

            if game.SinglePlayer() and SERVER then
                if (v.v1 or v.v2 or v.vt) then
                    net.Start("ARC9_AnimRumble")
                    net.WriteUInt(v.v1 or 0, 16)
                    net.WriteUInt(v.v2 or 0, 16)
                    net.WriteFloat(v.vt or 0.1)
                    net.Send(self:GetOwner())
                end
            elseif !game.SinglePlayer() and CLIENT then
                SInputAnimRumble(v.v1 or 0, v.v2 or 0, v.vt or 0.1)
            end
        end, "soundtable_" .. tostring(i))
    end
end

if SERVER then
    util.AddNetworkString("ARC9_AnimRumble")
    if game.SinglePlayer() then
        util.AddNetworkString("ARC9_SP_FOV")
    end
end

ARC9.Ease = {
    ["InBack"]       = 1,
    ["InBounce"]     = 2,
    ["InCirc"]       = 3,
    ["InCubic"]      = 4,
    ["InElastic"]    = 5,
    ["InExpo"]       = 6,
    ["InOutBack"]    = 7,
    ["InOutBounce"]  = 8,
    ["InOutCirc"]    = 9,
    ["InOutCubic"]   = 10,
    ["InOutElastic"] = 11,
    ["InOutExpo"]    = 12,
    ["InOutQuad"]    = 13,
    ["InOutQuart"]   = 14,
    ["InOutQuint"]   = 15,
    ["InOutSine"]    = 16,
    ["InQuad"]       = 17,
    ["InQuart"]      = 18,
    ["InQuint"]      = 19,
    ["InSine"]       = 20,
    ["OutBack"]      = 21,
    ["OutBounce"]    = 22,
    ["OutCirc"]      = 23,
    ["OutCubic"]     = 24,
    ["OutElastic"]   = 25,
    ["OutExpo"]      = 26,
    ["OutQuad"]      = 27,
    ["OutQuart"]     = 28,
    ["OutQuint"]     = 29,
    ["OutSine"]      = 30,
}

ARC9.EaseToFunc = {
    [1] = math.ease.InBack,
    [2] = math.ease.InBounce,
    [3] = math.ease.InCirc,
    [4] = math.ease.InCubic,
    [5] = math.ease.InElastic,
    [6] = math.ease.InExpo,
    [7] = math.ease.InOutBack,
    [8] = math.ease.InOutBounce,
    [9] = math.ease.InOutCirc,
    [10] = math.ease.InOutCubic,
    [11] = math.ease.InOutElastic,
    [12] = math.ease.InOutExpo,
    [13] = math.ease.InOutQuad,
    [14] = math.ease.InOutQuart,
    [15] = math.ease.InOutQuint,
    [16] = math.ease.InOutSine,
    [17] = math.ease.InQuad,
    [18] = math.ease.InQuart,
    [19] = math.ease.InQuint,
    [20] = math.ease.InSine,
    [21] = math.ease.OutBack,
    [22] = math.ease.OutBounce,
    [23] = math.ease.OutCirc,
    [24] = math.ease.OutCubic,
    [25] = math.ease.OutElastic,
    [26] = math.ease.OutExpo,
    [27] = math.ease.OutQuad,
    [28] = math.ease.OutQuart,
    [29] = math.ease.OutQuint,
    [30] = math.ease.OutSine,
}

if CLIENT then
    net.Receive("ARC9_SP_FOV", function()
        local wpn = net.ReadEntity()
        local v1 = net.ReadFloat()
        local v2 = net.ReadFloat()
        local v3 = net.ReadFloat()
        local v4 = ARC9.EaseToFunc[net.ReadUInt(5)]
        local v5 = ARC9.EaseToFunc[net.ReadUInt(5)]
        wpn:CreateFOVEvent( v1, v2, v3, v4, v5 )
    end)

    local cl_rumble = GetConVar("arc9_controller_rumble")

    net.Receive("ARC9_AnimRumble", function()
        local v1 = net.ReadUInt(16)
        local v2 = net.ReadUInt(16)
        local vt = net.ReadFloat()
        SInputAnimRumble(v1 or 0, v2 or 0, vt or 0.1)
    end)

    function SInputAnimRumble(v1, v2, vt)
        if !sinput then return false end
        if !cl_rumble:GetBool() then return false end

        local P1 = sinput.GetControllerForGamepadIndex(0)
        sinput.TriggerVibration(P1, v1, v2)
        timer.Remove("SInput_ARC9_AnimRumble")

        timer.Create("SInput_ARC9_AnimRumble", vt, 1, function()
            sinput.TriggerVibration(P1, 0, 0)
        end)
    end
end

function SWEP:CancelSoundTable()
    for _, t in pairs(self.ActiveTimers) do
        if isstring(t[2]) and string.sub(t[2], 1, 10) == "soundtable" then
            self:KillTimer(t[2])
        end
    end
end
--PATH lua/weapons/arccw_b2_blaster.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/shared.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_blur.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_customize2.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_hud.lua:
local translate = ArcCW.GetTranslation

local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

local cvar_deadzonex, cvar_deadzoney
local function CopeX()
    if !cvar_deadzonex then cvar_deadzonex = ArcCW.ConVars["hud_deadzone_x"] end
    return cvar_deadzonex:GetFloat() * ScrW() / 2
end

local function CopeY()
    if !cvar_deadzoney then cvar_deadzoney = ArcCW.ConVars["hud_deadzone_y"] end
    return cvar_deadzoney:GetFloat() * ScrH() / 2
end

local function MyDrawText(tbl)
    local x = tbl.x
    local y = tbl.y
    local dontbust = Color(tbl.col.r, tbl.col.g, tbl.col.b, tbl.col.a)
    surface.SetFont(tbl.font)

    if tbl.alpha then
        dontbust.a = tbl.alpha
    else
        dontbust.a = 255
    end

    if tbl.align or tbl.yalign then
        local w, h = surface.GetTextSize(tbl.text)
        if tbl.align == 1 then
            x = x - w
        elseif tbl.align == 2 then
            x = x - (w / 2)
        end
        if tbl.yalign == 1 then
            y = y - h
        elseif tbl.yalign == 2 then
            y = y - h / 2
        end
    end

    if tbl.shadow then
        surface.SetTextColor(Color(0, 0, 0, tbl.alpha or 255))
        surface.SetTextPos(x, y)
        surface.SetFont(tbl.font .. "_Glow")
        surface.DrawText(tbl.text)
    end

    surface.SetTextColor(dontbust)
    surface.SetTextPos(x, y)
    surface.SetFont(tbl.font)
    surface.DrawText(tbl.text)
end

local vhp = 0
local varmor = 0
local vclip = 0
local vreserve = 0
local vclip2 = 0
local vreserve2 = 0
local vubgl = 0
local lastwpn = ""
local lastinfo = {ammo = 0, clip = 0, firemode = "", plus = 0}
local lastinfotime = 0

function SWEP:GetHUDData()
    local data = {
        clip = math.Round(vclip or self:Clip1()),
        ammo = math.Round(vreserve or self:Ammo1()),
        bars = self:GetFiremodeBars(),
        mode = self:GetFiremodeName(),
        ammotype = self.Primary.Ammo,
        ammotype2 = self.Secondary.Ammo,
        heat_enabled        = self:HeatEnabled(),
        heat_name           = translate("ui.heat"),
        heat_level          = self:GetHeat(),
        heat_maxlevel       = self:GetMaxHeat(),
        heat_locked         = self:GetHeatLocked(),
    }

    if data.clip > self:GetCapacity() then
        data.plus = data.clip - self:GetCapacity()
        data.clip = self:GetCapacity()
    end

    local infammo, btmless = self:HasInfiniteAmmo(), self:HasBottomlessClip()
    data.infammo = infammo
    data.btmless = btmless

    if self.PrimaryBash or self:Clip1() == -1 or self:GetCapacity() == 0 or self.Primary.ClipSize == -1 then
        data.clip = "-"
    end
    if self.PrimaryBash then
        data.ammo = "-"
    end

    if self:GetBuff_Override("UBGL") then
        data.clip2 = math.Round(vclip2 or self:Clip2())

        local ubglammo = self:GetBuff_Override("UBGL_Ammo")
        if ubglammo then
            data.ammo2 = tostring(math.Round(vreserve2 or self:GetOwner():GetAmmoCount(ubglammo)))
        end

        if data.clip2 > self:GetBuff_Override("UBGL_Capacity") then
            data.plus2 = (data.clip2 - self:GetBuff_Override("UBGL_Capacity"))
            data.clip2 = self:GetBuff_Override("UBGL_Capacity")
        end
    end

    do
        if infammo then
            data.ammo = btmless and data.ammo or "-"
            data.clip = self.Throwing and "∞" or data.clip
        end
        if btmless then
            data.clip = infammo and "∞" or data.ammo
            data.ammo = "-"
        end

        local ubglammo = self:GetBuff_Override("UBGL_Ammo")
        if ubglammo then
            data.ubgl = self:Clip2() + self:GetOwner():GetAmmoCount(ubglammo)
        end
    end

    data = self:GetBuff_Hook("Hook_GetHUDData", data) or data

    return data
end

local t_states = {
    [0] = "STATE_IDLE",
    [1] = "STATE_SIGHTS",
    [2] = "STATE_SPRINT",
    [3] = "STATE_DISABLE",
    [4] = "STATE_CUSTOMIZE",
    [5] = "STATE_BIPOD"
}

local mr = math.Round
local bird = Material("arccw/hud/really cool bird.png", "mips smooth")
local statlocked = Material("arccw/hud/locked_32.png", "mips smooth")

local bar_fill = Material("arccw/hud/fmbar_filled.png",           "mips smooth")
local bar_outl = Material("arccw/hud/fmbar_outlined.png",         "mips smooth")
local bar_shad = Material("arccw/hud/fmbar_shadow.png",           "mips smooth")
local bar_shou = Material("arccw/hud/fmbar_outlined_shadow.png",  "mips smooth")

local hp = Material("arccw/hud/hp.png", "smooth")
local hp_shad = Material("arccw/hud/hp_shadow.png", "mips smooth")

local armor = Material("arccw/hud/armor.png", "mips smooth")
local armor_shad = Material("arccw/hud/armor_shadow.png", "mips smooth")
local ubgl_mat = Material("arccw/hud/ubgl.png", "smooth")
local bipod_mat = Material("arccw/hud/bipod.png", "smooth")

local function debug_panel(self)
    local reloadtime = self:GetReloadTime()
    local s = ScreenScaleMulti(1)
    local thestate = self:GetState()
    local ecksy = s * 64

    if thestate == ArcCW.STATE_CUSTOMIZE then
        ecksy = s * 256
    elseif thestate == ArcCW.STATE_SIGHTS then
        surface.SetDrawColor(255, 50, 50, 150)
        surface.DrawLine(ScrW() / 2, ScrH() * 0.5 - 256, ScrW() / 2, ScrH() * 0.5 + 256)
        surface.DrawLine(ScrW() * 0.5 - 256, ScrH() / 2, ScrW() * 0.5 + 256, ScrH() / 2)
    end

    surface.SetFont("ArcCW_26")
    surface.SetTextColor(255, 255, 255, 255)
    surface.SetDrawColor(0, 0, 0, 63)

    -- it's for contrast, i promise
    surface.SetMaterial(bird)
    surface.DrawTexturedRect(ecksy - s-400, s-320, s * 512, s * 512)

    surface.SetDrawColor(255, 255, 255, 255)
    if reloadtime then
        surface.SetTextPos(ecksy, 26 * s * 1)
        surface.DrawText(math.Round(reloadtime[1], 2))

        surface.SetTextPos(ecksy, 26 * s * 2)
        surface.DrawText(math.Round(reloadtime[2], 2))

        surface.SetTextPos(ecksy, 26 * s * 3)
        if self:GetMagUpIn() - CurTime() > 0 then
            surface.SetTextColor(255, 127, 127, 255)
        end
        surface.DrawText( mr( math.max( self:GetMagUpIn() - CurTime(), 0 ), 2) )
    else
        surface.SetFont("ArcCW_20")
        surface.SetTextPos(ecksy, 26 * s * 2)
        surface.DrawText("NO RELOAD ANIMATION")

        surface.SetFont("ArcCW_12")
        surface.SetTextPos(ecksy, 26 * s * 2.66)
        surface.DrawText("not a mag fed one, at least...")
    end
    surface.SetTextPos(ecksy + (s*36*3), 26 * s * 3)
    if self:GetReloadingREAL() - CurTime() > 0 then
        surface.SetTextColor(255, 127, 127, 255)
    end
    surface.DrawText( mr( math.max( self:GetReloadingREAL() - CurTime(), 0 ), 2) )
    surface.SetFont("ArcCW_26")
    surface.SetTextColor(255, 255, 255, 255)

    local delay = math.max(self:GetReloadingREAL(), self:GetNWPriorityAnim())
    if delay - CurTime() > 0 then
        surface.SetTextColor(255, 127, 127, 255)
    end
    surface.SetTextPos(ecksy, 26 * s * 4)
    surface.DrawText( mr( math.max( delay - CurTime(), 0 ), 2 ) )
    surface.SetTextColor(255, 255, 255, 255)

    if self:GetWeaponOpDelay() - CurTime() > 0 then
        surface.SetTextColor(255, 127, 127, 255)
    end
    surface.SetTextPos(ecksy, 26 * s * 5)
    surface.DrawText( mr( math.max( self:GetWeaponOpDelay() - CurTime(), 0 ), 2 ) )
    surface.SetTextColor(255, 255, 255, 255)

    if self:GetNextPrimaryFire() - CurTime() > 0 then
        surface.SetTextColor(255, 127, 127, 255)
    end
    surface.SetTextPos(ecksy, 26 * s * 6)
    surface.DrawText( mr( math.max( self:GetNextPrimaryFire() * 1000 - CurTime() * 1000, 0 ), 0 ) .. "ms" )
    surface.SetTextColor(255, 255, 255, 255)

    local seq = self:GetSequenceInfo( self:GetOwner():GetViewModel():GetSequence() )
    local seq2 = self:GetOwner():GetViewModel():GetSequence()
    local seq3 = self:GetOwner():GetViewModel()
    surface.SetFont("ArcCW_20")
    surface.SetTextPos(ecksy, 26 * s * 7)
    surface.DrawText( seq2 .. ", " .. seq.label )

    local proggers = 1 - ( self.LastAnimFinishTime - CurTime() ) / seq3:SequenceDuration()

    surface.SetTextPos(ecksy, 26 * s * 8)
    surface.SetFont("ArcCW_12")
    surface.DrawText( mr( seq3:SequenceDuration() * proggers, 2 ) )

    surface.SetTextPos(ecksy + s * 30, 26 * s * 8)
    surface.DrawText( "-" )

    surface.SetTextPos(ecksy + s * 48, 26 * s * 8)
    surface.DrawText( mr( self:SequenceDuration( seq2 ), 2 ) )

    surface.SetTextPos(ecksy + s * 132, 26 * s * 7.6)
    surface.DrawText( mr(proggers * 100) .. "%" )

    -- welcome to the bar
    surface.DrawOutlinedRect(ecksy, 26 * s * 7.7, s * 128, s * 8, s)
    surface.DrawRect(ecksy, 26 * s * 7.7 + s * 2, s * 128 * math.Clamp(proggers, 0, 1), s * 8-s * 4, s)

    surface.SetFont("ArcCW_20")
    surface.SetTextPos(ecksy, 26 * s * 8.5)
    surface.DrawText( t_states[thestate] )

    surface.SetTextPos(ecksy, 26 * s * 9.25)
    surface.DrawText( mr(self:GetSightDelta() * 100) .. "%" )

    surface.DrawOutlinedRect(ecksy, 26 * s * 10, s * 64, s * 4, s / 2)
    surface.DrawRect(ecksy, 26 * s * 10 + s * 1, s * 64 * self:GetSightDelta(), s * 4-s * 2)

    surface.DrawOutlinedRect(ecksy, 26 * s * 10.25, s * 64, s * 4, s / 2)
    surface.DrawRect(ecksy, 26 * s * 10.25 + s * 1, s * 64 * self:GetSprintDelta(), s * 4-s * 2)


    surface.SetTextPos(ecksy, 26 * s * 11)
    surface.DrawText( mr(self:GetHolster_Time(), 1) )

    surface.SetTextPos(ecksy, 26 * s * 12)
    surface.DrawText( tostring(self:GetHolster_Entity()) )

    -- Labels
    surface.SetTextColor(255, 255, 255, 255)
    surface.SetFont("ArcCW_8")

    if reloadtime then
        surface.SetTextPos(ecksy, 26 * s * 1)
        surface.DrawText("RELOAD")

        surface.SetTextPos(ecksy- s * 36, s * 26 * 1.33)
        surface.DrawText("FULL")

        surface.SetTextPos(ecksy- s * 36, s * 26 * 2.33)
        surface.DrawText("MAGIN")

        surface.SetTextPos(ecksy- s * 36, s * 26 * 3.33)
        surface.DrawText("MAG LOAD")
    end

    surface.SetTextPos(ecksy- s * (36 * -2), s * 26 * 3.33)
    surface.DrawText("RELOAD TIME")

    surface.SetTextPos(ecksy, 26 * s * 4)
    surface.DrawText("PRIORITY DELAY")

    surface.SetTextPos(ecksy, 26 * s * 5)
    surface.DrawText("WEAPON OPERATION DELAY")

    surface.SetTextPos(ecksy, 26 * s * 6)
    surface.DrawText("NEXT PRIMARY FIRE")

    surface.SetTextPos(ecksy, 26 * s * 7)
    surface.DrawText("CURRENT ANIMATION")

    surface.SetTextPos(ecksy, 26 * s * 8.5)
    surface.DrawText("WEAPON STATE")

    surface.SetTextPos(ecksy, 26 * s * 9.25)
    surface.DrawText("SIGHT DELTA")

    surface.SetTextPos(ecksy, 26 * s * 11)
    surface.DrawText("HOLSTER TIME")

    surface.SetTextPos(ecksy, 26 * s * 12)
    surface.DrawText("HOLSTER ENT")

    -- lhik timeline
    surface.SetTextColor(255, 255, 255, 255)
    surface.SetFont("ArcCW_8")
    surface.SetDrawColor(255, 255, 255, 11)
    surface.DrawRect(s * 8, s * 8, ScrW() - (s * 16), s * 2)

    local texy = math.Round(CurTime(),1)
    local a, b = surface.GetTextSize(texy)
    surface.SetTextPos((ScrW() / 2) - (a / 2), (s * 16) - (b / 2))
    surface.DrawText(texy)

    surface.SetDrawColor(255, 255, 255, 127)
    if self.LHIKTimeline then for i, v in pairs(self.LHIKTimeline) do

        local pox = ScrW() / 2
        local poy = (s * 7)

        local zo = s * 0.01

        local dist = self.LHIKStartTime + v.t

        surface.DrawRect(pox + (dist * zo), poy, s * 8, s * 4)

        texy = math.Round(dist,1)
        a, b = surface.GetTextSize(texy)
        surface.SetTextPos(pox + (dist * zo) - (a / 2), (s * 16) - (b / 2) )
        surface.DrawText(texy)
    end end
end

function SWEP:DrawHUD()
    if ArcCW.ConVars["dev_debug"]:GetBool() then
        debug_panel(self)
    end

    if ArcCW.ConVars["dev_benchgun"]:GetBool() then
        draw.SimpleTextOutlined("BENCHGUN ENABLED", "ArcCW_26", ScrW() / 2, ScreenScaleMulti(4), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 2, Color(0, 0, 0))
        draw.SimpleTextOutlined("VIEWMODEL POSITION MOVED", "ArcCW_16", ScrW() / 2, ScreenScaleMulti(30), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 2, Color(0, 0, 0))
    end

    if !GetConVar("cl_drawhud"):GetBool() then return false end

    if self:GetState() != ArcCW.STATE_CUSTOMIZE then
        self:GetBuff_Hook("Hook_DrawHUD")
    end

    local col2 = Color(255, 255, 255, 255)
    local col3 = Color(255, 0, 0, 255)

    local airgap = ScreenScaleMulti(8)

    local apan_bg = {
        w = ScreenScaleMulti(128),
        h = ScreenScaleMulti(48),
    }

    local data = self:GetHUDData()

    if data.heat_locked then
        col2 = col3
    end

    local curTime = CurTime()
    --local mode = self:GetFiremodeName()

    local muzz = self:GetBuff_Override("Override_MuzzleEffectAttachment") or self.MuzzleEffectAttachment or 1

    local fmbars = ArcCW.ConVars["hud_fcgbars"]:GetBool() and string.len( self:GetFiremodeBars() or "-----" ) != 0

    if ArcCW:ShouldDrawHUDElement("CHudAmmo") then
        local decaytime = GetConVar("arccw_hud_3dfun_decaytime"):GetFloat()
        if decaytime == 0 then decaytime = math.huge end
        local visible = (lastinfotime + decaytime + 1 > curTime or lastinfotime - 0.5 > curTime)

        -- Detect changes to stuff drawn in HUD
        local curInfo = {
            ammo = data.ammo,
            clip = data.clip,
            plus = data.plus or "0", -- data.plus is nil when it doesnt exist
            ammo2 = data.ammo2,
            clip2 = data.clip2,
            plus2 = data.plus2 or "0", -- data.plus is nil when it doesnt exist
            ammotype = data.ammotype,
            firemode = data.mode,
            heat = data.heat_level,
            self:GetInUBGL(),
            self:GetInBipod(),
            self:CanBipod(),
        }
        if GetConVar("arccw_hud_3dfun_lite"):GetBool() then
            curInfo.clip = nil
            curInfo.plus = nil
            curInfo.clip2 = nil
            curInfo.plus2 = nil
            curInfo.heat = nil
        end
        for i, v in pairs(curInfo) do
            if v != lastinfo[i] then
                lastinfotime = visible and (curTime - 0.5) or curTime
                lastinfo = curInfo
                break
            end
        end
        local qss = ScreenScaleMulti(24)
        local correct_y = 28
        local correct_x = 0
        if !GetConVar("arccw_hud_3dfun"):GetBool() then
            qss = ScreenScaleMulti(-24)
            correct_y = -36
            correct_x = 52
        end

        -- TODO: There's an issue where this won't ping the HUD when switching in from non-ArcCW weapons
        if LocalPlayer():KeyDown(IN_RELOAD) or lastwpn != self then lastinfotime = visible and (curTime - 0.5) or curTime end

        local alpha
        if lastinfotime + decaytime < curTime then
            alpha = 255 - (curTime - lastinfotime - decaytime) * 255
        elseif lastinfotime + 0.5 > curTime then
            alpha = 255 - (lastinfotime + 0.5 - curTime) * 255
        else
            alpha = 255
        end

        if alpha > 0 then

            local EyeAng = EyeAngles()

            local angpos
            if GetConVar("arccw_hud_3dfun"):GetBool() and self:GetOwner():ShouldDrawLocalPlayer() then
                local bone = "ValveBiped.Bip01_R_Hand"
                local ind = self:GetOwner():LookupBone(bone)

                if ind and ind > -1 then
                    local p, a = self:GetOwner():GetBonePosition(ind)
                    angpos = {Ang = a, Pos = p}
                end
            elseif GetConVar("arccw_hud_3dfun"):GetBool() then
                local vm = self:GetOwner():GetViewModel()

                if vm and vm:IsValid() then
                    angpos = vm:GetAttachment(muzz)
                end
            end

            if GetConVar("arccw_hud_3dfun"):GetBool() and angpos then

                angpos.Pos = angpos.Pos - EyeAng:Up() * GetConVar("arccw_hud_3dfun_up"):GetFloat() - EyeAng:Right() * GetConVar("arccw_hud_3dfun_right"):GetFloat() - EyeAng:Forward() * GetConVar("arccw_hud_3dfun_forward"):GetFloat()
                cam.Start3D()
                    local toscreen = angpos.Pos:ToScreen()
                cam.End3D()

                apan_bg.x = toscreen.x - apan_bg.w - ScreenScaleMulti(8)
                apan_bg.y = toscreen.y - apan_bg.h * 0.5
            else
                apan_bg.x = ScrW() - CopeX() - ScreenScaleMulti(128 + 8)
                apan_bg.y = ScrH() - CopeY() - ScreenScaleMulti(48)
            end

            apan_bg.x = math.Clamp(apan_bg.x, ScreenScaleMulti(8), ScrW() - CopeX() - ScreenScaleMulti(128 + 8))
            apan_bg.y = math.Clamp(apan_bg.y, ScreenScaleMulti(8), ScrH() - CopeY() - ScreenScaleMulti(48))

            if !fmbars then
                apan_bg.y = apan_bg.y + ScreenScaleMulti(6)
            end

            local corny = 22 * math.ease.OutSine(math.sin(vubgl * math.pi)) * (self:GetInUBGL() and -1 or 1)
            local ngap = 22 * vubgl
            local wammo = {
                x = apan_bg.x + apan_bg.w - airgap + ScreenScaleMulti(corny),
                y = apan_bg.y - ScreenScaleMulti(4) - ScreenScaleMulti(ngap),
                text = tostring(data.clip),
                font = "ArcCW_26",
                col = col2,
                align = 1,
                shadow = true,
                alpha = alpha,
            }

            wammo.col = col2

            if data.clip == 0 then
                wammo.col = col3
            end

            if tostring(data.clip) == "-" then
                wammo.text = ""
            end
                MyDrawText(wammo)
                wammo.w, wammo.h = surface.GetTextSize(wammo.text)
            surface.SetFont("ArcCW_26")

            if data.plus and !self:HasBottomlessClip() then
                local wplus = {
                    x = wammo.x,
                    y = wammo.y,
                    text = "+" .. tostring(data.plus),
                    font = "ArcCW_16",
                    col = col2,
                    shadow = true,
                    alpha = alpha,
                }

                MyDrawText(wplus)
            end

            local wreserve = {
                x = wammo.x - wammo.w - ScreenScaleMulti(4),
                y = apan_bg.y + ScreenScaleMulti(10) - ScreenScaleMulti(ngap),
                text = tostring(data.ammo) .. " /",
                font = "ArcCW_12",
                col = col2,
                align = 1,
                yalign = 2,
                shadow = true,
                alpha = alpha,
            }

            if tonumber(data.ammo) and tonumber(data.clip) and tonumber(data.clip) >= self:GetCapacity() then
                wreserve.text = tostring(data.ammo) .. " |"
            end

            if self:GetPrimaryAmmoType() <= 0 then
                wreserve.text = "!"
            end

            if self.PrimaryBash then
                wreserve.text = ""
            end

            local drew = false
            local ungl = false
            if tostring(data.ammo) != "-" then
                drew = true
                MyDrawText(wreserve)
                surface.SetFont("ArcCW_12")
                wreserve.w, wreserve.h = surface.GetTextSize(wreserve.text)
            end

            if GetConVar("arccw_hud_3dfun_ammotype"):GetBool() and isstring(data.ammotype) then
                local wammotype = {
                    x = wammo.x - wammo.w - ScreenScaleMulti(3),
                    y = wammo.y + (wammo.h/2),
                    text = language.GetPhrase(data.ammotype .. "_ammo"),
                    font = "ArcCW_8",
                    col = col2,
                    align = 1,
                    yalign = 2,
                    shadow = true,
                    alpha = alpha,
                }

                if drew then
                    wammotype.x = wreserve.x - wreserve.w - ScreenScaleMulti(3)
                    wammotype.y = wreserve.y-- + (wreserve.h/2)
                end

                MyDrawText(wammotype)
            end

            --ubgl
            if self:GetBuff_Override("UBGL") then
                ungl = true
                local ugap = 22 * (1-vubgl)

                local wammo = {
                    x = apan_bg.x + apan_bg.w - airgap + ScreenScaleMulti(corny*-1),
                    y = apan_bg.y - ScreenScaleMulti(4) - ScreenScaleMulti(ugap),
                    text = tostring(data.clip2),
                    font = "ArcCW_26",
                    col = col2,
                    align = 1,
                    shadow = true,
                    alpha = alpha,
                }

                wammo.col = col2

                if data.clip2 == 0 then
                    wammo.col = col3
                end

                if tostring(data.clip2) != "-" then
                    MyDrawText(wammo)
                end
                surface.SetFont("ArcCW_26")
                wammo.w, wammo.h = surface.GetTextSize(wammo.text)

                if data.plus2 and !self:HasBottomlessClip() then
                    local wplus = {
                        x = wammo.x,
                        y = wammo.y,
                        text = "+" .. tostring(data.plus2),
                        font = "ArcCW_16",
                        col = col2,
                        shadow = true,
                        alpha = alpha,
                    }

                    MyDrawText(wplus)
                end

                local wreserve = {
                    x = wammo.x - wammo.w - ScreenScaleMulti(4),
                    y = apan_bg.y + ScreenScaleMulti(10) - ScreenScaleMulti(ugap),
                    text = tostring(data.ammo2) .. " /",
                    font = "ArcCW_12",
                    col = col2,
                    align = 1,
                    yalign = 2,
                    shadow = true,
                    alpha = alpha,
                }

                if tonumber(data.ammo2) and tonumber(data.clip2) and tonumber(data.clip2) >= self:GetBuff_Override("UBGL_Capacity") then
                    wreserve.text = tostring(data.ammo2) .. " |"
                end

                if self:GetSecondaryAmmoType() <= 0 then
                    wreserve.text = "!"
                end

                local drew = false
                if tostring(data.ammo2) != "-" then
                    drew = true
                    MyDrawText(wreserve)
                    surface.SetFont("ArcCW_12")
                    wreserve.w, wreserve.h = surface.GetTextSize(wreserve.text)
                end

                if GetConVar("arccw_hud_3dfun_ammotype"):GetBool() and isstring(data.ammotype) then
                    local wammotype = {
                        x = wammo.x - wammo.w - ScreenScaleMulti(3),
                        y = wammo.y + (wammo.h/2),
                        text = language.GetPhrase(data.ammotype2 .. "_ammo"),
                        font = "ArcCW_8",
                        col = col2,
                        align = 1,
                        yalign = 2,
                        shadow = true,
                        alpha = alpha,
                    }

                    if drew then
                        wammotype.x = wreserve.x - wreserve.w - ScreenScaleMulti(3)
                        wammotype.y = wreserve.y
                    end

                    MyDrawText(wammotype)
                end
            end

            local wmode = {
                x = apan_bg.x + apan_bg.w - airgap,
                y = apan_bg.y + ScreenScaleMulti(28),
                font = "ArcCW_12",
                text = data.mode,
                col = col2,
                align = 1,
                shadow = true,
                alpha = alpha,
            }
            if !fmbars then
                wmode.y = wmode.y - ScreenScaleMulti(6)
            end
            MyDrawText(wmode)

            -- overheat bar 3d
            if self:GetMalfunctionJam() then
                local col = Color(255, 0, 32)

                local wheat = { --cheeeeerios
                    x = apan_bg.x + apan_bg.w - airgap,
                    y = wmode.y + ScreenScaleMulti(16) * ( !GetConVar("arccw_hud_3dfun"):GetBool() and -2.5 or 1 ),
                    font = "ArcCW_12",
                    text = translate("ui.jammed"),
                    col = col,
                    align = 1,
                    shadow = true,
                    alpha = alpha,
                }
                if fmbars then
                    wheat.y = wmode.y + ScreenScaleMulti(16) * ( !GetConVar("arccw_hud_3dfun"):GetBool() and -2.5 or 0.8 )
                end
                if ungl then
                    wheat.y = wheat.y - ScreenScaleMulti(24)
                end

                local wheat_shad = {
                    x = wheat.x,
                    y = wheat.y,
                    font = "ArcCW_12_Glow",
                    text = wheat.text,
                    col = col,
                    align = 1,
                    shadow = false,
                    alpha = alpha,
                }
                MyDrawText(wheat_shad)

                MyDrawText(wheat)
            elseif data.heat_enabled then
                local pers = math.Clamp(1 - (data.heat_level / data.heat_maxlevel), 0, 1)
                local pers2 = math.Clamp(data.heat_level / data.heat_maxlevel, 0, 1)
                local colheat1 = data.heat_locked and Color(255, 0, 0) or Color(255, 128 + 127 * pers, 128 + 127 * pers)
                local colheat2 = data.heat_locked and Color(255, 0, 0) or Color(255 * pers2, 0, 0)

                local wheat = {
                    x = apan_bg.x + apan_bg.w - airgap,
                    y = wmode.y + ScreenScaleMulti(16) * ( !GetConVar("arccw_hud_3dfun"):GetBool() and -2.5 or 1 ),
                    font = "ArcCW_12",
                    text = data.heat_name .. " " .. tostring(math.floor(100 * data.heat_level / data.heat_maxlevel)) .. "%",
                    col = colheat1,
                    align = 1,
                    shadow = false,
                    alpha = alpha,
                }
                if fmbars then
                    wheat.y = wmode.y + ScreenScaleMulti(16) * ( !GetConVar("arccw_hud_3dfun"):GetBool() and -2.5 or 0.8 )
                end
                if ungl then
                    wheat.y = wheat.y - ScreenScaleMulti(24)
                end

                local wheat_shad = {
                    x = wheat.x,
                    y = wheat.y,
                    font = "ArcCW_12_Glow",
                    text = wheat.text,
                    col = colheat2,
                    align = 1,
                    shadow = false,
                    alpha = alpha * pers,
                }
                MyDrawText(wheat_shad)

                MyDrawText(wheat)
            end
            if self:CanBipod() or self:GetInBipod() then
                local size = ScreenScaleMulti(32)
                local awesomematerial = self:GetBuff_Override("Bipod_Icon", bipod_mat)
                local whatsthecolor =   self:GetInBipod() and     Color(255, 255, 255, alpha) or
                                        self:CanBipod() and   Color(255, 255, 255, alpha / 4) or Color(0, 0, 0, 0)
                local bar = {
                    w = size,
                    h = size,
                    x = (ScrW()/2) - (size/2),
                    y = ScrH() - CopeY() - ScreenScaleMulti(40),
                }
                surface.SetDrawColor( whatsthecolor )
                surface.SetMaterial( awesomematerial )
                surface.DrawTexturedRect( bar.x, bar.y, bar.w, bar.h )

                local txt = string.upper(ArcCW:GetBind("+use"))

                local bip = {
                    shadow = true,
                    x = bar.x + (bar.w/2),
                    y = bar.y - ScreenScaleMulti(12),
                    align = 2,
                    font = "ArcCW_12",
                    text = txt,
                    col = whatsthecolor,
                    alpha = alpha,
                }

                MyDrawText(bip)
            end

            if ArcCW.ConVars["hud_togglestats"] and ArcCW.ConVars["hud_togglestats"]:GetBool() then
            local items = {
            }
            --[[
            {
                Icon = "",
                Locked = false,
                Selected = 1,
                Toggles = {
                    [1] = "",
                    [2] = "",
                    [3] = "",
                }
            }
            ]]

            for k, v in pairs(self.Attachments) do
                local atttbl = v.Installed and ArcCW.AttachmentTable[v.Installed]
                if atttbl and atttbl.ToggleStats then-- and !v.ToggleLock then
                    --print(atttbl.PrintName)
                    local item = {
                        Icon = atttbl.Icon,
                        Locked = v.ToggleLock,
                        Selected = v.ToggleNum,
                        Toggles = {}
                    }
                    for i, h in ipairs(atttbl.ToggleStats) do
                        table.insert(item.Toggles, h.PrintName)
                        --print("\t" .. (v.ToggleNum == i and "> " or "") .. atttbl.ToggleStats[i].PrintName .. (v.ToggleNum == i and " <" or ""))
                    end
                    table.insert(items, item)
                end
            end

            for i=1, 0 do
                table.insert(items, {
                    Icon = Material("Test"),
                    Locked = false,
                    Selected = i,
                    Toggles = {
                        "Test",
                        "Test",
                        "Test",
                        "Test",
                        "Test",
                    }
                })
            end

            do
                local size = ScreenScaleMulti(28)
                local lock = ScreenScaleMulti(7)
                local shiit = 1.5
                local gaap = ScreenScaleMulti(7) -- 32 / 8
                if #items == 1 then
                    gaap = 0
                    shiit = 1
                end
                for index, item in ipairs(items) do
                    surface.SetMaterial(item.Icon or bird)
                    surface.SetDrawColor(color_white)

                    local px, py = (ScrW()/2) - ((size*shiit)*(index-(#items*0.5))) + gaap, (ScrH()-CopeY()-(size*1.25))
                    surface.DrawTexturedRect(px, py, size, size)

                    if item.Locked then
                        surface.SetMaterial(statlocked)
                        surface.DrawTexturedRect(px + (size/2) - (lock/2), py + size - (lock/2), lock, lock)
                    end

                    for tdex, tinfo in ipairs(item.Toggles) do
                        local infor = {
                            x = px + (size*0.5),
                            y = py - (#item.Toggles * ScreenScaleMulti(8)) + (tdex * ScreenScaleMulti(8)),
                            font = "ArcCW_8",
                            text = tinfo,
                            col = col2,
                            align = 2,
                            yalign = 1,
                            shadow = true,
                            alpha = alpha * (tdex == item.Selected and 1 or 0.25),
                        }
                        MyDrawText(infor)
                    end
                end
            end
            end

            if fmbars then
                local segcount = string.len( self:GetFiremodeBars() or "-----" )
                local bargap = ScreenScaleMulti(2)
                local bart = {
                    w = (ScreenScaleMulti(100) + ((segcount + 1) * bargap)) / segcount,
                    h = ScreenScaleMulti(8),
                    x = apan_bg.x + apan_bg.w,
                    y = apan_bg.y + apan_bg.h
                }

                bart.x = bart.x - ((bart.w / 2 + bargap) * segcount) - ScreenScaleMulti(4) - (bart.w / 4)
                bart.y = bart.y - ScreenScaleMulti(28)

                for i = 1, segcount do
                    local c = data.bars[i]

                    if c == "#" then continue end

                    if c != "!" and c != "-" then
                        surface.SetMaterial(bar_shou)
                    else
                        surface.SetMaterial(bar_shad)
                    end
                    surface.SetDrawColor(255, 255, 255, 255 / 5 * 3)
                    surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)

                    if c == "-" then
                        -- good ol filled
                        surface.SetMaterial(bar_fill)
                        surface.SetDrawColor(col2)
                        surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                    elseif c == "!" then
                        surface.SetMaterial(bar_fill)
                        surface.SetDrawColor(col3)
                        surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                        surface.SetMaterial(bar_outl)
                        surface.SetDrawColor(col2)
                        surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                    else
                        -- good ol outline
                        surface.SetMaterial(bar_outl)
                        surface.SetDrawColor(col2)
                        surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                    end

                    bart.x = bart.x + (bart.w / 2 + bargap)
                end
            end
        end
    elseif !ArcCW.ConVars["override_hud_off"]:GetBool() and ArcCW.ConVars["hud_minimal"]:GetBool() then
        if fmbars then
            local segcount = string.len( self:GetFiremodeBars() or "-----" )
            local bargap = ScreenScaleMulti(2)
            local bart = {
                w = (ScreenScaleMulti(256) - ((segcount + 1) * bargap)) / segcount,
                h = ScreenScaleMulti(8),
                x = ScrW() / 2,
                y = ScrH() - ScreenScaleMulti(24)
            }

            bart.x = bart.x - ((bart.w / 4) * segcount) - bart.w / 3.5 - bargap

            for i = 1, segcount do
                local c = data.bars[i]

                if c == "#" then continue end

                if c != "!" and c != "-" then
                    surface.SetMaterial(bar_shou)
                else
                    surface.SetMaterial(bar_shad)
                end
                surface.SetDrawColor(255, 255, 255, 255 / 5 * 3)
                surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)

                if c == "-" then
                    -- good ol filled
                    surface.SetMaterial(bar_fill)
                    surface.SetDrawColor(col2)
                    surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                elseif c == "!" then
                    surface.SetMaterial(bar_fill)
                    surface.SetDrawColor(col3)
                    surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                    surface.SetMaterial(bar_outl)
                    surface.SetDrawColor(col2)
                    surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                else
                    -- good ol outline
                    surface.SetMaterial(bar_outl)
                    surface.SetDrawColor(col2)
                    surface.DrawTexturedRect(bart.x, bart.y, bart.w, bart.h)
                end

                bart.x = bart.x + (bart.w / 2) + bargap
            end
        end
        local wmode = {
            x = ScrW() / 2,
            y = ScrH() - ScreenScaleMulti(34),
            font = "ArcCW_12",
            text = data.mode,
            col = col2,
            align = 2,
            shadow = true,
            alpha = alpha,
        }
        MyDrawText(wmode)

        if self:GetBuff_Override("UBGL") then
            local size = ScreenScaleMulti(32)
            local awesomematerial = self:GetBuff_Override("UBGL_Icon", ubgl_mat)
            local whatsthecolor = self:GetInUBGL() and  Color(255, 255, 255, 255) or
                                                    Color(255, 255, 255, 0)
            local bar2 = {
                w = size,
                h = size,
                x = ScrW() / 2 + ScreenScaleMulti(32),
                y = ScrH() - ScreenScaleMulti(52),
            }
            surface.SetDrawColor( whatsthecolor )
            surface.SetMaterial( awesomematerial )
            surface.DrawTexturedRect( bar2.x, bar2.y, bar2.w, bar2.h )
        end

        if self:CanBipod() or self:GetInBipod() then
            local size = ScreenScaleMulti(32)
            local awesomematerial = self:GetBuff_Override("Bipod_Icon", bipod_mat)
            local whatsthecolor =   self:GetInBipod() and   Color(255, 255, 255, 255) or
                                    self:CanBipod() and     Color(255, 255, 255, 127) or
                                                            Color(255, 255, 255, 0)
            local bar2 = {
                w = size,
                h = size,
                x = ScrW() / 2 - ScreenScaleMulti(64),
                y = ScrH() - ScreenScaleMulti(52),
            }
            surface.SetDrawColor( whatsthecolor )
            surface.SetMaterial( awesomematerial )
            surface.DrawTexturedRect( bar2.x, bar2.y, bar2.w, bar2.h )

            local txt = string.upper(ArcCW:GetBind("+use"))

            local bip = {
                shadow = true,
                x = ScrW() / 2 - ScreenScaleMulti(64),
                y = ScrH() - ScreenScaleMulti(52),
                font = "ArcCW_12",
                text = txt,
                col = whatsthecolor,
            }

            MyDrawText(bip)
        end

        if data.heat_enabled then
            surface.SetDrawColor(col2)
            local perc = data.heat_level / data.heat_maxlevel

            local bar = {
                x = 0,
                y = ScrH() - ScreenScaleMulti(22)
            }

            surface.DrawOutlinedRect(ScrW() / 2 - ScreenScaleMulti(62), bar.y + ScreenScaleMulti(4.5), ScreenScaleMulti(124), ScreenScaleMulti(3))
            surface.DrawRect(ScrW() / 2 - ScreenScaleMulti(62), bar.y + ScreenScaleMulti(4.5), ScreenScaleMulti(124) * perc, ScreenScaleMulti(3))

            surface.SetFont("ArcCW_8")
            local bip = {
                shadow = false,
                x = (ScrW() / 2) - (surface.GetTextSize(data.heat_name) / 2),
                y = bar.y + ScreenScaleMulti(8),
                font = "ArcCW_8",
                text = data.heat_name,
                col = col2,
            }

            MyDrawText(bip)
        end
    end

    -- health + armor

    if ArcCW:ShouldDrawHUDElement("CHudHealth") then

        local colhp = Color(255, 255, 255, 255)
        local gotarmor = false

        if LocalPlayer():Armor() > 0 then
            gotarmor = true
            local armor_s = ScreenScaleMulti(10)
            local war = {
                x = airgap + CopeX() + armor_s + ScreenScaleMulti(6),
                y = ScrH() - ScreenScaleMulti(16) - airgap - CopeY(),
                font = "ArcCW_16",
                text = tostring(math.Round(varmor)),
                col = Color(255, 255, 255, 255),
                shadow = true,
                alpha = alpha
            }

            local armor_x = war.x - armor_s - ScreenScaleMulti(4)
            local armor_y = war.y + ScreenScaleMulti(4)

            surface.SetMaterial(armor_shad)
            surface.SetDrawColor(0, 0, 0, 255)
            surface.DrawTexturedRect(armor_x, armor_y, armor_s, armor_s)

            surface.SetMaterial(armor)
            surface.SetDrawColor(colhp)
            surface.DrawTexturedRect(armor_x, armor_y, armor_s, armor_s)

            MyDrawText(war)
        end

        local hpicon_s = ScreenScaleMulti(16)
        local hpicon_x = airgap + CopeX()

        if LocalPlayer():Health() <= 30 then
            colhp = col3
        end

        local whp = {
            x = airgap + hpicon_s + CopeX(),
            y = ScrH() - ScreenScaleMulti(26 + (gotarmor and 16 or 0)) - airgap - CopeY(),
            font = "ArcCW_26",
            text = tostring(math.Round(vhp)),
            col = colhp,
            shadow = true,
            alpha = alpha
        }

        local hpicon_y = whp.y + ScreenScaleMulti(8)

        MyDrawText(whp)

        surface.SetMaterial(hp_shad)
        surface.SetDrawColor(0, 0, 0, 255)
        surface.DrawTexturedRect(hpicon_x, hpicon_y, hpicon_s, hpicon_s)

        surface.SetMaterial(hp)
        surface.SetDrawColor(colhp)
        surface.DrawTexturedRect(hpicon_x, hpicon_y, hpicon_s, hpicon_s)

    end

    vhp = self:GetOwner():Health()
    varmor = self:GetOwner():Armor()

    local clipdiff = math.abs(vclip - self:Clip1())
    local reservediff = math.abs(vreserve - self:Ammo1())

    if clipdiff == 1 then
        vclip = self:Clip1()
    elseif self:Clip1() == ArcCW.BottomlessMagicNumber then
        clipdiff = 0
    end

    vclip = math.Approach(vclip, self:Clip1(), FrameTime() * 30 * clipdiff)
    vreserve = math.Approach(vreserve, self:Ammo1(), FrameTime() * 30 * reservediff)

    do
        local clipdiff = math.abs(vclip2 - self:Clip2())
        local reservediff = math.abs(vreserve2 - self:Ammo2())

        if clipdiff == 1 then
            vclip2 = self:Clip2()
        elseif self:Clip2() == ArcCW.BottomlessMagicNumber then
            clipdiff = 0
        end

        vclip2 = math.Approach(vclip2, self:Clip2(), FrameTime() * 30 * clipdiff)
        vreserve2 = math.Approach(vreserve2, self:Ammo2(), FrameTime() * 30 * reservediff)
    end

    vubgl = math.Approach(vubgl, (self:GetInUBGL() and 1 or 0), (FrameTime() / 0.3) )

    if lastwpn != self then
        vclip = self:Clip1()
        vreserve = self:Ammo1()
        vclip2 = self:Clip2()
        vreserve2 = self:Ammo2()
        vubgl = 0
        vhp = self:GetOwner():Health()
        varmor = self:GetOwner():Armor()
    end

    lastwpn = self
end

function SWEP:CustomAmmoDisplay()
    local data = self:GetHUDData()
    self.AmmoDisplay = self.AmmoDisplay or {}

    self.AmmoDisplay.Draw = true -- draw the display?

    if self.Primary.ClipSize > 0 and tonumber(data.clip) then
        local plus = tonumber(data.plus) or 0
        self.AmmoDisplay.PrimaryClip = tonumber(data.clip) + plus -- amount in clip
    end

    if self.Primary.ClipSize > 0 and tonumber(data.ammo) then
        self.AmmoDisplay.PrimaryAmmo = tonumber(data.ammo) -- amount in reserve
    end

    if true then
        local ubglammo = self:GetBuff_Override("UBGL_Ammo")
        if ubglammo then
            self.AmmoDisplay.SecondaryAmmo = self:Clip2() + self:GetOwner():GetAmmoCount(ubglammo) -- amount of secondary ammo
        end
    end

    return self.AmmoDisplay -- return the table
end
--PATH lua/weapons/arccw_base/cl_presets.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_presets.lua:
-- atts are comma separated
-- optic_mrs,,,perk_quickdraw,ammo_match



local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

function SWEP:GetPresetBase()
    return self.PresetBase or self:GetClass()
end

function SWEP:GetPresets()
    local path = ArcCW.PresetPath .. self:GetPresetBase() .. "/*.txt"

    local files = file.Find(path, "DATA")

    files = table.Add(files, file.Find(ArcCW.PresetPath .. self:GetPresetBase() .. "/*.json", "DATA"))

    return files
end

function SWEP:LoadPreset(presetname)
    presetname = presetname or "autosave"
    if presetname == "autosave" then
        if self:GetNWBool("ArcCW_DisableAutosave", false) then return end
        if !ArcCW.ConVars["autosave"]:GetBool() then return end
    end

    if presetname != "autosave" then
        surface.PlaySound("weapons/arccw/install.wav")
    end

    -- ???
    self.Attachments.BaseClass = nil

    local presetTbl


    -- New behavior
    local filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. presetname .. ".json"
    if file.Exists(filename, "DATA") then
        presetTbl = util.JSONToTable(file.Read(filename))
        if presetTbl and presetTbl != {} then
            for i = 1, table.Count(self.Attachments) do
                local ok = true

                if !presetTbl[i] or !ArcCW.AttachmentTable[presetTbl[i].Installed or ""] then
                    ok = false
                end

                if !ok then
                    presetTbl[i] = nil
                end
            end
        end
    end

    -- Legacy behavior
    filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. presetname .. ".txt"
    if presetTbl == nil and file.Exists(filename, "DATA") then
        local f = file.Open(filename, "r", "DATA")
        if !f then return end

        presetTbl = {}

        for i = 1, table.Count(self.Attachments) do
            local line = f:ReadLine()
            if !line then continue end
            local split = string.Split(string.Trim(line, "\n"), ",")
            if !ArcCW.AttachmentTable[split[1]] then continue end
            presetTbl[i] = {
                Installed = split[1],
                SlidePos = split[2] and tonumber(split[2]),
                SightMagnifications = split[3] and tonumber(split[3]),
                ToggleNum = nil, -- not implemented in legacy preset
            }
        end
        f:Close()
    end

    if !presetTbl then return end

    net.Start("arccw_applypreset")
    net.WriteEntity(self)
    for k, v in pairs(self.Attachments) do
        local att = (presetTbl[k] or {}).Installed

        if !att or !ArcCW.AttachmentTable[att] then
            net.WriteUInt(0, ArcCW.GetBitNecessity())
            continue
        end

        net.WriteUInt(ArcCW.AttachmentTable[att].ID, ArcCW.GetBitNecessity())

        net.WriteBool(presetTbl[k].SlidePos)
        if presetTbl[k].SlidePos then
            net.WriteFloat(presetTbl[k].SlidePos)
        end

        if ArcCW.AttachmentTable[att].ToggleStats != nil then
            net.WriteUInt(presetTbl[k].ToggleNum or 1, 8)
        end
        v.ToggleNum = presetTbl[k].ToggleNum or 1

        -- not networked
        self.SightMagnifications[k] = presetTbl[k].SightMagnifications
    end
    net.SendToServer()

    --[[]
    for i = 1, table.Count(self.Attachments) do
        local att = presetTbl[i]
        if !att then continue end

        if ArcCW:PlayerGetAtts(self:GetOwner(), att) == 0 then continue end
        if !self.Attachments[i] then continue end

        -- detect commas
        -- no commas = do nothing
        -- commas: If exactly two commas are detected
        -- try to parse them as slidepos, magnification

        local split = string.Split(att, ",")
        local sc = table.Count(split)

        local slidepos = 0.5
        local mag = -1

        if sc == 3 then
            att = split[1]
            slidepos = tonumber(split[2])
            mag = tonumber(split[3])
        end

        if att == self.Attachments[i].Installed then continue end

        self:Detach(i, true, true)

        if !ArcCW.AttachmentTable[att] then continue end

        self:Attach(i, att, true, true)

        if slidepos != 0.5 then
            self.Attachments[i].SlidePos = slidepos
        end

        if mag != -1 then
            self.SightMagnifications[i] = mag
        end
    end

    self:SendAllDetails()

    self:SavePreset()
    ]]
end

function SWEP:SavePreset(presetname)
    presetname = presetname or "autosave"
    if presetname == "autosave" and !ArcCW.ConVars["attinv_free"]:GetBool() then return end

    local presetTbl = {}
    for i, k in pairs(self.Attachments) do
        if k.Installed then
            presetTbl[i] = {
                Installed = k.Installed,
                SlidePos = k.SlidePos,
                SightMagnifications = self.SightMagnifications[i],
                ToggleNum = k.ToggleNum
            }
        end
    end

    filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. presetname .. ".json"
    file.CreateDir(ArcCW.PresetPath .. self:GetPresetBase())
    file.Write(filename, util.TableToJSON(presetTbl))

    local legacy_filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. presetname .. ".txt"
    if file.Exists(legacy_filename, "DATA") then
        file.Delete(legacy_filename)
    end

    -- Legacy presets
    --[[]
    local str = ""
    for i, k in pairs(self.Attachments) do
        if k.Installed then
            str = str .. k.Installed
            if k.SlidePos or self.SightMagnifications[i] then
                str = str .. "," .. tostring(k.SlidePos or 0.5) .. "," .. tostring(self.SightMagnifications[i] or -1)
            end
        end

        str = str .. "\n"
    end

    filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. filename .. ".txt"

    file.CreateDir(ArcCW.PresetPath .. self:GetPresetBase())
    file.Write(filename, str)
    ]]
end

function SWEP:CreatePresetSave()
    if !IsValid(ArcCW.InvHUD) then return end
    local bg = vgui.Create("DFrame", ArcCW.InvHUD)
    bg:SetPos(0, 0)
    bg:SetSize(ScrW(), ScrH())
    bg:SetText("")
    bg:SetTitle("")
    bg:SetDraggable(false)
    bg:ShowCloseButton(false)
    bg.Paint = function(span)
        surface.SetDrawColor(0, 0, 0, 200)
        surface.DrawRect(0, 0, ScrW(), ScrH())
    end
    bg:MakePopup()

    local text = vgui.Create("DTextEntry", bg)
    text:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(26))
    text:Center()
    text:RequestFocus()
    text:SetFont("ArcCW_24")
    text:SetText(self.LastPresetName or "")

    local accept = vgui.Create("DButton", bg)
    accept:SetSize((ScreenScaleMulti(256) - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
    accept:SetText("")
    accept:SetPos((ScrW() - ScreenScaleMulti(256)) / 2, ((ScrH() - ScreenScaleMulti(14)) / 2) + ScreenScaleMulti(26) + ScreenScaleMulti(2))

    accept.OnMousePressed = function(spaa, kc)
        local txt = text:GetText()
        txt = string.sub(txt, 0, 36)
        self.LastPresetName = txt
        self:SavePreset(txt)
        bg:Close()
        bg:Remove()

        ArcCW.InvHUD_FormPresets()
    end

    accept.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = "Save"

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(2), ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local cancel = vgui.Create("DButton", bg)
    cancel:SetSize((ScreenScaleMulti(256) - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
    cancel:SetText("")
    cancel:SetPos(((ScrW() - ScreenScaleMulti(256)) / 2) + ScreenScaleMulti(128 + 1), ((ScrH() - ScreenScaleMulti(14)) / 2) + ScreenScaleMulti(26) + ScreenScaleMulti(2))

    cancel.OnMousePressed = function(spaa, kc)
        bg:Close()
        bg:Remove()
    end

    cancel.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = "Cancel"

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(2), ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end
end

function SWEP:CreatePresetMenu()
    if !IsValid(ArcCW.InvHUD) then return end

    if !IsValid(ArcCW.InvHUD) then return end
    local bg = vgui.Create("DFrame", ArcCW.InvHUD)
    bg:SetPos(0, 0)
    bg:SetSize(ScrW(), ScrH())
    bg:SetText("")
    bg:SetTitle("")
    bg:SetDraggable(false)
    bg:ShowCloseButton(false)
    bg.Paint = function(span)
        surface.SetDrawColor(0, 0, 0, 200)
        surface.DrawRect(0, 0, ScrW(), ScrH())
    end

    local cancel = vgui.Create("DButton", bg)
    cancel:SetSize(ScreenScaleMulti(128), ScreenScaleMulti(14))
    cancel:SetText("")
    cancel:SetPos((ScrW() - ScreenScaleMulti(128)) / 2, ScrH() - ScreenScaleMulti(32))

    cancel.OnMousePressed = function(spaa, kc)
        bg:Close()
        bg:Remove()
    end

    cancel.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = "Cancel"

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(2), ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local presetsmenu = vgui.Create("DScrollPanel", bg)
    presetsmenu:SetText("")
    presetsmenu:SetSize(ScreenScaleMulti(256), ScrH() - ScreenScaleMulti(64))
    presetsmenu:SetPos((ScrW() - ScreenScaleMulti(256)) / 2, ScreenScaleMulti(8))
    presetsmenu.Paint = function(span, w, h)
    end

    local sbar = presetsmenu:GetVBar()
    sbar.Paint = function() end

    sbar.btnUp.Paint = function(span, w, h)
    end

    sbar.btnDown.Paint = function(span, w, h)
    end

    sbar.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(0, 0, w, h)
    end

    local c = 0

    for i, k in pairs(self:GetPresets()) do
        if string.StripExtension(k) == "autosave" then continue end
        local preset = vgui.Create("DButton", presetsmenu)
        preset:SetSize(ScreenScaleMulti(254), ScreenScaleMulti(14))
        preset:SetText("")
        preset:Dock(TOP)
        preset:DockMargin( 0, 0, 0, ScreenScaleMulti(2) )

        preset.PresetName = string.StripExtension(k) --string.sub(k, 1, -5)
        preset.PresetFile = k

        preset.OnMousePressed = function(spaa, kc)
            self.LastPresetName = spaa.PresetName
            self:LoadPreset(spaa.PresetName)
            bg:Close()
            bg:Remove()
        end

        preset.Paint = function(spaa, w, h)
            if !self:IsValid() then return end
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(2), ScreenScaleMulti(1))
            surface.SetFont("ArcCW_12")
            surface.DrawText(string.upper(spaa.PresetName))
        end

        local close = vgui.Create("DButton", preset)
        close:SetSize(ScreenScaleMulti(16), ScreenScaleMulti(16))
        close:SetText("")
        close:Dock(RIGHT)

        close.OnMousePressed = function(spaa, kc)
            local filename = spaa.PresetFile
            file.Delete(filename)
            preset:Remove()
        end

        close.Paint = function(spaa, w, h)
            if !self:IsValid() or preset:IsHovered() then return end
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            local w_x, h_x = surface.GetTextSize("×")
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos((ScreenScaleMulti(16) - w_x) / 2, (ScreenScaleMulti(16) - h_x) / 2)
            surface.SetFont("ArcCW_12")
            surface.DrawText("×")
        end
        c = c + 1
    end

    if c == 0 then
        local label = vgui.Create("DLabel", presetsmenu)
        label:SetSize(ScreenScaleMulti(254), ScreenScaleMulti(14))
        label:SetText("")
        label:Dock(TOP)
        label:DockMargin( 0, 0, 0, ScreenScaleMulti(2) )

        label.Paint = function(spaa, w, h)
            local Bfg_col = Color(255, 255, 255, 255)

            local txt = "No presets found! Go make some!"

            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(2), ScreenScaleMulti(1))
            surface.SetFont("ArcCW_12")
            surface.DrawText(txt)
        end
    end
end

function SWEP:ClosePresetMenu()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_base/sh_custom.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_freeaim.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_rocket.lua:
function SWEP:FireRocket(ent, vel, ang, dontinheritvel)
    if CLIENT then return end

    local rocket = ents.Create(ent)

    ang = ang or (self:GetOwner():EyeAngles() + self:GetFreeAimOffset())

    local src = self:GetShootSrc()

    if !rocket:IsValid() then print("!!! INVALID ROUND " .. ent) return end

    local rocketAng = Angle(ang.p, ang.y, ang.r)
    if ang and self.ShootEntityAngleCorrection then
        local up = ang:Up()
        local right = ang:Right()
        local forward = ang:Forward()
        rocketAng:RotateAroundAxis(up, self.ShootEntityAngleCorrection.y)
        rocketAng:RotateAroundAxis(right, self.ShootEntityAngleCorrection.p)
        rocketAng:RotateAroundAxis(forward, self.ShootEntityAngleCorrection.r)
    end

    rocket:SetAngles(rocketAng)
    rocket:SetPos(src)

    rocket:SetOwner(self:GetOwner())

    rocket.Inflictor = self

    local randfactor = self:GetBuff("DamageRand")
    local mul = 1
    if randfactor > 0 then
        mul = mul * math.Rand(1 - randfactor, 1 + randfactor)
    end
    rocket.Damage = self:GetBuff("Damage") * mul

    if self.BlastRadius then
        local r_randfactor = self:GetBuff("DamageRand")
        local r_mul = 1
        if r_randfactor > 0 then
            r_mul = r_mul * math.Rand(1 - r_randfactor, 1 + r_randfactor)
        end
        rocket.BlastRadius = self:GetBuff("BlastRadius") * r_mul
    end

    local RealVelocity = (!dontinheritvel and self:GetOwner():GetAbsVelocity() or Vector(0, 0, 0)) + ang:Forward() * vel
    rocket.CurVel = RealVelocity -- for non-physical projectiles that move themselves

    rocket:Spawn()
    rocket:Activate()
    if !rocket.NoPhys and rocket:GetPhysicsObject():IsValid() then
        rocket:SetCollisionGroup(rocket.CollisionGroup or COLLISION_GROUP_DEBRIS)
        rocket:GetPhysicsObject():SetVelocityInstantaneous(RealVelocity)
    end

    if rocket.Launch and rocket.SetState then
        rocket:SetState(1)
        rocket:Launch()
    end

    if rocket.ArcCW_Killable == nil then
        rocket.ArcCW_Killable = true
    end

    rocket.ArcCWProjectile = true

    self:GetBuff_Hook("Hook_PostFireRocket", rocket)

    return rocket
end
--PATH lua/weapons/arccw_base/sh_ubgl.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a280c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "A-280c"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The A280 blaster rifle was a type of blaster rifle mostly used by Rebel Alliance troopers and New Republic soldiers. There existed two variants of the A280 blaster, the A280C and the A280-CFE, both of which were favored by commandos and special force of the Rebel Alliance."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/a280c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000100000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_a280c.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(0.9, 0.5, -2.9),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 32
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 320
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.70
SWEP.RecoilPunch = 0.85

SWEP.Delay = 60 / 550
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_A280"
SWEP.ShootSound = "ArcCW_Kraken.SW_A280"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -4, 1.1),
    Ang = Angle(0, 0, 2.5),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -2, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, 0)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, -3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["optic_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 4, bg = 0}},
    },
    ["foregrip_attach"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_sling",
        InstalledEles = {"optic_attach"},
        Offset = {
            vpos = Vector(4, 0, 1.5),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(24.5, -0.05, 0),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        InstalledEles = {"laser_attach"},
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(13.4, 0.8, 0.3),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_sling",
        InstalledEles = {"foregrip_attach"},
        Offset = {
            vpos = Vector(13, 0.1, -0.38),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(6.6, -0.6, -1.3),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(2.5, -0.6, 0),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/a280/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
			{s = path .. "wpfoly_mike4_reload_lift_v2.ogg", t = 0.1/30},
            {s = "ArcCW_Kraken.Overheat", t = 19/30},
			{s = path .. "wpfoly_mike4_reload_magout_v2.ogg", t = 18/30},
			{s = path .. "wpfoly_mike4_reload_magin_01.ogg", t = 28/30},
			{s = path .. "wpfoly_mike4_reload_magin_v2.ogg", t = 31/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 32/30},
			{s = path .. "wpfoly_mike4_reload_end_v2.ogg", t = 52/30},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
			{s = path .. "wpfoly_mike4_reload_empty_lift_v2.ogg", t = 0.1/30},
			{s = path .. "wpfoly_mike4_reload_empty_magout_v2.ogg", t = 5/30},
            {s = "ArcCW_Kraken.Overheat", t = 6/30},
			{s = path .. "wpfoly_mike4_reload_empty_magin_v2.ogg", t = 31/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 32/30},
			{s = path .. "wpfoly_mike4_reload_empty_chamber_v2.ogg", t = 53/30},
			{s = path .. "wpfoly_mike4_reload_empty_end_v2.ogg", t = 63/30},
        },
    },
    ["ready"] = {
        Source = "draw",
		MinProgress = 0.6,
        SoundTable = {
            {s = path .. "wpfoly_mike4_raise_first_01.ogg", t = 0.2},
            {s = path .. "wpfoly_mike4_raise_first_02.ogg", t = 0.85},
            {s = path .. "wpfoly_mike4_raise_first_03.ogg", t = 1.3},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wpfoly_mike4_raise_v2.ogg", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		--Mult = 0.8,
        SoundTable = {
            {s = path .. "wpfoly_mike4_drop_v2.ogg", t = 0.1/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["inspect"] = {
        Source = "lookat01",
        LHIK = true,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_ar_mike4_inspect_01.ogg", t = 0},
			{s = path .. "wfoly_ar_mike4_inspect_02.ogg", t = 1.3},
			{s = path .. "wfoly_ar_mike4_inspect_03.ogg", t = 2.36},
			{s = path .. "wfoly_ar_mike4_inspect_04.ogg", t = 3.6},
			{s = path .. "wfoly_ar_mike4_inspect_05.ogg", t = 4.2},
        },
    },
    ["bash"] = {
        Source = {"melee", "melee2", "melee3"},
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "weap_m4_selector_semi_on_03.ogg", t = 0.1/30},
        },
    },
    ["fix"] = {
        Source = "unjam",
        MinProgress = 0.4,
        FireASAP = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 5/30},
			{s = path .. "wpfoly_mike4_reload_empty_lift_v2.ogg", t = 5/30},
            {s = path .. "wpfoly_mike4_jam_bolt.ogg", t = 10/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 34/30},
			{s = path .. "wpfoly_mike4_reload_empty_chamber_v2.ogg", t = 25/30},
			{s = path .. "wpfoly_mike4_reload_empty_end_v2.ogg", t = 34/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a620.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "A-620"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The A280 blaster rifle was a type of blaster rifle mostly used by Rebel Alliance troopers and New Republic soldiers. There existed two variants of the A280 blaster, the A280C and the A280-CFE, both of which were favored by commandos and special force of the Rebel Alliance."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/a620.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0110101000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_a280c.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(0.9, 0.5, -2.9),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 48
SWEP.DamageMin = 28
SWEP.RangeMin = 0
SWEP.Range = 540
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 45

SWEP.Recoil = 1.15
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.78
SWEP.RecoilPunch = 1.1

SWEP.Delay = 60 / 320
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_A280"
SWEP.ShootSound = "ArcCW_Kraken.SW_A280"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -4, 1.1),
    Ang = Angle(0, 0, 2.5),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CrouchPos = Vector(-4, 0, 0)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, -3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["optic_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 4, bg = 0}},
    },
    ["foregrip_attach"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_sling",
        InstalledEles = {"optic_attach"},
        Offset = {
            vpos = Vector(4, 0, 1.5),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(30.5, -0.05, 0.05),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        InstalledEles = {"laser_attach"},
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(13.4, 0.8, 0.3),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_sling",
        InstalledEles = {"foregrip_attach"},
        Offset = {
            vpos = Vector(13, 0.1, -0.38),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(6.6, -0.6, -1.3),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(2.5, -0.6, 0),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/a280/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
			{s = path .. "wpfoly_mike4_reload_lift_v2.ogg", t = 0.1/30},
            {s = "ArcCW_Kraken.Overheat", t = 19/30},
			{s = path .. "wpfoly_mike4_reload_magout_v2.ogg", t = 18/30},
			{s = path .. "wpfoly_mike4_reload_magin_01.ogg", t = 28/30},
			{s = path .. "wpfoly_mike4_reload_magin_v2.ogg", t = 31/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 32/30},
			{s = path .. "wpfoly_mike4_reload_end_v2.ogg", t = 52/30},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
			{s = path .. "wpfoly_mike4_reload_empty_lift_v2.ogg", t = 0.1/30},
			{s = path .. "wpfoly_mike4_reload_empty_magout_v2.ogg", t = 5/30},
            {s = "ArcCW_Kraken.Overheat", t = 6/30},
			{s = path .. "wpfoly_mike4_reload_empty_magin_v2.ogg", t = 31/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 32/30},
			{s = path .. "wpfoly_mike4_reload_empty_chamber_v2.ogg", t = 53/30},
			{s = path .. "wpfoly_mike4_reload_empty_end_v2.ogg", t = 63/30},
        },
    },
    ["ready"] = {
        Source = "draw",
		MinProgress = 0.6,
        SoundTable = {
            {s = path .. "wpfoly_mike4_raise_first_01.ogg", t = 0.2},
            {s = path .. "wpfoly_mike4_raise_first_02.ogg", t = 0.85},
            {s = path .. "wpfoly_mike4_raise_first_03.ogg", t = 1.3},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wpfoly_mike4_raise_v2.ogg", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		--Mult = 0.8,
        SoundTable = {
            {s = path .. "wpfoly_mike4_drop_v2.ogg", t = 0.1/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["inspect"] = {
        Source = "lookat01",
        LHIK = true,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_ar_mike4_inspect_01.ogg", t = 0},
			{s = path .. "wfoly_ar_mike4_inspect_02.ogg", t = 1.3},
			{s = path .. "wfoly_ar_mike4_inspect_03.ogg", t = 2.36},
			{s = path .. "wfoly_ar_mike4_inspect_04.ogg", t = 3.6},
			{s = path .. "wfoly_ar_mike4_inspect_05.ogg", t = 4.2},
        },
    },
    ["bash"] = {
        Source = {"melee", "melee2", "melee3"},
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "weap_m4_selector_semi_on_03.ogg", t = 0.1/30},
        },
    },
    ["fix"] = {
        Source = "unjam",
        MinProgress = 0.4,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 5/30},
			{s = path .. "wpfoly_mike4_reload_empty_lift_v2.ogg", t = 5/30},
            {s = path .. "wpfoly_mike4_jam_bolt.ogg", t = 10/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 34/30},
			{s = path .. "wpfoly_mike4_reload_empty_chamber_v2.ogg", t = 25/30},
			{s = path .. "wpfoly_mike4_reload_empty_end_v2.ogg", t = 34/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_bryar.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cr2.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15a_stun.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17_stun.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17ext.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17ext.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-17 Extended"
SWEP.Trivia_Class = "Hand Blaster"
SWEP.Trivia_Desc = "The DC-17 repeater hand blaster, also known more simply as the DC-17 hand blaster or DC-17 blaster pistol, was a model of heavy blaster pistol and the Grand Army of the Republic's standard-issue sidearm. Produced by BlasTech Industries, the DC-17 was usually given to weapon teams, the crews of vehicles, and officers. The weapon was one of the most reliable and toughest models of blaster pistols created, as well as having remarkable stopping power in its small design. The weapon was also well balanced, possessed a respectable rate of fire, and lightweight."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17_ext.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17ext.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-16, 5, -3.4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 13
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 28
SWEP.DamageMin = 16
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 22

SWEP.Recoil = 1.13
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.67

SWEP.Delay = 60 / 190
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.79, -6.251, 0.1),
    Ang = Vector(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(0, -6, -9)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(0, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.AttachmentElements = {
    ["akimbo"] = {
        Override_ActivePos = Vector(2, -2, 0),
        Override_CrouchPos = Vector(0, -3, 0),	
        Override_CrouchAng = Angle(0, 0, 0),
        Override_HolsterPos = Vector(2,2,2),
        Override_HolsterAng = Angle(-20, 0, -5),		
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Hook_SelectReloadAnimation = function(wep, anim)
    if wep.Attachments[4].Installed then
        return anim .. "_akimbo"
    end

    return anim
end

SWEP.Attachments = {
    {
        PrintName = "Optic",
        Slot = "optic",
        Bone = "frame",
        InstalledEles = {"scope_attach"},
        DefaultAttName = "DC-17 Holosight",
        Offset = {
            vpos = Vector(-2, 4.7, 0.13),
            vang = Angle(180,0,90),
        },
        VMScale = Vector(1.25, 1.25, 1.25),
    },
    {
        PrintName = "Tactical",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "frame",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-8.6, 1.3, 0.15),
            vang = Angle(180,0,90),
        },
        ExtraSightDist = 9,
        CorrectivePos = Vector(1, 0, -1),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "frame",
        Offset = {
            vpos = Vector(-10.4, 2.7, 0.11),
            vang = Angle(180,0,90),
        },
    },
    {
        PrintName = "Left Hand",
        Slot = {"gso_extra_pistol_akimbo", "mifl_fas2_akimbo", "akimbotest"},
        Bone = "Akimbo_Base",
        DefaultAttName = "None",
        Offset = {
            vpos = Vector(6, -2.8, 0.2),
            vang = Angle(0, 0, 0),
        },
        InstalledEles = {"akimbo"},
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode_pistol"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "frame",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.3, -1, -0.55),
            vang = Angle(180,0,90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "frame",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-8, 1.95, -0.87),
            vang = Angle(180,0,90),
        },
    },     
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["ready"] = {
        Source = "draw",
    },
    ["fire"] = {
        Source = "fire1",
        ShellEjectAt = false,
    },
    ["fire_iron"] = {
        Source = "fire_scoped2",
        ShellEjectAt = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.8,
        LHIKEaseOut = 0.5,
        SoundTable = {
            {s = "arccw/kraken/republic/dc17/handling/magout.wav", t = 5 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin_partial.wav", t = 30 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin.wav", t = 40 / 30},
        },
    },
--------------------------------------------------------
    ["reload_akimbo"] = {
        Source = "reload_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_empty_akimbo"] = {
        Source = "reload_empty_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_akimbo"] = {
        Source = "reload_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_empty_akimbo"] = {
        Source = "reload_empty_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },

    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 75 / 30},
            {s = "ArcCW_Kraken.Grab", t = 78 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17ext_akimbo.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17s.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17s_dual.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Dual DC-17s"
SWEP.Trivia_Class = "Hand Blaster"
SWEP.Trivia_Desc = "The DC-17 repeater hand blaster, also known more simply as the DC-17 hand blaster or DC-17 blaster pistol, was a model of heavy blaster pistol and the Grand Army of the Republic's standard-issue sidearm. Produced by BlasTech Industries, the DC-17 was usually given to weapon teams, the crews of vehicles, and officers. The weapon was one of the most reliable and toughest models of blaster pistols created, as well as having remarkable stopping power in its small design. The weapon was also well balanced, possessed a respectable rate of fire, and lightweight."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17s_dual.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "001110111000"

SWEP.MirrorVMWM = false
SWEP.NoHideLeftHandInCustomization = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17s_akimbo.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 65

SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 28
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.1
SWEP.RecoilPunch = 2.5
SWEP.RecoilVMShake = 0.1

SWEP.Delay = 60 / 285
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = nil
SWEP.MuzzleFlashColor = nil

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(0,0,0),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = "duel"
SWEP.HoltypeCustomize = "normal"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(0, -10, -10)
SWEP.SprintAng = Angle(25, 0, 0)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(0, -5.226, 1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, -4, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"dc17"}
SWEP.AttachmentElements = {
    ["dc17"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/republic/v_dc17s.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                ModelBodygroups = "001110000",
                Scale = Vector(1,1,1),
                Offset = {
                    pos = Vector(-170, 50, -65),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kraken/republic/v_dc17s.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                ModelBodygroups = "001110000",
                Scale = Vector(1,1,1),
                Offset = {
                    pos = Vector(-265, 275, -120),
                    ang = Angle(180, -180, 2)
                }
            },
        },   
    },
}
WMOverride = "models/arccw/kraken/republic/v_dc17s.mdl"

SWEP.Attachments = {
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo"}
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_pistol"},
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    }, 
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
    },
    ["idle_iron"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 25/30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["enter_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
    ["idle_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17sa_dual.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Dual DC-17sa"
SWEP.Trivia_Class = "Hand Blaster"
SWEP.Trivia_Desc = "The DC-17 repeater hand blaster, also known more simply as the DC-17 hand blaster or DC-17 blaster pistol, was a model of heavy blaster pistol and the Grand Army of the Republic's standard-issue sidearm. Produced by BlasTech Industries, the DC-17 was usually given to weapon teams, the crews of vehicles, and officers. The weapon was one of the most reliable and toughest models of blaster pistols created, as well as having remarkable stopping power in its small design. The weapon was also well balanced, possessed a respectable rate of fire, and lightweight."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17sa_dual.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000110011000"

SWEP.MirrorVMWM = false
SWEP.NoHideLeftHandInCustomization = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17s_akimbo.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 65

SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 180
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.9
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = nil
SWEP.MuzzleFlashColor = nil

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(0,0,0),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = "duel"
SWEP.HoltypeCustomize = "normal"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(0, -10, -10)
SWEP.SprintAng = Angle(25, 0, 0)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(0, -5.226, 1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, -4, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"dc17"}
SWEP.AttachmentElements = {
    ["dc17"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/republic/v_dc17s.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                ModelBodygroups = "0001100000",
                Scale = Vector(1,1,1),
                Offset = {
                    pos = Vector(-170, 50, -65),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kraken/republic/v_dc17s.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                ModelBodygroups = "0001100000",
                Scale = Vector(1,1,1),
                Offset = {
                    pos = Vector(-265, 275, -120),
                    ang = Angle(180, -180, 2)
                }
            },
        },   
    },
}
WMOverride = "models/arccw/kraken/republic/v_dc17s.mdl"

SWEP.Attachments = {
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo"}
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_pistol"},
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    }, 
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
    },
    ["idle_iron"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 25/30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["enter_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
    ["idle_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_defender_s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Defender"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The Defender sporting blaster pistol was made by the Drearian Defense Conglomerate. The DDC Defender was a short range and low-powered weapon, meant for civilian self-defense and small-game hunting. It was also a popular weapon for use in honor duels among the nobility."
SWEP.Trivia_Manufacturer = "Drearian Defense Conglomerate"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/defender_s.png"

-- Base
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_defender.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 13
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 34
SWEP.DamageMin = 16
SWEP.RangeMin = 0
SWEP.Range = 340
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.2
SWEP.RecoilSide = 0.65
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 220
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DEFENDER"
SWEP.ShootSound = "ArcCW_Kraken.SW_DEFENDER"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.045, -11.296, 0.8),
    Ang = Angle(0.5,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -1.8, -3.2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0, -1.4, 3.9),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.36, -1.35, 2),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.35, -1, -3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.35, -1, -1),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dh17e.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DH-17e"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DH-17 blaster pistol was commonly used by soldiers of the Rebel Alliance for conflicts aboard starships, and sometimes the officers of the Galactic Empire carried it instead of the standard E-11 medium blaster rifles. The DH-17 blaster rifle was a rifle version that featured a shoulder stock, and a hand-calibrated macroscopes. The rifles were black and silver in color."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dh17e.png"

-- Base
SWEP.DefaultBodygroups = "011000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dh17_pistols.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 18
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 30
SWEP.DamageMin = 23
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 32

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.2

SWEP.Delay = 60 / 345
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.04, -11.296, 1.25),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 2}, {ind = 2, bg = 2}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -2.35, -5.2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0, -1, 2.1),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.3, -1.2, -1),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.39, -0.1, -2.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.6, -0.9, -4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl18d.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl44e.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DL-44e"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DL-44 heavy blaster pistol, also known more simply as a DL-44 blaster pistol, was a type of heavy blaster pistol produced by BlasTech Industries that was used during the years of the Galactic Republic and the Age of the Empire. It was considered one of the most powerful blaster pistols in the galaxy, delivering massive damage at close range; however, it overheated quickly. This pistol can also be reconfigure into a blaster rifle by including an extended barrel with the existing flash-suppressor and an attachable stock. This version was used by Tobias Beckett in the trenches of Mimban before he deconstructed his DL-44 and gave it to Han Solo, who used it for the rest of his life."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dl44e.png"

-- Base
SWEP.DefaultBodygroups = "011000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dl44.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 62
SWEP.DamageMin = 45
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 28

SWEP.Recoil = 1.1
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DH17"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.04, -11.296, 0.5),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.05, -2.8, -3.3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.7, -1.2, -1),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.4, -0.5, -0.6),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.4, -0.9, -2.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt74.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dp23c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_f11d.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "F-11d"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The F-11D blaster rifle was a blaster rifle manufactured by Sonn-Blas Corporation. This ranged weapon was the successor of the older E-11 medium blaster rifle used by the Galactic Empire. It served as the standard issue weapon of First Order stormtroopers."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Calibre = "Sonn-Blas Corporation"
SWEP.IconOverride = "entities/kraken/galactic/f11d.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00001100000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_f11d.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 56
SWEP.DamageMin = 29
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 1.2
SWEP.RecoilSide = 0.54
SWEP.RecoilRise = 0.97
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 340
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_F10"
SWEP.ShootSound = "ArcCW_Kraken.SW_F10"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.9, 0, 1.3),
    Ang = Vector(2, -0.3, 1),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 2, 0)
SWEP.ActiveAng = Angle(0, -0.3, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 4, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 10, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.2, -3.2, 1.1),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.9, 4, 0.25),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.1, 1.1, 1.1),
        WMScale = Vector(1.1, 1.1, 1.1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.1, 9, 0.1),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.93, -1.5, -0.1),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, -3.6, -0.25),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "shoot",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_fwmb10.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "FWMB-10"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "The FWMB-10 repeating blaster, also known as the megablaster,[3] was a repeating blaster manufactured by the Sonn-Blas Corporation.[1] The FWMB-10s used by First Order megablaster heavy assault troopers—who earned their name from their use of the blaster[1]— featured integrated stands that could fold out from the blaster,[4] as well as barrel cooling shrouds.[1] Light Infantry Utility Vehicles also used pintle-mounted megablasters as their primary armament.[1] These forward-mounted[5] FWMB-10s had steadying grips and trigger levers, data and power feeds, calibration adjustment, elevation gear, a collimator ring, and collimator sleeves.[1] It was powered by an Eksoan Class-5B1 duplex power generator.[6] The FWMB-10K was a smaller variant of the FWMB-10.[7]"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/fwmb10.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_fwmb10k.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 30
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 28
SWEP.DamageMin = 25
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 70

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 400
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_FWMB"
SWEP.ShootSound = "ArcCW_Kraken.SW_FWMB"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.138, 0, 0.982),
    Ang = Vector(0, 0, -4.242),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, -4)

SWEP.CrouchPos = Vector(0, 0, 1)
SWEP.CrouchAng = Angle(0, 0, -4)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-1.2, 10.15, 0.3),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.2, 22, 0.),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-0., 7, -0.8),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.4, -3.6, 0.5),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.1, 0, -0.35),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_hh12.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_smartlauncher.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Explosives - Rocket Launchers"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Smart Launcher"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "The Smart Rocket was a powerful rocket/missile hybrid used by both the Galactic Empire and Rebel Alliance during the Galactic Civil War, and later by the Resistance and First Order in their conflict decades later. The Smart Rocket was also used by the Galactic Republic prior to the formation of the Empire."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Rocket"
SWEP.Trivia_Mechanism = "Kabum"
SWEP.Trivia_Country = " Universal"
SWEP.IconOverride = "entities/kraken/explosives/smartlauncher.png"

-- Base
SWEP.DefaultBodygroups = "0100000000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_smartlauncher.mdl"
SWEP.MirrorWorldModel = "models/arccw/kraken/sw/explosives/v_smartlauncher_mirror.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-4.5, 1.3, -5),
    ang = Angle(0, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.ShootEntity = "rocket_rps"
SWEP.MuzzleVelocity = 6000

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.Recoil = 3.2
SWEP.RecoilSide = 0.550
SWEP.RecoilRise = 1.7
SWEP.RecoilPunch = 2
SWEP.RecoilVMShake = 1.5
SWEP.VisualRecoilMult = 0.7

SWEP.Delay = 60 / 60
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 500

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "RPG_Round"
SWEP.ShootVol = 120
SWEP.ShootPitch = 95
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/launchers/smartlauncher/bazooka_fp.wav"
SWEP.ShootSound = "kraken/launchers/smartlauncher/bazooka_fp.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "muzzleflash_m79"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 142, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 0),
    Ang = Vector(5, 0, -5),
     Magnification = 1.5,
     SwitchToSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_up.ogg",
     SwitchFromSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_down.ogg",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "rpg"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, -4, 0)
SWEP.ActiveAng = Angle(5, 0, -5)

SWEP.SprintPos = Vector(4.019, -5.226, -2)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CrouchPos = Vector(-4.5, -7, -3)
SWEP.CrouchAng = Angle(0, 0, -29)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "Weapon",
        Offset = {
            vpos = Vector(1.33, 18, 2.8),
            vang = Angle(90, -90, 0),
        },
    }, 
    {
        PrintName = "Ammunition",
        DefaultAttName = "Rocket",
        Slot = {"k_rocket_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "Weapon",
        Offset = {
            vpos = Vector(1.67, 11.8, 2.54),
            vang = Angle(0, -90, 0),
        },
    },
}

-- Animations!
local path = "kraken/launchers/smartlauncher/bazooka_"

SWEP.Animations = {
    ["idle"] = { Source = "base_idle" },
    ["idle_iron"] = { Source = false, },
    ["fire"] = { Source = "base_fire" },
    ["fire_iron"] = { Source =  false, },
    ["enter_sights"] = { Source = false, },
    ["dryfire"] = { Source = "base_dryfire" },
    ["dryfire_iron"] = { Source = "iron_dryfire" },
    ["reload"] = { Source = "base_reload", TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, MinProgress = 0.75, MagSwapTime = 0.75, Mult = 0.9,  
    SoundTable = {
        {t = 50 / 32.5, s = path .. "fetch.wav"},
        {t = 78 / 32.5, s = path .. "load1.wav"},
        {t = 87 / 32.5, s = path .. "load2.wav"},
        {t = 114 / 32.5, s = path .. "wire.wav"},
        {t = 160 / 32.5, s = path .. "reshoulder.wav"},
        {t = 199 / 32.5, s = path .. "shoulder.wav"},
    } },
    ["ready"] = { Source = "base_ready", MinProgress = 1, FireASAP = true, 
    SoundTable = {
        {t = 0 / 30, s = path .. "fetch.wav" },
        {t = 47 / 30, s = path .. "fetch.wav"},
        {t = 75 / 30, s = path .. "load1.wav"},
        {t = 84 / 30, s = path .. "load2.wav"},
        {t = 112 / 30, s = path .. "wire.wav"},
        {t = 160 / 30, s = path .. "reshoulder.wav"},
        {t = 196 / 30, s = path .. "shoulder.wav"},
    } },
    ["draw"] = { Source = "base_draw", 
    SoundTable = {
        {t = 50 / 32.5, s = path .. "fetch.wav"},
    } },
    ["holster"] = { Source = "base_holster", 
    SoundTable = {
        {t = 50 / 32.5, s = path .. "fetch.wav"},
    } },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_mk2paladin.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "MK II Paladin"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "Blaster Rifle designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/mk2paladin.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_mk2_paladin.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 36
SWEP.DamageMin = 24
SWEP.RangeMin = 0
SWEP.Range = 450
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.05
SWEP.RecoilSide = 0.49
SWEP.RecoilRise = 0.85

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_MK2PALADIN"
SWEP.ShootSound = "ArcCW_Kraken.SW_MK2PALADIN"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.1, -5, 0.7),
    Ang = Vector(4, -0.7, -4),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, -1, 0.5)
SWEP.ActiveAng = Angle(0, 0, -2)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, 20, 0),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.07, -3.1, 1.15),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.6, 14, 0),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.1, 1.1, 1.1),
        WMScale = Vector(1.1, 1.1, 1.1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0, 22.8, 0),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.63, 3, -1.25),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.7, 0.2, 0),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "shoot",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_antitankmine.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_c25.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_c25.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "C-25 Fragmentation Grenade"
SWEP.Trivia_Class = "Hand Grenade, Fragmentation Grenade"
SWEP.Trivia_Desc = "The C-25 fragmentation grenade was a fragmentation grenade manufactured by Merr-Sonn Munitions, Inc.. It consisted of a sphere of baradium-impregnated detonite encased in a conductive shell, which was itself housed within a cylinder that was activated with a twist"
SWEP.Trivia_Manufacturer = "Merr-Sonn Munitions, Inc"
SWEP.Trivia_Calibre = "High Fragmentation Explosive"
SWEP.Trivia_Mechanism = "Explosive"
SWEP.Trivia_Country = "Galactic Empire"
SWEP.IconOverride = "entities/kraken/explosives/c25.png"

-- Base
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_c25.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-10.9, -4, -2),
    ang = Angle(0, 0, -50),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}


-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_c25"

SWEP.MuzzleVelocity = 1050
SWEP.MuzzleVelocityAlt = 500

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 6, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 0.9},
    ["enter_sprint"] = {Source = "sprint_in", Mult = 0.1},
    ["exit_sprint"] = {Source = "sprint_out", Mult = 0.1},
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
        MinProgress = 0.5,
    },
    ["fire"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = {"toss_overhead"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
    },
    ["throw_alt"] = {
        Source = {"underhand"},
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
    },
    ["bash"] = {
        Source = {"melee"},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.6,
        LHIKEaseOut = 0.4,
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
        LHIK = true,
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
        LHIK = true,
    },
    ["idle_inspect"] = {
        Source = "inspect",
        LHIK = true,
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_shock.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_thermal.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Class-A Thermal Detonator"
SWEP.Trivia_Class = "Hand Grenade, High Explosive"
SWEP.Trivia_Desc = "Thermal detonators, also known as thermal charges or thermal devices, were palm-sized, spherical devices that were used as extremely deadly explosive weapons."
SWEP.Trivia_Manufacturer = "BlastTech Industries, Merr-Sonn Munitions Inc."
SWEP.Trivia_Calibre = "Explosive"
SWEP.Trivia_Mechanism = "Thermal Detonator"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/thermal.png"

-- Base
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_thermal.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-9, 6, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}


-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_thermal"

SWEP.MuzzleVelocity = 850
SWEP.MuzzleVelocityAlt = 500

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 6, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "kraken/explosives/rifle_fetch-1.wav", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "kraken/explosives/thermaldetonator/click.wav", t = 0.4},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "kraken/explosives/rifle_fetch-1.wav", t = 0.1},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "throw",
        SoundTable = {
            {s = "kraken/explosives/rifle_fetch-1.wav", t = 0.1},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_thermalimploder.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Thermal Imploder"
SWEP.Trivia_Class = "Hand Grenade, Thermal Implosionator"
SWEP.Trivia_Desc = "Thermal imploders were high explosives carried by Wookiee warriors, Imperial stormtroopers, and Rebel troopers during the Galactic Civil War. The imploder functioned by compressing and heating the surrounding atmosphere, thus creating a vacuum that provides a powerful implosion in a large radius. A thermal imploder could seriously damage a turret, an AT-ST, or kill a squad of infantry if properly used."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Explosive"
SWEP.Trivia_Mechanism = "Thermal Implosion"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/thermalimploder.png"

-- Base
SWEP.DefaultBodygroups = "0000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_thermalimploder.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-16, 6, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_thermalimploder"

SWEP.MuzzleVelocity = 900
SWEP.MuzzleVelocityAlt = 500

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_relbv15.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_sg6.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_westar35_akimbo.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "WESTAR-35 Akimbo"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The WESTAR-35 blaster pistol, also known as the MandalTech Jai'galaar model blaster, was a blaster pistol model manufactured by Concordian Crescent Technologies. They were commonly used by the Mandalorians of Death Watch during the Clone Wars and continued to see use by Mandalorians into the Imperial Era and beyond."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/westar35_akimbo.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_akimbo_westar35.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.NoHideLeftHandInCustomization = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 25
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 192, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_orange"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 48

SWEP.Recoil = 0.8
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.8

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_WESTAR"
SWEP.ShootSound = "ArcCW_Kraken.SW_WESTAR"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = false
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 192, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(0, 0, 0),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = "duel"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -4, -17)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.ReloadPos = Vector(0, -5, -0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(10, 0, 0)

-- Attachments
SWEP.DefaultElements = {"de18dual"}
SWEP.AttachmentElements = {
    ["de18dual"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/galactic/v_westar35.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-200, 70, -65),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kraken/galactic/v_westar35.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-300, 290, -110),
                    ang = Angle(180, -180, 2)
                }
            },
        },   
    }
}WMOverride = "models/arccw/kraken/galactic/v_westar35.mdl"

SWEP.Attachments = {
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    }, 
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
    },
    ["idle_iron"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot_l", "shoot_r"},
        Mult = 2,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 20 / 30},
            {s = "ArcCW_Kraken.Grab", t = 35 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 20 / 30},
            {s = "ArcCW_Kraken.Grab", t = 35 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["enter_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
    ["idle_inspect"] = {
        Source = "lookat01",
        Mult = 2,
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_zerzium.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Zerzium Carbine"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "Blaster Carabine designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/zerzium.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_zersium.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 39
SWEP.DamageMin = 26
SWEP.RangeMin = 0
SWEP.Range = 1000
SWEP.Penetration = 8
SWEP.DamageType = DMG_CRUSH
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "nio_tracer"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.9
SWEP.RecoilSide = 0.44
SWEP.RecoilRise = 0.64

SWEP.Delay = 60 / 320
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_ZERZIUM"
SWEP.ShootSound = "ArcCW_Kraken.SW_ZERZIUM"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.95, 0, 0.7),
    Ang = Vector(2, -0.1, -2),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 11, 0),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.15, -1, 1.85),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.9, 6, 0.6),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0, 17, 0.7),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.54, -1.4, -0.9),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.14, 0.8, 0.75),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH lua/weapons/arccw_rg4d.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "RG-4D"
SWEP.Trivia_Class = "CIS Blaster Pistol"
SWEP.Trivia_Desc = "High tech CIS RG-4D Blaster Pistol"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_rg4d.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 100
SWEP.DamageMin = 17
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 1.4
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 800 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/rg4d.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-3.95, -10, 1.6),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(12.824, -8, -3.897)
SWEP.CustomizeAng = Angle(10.149, 34.547, 0)


SWEP.DefaultElements = {"rg4d"}

SWEP.AttachmentElements = {
    ["rg4d"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/rg4d_blaster.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0, -4, -2.951),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/rg4d_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(80, 20, 15.3),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/kuro/sw_battlefront/weapons/rg4d_blaster.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = {"optic_lp", "optic"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.04, -0.8, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(50, 20, -40),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(11, 11, 11),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -6, 1),
            vang = Angle(0, 90, 0),
            wpos = Vector(90 , 20, -40),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.2, -0.3, 15),
            vang = Angle(90, 0, -90),
            wpos = Vector(170, 20, -67.5),
            wang = Angle(-15, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, -0.6, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(50, 25, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_firepuncher.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_heavyrepeater.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_b0l3.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "B0-L3"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The B0-L3 is a powerful blaster carbine, designed for both military and civilian use. Known for its high-impact energy shots, it delivers exceptional range and stopping power, making it ideal for both combat and personal defense."
SWEP.Trivia_Manufacturer = "Concordian Crescent Technologies"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/b0l3.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_boiler_rifle.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11, 5, -1.5),
    ang = Angle(-15, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 34
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 34
SWEP.DamageMin = 29
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(2500, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_orange"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.4
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 0.9
SWEP.RecoilVMShake = 0.7

SWEP.Delay = 60 / 320
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/boiler.wav"
SWEP.ShootSound = "kraken/sops/boiler.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.114, 0, 0.75),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dc15s",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.25, 0, 24),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dc15s",
        VMScale = Vector(0.9,0.9,0.9),
        WMScale = Vector(0.9,0.9,0.9),
        Offset = {
            vpos = Vector(-0.12, -1.9, 7),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dc15s",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.7, -1.1, 13),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(0.33, 0.2, -4.59),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(0.55, 0.3, 2),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.4,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 80 / 30},
            {s = "ArcCW_Kraken.Grab", t = 85 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}

SWEP.Hook_BulletHit = function(wep, data)
    if CLIENT then return end

    local ent = data.tr.Entity

    ent:Ignite(5, 500)
    if ent:IsOnFire() then
        ent:SetHealth(ent:Health() - 2.5)
    end
end
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_deadmanstale.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Dead Man's Tale"
SWEP.Trivia_Class = "Lever-Action Blaster"
SWEP.Trivia_Desc = "Galactic Lever-Action rifle. Unkown origin. 'Long, short, they all end the same way.'"
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Capsule"
SWEP.IconOverride = "entities/kraken/sops/deadmanstale.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/c_dead_mans_tale.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11.3, 6, -3),
    ang = Angle(-15, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.9,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.ShotgunReload = true
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 95
SWEP.ShellScale = 2

SWEP.Damage = 132
SWEP.DamageMin = 87
SWEP.RangeMin = 0
SWEP.Range = 750
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 14

SWEP.Recoil = 1.25
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/deadmanstale/deadmansfire1.wav"
SWEP.ShootSound = "kraken/sops/deadmanstale/deadmansfire2.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.231, -11.483, 0.837),
    Ang = Vector(0, 0, 1.73),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, -5, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.Attachments = {     
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },  
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle_retracted",
    },
	["fire"] = {
        Source = "shoot",
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "shootiron",
        ShellEjectAt = 0,
    },
    ["sgreload_start"] = {
        Source = "start reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "kraken/sops/deadmanstale/deadmansreloadstart.wav", t = 0.1},
                    },
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0,
    },
    ["sgreload_insert"] = {
        Source = "insert",
        RestoreAmmo = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "kraken/sops/deadmanstale/deadmansreloadinsert.wav", t = 3/30},
                    },
        TPAnimStartTime = 0.3,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["sgreload_finish"] = {
        Source = "finish reload",
        SoundTable = {
                        {s = "kraken/sops/deadmanstale/deadmansreloadend.wav", t = 0.01},
                    },
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.4,
    },  
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "kraken/sops/deadmanstale/deadmansdraw.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "kraken/sops/deadmanstale/deadmansdraw.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_dh16.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DH-16"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DH-16 is a powerful blaster designed for both military and civilian use, known for its high precision and stopping power. Compact yet formidable, it offers versatile performance, making it suitable for a range of tactical and self-defense situations."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/dh16.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_dh16.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 26
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 270
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 1
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.5

SWEP.Delay = 60 / 370
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/dh16.wav"
SWEP.ShootSound = "kraken/sops/dh16.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-6.02, 1.11, 3.354),
    Ang = Vector(0, 0.389, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(-3, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.25, -2, 12),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0.23, -2.1, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "a180",
        Offset = {
            vpos = Vector(0.14, -0.8, 14.3),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.2, -0.2, 8),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.5, 0.35, 2.2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.95, -0.72, 3.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}

--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_dt40.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DT-40"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DT-40 blaster pistol was a stylish and reliable heavy blaster pistol that was manufactured by Antrech Arms, a subsidiary of BlasTech Industries. It was vaunted for its reliability and ease of maintenance, and heavily resembled a slugthrower revolver."
SWEP.Trivia_Manufacturer = "Antrech Arms"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/dt40.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_de10.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 45
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 190
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 1
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/de10.wav"
SWEP.ShootSound = "kraken/sops/de10.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-6.237, -5.169, 3.355),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(-3, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.25, -1, 14),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.18, -1.8, 4.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "a180",
        Offset = {
            vpos = Vector(0.25, -1.4, 11),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.5, -0.9, 8),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.6, 0.4, 2.8),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.5, -0.83, 5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}

--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_k0bu.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_tl30.lua:
return gluapack()()
--PATH lua/weapons/awhg_bobs_gun_base/cl_init.lua:
include('shared.lua')

SWEP.PrintName				= ""				// 'Nice' Weapon name (Shown on HUD)	
SWEP.Slot				= 4				// Slot in the weapon selection menu
SWEP.SlotPos				= 1				// Position in the slot
SWEP.DrawAmmo				= true				// Should draw the default HL2 ammo counter				// Should draw the default crosshair
SWEP.DrawWeaponInfoBox			= true			// Should draw the weapon info box
SWEP.BounceWeaponIcon   			= false				// Should the weapon icon bounce?
SWEP.CSMuzzleFlashes			= false


--PATH addons/[misc] szachy/lua/weapons/chess_admin_tool.lua:
return gluapack()()
--PATH lua/weapons/ce_bcr_config.lua:
return gluapack()()
--PATH lua/weapons/cloaking-2/shared.lua:
AddCSLuaFile()
include("weapons/ce_bcr_config.lua")



//----------------------------------
// SWEP Info
//----------------------------------
SWEP.Author                 =   "Temporary Solutions"
SWEP.PrintName              =   "Cloaking - " .. cloakconfig.MaxCharge2 .. " Seconds"
SWEP.Base                   =   "weapon_base"
SWEP.Instructions           =   [[Left-Click: Toggle Cloak
Right-Click: N/A]]
SWEP.Spawnable              =   true
SWEP.AdminSpawnable         =   true
SWEP.AdminOnly 				= 	false
//----------------------------------
// SWEP Models
//----------------------------------
SWEP.ViewModelFlip          =   false
SWEP.UseHands               =   false
SWEP.ViewModel              =   "models/weapons/v_hands.mdl"
SWEP.WorldModel             =   ""
SWEP.HoldType               =   "normal"
//----------------------------------
// SWEP Slot Properties
//----------------------------------
SWEP.AutoSwitchTo           =   true
SWEP.AutoSwithFrom          =   true
SWEP.Slot                   =   5
SWEP.SlotPos                =   121
//----------------------------------
// SWEP Weapon Properties
//----------------------------------
SWEP.DrawAmmo               =   false
SWEP.DrawCrosshair          =   false
SWEP.m_WeaponDeploySpeed 	= 	100
SWEP.OnRemove = onDeathDropRemove
SWEP.OnDrop = onDeathDropRemove

SWEP.Primary.ClipSize       =   0
SWEP.Primary.DefaultClip    =   0
SWEP.Primary.Ammo           =   "none"
SWEP.Primary.Automatic      =   false
 
SWEP.Secondary.ClipSize     =   -1
SWEP.Secondary.DefaultClip  =   -1
SWEP.Secondary.Ammo         =   "none"
SWEP.Secondary.Automatic    =   false

--[[
	Hey me, don't forget if you're going to copy paste this for the other 3 sweps you need to:
	Change cloakconfig.MaxCharge2
	Edit SWEP:Equip, The Timers, and HudDraw
	And change ce_bc2_2
]]--

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)

    sound.Add({
	name = "CloakTauntSound",
	channel = CHAN_STATIC,
	volume = cloakconfig.TauntVolume,
	level = 70,
	pitch = { 95, 100 },
	sound = cloakconfig.TauntSound})
end


local function Cloak(ply)
	local plyVelocity = ply:GetVelocity()
    local plyWeapon = ply:GetActiveWeapon()
    local col = ply:GetColor()
    ply:SetNWBool("HideHUD", true)

    local untilVelAlpha = math.max(0, plyVelocity:Length() - cloakconfig.CloakUntilVel) 	-- Keeps player completly cloaked until they meet a set velocity.
    local approachAlpha = math.Approach(col.a, untilVelAlpha, 500 * FrameTime()) 	-- Gradually get to the alpha (Instead of snapping to it).
    approachAlpha = math.max(approachAlpha, cloakconfig.MinimumVisibility) 	-- If the alpha is being set below the set minimum, just use the minimum.

    --[[
    	This is a fix for most weapons not going invisible unless the
    	alpha is 0. I don't think I can fix this as
    	it probably has to do with the weapon's models or textures.
    --]]
    local wepAlpha = 0
    
    if untilVelAlpha >= 70 then
    	wepAlpha = untilVelAlpha
   	else
   		wepAlpha = 0
   	end

   	if cloakconfig.CloakEffectOn ~= "" then
   		local effectpos = ply:GetPos()
		local effectdata = EffectData()
		effectdata:SetOrigin(effectpos)
		effectdata:SetNormal(Vector(0, 0, 0))
		util.Effect(cloakconfig.CloakEffectOn, effectdata)
	end


	ply:RemoveAllDecals()
	ply:DrawShadow(false)
	ply:SetDSP(cloakconfig.DistortSound)

	if cloakconfig.CloakType == "Transparent" then
		ply:SetRenderMode(RENDERMODE_TRANSALPHA)
		ply:SetColor(Color(255, 255, 255, approachAlpha))
		plyWeapon:SetRenderMode(RENDERMODE_TRANSALPHA)
		plyWeapon:SetColor(Color(255, 255, 255, wepAlpha))
	elseif cloakconfig.CloakType == "Material" then
		ply:SetMaterial(cloakconfig.CloakMaterial, true)
		plyWeapon:SetMaterial(cloakconfig.CloakMaterial, true)
	end

	if SERVER then
		if approachAlpha < cloakconfig.MinimumNPCVisibility then
			ply:SetNoTarget(true)
		else
			ply:SetNoTarget(false)
		end
	end
end



local function Uncloak(ply, forced, debug, holdcharge)
	--print(debug)
	if forced and cloakconfig.ForceDisableSound ~= "" and ply.CloakActive then
		ply:EmitSound(cloakconfig.ForceDisableSound)
		--print("2 1")
	elseif cloakconfig.DisableSound ~= ""  and debug ~= "Equip" and ply.CloakActive then
		ply:EmitSound(cloakconfig.DisableSound)
		--print("2 2")
	end
	ply:SetNWBool("HideHUD", false)
	ply.CloakActive = false
	ply:SetDSP(0)
    ply:DrawShadow(true)
    ply:SetRenderMode(RENDERMODE_NORMAL)
    ply:SetColor(Color(255, 255, 255, 255))
    ply:SetMaterial("")

    if SERVER then
    	ply:SetNoTarget(false)
    end

    if not holdcharge then
   		ply:SetNWFloat("CloakCharge", cloakconfig.MaxCharge2)
   	end

    timer.Simple(cloakconfig.ToggleTime, function()
		ply.AllowedToggle = true
	end)

    if cloakconfig.CloakEffectOff != "" then
   		local effectpos = ply:GetPos()
		local effectdata = EffectData()
		effectdata:SetOrigin(effectpos)
		effectdata:SetNormal(Vector(0, 0, 0))
		util.Effect(cloakconfig.CloakEffectOff, effectdata)
	end

    for k, v in pairs(ply:GetWeapons()) do 	-- Uncloaks previously cloaked weapons
    	if IsValid(v) then
    		v:SetRenderMode(RENDERMODE_NORMAL)
   	 		v:SetColor(Color(255, 255, 255, 255))
   	 	end
   	end
end



local DontSpam = 0
function SWEP:PrimaryAttack()
	local ply = self:GetOwner()

	if ply.CloakActive == nil then
		ply.CloakActive = false
	elseif ply.AllowedToggle == nil then
		ply.AllowedToggle = true
	end

	if DontSpam < CurTime() then
		if SERVER then
			if not ply.CloakActive and ply.AllowedToggle then
				ply.CloakActive = true
				ply.AllowedToggle = false
				if cloakconfig.EnableSound != "" then
   					ply:EmitSound(cloakconfig.EnableSound)
   				end
			elseif ply.CloakActive then
				if cloakconfig.CloakMode == "Charge" then
					Uncloak(ply, false, "Primary", true)
				else
					Uncloak(ply, false, "Primary")
				end
			else
				if cloakconfig.ToggleFailureSound != "" then
				ply:EmitSound(cloakconfig.ToggleFailureSound)
				end
			end
		end
		DontSpam = CurTime() + 0.5
	end
end



function SWEP:CanSecondaryAttack()	
	return false
end



function SWEP:Reload()
	ply = self:GetOwner()
	if (self.nextreload or 0) <= CurTime() and cloakconfig.TauntSound != "" then
    	self.nextreload = CurTime() + cloakconfig.TauntDelay
		ply:EmitSound("CloakTauntSound")
	end
end



function SWEP:Deploy()
	self.Owner:DrawViewModel(false)
end



function SWEP:Equip()
	local ply = self.Owner

	--(Removes Other Cloaks)--
	if ply:HasWeapon("cloaking-1") then
		ply:StripWeapon("cloaking-1")
	elseif ply:HasWeapon("cloaking-infinite") then
		ply:StripWeapon("cloaking-infinite")
	elseif ply:HasWeapon("cloaking-3") then
		ply:StripWeapon("cloaking-3")
	end

	Uncloak(ply, false, "Equip")

	if cloakconfig.CloakMode == "Rechage" then
		self.Owner.CloakCharge = cloakconfig.MaxCharge2
	end
end



hook.Add("PlayerPostThink", "ce_bc2_2_ThinkHook", function(ply)
	if ply.CloakActive then
		Cloak(ply)
	end

	if not ply.LastCharge then
		ply.LastCharge = CurTime()
	end

	if SERVER and ply:HasWeapon("cloaking-2") then
		if cloakconfig.CloakMode == "Charge" and cloakconfig.MaxCharge2 != 0 then
			if ply.LastCharge + (1 * cloakconfig.ChargeLossMultiplier) <= CurTime() and ply:GetNWFloat("CloakCharge") > 0 and ply.CloakActive then 	-- Depletes Charge
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") - 1)
				ply.LastCharge = CurTime()
			elseif ply.LastCharge + (1 * cloakconfig.ChargeGainMultiplier) <= CurTime() and ply:GetNWFloat("CloakCharge") < cloakconfig.MaxCharge2 and !ply.CloakActive and !ply.CloakPause then 	-- Adds Charge
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") + 1)
				ply.LastCharge = CurTime()
			elseif ply.CloakActive and ply:GetNWFloat("CloakCharge") == 0 then	-- Uncloaks when out of charge
				Uncloak(ply, true, "Charge", true)
			end
		end
	end

	-- Its like charge, without the recharge
	if ply:HasWeapon("cloaking-2") then
		if cloakconfig.CloakMode == "Timer" and cloakconfig.MaxCharge2 != 0 then
			if ply.LastCharge + 1 <= CurTime() and ply:GetNWFloat("CloakCharge") > 0 and ply.CloakActive then
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") - 1)
				ply.LastCharge = CurTime()
			elseif ply.CloakActive and ply:GetNWFloat("CloakCharge") == 0 then
				Uncloak(ply, true, "Timer")
				ply:SetNWFloat("CloakCharge", cloakconfig.MaxCharge2)
			end
		end
	end
		-- Copy pasted as an attempted bugfix for some weapons being a pain in the ass
	local plyVelocity = ply:GetVelocity()
    local plyWeapon = ply:GetActiveWeapon()
    local col = ply:GetColor()

    local untilVelAlpha = math.max(0, plyVelocity:Length() - cloakconfig.CloakUntilVel) 	-- Keeps player completly cloaked until they meet a set velocity.
    local approachAlpha = math.Approach(col.a, untilVelAlpha, 500 * FrameTime()) 	-- Gradually get to the alpha (Instead of snapping to it).
    approachAlpha = math.max(approachAlpha, cloakconfig.MinimumVisibility) 	-- If the alpha is being set below the set minimum, just use the minimum.

    --[[
    	This is a fix for most weapons not going invisible unless the
    	alpha is 0. I don't think I can fix this as
    	it probably has to do with the weapon's models or textures.
    --]]
    local wepAlpha = 0
    
    if untilVelAlpha >= 70 then
    	wepAlpha = untilVelAlpha
   	else
   		wepAlpha = 0
   	end

   	if cloakconfig.CloakType == "Transparent" and ply.CloakActive then
		plyWeapon:SetRenderMode(RENDERMODE_TRANSALPHA)
		plyWeapon:SetColor(Color(255, 255, 255, wepAlpha))
	elseif cloakconfig.CloakType == "Material" and ply.CloakActive then
		plyWeapon:SetMaterial(cloakconfig.CloakMaterial, true)
	end
end)



hook.Add("EntityFireBullets", "ce_bc2_2_UncloakOnFire", function(ent, bullet)
	if IsValid(ent) and ent:IsPlayer() and ent.CloakActive then
		if cloakconfig.CloakFireMode == 1 then
			Uncloak(ent, true, "Fired")
		elseif cloakconfig.CloakFireMode == 2 then
			if cloakconfig.CloakMode == "Charge" then
				ent:SetNWFloat("CloakCharge", ent:GetNWFloat("CloakCharge") - cloakconfig.LoseChargeAmountFire)
			elseif cloakconfig.CloakMode == "Timer" then
				print("Yeah you probably shouldn't set a charge option if you're using the timer mode.\nDefaulting to Option 1")
				GetConVar("bc2_CloakFireMode"):SetInt(1)
				Uncloak(ent, true, "Fired2")
			end
		elseif cloakconfig.CloakFireMode == 3 and ent:Alive() then
			Uncloak(ent, true, "Fired3", true)
			ent.AllowedToggle = false
			ent.CloakPause = true
			timer.Simple(cloakconfig.TempDisableTimeFire, function()
				if IsValid(ent) and not ent.DidSomethingStupid then
					ent.CloakActive = true
				end
			ent.AllowedToggle = true
			ent.DidSomethingStupid = false
			ent.CloakPause = false
			end)
		end
	end
end)



hook.Add("EntityTakeDamage", "ce_bc2_2_UncloakOnDamage", function(ent, dmginfo)
	if IsValid(ent) and ent:IsPlayer() and ent.CloakActive then
		if cloakconfig.CloakDamageMode == 1 then
			Uncloak(ent, true, "Damage")
		elseif cloakconfig.CloakDamageMode == 2 then
			if cloakconfig.CloakMode == "Charge" then
				ent:SetNWFloat("CloakCharge", ent:GetNWFloat("CloakCharge") - cloakconfig.LoseChargeAmountHurt)
			elseif cloakconfig.CloakMode == "Timer" then
				print("Yeah you probably shouldn't set a charge option if you're using the timer mode.\nDefaulting to Option 1")
				GetConVar("bc2_CloakDamageMode"):SetInt(1)
				Uncloak(ent, true, "Damage2")
			end
		elseif cloakconfig.CloakDamageMode == 3 and ent:Alive() then
			Uncloak(ent, true, "Damage3", true)
			ent.AllowedToggle = false
			ent.CloakPause = true
			timer.Simple(cloakconfig.TempDisableTimeHurt, function()
				if IsValid(ent) and not ent.DidSomethingStupid then
					ent.CloakActive = true
				end
			ent.AllowedToggle = true
			ent.DidSomethingStupid = false
			ent.CloakPause = false
			end)
		end
	end
end)



hook.Add("PlayerFootstep", "ce_bc2_2_SilentSteps", function(ply, pos, foot, sound, volume, rf)
    if ply.CloakActive then
    	ply:EmitSound(sound, 20, nil, cloakconfig.FootstepVolume, 4)
   		return true
	else
    	return false
 	end
end)



hook.Add("HUDDrawTargetID", "ce_bc2_2_HidePlayerID", function()
	if CLIENT then
    	local gplytr = util.GetPlayerTrace(LocalPlayer())
    	local ent = util.TraceLine(gplytr).Entity
    	local col = 255
    	if IsValid(ent) then
    		col = ent:GetColor()
    	end

    	if ent:IsPlayer() and IsValid(ent) then
    		if cloakconfig.CloakType == "Transparent" and ent.CloakActive and col.a < cloakconfig.MinimumIDVisibility then
        		return false
        	elseif cloakconfig.CloakType == "Material" and ent.CloakActive then
           		return false
           	else
           		return
        	end
        end
	end
end)



hook.Add("HUDPaint", "ce_bc2_1_DrawThings", function()
	local ply = LocalPlayer()
	if IsValid(ply) and ply:Alive() and IsValid(ply:GetActiveWeapon()) then

		local activeweapon = ply:GetActiveWeapon():GetClass()

		if ply.CloakActive and cloakconfig.CloakOverlay ~= "" then
			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetMaterial(Material(cloakconfig.CloakOverlay))
			surface.DrawTexturedRect( 0, 0, ScrW(), ScrH())
		end

		if ply:HasWeapon("cloaking-2") and GetConVar("bc2_ShowCloakCharge"):GetBool() and (activeweapon == "cloaking-2" or ply:GetNWFloat("CloakCharge") != cloakconfig.MaxCharge2) and cloakconfig.MaxCharge2 != 0 then
			draw.SimpleText(ply:GetNWFloat("CloakCharge"), "DermaLarge", ScrW()/2 - 25, 900, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end
	end
end)



hook.Add("HUDShouldDraw", "DarkRP_HideDarkPlayerID", function(hudName)
    if hudName ~= "DarkRP_EntityDisplay" then return end

    local playersToDraw = {}
    for _,ply in pairs(player.GetAll()) do
        if IsValid(ply) and not ply:GetNWBool("HideHUD") then
            table.insert(playersToDraw, ply)
        end
    end
    return true, playersToDraw
end)



hook.Add("PlayerEnteredVehicle", "ce_bc2_2_UncloakEnteringVehicle", function(ply, veh, seat)
	if ply.CloakActive and cloakconfig.UncloakInVehicle then
		Uncloak(ply, false, "Vehicle")
	end
end)


-- Accidents
local function onDemote(source, demoted, reason)
	if demoted.CloakActive then
	Uncloak(demoted, false, "Demoted")
	demoted.DidSomethingStupid = true
	end
end

local function UncloakOnAccident(ply)
	Uncloak(ply, false, "Accident")
	ply.DidSomethingStupid = true
end

hook.Add("PlayerDeath", "ce_bc2_2_Death" , UncloakOnAccident)
hook.Add("playerAFKDemoted", "ce_bc2_2_AFK" , UncloakOnAccident)
hook.Add("onPlayerDemoted", "ce_bc2_2_Demoted" , onDemote)
hook.Add("playerArrested", "ce_bc2_2_Arrested" , UncloakOnAccident)
hook.Add("playerStarved", "ce_bc2_2_Starved" , UncloakOnAccident)
hook.Add("OnPlayerChangedTeam", "ce_bc2_2_ChangedTeam" , UncloakOnAccident)
--PATH lua/weapons/gmod_tool/stools/hologramtool.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/removeprops.lua:
/*
	Perma Remove Props
	Created by Malboro, July 2015
	
	Ideas:
		Remove FUCKING Maps Props
		
	Errors:
		Errors on die

*/

TOOL.Category		=	"Props Tool"
TOOL.Name			=	"RemoveProps"
TOOL.Command		=	nil
TOOL.ConfigName		=	""

if CLIENT then
	language.Add("Tool.removeprops.name", "RemoveProps")
	language.Add("Tool.removeprops.desc", "Remove a props permanently")
	language.Add("Tool.removeprops.0", "LeftClick: Add RightClick: OpenMenu")
end

if SERVER then
	util.AddNetworkString("ContentRmvProps")
	util.AddNetworkString("RmvPropsSQL")
	sql.Query("CREATE TABLE IF NOT EXISTS removeprops('id' INTEGER NOT NULL, 'map' TEXT NOT NULL, 'content' TEXT NOT NULL, PRIMARY KEY('id'));")
end

if SERVER then

	local function RmvPropsSQL( um, ply )

		local EntIndex = net.ReadFloat()
		if not ply:IsAdmin() then return end
		
		local content = sql.Query( "SELECT * FROM removeprops;" )

		if content == nil then return end
		
		for k, v in pairs( content ) do

			if game.GetMap() == v.map then

				local data = util.JSONToTable(v.content)

				if data.ID == EntIndex then

					sql.Query("DELETE FROM removeprops WHERE id = ".. v.id ..";")
				
				end

			end

		end

	end
	net.Receive("RmvPropsSQL", RmvPropsSQL)

end

local function RemoveProps()

	if CLIENT then return end

	local content = sql.Query( "SELECT * FROM removeprops;" )

	if not content or content == nil then return end
	
	for k, v in pairs( content ) do

		if game.GetMap() == v.map then

			local data = util.JSONToTable(v.content)

			local ent = ents.GetByIndex(data.ID)

			for k2, v2 in pairs(ents.FindInSphere( data.Pos, 0.2 )) do
				
				if v2:GetModel() == data.Model and v2:GetClass() == data.Name  then
					
					v2:Remove()

				end

			end

			/*if ent:IsValid() then
				
				ent:Remove()

			end*/

		end

	end

end
hook.Add("InitPostEntity", "InitializeRemoveProps", RemoveProps)
hook.Add("PostCleanupMap", "WhenCleanUpRemoveProps", RemoveProps)
timer.Simple(5, function() RemoveProps() end) -- When the hook isn't call ...

function TOOL:LeftClick(trace)

	if CLIENT then return end

	local ply = self:GetOwner()
	local ent = trace.Entity

	if not self:GetOwner():IsAdmin() then return false end
	if ent:IsWorld() then ply:ChatPrint( "You can't remove the world DUDE !" ) return false end
	if not ent then ply:ChatPrint( "That is not a valid entity !" ) return false end
	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return false end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return false end
	if ent.OnDieFunctions then ply:ChatPrint( "You can't remove this !" ) return false end
	if ent.PermaProps then ply:ChatPrint( "You can't remove this !" ) return false end

	local effectdata = EffectData()
	effectdata:SetOrigin(ent:GetPos())
	effectdata:SetMagnitude(2)
	effectdata:SetScale(2)
	effectdata:SetRadius(3)
	util.Effect("Sparks", effectdata)

	local content = {}
	content.ID = ent:EntIndex()
	content.Name = ent:GetClass()
	content.Model = ent:GetModel()
	content.Pos = ent:GetPos()
	content.Angle = ent:GetAngles()

	sql.Query("INSERT INTO removeprops (id, map, content) VALUES(NULL, ".. sql.SQLStr(game.GetMap()) ..", ".. sql.SQLStr(util.TableToJSON(content)) ..");")
	ply:ChatPrint("You remove " .. ent:GetClass() .. " permanently in the map !")

	ent:Remove()

	return true

end

function TOOL:RightClick(trace)

	if CLIENT then return end

	local SendTable = {}
	local content = sql.Query( "SELECT * FROM removeprops;" )

	if content == nil then return end
	
	for k, v in pairs( content ) do

		if game.GetMap() == v.map then

			local data = util.JSONToTable(v.content)

			table.insert(SendTable, data)

		end

	end

	net.Start("ContentRmvProps")
	net.WriteTable(SendTable)
	net.Send(self:GetOwner())

	return false

end

function TOOL:Reload(trace)

	if CLIENT then return end

	return false

end

function TOOL.BuildCPanel(panel)

	panel:AddControl("Header",{Text = "Perma Remove Props", Description = "Remove a server props for restarts\nBy Malboro"})

end

local function ContentRmvProps()

	local Content = net.ReadTable()

	local DermaPanel = vgui.Create( "DFrame" )
	DermaPanel:SetSize( 500, 200 )
	DermaPanel:SetTitle( "Removed props" )
	DermaPanel:Center()
	DermaPanel:MakePopup()
	 
	local DermaListView = vgui.Create("DListView", DermaPanel)
	DermaListView:SetPos(25, 30)
	DermaListView:SetSize(450, 125)
	DermaListView:SetMultiSelect(false)
	local Col1 = DermaListView:AddColumn("ID")
	local Col2 = DermaListView:AddColumn("Name")
	local Col3 = DermaListView:AddColumn("Model")
	Col1:SetMinWidth(50)
	Col1:SetMaxWidth(50)

	Col2:SetMinWidth(80)
	Col2:SetMaxWidth(80)
	DermaListView.OnRowRightClick = function(panel, line)

		local MenuButtonOptions = DermaMenu()
	    MenuButtonOptions:AddOption("Draw entity", function() 

	    	if not LocalPlayer().DrawRemovedEnt or not istable(LocalPlayer().DrawRemovedEnt) then LocalPlayer().DrawRemovedEnt = {} end

	    	if LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] and LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID]:IsValid() then return end

		    local ent = ents.CreateClientProp( Content[DermaListView:GetLine(line):GetValue(1)].Model ) 
			ent:SetPos( Content[DermaListView:GetLine(line):GetValue(1)].Pos )
			ent:SetAngles( Content[DermaListView:GetLine(line):GetValue(1)].Angle )

			LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] = ent

		end )

		if LocalPlayer().DrawRemovedEnt and LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] != nil then
			
			MenuButtonOptions:AddOption("Stop Drawing", function() 

				LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID]:Remove()
				LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] = nil

			end )

		end

	    MenuButtonOptions:AddOption("Remove", function()

	    	net.Start("RmvPropsSQL")
	    	net.WriteFloat(Content[DermaListView:GetLine(line):GetValue(1)].ID)
	    	net.SendToServer()

	    	if LocalPlayer().DrawRemovedEnt and LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] != nil then

	    		LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID]:Remove()
				LocalPlayer().DrawRemovedEnt[Content[DermaListView:GetLine(line):GetValue(1)].ID] = nil
				
	    	end

	    	DermaListView:RemoveLine(line)

	    	LocalPlayer():ChatPrint("Removed successfully from the database ! ( Need server restart )")


		end )
	    MenuButtonOptions:Open()
		
	end
	 
	for k, v in pairs(Content) do

	    DermaListView:AddLine(k, v.Name, v.Model)

	end

end
net.Receive("ContentRmvProps", ContentRmvProps)

local function RemoverViewer()

	if not LocalPlayer().DrawRemovedEnt or not istable(LocalPlayer().DrawRemovedEnt) then return end

    local pos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 10
    local ang = LocalPlayer():EyeAngles()

    ang = Angle(ang.p + 90, ang.y, 0)

    for k, v in pairs(LocalPlayer().DrawRemovedEnt) do

    	if not v or not v:IsValid() then LocalPlayer().DrawRemovedEnt[k] = nil continue end

	    render.ClearStencil()
	    render.SetStencilEnable(true)
	        render.SetStencilWriteMask(255)
	        render.SetStencilTestMask(255)
	        render.SetStencilReferenceValue(15)
	        render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilZFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilPassOperation(STENCILOPERATION_KEEP)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
	        render.SetBlend(0)
	        v:DrawModel()
	        render.SetBlend(1)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	        cam.Start3D2D(pos, ang, 1)
	                surface.SetDrawColor(255, 0, 0, 255)
	                surface.DrawRect(-ScrW(), -ScrH(), ScrW() * 2, ScrH() * 2)
	        cam.End3D2D()
	        v:DrawModel()
	    render.SetStencilEnable(false)

	end

end
hook.Add("PostDrawOpaqueRenderables", "RemoverViewer", RemoverViewer)
--PATH lua/weapons/gmod_tool/stools/vjstool_npcfollower.lua:
TOOL.Name = "#tool.vjstool_npcfollower.name"
TOOL.Tab = "DrVrej"
TOOL.Category = "Tools"
TOOL.Command = nil -- The console command to execute upon being selected in the Q menu.

TOOL.Information = {
	{name = "left"},
	{name = "right"},
	{name = "reload"},
}

-- Just to make it easier to reset everything to default
local DefaultConVars = {}
for k,v in pairs(TOOL.ClientConVar) do
	DefaultConVars["vjstool_npcfollower_"..k] = v
end
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	NPC_FOLLOWER_ENT_NAME = "None"
	local function DoBuildCPanel_NPCFollower(Panel)
		local reset = vgui.Create("DButton")
		reset:SetFont("DermaDefaultBold")
		reset:SetText("#vjbase.menu.general.reset.everything")
		reset:SetSize(150, 25)
		reset:SetColor(Color(0,0,0,255))
		reset.DoClick = function()
			for k, v in pairs(DefaultConVars) do
				if v == "" then
					LocalPlayer():ConCommand(k.." ".."None")
				else
					LocalPlayer():ConCommand(k.." "..v)
				end
				timer.Simple(0.05,function()
					GetPanel = controlpanel.Get("vjstool_npcfollower")
					GetPanel:ClearControls()
					DoBuildCPanel_NPCFollower(GetPanel)
				end)
			end
		end
		Panel:AddPanel(reset)
		
		Panel:AddControl("Label", {Text = "#tool.vjstool.menu.label.recommendation"})
		Panel:AddControl("Label", {Text = "Selected NPC: " .. NPC_FOLLOWER_ENT_NAME})
		
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	net.Receive("vj_npcfollower_cl_update", function(len, ply)
		local wep = LocalPlayer():GetActiveWeapon()
		if wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "vjstool_npcfollower" then
			local entName = net.ReadString()
			NPC_FOLLOWER_ENT_NAME = entName
			GetPanel = controlpanel.Get("vjstool_npcfollower")
			GetPanel:ClearControls()
			DoBuildCPanel_NPCFollower(GetPanel)
		end
	end)
---------------------------------------------------------------------------------------------------------------------------------------------
	function TOOL.BuildCPanel(Panel)
		DoBuildCPanel_NPCFollower(Panel)
	end
else -- If SERVER
	util.AddNetworkString("vj_npcfollower_cl_update")
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:LeftClick(tr)
	if CLIENT then return true end
	local ent = tr.Entity
	if (!IsValid(ent)) then return end
	if !ent:IsNPC() then return end
	if !ent.IsVJBaseSNPC then return end
	
	local NPCname = list.Get("NPC")[ent:GetClass()].Name
	local ply = self:GetOwner()
	self:ClearObjects()
	self:SetObject(1, ent, tr.HitPos, Phys, tr.PhysicsBone, tr.HitNormal)
	//if CLIENT then return true end
	ply:ChatPrint(NPCname .. " Has been selected!")
	
	net.Start("vj_npcfollower_cl_update")
	net.WriteString(NPCname)
	net.Send(ply)
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:RightClick(tr)
	if CLIENT then return true end
	local ent = tr.Entity
	if (!IsValid(ent)) then return end
	
	local iNum = self:NumObjects()
	local ply = self:GetOwner()
	if iNum >= 1 then
		local selectedEnt = self:GetEnt(1)
		if IsValid(selectedEnt) then
			if selectedEnt:Follow(ent, false) then
				self:ClearObjects()
				ply:ChatPrint(list.Get("NPC")[selectedEnt:GetClass()].Name .. " is now following " .. ent:GetClass())
			else
				ply:ChatPrint(list.Get("NPC")[selectedEnt:GetClass()].Name .. " is currently unable to follow!")
			end
		else
			ply:ChatPrint("#tool.vjstool_npcfollower.print.noselection")
		end
	else
		ply:ChatPrint("#tool.vjstool_npcfollower.print.noselection")
	end
	//if CLIENT then return true end
	net.Start("vj_npcfollower_cl_update")
	net.WriteString("None")
	net.Send(ply)
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:Reload(tr)
	if CLIENT then return true end
	local ent = tr.Entity
	if (!IsValid(ent)) then return end
	if !ent:IsNPC() then return end
	if !ent.IsVJBaseSNPC then return end
	
	ent:FollowReset()
	local ply = self:GetOwner()
	ply:ChatPrint("#tool.vjstool_npcfollower.print.reset")
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:Holster()
	if SERVER then
		net.Start("vj_npcfollower_cl_update")
		net.WriteString("None")
		net.Send(self:GetOwner())
	end
	self:ClearObjects()
end
--PATH lua/weapons/jet_mk1.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = ""

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.PrintName	= "Jetpack"
SWEP.Category	= "Star Wars Jetpacks"
SWEP.Purpose    = "LMB - Equip/Unequip\n\nSPACE - Fly up\n\nCTRL - Fly down\n\nSHIFT - Hover"

SWEP.Slot		= 4
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= true
SWEP.AdminOnly		= false

if SERVER then
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "Fuel" )
	if ( SERVER ) then
		self:SetFuel(100)
	end
end

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end



function SWEP:Reload()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if IsValid(ex) then
		ex:Remove()
		ply:SetNWEntity('Jetted',NULL)
		ply.LastJetExecuted = CurTime()
	else
		if !ply:IsOnGround() then return end
		if (ply.LastJetExecuted or 0)+1 >= CurTime() then return end
		local jp = ents.Create('mk1')
		jp:SetSlotName('mk1')
		jp:Spawn()
		jp:Attach(ply)
		ply.Jetted = jp
		ply:SetNWEntity('Jetted',jp)
	end
	ply:EmitSound('buttons/button14.wav')
end

local skinint = 1

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if !IsValid(ex) then return end
	skinint = (skinint + 1)%3
	ex:SetSkin(skinint)
	ply:EmitSound('buttons/button16.wav')
end

function SWEP:Deploy()
	return true
end

function SWEP:Equip()

end

function SWEP:ShouldDropOnDie() return false end


if SERVER then return end

--function SWEP:DrawHUD() end
--function SWEP:PrintWeaponInfo( x, y, alpha ) end

--function SWEP:HUDShouldDraw( name )
	--if ( name == "CHudWeaponSelection" ) then return true end
	--if ( name == "CHudChat" ) then return true end
	--return false
--end
--PATH gamemodes/starwarsrp/entities/weapons/lockpick/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Slot = 5
    SWEP.SlotPos = 1
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

-- Variables that are used on both client and server

SWEP.PrintName = "Lock Pick"
SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left or right click to pick a lock"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPLockpick = true

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/weapons/c_crowbar.mdl")
SWEP.WorldModel = Model("models/weapons/w_crowbar.mdl")

SWEP.UseHands = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"

SWEP.Sound = Sound("physics/wood/wood_box_impact_hard3.wav")

SWEP.Primary.ClipSize = -1      -- Size of a clip
SWEP.Primary.DefaultClip = 0        -- Default number of bullets in a clip
SWEP.Primary.Automatic = false      -- Automatic/Semi Auto
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1        -- Size of a clip
SWEP.Secondary.DefaultClip = -1     -- Default number of bullets in a clip
SWEP.Secondary.Automatic = false        -- Automatic/Semi Auto
SWEP.Secondary.Ammo = ""

function SWEP:SetupDataTables()
    self:NetworkVar("Bool", 0, "IsLockpicking")
    self:NetworkVar("Float", 0, "LockpickStartTime")
    self:NetworkVar("Float", 1, "LockpickEndTime")
    self:NetworkVar("Float", 2, "NextSoundTime")
    self:NetworkVar("Int", 0, "TotalLockpicks")
    self:NetworkVar("Entity", 0, "LockpickEnt")
end

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + 0.5)
    if self:GetIsLockpicking() then return end

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    Owner:LagCompensation(true)
    local trace = Owner:GetEyeTrace()
    Owner:LagCompensation(false)
    local ent = trace.Entity

    if not IsValid(ent) or ent.DarkRPCanLockpick == false then return end
    local canLockpick = hook.Call("canLockpick", nil, Owner, ent, trace)

    if canLockpick == false then return end
    if canLockpick ~= true and (
            trace.HitPos:DistToSqr(Owner:GetShootPos()) > 10000 or
            (not GAMEMODE.Config.canforcedooropen and ent:getKeysNonOwnable()) or
            (not ent:isDoor() and not ent:IsVehicle() and not string.find(string.lower(ent:GetClass()), "vehicle") and (not GAMEMODE.Config.lockpickfading or not ent.isFadingDoor))
        ) then
        return
    end

    self:SetHoldType("pistol")

    self:SetIsLockpicking(true)
    self:SetLockpickEnt(ent)
    self:SetLockpickStartTime(CurTime())
    local endDelta = hook.Call("lockpickTime", nil, Owner, ent) or util.SharedRandom("DarkRP_Lockpick" .. self:EntIndex() .. "_" .. self:GetTotalLockpicks(), 10, 30)
    self:SetLockpickEndTime(CurTime() + endDelta)
    self:SetTotalLockpicks(self:GetTotalLockpicks() + 1)


    if IsFirstTimePredicted() then
        hook.Call("lockpickStarted", nil, Owner, ent, trace)
    end

    if CLIENT then
        self.Dots = ""
        self.NextDotsTime = SysTime() + 0.5
        return
    end

    local onFail = function(ply) if ply == Owner then hook.Call("onLockpickCompleted", nil, ply, false, ent) end end

    -- Lockpick fails when dying or disconnecting
    hook.Add("PlayerDeath", self, fc{onFail, fn.Flip(fn.Const)})
    hook.Add("PlayerDisconnected", self, fc{onFail, fn.Flip(fn.Const)})
    -- Remove hooks when finished
    hook.Add("onLockpickCompleted", self, fc{fp{hook.Remove, "PlayerDisconnected", self}, fp{hook.Remove, "PlayerDeath", self}})
end

function SWEP:Holster()
    if self:GetIsLockpicking() and self:GetLockpickEndTime() ~= 0 then
        self:Fail()
    end
    return true
end

function SWEP:Succeed()
    self:SetHoldType("normal")

    local ent = self:GetLockpickEnt()
    self:SetIsLockpicking(false)
    self:SetLockpickEnt(nil)

    if not IsValid(ent) then return end

    local override = hook.Call("onLockpickCompleted", nil, self:GetOwner(), true, ent)

    if override then return end

    if ent.isFadingDoor and ent.fadeActivate and not ent.fadeActive then
        ent:fadeActivate()
        if IsFirstTimePredicted() then timer.Simple(5, function() if IsValid(ent) and ent.fadeActive then ent:fadeDeactivate() end end) end
    elseif ent.Fire then
        ent:keysUnLock()
        ent:Fire("open", "", .6)
        ent:Fire("setanimation", "open", .6)
    end
end

function SWEP:Fail()
    self:SetIsLockpicking(false)
    self:SetHoldType("normal")

    hook.Call("onLockpickCompleted", nil, self:GetOwner(), false, self:GetLockpickEnt())
    self:SetLockpickEnt(nil)
end

local colorBackground = Color(10, 10, 10, 120)
local dots = {
    [0] = ".",
    [1] = "..",
    [2] = "...",
    [3] = ""
}
function SWEP:Think()
    if not self:GetIsLockpicking() or self:GetLockpickEndTime() == 0 then return end

    if CurTime() >= self:GetNextSoundTime() then
        self:SetNextSoundTime(CurTime() + 1)
        local snd = {1,3,4}
        self:EmitSound("weapons/357/357_reload" .. tostring(snd[math.Round(util.SharedRandom("DarkRP_LockpickSnd" .. CurTime(), 1, #snd))]) .. ".wav", 50, 100)
    end
    if CLIENT and (not self.NextDotsTime or SysTime() >= self.NextDotsTime) then
        self.NextDotsTime = SysTime() + 0.5
        self.Dots = self.Dots or ""
        local len = string.len(self.Dots)

        self.Dots = dots[len]
    end

    local trace = self:GetOwner():GetEyeTrace()
    if not IsValid(trace.Entity) or trace.Entity ~= self:GetLockpickEnt() or trace.HitPos:DistToSqr(self:GetOwner():GetShootPos()) > 10000 then
        self:Fail()
    elseif self:GetLockpickEndTime() <= CurTime() then
        self:Succeed()
    end
end

function SWEP:DrawHUD()
    if not self:GetIsLockpicking() or self:GetLockpickEndTime() == 0 then return end

    self.Dots = self.Dots or ""
    local w = ScrW()
    local h = ScrH()
    local x, y, width, height = w / 2 - w / 10, h / 2 - 60, w / 5, h / 15
    draw.RoundedBox(8, x, y, width, height, colorBackground)

    local time = self:GetLockpickEndTime() - self:GetLockpickStartTime()
    local curtime = CurTime() - self:GetLockpickStartTime()
    local status = math.Clamp(curtime / time, 0, 1)
    local BarWidth = status * (width - 16)
    local cornerRadius = math.Min(8, BarWidth / 3 * 2 - BarWidth / 3 * 2 % 2)
    draw.RoundedBox(cornerRadius, x + 8, y + 8, BarWidth, height - 16, Color(255 - (status * 255), 0 + (status * 255), 0, 255))

    draw.DrawNonParsedSimpleText(DarkRP.getPhrase("picking_lock") .. self.Dots, "Trebuchet24", w / 2, y + height / 2, color_white, 1, 1)
end

function SWEP:SecondaryAttack()
    self:PrimaryAttack()
end


DarkRP.hookStub{
    name = "canLockpick",
    description = "Whether an entity can be lockpicked.",
    parameters = {
        {
            name = "ply",
            description = "The player attempting to lockpick an entity.",
            type = "Player"
        },
        {
            name = "ent",
            description = "The entity being lockpicked.",
            type = "Entity"
        },
        {
            name = "trace",
            description = "The trace result.",
            type = "table"
        }
    },
    returns = {
        {
            name = "allowed",
            description = "Whether the entity can be lockpicked",
            type = "boolean"
        }
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "lockpickStarted",
    description = "Called when a player is about to pick a lock.",
    parameters = {
        {
            name = "ply",
            description = "The player that is about to pick a lock.",
            type = "Player"
        },
        {
            name = "ent",
            description = "The entity being lockpicked.",
            type = "Entity"
        },
        {
            name = "trace",
            description = "The trace result.",
            type = "table"
        }
    },
    returns = {},
    realm = "Shared"
}

DarkRP.hookStub{
    name = "onLockpickCompleted",
    description = "Result of a player attempting to lockpick an entity.",
    parameters = {
        {
            name = "ply",
            description = "The player attempting to lockpick the entity.",
            type = "Player"
        },
        {
            name = "success",
            description = "Whether the player succeeded in lockpicking the entity.",
            type = "boolean"
        },
        {
            name = "ent",
            description = "The entity that was lockpicked.",
            type = "Entity"
        },
    },
    returns = {
        {
            name = "override",
            description = "Return true to override default behaviour, which is opening the (fading) door.",
            type = "boolean"
        }
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "lockpickTime",
    description = "The length of time, in seconds, it takes to lockpick an entity.",
    parameters = {
        {
            name = "ply",
            description = "The player attempting to lockpick an entity.",
            type = "Player"
        },
        {
            name = "ent",
            description = "The entity being lockpicked.",
            type = "Entity"
        },
    },
    returns = {
        {
            name = "time",
            description = "Seconds in which it takes a player to lockpick an entity",
            type = "number"
        }
    },
    realm = "Shared"
}

--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15a_stun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Stun DC-15a"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15a_stun.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.ViewModel = "models/servius/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_dc-15a.mdl"
SWEP.ViewModelFOV = 56

SWEP.DefaultBodygroups = "010"
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 36
SWEP.RangeMin = 243
SWEP.DamageMin = 24
SWEP.Range = 510
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55

SWEP.Recoil = 0.43
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.63
SWEP.Delay = 60 / 324
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
		Mode = -2
	},
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.50
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 50

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.66, -12.75, 2.529),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 3)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

-- Attachments
SWEP.DefaultElements = {"dc15"}
SWEP.AttachmentElements = {
    ["dc15"] = {
        WMElements = {
            {
                Model = "models/servius/weapons/worldmodels/w_dc-15a.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                WBodygroups = {{ind = 0, bg = 0}},
                Offset = {
                    pos = Vector(-550, 0, 470),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4150, 0, -1100),
                    ang = Angle(-15, 0, 100)
                },
                IsMuzzleDevice = true
            },
        },
    },
}
WMOverride = "models/servius/weapons/worldmodels/w_dc-15a.mdl"

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard", 
        Slot = "optic", 
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0.110, -3.771, 2.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(420, 50, -450),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Slot = {"dc15a_magazine_75"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0, -3.7, 0.5),
            vang = Angle(0, 0, 90),
            wpos = Vector(550, 115, -250),
            wang = Angle(-15, -90, -90)
        },
    },      
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "sw_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.3, -6.739, 0.504),
            vang = Angle(0, -90, 0),
            wpos = Vector(115, 180, -125),
            wang = Angle(-10 , 0, 180)
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.1, -9, 0.7),
            vang = Angle(0, -90, 0),
            wpos = Vector(-100, 180, -75),
            wang = Angle(-15 , 0, 180)
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 2.3,
        Source = {"shoot", "shoot2"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 2 / 30},
        },
    },


sound.Add({
    name =          "dc15a_reload1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armas/misc/dc17s_reload.wav"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15s_train.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Training DC-15s"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s_training.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/servius/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/servius/starwars/w_dc15s.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.6,
    [HITGROUP_CHEST] = 1.2,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 1
SWEP.RangeMin = 198
SWEP.DamageMin = 1
SWEP.Range = 399
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(250, 167, 0)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 255

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 162, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.837, 0.619, 1.656),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.6, -0.5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.101, 2.378, 6.164),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
        vmin = Vector(-0.2, 0, 5.100),
        vmax = Vector(-0.2, 0, 9),
        },          
    },
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Bone = "DC15",
        Slot = "stock",
        Offset = {
            vpos = Vector(0, 0.5, -9.1),
            vang = Angle(0, 0, -90),
        },
    }, 
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.1, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },    
    {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15sa.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15sa.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15sa"
SWEP.Trivia_Class = "Blaster Modular Pistol"
SWEP.Trivia_Desc = "The DC-15s side arm blaster was a blaster pistol created by BlasTech Industries for the Grand Army of the Republic. DC-15s pistols were used by clone commandos as a backup in addition to the heavier DC-17m Interchangeable Weapon System. The energy cell kept the blaster recharging at a slow but steady rate."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15sa.png"

SWEP.UseHands = true

SWEP.MirrorVMWM = false
SWEP.ViewModel = "models/jellyton/view_models/c_DC15SA.mdl"
SWEP.WorldModel = "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 36
SWEP.RangeMin = 90
SWEP.DamageMin = 23
SWEP.Range = 551
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 253
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.16
SWEP.HipDispersion = 410
SWEP.MoveDispersion = 37

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

----AMMO / stuff----
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootSound = "armas/disparos/dc15sa.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"
SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true
SWEP.Jamming = true
SWEP.HeatGain = 1 
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 15 
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5

SWEP.IronSightStruct = {
    Pos = Vector(-5.173, -6.689, 0.411),
    Ang = Vector(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.HoldtypeHolstered = "idle"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-4, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

-- Attachments
SWEP.DefaultElements = {"dc15sa"}
SWEP.AttachmentElements = {
    ["dc15sa"] = {
        VMElements = {
            {
                Model = "models/cs574/weapons/dc15sa.mdl",
                Bone = "DC-15SA",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.128, 4.4, -0.9),
                    ang = Angle(90, 0, -90),
                }
            }
        },
        WMElements = {
            {
                Model = "models/cs574/weapons/dc15sa.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(840, 100, 275),
                    ang = Angle(0, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(1250, 100, -400),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            }, 
        },
    },
}
WMOverride = "models/cs574/weapons/dc15sa.mdl"
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.150, -1.9, -5.32),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 100, -475),
            wang = Angle(0, 0, 180)
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, -4, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(111, 111, 111),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(-0, -1.5, 4.2),
            vang = Angle(90, 0, 0),
            wpos = Vector(1450, 100, -400),
            wang = Angle(0, 0, 180)
        },
    },       
    {
        PrintName = "Tactical", 
        DefaultAttName = "None", 
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(100, 100, 100),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(-1.1, -0.6, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(1110, 100, -250),
            wang = Angle(0, 0, -180)
        },
    },      
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None", 
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None", 
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(0.503, -1.3, -5.336),
            vang = Angle(90, 0, -90),
            wpos = Vector(325, 180, -350),
            wang = Angle(-10, 0, 180)
        },
    },          
}

SWEP.Animations = {
    ["fire"] = {
        Source = "fire",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "dc15sa_1", t = 1 / 60}, --s sound file
        },
    },


sound.Add({
    name =          "dc15sa_1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_var_02.mp3"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17s_red.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17s [Red]"
SWEP.Trivia_Class = "Heavy Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17s hand blaster, also known as DC-17s blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers. This one version is a powerful one."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17s_red.png"

-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapon/ven/ggn/dc17s_single.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.DefaultSkin = 0

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.AutoReload = true
SWEP.Damage = 32
SWEP.RangeMin = 133
SWEP.DamageMin = 16
SWEP.Range = 550
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20
SWEP.Recoil = 0.5
SWEP.RecoilPunch = 0.3
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17
SWEP.Delay = 60 / 337
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },    
}
SWEP.AccuracyMOA = 0.57
SWEP.HipDispersion = 576
SWEP.MoveDispersion = 53

-- Sounds & Muzzleflash
SWEP.ShootSound = "armas/disparos/dc17s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"
SWEP.NoFlash = nil 
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)


-- Ironsight & Holdtype
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.IronSightStruct = {
    Pos = Vector(-3.947, 1.389, 0.526),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 60,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 6, 1)
SWEP.ActiveAng = Angle(-3.2, -3, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, -1.08)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)


-- Attachments
SWEP.DefaultElements = {"dc17s"}
SWEP.AttachmentElements = {
    ["dc17s"] = { 
        WMElements = {
            {
                Model = "models/weapon/ven/ggn/dc17s_single_world.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                ModelSkin = 0,
                Offset = {
                    pos = Vector(450, 50, -100),
                    ang = Angle(0, -10, -180),
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(1900, 200, -200),
                    ang = Angle(0, -10, 180)
                },
                IsMuzzleDevice = true
            }, 
        },
    },
}
WMOverride = "models/weapon/ven/ggn/dc17s_single_world.mdl"

SWEP.Attachments = {
    {
        PrintName = "Sight", -- name of the attachment
        DefaultAttName = "Standard", -- default name (like: 'default', 'none', 'standard')
        Slot = "optic", -- slots, you can add attachments per slot using this: Slot = {"optic", "optics", "etc"},
        Bone = "DC17S_Root",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(0.001, -1.9, -2.32),
            vang = Angle(90, 0, -90),
            wpos = Vector(600, 100, -475),
            wang = Angle(0, -10, 180)
        },
    },
    {
        PrintName = "Laser/Flashlight", 
        DefaultAttName = "None",
        Slot = {"tac_pistol", "tactical"},
        Bone = "DC17S_Root",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(-0.101, 0.557, 7.738),
            vang = Angle(90, 0, -90),
            wpos = Vector(1450, 265, -175),
            wang = Angle(0, -10, 180)
        },
    },    
    {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk", 
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "DC17S_Root",
        Offset = {
            vpos = Vector(0.768, -0.238, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(750, 225, -350),
            wang = Angle(0, -10, 180)
        },
    },          
}


-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["sprint"] = {
        Source = "base_sprint_loop"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.1,
        SoundTable = {
            {
                s = "armas/misc/dc17s_draw.wav",
                p = 100,
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armas/misc/dc17s_holster.wav",
                p = 100, 
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL, 
        SoundTable = {
            {s = "dc17s_1", t = 1 / 30},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL, 
        SoundTable = {
            {s = "dc17s_2", t = 4 / 30},
        },
    },


sound.Add({
    name =          "dc17s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armas/misc/dc17s_reload.wav"
    }),
sound.Add({
    name =          "dc17s_2",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armas/misc/dc17s_empty.wav"
    }),
}


--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dp23.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DP-23"
SWEP.Trivia_Class = "Blaster Heavy Shotgun"
SWEP.Trivia_Desc = "The DP-23 was a type of blaster that could pierce through enemy defenses. It was used by the Grand Army of the Republic's clone troopers during the Clone Wars between the Galactic Republic and the Confederacy of Independent Systems. The DP-23 fired blue blaster bolts, and had a ridged barrel with a pointed muzzle, a black stock, and a small foregrip."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dp23.png"

SWEP.Slot = 3

SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 55
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 25
SWEP.RangeMin = 20
SWEP.DamageMin = 17
SWEP.Range = 55
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 2
SWEP.RecoilSide = 2
SWEP.RecoilPunch = 0.9
SWEP.RecoilRise = 0.9

SWEP.Delay = 10 / 70
SWEP.Num = 5
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 50
SWEP.HipDispersion = 450
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)
SWEP.Primary.Ammo = "ar2"

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.325, -5.188, 2),
    Ang = Vector(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.04
SWEP.ShootSound = "armas/disparos/dp23.wav"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "smg"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(7, -3, -1.206)
SWEP.CustomizeAng = Angle(18.291, 30.954, 17.587)

SWEP.DefaultElements = {"dp23", "muzzle"}
SWEP.AttachmentElements = {
    ["dp23"] = {
        VMElements = {
            {
                Model = "models/tor/dp23_base.mdl",
                Bone = "v_dlt19_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.5, 5, 1.5),
                    ang = Angle(0, -180, 0)
                }
            }
        }
    },
    ["muzzle"] = {
         VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "dlt19_sight",
                Scale = Vector(0, 0, 0),             
                Offset = {
                    pos = Vector(-0.5, 5, 8),
                    ang = Angle(90, 0, 0)
                },
                IsMuzzleDevice = true
            }
        },
        WMElements = {
            {
                Model = "models/tor/dp23_base.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.2, 1.2, 1.2),
                Offset = {
                    pos = Vector(1100, -50, -450),
                    ang = Angle(5, 90, 190)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2800, 0, -500),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        }, 
    }
}
WMOverride = "models/tor/dp23_base.mdl"

--SWEP.Attachments
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "dlt19_sight",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(-0.150, 0.6, -1.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(1000, 50, -740),
            wang = Angle(-5, -1, 180)
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    }, 
    {
        PrintName = "Tactical",
        DefaultAttName = "None", 
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight",
        Offset = {
            vpos = Vector(0.8, 2.5, 7),
            vang = Angle(90, 0, -0),
            wpos = Vector(2300, 200, -600),
            wang = Angle(-5, -1, -90)
        },
    },    
    {
        PrintName = "Grenade Launcher", 
        DefaultAttName = "None",
        Slot = "rep_ubgl",
        Bone = "v_dlt19_reference001",
        WMScale = Vector(130, 130, 130),
        Offset = {
            vpos = Vector(0, 5, 1.6),
            vang = Angle(0, -90, 0),
            wpos = Vector(1200, 50, -530),
            wang = Angle(-5, -1, -180)
        },   
        LHIK = true    
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dlt19_sight", 
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(0, 2.5, 10),
            vang = Angle(90, 0, -90),
            wpos = Vector(2800, 50, -650),
            wang = Angle(-5, 0.5, 180)
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "Standard Energization",
        Slot = {"ammo", "shotgun_ammo"}
    }, 
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },       
    {
        PrintName = "Training/Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight",
        Offset = {
            vpos = Vector(0.5, 2.5, -6),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 150, -430),
            wang = Angle(-5, 0, 180)
        },
    },           
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot1", "shoot2", "shoot3"}
    },
    ["fire_iron"] = {
        Source = {"shoot1", "shoot2", "shoot3"}
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_04.mp3", t = 0.1/30},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_01.mp3", t = 2},
        },
    },
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_repshield.lua:
SWEP.Base = "arccw_base_melee"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.AdminOnly = false

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Republic Blast Shield"
SWEP.Trivia_Class = "Shield"
SWEP.Trivia_Desc = "Anti-blaster fire shield for the grand army of the Republic. Stops blaster fire, specially from those damm clankers."
SWEP.Trivia_Manufacturer = "Grand Army of the Republic"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/republic_shield.png"

SWEP.Slot = 0

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw_go/v_shield.mdl"
SWEP.WorldModel = "models/weapons/arccw_go/v_shield.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(0, 15, -12),
    ang = Angle(0, 0, 180 - 15)
}

SWEP.ShieldProps = {
    {
        Model = "models/weapons/arccw_go/v_shield.mdl",
        Pos = Vector(0, -15, -12),
        Ang = Angle(0, 0, 180 - 15),
        Resistance = 100
    }
}

SWEP.PrimaryBash = true

SWEP.SpeedMult = 0.85

SWEP.MeleeDamage = 35
SWEP.MeleeRange = 32
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 1
SWEP.MeleeGesture = ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE
SWEP.MeleeAttackTime = 0

SWEP.MeleeSwingSound = {
    "arccw_go/shield/shield_push_01.wav",
}
SWEP.MeleeHitSound = {
    "physics/metal/metal_barrel_impact_hard7.wav",
}
SWEP.MeleeHitNPCSound = {
    "physics/body/body_medium_break3.wav",
}

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "MELEE"
    },
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "melee2"

SWEP.Primary.ClipSize = -1

SWEP.Animations = {
    ["draw"] = {
        Source = "deploy",
    },
    -- ["idle"] = {
    --     Source = {"idle1", "idle2"}
    -- },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
        Time = 2,
    },
}

SWEP.IronSightStruct = false

SWEP.ActivePos = Vector(0, 0, 3)

SWEP.BashPreparePos = Vector(0, 0, 0)
SWEP.BashPrepareAng = Angle(0, 5, 0)

SWEP.CustomizePos = Vector(15, 5, 0)
SWEP.CustomizeAng = Angle(0, 60, 0)

SWEP.BashPos = Vector(0, 0, 0)
SWEP.BashAng = Angle(10, -10, 0)

SWEP.HolsterPos = Vector(0, -1, 2)
SWEP.HolsterAng = Angle(-15, 0, 0)

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipStart",
    channel = 16,
    volume = 1.0,
    sound = "arccw_go/shield/shield_equip_04.wav"
})

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipEnd",
    channel = 16,
    volume = 1.0,
    sound = "arccw_go/shield/shield_equip_05.wav"
})
--PATH lua/weapons/nmg_eksoan_class_4ts_power_gen_bag.lua:
SWEP.PrintName = "Eksoan Class 4TS Power Gen Bag"
SWEP.Author = "R4V3NGaming"
SWEP.Category = "[Nexus Modding Group] E-Web"
SWEP.Base = "weapon_base"
SWEP.Slot = 0
SWEP.SlotPos = 0
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.HoldType = "duel"
SWEP.ShowViewModel = false
SWEP.ShowWorldModel = false
SWEP.UseHands = true
SWEP.ViewModelFOV = 100
SWEP.ViewModelFlip = false
SWEP.Energy = 75
SWEP.ViewModel = "models/weapons/cstrike/c_pist_elite.mdl"
SWEP.WorldModel = "models/r4v3ngaming/swrp/props/eweb/clonewars/eweb_battery.mdl"
SWEP.IconOverride = "materials/entities/nmg_eksoan_class_4ts_power_gen.png"

SWEP.WElements = {
	["we"] = { type = "Model", model = "models/r4v3ngaming/swrp/props/eweb/clonewars/eweb_battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(1, 11, 2), angle = Angle(0, 90, 180), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.VElements = {
	["ve"] = { type = "Model", model = "models/r4v3ngaming/swrp/props/eweb/clonewars/eweb_battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(5, 12, 8), angle = Angle(0, 90, 180), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.ViewModelBoneMods = {
	["v_weapon.elite_right"] = { scale = Vector(0, 0, 0), pos = Vector(0, 0, 100), angle = Angle(0, 0, 0) },
	["v_weapon.elite_left"] = { scale = Vector(0, 0, 0), pos = Vector(0, 0, 100), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(7, 3, 3), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(7, 2, 1), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

function SWEP:Initialize()
	self:SetupDataTables()
	self:SetHoldType("duel")
	self:SetEnergy(self.Energy)
	if CLIENT then
		self.VElements = table.FullCopy(self.VElements)
		self.WElements = table.FullCopy(self.WElements)
		self.ViewModelBoneMods = table.FullCopy(self.ViewModelBoneMods)
		self:CreateModels(self.VElements)
		self:CreateModels(self.WElements)
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255, 255, 255, 255))
				else
					vm:SetColor(Color(255, 255, 255, 1))
					vm:SetMaterial("Debug/hsv")
				end
			end
		end
	end
end

function SWEP:Equip( ply )
	timer.Simple( 0.1, function() ply:SelectWeapon( self:GetClass() ) end)
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "Energy" )
end


function SWEP:GetEnergy() return self.Energy end
function SWEP:SetEnergy(Energy) self.Energy = Energy end

function SWEP:DrawWorldModel() end

function SWEP:Think() end

function SWEP:PrimaryAttack() end

function SWEP:SecondaryAttack()
	if SERVER then
		local ply = self:GetOwner()

		if IsValid(ply) then
			local tr = ply:GetEyeTrace()
			local MaxDistance = 100
			local Energy = self:GetEnergy()
			local Item = ents.Create("nmg_eksoan_class_4ts_power_gen")

			local Distance = ply:GetPos():Distance(tr.HitPos)

			if Distance <= MaxDistance then
				if IsValid(Item) then
					local SpawnPos = tr.HitPos + Vector(0, 0, 20)
					Item:SetPos(SpawnPos)
					Item:SetEnergy(Energy)
					Item:Spawn()
				end
				self:GetOwner():StripWeapon(self:GetClass())
			else
				ply:ChatPrint("ENG: The destination is too far away! | GER: Das Ziel ist zu weit weg!")
			end
		end
	end
end


function SWEP:Holster()
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()

		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end

	return true
end

function SWEP:DrawHUD()
	local x, y, w, h = ScrW() * 0.5, ScrH() - 100, 200, 30
	draw.RoundedBox(8, x - w * 0.5, y, w, h, Color(0, 0, 0, 150))

	local Energy = self:GetEnergy()
	local Perc = math.ceil((Energy / 75) * 100)

	local Text = "Energy: " .. Perc .. "%"
	draw.SimpleText(Text, "DermaLarge", x, y + h * 0.5, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

function SWEP:OnRemove() self:Holster() end

if CLIENT then
	SWEP.vRenderOrder = nil

	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid(vm) then return end
		if (not self.VElements) then return end
		self:UpdateBonePositions(vm)

		if (not self.vRenderOrder) then
			self.vRenderOrder = {}
			for k, v in pairs(self.VElements) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
		end

		for k, name in ipairs(self.vRenderOrder) do
			local v = self.VElements[name]

			if (not v) then
				self.vRenderOrder = nil
				break
			end

			if (v.hide) then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if (not v.bone) then continue end
			local pos, ang = self:GetBoneOrientation(self.VElements, v, vm)
			if (not pos) then continue end

			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() ~= v.material) then
					model:SetMaterial(v.material)
				end

				if (v.skin and v.skin ~= model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if v.bodygroup then
					for bg_k, bg_v in pairs(v.bodygroup) do
						local currentBodygroup = model:GetBodygroup(bg_k)
						if currentBodygroup ~= bg_v then
							model:SetBodygroup(bg_k, bg_v)
						end
					end
				end



				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
				render.SetBlend(v.color.a / 255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	SWEP.wRenderOrder = nil

	function SWEP:DrawWorldModel()
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end

		if (not self.WElements) then return end

		if (not self.wRenderOrder) then
			self.wRenderOrder = {}

			for k, v in pairs(self.WElements) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end

		if (IsValid(self:GetOwner())) then
			bone_ent = self:GetOwner()
		else
			bone_ent = self
		end

		for k, name in pairs(self.wRenderOrder) do
			local v = self.WElements[name]

			if (not v) then
				self.wRenderOrder = nil
				break
			end

			if (v.hide) then continue end
			local pos, ang

			if (v.bone) then
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent)
			else
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand")
			end

			if (not pos) then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial

			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() ~= v.material) then
					model:SetMaterial(v.material)
				end

				if (v.skin and v.skin ~= model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for k, v in pairs(v.bodygroup) do
						if (model:GetBodygroup(k) ~= v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
				render.SetBlend(v.color.a / 255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation(basetab, tab, ent, bone_override)
		local bone, pos, ang

		if (tab.rel and tab.rel ~= "") then
			local v = basetab[tab.rel]
			if (not v) then return end
			pos, ang = self:GetBoneOrientation(basetab, v, ent)
			if (not pos) then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
		else
			bone = ent:LookupBone(bone_override or tab.bone)
			if (not bone) then return end
			pos, ang = Vector(0, 0, 0), Angle(0, 0, 0)
			local m = ent:GetBoneMatrix(bone)

			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end

			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r
			end
		end

		return pos, ang
	end

	function SWEP:CreateModels(tab)
		if (not tab) then return end

		for k, v in pairs(tab) do
			if (v.type == "Model" and v.model and v.model ~= "" and (not IsValid(v.modelEnt) or v.createdModel ~= v.model) and string.find(v.model, ".mdl") and file.Exists(v.model, "GAME")) then
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)

				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif (v.type == "Sprite" and v.sprite and v.sprite ~= "" and (not v.spriteMaterial or v.createdSprite ~= v.sprite) and file.Exists("materials/" .. v.sprite .. ".vmt", "GAME")) then
				local name = v.sprite .. "-"

				local params = {
					["$basetexture"] = v.sprite
				}

				local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}

				for i, j in pairs(tocheck) do
					if (v[j]) then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name, "UnlitGeneric", params)
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		if self.ViewModelBoneMods then
			if (not vm:GetBoneCount()) then return end
			local loopthrough = self.ViewModelBoneMods

			if (not hasGarryFixedBoneScalingYet) then
				allbones = {}

				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)

					if (self.ViewModelBoneMods[bonename]) then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector(1, 1, 1),
							pos = Vector(0, 0, 0),
							angle = Angle(0, 0, 0)
						}
					end
				end

				loopthrough = allbones
			end

			for k, v in pairs(loopthrough) do
				local bone = vm:LookupBone(k)
				if (not bone) then continue end
				local s = Vector(v.scale.x, v.scale.y, v.scale.z)
				local p = Vector(v.pos.x, v.pos.y, v.pos.z)
				local ms = Vector(1, 1, 1)

				if (not hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)

					while (cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end

				s = s * ms

				if vm:GetManipulateBoneScale(bone) ~= s then
					vm:ManipulateBoneScale(bone, s)
				end

				if vm:GetManipulateBoneAngles(bone) ~= v.angle then
					vm:ManipulateBoneAngles(bone, v.angle)
				end

				if vm:GetManipulateBonePosition(bone) ~= p then
					vm:ManipulateBonePosition(bone, p)
				end
			end
		else
			self:ResetBonePositions(vm)
		end
	end

	function SWEP:ResetBonePositions(vm)
		if (not vm:GetBoneCount()) then return end

		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale(i, Vector(1, 1, 1))
			vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
			vm:ManipulateBonePosition(i, Vector(0, 0, 0))
		end
	end

	function table.FullCopy(tab)
		if (not tab) then return nil end
		local res = {}

		for k, v in pairs(tab) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v)
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end

		return res
	end
end
--PATH lua/weapons/tfa_gun_base/shared.lua:
SWEP.Category = "" --The category.  Please, just choose something generic or something I've already done if you plan on only doing like one swep.
SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""
SWEP.DrawCrosshair = true
SWEP.DrawCrosshairIronSights = false
SWEP.ViewModelFOV = 65
SWEP.ViewModelFlip = false
SWEP.Skin = 0 --Viewmodel skin
SWEP.Spawnable = false
SWEP.IsTFAWeapon = true

SWEP.LoopedReload = false
SWEP.LoopedReloadInsertAmount = 1
SWEP.ShotgunEmptyAnim = false
SWEP.ShotgunEmptyAnim_Shell = true
SWEP.ShotgunStartAnimShell = false --shotgun start anim inserts shell

SWEP.Secondary.IronSightsEnabled = true
SWEP.Secondary.ScopeZoom = 1
SWEP.Secondary.ScopeScreenScale = 0.392592592592592

SWEP.RegularMoveSpeedMultiplier = 1

SWEP.FireSoundAffectedByClipSize = true

SWEP.Primary.Damage = -1
SWEP.Primary.DamageTypeHandled = true --true will handle damagetype in base
SWEP.Primary.NumShots = 1
SWEP.Primary.Force = -1
SWEP.Primary.Knockback = -1
SWEP.Primary.Recoil = 1
SWEP.Primary.RPM = 600
SWEP.Primary.RPM_Semi = -1
SWEP.Primary.RPM_Burst = -1
SWEP.Primary.StaticRecoilFactor = 0.5
SWEP.Primary.KickUp = 0.5
SWEP.Primary.KickDown = 0.5
SWEP.Primary.KickRight = 0.5
SWEP.Primary.KickHorizontal = 0.5
SWEP.Primary.DamageType = nil
SWEP.Primary.Ammo = "smg1"
SWEP.Primary.AmmoConsumption = 1
SWEP.Primary.Spread = 0
SWEP.Primary.DisplaySpread = true
SWEP.Primary.SpreadMultiplierMax = -1 --How far the spread can expand when you shoot.
SWEP.Primary.SpreadIncrement = -1 --What percentage of the modifier is added on, per shot.
SWEP.Primary.SpreadRecovery = -1 --How much the spread recovers, per second.
SWEP.Primary.SpreadRecoveryDelay = 0
SWEP.Primary.IronAccuracy = 0
SWEP.Primary.Range = -1--1200
SWEP.Primary.RangeFalloff = -1--0.5
SWEP.Primary.PenetrationMultiplier = 1
SWEP.Primary.DryFireDelay = nil

--[[Actual clientside values]]--

SWEP.DrawAmmo                       = true              -- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox              = false             -- Should draw the weapon info box
SWEP.BounceWeaponIcon               = false             -- Should the weapon icon bounce?

local sv_tfa_jamming = GetConVar("sv_tfa_jamming")
local sv_tfa_jamming_mult = GetConVar("sv_tfa_jamming_mult")
local sv_tfa_jamming_factor = GetConVar("sv_tfa_jamming_factor")
local sv_tfa_jamming_factor_inc = GetConVar("sv_tfa_jamming_factor_inc")

-- RP owners always like realism, so this feature might be something they like. Enable it for them!
TFA_AUTOJAMMING_ENABLED = string.find(engine.ActiveGamemode(), 'rp') or
	string.find(engine.ActiveGamemode(), 'roleplay') or
	string.find(engine.ActiveGamemode(), 'nutscript') or
	string.find(engine.ActiveGamemode(), 'serious') or
	TFA_ENABLE_JAMMING_BY_DEFAULT

SWEP.CanJam = tobool(TFA_AUTOJAMMING_ENABLED)

SWEP.JamChance = 0.04
SWEP.JamFactor = 0.06

SWEP.BoltAction = false --Unscope/sight after you shoot?
SWEP.BoltAction_Forced = false
SWEP.Scoped = false --Draw a scope overlay?
SWEP.ScopeOverlayThreshold = 0.875 --Percentage you have to be sighted in to see the scope.
SWEP.BoltTimerOffset = 0.25 --How long you stay sighted in after shooting, with a bolt action.
SWEP.ScopeScale = 0.5
SWEP.ReticleScale = 0.7

SWEP.MuzzleAttachment = "1"
SWEP.ShellAttachment = "2"

SWEP.MuzzleFlashEnabled = true
SWEP.MuzzleFlashEffect = nil
SWEP.MuzzleFlashEffectSilenced = "tfa_muzzleflash_silenced"
SWEP.CustomMuzzleFlash = true

SWEP.EjectionSmokeEnabled = true

SWEP.LuaShellEject = false
SWEP.LuaShellEjectDelay = 0
SWEP.LuaShellEffect = nil --Defaults to blowback

SWEP.SmokeParticle = nil --Smoke particle (ID within the PCF), defaults to something else based on holdtype

SWEP.StatusLengthOverride = {} --Changes the status delay of a given animation; only used on reloads.  Otherwise, use SequenceLengthOverride or one of the others
SWEP.SequenceLengthOverride = {} --Changes both the status delay and the nextprimaryfire of a given animation
SWEP.SequenceTimeOverride = {} --Like above but changes animation length to a target
SWEP.SequenceRateOverride = {} --Like above but scales animation length rather than being absolute

SWEP.BlowbackEnabled = false --Enable Blowback?
SWEP.BlowbackVector = Vector(0, -1, 0) --Vector to move bone <or root> relative to bone <or view> orientation.
SWEP.BlowbackCurrentRoot = 0 --Amount of blowback currently, for root
SWEP.BlowbackCurrent = 0 --Amount of blowback currently, for bones
SWEP.BlowbackBoneMods = nil --Viewmodel bone mods via SWEP Creation Kit
SWEP.Blowback_Only_Iron = true --Only do blowback on ironsights
SWEP.Blowback_PistolMode = false --Do we recover from blowback when empty?
SWEP.BlowbackAllowAnimation = false

SWEP.ProceduralHolsterEnabled = nil
SWEP.ProceduralHolsterTime = 0.3
SWEP.ProceduralHolsterPosition = Vector(3, 0, -5)
SWEP.ProceduralHolsterAngle = Vector(-40, -30, 10)

SWEP.IsProceduralReloadBased = false --Do we reload using lua instead of a .mdl animation
SWEP.ProceduralReloadTime = 1 --Time to take when procedurally reloading, including transition in (but not out)

SWEP.Blowback_PistolMode_Disabled = {
	[ACT_VM_RELOAD] = true,
	[ACT_VM_RELOAD_EMPTY] = true,
	[ACT_VM_DRAW_EMPTY] = true,
	[ACT_VM_IDLE_EMPTY] = true,
	[ACT_VM_HOLSTER_EMPTY] = true,
	[ACT_VM_DRYFIRE] = true,
	[ACT_VM_FIDGET] = true,
	[ACT_VM_FIDGET_EMPTY] = true
}

SWEP.Blowback_Shell_Enabled = true
SWEP.Blowback_Shell_Effect = "ShellEject"

SWEP.Secondary.Ammo = ""
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0

SWEP.Sights_Mode = TFA.Enum.LOCOMOTION_LUA -- ANI = mdl, HYBRID = lua but continue idle, Lua = stop mdl animation
SWEP.Sprint_Mode = TFA.Enum.LOCOMOTION_LUA -- ANI = mdl, HYBRID = ani + lua, Lua = lua only
SWEP.Walk_Mode = TFA.Enum.LOCOMOTION_LUA -- ANI = mdl, HYBRID = ani + lua, Lua = lua only
SWEP.Customize_Mode = TFA.Enum.LOCOMOTION_LUA -- ANI = mdl, HYBRID = ani + lua, Lua = lua only
SWEP.SprintFOVOffset = 5
SWEP.Idle_Mode = TFA.Enum.IDLE_BOTH --TFA.Enum.IDLE_DISABLED = no idle, TFA.Enum.IDLE_LUA = lua idle, TFA.Enum.IDLE_ANI = mdl idle, TFA.Enum.IDLE_BOTH = TFA.Enum.IDLE_ANI + TFA.Enum.IDLE_LUA
SWEP.Idle_Blend = 0.25 --Start an idle this far early into the end of a transition
SWEP.Idle_Smooth = 0.05 --Start an idle this far early into the end of another animation

SWEP.IronSightTime = 0.3
SWEP.IronSightsSensitivity = 1

SWEP.InspectPosDef = Vector(9.779, -11.658, -2.241)
SWEP.InspectAngDef = Vector(24.622, 42.915, 15.477)

SWEP.SprintViewModelPosition = Vector(0,0,0)
SWEP.SprintViewModelAngle = Vector(0,0,0)
SWEP.AllowSprintAttack = false --Shoot while sprinting?

SWEP.CrouchViewModelPosition = Vector(0, -1, -.5)
SWEP.CrouchViewModelAngle = Vector(0, 0, 0)

SWEP.Primary.RecoilLUT_IronSightsMult = 0.5
SWEP.Primary.RecoilLUT_AnglePunchMult = 0.25
SWEP.Primary.RecoilLUT_ViewPunchMult = 1

SWEP.EventTable = {}

SWEP.RTMaterialOverride = nil
SWEP.RTOpaque = false
SWEP.RTCode = nil--function(self) return end
SWEP.RTBGBlur = true

SWEP.ViewModelPosition = Vector(0,0,0)
SWEP.ViewModelAngle = Vector(0,0,0)
SWEP.CameraOffset = Angle(0, 0, 0)
SWEP.AdditiveViewModelPosition = true

SWEP.AllowIronSightsDoF = true

SWEP.Primary.DisplayFalloff = true

SWEP.IronAnimation = {
	--[[
	["in"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Idle_To_Iron", --Number for act, String/Number for sequence
		["value_empty"] = "Idle_To_Iron_Dry",
		["transition"] = true
	}, --Inward transition
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Idle_Iron", --Number for act, String/Number for sequence
		["value_empty"] = "Idle_Iron_Dry"
	}, --Looping Animation
	["out"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Iron_To_Idle", --Number for act, String/Number for sequence
		["value_empty"] = "Iron_To_Idle_Dry",
		["transition"] = true
	}, --Outward transition
	["shoot"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Fire_Iron", --Number for act, String/Number for sequence
		["value_last"] = "Fire_Iron_Last",
		["value_empty"] = "Fire_Iron_Dry"
	} --What do you think
	]]--
}

SWEP.SprintAnimation = {
	--[[
	["in"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Idle_to_Sprint", --Number for act, String/Number for sequence
		["value_empty"] = "Idle_to_Sprint_Empty",
		["transition"] = true
	}, --Inward transition
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Sprint_", --Number for act, String/Number for sequence
		["value_empty"] = "Sprint_Empty_",
		["is_idle"] = true
	},--looping animation
	["out"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Sprint_to_Idle", --Number for act, String/Number for sequence
		["value_empty"] = "Sprint_to_Idle_Empty",
		["transition"] = true
	} --Outward transition
	]]--
}

SWEP.ShootAnimation = {--[[
	["in"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "shoot_loop_start", --Number for act, String/Number for sequence
		["value_is"] = "shoot_loop_iron_start"
	},
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "shoot_loop", --Number for act, String/Number for sequence
		["value_is"] = "shoot_loop_iron",
		["is_idle"] = true
	},
	["out"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "shoot_loop_end", --Number for act, String/Number for sequence
		["value_is"] = "shoot_loop_iron_end"
	}]]--
}

SWEP.FirstDeployEnabled = nil--Force first deploy enabled

--[[Dont edit under this unless you know what u r doing]]

SWEP.IronSightsProgress = 0
SWEP.CLIronSightsProgress = 0
SWEP.SprintProgress = 0
SWEP.WalkProgress = 0
SWEP.SpreadRatio = 0
SWEP.CrouchingRatio = 0
SWEP.SmokeParticles = {
	pistol = "tfa_ins2_weapon_muzzle_smoke",
	smg = "tfa_ins2_weapon_muzzle_smoke",
	grenade = "tfa_ins2_weapon_muzzle_smoke",
	ar2 = "tfa_ins2_weapon_muzzle_smoke",
	shotgun = "tfa_ins2_weapon_muzzle_smoke",
	rpg = "tfa_ins2_weapon_muzzle_smoke",
	physgun = "tfa_ins2_weapon_muzzle_smoke",
	crossbow = "tfa_ins2_weapon_muzzle_smoke",
	melee = "tfa_ins2_weapon_muzzle_smoke",
	slam = "tfa_ins2_weapon_muzzle_smoke",
	normal = "tfa_ins2_weapon_muzzle_smoke",
	melee2 = "tfa_ins2_weapon_muzzle_smoke",
	knife = "tfa_ins2_weapon_muzzle_smoke",
	duel = "tfa_ins2_weapon_muzzle_smoke",
	camera = "tfa_ins2_weapon_muzzle_smoke",
	magic = "tfa_ins2_weapon_muzzle_smoke",
	revolver = "tfa_ins2_weapon_muzzle_smoke",
	silenced = "tfa_ins2_weapon_muzzle_smoke"
}
--[[ SWEP.SmokeParticles = {
	pistol = "weapon_muzzle_smoke",
	smg = "weapon_muzzle_smoke",
	grenade = "weapon_muzzle_smoke",
	ar2 = "weapon_muzzle_smoke",
	shotgun = "weapon_muzzle_smoke_long",
	rpg = "weapon_muzzle_smoke_long",
	physgun = "weapon_muzzle_smoke_long",
	crossbow = "weapon_muzzle_smoke_long",
	melee = "weapon_muzzle_smoke",
	slam = "weapon_muzzle_smoke",
	normal = "weapon_muzzle_smoke",
	melee2 = "weapon_muzzle_smoke",
	knife = "weapon_muzzle_smoke",
	duel = "weapon_muzzle_smoke",
	camera = "weapon_muzzle_smoke",
	magic = "weapon_muzzle_smoke",
	revolver = "weapon_muzzle_smoke_long",
	silenced = "weapon_muzzle_smoke"
}--]]
--[[
SWEP.SmokeParticles = {
	pistol = "smoke_trail_controlled",
	smg = "smoke_trail_tfa",
	grenade = "smoke_trail_tfa",
	ar2 = "smoke_trail_tfa",
	shotgun = "smoke_trail_wild",
	rpg = "smoke_trail_tfa",
	physgun = "smoke_trail_tfa",
	crossbow = "smoke_trail_tfa",
	melee = "smoke_trail_tfa",
	slam = "smoke_trail_tfa",
	normal = "smoke_trail_tfa",
	melee2 = "smoke_trail_tfa",
	knife = "smoke_trail_tfa",
	duel = "smoke_trail_tfa",
	camera = "smoke_trail_tfa",
	magic = "smoke_trail_tfa",
	revolver = "smoke_trail_tfa",
	silenced = "smoke_trail_controlled"
}
]]--

SWEP.Inspecting = false
SWEP.InspectingProgress = 0
SWEP.LuaShellRequestTime = -1
SWEP.BobScale = 0
SWEP.SwayScale = 0
SWEP.BoltDelay = 1
SWEP.ProceduralHolsterProgress = 0
SWEP.BurstCount = 0
SWEP.DefaultFOV = 90
SWEP.m_WeaponDeploySpeed = 255

--[[ Localize Functions  ]]
local function l_Lerp(v, f, t)
	return f + (t - f) * v
end
local l_mathApproach = math.Approach
local l_CT = CurTime
--[[Frequently Reused Local Vars]]
local stat --Weapon status
local ct  = 0--Curtime, frametime, real frametime
local sp = game.SinglePlayer() --Singleplayer
local developer = GetConVar("developer")

function SWEP:NetworkVarTFA(typeIn, nameIn)
	if not self.TrackedDTTypes then
		self.TrackedDTTypes = {
			Angle = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			Bool = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			Entity = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			Float = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			Int = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			String = {0, 1, 2, 3},
			Vector = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
		}

		if istable(self.dt) then
			local meta = getmetatable(self.dt)

			if istable(meta) and isfunction(meta.__index) then
				local name, value = debug.getupvalue(meta.__index, 1)

				if name == "datatable" and istable(value) then
					for variableName, variableData in SortedPairs(value) do
						if istable(variableData) and isstring(variableData.typename) and isnumber(variableData.index) then
							local trackedData = self.TrackedDTTypes[variableData.typename]

							if trackedData then
								table.RemoveByValue(trackedData, variableData.index)
							end
						end
					end
				end
			end
		end
	end

	if not self.TrackedDTTypes[typeIn] then
		error("Variable type " .. typeIn .. " is invalid")
	end

	local gatherindex = table.remove(self.TrackedDTTypes[typeIn], 1)

	if gatherindex then
		(self["NetworkVar_TFA"] or self["NetworkVar"])(self, typeIn, gatherindex, nameIn)
		return
	end

	local get = self["GetNW2" .. typeIn]
	local set = self["SetNW2" .. typeIn]

	self["Set" .. nameIn] = function(_self, value)
		set(_self, nameIn, value)
	end

	self["Get" .. nameIn] = function(_self, def)
		return get(_self, nameIn, def)
	end

	if developer:GetBool() then
		print("[TFA Base] developer 1: Variable " .. nameIn .. " can not use DTVars due to " .. typeIn .. " index exhaust")
	end
end

--[[
Function Name:  SetupDataTables
Syntax: Should not be manually called.
Returns:  Nothing.  Simple sets up DTVars to be networked.
Purpose:  Networking.
]]
function SWEP:SetupDataTables()
	self.TrackedDTTypes = nil
	self.NetworkVar_TFA = self.NetworkVar

	--self:NetworkVarTFA("Bool", "IronSights")
	self:NetworkVarTFA("Bool", "IronSightsRaw")
	self:NetworkVarTFA("Bool", "Sprinting")
	self:NetworkVarTFA("Bool", "Silenced")
	self:NetworkVarTFA("Bool", "ReloadLoopCancel")
	self:NetworkVarTFA("Bool", "Walking")
	self:NetworkVarTFA("Bool", "Customizing")

	self.GetShotgunCancel = self.GetReloadLoopCancel
	self.SetShotgunCancel = self.SetReloadLoopCancel

	self:NetworkVarTFA("Bool", "FlashlightEnabled")
	self:NetworkVarTFA("Bool", "Jammed")
	self:NetworkVarTFA("Bool", "FirstDeployEvent")
	self:NetworkVarTFA("Bool", "IsCyclingSafety")
	self:NetworkVarTFA("Bool", "SafetyCycleAnimated")
	self:NetworkVarTFA("Bool", "HasPlayedEmptyClick")

	self:NetworkVarTFA("Float", "StatusEnd")
	self:NetworkVarTFA("Float", "NextIdleAnim")
	self:NetworkVarTFA("Float", "NextLoopSoundCheck")
	self:NetworkVarTFA("Float", "JamFactor")
	self:NetworkVarTFA("Float", "EventTimer")
	self:NetworkVarTFA("Float", "LastGunFire")

	self:NetworkVarTFA("Int", "StatusRaw")
	self:NetworkVarTFA("Int", "FireMode")
	self:NetworkVarTFA("Int", "LastActivity")
	self:NetworkVarTFA("Int", "BurstCount")
	self:NetworkVarTFA("Int", "ShootStatus")
	self:NetworkVarTFA("Int", "EventStatus1")
	self:NetworkVarTFA("Int", "EventStatus2")
	self:NetworkVarTFA("Int", "EventStatus3")
	self:NetworkVarTFA("Int", "EventStatus4")
	self:NetworkVarTFA("Int", "EventStatus5")
	self:NetworkVarTFA("Int", "EventStatus6")
	self:NetworkVarTFA("Int", "EventStatus7")
	self:NetworkVarTFA("Int", "EventStatus8")

	self:NetworkVarTFA("Bool", "RecoilLoop")
	self:NetworkVarTFA("Bool", "RecoilThink")

	self:NetworkVarTFA("Float", "RecoilInProgress")
	self:NetworkVarTFA("Float", "RecoilInWait")
	self:NetworkVarTFA("Float", "RecoilLoopProgress")
	self:NetworkVarTFA("Float", "RecoilLoopWait")
	self:NetworkVarTFA("Float", "RecoilOutProgress")

	if not self.get_event_status_lut then
		self.get_event_status_lut = {}
		self.set_event_status_lut = {}

		for i = 1, 8 do
			self.get_event_status_lut[i] = self['GetEventStatus' .. i]
			self.set_event_status_lut[i] = self['SetEventStatus' .. i]
		end
	end

	self:NetworkVarTFA("Entity", "SwapTarget")

	self:NetworkVarNotify("Customizing", self.CustomizingUpdated)

	self:NetworkVarTFA("Float", "SpreadRatio")
	self:NetworkVarTFA("Float", "IronSightsProgress")
	self:NetworkVarTFA("Float", "ProceduralHolsterProgress")
	self:NetworkVarTFA("Float", "InspectingProgress")
	self:NetworkVarTFA("Float", "JumpRatio")
	self:NetworkVarTFA("Float", "CrouchingRatio")

	self:NetworkVarTFA("Float", "ViewPunchBuild")
	self:NetworkVarTFA("Float", "ViewPunchP")
	self:NetworkVarTFA("Float", "ViewPunchY")

	self:NetworkVarTFA("Float", "SprintProgress")
	self:NetworkVarTFA("Float", "WalkProgress")
	self:NetworkVarTFA("Float", "LastVelocity")

	self:NetworkVarTFA("Int", "AnimCycle")

	self:NetworkVarTFA("Vector", "QueuedRecoil")
	self:NetworkVarTFA("Float", "PrevRecoilAngleTime")
	self:NetworkVarTFA("Angle", "PrevRecoilAngle")

	self:NetworkVarTFA("Bool", "CustomizeUpdated")
	self:NetworkVarTFA("Bool", "IronSightsOldFinal")

	function self.NetworkVar(self2, typeIn, slotIn, nameIn)
		return self2:NetworkVarTFA(typeIn, nameIn)
	end

	self:NetworkVarTFA("Float", "StatusStart")
	self:NetworkVarTFA("Float", "LastSafetyShoot")

	self:NetworkVarTFA("Int", "LastSequence")
	self:NetworkVarTFA("Int", "DownButtons")
	self:NetworkVarTFA("Int", "LastPressedButtons")

	self:NetworkVarTFA("Float", "LastReloadPressed")

	self:NetworkVarTFA("Float", "LastIronSightsPressed")

	self.GetStatus = self.GetStatusRaw
	self.GetIronSights = self.GetIronSightsOldFinal
	self.GetIronSightsDirect = self.GetIronSightsOldFinal

	self:NetworkVarTFA("Bool", "IsFirstDeploy")
	self:NetworkVarTFA("Float", "LastDeployAnim")

	hook.Run("TFA_SetupDataTables", self)
end

function SWEP:GetStatusProgress(unpredicted)
	if self:GetStatus() == TFA.Enum.STATUS_IDLE then return 1 end
	local StatusStart = self:GetStatusStart()

	if StatusStart <= 0 then return end
	local StatusEnd = self:GetStatusEnd()

	if StatusStart > StatusEnd then return 1 end

	local time = unpredicted and (l_CT() + (self.CurTimePredictionAdvance or 0)) or l_CT()
	if StatusStart >= time then return 0 end
	if StatusEnd <= time then return 1 end

	return (time - StatusStart) / (StatusEnd - StatusStart)
end

function SWEP:GetStatusProgressTime(unpredicted)
	if self:GetStatus() == TFA.Enum.STATUS_IDLE then return 0 end
	local StatusStart = self:GetStatusStart()

	if StatusStart <= 0 then return end
	local StatusEnd = self:GetStatusEnd()

	if StatusStart > StatusEnd then return 0 end

	local time = unpredicted and (l_CT() + (self.CurTimePredictionAdvance or 0)) or l_CT()
	if StatusEnd <= time then return 0 end

	return StatusEnd - time
end

function SWEP:SetStatus(statusIn, timeOn)
	self:SetStatusRaw(statusIn)
	self:SetStatusStart(l_CT())

	if timeOn ~= nil then
		self:SetStatusEnd(timeOn)
	end
end

function SWEP:ScheduleStatus(statusIn, timeFor)
	self:SetStatusRaw(statusIn)
	local time = l_CT()
	self:SetStatusStart(time)
	self:SetStatusEnd(time + timeFor)
end

function SWEP:ExtendStatus(timeFor)
	self:SetStatusEnd(self:GetStatusEnd() + timeFor)
end

function SWEP:ExtendStatusTo(timeFor)
	self:SetStatusEnd(math.max(self:GetStatusEnd(), timeFor))
end

--[[
Function Name:  Initialize
Syntax: Should not be normally called.
Notes:   Called after actual SWEP code, but before deploy, and only once.
Returns:  Nothing.  Sets the intial values for the SWEP when it's created.
Purpose:  Standard SWEP Function
]]

local PistolHoldTypes = {
	["pistol"] = true,
	["357"] = true,
	["revolver"] = true
}
local MeleeHoldTypes = {
	["melee"] = true,
	["melee2"] = true,
	["knife"] = true
}

local patch_blacklist

do
	local string_sub = string.sub

	function patch_blacklist(input, structure_version)
		local target = {}

		for key in pairs(input) do
			target[TFA.RemapStatPath(key, TFA.LatestDataVersion, structure_version)] = true
		end

		table.Empty(input)

		setmetatable(input, {
			__index = target,
			__newindex = function(_, key, value)
				target[TFA.RemapStatPath(key, TFA.LatestDataVersion, structure_version)] = value
			end
		})

		return target
	end
end

function SWEP:Initialize()
	local self2 = self:GetTable()

	if self2.HasInitialized then
		ErrorNoHalt(debug.traceback("SWEP:Initialize was called out of order", 2) .. "\n")
		return
	end

	self2.HasInitialized = true

	--TFA.MigrateStructure(self, self2, self:GetClass(), true)

	hook.Run("TFA_PreInitialize", self)

	self2.DrawCrosshairDefault = self2.DrawCrosshair

	if not self2.BobScaleCustom or self2.BobScaleCustom <= 0 then
		self2.BobScaleCustom = 1
	end

	TFA.UnfoldBaseClass(self2.Primary)
	TFA.UnfoldBaseClass(self2.Secondary)

	TFA.UnfoldBaseClass(self2.Primary.PenetrationMaterials)

	TFA.UnfoldBaseClass(self2.AttachmentTableOverride)

	--[[for k, v in pairs(self2.AttachmentTableOverride) do
		if istable(v) and k ~= "BaseClass" then
			TFA.MigrateStructure(self, v, self:GetClass(), false)
		end
	end]]

	self2.Primary.BaseClass = nil
	self2.Secondary.BaseClass = nil

	if self2.Primary.DisplayIronSpread == nil then
		self2.Primary.DisplayIronSpread = self2.Primary.DisplaySpread
	end

	self2.Primary_TFA = table.Copy(self2.Primary)
	self2.Secondary_TFA = table.Copy(self2.Secondary)

	self2.BobScale = 0
	self2.SwayScaleCustom = 1
	self2.SwayScale = 0
	self2.SetSilenced(self, self2.Silenced or self2.DefaultSilenced)
	self2.Silenced = self2.Silenced or self2.DefaultSilenced
	self2.InitializeAnims(self)
	self2.InitializeMaterialTable(self)

	self2.RunAutoDetection(self)

	table.Merge(self2.Primary, self2.Primary_TFA)
	table.Merge(self2.Secondary, self2.Secondary_TFA)

	TFA.UnfoldBaseClass(self2.StatCache_Blacklist)
	self2.StatCache_Blacklist_Real = patch_blacklist(self2.StatCache_Blacklist, self2.TFADataVersion)

	TFA.UnfoldBaseClass(self2.Attachments)
	TFA.UnfoldBaseClass(self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion))
	TFA.UnfoldBaseClass(self2.ViewModelBoneMods)
	TFA.UnfoldBaseClass(self2.EventTable)

	TFA.UnfoldBaseClass(self2.Blowback_PistolMode_Disabled)
	TFA.UnfoldBaseClass(self2.IronAnimation)
	TFA.UnfoldBaseClass(self2.SprintAnimation)
	TFA.UnfoldBaseClass(self2.ShootAnimation)
	TFA.UnfoldBaseClass(self2.SmokeParticles)

	self2.ClearStatCache(self)

	self2.InitAttachments(self)

	self2.WorldModelBodygroups = self:GetStatRawL("WorldModelBodygroups")
	self2.ViewModelBodygroups = self:GetStatRawL("ViewModelBodygroups")

	if not self:GetStatRawL("AimingDownSightsSpeedMultiplier") then
		self:SetStatRawL("AimingDownSightsSpeedMultiplier", self:GetStatRawL("RegularMoveSpeedMultiplier") * 0.8)
	end

	if isnumber(self2.GetStatL(self, "Skin")) then
		self:SetSkin(self:GetStatL("Skin"))
	end

	self:ResetAnimCycle()
	self:ResetFirstDeploy()

	self:SetNextLoopSoundCheck(-1)
	self:SetShootStatus(TFA.Enum.SHOOT_IDLE)

	if SERVER and self:GetOwner():IsNPC() then
		local seq = self:GetOwner():LookupSequence("shootp1")

		if MeleeHoldTypes[self2.DefaultHoldType or self2.HoldType] then
			if self:GetOwner():GetSequenceName(seq) == "shootp1" then
				self:SetWeaponHoldType("melee2")
			else
				self:SetWeaponHoldType("melee")
			end
		elseif PistolHoldTypes[self2.DefaultHoldType or self2.HoldType] then
			if self:GetOwner():GetSequenceName(seq) == "shootp1" then
				self:SetWeaponHoldType("pistol")
			else
				self:SetWeaponHoldType("smg")
			end
		else
			self:SetWeaponHoldType(self2.DefaultHoldType or self2.HoldType)
		end

		if self:GetOwner():GetClass() == "npc_citizen" then
			self:GetOwner():Fire( "DisableWeaponPickup", "", 0 )
		end

		self:GetOwner():SetKeyValue("spawnflags", "256")

		return
	end

	hook.Run("TFA_Initialize", self)
end

function SWEP:NPCWeaponThinkHook()
	local self2 = self:GetTable()

	if not self:GetOwner():IsNPC() then
		hook.Remove("TFA_NPCWeaponThink", self)
		return
	end

	self2.Think(self)
end

--[[
Function Name:  Deploy
Syntax: self:Deploy()
Notes:  Called after self:Initialize().  Called each time you draw the gun.  This is also essential to clearing out old networked vars and resetting them.
Returns:  True/False to allow quickswitch.  Why not?  You should really return true.
Purpose:  Standard SWEP Function
]]

function SWEP:Deploy()
	local self2 = self:GetTable()
	hook.Run("TFA_PreDeploy", self)
	local ply = self:GetOwner()

	self2.IsNPCOwned = ply:IsNPC()

	if IsValid(ply) and IsValid(ply:GetViewModel()) then
		self2.OwnerViewModel = ply:GetViewModel()
	end

	if SERVER and self:GetStatL("FlashlightAttachment", 0) > 0 and IsValid(ply) and ply:IsPlayer() and ply:FlashlightIsOn() then
		if not self:GetFlashlightEnabled() then
			self:ToggleFlashlight(true)
		end

		ply:Flashlight(false)
	end

	if IsValid(ply) and ply:IsPlayer() then
		if CLIENT then
			self:ResetKeyBindHintAlpha()
		elseif sp then
			self:CallOnClient("ResetKeyBindHintAlpha")
		end
	end

	ct = l_CT()

	if not self2.VMIV(self) then
		print("Invalid VM on owner: ")
		print(ply)

		return
	end

	if not self2.HasDetectedValidAnimations then
		self:CacheAnimations()
	end

	local _, tanim, ttype = self:ChooseDrawAnim()

	if sp then
		self:CallOnClient("ChooseDrawAnim", "")
	end

	local len = self:GetActivityLength(tanim, false, ttype)

	self:ScheduleStatus(TFA.Enum.STATUS_DRAW, len)
	self:SetFirstDeployEvent(true)

	self:SetNextPrimaryFire(ct + len)
	self:SetIronSightsRaw(false)

	if not self:GetStatL("PumpAction") then
		self:SetReloadLoopCancel( false )
	end

	self:SetBurstCount(0)

	self:SetIronSightsProgress(0)
	self:SetSprintProgress(0)
	self:SetInspectingProgress(0)
	self:SetProceduralHolsterProgress(0)

	if self:GetCustomizing() then
		self:ToggleCustomize()
	end

	self2.DefaultFOV = TFADUSKFOV or ( IsValid(ply) and ply:GetFOV() or 90 )

	self:ApplyViewModelModifications()
	self:CallOnClient("ApplyViewModelModifications")

	local v = hook.Run("TFA_Deploy", self)

	if v ~= nil then return v end

	return true
end

--[[
Function Name:  Holster
Syntax: self:Holster( weapon entity to switch to )
Notes:  This is kind of broken.  I had to manually select the new weapon using ply:ConCommand.  Returning true is simply not enough.  This is also essential to clearing out old networked vars and resetting them.
Returns:  True/False to allow holster.  Useful for animations.
Purpose:  Standard SWEP Function
]]
function SWEP:Holster(target)
	local self2 = self:GetTable()

	local v = hook.Run("TFA_PreHolster", self, target)
	if v ~= nil then return v end

	if not IsValid(target) then
		self2.InspectingProgress = 0

		return true
	end

	if not IsValid(self) then return end
	ct = l_CT()
	stat = self:GetStatus()

	if not TFA.Enum.HolsterStatus[stat] then
		if stat == TFA.Enum.STATUS_RELOADING_WAIT and self:Clip1() <= self:GetStatL("Primary.ClipSize") and (not self:GetStatL("Primary.DisableChambering")) and (not self:GetStatL("LoopedReload")) then
			self:ResetFirstDeploy()

			if sp then
				self:CallOnClient("ResetFirstDeploy", "")
			end
		end

		local success, tanim, ttype = self:ChooseHolsterAnim()

		if IsFirstTimePredicted() then
			self:SetSwapTarget(target)
		end

		self:ScheduleStatus(TFA.Enum.STATUS_HOLSTER, success and self:GetActivityLength(tanim, false, ttype) or (self:GetStatL("ProceduralHolsterTime") / self:GetAnimationRate(ACT_VM_HOLSTER)))

		return false
	elseif stat == TFA.Enum.STATUS_HOLSTER_READY or stat == TFA.Enum.STATUS_HOLSTER_FINAL then
		self:ResetViewModelModifications()

		if IsValid(target) and target:IsWeapon() and not target.IsTFAWeapon then
			if CLIENT then
				self:ResetKeyBindHintAlpha(true)
			elseif sp then
				self:CallOnClient("ResetKeyBindHintAlpha", "true")
			end
		end

		return true
	end
end

function SWEP:FinishHolster()
	local self2 = self:GetTable()

	self:CleanParticles()

	local v2 = hook.Run("TFA_Holster", self)

	if self:GetOwner():IsNPC() then return end
	if v2 ~= nil then return v2 end

	if SERVER then
		local ent = self:GetSwapTarget()
		self:Holster(ent)

		if IsValid(ent) and ent:IsWeapon() then
			self:GetOwner():SelectWeapon(ent:GetClass())

			if ent.IsTFAWeapon then
				ent:ApplyViewModelModifications()
				ent:CallOnClient("ApplyViewModelModifications")
			end

			self2.OwnerViewModel = nil
		end
	end
end

--[[
Function Name:  OnRemove
Syntax: self:OnRemove()
Notes:  Resets bone mods and cleans up.
Returns:  Nil.
Purpose:  Standard SWEP Function
]]
function SWEP:OnRemove()
	local self2 = self:GetTable()

	if self2.CleanParticles then
		self2.CleanParticles(self)
	end

	if self2.ResetViewModelModifications then
		self2.ResetViewModelModifications(self)
	end

	return hook.Run("TFA_OnRemove", self)
end

--[[
Function Name:  OnDrop
Syntax: self:OnDrop()
Notes:  Resets bone mods and cleans up.
Returns:  Nil.
Purpose:  Standard SWEP Function
]]
function SWEP:OnDrop()
	local self2 = self:GetTable()

	if self2.CleanParticles then
		self2.CleanParticles(self)
	end

	-- if self2.ResetViewModelModifications then
	--  self:ResetViewModelModifications()
	-- end

	return hook.Run("TFA_OnDrop", self)
end

function SWEP:OwnerChanged() -- TODO: sometimes not called after switching weapon ???
	if not IsValid(self:GetOwner()) and self.ResetViewModelModifications then
		self:ResetViewModelModifications()
	end

	if SERVER then
		if self.IsNPCOwned and (not IsValid(self:GetOwner()) or not self:GetOwner():IsNPC()) then
			self:SetClip1(self:GetMaxClip1())
			self:SetClip2(self:GetMaxClip2())
		end
	end
end

--[[
Function Name:  Think
Syntax: self:Think()
Returns:  Nothing.
Notes:  This is blank.
Purpose:  Standard SWEP Function
]]
function SWEP:Think()
	local self2 = self:GetTable()
	self2.CalculateRatios(self)

	if self:GetOwner():IsNPC() and SERVER then
		if self2.ThinkNPC then self2.ThinkNPC(self) end
		self2.Think2(self, false)
	end

	stat = self2.GetStatus(self)

	if (not sp or SERVER) and not self:GetFirstDeployEvent() then
		self2.ProcessEvents(self, sp or IsFirstTimePredicted())
	end

	-- backward compatibility
	self2.AnimCycle = self:GetAnimCycle()

	if (not sp or SERVER) and ct > self:GetNextIdleAnim() and (TFA.Enum.ReadyStatus[stat] or (stat == TFA.Enum.STATUS_SHOOTING and TFA.Enum.ShootLoopingStatus[self:GetShootStatus()])) then
		self:ChooseIdleAnim()
	end

	self2.ProcessLoopFire(self)
end

function SWEP:PlayerThink(plyv, is_working_out_prediction_errors)
	if not self:NullifyOIV() then return end

	self:Think2(is_working_out_prediction_errors)
end

local sv_cheats = GetConVar("sv_cheats")
local host_timescale = GetConVar("host_timescale")

local function Clamp(a, b, c)
	if a < b then return b end
	if a > c then return c end
	return a
end

local Lerp = Lerp

function SWEP:ShouldPlaySafetyAnim()
	if self:IsSafety() then
		return not self.SprintProgressUnpredicted2 or self.SprintProgressUnpredicted2 < 0.3
	end

	if not TFA.FriendlyEncounter then return false end
	return not self:GetIronSights() and (self:GetLastGunFire() + 1 < CurTime()) and (not self.SprintProgressUnpredicted2 or self.SprintProgressUnpredicted2 < 0.3)
end

local tickInterval = engine.TickInterval()

function SWEP:PlayerThinkCL(plyv)
	local self2 = self:GetTable()

	if not self:NullifyOIV() then return end

	self:SmokePCFLighting()

	if sp then
		self:Think2(false)
	end

	local ft = RealFrameTime() * game.GetTimeScale() * (sv_cheats:GetBool() and host_timescale:GetFloat() or 1)

	if self2.GetStatL(self, "BlowbackEnabled") then
		if not self2.Blowback_PistolMode or self:Clip1() == -1 or self:Clip1() > 0.1 or self2.Blowback_PistolMode_Disabled[self:GetLastActivity()] or self2.Blowback_PistolMode_Disabled[self:GetLastSequence()] or self2.Blowback_PistolMode_Disabled[self:GetLastSequenceString()] then
			self2.BlowbackCurrent = l_mathApproach(self2.BlowbackCurrent, 0, self2.BlowbackCurrent * ft * 15)
		end

		self2.BlowbackCurrentRoot = l_mathApproach(self2.BlowbackCurrentRoot, 0, self2.BlowbackCurrentRoot * ft * 15)
	end

	local is = self2.GetIronSights(self)
	local spr = self2.GetSprinting(self)
	local walk = self2.GetWalking(self)
	local status = self2.GetStatus(self)

	local ist = is and 1 or 0
	local ist2 = TFA.Enum.ReloadStatus[self:GetStatus()] and ist * .25 or ist

	local reloadBlendMult, reloadBlendMult2 = 1, 1

	if not self:GetStatL("LoopedReload") and (status == TFA.Enum.STATUS_RELOADING or status == TFA.Enum.STATUS_RELOADING_WAIT) and self2.ReloadAnimationEnd and self2.ReloadAnimationStart then
		local time = l_CT()
		local progress = Clamp((time - self2.ReloadAnimationStart) / (self2.ReloadAnimationEnd - self2.ReloadAnimationStart), 0, 1)

		reloadBlendMult = TFA.Cubic(math.max(
			Clamp(progress - 0.7, 0, 0.3) / 0.3,
			Clamp(0.1 - progress, 0, 0.1) / 0.1
		))

		reloadBlendMult2 = (1 + reloadBlendMult) / 2
	elseif TFA.Enum.ReloadStatus[status] then
		reloadBlendMult = 0
		reloadBlendMult2 = 0.5
	end

	local fidgetBlendMult = 1

	if status == TFA.Enum.STATUS_FIDGET then
		local progress = self:GetStatusProgress(true)

		fidgetBlendMult = TFA.Cubic(math.max(
			Clamp(progress - 0.8, 0, 0.2) / 0.2,
			Clamp(0.1 - progress, 0, 0.1) / 0.1
		))
	end

	local sprt = spr and reloadBlendMult or 0
	local sprt2 = spr and (fidgetBlendMult * reloadBlendMult) or 0
	local sprt3 = spr and reloadBlendMult2 or 0

	local walkt = walk and 1 or 0

	local IronSightsPosition = self2.GetStatL(self, "IronSightsPosition", self2.SightsPos)
	local IronSightsAngle = self2.GetStatL(self, "IronSightsAngle", self2.SightsAng)

	if IronSightsPosition then
		self2.IronSightsPositionCurrent = self2.IronSightsPositionCurrent or Vector(IronSightsPosition)
		self2.IronSightsAngleCurrent = self2.IronSightsAngleCurrent or Vector(IronSightsAngle)

		self2.IronSightsPositionCurrent.x = Lerp(ft * 11, self2.IronSightsPositionCurrent.x, IronSightsPosition.x)
		self2.IronSightsPositionCurrent.y = Lerp(ft * 11, self2.IronSightsPositionCurrent.y, IronSightsPosition.y)
		self2.IronSightsPositionCurrent.z = Lerp(ft * 11, self2.IronSightsPositionCurrent.z, IronSightsPosition.z)

		self2.IronSightsAngleCurrent.x = Lerp(ft * 11, self2.IronSightsAngleCurrent.x, self2.IronSightsAngleCurrent.x - math.AngleDifference(self2.IronSightsAngleCurrent.x, IronSightsAngle.x))
		self2.IronSightsAngleCurrent.y = Lerp(ft * 11, self2.IronSightsAngleCurrent.y, self2.IronSightsAngleCurrent.y - math.AngleDifference(self2.IronSightsAngleCurrent.y, IronSightsAngle.y))
		self2.IronSightsAngleCurrent.z = Lerp(ft * 11, self2.IronSightsAngleCurrent.z, self2.IronSightsAngleCurrent.z - math.AngleDifference(self2.IronSightsAngleCurrent.z, IronSightsAngle.z))
	end

	local adstransitionspeed
	if is then
		adstransitionspeed = 12.5 / (self:GetStatL("IronSightTime") / 0.3)
	elseif spr or walk then
		adstransitionspeed = 7.5
	else
		adstransitionspeed = 12.5
	end
	adstransitionspeed = math.min(adstransitionspeed, 1000)

	local ply = self:GetOwner()
	local velocity = self2.LastUnpredictedVelocity or ply:GetVelocity()

	local jr_targ = math.min(math.abs(velocity.z) / 500, 1)
	self2.JumpRatioUnpredicted = l_mathApproach((self2.JumpRatioUnpredicted or 0), jr_targ, (jr_targ - (self2.JumpRatioUnpredicted or 0)) * ft * 20)
	self2.CrouchingRatioUnpredicted = l_mathApproach((self2.CrouchingRatioUnpredicted or 0), ((ply:Crouching() or self2.KeyDown(self, IN_DUCK)) and ply:OnGround() and not ply:InVehicle()) and 1 or 0, ft / self2.ToCrouchTime)

	self2.IronSightsProgressPredicted = self2.GetIronSightsProgress(self) + (ist - self2.GetIronSightsProgress(self)) * tickInterval * adstransitionspeed * TFA.TickDelta
	self2.SprintProgressPredicted = self2.GetSprintProgress(self) + (sprt - self2.GetSprintProgress(self)) * tickInterval * adstransitionspeed * TFA.TickDelta
	self2.InspectingProgressPredicted = self2.GetInspectingProgress(self) + ((self2.GetCustomizing(self) and 1 or 0) - self2.GetInspectingProgress(self)) * tickInterval * 10 * TFA.TickDelta

	self2.IronSightsProgressUnpredicted = l_mathApproach(self2.IronSightsProgressUnpredicted or 0, ist, (ist - (self2.IronSightsProgressUnpredicted or 0)) * ft * adstransitionspeed * 1.2)
	self2.IronSightsProgressUnpredicted2 = l_mathApproach(self2.IronSightsProgressUnpredicted2 or 0, ist, (ist - (self2.IronSightsProgressUnpredicted2 or 0)) * ft * adstransitionspeed * 0.4)
	self2.IronSightsProgressUnpredicted3 = l_mathApproach(self2.IronSightsProgressUnpredicted3 or 0, ist2, (ist2 - (self2.IronSightsProgressUnpredicted3 or 0)) * ft * adstransitionspeed * 0.7)
	self2.SprintProgressUnpredicted = l_mathApproach(self2.SprintProgressUnpredicted or 0, sprt, (sprt - (self2.SprintProgressUnpredicted or 0)) * ft * adstransitionspeed)
	self2.SprintProgressUnpredicted2 = l_mathApproach(self2.SprintProgressUnpredicted2 or 0, sprt2, (sprt2 - (self2.SprintProgressUnpredicted2 or 0)) * ft * adstransitionspeed)
	self2.SprintProgressUnpredicted3 = l_mathApproach(self2.SprintProgressUnpredicted3 or 0, sprt3, (sprt3 - (self2.SprintProgressUnpredicted3 or 0)) * ft * adstransitionspeed)

	if is and not self2.VM_IronPositionScore then
		self2.VM_IronPositionScore = Clamp(self2.GetStatL(self, "ViewModelPosition"):Distance(self2.IronSightsPositionCurrent or self2.GetStatL(self, "IronSightsPosition", self2.GetStat(self, "SightsPos", vector_origin))) / 7, 0, 1)
	elseif not is and self2.VM_IronPositionScore and self2.IronSightsProgressUnpredicted2 <= 0.08 then
		self2.VM_IronPositionScore = nil
	end

	if self2.IronSightsProgressUnpredicted2 >= 0.8 and not self2.VM_IsScopedIn then
		self2.VM_IsScopedIn = true
	--elseif self2.IronSightsProgressUnpredicted2 <= 0.1 and self2.VM_IsScopedIn then
	elseif self2.IronSightsProgressUnpredicted2 <= 0.15 then
		self2.VM_IsScopedIn = false
	end

	local customizingTarget = self:GetCustomizing() and 1 or 0
	self2.CustomizingProgressUnpredicted = l_mathApproach((self2.CustomizingProgressUnpredicted or 0), customizingTarget, (customizingTarget - (self2.CustomizingProgressUnpredicted or 0)) * ft * 5)

	self2.WalkProgressUnpredicted = l_mathApproach((self2.WalkProgressUnpredicted or 0), walkt, (walkt - (self2.WalkProgressUnpredicted or 0)) * ft * adstransitionspeed)

	if status ~= TFA.Enum.STATUS_FIREMODE or not self:GetIsCyclingSafety() then
		local safetyTarget = self:ShouldPlaySafetyAnim() and (fidgetBlendMult * reloadBlendMult) or 0
		self2.SafetyProgressUnpredicted = l_mathApproach(self2.SafetyProgressUnpredicted or 0, safetyTarget, (safetyTarget - (self2.SafetyProgressUnpredicted or 0)) * ft * adstransitionspeed * 0.7)
	elseif status == TFA.Enum.STATUS_FIREMODE and self:GetIsCyclingSafety() then
		if not self:ShouldPlaySafetyAnim() then
			local safetyTarget = 0

			if self:GetSafetyCycleAnimated() then
				self2.SafetyProgressUnpredicted = l_mathApproach(self2.SafetyProgressUnpredicted or 0, safetyTarget, (safetyTarget - (self2.SafetyProgressUnpredicted or 0)) * ft * adstransitionspeed * 1.1)
			else
				self2.SafetyProgressUnpredicted = l_mathApproach(self2.SafetyProgressUnpredicted or 0, safetyTarget, (safetyTarget - (self2.SafetyProgressUnpredicted or 0)) * ft * adstransitionspeed)
			end
		else
			local safetyTarget = fidgetBlendMult * reloadBlendMult

			if not self:GetSafetyCycleAnimated() then
				self2.SafetyProgressUnpredicted = l_mathApproach(self2.SafetyProgressUnpredicted or 0, safetyTarget, (safetyTarget - (self2.SafetyProgressUnpredicted or 0)) * ft * adstransitionspeed * 0.7)
			end
		end
	end
end

local UnPredictedCurTime = UnPredictedCurTime

--[[
Function Name:  Think2
Syntax: self:Think2().  Called from Think.
Returns:  Nothing.
Notes:  Essential for calling other important functions.
Purpose:  Standard SWEP Function
]]
function SWEP:Think2(is_working_out_prediction_errors)
	local self2 = self:GetTable()

	ct = l_CT()

	if not is_working_out_prediction_errors then
		if CLIENT then
			self2.CurTimePredictionAdvance = ct - UnPredictedCurTime()
		end

		if self2.LuaShellRequestTime > 0 and ct > self2.LuaShellRequestTime then
			self2.LuaShellRequestTime = -1
			self2.MakeShell(self)
		end

		if not self2.HasInitialized then
			self:Initialize()
		end

		if not self2.HasDetectedValidAnimations then
			self2.CacheAnimations(self)
			self2.ChooseDrawAnim(self)
		end

		self2.InitAttachments(self)

		self2.ProcessBodygroups(self)

		self2.ProcessHoldType(self)
		self2.ReloadCV(self)
		self2.IronSightSounds(self)
		self2.ProcessLoopSound(self)
	end

	self2.ProcessFireMode(self)

	if (not sp or SERVER) and self:GetFirstDeployEvent() then
		self2.ProcessEvents(self, sp or not is_working_out_prediction_errors)
	end

	--if is_working_out_prediction_errors then return end

	if not sp or SERVER then
		self2.IronSights(self)
	end

	self2.ProcessStatus(self)
end

SWEP.IronSightsReloadEnabled = false
SWEP.IronSightsReloadLock = true

function SWEP:IronSights()
	local self2 = self:GetTable()
	local owent = self:GetOwner()
	if not IsValid(owent) then return end

	ct = l_CT()
	stat = self:GetStatus()

	local issprinting = self:GetSprinting()
	local iswalking = self:GetWalking()

	local issighting = self:GetIronSightsRaw()
	local isplayer = owent:IsPlayer()
	local old_iron_sights_final = self:GetIronSightsOldFinal()

	if TFA.Enum.ReloadStatus[stat] and self2.GetStatL(self, "IronSightsReloadLock") then
		issighting = old_iron_sights_final
	end

	if issighting and isplayer and owent:InVehicle() and not owent:GetAllowWeaponsInVehicle() then
		issighting = false
		self:SetIronSightsRaw(false)
	end

	-- self:SetLastSightsStatusCached(false)
	local userstatus = issighting

	if issprinting then
		issighting = false
	end

	if issighting and not TFA.Enum.IronStatus[stat] and (not self:GetStatL("IronSightsReloadEnabled") or not TFA.Enum.ReloadStatus[stat]) then
		issighting = false
	end

	if issighting and self:IsSafety() then
		issighting = false
	end

	if stat == TFA.Enum.STATUS_FIREMODE and self:GetIsCyclingSafety() then
		issighting = false
	end

	local isbolt = self2.GetStatL(self, "BoltAction")
	local isbolt_forced = self2.GetStatL(self, "BoltAction_Forced")
	if isbolt or isbolt_forced then
		if stat == TFA.Enum.STATUS_SHOOTING and not self2.LastBoltShoot then
			self2.LastBoltShoot = l_CT()
		end

		if self2.LastBoltShoot then
			if stat == TFA.Enum.STATUS_SHOOTING then
				if l_CT() > self2.LastBoltShoot + self2.GetStatL(self, "BoltTimerOffset") then
					issighting = false
				end
			else
				self2.LastBoltShoot = nil
			end
		end

		if (stat == TFA.Enum.STATUS_IDLE and self:GetReloadLoopCancel(true)) or stat == TFA.Enum.STATUS_PUMP then
			issighting = false
		end
	end

	local sightsMode = self2.GetStatL(self, "Sights_Mode")
	local sprintMode = self2.GetStatL(self, "Sprint_Mode")
	local walkMode = self2.GetStatL(self, "Walk_Mode")
	local customizeMode = self2.GetStatL(self, "Customize_Mode")

	if old_iron_sights_final ~= issighting and sightsMode == TFA.Enum.LOCOMOTION_LUA then -- and stat == TFA.Enum.STATUS_IDLE then
		self:SetNextIdleAnim(-1)
	end

	local smi = (sightsMode ~= TFA.Enum.LOCOMOTION_LUA)
		and old_iron_sights_final ~= issighting

	local spi = (sprintMode ~= TFA.Enum.LOCOMOTION_LUA)
		and self2.sprinting_updated

	local wmi = (walkMode ~= TFA.Enum.LOCOMOTION_LUA)
		and self2.walking_updated

	local cmi = (customizeMode ~= TFA.Enum.LOCOMOTION_LUA)
		and self:GetCustomizeUpdated()

	self:SetCustomizeUpdated(false)

	if
		(smi or spi or wmi or cmi) and
		(self:GetStatus() == TFA.Enum.STATUS_IDLE or
			(self:GetStatus() == TFA.Enum.STATUS_SHOOTING and self:CanInterruptShooting()))
		and not self:GetReloadLoopCancel()
	then
		local toggle_is = old_iron_sights_final ~= issighting

		if issighting and self:GetSprinting() then
			toggle_is = true
		end

		local success, _ = self:Locomote(toggle_is and (sightsMode ~= TFA.Enum.LOCOMOTION_LUA), issighting, spi, issprinting, wmi, iswalking, cmi, self:GetCustomizing())

		if not success and (toggle_is and smi or spi or wmi or cmi) then
			self:SetNextIdleAnim(-1)
		end
	end

	self:SetIronSightsOldFinal(issighting)

	return userstatus, issighting
end

SWEP.is_sndcache_old = false

function SWEP:IronSightSounds()
	local self2 = self:GetTable()

	local is = self:GetIronSights()

	if SERVER or IsFirstTimePredicted() then
		if is ~= self2.is_sndcache_old and hook.Run("TFA_IronSightSounds", self) == nil then
			if is then
				self:EmitSound(self:GetStatL("Secondary.IronSightsInSound", "TFA.IronIn"))
			else
				self:EmitSound(self:GetStatL("Secondary.IronSightsOutSound", "TFA.IronOut"))
			end
		end

		self2.is_sndcache_old = is
	end
end

local legacy_reloads_cv = GetConVar("sv_tfa_reloads_legacy")
local dryfire_cvar = GetConVar("sv_tfa_allow_dryfire")

SWEP.Primary.Sound_DryFire = Sound("Weapon_Pistol.Empty2") -- dryfire sound, played only once
SWEP.Primary.Sound_DrySafety = Sound("Weapon_AR2.Empty2") -- safety click sound
SWEP.Primary.Sound_Blocked = Sound("Weapon_AR2.Empty") -- underwater click sound
SWEP.Primary.Sound_Jammed = Sound("Default.ClipEmpty_Rifle") -- jammed click sound

SWEP.Primary.SoundHint_Fire = true
SWEP.Primary.SoundHint_DryFire = true

local function Dryfire(self, self2, reload)
	if not dryfire_cvar:GetBool() and reload then
		self:Reload(true)
	end

	if self2.GetHasPlayedEmptyClick(self) then return end

	self2.SetHasPlayedEmptyClick(self, true)

	if SERVER and self:GetStatL("Primary.SoundHint_DryFire") then
		sound.EmitHint(SOUND_COMBAT, self:GetPos(), 500, 0.2, self:GetOwner())
	end

	if self:GetOwner():IsNPC() or self:KeyPressed(IN_ATTACK) then
		local enabled, tanim, ttype = self:ChooseDryFireAnim()

		if enabled then
			self:SetNextPrimaryFire(l_CT() + self:GetStatL("Primary.DryFireDelay", self:GetActivityLength(tanim, true, ttype)))
			return
		end
	end

	if IsFirstTimePredicted() then
		self:EmitSound(self:GetStatL("Primary.Sound_DryFire"))
	end
end

function SWEP:CanPrimaryAttack()
	local attackKeyPressed = false
	if IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
		attackKeyPressed = self:GetOwner():KeyPressed(IN_ATTACK)
	end

	local self2 = self:GetTable()

	local v = hook.Run("TFA_PreCanPrimaryAttack", self)

	if v ~= nil then
		return v
	end

	stat = self:GetStatus()

	if not TFA.Enum.ReadyStatus[stat] and stat ~= TFA.Enum.STATUS_SHOOTING then
		if attackKeyPressed and self:GetStatL("LoopedReload") and TFA.Enum.ReloadStatus[stat] then
			self:SetReloadLoopCancel(true)
		end

		return false
	end

	if self:IsSafety() then
		if attackKeyPressed then
			if IsFirstTimePredicted() then
				self:EmitSound(self:GetStatL("Primary.Sound_DrySafety"))

				if SERVER and self:GetStatL("Primary.SoundHint_DryFire") then
					sound.EmitHint(SOUND_COMBAT, self:GetPos(), 200, 0.2, self:GetOwner())
				end
			end

			if l_CT() < self:GetLastSafetyShoot() + 0.2 then
				self:CycleSafety()
				-- self:SetNextPrimaryFire(l_CT() + 0.1)
			end

			self:SetLastSafetyShoot(l_CT() + 0.2)
		end

		return false
	end

	if self:GetSprintProgress() >= 0.1 and not self:GetStatL("AllowSprintAttack", false) then
		return false
	end

	if self:GetStatL("Primary.ClipSize") <= 0 and self:Ammo1() < self:GetStatL("Primary.AmmoConsumption") then
		Dryfire(self, self2)
		return false
	end

	if self:GetPrimaryClipSize(true) > 0 and self:Clip1() < self:GetStatL("Primary.AmmoConsumption") then
		Dryfire(self, self2, true)
		return false
	end

	if self2.GetStatL(self, "Primary.FiresUnderwater") == false and self:GetOwner():WaterLevel() >= 3 then
		self:SetNextPrimaryFire(l_CT() + 0.5)
		self:EmitSound(self:GetStatL("Primary.Sound_Blocked"))
		return false
	end

	self2.SetHasPlayedEmptyClick(self, false)

	if l_CT() < self:GetNextPrimaryFire() then return false end

	local v2 = hook.Run("TFA_CanPrimaryAttack", self)

	if v2 ~= nil then
		return v2
	end

	if self:CheckJammed() then
		if IsFirstTimePredicted() then
			self:EmitSound(self:GetStatL("Primary.Sound_Jammed"))
		end

		local typev, tanim = self:ChooseAnimation("shoot1_empty")

		if typev ~= TFA.Enum.ANIMATION_SEQ then
			self:SendViewModelAnim(tanim)
		else
			self:SendViewModelSeq(tanim)
		end

		self:SetNextPrimaryFire(l_CT() + 1)

		return false
	end

	return true
end

function SWEP:EmitGunfireLoop()
	local self2 = self:GetTable()
	local tgtSound = self:GetStatL("Primary.LoopSound")

	if self:GetSilenced() then
		tgtSound = self:GetStatL("Primary.LoopSoundSilenced", tgtSound)
	end

	if (not sp and SERVER) or not self:IsFirstPerson() then
		tgtSound = self:GetSilenced() and self:GetStatL("Primary.LoopSoundSilenced_World", tgtSound) or self:GetStatL("Primary.LoopSound_World", tgtSound)
	end

	if self:GetNextLoopSoundCheck() < 0 or (l_CT() >= self:GetNextLoopSoundCheck() and self2.LastLoopSound ~= tgtSound) then
		if self2.LastLoopSound ~= tgtSound and self2.LastLoopSound ~= nil then
			self:StopSound(self2.LastLoopSound)
		end

		self2.LastLoopSound = tgtSound
		self2.GunfireLoopIFTPHack = true

		self:EmitSoundNet(tgtSound, nil, true)
	end

	self:SetNextLoopSoundCheck(CurTime() + self:GetFireDelay())
end

function SWEP:EmitGunfireSound(soundscript)
	self:EmitSoundNet(soundscript)
end

local sv_tfa_nearlyempty = GetConVar("sv_tfa_nearlyempty")

SWEP.LowAmmoSoundThreshold = 0.33

function SWEP:EmitLowAmmoSound()
	if not sv_tfa_nearlyempty:GetBool() then return end

	local self2 = self:GetTable()

	if not self2.FireSoundAffectedByClipSize then return end

	local clip1, maxclip1 = self:Clip1(), self:GetMaxClip1()
	if clip1 <= 0 then return end

	local nextclip1 = clip1 - self:GetStatL("Primary.AmmoConsumption", 1)
	if self:GetStatL("IsAkimbo") then
		nextclip1 = nextclip1 - self:GetAnimCycle()
	end

	local mult = nextclip1 / maxclip1
	if mult >= self2.LowAmmoSoundThreshold then return end

	local soundname = (nextclip1 <= 0) and self:GetStatL("LastAmmoSound", "") or self:GetStatL("LowAmmoSound", "")

	if soundname and soundname ~= "" then
		self2.GonnaAdjustVol = true
		self2.RequiredVolume = 1 - (mult / math.max(self2.LowAmmoSoundThreshold, 0.01))

		self:EmitSound(soundname)
	end
end

function SWEP:TriggerAttack(tableName, clipID)
	local self2 = self:GetTable()
	local ply = self:GetOwner()

	local fnname = clipID == 2 and "Secondary" or "Primary"

	if TFA.Enum.ShootReadyStatus[self:GetShootStatus()] then
		self:SetShootStatus(TFA.Enum.SHOOT_IDLE)
	end

	if self:GetStatRawL("CanBeSilenced") and (ply.KeyDown and self:KeyDown(IN_USE)) and (SERVER or not sp) and (ply.GetInfoNum and ply:GetInfoNum("cl_tfa_keys_silencer", 0) == 0) then
		local _, tanim, ttype = self:ChooseSilenceAnim(not self:GetSilenced())
		self:ScheduleStatus(TFA.Enum.STATUS_SILENCER_TOGGLE, self:GetActivityLength(tanim, true, ttype))

		return
	end

	self["SetNext" .. fnname .. "Fire"](self, self2["GetNextCorrected" .. fnname .. "Fire"](self, self2.GetFireDelay(self)))

	if self:GetMaxBurst() > 1 then
		self:SetBurstCount(math.max(1, self:GetBurstCount() + 1))
	end

	if self:GetStatL("PumpAction") and self:GetReloadLoopCancel() then return end

	self:SetStatus(TFA.Enum.STATUS_SHOOTING, self["GetNext" .. fnname .. "Fire"](self))
	self:ToggleAkimbo()
	self:IncreaseRecoilLUT()

	local ifp = IsFirstTimePredicted()

	local _, tanim, ttype = self:ChooseShootAnim(ifp)

	ply:SetAnimation(PLAYER_ATTACK1)

	if SERVER and self:GetStatL(tableName .. ".SoundHint_Fire") then
		sound.EmitHint(bit.bor(SOUND_COMBAT, SOUND_CONTEXT_GUNFIRE), self:GetPos(), self:GetSilenced() and 500 or 1500, 0.2, self:GetOwner())
	end

	if self:GetStatL(tableName .. ".Sound") and ifp and not (sp and CLIENT) then
		if ply:IsPlayer() and self:GetStatL(tableName .. ".LoopSound") and self:ShouldEmitGunfireLoop(tableName) then
			self:EmitGunfireLoop()
		else
			local tgtSound = self:GetStatL(tableName .. ".Sound")

			if self:GetSilenced() then
				tgtSound = self:GetStatL(tableName .. ".SilencedSound", tgtSound)
			end

			if (not sp and SERVER) or not self:IsFirstPerson() then
				tgtSound = self:GetSilenced() and self:GetStatL(tableName .. ".SilencedSound_World", tgtSound) or self:GetStatL(tableName .. ".Sound_World", tgtSound)
			end

			self:EmitGunfireSound(tgtSound)
		end

		self:EmitLowAmmoSound()
	end

	self2["Take" .. fnname .. "Ammo"](self, self:GetStatL(tableName .. ".AmmoConsumption"))

	if self["Clip" .. clipID](self) == 0 and self:GetStatL(tableName .. ".ClipSize") > 0 then
		self["SetNext" .. fnname .. "Fire"](self, math.max(self["GetNext" .. fnname .. "Fire"](self), l_CT() + (self:GetStatL(tableName .. ".DryFireDelay", self:GetActivityLength(tanim, true, ttype)))))
	end

	self:ShootBulletInformation()
	self:UpdateJamFactor()
	local _, CurrentRecoil = self:CalculateConeRecoil()
	self:Recoil(CurrentRecoil, ifp)

	-- shouldn't this be not required since recoil state is completely networked?
	if sp and SERVER then
		self:CallOnClient("Recoil", "")
	end

	if self:GetStatL(tableName .. ".MuzzleFlashEnabled", self:GetStatL("MuzzleFlashEnabled")) and (not self:IsFirstPerson() or not self:GetStatL(tableName .. ".AutoDetectMuzzleAttachment", self:GetStatL("AutoDetectMuzzleAttachment"))) then
		self:ShootEffectsCustom()
	end

	if self:GetStatL(tableName .. ".EjectionSmoke", self:GetStatL("EjectionSmoke")) and CLIENT and ply == LocalPlayer() and ifp and not self:GetStatL(tableName .. ".LuaShellEject", self:GetStatL("LuaShellEject")) then
		self:EjectionSmoke()
	end

	self:DoAmmoCheck(clipID)

	-- Condition self:GetStatus() == TFA.Enum.STATUS_SHOOTING is always true?
	if self:GetStatus() == TFA.Enum.STATUS_SHOOTING and self:GetStatL("PumpAction") then
		if self["Clip" .. clipID](self) == 0 and self:GetStatL("PumpAction.value_empty") then
			self:SetReloadLoopCancel(true)
		elseif (self:GetStatL(tableName .. ".ClipSize") < 0 or self["Clip" .. clipID](self) > 0) and self:GetStatL("PumpAction.value") then
			self:SetReloadLoopCancel(true)
		end
	end

	self:RollJamChance()
end

function SWEP:PrimaryAttack()
	local self2 = self:GetTable()
	local ply = self:GetOwner()
	if not IsValid(ply) then return end

	if not IsValid(self) then return end
	if ply:IsPlayer() and not self:VMIV() then return end
	if not self:CanPrimaryAttack() then return end

	self:PrePrimaryAttack()

	if hook.Run("TFA_PrimaryAttack", self) then return end

	self:TriggerAttack("Primary", 1)

	self:PostPrimaryAttack()
	hook.Run("TFA_PostPrimaryAttack", self)
end

function SWEP:PrePrimaryAttack()
	-- override
end

function SWEP:PostPrimaryAttack()
	-- override
end

function SWEP:CanSecondaryAttack()
	-- override
end

function SWEP:SecondaryAttack()
	self:PreSecondaryAttack()

	if hook.Run("TFA_SecondaryAttack", self) then return end

	if not self:GetStatL("Secondary.IronSightsEnabled", false) and self.AltAttack and self:GetOwner():IsPlayer() then
		self:AltAttack()
		self:PostSecondaryAttack()
		return
	end

	self:PostSecondaryAttack()
end

function SWEP:PreSecondaryAttack()
	-- override
end

function SWEP:PostSecondaryAttack()
	-- override
end

function SWEP:GetLegacyReloads()
	return legacy_reloads_cv:GetBool()
end

do
	local bit_band = bit.band

	function SWEP:KeyDown(keyIn)
		return bit_band(self:GetDownButtons(), keyIn) == keyIn
	end

	function SWEP:KeyPressed(keyIn)
		return bit_band(self:GetLastPressedButtons(), keyIn) == keyIn
	end
end

if SERVER and sp then
	util.AddNetworkString("tfa_reload_blending")
elseif CLIENT and sp then
	net.Receive("tfa_reload_blending", function()
		local self = net.ReadEntity()
		if not IsValid(self) then return end
		self.ReloadAnimationStart = net.ReadDouble()
		self.ReloadAnimationEnd = net.ReadDouble()
	end)
end

function SWEP:Reload(released)
	local self2 = self:GetTable()

	self:PreReload(released)

	if hook.Run("TFA_PreReload", self, released) then return end

	local isplayer = self:GetOwner():IsPlayer()
	local vm = self2.VMIV(self)

	if isplayer and not vm then return end

	if not self:IsJammed() then
		if self:Ammo1() <= 0 then return end
		if self:GetStatL("Primary.ClipSize") < 0 then return end
	end

	if not released and not self:GetLegacyReloads() then return end
	if self:GetLegacyReloads() and not dryfire_cvar:GetBool() and not self:KeyDown(IN_RELOAD) then return end
	if self:KeyDown(IN_USE) then return end

	ct = l_CT()
	stat = self:GetStatus()

	if self:GetStatL("PumpAction") and self:GetReloadLoopCancel() then
		if stat == TFA.Enum.STATUS_IDLE then
			self:DoPump()
		end
	elseif TFA.Enum.ReadyStatus[stat] or (stat == TFA.Enum.STATUS_SHOOTING and self:CanInterruptShooting()) or self:IsJammed() then
		if self:Clip1() < self:GetPrimaryClipSize() or self:IsJammed() then
			if hook.Run("TFA_Reload", self) then return end
			self:SetBurstCount(0)

			if self:GetStatL("LoopedReload") then
				local _, tanim, ttype = self:ChooseShotgunReloadAnim()

				if self:GetStatL("ShotgunStartAnimShell") then
					self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY)
				elseif self2.ShotgunEmptyAnim then
					local _, tg = self:ChooseAnimation("reload_empty")
					local action = tanim

					if type(tg) == "string" and tonumber(tanim) and tonumber(tanim) > 0 and isplayer then
						if ttype == TFA.Enum.ANIMATION_ACT then
							action = vm:GetSequenceName(vm:SelectWeightedSequenceSeeded(tanim, self:GetSeedIrradical()))
						else
							action = vm:GetSequenceName(tanim)
						end
					end

					if action == tg and self:GetStatL("ShotgunEmptyAnim_Shell") then
						self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY)
					else
						self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START)
					end
				else
					self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START)
				end

				self:SetStatusEnd(ct + self:GetActivityLength(tanim, true, ttype))
				--self:SetNextPrimaryFire(ct + self:GetActivityLength( tanim, false ) )
			else
				local _, tanim, ttype = self:ChooseReloadAnim()

				self:SetStatus(TFA.Enum.STATUS_RELOADING)

				if self:GetStatL("IsProceduralReloadBased") then
					self:SetStatusEnd(ct + self:GetStatL("ProceduralReloadTime"))
				else
					self:SetStatusEnd(ct + self:GetActivityLength(tanim, true, ttype))
					self:SetNextPrimaryFire(ct + self:GetActivityLength(tanim, false, ttype))
				end

				if CLIENT then
					self2.ReloadAnimationStart = ct
					self2.ReloadAnimationEnd = ct + self:GetActivityLength(tanim, false, ttype)
				elseif sp then
					net.Start("tfa_reload_blending", true)
					net.WriteEntity(self)
					net.WriteDouble(ct)
					net.WriteDouble(ct + self:GetActivityLength(tanim, false, ttype))
					net.Broadcast()
				end
			end

			self:GetOwner():SetAnimation(PLAYER_RELOAD)

			if self:GetStatL("Primary.ReloadSound") and IsFirstTimePredicted() then
				self:EmitSound(self:GetStatL("Primary.ReloadSound"))
			end

			self:ResetAnimCycle()

			self:SetNextPrimaryFire( -1 )
		elseif released or self:KeyPressed(IN_RELOAD) then--if self:GetOwner():KeyPressed(IN_RELOAD) or not self:GetLegacyReloads() then
			self:CheckAmmo()
		end
	end

	self:PostReload(released)

	hook.Run("TFA_PostReload", self)
end

function SWEP:PreReload(released)
	-- override
end

function SWEP:PostReload(released)
	-- override
end

function SWEP:Reload2(released)
	local self2 = self:GetTable()

	local isplayer = self:GetOwner():IsPlayer()
	local vm = self2.VMIV(self)

	if isplayer and not vm then return end

	if self:Ammo2() <= 0 then return end
	if self:GetStatL("Secondary.ClipSize") < 0 then return end
	if not released and not self:GetLegacyReloads() then return end
	if self:GetLegacyReloads() and not dryfire_cvar:GetBool() and not self:KeyDown(IN_RELOAD) then return end
	if self:KeyDown(IN_USE) then return end

	ct = l_CT()
	stat = self:GetStatus()

	if self:GetStatL("PumpAction") and self:GetReloadLoopCancel() then
		if stat == TFA.Enum.STATUS_IDLE then
			self:DoPump()
		end
	elseif TFA.Enum.ReadyStatus[stat] or ( stat == TFA.Enum.STATUS_SHOOTING and self:CanInterruptShooting() ) then
		if self:Clip2() < self:GetSecondaryClipSize() then
			if self:GetStatL("LoopedReload") then
				local _, tanim, ttype = self:ChooseShotgunReloadAnim()

				if self2.ShotgunEmptyAnim  then
					local _, tg = self:ChooseAnimation("reload_empty")
					local action = tanim

					if type(tg) == "string" and tonumber(tanim) and tonumber(tanim) > 0 and isplayer then
						if ttype == TFA.Enum.ANIMATION_ACT then
							action = vm:GetSequenceName(vm:SelectWeightedSequenceSeeded(tanim, self:GetSeedIrradical()))
						else
							action = vm:GetSequenceName(tanim)
						end
					end

					if action == tg and self:GetStatL("ShotgunEmptyAnim_Shell") then
						self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY)
					else
						self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START)
					end
				else
					self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START)
				end

				self:SetStatusEnd(ct + self:GetActivityLength(tanim, true, ttype))
				--self:SetNextPrimaryFire(ct + self:GetActivityLength( tanim, false ) )
			else
				local _, tanim, ttype = self:ChooseReloadAnim()

				self:SetStatus(TFA.Enum.STATUS_RELOADING)

				if self:GetStatL("IsProceduralReloadBased") then
					self:SetStatusEnd(ct + self:GetStatL("ProceduralReloadTime"))
				else
					self:SetStatusEnd(ct + self:GetActivityLength(tanim, true, ttype))
					self:SetNextPrimaryFire(ct + self:GetActivityLength(tanim, false, ttype))
				end

				if CLIENT then
					self2.ReloadAnimationStart = ct
					self2.ReloadAnimationEnd = ct + self:GetActivityLength(tanim, false, ttype)
				end
			end

			self:GetOwner():SetAnimation(PLAYER_RELOAD)

			if self:GetStatL("Secondary.ReloadSound") and IsFirstTimePredicted() then
				self:EmitSound(self:GetStatL("Secondary.ReloadSound"))
			end

			self:SetNextPrimaryFire( -1 )
		elseif released or self:KeyPressed(IN_RELOAD) then--if self:GetOwner():KeyPressed(IN_RELOAD) or not self:GetLegacyReloads() then
			self:CheckAmmo()
		end
	end
end

function SWEP:DoPump()
	if hook.Run("TFA_Pump", self) then return end

	local _, tanim, activityType = self:PlayAnimation(self:GetStatL("PumpAction"))

	self:ScheduleStatus(TFA.Enum.STATUS_PUMP, self:GetActivityLength(tanim, true, activityType))
	self:SetNextPrimaryFire(l_CT() + self:GetActivityLength(tanim, false, activityType))
	self:SetNextIdleAnim(math.max(self:GetNextIdleAnim(), l_CT() + self:GetActivityLength(tanim, false, activityType)))
end

function SWEP:LoadShell()
	if hook.Run("TFA_LoadShell", self) then return end

	local _, tanim, ttype = self:ChooseReloadAnim()

	if self:GetActivityLength(tanim, true, ttype) < self:GetActivityLength(tanim, false, ttype) then
		self:SetStatusEnd(ct + self:GetActivityLength(tanim, true, ttype))
	else
		local sht = self:GetStatL("LoopedReloadInsertTime")
		if sht then sht = sht / self:GetAnimationRate(ACT_VM_RELOAD) end
		self:SetStatusEnd(ct + ( sht or self:GetActivityLength(tanim, true, ttype)))
	end

	return TFA.Enum.STATUS_RELOADING_LOOP
end

function SWEP:CompleteReload()
	if hook.Run("TFA_CompleteReload", self) then return end

	local maxclip = self:GetPrimaryClipSizeForReload(true)
	local curclip = self:Clip1()
	local amounttoreplace = math.min(maxclip - curclip, self:Ammo1())
	self:TakePrimaryAmmo(amounttoreplace * -1)
	self:TakePrimaryAmmo(amounttoreplace, true)
	self:SetJammed(false)
end

function SWEP:CheckAmmo()
	if hook.Run("TFA_CheckAmmo", self) then return end

	local self2 = self:GetTable()

	if self2.GetIronSights(self) or self2.GetSprinting(self) then return end

	--if self2.NextInspectAnim == nil then
	--  self2.NextInspectAnim = -1
	--end

	if self:GetOwner().GetInfoNum and self:GetOwner():GetInfoNum("cl_tfa_keys_inspect", 0) > 0 then
		return
	end

	if (self:GetActivityEnabled(ACT_VM_FIDGET) or self2.InspectionActions) and self:GetStatus() == TFA.Enum.STATUS_IDLE then--and CurTime() > self2.NextInspectAnim then
		local _, tanim, ttype = self:ChooseInspectAnim()
		self:ScheduleStatus(TFA.Enum.STATUS_FIDGET, self:GetActivityLength(tanim, false, ttype))
	end
end

local cv_strip = GetConVar("sv_tfa_weapon_strip")

function SWEP:DoAmmoCheck(clipID)
	if self:GetOwner():IsNPC() then return end
	if clipID == nil then clipID = 1 end
	local self2 = self:GetTable()

	if IsValid(self) and SERVER and cv_strip:GetBool() and self["Clip" .. clipID](self) == 0 and self["Ammo" .. clipID](self) == 0 then
		timer.Simple(.1, function()
			if SERVER and IsValid(self) and self:OwnerIsValid() then
				self:GetOwner():StripWeapon(self2.ClassName)
			end
		end)
	end
end

--[[
Function Name:  AdjustMouseSensitivity
Syntax: Should not normally be called.
Returns:  SWEP sensitivity multiplier.
Purpose:  Standard SWEP Function
]]

local fovv
local sensval
local sensitivity_cvar, sensitivity_fov_cvar, sensitivity_speed_cvar
if CLIENT then
	sensitivity_cvar = GetConVar("cl_tfa_scope_sensitivity")
	sensitivity_fov_cvar = GetConVar("cl_tfa_scope_sensitivity_autoscale")
	sensitivity_speed_cvar = GetConVar("sv_tfa_scope_gun_speed_scale")
end

function SWEP:AdjustMouseSensitivity()
	sensval = 1

	if self:GetIronSights() then
		sensval = sensval * sensitivity_cvar:GetFloat() / 100

		if sensitivity_fov_cvar:GetBool() then
			fovv = self:GetStatL("Secondary.OwnerFOV") or 70
			sensval = sensval * TFA.CalculateSensitivtyScale( fovv, nil, 1 )
		else
			sensval = sensval
		end

		if sensitivity_speed_cvar:GetFloat() then
			-- weapon heaviness
			sensval = sensval * self:GetStatL("AimingDownSightsSpeedMultiplier")
		end
	end

	sensval = sensval * l_Lerp(self:GetIronSightsProgress(), 1, self:GetStatL( "IronSightsSensitivity" ) )
	return sensval
end

--[[
Function Name:  TranslateFOV
Syntax: Should not normally be called.  Takes default FOV as parameter.
Returns:  New FOV.
Purpose:  Standard SWEP Function
]]

local cv_fov_sprintmult = GetConVar("sv_tfa_fov_sprintmod")

function SWEP:TranslateFOV(fov)
	local self2 = self:GetTable()

	self2.LastTranslatedFOV = fov

	local retVal = hook.Run("TFA_PreTranslateFOV", self, fov)

	if retVal then return retVal end

	self2.CorrectScopeFOV(self)

	local ironprog = self2.IronSightsProgressPredicted or self2.GetIronSightsProgress(self)
	if self2.GetStatL(self, "Secondary.OwnerFOVUseThreshold", self2.GetStatL(self, "Scoped")) then
		local threshold = math.min(self2.GetStatL(self, "Secondary.OwnerFOVThreshold", self2.GetStatL(self, "ScopeOverlayThreshold")), 0.999999)

		ironprog = ironprog < threshold and 0 or math.max(ironprog - threshold, 0) / (1 - threshold)
	end

	local nfov = l_Lerp(ironprog, fov, fov * math.min(self2.GetStatL(self, "Secondary.OwnerFOV") / 90, 1))

	local ret = nfov
	if cv_fov_sprintmult:GetBool() then
		ret = l_Lerp(self2.SprintProgressPredicted or self2.GetSprintProgress(self), nfov, nfov + self2.GetStatL(self, "SprintFOVOffset", 5))
	end

	if self2.OwnerIsValid(self) and not self2.IsMelee then
		local vpa = self:GetOwner():GetViewPunchAngles()

		ret = ret + math.abs(vpa.p) / 4 + math.abs(vpa.y) / 4 + math.abs(vpa.r) / 4
	end

	ret = hook.Run("TFA_TranslateFOV", self, ret) or ret

	return ret
end

function SWEP:GetPrimaryAmmoType()
	return self:GetStatL("Primary.Ammo") or ""
end

function SWEP:ToggleInspect()
	if self:GetOwner():IsNPC() then return false end -- NPCs can't look at guns silly

	local self2 = self:GetTable()

	if (self:GetSprinting() or self:GetIronSights() or self:GetStatus() ~= TFA.Enum.STATUS_IDLE) and not self:GetCustomizing() then return end

	self:SetCustomizing(not self:GetCustomizing())
	self2.Inspecting = self:GetCustomizing()
	self:SetCustomizeUpdated(true)

	--if self2.Inspecting then
	--  gui.EnableScreenClicker(true)
	--else
	--  gui.EnableScreenClicker(false)
	--end

	return self:GetCustomizing()
end

SWEP.ToggleCustomize = SWEP.ToggleInspect

function SWEP:GetIsInspecting()
	return self:GetCustomizing()
end

function SWEP:CustomizingUpdated(_, old, new)
	if old ~= new and self._inspect_hack ~= new then
		self._inspect_hack = new

		if new then
			self:OnCustomizationOpen()
		else
			self:OnCustomizationClose()
		end
	end
end

function SWEP:OnCustomizationOpen()
	-- override
	-- example:
	--[[
		if CLIENT then surface.PlaySound("ui/buttonclickrelease.wav") end
	]]
end

function SWEP:OnCustomizationClose()
	-- override
end

function SWEP:CanBeJammed()
	return self.CanJam and self:GetMaxClip1() > 0 and sv_tfa_jamming:GetBool()
end

-- Use this to increase/decrease factor added based on ammunition/weather conditions/etc
function SWEP:GrabJamFactorMult()
	return 1 -- override
end

function SWEP:UpdateJamFactor()
	local self2 = self:GetTable()
	if not self:CanBeJammed() then return self end
	self:SetJamFactor(math.min(100, self:GetJamFactor() + self2.JamFactor * sv_tfa_jamming_factor_inc:GetFloat() * self:GrabJamFactorMult()))
	return self
end

function SWEP:IsJammed()
	if not self:CanBeJammed() then return false end
	return self:GetJammed()
end

function SWEP:NotifyJam()
	local ply = self:GetOwner()

	if IsValid(ply) and ply:IsPlayer() and IsFirstTimePredicted() and (not ply._TFA_LastJamMessage or ply._TFA_LastJamMessage < RealTime()) then
		ply:PrintMessage(HUD_PRINTCENTER, "#tfa.msg.weaponjammed")
		ply._TFA_LastJamMessage = RealTime() + 4
	end
end

function SWEP:CheckJammed()
	if not self:IsJammed() then return false end
	self:NotifyJam()
	return true
end

function SWEP:RollJamChance()
	if not self:CanBeJammed() then return false end
	if self:IsJammed() then return true end

	local chance = self:GetJamChance()
	local roll = util.SharedRandom('tfa_base_jam', math.max(0.002711997795105, math.pow(chance, 1.19)), 1, l_CT())

	if roll <= chance * sv_tfa_jamming_mult:GetFloat() then
		self:SetJammed(true)

		if IsFirstTimePredicted() then
			self:NotifyJam()
		end

		return true
	end

	return false
end

function SWEP:GrabJamChanceMult()
	return 1 -- override
end

function SWEP:GetJamChance()
	-- you can safely override this with your own logic if you desire
	local self2 = self:GetTable()
	if not self:CanBeJammed() then return 0 end
	return self:GetJamFactor() * sv_tfa_jamming_factor:GetFloat() * (self2.JamChance / 100) * self:GrabJamChanceMult()
end

SWEP.FlashlightSoundToggleOn = Sound("HL2Player.FlashLightOn")
SWEP.FlashlightSoundToggleOff = Sound("HL2Player.FlashLightOff")

function SWEP:ToggleFlashlight(toState)
	if toState == nil then
		toState = not self:GetFlashlightEnabled()
	end

	self:SetFlashlightEnabled(toState)
	self:EmitSoundNet(self:GetStatL("FlashlightSoundToggle" .. (toState and "On" or "Off")))
end

-- source engine save load
function SWEP:OnRestore()
	self:BuildAttachmentCache()

	self:InitializeAnims()
	self:InitializeMaterialTable()

	self:IconFix()
	self:RemoveEmptyRTCode()

	do -- attempt to restore attachments; weapons DO have owner so we don't need the precautions
		local OldFD = self:GetIsFirstDeploy()

		self:SetIsFirstDeploy(true) -- so extmag attachments don't unload the clip
		self.IsFirstDeploy = true
		for attName, sel in pairs(self.AttachmentCache or {}) do
			if sel then
				local att = TFA.Attachments.Atts[attName]

				if att and att.Attach then
					att:Attach(self)
				end
			end
		end
		self:SetIsFirstDeploy(OldFD)
		self.IsFirstDeploy = OldFD
	end
end

-- lua autorefresh / weapons.Register
function SWEP:OnReloaded()
	-- queue to next game frame since gmod is a fucking idiot
	timer.Simple(0, function()
		if not self:IsValid() then return end

		local baseclassSelf = table.Copy(baseclass.Get(self:GetClass()))
		if not baseclassSelf then return end

		local self2 = self:GetTable()

		self2.Primary_TFA.RangeFalloffLUTBuilt = nil
		self2.Primary.RangeFalloffLUTBuilt = nil

		--TFA.MigrateStructure(self, baseclassSelf, self:GetClass(), true)
		--TFA.MigrateStructure(self, self2, self:GetClass(), true)

		if istable(baseclassSelf.Primary) then
			self2.Primary_TFA = table.Copy(baseclassSelf.Primary)
			TFA.UnfoldBaseClass(baseclassSelf.Primary)
		end

		if istable(baseclassSelf.Secondary) then
			self2.Secondary_TFA = table.Copy(baseclassSelf.Secondary)
			TFA.UnfoldBaseClass(baseclassSelf.Secondary)
		end

		self2.StatCache_Blacklist = baseclassSelf.StatCache_Blacklist
		TFA.UnfoldBaseClass(self2.StatCache_Blacklist)

		if self2.StatCache_Blacklist_Real then
			table.Merge(self2.StatCache_Blacklist, self2.StatCache_Blacklist_Real)
		end

		self2.StatCache_Blacklist_Real = patch_blacklist(self2.StatCache_Blacklist, self2.TFADataVersion)

		self2.event_table_warning = false
		self2.event_table_built = false

		self2.AutoDetectMuzzle(self)
		self2.AutoDetectDamage(self)
		self2.AutoDetectDamageType(self)
		self2.AutoDetectForce(self)
		self2.AutoDetectPenetrationPower(self)
		self2.AutoDetectKnockback(self)
		self2.AutoDetectSpread(self)
		self2.AutoDetectRange(self)
		self2.IconFix(self)
		self2.RemoveEmptyRTCode(self)
		self2.ClearStatCache(self)
	end)
end

function SWEP:ProcessLoopSound()
	if sp and not SERVER then return end
	if self:GetNextLoopSoundCheck() < 0 or ct < self:GetNextLoopSoundCheck() or self:GetStatus() == TFA.Enum.STATUS_SHOOTING then return end

	self:SetNextLoopSoundCheck(-1)

	local tgtSound = self:GetStatL("Primary.LoopSound")

	if self:GetSilenced() then
		tgtSound = self:GetStatL("Primary.LoopSoundSilenced", tgtSound)
	end

	if tgtSound then
		self:StopSoundNet(tgtSound)
	end

	if (not sp and SERVER) or not self:IsFirstPerson() then
		tgtSound = self:GetSilenced() and self:GetStatL("Primary.LoopSoundSilenced_World", tgtSound) or self:GetStatL("Primary.LoopSound_World", tgtSound)

		if tgtSound then
			self:StopSoundNet(tgtSound)
		end
	end

	tgtSound = self:GetStatL("Primary.LoopSoundTail")

	if self:GetSilenced() then
		tgtSound = self:GetStatL("Primary.LoopSoundTailSilenced", tgtSound)
	end

	if (not sp and SERVER) or not self:IsFirstPerson() then
		tgtSound = self:GetSilenced() and self:GetStatL("Primary.LoopSoundTailSilenced_World", tgtSound) or self:GetStatL("Primary.LoopSoundTail_World", tgtSound)
	end

	if tgtSound and (SERVER or self.GunfireLoopIFTPHack) then
		self:EmitSoundNet(tgtSound, nil, true)
		self.GunfireLoopIFTPHack = false
	end
end

function SWEP:ProcessLoopFire()
	if sp and not IsFirstTimePredicted() then return end
	if (self:GetStatus() == TFA.Enum.STATUS_SHOOTING ) then
		if TFA.Enum.ShootLoopingStatus[self:GetShootStatus()] then
			self:SetShootStatus(TFA.Enum.SHOOT_LOOP)
		end
	else --not shooting
		if (not TFA.Enum.ShootReadyStatus[self:GetShootStatus()]) then
			if ( self:GetShootStatus() ~= TFA.Enum.SHOOT_CHECK ) then
				self:SetShootStatus(TFA.Enum.SHOOT_CHECK) --move to check first
			else --if we've checked for one more tick that we're not shooting
				self:SetShootStatus(TFA.Enum.SHOOT_IDLE) --move to check first

				if TFA.Enum.ReadyStatus[self:GetStatus()] then
					self:PlayAnimation(self:GetStatL("ShootAnimation.out")) --exit

					-- force flip walking and sprinting flags when needed
					if self:GetWalking() then
						self.walking_updated = true
					end
					if self:GetSprinting() then
						self.sprinting_updated = true
					end
				end
			end
		end
	end
end

--PATH lua/weapons/tfa_gun_base/common/autodetection.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/stat.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/attachments.lua:
local ATT_DIMENSION
local ATT_MAX_SCREEN_RATIO = 1 / 3
local tableCopy = table.Copy

SWEP.Attachments = {} --[MDL_ATTACHMENT] = = { offset = { 0, 0 }, atts = { "sample_attachment_1", "sample_attachment_2" }, sel = 1, order = 1 } --offset will move the offset the display from the weapon attachment when using CW2.0 style attachment display --atts is a table containing the visible attachments --sel allows you to have an attachment pre-selected, and is used internally by the base to show which attachment is selected in each category. --order is the order it will appear in the TFA style attachment menu
SWEP.AttachmentCache = {} --["att_name"] = true
SWEP.AttachmentTableCache = {}
SWEP.AttachmentCount = 0
SWEP.AttachmentDependencies = {} --{["si_acog"] = {"bg_rail"}}
SWEP.AttachmentExclusions = {} --{ ["si_iron"] = {"bg_heatshield"} }
SWEP.AttachmentTableOverride = {}

local att_enabled_cv = GetConVar("sv_tfa_attachments_enabled")

function SWEP:RemoveUnusedAttachments()
	for k, v in pairs(self.Attachments) do
		if v.atts then
			local t = {}
			local i = 1

			for _, b in pairs(v.atts) do
				if TFA.Attachments.Atts[b] then
					t[i] = b
					i = i + 1
				end
			end

			v.atts = tableCopy(t)
		end

		if #v.atts <= 0 then
			self.Attachments[k] = nil
		end
	end
end

local function select_function_table(target)
	-- idk
	local found_table

	for i_index, base_value in pairs(target) do
		if istable(base_value) then
			found_table = base_value
		end
	end

	if not found_table then
		found_table = {}
		table.insert(target, found_table)
	end

	return found_table
end

local function get(path, target)
	if #path == 1 then
		return target[path[1]]
	end

	local _target = target[path[1]]

	if _target == nil then
		target[path[1]] = {}
		_target = target[path[1]]
	end

	for i = 2, #path do
		if not istable(_target) then
			return
		end

		if _target[path[i]] == nil then _target[path[i]] = {} end

		if istable(_target[path[i]]) and _target[path[i]].functionTable and i ~= #path then
			_target = select_function_table(_target[path[i]])
		else
			_target = _target[path[i]]
		end
	end

	return _target
end

local function set(path, target, value)
	if #path == 1 then
		target[path[1]] = value
		return value
	end

	local _target = target[path[1]]

	if _target == nil then
		target[path[1]] = {}
		_target = target[path[1]]
	end

	for i = 2, #path - 1 do
		if not istable(_target) then
			return value
		end

		if _target[path[i]] == nil then _target[path[i]] = {} end

		if _target[path[i]].functionTable then
			_target = select_function_table(_target[path[i]])
		else
			_target = _target[path[i]]
		end
	end

	if istable(_target) then
		if istable(_target[path[#path]]) and _target[path[#path]].functionTable then
			table.insert(select_function_table(_target[path[#path]]), value)
		else
			_target[path[#path]] = value
		end
	end

	return value
end

local function CloneTableRecursive(source, target, root, source_version, target_version)
	for index, value in pairs(source) do
		local _root = root == "" and index or (root .. "." .. index)

		-- merge two tables
		if istable(value) then
			local baseTable = get(TFA.GetStatPath(_root, source_version, target_version), target)

			-- target is a function table
			if istable(baseTable) and baseTable.functionTable then
				local found_table

				for i_index, base_value in pairs(baseTable) do
					if istable(base_value) then
						found_table = base_value
					end
				end

				if not found_table then
					found_table = {}
					table.insert(baseTable, 1, found_table)
				end

				CloneTableRecursive(value, target, _root, source_version, target_version)
			-- target is a regular table
			else
				if not istable(baseTable) then
					set(TFA.GetStatPath(_root, source_version, target_version), target, {})
				end

				CloneTableRecursive(value, target, _root, source_version, target_version)
			end
		-- final value is determined by function
		elseif isfunction(value) then
			local temp
			local get_path = TFA.GetStatPath(_root, source_version, target_version)
			local get_table = get(get_path, target)

			if get_table ~= nil and not istable(get_table) then
				temp = get_table
			end

			local get_value = not istable(get_table) and set(get_path, target, {}) or get_table

			-- mark this table as function based
			get_value.functionTable = true

			if temp ~= nil then
				-- insert variable that was there before
				table.insert(get_value, temp)
			end

			-- insert function
			table.insert(get_value, value)
		-- final value is a scalar
		else
			local get_table = get(TFA.GetStatPath(_root, source_version, target_version), target)

			if istable(get_table) and get_table.functionTable then
				table.insert(get_table, 1, value)
			else
				set(TFA.GetStatPath(_root, source_version, target_version), target, value)
			end
		end
	end
end

function SWEP:BuildAttachmentCache()
	self.AttachmentCount = 0

	for k, v in pairs(self.Attachments) do
		if v.atts then
			for l, b in pairs(v.atts) do
				self.AttachmentCount = self.AttachmentCount + 1
				self.AttachmentCache[b] = (v.sel == l) and k or false
			end
		end
	end

	table.Empty(self.AttachmentTableCache)

	for attName, sel in pairs(self.AttachmentCache) do
		if not sel then goto CONTINUE end
		if not TFA.Attachments.Atts[attName] then goto CONTINUE end

		local srctbl = TFA.Attachments.Atts[attName].WeaponTable

		if istable(srctbl) then
			CloneTableRecursive(srctbl, self.AttachmentTableCache, "", TFA.Attachments.Atts[attName].TFADataVersion or 0, self.TFADataVersion or 0)
		end

		if istable(self.AttachmentTableOverride[attName]) then
			CloneTableRecursive(self.AttachmentTableOverride[attName], self.AttachmentTableCache, "", self.TFADataVersion or 0, self.TFADataVersion or 0)
		end

		::CONTINUE::
	end

	self:ClearStatCache()
	self:ClearMaterialCache()

	if CLIENT then
		self:ResetKeyBindHintAlpha(true)
	end
end

function SWEP:IsAttached(attn)
	return isnumber(self.AttachmentCache[attn])
end

local tc

function SWEP:CanAttach(attn, detaching)
	local retVal

	if detaching then
		retVal = hook.Run("TFA_PreCanDetach", self, attn)
	else
		retVal = hook.Run("TFA_PreCanAttach", self, attn)
	end

	if retVal ~= nil then return retVal end

	local self2 = self:GetTable()

	if not self2.HasBuiltMutualExclusions then
		tc = tableCopy(self2.AttachmentExclusions)

		for k, v in pairs(tc) do
			if k ~= "BaseClass" then
				for _, b in pairs(v) do
					self2.AttachmentExclusions[b] = self2.AttachmentExclusions[b] or {}

					if not table.HasValue(self2.AttachmentExclusions[b]) then
						self2.AttachmentExclusions[b][#self2.AttachmentExclusions[b] + 1] = k
					end
				end
			end
		end

		self2.HasBuiltMutualExclusions = true
	end

	if att_enabled_cv and not att_enabled_cv:GetBool() then return false end

	if self2.AttachmentExclusions[attn] then
		for _, v in pairs(self2.AttachmentExclusions[attn]) do
			if not detaching and self2.IsAttached(self, v) then
				return false
			end
		end
	end

	if not detaching and self2.AttachmentDependencies[attn] then
		local t = self2.AttachmentDependencies[attn]

		if isstring(t) then
			if t ~= "BaseClass" and not self2.IsAttached(self, t) then return false end
		elseif istable(t) then
			t.type = t.type or "OR"

			if t.type == "AND" then
				for k, v in pairs(self.AttachmentDependencies[attn]) do
					if k ~= "BaseClass" and k ~= "type" and not self2.IsAttached(self, v) then return false end
				end
			else
				local cnt = 0

				for k, v in pairs(self.AttachmentDependencies[attn]) do
					if k ~= "BaseClass" and k ~= "type" and self2.IsAttached(self, v) then
						cnt = cnt + 1
					end
				end

				if cnt == 0 then return false end
			end
		end
	end

	local atTable = TFA.Attachments.Atts[attn]

	if atTable then
		if detaching then
			if atTable.CanDetach and not atTable.CanDetach(self) then return false end
		else
			if not atTable:CanAttach(self) then return false end
		end
	end

	local retVal2

	if detaching then
		retVal2 = hook.Run("TFA_CanDetach", self, attn)
	else
		retVal2 = hook.Run("TFA_CanAttach", self, attn)
	end

	if retVal2 ~= nil then return retVal2 end
	return true
end

local ATTACHMENT_SORTING_DEPENDENCIES = false

function SWEP:ForceAttachmentReqs(attn)
	if not ATTACHMENT_SORTING_DEPENDENCIES then
		ATTACHMENT_SORTING_DEPENDENCIES = true
		local related = {}

		for k, v in pairs(self.AttachmentDependencies) do
			if istable(v) then
				for _, b in pairs(v) do
					if k == attn then
						related[b] = true
					elseif b == attn then
						related[k] = true
					end
				end
			elseif isstring(v) then
				if k == attn then
					related[v] = true
				elseif v == attn then
					related[k] = true
				end
			end
		end

		for k, v in pairs(self.AttachmentExclusions) do
			if istable(v) then
				for _, b in pairs(v) do
					if k == attn then
						related[b] = true
					elseif b == attn then
						related[k] = true
					end
				end
			elseif isstring(v) then
				if k == attn then
					related[v] = true
				elseif v == attn then
					related[k] = true
				end
			end
		end

		for k, v in pairs(self.AttachmentCache) do
			if v and related[k] and not self:CanAttach(k) then
				self:SetTFAAttachment(v, 0, true, true)
			end
		end

		ATTACHMENT_SORTING_DEPENDENCIES = false
	end
end

do
	local self3, att_neue, att_old

	local function attach()
		att_neue:Attach(self3)
	end

	local function detach()
		att_old:Detach(self3)
	end

	function SWEP:SetTFAAttachment(cat, id, nw, force)
		self3 = self
		local self2 = self:GetTable()

		if not self2.Attachments[cat] then return false end

		if isstring(id) then
			if id == "" then
				id = -1
			else
				id = table.KeyFromValue(self2.Attachments[cat].atts, id)
				if not id then return false end
			end
		end

		if id <= 0 and self2.Attachments[cat].default and type(self2.Attachments[cat].default) == "string" and self2.Attachments[cat].default ~= "" then
			return self2.SetTFAAttachment(self, cat, self2.Attachments[cat].default, nw, force)
		end

		local attn = self2.Attachments[cat].atts[id] or ""
		local attn_old = self2.Attachments[cat].atts[self2.Attachments[cat].sel or -1] or ""
		if SERVER and id > 0 and not (force or self2.CanAttach(self, attn)) then return false end
		if SERVER and id <= 0 and not (force or self2.CanAttach(self, attn_old, true)) then return false end

		if id ~= self2.Attachments[cat].sel then
			att_old = TFA.Attachments.Atts[self2.Attachments[cat].atts[self2.Attachments[cat].sel] or -1]
			local detach_status = att_old == nil

			if att_old then
				detach_status = ProtectedCall(detach)

				if detach_status then
					hook.Run("TFA_Attachment_Detached", self, attn_old, att_old, cat, id, force)
				end
			end

			att_neue = TFA.Attachments.Atts[self2.Attachments[cat].atts[id] or -1]
			local attach_status = att_neue == nil

			if detach_status then
				if att_neue then
					attach_status = ProtectedCall(attach)

					if attach_status then
						hook.Run("TFA_Attachment_Attached", self, attn, att_neue, cat, id, force)
					end
				end
			end

			if detach_status and attach_status then
				if id > 0 then
					self2.Attachments[cat].sel = id
				else
					self2.Attachments[cat].sel = nil
				end
			end
		end

		self2.BuildAttachmentCache(self)
		self2.ForceAttachmentReqs(self, (id > 0) and attn or attn_old)

		if nw and (not isentity(nw) or SERVER) then
			net.Start("TFA_Attachment_Set")
			if SERVER then net.WriteEntity(self) elseif CLIENT then net.WriteString(self:GetClass()) end
			net.WriteUInt(cat, 8)
			net.WriteString(attn)

			if SERVER then
				if isentity(nw) then
					local filter = RecipientFilter()
					filter:AddPVS(self:GetPos())
					filter:RemovePlayer(nw)
					net.Send(filter)
				else
					net.SendPVS(self:GetPos())
				end
			elseif CLIENT then
				net.SendToServer()
			end
		end

		return true
	end
end

function SWEP:Attach(attname, force)
	if not attname or not IsValid(self) then return false end
	if self.AttachmentCache[attname] == nil then return false end

	for cat, tbl in pairs(self.Attachments) do
		local atts = tbl.atts

		for id, att in ipairs(atts) do
			if att == attname then return self:SetTFAAttachment(cat, id, true, force) end
		end
	end

	return false
end

function SWEP:Detach(attname, force)
	if not attname or not IsValid(self) then return false end
	local cat = self.AttachmentCache[attname]
	if not cat then return false end

	return self:SetTFAAttachment(cat, 0, true, force)
end

function SWEP:RandomizeAttachments(force)
	for key, slot in pairs(self.AttachmentCache) do
		if slot then
			self:Detach(key)
		end
	end

	for category, def in pairs(self.Attachments) do
		if istable(def) and istable(def.atts) and #def.atts > 0 then
			if math.random() > 0.3 then
				local randkey = math.random(1, #def.atts)
				self:SetTFAAttachment(category, randkey, true, force)
			end
		end
	end
end

local attachments_sorted_alphabetically = GetConVar("sv_tfa_attachments_alphabetical")

function SWEP:InitAttachments()
	if self.HasInitAttachments then return end
	hook.Run("TFA_PreInitAttachments", self)
	self.HasInitAttachments = true

	for k, v in pairs(self.Attachments) do
		if type(k) == "string" then
			local tatt = self:VMIV() and self.OwnerViewModel:LookupAttachment(k) or self:LookupAttachment(k)

			if tatt > 0 then
				self.Attachments[tatt] = v
			end

			self.Attachments[k] = nil
		elseif (not attachments_sorted_alphabetically) and attachments_sorted_alphabetically:GetBool() then
			local sval = v.atts[v.sel]

			table.sort(v.atts, function(a, b)
				local aname = ""
				local bname = ""
				local att_a = TFA.Attachments.Atts[a]

				if att_a then
					aname = att_a.Name or a
				end

				local att_b = TFA.Attachments.Atts[b]

				if att_b then
					bname = att_b.Name or b
				end

				return aname < bname
			end)

			if sval then
				v.sel = table.KeyFromValue(v.atts, sval) or v.sel
			end
		end
	end

	for k, v in pairs(self.Attachments) do
		if v.sel then
			local vsel = v.sel
			v.sel = nil

			if type(vsel) == "string" then
				vsel = table.KeyFromValue(v.atts, vsel) or tonumber(vsel)

				if not vsel then goto CONTINUE end
			end

			timer.Simple(0, function()
				if IsValid(self) and self.SetTFAAttachment then
					self:SetTFAAttachment(k, vsel, false)
				end
			end)
		end

		::CONTINUE::
	end

	hook.Run("TFA_PostInitAttachments", self)
	self:RemoveUnusedAttachments()
	self:BuildAttachmentCache()
	hook.Run("TFA_FinalInitAttachments", self)

	self:RestoreAttachments()
end

local cv_persist_enable = GetConVar("cl_tfa_attachments_persist_enabled")

function SWEP:SaveAttachments()
	if not CLIENT or not cv_persist_enable:GetBool() then return end

	TFA.SetSavedAttachments(self)
end

function SWEP:RestoreAttachments()
	if not CLIENT or not cv_persist_enable:GetBool() then return end

	for cat, id in pairs(TFA.GetSavedAttachments(self) or {}) do
		self:SetTFAAttachment(cat, id, true, true)
	end
end

function SWEP:GenerateVGUIAttachmentTable()
	self.VGUIAttachments = {}
	local keyz = table.GetKeys(self.Attachments)
	table.RemoveByValue(keyz, "BaseClass")

	table.sort(keyz, function(a, b)
		--A and B are keys
		local v1 = self.Attachments[a]
		local v2 = self.Attachments[b]

		if v1 and v2 and (v1.order or v2.order) then
			return (v1.order or a) < (v2.order or b)
		else
			return a < b
		end
	end)

	for _, k in ipairs(keyz) do
		local v = self.Attachments[k]

		if not v.hidden then
			local aTbl = tableCopy(v)

			aTbl.cat = k
			aTbl.offset = nil
			aTbl.order = nil

			table.insert(self.VGUIAttachments, aTbl)
		end
	end

	ATT_DIMENSION = math.Round(TFA.ScaleH(TFA.Attachments.IconSize))
	local max_row_atts = math.floor(ScrW() * ATT_MAX_SCREEN_RATIO / ATT_DIMENSION)
	local i = 1

	while true do
		local v = self.VGUIAttachments[i]
		if not v then break end
		i = i + 1

		for l, b in pairs(v.atts) do
			if not istable(b) then
				v.atts[l] = {b, l} --name, ID
			end
		end

		if (#v.atts > max_row_atts) then
			while (#v.atts > max_row_atts) do
				local t = tableCopy(v)

				for _ = 1, max_row_atts do
					table.remove(t.atts, 1)
				end

				for _ = 1, #v.atts - max_row_atts do
					table.remove(v.atts)
				end

				table.insert(self.VGUIAttachments, i, t)
			end
		end
	end
end

local bgt = {}
SWEP.ViewModelBodygroups = {}
SWEP.WorldModelBodygroups = {}

function SWEP:IterateBodygroups(entity, tablename, version)
	local self2 = self:GetTable()

	bgt = self2.GetStatVersioned(self, tablename, version or 0, self2[tablename])

	for k, v in pairs(bgt) do
		if isnumber(k) then
			local bgn = entity:GetBodygroupName(k)

			if bgt[bgn] then
				v = bgt[bgn]
			end

			if entity:GetBodygroup(k) ~= v then
				entity:SetBodygroup(k, v)
			end
		end
	end
end

function SWEP:ProcessBodygroups()
	local self2 = self:GetTable()
	local ViewModelBodygroups = self:GetStatRawL("ViewModelBodygroups")
	local WorldModelBodygroups = self:GetStatRawL("WorldModelBodygroups")

	if not self2.HasFilledBodygroupTables then
		if self2.VMIV(self) then
			for i = 0, #(self2.OwnerViewModel:GetBodyGroups() or ViewModelBodygroups) do
				ViewModelBodygroups[i] = ViewModelBodygroups[i] or 0
			end
		end

		for i = 0, #(self:GetBodyGroups() or WorldModelBodygroups) do
			WorldModelBodygroups[i] = WorldModelBodygroups[i] or 0
		end

		self2.HasFilledBodygroupTables = true
	end

	if self2.VMIV(self) then
		self2.IterateBodygroups(self, self2.OwnerViewModel, "ViewModelBodygroups", TFA.LatestDataVersion)
	end

	self2.IterateBodygroups(self, self, "WorldModelBodygroups", TFA.LatestDataVersion)
end

function SWEP:CallAttFunc(funcName, ...)
	for attName, sel in pairs(self.AttachmentCache or {}) do
		if not sel then goto CONTINUE end

		local att = TFA.Attachments.Atts[attName]
		if not att then goto CONTINUE end

		local attFunc = att[funcName]
		if attFunc and type(attFunc) == "function" then
			local _ret1, _ret2, _ret3, _ret4, _ret5, _ret6, _ret7, _ret8, _ret9, _ret10 = attFunc(att, self, ...)

			if _ret1 ~= nil then
				return _ret1, _ret2, _ret3, _ret4, _ret5, _ret6, _ret7, _ret8, _ret9, _ret10
			end
		end

		::CONTINUE::
	end

	return nil
end

--PATH lua/weapons/tfa_gun_base/common/effects.lua:
local fx, sp = nil, game.SinglePlayer()
local shelltype

function SWEP:PCFTracer(bul, hitpos, ovrride)
	if bul.PCFTracer then
		self:UpdateMuzzleAttachment()
		local mzp = self:GetMuzzlePos()
		if bul.PenetrationCount > 0 and not ovrride then return end --Taken care of with the pen effect

		if (CLIENT or game.SinglePlayer()) and self.Scoped and self:IsCurrentlyScoped() and self:IsFirstPerson() then
			TFA.ParticleTracer(bul.PCFTracer, self:GetOwner():GetShootPos() - self:GetOwner():EyeAngles():Up() * 5, hitpos, false, 0, -1)
		else
			local vent = self

			if (CLIENT or game.SinglePlayer()) and self:IsFirstPerson() then
				vent = self.OwnerViewModel
			end

			if sp and not self:IsFirstPerson() then
				TFA.ParticleTracer(bul.PCFTracer, self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * 32, hitpos, false)
			else
				TFA.ParticleTracer(bul.PCFTracer, mzp.Pos, hitpos, false, vent, self.MuzzleAttachmentRaw or 1)
			end
		end
	end
end

function SWEP:EventShell()
	if SERVER and self.processing_events and sp then return end

	if SERVER then
		net.Start("tfaBaseShellSV", true)
		net.WriteEntity(self)

		if self:GetOwner():IsPlayer() then
			if sp then
				net.Broadcast()
			else
				net.SendOmit(self:GetOwner())
			end
		else
			net.SendPVS(self:GetPos())
		end

		return
	end

	self:MakeShellBridge()
end

function SWEP:MakeShellBridge(ifp)
	if ifp == false then return end

	if self.LuaShellEjectDelay > 0 then
		self.LuaShellRequestTime = CurTime() + self.LuaShellEjectDelay / self:GetAnimationRate(ACT_VM_PRIMARYATTACK)
	else
		self:MakeShell()
	end
end

SWEP.ShellEffectOverride = nil -- ???
SWEP.ShellEjectionQueue = 0

function SWEP:GetShellAttachmentID(ent, isVM)
	local raw = self:GetStatL("ShellAttachmentRaw")
	local israw = false
	local attid

	if raw and ent:GetAttachment(raw) then
		attid = raw
		israw = true
	else
		attid = ent:LookupAttachment(self:GetStatL("ShellAttachment"))
	end

	if self:GetStatL("IsAkimbo") and not israw then
		return 3 + self:GetAnimCycle()
	end

	if attid and attid <= 0 then attid = 2 end

	attid = math.Clamp(attid and attid or 2, 1, 127)

	return attid
end

function SWEP:GetShellEjectPosition(ent, isVM)
	local attid = self:GetShellAttachmentID(ent, isVM)

	local angpos = ent:GetAttachment(attid)

	if angpos then
		return angpos.Pos, angpos.Ang, attid
	end
end

function SWEP:MakeShell(eject_now)
	if not self:IsValid() then return end -- what
	if self.current_event_iftp == false then return end

	local retVal = hook.Run("TFA_MakeShell", self)

	if retVal ~= nil then
		return retVal
	end

	if self:GetStatL("ShellEffectOverride") then
		shelltype = self:GetStatL("ShellEffectOverride")
	elseif TFA.GetLegacyShellsEnabled() then
		shelltype = "tfa_shell_legacy"
	else
		shelltype = "tfa_shell"
	end

	local ent = self
	local isVM = false

	if self:IsFirstPerson() then
		if not eject_now and CLIENT then
			self.ShellEjectionQueue = self.ShellEjectionQueue + 1
			return
		end

		ent = self.OwnerViewModel or self
		isVM = ent == self.OwnerViewModel
	end

	self:EjectionSmoke(true)

	if not isstring(shelltype) or shelltype == "" then return end -- allows to disable shells by setting override to "" - will shut up all rp fags

	if not IsValid(ent) then return end
	local pos, ang, attid = self:GetShellEjectPosition(ent, isVM)

	if not pos then return end

	fx = EffectData()
	fx:SetEntity(self)
	fx:SetAttachment(attid)
	fx:SetMagnitude(1)
	fx:SetScale(1)
	fx:SetOrigin(pos)
	fx:SetNormal(ang:Forward())
	TFA.Effects.Create(shelltype, fx)
end

--[[
Function Name:  CleanParticles
Syntax: self:CleanParticles().
Returns:  Nothing.
Notes:  Cleans up particles.
Purpose:  FX
]]
--
function SWEP:CleanParticles()
	if not IsValid(self) then return end

	if self.StopParticles then
		self:StopParticles()
	end

	if self.StopParticleEmission then
		self:StopParticleEmission()
	end

	if not self:VMIV() then return end
	local vm = self.OwnerViewModel

	if IsValid(vm) then
		if vm.StopParticles then
			vm:StopParticles()
		end

		if vm.StopParticleEmission then
			vm:StopParticleEmission()
		end
	end
end

--[[
Function Name:  EjectionSmoke
Syntax: self:EjectionSmoke().
Returns:  Nothing.
Notes:  Puff of smoke on shell attachment.
Purpose:  FX
]]
--
function SWEP:EjectionSmoke(ovrr)
	local retVal = hook.Run("TFA_EjectionSmoke",self)
	if retVal ~= nil then
		return retVal
	end
	if TFA.GetEJSmokeEnabled() and (self:GetStatL("EjectionSmokeEnabled") or ovrr) then
		local vm = self:IsFirstPerson() and self.OwnerViewModel or self

		if IsValid(vm) then
			local att = vm:LookupAttachment(self:GetStatL("ShellAttachment"))

			if not att or att <= 0 then
				att = 2
			end

			local oldatt = att
			att = self:GetStatL("ShellAttachmentRaw", att)
			local angpos = vm:GetAttachment(att)

			if not angpos then
				att = oldatt
				angpos = vm:GetAttachment(att)
			end

			if angpos then
				fx = EffectData()
				fx:SetEntity(self)
				fx:SetOrigin(angpos.Pos)
				fx:SetAttachment(att)
				fx:SetNormal(angpos.Ang:Forward())
				TFA.Effects.Create("tfa_shelleject_smoke", fx)
			end
		end
	end
end

--[[
Function Name:  ShootEffectsCustom
Syntax: self:ShootEffectsCustom().
Returns:  Nothing.
Notes:  Calls the proper muzzleflash, muzzle smoke, muzzle light code.
Purpose:  FX
]]
--
function SWEP:MuzzleSmoke(spv)
	local retVal = hook.Run("TFA_MuzzleSmoke",self)
	if retVal ~= nil then
		return retVal
	end
	if self.SmokeParticle == nil then
		self.SmokeParticle = self.SmokeParticles[self.DefaultHoldType or self.HoldType]
	end

	if self:GetStatL("SmokeParticle") and self:GetStatL("SmokeParticle") ~= "" then
		self:UpdateMuzzleAttachment()
		local att = self:GetMuzzleAttachment()
		fx = EffectData()
		fx:SetOrigin(self:GetOwner():GetShootPos())
		fx:SetNormal(self:GetOwner():EyeAngles():Forward())
		fx:SetEntity(self)
		fx:SetAttachment(att)
		TFA.Effects.Create("tfa_muzzlesmoke", fx)
	end
end

function SWEP:MuzzleFlashCustom(spv)
	local retVal = hook.Run("TFA_MuzzleFlash",self)
	if retVal ~= nil then
		return retVal
	end
	local att = self:GetMuzzleAttachment()
	fx = EffectData()
	fx:SetOrigin(self:GetOwner():GetShootPos())
	fx:SetNormal(self:GetOwner():EyeAngles():Forward())
	fx:SetEntity(self)
	fx:SetAttachment(att)
	local mzsil = self:GetStatL("MuzzleFlashEffectSilenced")

	if (self:GetSilenced() and mzsil and mzsil ~= "") then
		TFA.Effects.Create(mzsil, fx)
	else
		TFA.Effects.Create(self:GetStatL("MuzzleFlashEffect", self.MuzzleFlashEffect or ""), fx)
	end
end

function SWEP:ShootEffectsCustom(ifp)
	if self.DoMuzzleFlash ~= nil then
		self.MuzzleFlashEnabled = self.DoMuzzleFlash
		self.DoMuzzleFlash = nil
	end

	if not self.MuzzleFlashEnabled then return end
	if self:IsFirstPerson() and not self:VMIV() then return end
	if not self:GetOwner().GetShootPos then return end
	ifp = ifp or IsFirstTimePredicted()

	if (SERVER and sp and self.ParticleMuzzleFlash) or (SERVER and not sp) then
		net.Start("tfa_base_muzzle_mp", true)
		net.WriteEntity(self)

		if sp or not self:GetOwner():IsPlayer() then
			net.SendPVS(self:GetPos())
		else
			net.SendOmit(self:GetOwner())
		end

		return
	end

	if (CLIENT and ifp and not sp) or (sp and SERVER) then
		self:UpdateMuzzleAttachment()
		self:MuzzleFlashCustom(sp)
		self:MuzzleSmoke(sp)
	end
end

--[[
Function Name:  CanDustEffect
Syntax: self:CanDustEffect( concise material name ).
Returns:  True/False
Notes:  Used for the impact effect.  Should be used with GetMaterialConcise.
Purpose:  Utility
]]
--
local DustEffects = {
	[MAT_DIRT] = true,
	[MAT_CONCRETE] = true,
	[MAT_PLASTIC] = true,
	[MAT_WOOD] = true
}
function SWEP:CanDustEffect(matv)
	if DustEffects[matv] then return true end

	return false
end

--[[
Function Name:  CanSparkEffect
Syntax: self:CanSparkEffect( concise material name ).
Returns:  True/False
Notes:  Used for the impact effect.  Should be used with GetMaterialConcise.
Purpose:  Utility
]]
--
local SparkEffects = {
	[MAT_METAL] = true,
	[MAT_GRATE] = true,
	[MAT_VENT] = true
}
function SWEP:CanSparkEffect(matv)
	if SparkEffects[matv] then return true end

	return false
end

-- Returns muzzle attachment position for HL2 tracers
function SWEP:GetTracerOrigin(...)
	local att = self:GetMuzzleAttachment()

	local attpos = (self:IsFirstPerson() and self.OwnerViewModel or self):GetAttachment(att)

	if attpos and attpos.Pos then
		return attpos.Pos
	end
end

--PATH lua/weapons/tfa_gun_base/common/calc.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/akimbo.lua:
SWEP.AnimCycle = SWEP.ViewModelFlip and 0 or 1

function SWEP:FixAkimbo()
	if not self:GetStatL("IsAkimbo") or self.Secondary_TFA.ClipSize <= 0 then return end

	self.Primary_TFA.ClipSize = self.Primary_TFA.ClipSize + self.Secondary_TFA.ClipSize
	self.Secondary_TFA.ClipSize = -1
	self.Primary_TFA.RPM = self.Primary_TFA.RPM * 2
	self.Akimbo_Inverted = self.ViewModelFlip
	self:ResetAnimCycle()
	self:ClearStatCache()

	timer.Simple(FrameTime(), function()
		timer.Simple(0.01, function()
			if IsValid(self) and self:OwnerIsValid() then
				self:SetClip1(self.Primary_TFA.ClipSize)
			end
		end)
	end)
end

function SWEP:ResetAnimCycle()
	self:SetAnimCycle(self.Akimbo_Inverted and 0 or 1)
	self.AnimCycle = self:GetAnimCycle()
end

function SWEP:ToggleAkimbo(arg1)
	if self:GetStatL("IsAkimbo") then
		self:SetAnimCycle(1 - self:GetAnimCycle())
		self.AnimCycle = self:GetAnimCycle()
	end
end

--PATH lua/weapons/tfa_gun_base/common/skins.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/client/bobcode.lua:
local vector_origin = Vector()

SWEP.ti = 0
SWEP.LastCalcBob = 0
SWEP.tiView = 0
SWEP.LastCalcViewBob = 0
local TAU = math.pi * 2
local rateScaleFac = 2
local rate_up = 6 * rateScaleFac
local scale_up = 0.5
local rate_right = 3 * rateScaleFac
local scale_right = -0.5
local rate_forward_view = 3 * rateScaleFac
local scale_forward_view = 0.35
local rate_right_view = 3 * rateScaleFac
local scale_right_view = -1
local rate_p = 6 * rateScaleFac
local scale_p = 3
local rate_y = 3 * rateScaleFac
local scale_y = 6
local rate_r = 3 * rateScaleFac
local scale_r = -6
local pist_rate = 3 * rateScaleFac
local pist_scale = 9
local rate_clamp = 2 * rateScaleFac
local walkIntensitySmooth, breathIntensitySmooth = 0, 0
local walkRate = 160 / 60 * TAU / 1.085 / 2 * rateScaleFac --steps are at 160bpm at default velocity, then divide that by 60 for per-second, multiply by TAU for trig, divided by default walk rate
local walkVec = Vector()
local ownerVelocity, ownerVelocityMod = Vector(), Vector()
local zVelocity, zVelocitySmooth = 0, 0
local xVelocity, xVelocitySmooth, rightVec = 0, 0, Vector()
local flatVec = Vector(1, 1, 0)
local WalkPos = Vector()
local WalkPosLagged = Vector()
local gunbob_intensity_cvar = GetConVar("cl_tfa_gunbob_intensity")
local gunbob_intensity = 0
SWEP.VMOffsetWalk = Vector(0.5, -0.5, -0.5)
SWEP.footstepTotal = 0
SWEP.footstepTotalTarget = 0
local upVec, riVec, fwVec = Vector(0, 0, 1), Vector(1, 0, 0), Vector(0, 1, 0)

local function l_Lerp(t, a, b)
	if t <= 0 then return a end
	if t >= 1 then return b end
	return a + (b - a) * t
end

function SWEP:WalkBob(pos, ang, breathIntensity, walkIntensity, rate, ftv)
	local self2 = self:GetTable()
	if not self2.OwnerIsValid(self) then return end
	rate = math.min(rate or 0.5, rate_clamp)
	gunbob_intensity = gunbob_intensity_cvar:GetFloat()

	local ea = self:GetOwner():EyeAngles()
	local up = ang:Up()
	local ri = ang:Right()
	local fw = ang:Forward()
	local upLocal = upVec
	local riLocal = riVec
	local fwLocal = fwVec
	local delta = ftv
	local flip_v = self2.ViewModelFlip and -1 or 1
	--delta = delta * game.GetTimeScale()
	--self2.LastCalcBob = SysTime()
	self2.bobRateCached = rate
	self2.ti = self2.ti + delta * rate

	if self2.SprintStyle == nil then
		if self:GetStatL("SprintViewModelAngle") and self:GetStatL("SprintViewModelAngle").x > 5 then
			self2.SprintStyle = 1
		else
			self2.SprintStyle = 0
		end
	end

	--preceding calcs
	walkIntensitySmooth = l_Lerp(delta * 10 * rateScaleFac, walkIntensitySmooth, walkIntensity)
	breathIntensitySmooth = l_Lerp(delta * 10 * rateScaleFac, breathIntensitySmooth, breathIntensity)
	walkVec = LerpVector(walkIntensitySmooth, vector_origin, self2.VMOffsetWalk)
	ownerVelocity = self:GetOwner():GetVelocity()
	zVelocity = ownerVelocity.z
	zVelocitySmooth = l_Lerp(delta * 7 * rateScaleFac, zVelocitySmooth, zVelocity)
	ownerVelocityMod = ownerVelocity * flatVec
	ownerVelocityMod:Normalize()
	rightVec = ea:Right() * flatVec
	rightVec:Normalize()
	xVelocity = ownerVelocity:Length2D() * ownerVelocityMod:Dot(rightVec)
	xVelocitySmooth = l_Lerp(delta * 5 * rateScaleFac, xVelocitySmooth, xVelocity)

	--multipliers
	breathIntensity = breathIntensitySmooth * gunbob_intensity * 1.5
	walkIntensity = walkIntensitySmooth * gunbob_intensity * 1.5

	--breathing / walking while ADS
	local breatheMult2 = math.Clamp((self2.IronSightsProgressUnpredicted2 or self:GetIronSightsProgress()), 0, 1)
	--local breatheMult2 = 0
	local breatheMult1 = 1 - breatheMult2
	--local breatheMult1 = 1

	pos:Add(riLocal * (math.sin(self2.ti * walkRate) - math.cos(self2.ti * walkRate)) * flip_v * breathIntensity * 0.2 * breatheMult1)
	pos:Add(upLocal * math.sin(self2.ti * walkRate) * breathIntensity * 0.5 * breatheMult1)

	pos:Add(riLocal * math.cos(self2.ti * walkRate / 2) * flip_v * breathIntensity * 0.6 * breatheMult2)
	pos:Add(upLocal * math.sin(self2.ti * walkRate) * breathIntensity * 0.3 * breatheMult2)

	--walk anims, danny method because i just can't
	self2.walkTI = (self2.walkTI or 0) + delta * 160 / 60 * self:GetOwner():GetVelocity():Length2D() / self:GetOwner():GetWalkSpeed()
	WalkPos.x = l_Lerp(delta * 5 * rateScaleFac, WalkPos.x, -math.sin(self2.ti * walkRate * 0.5) * gunbob_intensity * walkIntensity)
	WalkPos.y = l_Lerp(delta * 5 * rateScaleFac, WalkPos.y, math.sin(self2.ti * walkRate) / 1.5 * gunbob_intensity * walkIntensity)
	WalkPosLagged.x = l_Lerp(delta * 5 * rateScaleFac, WalkPosLagged.x, -math.sin((self2.ti * walkRate * 0.5) + math.pi / 3) * gunbob_intensity * walkIntensity)
	WalkPosLagged.y = l_Lerp(delta * 5 * rateScaleFac, WalkPosLagged.y, math.sin(self2.ti * walkRate + math.pi / 3) / 1.5 * gunbob_intensity * walkIntensity)
	pos:Add(WalkPos.x * 0.33 * riLocal)
	pos:Add(WalkPos.y * 0.25 * upLocal)
	ang:RotateAroundAxis(ri, -WalkPosLagged.y)
	ang:RotateAroundAxis(up, WalkPosLagged.x)
	ang:RotateAroundAxis(fw, WalkPos.x)

	--constant offset
	pos:Add(riLocal * walkVec.x * flip_v)
	pos:Add(fwLocal * walkVec.y)
	pos:Add(upLocal * walkVec.z)

	--jumping
	local trigX = -math.Clamp(zVelocitySmooth / 200, -1, 1) * math.pi / 2
	local jumpIntensity = (3 + math.Clamp(math.abs(zVelocitySmooth) - 100, 0, 200) / 200 * 4) * (1 - (self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress()) * 0.8)
	pos:Add(ri * math.sin(trigX) * scale_r * 0.1 * jumpIntensity * flip_v * 0.4)
	pos:Add(-up * math.sin(trigX) * scale_r * 0.1 * jumpIntensity * 0.4)
	ang:RotateAroundAxis(ang:Forward(), math.sin(trigX) * scale_r * jumpIntensity * flip_v * 0.4)

	--rolling with horizontal motion
	local xVelocityClamped = xVelocitySmooth

	if math.abs(xVelocityClamped) > 200 then
		local sign = (xVelocityClamped < 0) and -1 or 1
		xVelocityClamped = (math.sqrt((math.abs(xVelocityClamped) - 200) / 50) * 50 + 200) * sign
	end

	ang:RotateAroundAxis(ang:Forward(), xVelocityClamped * 0.04 * flip_v)

	return pos, ang
end

function SWEP:SprintBob(pos, ang, intensity, origPos, origAng)
	local self2 = self:GetTable()
	if not IsValid(self:GetOwner()) or not gunbob_intensity then return pos, ang end
	local flip_v = self2.ViewModelFlip and -1 or 1

	local eyeAngles = self:GetOwner():EyeAngles()
	local localUp = ang:Up()
	local localRight = ang:Right()
	local localForward = ang:Forward()

	local playerUp = eyeAngles:Up()
	local playerRight = eyeAngles:Right()
	local playerForward = eyeAngles:Forward()

	intensity = intensity * gunbob_intensity * 1.5
	gunbob_intensity = gunbob_intensity_cvar:GetFloat()

	if intensity > 0.005 then
		if self2.SprintStyle == 1 then
			local intensity3 = math.max(intensity - 0.3, 0) / (1 - 0.3)
			ang:RotateAroundAxis(ang:Up(), math.sin(self2.ti * pist_rate) * pist_scale * intensity3 * 0.33 * 0.75)
			ang:RotateAroundAxis(ang:Forward(), math.sin(self2.ti * pist_rate) * pist_scale * intensity3 * 0.33 * -0.25)
			pos:Add(ang:Forward() * math.sin(self2.ti * pist_rate * 2 + math.pi) * pist_scale * -0.1 * intensity3 * 0.4)
			pos:Add(ang:Right() * math.sin(self2.ti * pist_rate) * pist_scale * 0.15 * intensity3 * 0.33 * 0.2)
		else
			pos:Add(localUp * math.sin(self2.ti * rate_up + math.pi) * scale_up * intensity * 0.33)
			pos:Add(localRight * math.sin(self2.ti * rate_right) * scale_right * intensity * flip_v * 0.33)
			pos:Add(eyeAngles:Forward() * math.max(math.sin(self2.ti * rate_forward_view), 0) * scale_forward_view * intensity * 0.33)
			pos:Add(eyeAngles:Right() * math.sin(self2.ti * rate_right_view) * scale_right_view * intensity * flip_v * 0.33)

			ang:RotateAroundAxis(localRight, math.sin(self2.ti * rate_p + math.pi) * scale_p * intensity * 0.33)
			pos:Add(-localUp * math.sin(self2.ti * rate_p + math.pi) * scale_p * 0.1 * intensity * 0.33)

			ang:RotateAroundAxis(localUp, math.sin(self2.ti * rate_y) * scale_y * intensity * flip_v * 0.33)
			pos:Add(localRight * math.sin(self2.ti * rate_y) * scale_y * 0.1 * intensity * flip_v * 0.33)

			ang:RotateAroundAxis(localForward, math.sin(self2.ti * rate_r) * scale_r * intensity * flip_v * 0.33)
			pos:Add(localRight * math.sin(self2.ti * rate_r) * scale_r * 0.05 * intensity * flip_v * 0.33)
			pos:Add(localUp * math.sin(self2.ti * rate_r) * scale_r * 0.1 * intensity * 0.33)
		end
	end

	return pos, ang
end

local cv_customgunbob = GetConVar("cl_tfa_gunbob_custom")
local fac, bscale

function SWEP:UpdateEngineBob()
	local self2 = self:GetTable()

	if cv_customgunbob:GetBool() then
		self2.BobScale = 0
		self2.SwayScale = 0

		return
	end

	local isp = self2.IronSightsProgressUnpredicted or self:GetIronSightsProgress()
	local wpr = self2.WalkProgressUnpredicted or self:GetWalkProgress()
	local spr = self:GetSprintProgress()

	fac = gunbob_intensity_cvar:GetFloat() * ((1 - isp) * 0.85 + 0.15)
	bscale = fac

	if spr > 0.005 then
		bscale = bscale * l_Lerp(spr, 1, self2.SprintBobMult)
	elseif wpr > 0.005 then
		bscale = bscale * l_Lerp(wpr, 1, l_Lerp(isp, self2.WalkBobMult, self2.WalkBobMult_Iron or self2.WalkBobMult))
	end

	self2.BobScale = bscale
	self2.SwayScale = fac
end

--PATH lua/weapons/tfa_gun_base/client/mods.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/client/mods.lua:
--[[Thanks to Clavus.  Like seriously, SCK was brilliant. Even though you didn't include a license anywhere I could find, it's only fit to credit you.]]
--

local vector_origin = Vector()

--[[
Function Name:  InitMods
Syntax: self:InitMods().  Should be called only once for best performance.
Returns:  Nothing.
Notes:  Creates the VElements and WElements table, and sets up mods.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:InitMods()
	--Create a new table for every weapon instance.
	self.SWEPConstructionKit = true

	self.ViewModelElements = self:CPTbl(self.ViewModelElements)
	self.WorldModelElements = self:CPTbl(self.WorldModelElements)
	self.ViewModelBoneMods = self:CPTbl(self.ViewModelBoneMods)

	-- i have no idea how this gonna behave without that with SWEP Construction kit
	-- so we gonna leave this thing alone and precache everything
	self:CreateModels(self.ViewModelElements, true) -- create viewmodels
	self:CreateModels(self.WorldModelElements) -- create worldmodels

	--Build the bones and such.
	if self:OwnerIsValid() then
		local vm = self.OwnerViewModel

		if IsValid(vm) then
			--self:ResetBonePositions(vm)
			if (self.ShowViewModel == nil or self.ShowViewModel) then
				vm:SetColor(Color(255, 255, 255, 255))
				--This hides the viewmodel, FYI, lol.
			else
				vm:SetMaterial("Debug/hsv")
			end
		end
	end
end

--[[
Function Name:  UpdateProjectedTextures
Syntax: self:UpdateProjectedTextures().  Automatically called already.
Returns:  Nothing.
Notes:  This takes care of our flashlight and laser.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--

function SWEP:UpdateProjectedTextures(view)
	self:DrawLaser(view)
	self:DrawFlashlight(view)
end

--[[
Function Name:  ViewModelDrawn
Syntax: self:ViewModelDrawn().  Automatically called already.
Returns:  Nothing.
Notes:  This draws the mods.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:PreDrawViewModel(vm, wep, ply)
	self:ProcessBodygroups()

	--vm:SetupBones()

	if self:GetHidden() then
		render.SetBlend(0)
	end
end

SWEP.CameraAttachmentOffsets = {{"p", 0}, {"y", 0}, {"r", 0}}
SWEP.CameraAttachment = nil
SWEP.CameraAttachments = {"camera", "attach_camera", "view", "cam", "look"}
SWEP.CameraAngCache = nil
local tmpvec = Vector(0, 0, -2000)

do
	local reference_table

	local function rendersorter(a, b)
		local ar, br = reference_table[a], reference_table[b]

		if ar == br then
			return a > b
		end

		return ar > br
	end

	local function inc_references(lookup, name, entry, output, level)
		output[name] = (output[name] or 0) + level
		local elemother = lookup[entry.rel]

		if elemother then
			inc_references(lookup, entry.rel, elemother, output, level + 1)
		end
	end

	function SWEP:RebuildModsRenderOrder()
		self.vRenderOrder = {}
		self.wRenderOrder = {}
		self.VElementsBodygroupsCache = {}
		self.WElementsBodygroupsCache = {}

		local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion) or {}
		local WorldModelElements = self:GetStatRaw("WorldModelElements", TFA.LatestDataVersion) or {}

		if istable(ViewModelElements) then
			local target = self.vRenderOrder
			reference_table = {}

			for k, v in pairs(ViewModelElements) do
				if v.type == "Model" then
					table.insert(target, k)
					inc_references(ViewModelElements, k, v, reference_table, 10000)
				elseif v.type == "Sprite" or v.type == "Quad" or v.type == "Bodygroup" then
					table.insert(target, k)
					inc_references(ViewModelElements, k, v, reference_table, 1)
				end
			end

			table.sort(target, rendersorter)
		end

		if istable(WorldModelElements) then
			local target2 = self.wRenderOrder
			reference_table = {}

			for k, v in pairs(WorldModelElements) do
				if v.type == "Model" then
					table.insert(target2, 1, k)
					inc_references(WorldModelElements, k, v, reference_table, 10000)
				elseif v.type == "Sprite" or v.type == "Quad" or v.type == "Bodygroup" then
					table.insert(target2, k)
					inc_references(WorldModelElements, k, v, reference_table, 1)
				end
			end

			table.sort(target2, rendersorter)
		end

		return self.vRenderOrder, self.wRenderOrder
	end
end

function SWEP:RemoveModsRenderOrder()
	self.vRenderOrder = nil
end

local drawfn, drawself, fndrawpos, fndrawang, fndrawsize

local function dodrawfn()
	drawfn(drawself, fndrawpos, fndrawang, fndrawsize)
end

local next_setup_bones = 0

function TFA._IncNextSetupBones()
	next_setup_bones = next_setup_bones + 1
end

function TFA._GetNextSetupBones()
	return next_setup_bones
end

local mirror_scale = Vector(1, -1, 1)
local normal_scale = Vector(1, 1, 1)

local mirror = Matrix()

local DRAW_AND_SETUP = 0
local ONLY_DRAW = 1
local ONLY_SETUP = 2

local function draw_element_closure(self, self2, name, index, vm, ViewModelElements, element, nodraw)
	if self2.GetStatL(self, "ViewModelElements." .. name .. ".active") == false then return end
	if self2.TFA_IsDrawingStencilSights and self2.GetStatL(self, "StencilSight_VElement") == name then return end

	local pos, ang = self:GetBoneOrientation(ViewModelElements, element, vm, nil, true)
	if not pos and not element.bonemerge then return end

	self:PrecacheElement(element, true)

	local model = element.curmodel
	local sprite = element.spritemat

	local dodraw = nodraw == DRAW_AND_SETUP or nodraw == ONLY_DRAW
	local dosetup = nodraw == DRAW_AND_SETUP or nodraw == ONLY_SETUP

	if element.type == "Model" and IsValid(model) then
		if not element.bonemerge and dosetup then
			mirror:Identity()

			if self2.ViewModelFlip then
				model:SetPos(pos + ang:Forward() * element.pos.x - ang:Right() * element.pos.y + ang:Up() * element.pos.z)

				ang:RotateAroundAxis(ang:Up(), -element.angle.y)
				ang:RotateAroundAxis(ang:Right(), element.angle.p)
				ang:RotateAroundAxis(ang:Forward(), -element.angle.r)

				mirror:Scale(mirror_scale)
				mirror:Scale(element.size)
			else
				model:SetPos(pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z)

				ang:RotateAroundAxis(ang:Up(), element.angle.y)
				ang:RotateAroundAxis(ang:Right(), element.angle.p)
				ang:RotateAroundAxis(ang:Forward(), element.angle.r)

				mirror:Scale(normal_scale)
				mirror:Scale(element.size)
			end

			model:SetAngles(ang)
			model:EnableMatrix("RenderMultiply", mirror)
		end

		if dodraw then
			if element.surpresslightning then
				render.SuppressEngineLighting(true)
			end

			local material = self:GetStatL("ViewModelElements." .. name .. ".material")

			if not material or material == "" then
				model:SetMaterial("")
			elseif model:GetMaterial() ~= material then
				model:SetMaterial(material)
			end

			local skin = self:GetStatL("ViewModelElements." .. name .. ".skin")

			if skin and skin ~= model:GetSkin() then
				model:SetSkin(skin)
			end

			if not self2.SCKMaterialCached_V[name] then
				self2.SCKMaterialCached_V[name] = true

				local materialtable = self:GetStatL("ViewModelElements." .. name .. ".materials", {})
				local entmats = table.GetKeys(model:GetMaterials())

				for _, k in ipairs(entmats) do
					model:SetSubMaterial(k - 1, materialtable[k] or "")
				end
			end
		end

		if dosetup then
			if not self2.VElementsBodygroupsCache[index] then
				self2.VElementsBodygroupsCache[index] = #model:GetBodyGroups() - 1
			end

			if self2.VElementsBodygroupsCache[index] then
				for _b = 0, self2.VElementsBodygroupsCache[index] do
					local newbg = self2.GetStatL(self, "ViewModelElements." .. name .. ".bodygroup." .. _b, 0) -- names are not supported, use overridetable

					if model:GetBodygroup(_b) ~= newbg then
						model:SetBodygroup(_b, newbg)
					end
				end
			end

			if element.bonemerge then
				model:SetPos(pos)
				model:SetAngles(ang)

				if element.rel and ViewModelElements[element.rel] and IsValid(ViewModelElements[element.rel].curmodel) then
					element.parModel = ViewModelElements[element.rel].curmodel
				else
					element.parModel = self2.OwnerViewModel or self
				end

				if model:GetParent() ~= element.parModel then
					model:SetParent(element.parModel)
				end

				if not model:IsEffectActive(EF_BONEMERGE) then
					model:AddEffects(EF_BONEMERGE)
					model:AddEffects(EF_BONEMERGE_FASTCULL)
					model:SetMoveType(MOVETYPE_NONE)
					model:SetLocalPos(vector_origin)
					model:SetLocalAngles(angle_zero)
				end
			elseif model:IsEffectActive(EF_BONEMERGE) then
				model:RemoveEffects(EF_BONEMERGE)
				model:SetParent(NULL)
			end
		end

		if dodraw then
			render.SetColorModulation(element.color.r / 255, element.color.g / 255, element.color.b / 255)
			render.SetBlend(element.color.a / 255)
		end

		if dosetup and model.tfa_next_setup_bones ~= next_setup_bones then
			model:InvalidateBoneCache()
			model:SetupBones()
			model.tfa_next_setup_bones = next_setup_bones
		end

		if dodraw then
			if self2.ViewModelFlip then
				render.CullMode(MATERIAL_CULLMODE_CW)
			end

			model:DrawModel()

			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)

			if self2.ViewModelFlip then
				render.CullMode(MATERIAL_CULLMODE_CCW)
			end

			if element.surpresslightning then
				render.SuppressEngineLighting(false)
			end
		end
	elseif dodraw and element.type == "Sprite" and sprite then
		local drawpos = pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z
		render.SetMaterial(sprite)
		render.DrawSprite(drawpos, element.size.x, element.size.y, element.color)
	elseif dodraw and element.type == "Quad" and element.draw_func then
		local drawpos = pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z
		ang:RotateAroundAxis(ang:Up(), element.angle.y)
		ang:RotateAroundAxis(ang:Right(), element.angle.p)
		ang:RotateAroundAxis(ang:Forward(), element.angle.r)

		cam.Start3D2D(drawpos, ang, element.size)
		render.PushFilterMin(TEXFILTER.ANISOTROPIC)
		render.PushFilterMag(TEXFILTER.ANISOTROPIC)

		drawfn, drawself, fndrawpos, fndrawang, fndrawsize = element.draw_func, self, nil, nil, nil
		ProtectedCall(dodrawfn)

		render.PopFilterMin()
		render.PopFilterMag()
		cam.End3D2D()
	end
end

function SWEP:ViewModelDrawn()
	local self2 = self:GetTable()
	render.SetBlend(1)

	if self2.DrawHands then
		self2.DrawHands(self)
	end

	local vm = self.OwnerViewModel
	if not IsValid(vm) then return end
	if not self:GetOwner().GetHands then return end

	if self2.UseHands then
		local hands = self:GetOwner():GetHands()

		if IsValid(hands) then
			if not self2.GetHidden(self) then
				hands:SetParent(vm)
			else
				hands:SetParent(nil)
				hands:SetPos(tmpvec)
			end
		end
	end

	self2.UpdateBonePositions(self, vm)

	if not self2.CameraAttachment then
		self2.CameraAttachment = -1

		for _, v in ipairs(self2.CameraAttachments) do
			local attid = vm:LookupAttachment(v)

			if attid and attid > 0 then
				self2.CameraAttachment = attid
				break
			end
		end
	end

	if self2.CameraAttachment and self2.CameraAttachment > 0 then
		local angpos = vm:GetAttachment(self2.CameraAttachment)

		if angpos and angpos.Ang then
			local ftv = FrameTime()
			local angv = angpos.Ang
			local off = vm:WorldToLocalAngles(angv)
			local spd = 15
			local cycl = vm:GetCycle()
			self2.CameraAngCache = self2.CameraAngCache or off

			for _, v in pairs(self2.CameraAttachmentOffsets) do
				local offtype = v[1]
				local offang = v[2]

				if offtype == "p" then
					off:RotateAroundAxis(off:Right(), offang)
				elseif offtype == "y" then
					off:RotateAroundAxis(off:Up(), offang)
				elseif offtype == "r" then
					off:RotateAroundAxis(off:Forward(), offang)
				end
			end

			if self2.ViewModelFlip then
				off = Angle()
			end

			local stat = self:GetStatus()

			if (stat == TFA.Enum.STATUS_DRAW) and cycl < 0.05 then
				local mul = cycl / 0.05

				self2.CameraAngCache.p = self2.CameraAngCache.p * mul
				self2.CameraAngCache.y = self2.CameraAngCache.y * mul
				self2.CameraAngCache.r = self2.CameraAngCache.r * mul
			elseif TFA.Enum.HolsterStatus[stat] and cycl > 0.95 and not self2.GetStatL(self, "ProceduralHolsterEnabled") then
				local mul = 1 - (cycl - 0.95) / 0.05

				self2.CameraAngCache.p = self2.CameraAngCache.p * mul
				self2.CameraAngCache.y = self2.CameraAngCache.y * mul
				self2.CameraAngCache.r = self2.CameraAngCache.r * mul
			end

			self2.CameraAngCache.p = math.Approach(self2.CameraAngCache.p, off.p, (self2.CameraAngCache.p - off.p) * ftv * spd)
			self2.CameraAngCache.y = math.Approach(self2.CameraAngCache.y, off.y, (self2.CameraAngCache.y - off.y) * ftv * spd)
			self2.CameraAngCache.r = math.Approach(self2.CameraAngCache.r, off.r, (self2.CameraAngCache.r - off.r) * ftv * spd)
		else
			self2.CameraAngCache.p = 0
			self2.CameraAngCache.y = 0
			self2.CameraAngCache.r = 0
		end
	end

	local ViewModelElements = self:GetStatRawL("ViewModelElements") or {}
	local ViewModelBodygroups = self:GetStatRawL("ViewModelBodygroups") or {}

	if ViewModelElements and self2.HasInitAttachments then
		-- ViewModelElements = self:GetStatL("ViewModelElements")
		-- self:CreateModels(ViewModelElements, true)

		self2.SCKMaterialCached_V = self2.SCKMaterialCached_V or {}

		if not self2.vRenderOrder then
			self:RebuildModsRenderOrder()
		end

		vm:InvalidateBoneCache()
		vm:SetupBones()
		next_setup_bones = next_setup_bones + 1

		for index = 1, #self2.vRenderOrder do
			local name = self2.vRenderOrder[index]
			local element = ViewModelElements[name]

			if not element then
				self:RebuildModsRenderOrder()
				break
			end

			if element.type == "Bodygroup" then
				if element.index and element.value_active then
					ViewModelBodygroups[element.index] = self2.GetStatL(self, "ViewModelElements." .. name .. ".active") and element.value_active or (element.value_inactive or 0)
				end

				goto CONTINUE
			end

			if element.hide then goto CONTINUE end

			if element.type == "Quad" and element.draw_func_outer then goto CONTINUE end
			if not element.bone and not element.attachment then goto CONTINUE end

			draw_element_closure(self, self2, name, index, vm, ViewModelElements, element, element.translucent == true and ONLY_SETUP or DRAW_AND_SETUP)

			::CONTINUE::
		end
	end

	if not self2.UseHands and self2.ViewModelDrawnPost then
		self:ViewModelDrawnPost()
		self:ViewModelDrawnPostFinal()
	end

	if self2.ShellEjectionQueue ~= 0 then
		for i = 1, self2.ShellEjectionQueue do
			self:MakeShell(true)
		end

		self2.ShellEjectionQueue = 0
	end
end

function SWEP:ViewModelDrawnPostFinal()
	local self2 = self:GetTable()
	local vm = self.OwnerViewModel
	if not IsValid(vm) then return end

	local ViewModelElements = self:GetStatRawL("ViewModelElements")
	if not ViewModelElements then return end

	for index = 1, #self2.vRenderOrder do
		local name = self2.vRenderOrder[index]
		local element = ViewModelElements[name]

		if element.hide or not element.translucent then goto CONTINUE end

		if element.type == "Quad" and element.draw_func_outer then goto CONTINUE end
		if not element.bone and not element.attachment then goto CONTINUE end

		draw_element_closure(self, self2, name, index, vm, ViewModelElements, element, ONLY_DRAW)

		::CONTINUE::
	end
end

function SWEP:ViewModelDrawnPost()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return end

	if not self.ViewModelFlip then
		self2.CacheSightsPos(self, self.OwnerViewModel, false)
	end

	local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion)

	if not ViewModelElements or not self2.vRenderOrder then return end

	for index = 1, #self2.vRenderOrder do
		local name = self2.vRenderOrder[index]
		local element = ViewModelElements[name]

		if element.type == "Quad" and element.draw_func_outer and not element.hide and (element.bone or element.attachment and element.attachment ~= "") and self:GetStatL("ViewModelElements." .. name .. ".active") ~= false then
			local pos, ang = self:GetBoneOrientation(ViewModelElements, element, self2.OwnerViewModel)

			if pos then
				local drawpos = pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z

				ang:RotateAroundAxis(ang:Up(), element.angle.y)
				ang:RotateAroundAxis(ang:Right(), element.angle.p)
				ang:RotateAroundAxis(ang:Forward(), element.angle.r)

				drawfn, drawself, fndrawpos, fndrawang, fndrawsize = element.draw_func_outer, self, drawpos, ang, element.size
				ProtectedCall(dodrawfn)
			end
		end
	end
end

--[[
Function Name:  DrawWorldModel
Syntax: self:DrawWorldModel().  Automatically called already.
Returns:  Nothing.
Notes:  This draws the world model, plus its attachments.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:DrawWorldModel()
	local self2 = self:GetTable()

	local skinStat = self2.GetStatL(self, "Skin")
	if isnumber(skinStat) then
		if self:GetSkin() ~= skinStat then
			self:SetSkin(skinStat)
		end
	end

	if not self2.MaterialCached_W and self2.GetStatL(self, "MaterialTable_W") then
		self2.MaterialCached_W = {}
		self:SetSubMaterial()

		local collectedKeys = table.GetKeys(self2.GetStatL(self, "MaterialTable_W"))
		table.Merge(collectedKeys, table.GetKeys(self2.GetStatL(self, "MaterialTable")))

		for _, k in ipairs(collectedKeys) do
			if (k == "BaseClass") then goto CONTINUE end

			local v = self2.GetStatL(self, "MaterialTable_W")[k]

			if not self2.MaterialCached_W[k] then
				self:SetSubMaterial(k - 1, v)
				self2.MaterialCached_W[k] = true
			end

			::CONTINUE::
		end
	end

	local ply = self:GetOwner()
	local validowner = IsValid(ply)

	if validowner then
		-- why? this tanks FPS because source doesn't have a chance to setup bones when it needs to
		-- instead we ask it to do it `right now`
		-- k then
		ply:SetupBones()
		ply:InvalidateBoneCache()
		self:InvalidateBoneCache()
	end

	if self2.ShowWorldModel == nil or self2.ShowWorldModel or not validowner then
		self2.WorldModelOffsetUpdate(self, ply)
		self2.ProcessBodygroups(self)

		self:DrawModel()
	end

	self:SetupBones()
	self2.UpdateWMBonePositions(self)

	self:DrawWElements()

	if IsValid(self) and self.IsTFAWeapon and (self:GetOwner() ~= LocalPlayer() or not self:IsFirstPerson()) then
		self2.UpdateProjectedTextures(self, false)
	end
end

function SWEP:DrawWElements()
	local self2 = self:GetTable()

	local WorldModelElements = self2.GetStatRaw(self, "WorldModelElements", TFA.LatestDataVersion)

	if not WorldModelElements then return end

	if not self2.SCKMaterialCached_W then
		self2.SCKMaterialCached_W = {}
	end

	if not self2.wRenderOrder then
		self2.RebuildModsRenderOrder(self)
	end

	local ply = self:GetOwner()
	local validowner = IsValid(ply)

	for index = 1, #self2.wRenderOrder do
		local name = self2.wRenderOrder[index]
		local element = WorldModelElements[name]

		if not element then
			self2.RebuildModsRenderOrder(self)
			break
		end

		if element.type == "Bodygroup" then
			if element.index and element.value_active then
				self2.WorldModelBodygroups[element.index] = self2.GetStatL(self, "WorldModelElements." .. name .. ".active") and element.value_active or (element.value_inactive or 0)
			end

			goto CONTINUE
		end

		if element.hide then goto CONTINUE end
		if self2.GetStatL(self, "WorldModelElements." .. name .. ".active") == false then goto CONTINUE end

		local bone_ent = (validowner and ply:LookupBone(element.bone or "ValveBiped.Bip01_R_Hand")) and ply or self
		local pos, ang

		if element.bone then
			pos, ang = self2.GetBoneOrientation(self, WorldModelElements, element, bone_ent)
		else
			pos, ang = self2.GetBoneOrientation(self, WorldModelElements, element, bone_ent, "ValveBiped.Bip01_R_Hand")
		end

		if not pos and not element.bonemerge then goto CONTINUE end

		self2.PrecacheElement(self, element, true)

		local model = element.curmodel
		local sprite = element.spritemat

		if element.type == "Model" and IsValid(model) then
			if element.bonemerge then
				model:SetPos(pos)
				model:SetAngles(ang)
			else
				model:SetPos(pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z)

				ang:RotateAroundAxis(ang:Up(), element.angle.y)
				ang:RotateAroundAxis(ang:Right(), element.angle.p)
				ang:RotateAroundAxis(ang:Forward(), element.angle.r)

				model:SetAngles(ang)
			end

			local material = self2.GetStatL(self, "WorldModelElements." .. name .. ".material")

			if not material or material == "" then
				model:SetMaterial("")
			elseif model:GetMaterial() ~= material then
				model:SetMaterial(material)
			end

			local skin = self2.GetStatL(self, "WorldModelElements." .. name .. ".skin")

			if skin and skin ~= model:GetSkin() then
				model:SetSkin(skin)
			end

			if not self2.SCKMaterialCached_W[name] then
				self2.SCKMaterialCached_W[name] = true

				local materialtable = self2.GetStatL(self, "WorldModelElements." .. name .. ".materials", {})
				local entmats = table.GetKeys(model:GetMaterials())

				for _, k in ipairs(entmats) do
					model:SetSubMaterial(k - 1, materialtable[k] or "")
				end
			end

			if not self2.WElementsBodygroupsCache[index] then
				self2.WElementsBodygroupsCache[index] = #model:GetBodyGroups() - 1
			end

			if self2.WElementsBodygroupsCache[index] then
				for _b = 0, self2.WElementsBodygroupsCache[index] do
					local newbg = self2.GetStatL(self, "WorldModelElements." .. name .. ".bodygroup." .. _b, 0) -- names are not supported, use overridetable

					if model:GetBodygroup(_b) ~= newbg then
						model:SetBodygroup(_b, newbg)
					end
				end
			end

			if element.surpresslightning then
				render.SuppressEngineLighting(true)
			end

			if element.bonemerge then
				if element.rel and WorldModelElements[element.rel] and IsValid(WorldModelElements[element.rel].curmodel) and WorldModelElements[element.rel].bone ~= "oof" then
					element.parModel = WorldModelElements[element.rel].curmodel
				else
					element.parModel = self
				end

				if model:GetParent() ~= element.parModel then
					model:SetParent(element.parModel)
				end

				if not model:IsEffectActive(EF_BONEMERGE) then
					model:AddEffects(EF_BONEMERGE)
					model:SetLocalPos(vector_origin)
					model:SetLocalAngles(angle_zero)
				end
			elseif model:IsEffectActive(EF_BONEMERGE) then
				model:RemoveEffects(EF_BONEMERGE)
				model:SetParent(nil)
			end

			render.SetColorModulation(element.color.r / 255, element.color.g / 255, element.color.b / 255)
			render.SetBlend(element.color.a / 255)

			model:DrawModel()

			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)

			if element.surpresslightning then
				render.SuppressEngineLighting(false)
			end
		elseif element.type == "Sprite" and sprite then
			local drawpos = pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z
			render.SetMaterial(sprite)
			render.DrawSprite(drawpos, element.size.x, element.size.y, element.color)
		elseif element.type == "Quad" and element.draw_func then
			local drawpos = pos + ang:Forward() * element.pos.x + ang:Right() * element.pos.y + ang:Up() * element.pos.z
			ang:RotateAroundAxis(ang:Up(), element.angle.y)
			ang:RotateAroundAxis(ang:Right(), element.angle.p)
			ang:RotateAroundAxis(ang:Forward(), element.angle.r)
			cam.Start3D2D(drawpos, ang, element.size)

			drawfn, drawself, fndrawpos, fndrawang, fndrawsize = element.draw_func, self, nil, nil, nil
			ProtectedCall(dodrawfn)

			cam.End3D2D()
		end

		::CONTINUE::
	end
end

function SWEP:WorldModelOffsetUpdate(ply)
	if not IsValid(ply) then
		self:SetRenderOrigin(nil)
		self:SetRenderAngles(nil)

		local WorldModelOffset = self:GetStatRawL("WorldModelOffset")

		if WorldModelOffset and WorldModelOffset.Scale then
			self:SetModelScale(WorldModelOffset.Scale, 0)
		end

		return
	end


	local WorldModelOffset = self:GetStatRawL("WorldModelOffset")

		-- THIS IS DANGEROUS
	if WorldModelOffset and WorldModelOffset.Pos and WorldModelOffset.Ang then
		-- TO DO ONLY CLIENTSIDE
		-- since this will break hitboxes!
		local handBone = ply:LookupBone("ValveBiped.Bip01_R_Hand")

		if handBone then
			--local pos, ang = ply:GetBonePosition(handBone)
			local pos, ang
			local mat = ply:GetBoneMatrix(handBone)

			if mat then
				pos, ang = mat:GetTranslation(), mat:GetAngles()
			else
				pos, ang = ply:GetBonePosition(handBone)
			end

			local opos, oang, oscale = WorldModelOffset.Pos, WorldModelOffset.Ang, WorldModelOffset.Scale

			pos = pos + ang:Forward() * opos.Forward + ang:Right() * opos.Right + ang:Up() * opos.Up
			ang:RotateAroundAxis(ang:Up(), oang.Up)
			ang:RotateAroundAxis(ang:Right(), oang.Right)
			ang:RotateAroundAxis(ang:Forward(), oang.Forward)
			self:SetRenderOrigin(pos)
			self:SetRenderAngles(ang)
			--if WorldModelOffset.Scale and ( !self2.MyModelScale or ( WorldModelOffset and self2.MyModelScale!=WorldModelOffset.Scale ) ) then
			self:SetModelScale(oscale or 1, 0)
			--end
		end
	end
end

--[[
Function Name:  GetBoneOrientation
Syntax: self:GetBoneOrientation( base bone mod table, bone mod table, entity, bone override ).
Returns:  Position, Angle.
Notes:  This is a very specific function for a specific purpose, and shouldn't be used generally to get a bone's orientation.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:GetBoneOrientation(basetabl, tabl, ent, bone_override, isVM, isAttachment, isNonRoot)
	local bone, pos, ang

	if not IsValid(ent) then return Vector(), Angle() end

	if not isNonRoot and tabl.rel and tabl.rel ~= "" and not tabl.bonemerge then
		local v = basetabl[tabl.rel]
		if not v then return Vector(), Angle() end

		local boneName = tabl.bone

		if tabl.attachment and tabl.attachment ~= "" and v.curmodel:LookupAttachment(tabl.attachment) ~= 0 then
			pos, ang = self:GetBoneOrientation(basetabl, v, v.curmodel, tabl.attachment, isVM, true, true)

			if pos and ang then return pos, ang end
		elseif v.curmodel and ent ~= v.curmodel and (v.bonemerge or (boneName and boneName ~= "" and v.curmodel:LookupBone(boneName))) then
			pos, ang = self:GetBoneOrientation(basetabl, v, v.curmodel, boneName, isVM, false, true)

			if pos and ang then return pos, ang end
		else
			--As clavus states in his original code, don't make your elements named the same as a bone, because recursion.
			pos, ang = self:GetBoneOrientation(basetabl, v, ent, nil, isVM, false, true)

			if pos and ang then
				pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z

				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				-- For mirrored viewmodels.  You might think to scale negatively on X, but this isn't the case.

				return pos, ang
			end
		end
	end

	if isAttachment == nil then isAttachment = tabl.attachment ~= nil end

	if isnumber(bone_override) then
		bone = bone_override
	elseif isAttachment then
		bone = ent:LookupAttachment(bone_override or tabl.attachment)
	else
		bone = ent:LookupBone(bone_override or tabl.bone) or 0
	end

	if not bone or bone == -1 then return end
	pos, ang = Vector(0, 0, 0), Angle(0, 0, 0)

	if ent.tfa_next_setup_bones ~= next_setup_bones then
		ent:InvalidateBoneCache()
		ent:SetupBones()
		ent.tfa_next_setup_bones = next_setup_bones
	end

	if isAttachment then
		-- mmmm yes tasty LuaVM memory
		-- GC screams in agony
		local get = ent:GetAttachment(bone)

		if get then
			pos, ang = get.Pos, get.Ang
		end
	else

		local m = ent:GetBoneMatrix(bone)

		if m then
			pos, ang = m:GetTranslation(), m:GetAngles()
		end
	end

	local owner = self:GetOwner()

	if isVM and self.ViewModelFlip then
		ang.r = -ang.r
	end

	return pos, ang
end
--[[
Function Name:  CleanModels
Syntax: self:CleanModels( elements table ).
Returns:   Nothing.
Notes:  Removes all existing models.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:CleanModels(input)
	if not istable(input) then return end

	for _, v in pairs(input) do
		if (v.type == "Model" and v.curmodel) then
			if IsValid(v.curmodel) then
				v.curmodel:Remove()
			end

			v.curmodel = nil
		elseif (v.type == "Sprite" and v.sprite and v.sprite ~= "" and (not v.spritemat or v.cursprite ~= v.sprite)) then
			v.cursprite = nil
			v.spritemat = nil
		end
	end
end

function SWEP:PrecacheElementModel(element, is_vm)
	element.curmodel = ClientsideModel(element.model, RENDERGROUP_OTHER)
	element.curmodel.tfa_gun_parent = self
	element.curmodel.tfa_gun_clmodel = true

	if self.SWEPConstructionKit then
		TFA.RegisterClientsideModel(element.curmodel, self)
	end

	if not IsValid(element.curmodel) then
		element.curmodel = nil
		return
	end

	element.curmodel:SetPos(self:GetPos())
	element.curmodel:SetAngles(self:GetAngles())
	element.curmodel:SetParent(self)
	element.curmodel:SetOwner(self)
	element.curmodel:SetNoDraw(true)

	if element.material then
		element.curmodel:SetMaterial(element.material or "")
	end

	if element.skin then
		element.curmodel:SetSkin(element.skin)
	end

	local matrix = Matrix()
	matrix:Scale(element.size)

	element.curmodel:EnableMatrix("RenderMultiply", matrix)
	element.curmodelname = element.model
	element.view = is_vm == true

	-- // make sure we create a unique name based on the selected options
end

do
	local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}

	function SWEP:PrecacheElementSprite(element, is_vm)
		if element.vmt then
			element.spritemat = Material(element.sprite)
			element.cursprite = element.sprite
			return
		end

		local name = "tfa-" .. element.sprite .. "-"

		local params = {
			["$basetexture"] = element.sprite
		}

		for _, element_property in ipairs(tocheck) do
			if (element[element_property]) then
				params["$" .. element_property] = 1
				name = name .. "1"
			else
				name = name .. "0"
			end
		end

		element.cursprite = element.sprite
		element.spritemat = CreateMaterial(name, "UnlitGeneric", params)
	end
end

function SWEP:PrecacheElement(element, is_vm)
	if element.type == "Model" and element.model and (not IsValid(element.curmodel) or element.curmodelname ~= element.model) and element.model ~= "" then
		if IsValid(element.curmodel) then
			element.curmodel:Remove()
		end

		self:PrecacheElementModel(element, is_vm)
	elseif (element.type == "Sprite" and element.sprite and element.sprite ~= "" and (not element.spritemat or element.cursprite ~= element.sprite)) then
		self:PrecacheElementSprite(element, is_vm)
	end
end

--[[
Function Name:  CreateModels
Syntax: self:CreateModels( elements table ).
Returns:   Nothing.
Notes:  Creates the elements for whatever you give it.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:CreateModels(input, is_vm)
	if not istable(input) then return end

	for _, element in pairs(input) do
		self:PrecacheElement(element, is_vm)
	end
end

--[[
Function Name:  UpdateBonePositions
Syntax: self:UpdateBonePositions( viewmodel ).
Returns:   Nothing.
Notes:   Updates the bones for a viewmodel.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
local bpos, bang
local onevec = Vector(1, 1, 1)
local getKeys = table.GetKeys

local function appendTable(t, t2)
	for i = 1, #t2 do
		t[#t + 1] = t2[i]
	end
end

SWEP.ChildrenScaled = {}
SWEP.ViewModelBoneMods_Children = {}

function SWEP:ScaleChildBoneMods(ent,bone,cumulativeScale)
	if self.ChildrenScaled[bone] then
		return
	end
	self.ChildrenScaled[bone] = true
	local boneid = ent:LookupBone(bone)
	if not boneid then return end
	local curScale = (cumulativeScale or Vector(1,1,1)) * 1
	if self.ViewModelBoneMods[bone] then
		curScale = curScale * self.ViewModelBoneMods[bone].scale
	end
	local ch = ent:GetChildBones(boneid)
	if ch and #ch > 0 then
		for _, boneChild in ipairs(ch) do
			self:ScaleChildBoneMods(ent,ent:GetBoneName(boneChild),curScale)
		end
	end
	if self.ViewModelBoneMods[bone] then
		self.ViewModelBoneMods[bone].scale = curScale
	else
		self.ViewModelBoneMods_Children[bone] = {
			["pos"] = vector_origin,
			["angle"] = angle_zero,
			["scale"] = curScale * 1
		}
	end
end

local vmbm_old_count = 0

function SWEP:UpdateBonePositions(vm)
	local self2 = self:GetTable()
	local vmbm = self2.GetStatL(self, "ViewModelBoneMods")

	local vmbm_count = 0

	if vmbm then
		vmbm_count = table.Count(vmbm)
	end

	if vmbm_old_count ~= vmbm_count then
		self:ResetBonePositions()
	end

	vmbm_old_count = vmbm_count

	if vmbm then
		local stat = self:GetStatus()

		if not self2.BlowbackBoneMods then
			self2.BlowbackBoneMods = {}
			self2.BlowbackCurrent = 0
		end

		if not self2.HasSetMetaVMBM then
			for k,v in pairs(self2.ViewModelBoneMods) do
				if (k == "BaseClass") then goto CONTINUE end -- do not name your bones like this pls

				local scale = v.scale

				if scale and scale.x ~= 1 or scale.y ~= 1 or scale.z ~= 1 then
					self:ScaleChildBoneMods(vm, k)
				end

				::CONTINUE::
			end

			for _,v in pairs(self2.BlowbackBoneMods) do
				v.pos_og = v.pos
				v.angle_og = v.angle
				v.scale_og = v.scale or onevec
			end

			self2.HasSetMetaVMBM = true
			self2.ViewModelBoneMods["wepEnt"] = self

			setmetatable(self2.ViewModelBoneMods, {__index = function(t,k)
				if not IsValid(self) then return end
				if self2.ViewModelBoneMods_Children[k] then return self2.ViewModelBoneMods_Children[k] end
				if not self2.BlowbackBoneMods[k] then return end
				if not ( self2.SequenceEnabled[ACT_VM_RELOAD_EMPTY] and TFA.Enum.ReloadStatus[stat] and self2.Blowback_PistolMode ) then
					self2.BlowbackBoneMods[k].pos = self2.BlowbackBoneMods[k].pos_og * self2.BlowbackCurrent
					self2.BlowbackBoneMods[k].angle = self2.BlowbackBoneMods[k].angle_og * self2.BlowbackCurrent
					self2.BlowbackBoneMods[k].scale = Lerp(self2.BlowbackCurrent, onevec, self2.BlowbackBoneMods[k].scale_og)
					return self2.BlowbackBoneMods[k]
				end
			end})
		end

		if not ( self2.SequenceEnabled[ACT_VM_RELOAD_EMPTY] and TFA.Enum.ReloadStatus[stat] and self2.Blowback_PistolMode ) then
			self2.BlowbackCurrent = math.Approach(self2.BlowbackCurrent, 0, self2.BlowbackCurrent * FrameTime() * 30)
		end

		local keys = getKeys(vmbm)
		appendTable(keys, getKeys(self2.GetStatL(self, "BlowbackBoneMods") or self2.BlowbackBoneMods))
		appendTable(keys, getKeys(self2.ViewModelBoneMods_Children))

		for _,k in pairs(keys) do
			if k == "wepEnt" then goto CONTINUE end

			local v = vmbm[k] or self2.GetStatL(self, "ViewModelBoneMods." .. k)
			if not v then goto CONTINUE end

			local vscale, vangle, vpos = v.scale, v.angle, v.pos

			local bone = vm:LookupBone(k)
			if not bone then goto CONTINUE end

			local b = self2.GetStatL(self, "BlowbackBoneMods." .. k)

			if b then
				vscale = Lerp(self2.BlowbackCurrent, vscale, vscale * b.scale)
				vangle = vangle + b.angle * self2.BlowbackCurrent
				vpos = vpos + b.pos * self2.BlowbackCurrent
			end

			if vm:GetManipulateBoneScale(bone) ~= vscale then
				vm:ManipulateBoneScale(bone, vscale)
			end

			if vm:GetManipulateBoneAngles(bone) ~= vangle then
				vm:ManipulateBoneAngles(bone, vangle)
			end

			if vm:GetManipulateBonePosition(bone) ~= vpos then
				vm:ManipulateBonePosition(bone, vpos)
			end

			::CONTINUE::
		end
	elseif self2.BlowbackBoneMods then
		for bonename, tbl in pairs(self2.BlowbackBoneMods) do
			local bone = vm:LookupBone(bonename)

			if bone and bone >= 0 then
				bpos = tbl.pos * self2.BlowbackCurrent
				bang = tbl.angle * self2.BlowbackCurrent
				vm:ManipulateBonePosition(bone, bpos)
				vm:ManipulateBoneAngles(bone, bang)
			end
		end
	end
end

--[[
Function Name:  ResetBonePositions
Syntax: self:ResetBonePositions( viewmodel ).
Returns:   Nothing.
Notes:   Resets the bones for a viewmodel.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:ResetBonePositions(val)
	if SERVER then
		self:CallOnClient("ResetBonePositions", "")

		return
	end

	local vm = self.OwnerViewModel
	if not IsValid(vm) then return end
	if (not vm:GetBoneCount()) then return end

	for i = 0, vm:GetBoneCount() do
		vm:ManipulateBoneScale(i, Vector(1, 1, 1))
		vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
		vm:ManipulateBonePosition(i, vector_origin)
	end
end

--[[
Function Name:  UpdateWMBonePositions
Syntax: self:UpdateWMBonePositions( worldmodel ).
Returns:   Nothing.
Notes:   Updates the bones for a worldmodel.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:UpdateWMBonePositions()
	if not self.WorldModelBoneMods then
		self.WorldModelBoneMods = {}
	end

	local WM_BoneMods = self:GetStatL("WorldModelBoneMods", self.WorldModelBoneMods)

	if next(WM_BoneMods) then
		for bone = 0, self:GetBoneCount() - 1 do
			local bonemod = WM_BoneMods[self:GetBoneName(bone)]
			if not bonemod then goto CONTINUE end

			local childscale
			local cur = self:GetBoneParent(bone)

			while (cur ~= -1) do
				local par = WM_BoneMods[self:GetBoneName(cur)]

				if par then
					childscale = (childscale or onevec) * (par.scale or onevec)
				end

				cur = self:GetBoneParent(cur)
			end

			local s = (bonemod.scale or onevec)
			if childscale then
				s = s * childscale
			end

			if self:GetManipulateBoneScale(bone) ~= s then
				self:ManipulateBoneScale(bone, s)
			end

			local a = bonemod.angle or angle_zero

			if self:GetManipulateBoneAngles(bone) ~= a then
				self:ManipulateBoneAngles(bone, a)
			end

			local p = bonemod.pos or vector_origin

			if self:GetManipulateBonePosition(bone) ~= p then
				self:ManipulateBonePosition(bone, p)
			end

			::CONTINUE::
		end
	end
end

--[[
Function Name:  ResetWMBonePositions
Syntax: self:ResetWMBonePositions( worldmodel ).
Returns:   Nothing.
Notes:   Resets the bones for a worldmodel.
Purpose:  SWEP Construction Kit Compatibility / Basic Attachments.
]]
--
function SWEP:ResetWMBonePositions(wm)
	if SERVER then
		self:CallOnClient("ResetWMBonePositions", "")

		return
	end

	if not wm then
		wm = self
	end

	if not IsValid(wm) then return end

	for i = 0, wm:GetBoneCount() - 1 do
		wm:ManipulateBoneScale(i, Vector(1, 1, 1))
		wm:ManipulateBoneAngles(i, Angle(0, 0, 0))
		wm:ManipulateBonePosition(i, vector_origin)
	end
end

function SWEP:PreDrawStencilSight(vm, ply, SightElementTable)
end

function SWEP:PostDrawStencilSight(vm, ply, SightElementTable)
end

--PATH lua/weapons/tfa_gun_base/client/flashlight.lua:
local vector_origin = Vector()

local att, angpos, attname, elemname, targetent
SWEP.FlashlightDistance = 12 * 50 -- default 50 feet
SWEP.FlashlightAttachment = 0
SWEP.FlashlightBrightness = 1
SWEP.FlashlightFOV = 60

local Material = Material
local ProjectedTexture = ProjectedTexture
local math = math

local function IsHolstering(wep)
	if IsValid(wep) and TFA.Enum.HolsterStatus[wep:GetStatus()] then return true end

	return false
end

-- TODO: This seems to be *extremely* similar to drawlaser
-- Should we merge them?
function SWEP:DrawFlashlight(is_vm)
	local self2 = self:GetTable()

	if not self2.FlashlightDotMaterial then
		self2.FlashlightDotMaterial = Material(self2.GetStatL(self, "FlashlightMaterial") or "effects/flashlight001")
	end

	local ply = self:GetOwner()
	if not IsValid(ply) then return end

	if not self:GetFlashlightEnabled() then
		self:CleanFlashlight()

		return
	end

	if is_vm then
		if not self2.VMIV(self) then
			self:CleanFlashlight()

			return
		end

		targetent = self2.OwnerViewModel
		elemname = self2.GetStatL(self, "Flashlight_VElement", self2.GetStatL(self, "Flashlight_Element"))

		local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion)

		if elemname and ViewModelElements[elemname] and IsValid(ViewModelElements[elemname].curmodel) then
			targetent = ViewModelElements[elemname].curmodel
		end

		att = self2.GetStatL(self, "FlashlightAttachment")

		attname = self2.GetStatL(self, "FlashlightAttachmentName")

		if attname then
			att = targetent:LookupAttachment(attname)
		end

		if (not att) or att <= 0 then
			self:CleanFlashlight()

			return
		end

		angpos = targetent:GetAttachment(att)

		if not angpos then
			self:CleanFlashlight()

			return
		end

		if self2.FlashlightISMovement and self2.CLIronSightsProgress > 0 then
			local isang = self2.GetStatL(self, "IronSightsAngle")
			angpos.Ang:RotateAroundAxis(angpos.Ang:Right(), isang.y * (self2.ViewModelFlip and -1 or 1) * self2.CLIronSightsProgress)
			angpos.Ang:RotateAroundAxis(angpos.Ang:Up(), -isang.x * self2.CLIronSightsProgress)
		end

		local localProjAng = select(2, WorldToLocal(vector_origin, angpos.Ang, vector_origin, EyeAngles()))
		localProjAng.p = localProjAng.p * ply:GetFOV() / self2.ViewModelFOV
		localProjAng.y = localProjAng.y * ply:GetFOV() / self2.ViewModelFOV
		local wsProjAng = select(2, LocalToWorld(vector_origin, localProjAng, vector_origin, EyeAngles())) --reprojection for view angle

		if not IsValid(ply.TFAFlashlightGun) and not IsHolstering(self) then
			local lamp = ProjectedTexture()
			ply.TFAFlashlightGun = lamp
			lamp:SetTexture(self2.FlashlightDotMaterial:GetString("$basetexture"))
			lamp:SetFarZ(self2.GetStatL(self, "FlashlightDistance")) -- How far the light should shine
			lamp:SetFOV(self2.GetStatL(self, "FlashlightFOV"))
			lamp:SetPos(angpos.Pos)
			lamp:SetAngles(angpos.Ang)
			lamp:SetBrightness(self2.GetStatL(self, "FlashlightBrightness") * (0.9  + 0.1 * math.max(math.sin(CurTime() * 120), math.cos(CurTime() * 40))))
			lamp:SetNearZ(1)
			lamp:SetColor(color_white)
			lamp:SetEnableShadows(true)
			lamp:Update()
		end

		local lamp = ply.TFAFlashlightGun

		if IsValid(lamp) then
			lamp:SetPos(angpos.Pos)
			lamp:SetAngles(wsProjAng)
			lamp:SetBrightness(1.4 + 0.1 * math.max(math.sin(CurTime() * 120), math.cos(CurTime() * 40)))
			lamp:Update()
		end

		return
	end

	targetent = self

	elemname = self2.GetStatL(self, "Flashlight_WElement", self2.GetStatL(self, "Flashlight_Element"))

	local WorldModelElements = self:GetStatRaw("WorldModelElements", TFA.LatestDataVersion)

	if elemname and WorldModelElements[elemname] and IsValid(WorldModelElements[elemname].curmodel) then
		targetent = WorldModelElements[elemname].curmodel
	end

	att = self2.GetStatL(self, "FlashlightAttachmentWorld", self2.GetStatL(self, "FlashlightAttachment"))

	attname = self2.GetStatL(self, "FlashlightAttachmentNameWorld", self2.GetStatL(self, "FlashlightAttachmentName"))

	if attname then
		att = targetent:LookupAttachment(attname)
	end

	if (not att) or att <= 0 then
		self:CleanFlashlight()

		return
	end

	angpos = targetent:GetAttachment(att)

	if not angpos then
		angpos = targetent:GetAttachment(1)
	end

	if not angpos then
		self:CleanFlashlight()

		return
	end

	if not IsValid(ply.TFAFlashlightGun) and not IsHolstering(self) then
		local lamp = ProjectedTexture()
		ply.TFAFlashlightGun = lamp
		lamp:SetTexture(self2.FlashlightDotMaterial:GetString("$basetexture"))
		lamp:SetFarZ(self2.GetStatL(self, "FlashlightDistance")) -- How far the light should shine
		lamp:SetFOV(self2.GetStatL(self, "FlashlightFOV"))
		lamp:SetPos(angpos.Pos)
		lamp:SetAngles(angpos.Ang)
		lamp:SetBrightness(self2.GetStatL(self, "FlashlightBrightness") * (0.9  + 0.1 * math.max(math.sin(CurTime() * 120), math.cos(CurTime() * 40))))
		lamp:SetNearZ(1)
		lamp:SetColor(color_white)
		lamp:SetEnableShadows(false)
		lamp:Update()
	end

	local lamp = ply.TFAFlashlightGun

	if IsValid(lamp) then
		local lamppos = angpos.Pos
		local ang = angpos.Ang
		lamp:SetPos(lamppos)
		lamp:SetAngles(ang)
		lamp:SetBrightness(self2.GetStatL(self, "FlashlightBrightness") * (0.9  + 0.1 * math.max(math.sin(CurTime() * 120), math.cos(CurTime() * 40))))
		lamp:Update()
	end
end

function SWEP:CleanFlashlight()
	local ply = self:GetOwner()

	if IsValid(ply) and IsValid(ply.TFAFlashlightGun) then
		ply.TFAFlashlightGun:Remove()
	end
end

TFA.SWEP_LOAD_COMPLETE = true
--PATH lua/weapons/tfa_swsft_base/shared.lua:
DEFINE_BASECLASS("tfa_gun_base")
SWEP.TracerCount = 1
SWEP.MuzzleFlashEffect = ""
SWEP.TracerName = "effect_sw_laser_red"
SWEP.Secondary.IronFOV = 70
SWEP.Primary.KickUp = 0.2
SWEP.Primary.KickDown = 0.1
SWEP.Primary.KickHorizontal = 0.1
SWEP.Primary.KickRight = 0.1
SWEP.DisableChambering = true

SWEP.ImpactDecal = "FadingScorch"
SWEP.RunSightsPos = Vector(2.127, 0, 1.355)
SWEP.RunSightsAng = Vector(-15.775, 10.023, -5.664)
SWEP.BlowbackEnabled = true
SWEP.BlowbackVector = Vector(0, -3, 0.1)
SWEP.Blowback_Shell_Enabled = false
SWEP.Blowback_Shell_Effect = ""
SWEP.ThirdPersonReloadDisable = false
SWEP.Primary.DamageType = DMG_SHOCK
SWEP.DamageType = DMG_SHOCK

SWEP.ImpactEffect = "effect_sw_impact" --Impact Effect

function SWEP:DrawHands()
	self.UseHandsDefault = self.UseHandsDefault or self.UseHands
	if not self.UseHandsDefault then return end
	if not IsValid(self) or not self:OwnerIsValid() then return end
	local vm = self.OwnerViewModel
	if not IsValid(vm) then return end

	if not IsValid(self.Owner.SWHands) then
		self.Owner.SWHands = ClientsideModel("models/player/kylejwest/cgi3dphase1clone_c_arms/cgi3dphase1clone_c_arms.mdl")
		self.Owner.SWHands:SetParent(vm)
		self.Owner.SWHands:SetPos(self.Owner:GetShootPos())
		self.Owner.SWHands:SetAngles(self.Owner:EyeAngles())
		self.Owner.SWHands:AddEffects(EF_BONEMERGE)
		self.Owner.SWHands:SetNoDraw(true)
		self.Owner.SWHands.BoneMergedEnt = vm
	elseif self.Owner.SWHands:GetParent() ~= vm then
		self.Owner.SWHands:SetModel("models/player/kylejwest/cgi3dphase1clone_c_arms/cgi3dphase1clone_c_arms.mdl")
		self.Owner.SWHands:SetParent(vm)
		self.Owner.SWHands:SetPos(self.Owner:GetShootPos())
		self.Owner.SWHands:SetAngles(self.Owner:EyeAngles())
		self.Owner.SWHands:AddEffects(EF_BONEMERGE)
	elseif self.Owner.SWHands:GetModel() ~= "models/player/kylejwest/cgi3dphase1clone_c_arms/cgi3dphase1clone_c_arms.mdl" then
		self.Owner.SWHands:SetModel("models/player/kylejwest/cgi3dphase1clone_c_arms/cgi3dphase1clone_c_arms.mdl")
	end

	if self.Owner.SWHands then
		self.Owner.SWHands:DrawModel()
	end

	self.UseHands = false
end

--PATH addons/!jobs/lua/weapons/weapon_ak47custom/shared.lua:
--[[---------------------------------------------------------------------------
Here's an example weapon that you can edit
---------------------------------------------------------------------------]]
AddCSLuaFile()

if CLIENT then
    SWEP.PrintName = "AK47" -- The name that shows in the scroll menu and when you hover over the gun in the q-menu.
    SWEP.Author = "DarkRP Developers and <Name here>" -- Author Name.
    SWEP.Slot = 3 -- In which tab in the scroll menu the weapon shows up in. 1 being the far left and 9 being the farthest right.
    SWEP.SlotPos = 0 -- If you have 300 weapons all in the same slot you could organize each of them with a uniqe number all the way up to 300. Would keep it organized...I guess.
    SWEP.IconLetter = "b"

    killicon.AddFont("weapon_ak47custom", "CSKillIcons", SWEP.IconLetter, Color(255, 80, 0, 255))
    -- If you were to change the above folder name you would change the kill icon as well.
end

SWEP.Base = "weapon_cs_base2" -- If you dont plan to use weapons from the workshop this wont matter much.

SWEP.Spawnable = true -- If the weapon can be spawned.
SWEP.AdminSpawnable = true -- If Admins can spawn this.
SWEP.Category = "DarkRP (Weapon)" -- Defines where the weapon will be grouped in the q-menu->weapons tab. Can be anything you like. (Case sensitive!)
SWEP.SpawnMenuIcon = "vgui/entities/weapon_ak472"
-- For custom weapons you can create new icons by going to the materials folder of the addon and creating an entities folder
-- and creating a png inside with the dimensions of 128x128 and have the name of the file match the name of the weapons folder name.
-- The above icon uses an older style of achieving the same goal.

SWEP.UseHands = true -- Use the hands of your playermodel if the playermodel supports it.
SWEP.ViewModel = "models/weapons/cstrike/c_rif_ak47.mdl" -- The players point of view.
SWEP.WorldModel = "models/weapons/w_rif_ak47.mdl" -- The point of view others have when looking at the player holding the gun.

SWEP.Weight = 5
SWEP.AutoSwitchTo = false -- When you pick it up should you auto switch to the gun?
SWEP.AutoSwitchFrom = false -- When you pick something else up should you switch away from what you are holding?

SWEP.HoldType = "ar2" -- This is how others view you carrying the weapon. Options include:
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive
-- You're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.Primary.Sound = Sound("Weapon_AK47.Single") -- The sound that is played while shooting. You can setup a sound file externally or you can paste the path to any type of sound file on your server.
SWEP.Primary.Recoil = 1.5 -- How much the gun will jump while shooting.
SWEP.Primary.Damage = 40 -- How much it will hurt every time a bullet hits its target.
SWEP.Primary.NumShots = 1 -- How many bullets come out every time you shoot. Anything higer than 1 would probably be a shotgun.
SWEP.Primary.Cone = 0.002 -- How accurate the gun will be. Think "CSGO" when it comes to the weapon spread, thats this.
SWEP.Primary.ClipSize = 30 -- How much ammo can you hold in the clip at one time.
SWEP.Primary.Delay = 0.08 -- A delay between shots. Effects fire speed.
SWEP.Primary.DefaultClip = 30 -- How much ammo you spawn with.
SWEP.Primary.Automatic = true -- Is the gun Semi-Automatic or Fully Automatic? True for Full; False for Semi.
SWEP.Primary.Ammo = "smg1" -- What kind of ammo.  Options, besides custom, include pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, and AirboatGun.
--Pistol, buckshot, and slam like to ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ClipSize = -1 -- How much ammo you have for your secondary fire. Since this weapon doesnt have a secondary fire its set to -1
SWEP.Secondary.DefaultClip = -1 -- How much ammo you would spawn with for your secondary fire.
SWEP.Secondary.Automatic = false -- If your secondary fire is automatic or semi-automatic.
SWEP.Secondary.Ammo = "none" -- What type of ammo your secondary fire takes. If you dont have a secondary fire make sure to set this to none.

SWEP.IronSightsPos = Vector(-6.6, -15, 2.6) -- Where the gun locks into place when aiming.
SWEP.IronSightsAng = Vector(2.6, 0.02, 0) -- Where the gun locks into place when aiming.

SWEP.MultiMode = true

--PATH lua/weapons/weapon_armorkit/cl_init.lua:
return gluapack()()
--PATH lua/weapons/weapon_armorkit/shared.lua:
if SERVER then
	AddCSLuaFile("shared.lua")
	AddCSLuaFile("cl_init.lua")
	AddCSLuaFile("animations.lua")
end

SWEP.PrintName = "Armorkit"
SWEP.Author = "MrGeRoI"
SWEP.Purpose = "Repair armor people with your primary attack, or yourself with the secondary."

SWEP.Spawnable = true

SWEP.ViewModel = "models/weapons/c_medkit.mdl"--"models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/items/battery.mdl" --"models/weapons/w_medkit.mdl"

SWEP.Primary.ClipSize = 100
SWEP.Primary.DefaultClip = 100
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.MaxAmmo = 100
SWEP.ArmorAmount = 15

function SWEP:Initialize()
	self:SetHoldType("slam")

	if CLIENT then
		self:Anim_Initialize()
	end

	if not SERVER then return end

	self.TimerName = "armorkit_ammo" .. self:EntIndex()
	local wep = self
	timer.Create(self.TimerName,1,0,function()
		if IsValid(wep) then
			if wep:Clip1() < wep.MaxAmmo then
				wep:SetClip1(math.min(wep:Clip1() + 2,wep.MaxAmmo))
			end
		else
			timer.Remove(wep.TimerName)
		end
	end)

end

function SWEP:Deploy()
	--self:SendWeaponAnim(ACT_VM_DRAW)
	self.IdleAnimation = CurTime() + self:SequenceDuration()
	self:SetHoldType("slam")

	return true
end

function SWEP:Think()
	if self.IdleAnimation and self.IdleAnimation <= CurTime() then
		self.IdleAnimation = nil
		self:SendWeaponAnim(ACT_VM_IDLE)
	end
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
	return false
end

function SWEP:CanAttack()
	if self:Clip1() <= 0 then
		self.Owner:EmitSound("items/suitchargeno1.wav")
		self:SetNextFire(CurTime() + 2)
		return false
	end

	return self:GetNextPrimaryFire() <= CurTime()
end

function SWEP:GetHitTrace()
	local shoot = self.Owner:GetShootPos()
	return util.TraceLine({
		start = shoot,
		endpos = shoot + self.Owner:GetAimVector() * 64,
		filter = self.Owner,
	})
end

function SWEP:SetNextFire(time)
	self:SetNextPrimaryFire(time)
	self:SetNextSecondaryFire(time)
end

function SWEP:PrimaryAttack()
	if not self:CanAttack() then return end

	self:SetNextFire(CurTime() + 2)

	local tr = self:GetHitTrace()
	local need = (IsValid(tr.Entity) and tr.Entity:IsPlayer()) and math.min(100-tr.Entity:Armor(),self.ArmorAmount) or self.ArmorAmount
	if self:Clip1() >= need and tr.Hit and IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity:Armor() < 100 then
		self.Owner:SetAnimation(PLAYER_ATTACK1) --DoAttackEvent()
		self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
		self.IdleAnimation = CurTime() + self:SequenceDuration()

		if SERVER then
			self:TakePrimaryAmmo(need)
			self.Owner:SetAnimation(PLAYER_ATTACK1)
			tr.Entity:SetArmor(math.min(100,tr.Entity:Armor()+need))
			tr.Entity:EmitSound("items/battery_pickup.wav")
		end
	elseif SERVER then
		self.Owner:EmitSound("items/suitchargeno1.wav")
	end
end

function SWEP:SecondaryAttack()
	if not self:CanAttack() then return end
	self:SetNextFire(CurTime() + 2)

	local need = math.min(100-self.Owner:Armor(),self.ArmorAmount)
	if self.Owner:Armor() < 100 and self:Clip1() >= need then
		self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
		self.Owner:SetAnimation(PLAYER_ATTACK1) --DoAttackEvent()
		self.IdleAnimation = CurTime() + self:SequenceDuration()

		if SERVER then
			local need = math.min(100-self.Owner:Armor(),self.ArmorAmount)
			self:TakePrimaryAmmo(need)
			self.Owner:SetAnimation(PLAYER_ATTACK1)
			self.Owner:SetArmor(math.min(100,self.Owner:Armor()+need))
			self.Owner:EmitSound("items/battery_pickup.wav")
		end
	elseif SERVER then
		self.Owner:EmitSound("items/suitchargeno1.wav")
	end
end

function SWEP:Holster()
	if CLIENT then
		self:Anim_Holster()
	end
	return true
end


function SWEP:OnRemove()
	if not SERVER then return end
	timer.Remove(self.TimerName)
end


function SWEP:CustomAmmoDisplay()
	self.AmmoDisplay = self.AmmoDisplay or {}
	self.AmmoDisplay.Draw = true
	self.AmmoDisplay.PrimaryClip = self:Clip1()

	return self.AmmoDisplay
end

--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_elastic.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_plastic.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_police.lua:
return gluapack()()
--PATH lua/weapons/weapon_extinguisher.lua:
return gluapack()()
--PATH lua/weapons/weapon_extinguisher.lua:

--[[

If you want to override the default extinguishing action, or do something custom when something gets extinguished by this mod, use this hook

hook.Add( "ExtinguisherDoExtinguish", "", function( prop )
	print( prop ) -- The prop that is being extinguished, can be any entity
	return true -- true to prevent default action. Other values or no return will mean do default action.
end )

]]

AddCSLuaFile()
AddCSLuaFile( "effects/rb655_extinguisher_effect.lua" )

if ( SERVER ) then resource.AddWorkshop( "104607228" ) end

SWEP.PrintName = "Extinguisher"
SWEP.Author = "Robotboy655"
SWEP.Category = "Robotboy655's Weapons"
SWEP.Contact = "http://steamcommunity.com/profiles/76561197996891752"
SWEP.Purpose = "To extinguish fire!"
SWEP.Instructions = "Shoot into a fire, to extinguish it. Jump into water to get more ammo!"

SWEP.Slot = 5
SWEP.SlotPos = 35
SWEP.Weight = 1

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = true

SWEP.DrawWeaponInfoBox = false
SWEP.Spawnable = true
SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/c_fire_extinguisher.mdl"
SWEP.ViewModelFOV = 55
SWEP.WorldModel = "models/weapons/w_fire_extinguisher.mdl"
SWEP.HoldType = "slam"

game.AddAmmoType( { name = "rb655_extinguisher" } )
if ( CLIENT ) then language.Add( "rb655_extinguisher_ammo", "Extinguisher Ammo" ) end

SWEP.MaxAmmo = 500

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = SWEP.MaxAmmo
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "rb655_extinguisher"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

function SWEP:SetupDataTables()
	self:NetworkVar( "Float", 0, "NextIdle" )
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:Deploy()
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() )

	self:Idle()

	return true
end

function SWEP:Holster( weapon )
	if ( CLIENT ) then return end

	if ( self.Sound ) then
		self.Sound:Stop()
		self.Sound = nil
	end

	return true
end

function SWEP:OnDrop()
	if ( self.Sound ) then
		self.Sound:Stop()
		self.Sound = nil
	end

	-- Do not give any more extra ammo
	self.Primary.DefaultClip = 0
end

function SWEP:DoEffect( effectscale )

	local effectdata = EffectData()
	effectdata:SetAttachment( 1 )
	effectdata:SetEntity( self.Owner )
	effectdata:SetOrigin( self.Owner:GetShootPos() )
	effectdata:SetNormal( self.Owner:GetAimVector() )
	effectdata:SetScale( effectscale or 1 )
	util.Effect( "rb655_extinguisher_effect", effectdata )

end

function SWEP:DoExtinguish( pushforce, effectscale )

	if ( self:Ammo1() < 1 ) then return end

	if ( CLIENT ) then
		if ( self.Owner == LocalPlayer() ) then self:DoEffect( effectscale ) end -- FIXME
		return
	end

	if ( !self.IsInfinite ) then
		self:TakePrimaryAmmo( 1 )
	end

	effectscale = effectscale or 1
	pushforce = pushforce or 0

	local tr
	if ( self.Owner:IsNPC() ) then
		tr = util.TraceLine( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 16384,
			filter = self.Owner
		} )
	else
		tr = self.Owner:GetEyeTrace()
	end

	local pos = tr.HitPos

	for id, prop in pairs( ents.FindInSphere( pos, 80 ) ) do
		if ( !IsValid( prop ) or prop:GetPos():Distance( self:GetPos() ) > 256 ) then continue end
		if ( prop:IsWeapon() and IsValid( prop:GetOwner() ) ) then continue end -- Played equipped weapons
		if ( prop:GetClass():find( "viewmodel" ) ) then continue end -- View models

		if ( pushforce > 0 ) then
			local physobj = prop:GetPhysicsObject()
			if ( IsValid( physobj ) ) then
				physobj:ApplyForceOffset( self.Owner:GetAimVector() * pushforce, pos )
			end
		end

		-- Perhaps this random call should be replaced by a timer of sorts?
		if ( math.random( 0, 1000 ) > 500 ) then
			local retval = hook.Call( "ExtinguisherDoExtinguish", nil, prop )
			if ( retval == true ) then continue end

			if ( prop:IsOnFire() ) then prop:Extinguish() end

			local class = prop:GetClass()
			if ( string.find( class, "ent_minecraft_torch" ) and prop:GetWorking() ) then
				prop:SetWorking( false )
			elseif ( string.find( class, "env_fire" ) ) then -- Gas Can support. Should work in ravenholm too.
				prop:Fire( "Extinguish" )
			end
		end
	end

	self:DoEffect( effectscale )

end

function SWEP:PrimaryAttack()
	if ( self:GetNextPrimaryFire() > CurTime() ) then return end

	if ( IsFirstTimePredicted() ) then

		self:DoExtinguish( 196, 1 )

		if ( SERVER ) then

			if ( self.Owner:KeyPressed( IN_ATTACK ) or !self.Sound ) then
				self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

				self.Sound = CreateSound( self.Owner, Sound( "weapons/extinguisher/fire1.wav" ) )

				self:Idle()
			end

			if ( self:Ammo1() > 0 and self.Sound ) then self.Sound:Play() end

		end
	end

	self:SetNextPrimaryFire( CurTime() + 0.05 )
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end

function SWEP:PlaySound()
	self:EmitSound( "weapons/extinguisher/release1.wav", 100, math.random( 95, 110 ) )
end

function SWEP:Think()

	if ( self:GetNextIdle() > 0 and CurTime() > self:GetNextIdle() ) then

		self:DoIdleAnimation()
		self:Idle()

	end

	if ( self:GetNextSecondaryFire() > CurTime() or CLIENT ) then return end

	if ( ( self.NextAmmoReplenish or 0 ) < CurTime() and self.Owner:WaterLevel() > 1 ) then
		if ( !self.IsInfinite && self:Ammo1() < self.MaxAmmo * 2 ) then
			self.Owner:SetAmmo( math.min( self:Ammo1() + 25, self.MaxAmmo * 2 ), self:GetPrimaryAmmoType() )
		end
		self.NextAmmoReplenish = CurTime() + 0.1
	end

	if ( self.Sound and self.Sound:IsPlaying() and self:Ammo1() < 1 ) then
		self.Sound:Stop()
		self.Sound = nil
		self:PlaySound()
		self:DoIdleAnimation()
		self:Idle()
	end

	if ( self.Owner:KeyReleased( IN_ATTACK ) or ( !self.Owner:KeyDown( IN_ATTACK ) and self.Sound ) ) then

		self:SendWeaponAnim( ACT_VM_SECONDARYATTACK )

		if ( self.Sound ) then
			self.Sound:Stop()
			self.Sound = nil
			if ( self:Ammo1() > 0 ) then
				self:PlaySound()
				if ( !game.SinglePlayer() ) then self:CallOnClient( "PlaySound", "" ) end
			end
		end

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() )
		self:SetNextSecondaryFire( CurTime() + self:SequenceDuration() )

		self:Idle()

	end
end

function SWEP:DoIdleAnimation()
	if ( self.Owner:KeyDown( IN_ATTACK ) and self:Ammo1() > 0 ) then self:SendWeaponAnim( ACT_VM_IDLE_1 ) return end
	if ( self.Owner:KeyDown( IN_ATTACK ) and self:Ammo1() < 1 ) then self:SendWeaponAnim( ACT_VM_IDLE_EMPTY ) return end
	self:SendWeaponAnim( ACT_VM_IDLE )
end

function SWEP:Idle()

	self:SetNextIdle( CurTime() + self:GetAnimationTime() )

end

function SWEP:GetAnimationTime()
	local time = self:SequenceDuration()
	if ( time == 0 and IsValid( self.Owner ) and !self.Owner:IsNPC() and IsValid( self.Owner:GetViewModel() ) ) then time = self.Owner:GetViewModel():SequenceDuration() end
	return time
end

if ( SERVER ) then return end

SWEP.WepSelectIcon = Material( "icons/rb655_extinguisher_icon.png" )

function SWEP:DrawWeaponSelection( x, y, w, h, a )

	render.PushFilterMag( TEXFILTER.ANISOTROPIC )
	render.PushFilterMin( TEXFILTER.ANISOTROPIC )

	surface.SetDrawColor( 255, 255, 255, a )
	surface.SetMaterial( self.WepSelectIcon )

	local size = math.min( w, h ) - 32
	surface.DrawTexturedRect( x + w / 2 - size / 2, y + h * 0.05, size, size )

	render.PopFilterMag()
	render.PopFilterMin()

end

--PATH lua/weapons/weapon_extinguisher_infinite.lua:
return gluapack()()
--PATH lua/weapons/weapon_grapplehook.lua:
return gluapack()()
--PATH lua/weapons/weapon_hl2axe/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_ar2/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base = "weapon_vj_base"
SWEP.PrintName = "AR2"
SWEP.Author = "DrVrej"
SWEP.Contact = "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose = "This weapon is made for Players and NPCs"
SWEP.Instructions = "Controls are like a regular weapon."
SWEP.Category = "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot = 2 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
SWEP.SlotPos = 4 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.UseHands = true
end
	-- NPC Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.NPC_HasSecondaryFire = true -- Can the weapon have a secondary fire?
SWEP.NPC_SecondaryFireEnt = "obj_vj_combineball"
SWEP.NPC_SecondaryFireDistance = 3000 -- How close does the owner's enemy have to be for it to fire?
SWEP.NPC_SecondaryFireChance = 4 -- Chance that the secondary fire is used | 1 = always
SWEP.NPC_SecondaryFireNext = VJ_Set(15, 20) -- How much time until the secondary fire can be used again?
SWEP.NPC_NextPrimaryFire = 0.9 -- Next time it can use primary fire
SWEP.NPC_TimeUntilFire = 0.1 -- How much time until the bullet/projectile is fired?
SWEP.NPC_TimeUntilFireExtraTimers = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6} -- Extra timers, which will make the gun fire again! | The seconds are counted after the self.NPC_TimeUntilFire!
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel = "models/weapons/c_irifle.mdl"
SWEP.WorldModel = "models/weapons/w_irifle.mdl"
SWEP.HoldType = "ar2"
SWEP.Spawnable = true
SWEP.AdminSpawnable = false
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage = 12 -- Damage
SWEP.Primary.Force = 10 -- Force applied on the object the bullet hits
SWEP.Primary.ClipSize = 30 -- Max amount of bullets per clip
SWEP.Primary.Delay = 0.1 -- Time until it can shoot again
SWEP.Primary.TracerType = "AR2Tracer" -- Tracer type (Examples: AR2, laster, 9mm)
SWEP.Primary.Automatic = true -- Is it automatic?
SWEP.Primary.Ammo = "AR2" -- Ammo type
SWEP.Primary.Sound = {"vj_weapons/hl2_ar2/ar2_single1.wav","vj_weapons/hl2_ar2/ar2_single2.wav","vj_weapons/hl2_ar2/ar2_single3.wav"}
SWEP.Primary.DistantSound = {"^weapons/ar1/ar1_dist1.wav","^weapons/ar1/ar1_dist2.wav"}
SWEP.PrimaryEffects_MuzzleParticles = {"vj_rifle_full_blue"}
SWEP.PrimaryEffects_SpawnShells = false
SWEP.PrimaryEffects_DynamicLightColor = Color(0, 31, 225)
	-- ====== Secondary Fire Variables ====== --
SWEP.Secondary.Ammo = "AR2AltFire" -- Ammo type

SWEP.DryFireSound = {"weapons/ar2/ar2_empty.wav"}
	-- Reload Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.HasReloadSound				= false -- Does it have a reload sound? Remember even if this is set to false, the animation sound will still play!
SWEP.ReloadSound				= "weapons/ar2/ar2_reload.wav"
SWEP.Reload_TimeUntilAmmoIsSet	= 0.8 -- Time until ammo is set to the weapon
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:NPC_SecondaryFire_BeforeTimer(eneEnt, fireTime)
	VJ_EmitSound(self, "weapons/cguard/charging.wav", 70)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:NPC_SecondaryFire()
	local owner = self:GetOwner()
	local pos = self:GetNW2Vector("VJ_CurBulletPos")
	local proj = ents.Create(self.NPC_SecondaryFireEnt)
	proj:SetPos(pos)
	proj:SetAngles(owner:GetAngles())
	proj:SetOwner(owner)
	proj:Spawn()
	proj:Activate()
	local phys = proj:GetPhysicsObject()
	if IsValid(phys) then
		phys:Wake()
		phys:SetVelocity(owner:CalculateProjectile("Line", pos, owner.EnemyData.LastVisiblePos, 2000))
	end

	VJ_CreateSound(self, "weapons/irifle/irifle_fire2.wav", 90)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnSecondaryAttack()
	local owner = self:GetOwner()
	local vm = owner:GetViewModel()
	local fidgetTime = VJ_GetSequenceDuration(vm, ACT_VM_FIDGET)
	local fireTime = VJ_GetSequenceDuration(vm, ACT_VM_SECONDARYATTACK)
	local totalTime = fidgetTime + fireTime
	local curTime = CurTime()
	self:SetNextSecondaryFire(curTime + totalTime)
	self.NextIdleT = curTime + totalTime
	self.NextReloadT = curTime + totalTime
	self:SendWeaponAnim(ACT_VM_FIDGET)
	VJ_CreateSound(self, "weapons/cguard/charging.wav", 85)
	
	timer.Simple(fidgetTime, function()
		if IsValid(self) && IsValid(owner) && owner:GetActiveWeapon() == self then
			VJ_CreateSound(self, "weapons/irifle/irifle_fire2.wav", 90)

			local proj = ents.Create(self.NPC_SecondaryFireEnt)
			proj:SetPos(owner:GetShootPos())
			proj:SetAngles(owner:GetAimVector():Angle())
			proj:SetOwner(owner)
			proj:Spawn()
			proj:Activate()
			local phys = proj:GetPhysicsObject()
			if IsValid(phys) then
				phys:Wake()
				phys:SetVelocity(owner:GetAimVector() * 2000)
			end

			owner:ViewPunch(Angle(-self.Primary.Recoil *3, 0, 0))
			owner:SetAnimation(PLAYER_ATTACK1)
			self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)
			self:TakeSecondaryAmmo(1)
		end
	end)
	return false
end
--PATH lua/weapons/weapon_vj_mp40/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_spas12/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_ssg08/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base = "weapon_vj_base"
SWEP.PrintName = "SSG-08"
SWEP.Author = "DrVrej"
SWEP.Contact = "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose = "This weapon is made for Players and NPCs"
SWEP.Instructions = "Controls are like a regular weapon."
SWEP.Category = "VJ Base"
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ General NPC Variables ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SWEP.NPC_NextPrimaryFire = 2 -- Next time it can use primary fire
SWEP.NPC_TimeUntilFire = 0.5 -- How much time until the bullet/projectile is fired?
SWEP.NPC_CustomSpread = 0.5 -- This is added on top of the custom spread that's set inside the SNPC! | Starting from 1: Closer to 0 = better accuracy, Farther than 1 = worse accuracy
SWEP.NPC_FiringDistanceScale = 2.5 -- Changes how far the NPC can fire | 1 = No change, x < 1 = closer, x > 1 = farther
SWEP.NPC_StandingOnly = true -- If true, the weapon can only be fired if the NPC is standing still
	-- ====== Reload Variables ====== --
SWEP.NPC_ReloadSound = {"vj_weapons/reload_boltaction.wav"} -- Sounds it plays when the base detects the SNPC playing a reload animation
	-- ====== Extra Firing Sound Variables ====== --
SWEP.NPC_ExtraFireSound = {"vj_weapons/perform_boltaction.wav"} -- Plays an extra sound after it fires (Example: Bolt action sound)
SWEP.NPC_ExtraFireSoundTime = 0.4 -- How much time until it plays the sound (After Firing)?
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.MadeForNPCsOnly = true -- Is this weapon meant to be for NPCs only?
SWEP.WorldModel = "models/vj_weapons/w_csgo_scout.mdl"
SWEP.WorldModel_UseCustomPosition = true -- Should the gun use custom position? This can be used to fix guns that are in the crotch
SWEP.WorldModel_CustomPositionAngle = Vector(-8, 90, 180)
SWEP.WorldModel_CustomPositionOrigin = Vector(-4.4, -1, -0.5)
SWEP.HoldType = "ar2"
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage = 80 -- Damage
SWEP.Primary.Force = 1 -- Force applied on the object the bullet hits
SWEP.Primary.ClipSize = 10 -- Max amount of bullets per clip
SWEP.Primary.Ammo = "SniperRound" -- Ammo type
SWEP.Primary.Sound = {"vj_weapons/ssg08/ssg08_fire.wav"}
SWEP.Primary.DistantSound = {"vj_weapons/ssg08/ssg08_fire_dist1.wav","vj_weapons/ssg08/ssg08_fire_dist2.wav","vj_weapons/ssg08/ssg08_fire_dist3.wav","vj_weapons/ssg08/ssg08_fire_dist4.wav"}
--PATH lua/entities/a-wing.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/arc9_gsr_plantable.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/arc9_nade_base.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/arc9_proj_base.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo.lua:
AddCSLuaFile()

ENT.Type                     = "anim"
ENT.Base                     = "base_entity"
ENT.RenderGroup              = RENDERGROUP_TRANSLUCENT

ENT.PrintName                = "Base Ammo"
ENT.Category                 = "ArcCW - Ammo"
ENT.ArcCW_Ammo = true

ENT.Spawnable                = false
ENT.Model                    = "models/items/sniper_round_box.mdl"
ENT.MaxHealth = 40
ENT.Scale = 1

ENT.AmmoType = "SniperPenetratedRound"
ENT.AmmoCount = 5
ENT.DetonationDamage = 10 -- Per-round damage
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/arccw/glock18/glock18-1.wav" -- string or table

ENT.ShellModel = "models/shells/shell_9mm.mdl"
ENT.ShellScale = 1.5

ENT.ResistanceMult = {
    [DMG_BURN] = 3,
    [DMG_DIRECT] = 3, -- This is also fire
    [DMG_BLAST] = 2,
    [DMG_BULLET] = 0.5,
    [DMG_BUCKSHOT] = 0.5,
    [DMG_CLUB] = 0.25,
    [DMG_SLASH] = 0.25,
    [DMG_CRUSH] = 0.25,
    [DMG_NERVEGAS] = 0,
    [DMG_POISON] = 0
}

function ENT:Initialize()
    self:SetModel(self.Model)
    self:SetHealth(math.max(math.ceil(self.MaxHealth * ArcCW.ConVars["mult_ammohealth"]:GetFloat()), 1))
    self.AmmoCount = math.max(math.ceil(self.AmmoCount * ArcCW.ConVars["mult_ammoamount"]:GetFloat(), 1))
    self.MaxAmmoCount = self.AmmoCount

    if engine.ActiveGamemode() == "terrortown" and ArcCW.TTTReplaceTable then
        self.AmmoType = ArcCW.TTTReplaceTable[self.AmmoType] or self.AmmoType
    end

    if self.Scale != 1 then
        self:SetModelScale(self.Scale)
    end

    if self:SkinCount() > 1 and math.random() <= ArcCW.ConVars["ammo_rareskin"]:GetFloat() then
        self:SetSkin(math.random(1, self:SkinCount() - 1))
    end

    if SERVER then

        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
        self:SetUseType(SIMPLE_USE)
        self:PhysWake()

        self:SetTrigger(true) -- Enables Touch() to be called even when not colliding
        if ArcCW.ConVars["ammo_largetrigger"]:GetBool() then
            self:UseTriggerBounds(true, 24)
        end
    end
end

-- Adapted from TTT's ammo - we don't use it otherwise
function ENT:TTT_PlayerCanPickup(ply)
    if ply == self:GetOwner() then return false end

    local result = hook.Call("TTTCanPickupAmmo", nil, ply, self)
    if result then
        return result
    end

    local ent = self
    local phys = ent:GetPhysicsObject()
    local spos = phys:IsValid() and phys:GetPos() or ent:OBBCenter()
    local epos = ply:GetShootPos()

    local tr = util.TraceLine({start = spos, endpos = epos, filter = {ply, ent}, mask = MASK_SOLID})

    -- can pickup if trace was not stopped
    return tr.Fraction == 1.0
end

-- Ditto - unused outside of TTT
function ENT:TTT_CheckForWeapon(ply)
    --[[]
    if !self.CachedWeapons then
        local tbl = {}
        for k,v in pairs(weapons.GetList()) do
            if v and v.Primary.Ammo == self.AmmoType then
                tbl[v.ClassName] = true -- WEPS.GetClass(v)
            end
        end
        self.CachedWeapons = tbl
    end
    ]]

    -- Why does TTT not iterate over the player's weapons? This is obviously faster
    for _, wep in ipairs(ply:GetWeapons()) do
        --if self.CachedWeapons[wep:GetClass()] then return true end
        -- Perform check for overwritten ammo types (attachments) and UBGLs
        if wep.ArcCW and
                (wep:GetBuff_Override("UBGL_Ammo") == self.AmmoType
                or wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo) == self.AmmoType
                or wep:GetBuff_Override("Akimbo_Ammo") == self.AmmoType) then
            return true
        end
    end
    return false
end

function ENT:ApplyAmmo(ply)
    if self.USED then return end
    if engine.ActiveGamemode() == "terrortown" then
        -- Stupid checks mate... but we'll play along unless an override exists
        if !self.IgnoreTTTChecks and !self:TTT_PlayerCanPickup(ply) or !self:TTT_CheckForWeapon(ply) then return end

        local giveCount = math.min(self.AmmoCount, ArcCW.TTTAmmoToClipMax[string.lower(self.AmmoType)] - ply:GetAmmoCount(self.AmmoType))
        if giveCount <= 0 then return end

        self.AmmoCount = self.AmmoCount - giveCount
        ply:GiveAmmo(giveCount, self.AmmoType)

        -- Ugly hack to let client update ammo count
        -- Why not just use NWInts or NetworkVars to begin with? Good question!
        self:SetNWInt("truecount", self.AmmoCount)

        if self.AmmoCount <= 0 then
            self.USED = true
            self:Remove()
        end
    else
        self.USED = true -- Prevent multiple uses
        ply:GiveAmmo(self.AmmoCount, self.AmmoType)
        self:Remove()
    end
end

function ENT:DetonateRound()
    local count = math.Clamp(math.random(1, self.MaxAmmoCount / 5), 1, self.AmmoCount)
    -- Default function
    self:FireBullets({
        Attacker = self.Burner,
        Damage = self.DetonationDamage,
        Force = self.DetonationDamage / 5,
        Num = count,
        AmmoType = self.AmmoType,
        Src = self:WorldSpaceCenter(),
        Dir = self:GetUp(),
        Spread = Vector(math.pi * 2, math.pi * 2, 0),
        IgnoreEntity = self
    })
    self.AmmoCount = self.AmmoCount - count

    self:GetPhysicsObject():AddVelocity(VectorRand() * math.random(30, 50) * self:GetPhysicsObject():GetMass())
    self:GetPhysicsObject():AddAngleVelocity(VectorRand() * math.random(60, 300))

    if self.DetonationSound then
        self:EmitSound(istable(self.DetonationSound) and table.Random(self.DetonationSound) or self.DetonationSound)
    end
end

function ENT:Detonate(wet, attacker)
    if wet then
        self:FireBullets({
            Attacker = attacker,
            Damage = self.DetonationDamage,
            Force = self.DetonationDamage / 5,
            Num = math.max(self.AmmoCount, 50),
            AmmoType = self.AmmoType,
            Src = self:WorldSpaceCenter(),
            Dir = self:GetUp(),
            Spread = Vector(math.pi * 2, math.pi * 2, 0),
            IgnoreEntity = self
        })
    end

    local e = EffectData()
    e:SetOrigin(self:GetPos())
    util.Effect("Explosion", e)

    util.BlastDamage(self, attacker, self:GetPos(), self.DetonationRadius, self.DetonationDamage * (wet and 0.5 or 1))
    self:Remove()
end

if SERVER then

    function ENT:Use(ply)
        if !ply:IsPlayer() then return end
        self:ApplyAmmo(ply)
    end


    function ENT:Touch(ply)
        if !ply:IsPlayer() or !ArcCW.ConVars["ammo_autopickup"]:GetBool() then return end
        self:ApplyAmmo(ply)
    end

    function ENT:Burn(attacker)
        self.Burning = true
        self.Burner = attacker
        self:Ignite(30)
        self:SetHealth(-1)
    end

    function ENT:OnTakeDamage(dmginfo)

        if self:Health() <= 0 or self.USED then return end

        --self:TakePhysicsDamage(dmginfo)
        self:SetHealth(self:Health() - dmginfo:GetDamage())

        if self:Health() <= 0 then

            self.USED = true

            local cvar = ArcCW.ConVars["ammo_detonationmode"]:GetInt()

            if cvar == -1 or (!ArcCW.ConVars["ammo_chaindet"]:GetBool() and dmginfo:GetInflictor().ArcCW_Ammo) or self.DetonationDamage <= 0 then
                -- Go quietly
                local e = EffectData()
                e:SetOrigin(self:GetPos())
                e:SetMagnitude(8)
                e:SetScale(2)
                util.Effect("Sparks", e)
                self:EmitSound("physics/cardboard/cardboard_box_break2.wav", 80, 120)
                self:Remove()
            elseif cvar == 2 and (math.random() <= 0.25 or dmginfo:IsDamageType(DMG_BURN)) then
                -- Fancy ammobox burning
                self:Burn(dmginfo:GetAttacker())
            else
                -- Plain old explosion
                self:Detonate(cvar >= 1, dmginfo:GetAttacker())
            end
        end

    end

    function ENT:Think()
        if self.Burning then

            if self.AmmoCount <= 0 then
                self:Detonate(false, IsValid(self.Burner) and self.Burner or self)
            else
                self:DetonateRound()
            end

            self:NextThink(CurTime() + math.random() * 0.3 + 0.2)
            return true
        end
    end

    -- Do it during the hook so that hit damage numbers show up properly (yes, I am _that_ pedantic)
    hook.Add("EntityTakeDamage", "ArcCW_Ammo", function(ent, dmginfo)
        if ent.ArcCW_Ammo then
            if ArcCW.ConVars["mult_ammohealth"]:GetFloat() < 0 then
                dmginfo:ScaleDamage(0)
            elseif ent.ResistanceMult then
                -- Only apply one multiplier, and prioritize larger ones
                for k, v in SortedPairsByValue(ent.ResistanceMult, true) do if dmginfo:IsDamageType(k) then dmginfo:ScaleDamage(v) break end end
            end
        end
    end)

elseif CLIENT then

    function ENT:DrawTranslucent()
        self:Draw()
    end

    function ENT:Draw()
        self:DrawModel()

        local cvar2d3d = ArcCW.ConVars["2d3d"]:GetInt()
        if cvar2d3d == 0 or (cvar2d3d == 1 and LocalPlayer():GetEyeTrace().Entity != self) then return end

        if (EyePos() - self:GetPos()):LengthSqr() <= 262144 then -- 512^2
            local ang = LocalPlayer():EyeAngles()

            ang:RotateAroundAxis(ang:Forward(), 180)
            ang:RotateAroundAxis(ang:Right(), 90)
            ang:RotateAroundAxis(ang:Up(), 90)

            cam.Start3D2D(self:WorldSpaceCenter() + Vector(0, 0, (self:OBBMaxs().z - self:OBBMins().z) * 0.5 + 8) , ang, 0.1)
                surface.SetFont("ArcCW_32_Unscaled")

                local w = surface.GetTextSize(self.PrintName)

                surface.SetTextPos(-w / 2 + 2, 2)
                surface.SetTextColor(0, 0, 0, 150)
                surface.DrawText(self.PrintName)

                surface.SetTextPos(-w / 2, 0)
                surface.SetTextColor(255, 255, 255, 255)
                surface.DrawText(self.PrintName)

                local ammo = self:GetNWInt("truecount", -1) != -1 and self:GetNWInt("truecount", -1) or self.AmmoCount
                if ammo then
                    w = surface.GetTextSize("×" .. ammo)

                    surface.SetTextColor(0, 0, 0, 150)
                    surface.SetTextPos(-w / 2 + 2, 27)
                    surface.DrawText("×" .. ammo)

                    surface.SetTextColor(255, 255, 255, 255)
                    surface.SetTextPos(-w / 2, 25)
                    surface.DrawText("×" .. ammo)
                end
            cam.End3D2D()
        end
    end

end
--PATH lua/entities/arccw_ammo_ar2.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"
ENT.RenderGroup               = RENDERGROUP_TRANSLUCENT

ENT.PrintName                 = "Rifle Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/rifle_ammo.mdl"

ENT.AmmoType = "ar2"
ENT.AmmoCount = 30

ENT.DetonationDamage = 50
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/ar1/ar1_dist2.wav"
--PATH lua/entities/arccw_ammo_ar2_large.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo_buckshot.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Shotgun Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/shotgun_ammo.mdl"

ENT.AmmoType = "buckshot"
ENT.AmmoCount = 20
if engine.ActiveGamemode() == "terrortown" then
    ENT.AmmoCount = 12
end

ENT.DetonationDamage = 80
ENT.DetonationRadius = 128
ENT.DetonationSound = "weapons/shotgun/shotgun_fire6.wav"
--PATH lua/entities/arccw_ammo_sniper.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/arccw_thr.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Base A Throwable"
ENT.Spawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE
ENT.Model = "models/arccw/masita/grenades/tdunprimed.mdl"

function ENT:CheckLOS(ent, origin)
    origin = origin or self:GetPos()
    if IsValid(self:GetParent()) then origin = self:GetParent():WorldSpaceCenter() end
    if ent == self:GetParent() then return true end
    local pos = ent:WorldSpaceCenter()
    local tr1 = util.TraceLine({
        start = origin,
        endpos = pos,
        filter = {self, self:GetParent()},
        mask = MASK_SHOT
    })
    if tr1.Fraction > 0.99 or tr1.Entity == ent then return true end

    -- only bother with extra traces if it is a player, npc or nextbot
    if not ent:IsPlayer() and not ent:IsNPC() and not ent:IsNextBot() then return false end
    local mins, maxs = ent:WorldSpaceAABB()

    local tr2 = util.TraceLine({
        start = origin,
        endpos = Vector(pos.x, pos.y, maxs.z),
        filter = {self, self:GetParent()},
        mask = MASK_SHOT
    })
    if tr2.Fraction > 0.99 or tr2.Entity == ent then return true end

    local tr3 = util.TraceLine({
        start = origin,
        endpos = Vector(pos.x, pos.y, mins.z),
        filter = {self, self:GetParent()},
        mask = MASK_SHOT
    })
    if tr3.Fraction > 0.99 or tr3.Entity == ent then return true end

    return false
end

function ENT:DrawTranslucent()
    self:DrawModel()
end

function ENT:Draw()
    self:DrawModel()
end
--PATH lua/entities/aura_lvs_9799/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_9799/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_acclamator_mk2/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_arquitens/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "REP | Arquitens"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/salty/repubarquitens-cruiser.mdl"
ENT.AITEAM 					= 2

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/big_canon.wav")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(800,550,760),
	[2] = Vector(800,-550,760),
	[3] = Vector(250,950,380),
	[4] = Vector(250,-950,380),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,5),
	[2] = Angle(0,180,-5),
	[3] = Angle(180,0,0),
	[4] = Angle(180,0,0)
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 800},
	{forward = 1000, right = 0, up = 600},
	{forward = 2000, right = 0, up = 400},
	{forward = 0, right = 2000, up = 400},
	{forward = 0, right = -2000, up = 200},
	{forward = 3000, right = 0, up = 800},
	{forward = -1000, right = 0, up = 600},
	{forward = -2500, right = 0, up = 800},
}
--PATH lua/entities/aura_lvs_cargo2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "NEU (team 0) | Cargo 2"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/props/colonial_movers/c_movers.mdl"
ENT.AITEAM 					= 0

ENT.Mass 					= 700

ENT.HealthVal 				= 50000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/9799_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 0.6
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{

}

ENT.TURRETANGLES = 
{

}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
	{forward = 700, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_cargo7/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "NEU (team 0) | Cargo 7"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/star_wars/the_clone_wars/vehicles/cis_boss_harbinger.mdl"
ENT.AITEAM 					= 0

ENT.Mass 					= 700

ENT.HealthVal 				= 350000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/9799_fire.mp3")

ENT.PRIMARYDAMAGE			= 80
ENT.SHOOTDELAY1 			= 0.6
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(2800,0,1510),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = -1000, right = 0, up = 800},
	{forward = -400, right = -1000, up = 800},
	{forward = -500, right = 1000, up = 800},
	{forward = -700, right = -1000, up = 800},
	{forward = -400, right = 1000, up = 800},
	{forward = -600, right = -1000, up = 600},
	{forward = -100, right = 1000, up = 600},
	{forward = 0, right = -1000, up = 800},
	{forward = 0, right = 1000, up = 800},
	{forward = 100, right = -1000, up = 600},
	{forward = 400, right = 1000, up = 600},
	{forward = 600, right = -1000, up = 400},
	{forward = 800, right = 1000, up = 400},
	{forward = 1000, right = -1000, up = 800},
	{forward = 1200, right = 1000, up = 800},
	{forward = -400, right = 1000, up = 800},
	{forward = -600, right = 1000, up = 800},

}

--PATH lua/entities/aura_lvs_core/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cr90_neu/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_display_panel/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_geo_cruiser/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_geo_cruiser/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Frégate Geo"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/kirillotron/rc ships/tr_ship2.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = -100, right = 800, up = 300}
ENT.SHIPSPAWNANGLE 			= {0,0,180}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_geono"
ENT.SHOOTSOUND				= Sound("weapons/geonosian_canon.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 4
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{
	[1] = Vector(-2500,200,430),
	[2] = Vector(-2500,-200,430),
	[3] = Vector(-1440,240,400),
	[4] = Vector(-1440,-240,400),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(90,-90,180),
	[2] = Angle(90,90,180),
	[3] = Angle(90,-90,180),
	[4] = Angle(90,90,180),
}

ENT.BOMBS = 
{
	{forward = -4000, right = 0, up = 0},
	{forward = -3000, right = 0, up = 300},
	{forward = -2000, right = 0, up = 0},
	{forward = -1000, right = 0, up = 300},
	{forward = 0, right = 0, up = 0},
	{forward = 1000, right = 0, up = 0},
	{forward = 2000, right = 0, up = 0},
	{forward = 3000, right = 0, up = 300},
	{forward = -1000, right = 0, up = 0},
	{forward = -2000, right = 0, up = 400},
	{forward = -3000, right = 0, up = 600},
}
--PATH lua/entities/aura_lvs_gozanti/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_munificent_mk2/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_providence_mk2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Providence"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/salty/providence.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = -2300, right = 2000, up = 1300}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/mega_turbolaser.mp3")

ENT.PRIMARYDAMAGE			= 50
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{
	[1] = Vector(3100,1000,1440),
	[2] = Vector(3100,-980,1440),
	[3] = Vector(-1210,1240,1620),
	[4] = Vector(-1210,-1200,1620),
	[5] = Vector(-4000,1290,1620),
	[6] = Vector(-4000,-1220,1620),
	[7] = Vector(-1000,-0,2850),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(68,-90,180),
	[2] = Angle(68,90,180),
	[3] = Angle(90,-90,190),
	[4] = Angle(90,90,170),
	[5] = Angle(90,-90,170),
	[6] = Angle(90,90,-170),
	[7] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = -6000, right = 0, up = 1800},
	{forward = -6000, right = -1000, up = 1800},
	{forward = -6000, right = 1000, up = 1800},
	{forward = -4000, right = -1000, up = 1800},
	{forward = -4000, right = 1000, up = 1800},
	{forward = -2000, right = -1000, up = 1600},
	{forward = -2000, right = 1000, up = 1600},
	{forward = 0, right = -1000, up = 1800},
	{forward = 0, right = 1000, up = 1800},
	{forward = 2000, right = -1000, up = 1600},
	{forward = 2000, right = 1000, up = 1600},
	{forward = 4000, right = -1000, up = 1400},
	{forward = 4000, right = 1000, up = 1400},
	{forward = 6000, right = -1000, up = 1800},
	{forward = 6000, right = 1000, up = 1800},
	{forward = -4000, right = 1000, up = 1800},
	{forward = -6000, right = 1000, up = 1800},

}
--PATH lua/entities/aura_lvs_recusant/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_venator_mk2/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH addons/[misc] bodygroupr/lua/entities/bodyman_closet/cl_init.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_hydrant/cl_init.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_leak/cl_init.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_rubble/cl_init.lua:
return gluapack()()
--PATH lua/entities/claimboard/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/darkrp_laws/cl_init.lua:
include("shared.lua")

local Laws = {}

ENT.DrawPos = Vector(1, -111, 58)

local color_navy_200 = Color(0, 0, 70, 200)
local color_red = Color(255, 0, 0, 255)
local color_white = color_white

function ENT:Draw()
    self:DrawModel()

    local DrawPos = self:LocalToWorld(self.DrawPos)

    local DrawAngles = self:GetAngles()
    DrawAngles:RotateAroundAxis(self:GetAngles():Forward(), 90)
    DrawAngles:RotateAroundAxis(self:GetAngles():Up(), 90)

    cam.Start3D2D(DrawPos, DrawAngles, 0.4)

        surface.SetDrawColor(0, 0, 0, 255)
        surface.DrawRect(0, 0, 558, 290)

        draw.RoundedBox(4, 0, 0, 558, 30, color_navy_200)

        draw.DrawNonParsedSimpleText(DarkRP.getPhrase("laws_of_the_land"), "Roboto20", 279, 5, color_red, TEXT_ALIGN_CENTER)

        local lastHeight = 0
        for k, v in ipairs(Laws) do
            draw.DrawNonParsedText(string.format("%u. %s", k, v), "Roboto20", 5, 35 + lastHeight, color_white)
            lastHeight = lastHeight + (fn.ReverseArgs(string.gsub(v, "\n", "")) + 1) * 21
        end

    cam.End3D2D()
end

local function addLaw(inLaw)
    local law = DarkRP.textWrap(inLaw, "Roboto20", 522)

    local lawNumber = table.insert(Laws, law)
    hook.Run("addLaw", lawNumber, inLaw)
end

local function umAddLaw(um)
    local law = um:ReadString()
    timer.Simple(0, fn.Curry(addLaw, 2)(law))
end
usermessage.Hook("DRP_AddLaw", umAddLaw)

local function umRemoveLaw(um)
    local i = um:ReadShort()

    local removed = table.remove(Laws, i)
    hook.Run("removeLaw", i, removed)
end
usermessage.Hook("DRP_RemoveLaw", umRemoveLaw)

local function umResetLaws(um)
    Laws = {}
    fn.Foldl(function(val,v) addLaw(v) end, nil, GAMEMODE.Config.DefaultLaws)
    hook.Run("resetLaws")
end
usermessage.Hook("DRP_ResetLaws", umResetLaws)

function DarkRP.getLaws()
    return Laws
end

timer.Simple(0, function()
    fn.Foldl(function(val,v) addLaw(v) end, nil, GAMEMODE.Config.DefaultLaws)
end)

--PATH gamemodes/starwarsrp/entities/entities/drug/shared.lua:
return gluapack()()
--PATH lua/entities/e60r_rocket2/shared.lua:
return gluapack()()
--PATH addons/[tfres] frest_levels/lua/entities/f_leaderboard/cl_init.lua:
include('shared.lua')


fstands = fstands or {}
fstands.lvl = fstands.lvl or {}
fstands.lvl.lb = {}
fstands.lvl.last = fstands.lvl.last or CurTime() - 0.5
if fstands ~= nil and fstands.lvl ~= nil and IsValid(fstands.lvl.Leaderboard) and fstands.lvl.last < CurTime() then
	fstands.lvl.last = CurTime() + 0.5
	fstands.lvl.Leaderboard:Remove()
end
local pending = {}

local me = false

local function asklb(val,m)
	if me == true then return end
	if m == true then
		me = true
		pending = {}
		pending[val] = true
	end
	pending[val] = true
	if !timer.Exists("pend") then 
		timer.Create("pend",1,1,function()
			net.Start("flvllb")
				net.WriteString(util.TableToJSON(pending))
			net.SendToServer()
			pending = {}
		end)
	end
end

function fleaderboard()

	local size = 43

	local frame = vgui.Create("FFrame")
	if !IsValid(frame) then return end
	frame:SetSize(400,500)
	frame:SetPos(0,0)
	frame:DockPadding(10,10,10,10)
	frame.Paint = function(self,w,h)
		draw.RoundedBox(20,0,0,w,h,Color(0,0,0))
	end
	frame:Hide()
	
	local top = vgui.Create("DPanel",frame)
	top:Dock(TOP)
	top.Paint = function(self,w,h)
		draw.RoundedBoxEx(5,0,0,w,h,Color(0,0,0),true,true,false,false)
	end
	
	local ppos = vgui.Create("DLabel",top)
	ppos:Dock(LEFT)
	ppos:SetContentAlignment(5)
	ppos:SetText("Pos")
	ppos:SetFont("CreditsText")
	ppos:SetSize(size,size)
	local pname = vgui.Create("DLabel",top)
	pname:Dock(FILL)
	pname:SetContentAlignment(5)
	pname:SetText("Nazwa Gracza")
	pname:SetFont("CreditsText")
	local plvl = vgui.Create("DLabel",top)
	plvl:Dock(RIGHT)
	plvl:SetSize(size,size)
	plvl:SetText("Level")
	plvl:SetFont("CreditsText")
	plvl:SetContentAlignment(5)
	local bb = vgui.Create("DButton",frame)
	bb:SetSize(frame:GetWide(),frame:GetTall())
	bb:SetText("")
	bb.Paint = nil

	local scr = vgui.Create("DScrollPanel",frame)
	scr:Dock(FILL)
	scr:NoClipping(true)

	scr.VBar.btnUp.Paint = function(self,w,h)
		draw.RoundedBox(5,w/5,0,w/1.5,h,Color(75,75,75))
		draw.SimpleText("▴",nil,w/2.25,h/2,Color(255,255,255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
	end
	scr.VBar.btnDown.Paint = function(self,w,h)
		draw.RoundedBox(5,w/5,0,w/1.5,h,Color(75,75,75))
		draw.SimpleText("▾",nil,w/2.25,h/2,Color(255,255,255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
	end

	scr.VBar.btnGrip.Paint = function(self,w,h)
		draw.RoundedBox(80,0 +w/5,0,w/1.5,h,Color(209,151,44))
	end


	function scr:Scroll(id)
					
		local h = size + 5
		
		y = (id-2) * h
	
		scr.VBar:AnimateTo( y, 2, 0, 0.5 )
	end
	local lead = vgui.Create("DListLayout",scr)
	lead:Dock(FILL)
	local function listw()
		lead:Clear()
		for i = 1, fstands.lvl.much or 1 do
			local pan = vgui.Create("DButton",lead)
			pan:SetText("")
			function pan:DoClick()
				scr:ScrollToChild(self)
			end
			pan:SetSize(lead:GetWide(),size)
			pan.Paint = function(self,w,h)
				draw.RoundedBox(5,0,0,w,h,Color(75,75,75))
			end
			local info

			local pos = vgui.Create("DLabel",pan)
			pos:Dock(LEFT)
			pos:SetText(i)
			pos:SetSize(size,size)
			pos:SetContentAlignment(5)

			local pln = vgui.Create("AvatarImage",pan)
			
			pln:Dock(LEFT)
			pln:SetSize(size,size)
			

			local name = vgui.Create("DLabel",pan)
			name:DockMargin(10,0,0,0,0)
			name:SetText("Loading...")
			name:SetContentAlignment(4)
			name:Dock(FILL)


			local lvl = vgui.Create("DLabel",pan)
			lvl:Dock(RIGHT)
			lvl:SetSize(size,size)
			lvl:SetText("...")



			local np = name.Paint
			name.Think = function(self)
				if self.SteamID == nil then return end
				if frame.localplayer and i == tonumber(frame.localplayer.SteamIDd) then
					pln:SetPlayer(LocalPlayer())
					self.SteamID = steamid
					self:SetText(LocalPlayer():Name())
				end
				if self.SteamID ~= LocalPlayer():SteamID64() and self.lastseen ~= nil and self.lastseen < CurTime() then
					self:SetText("Loading...")
					lvl:SetText("...")
					pln:SetSteamID("",size)
					fstands.lvl.lb[i] = nil
					self.SteamID = nil
					self.lastseen = nil
				end
			end
			name.Paint = function(self)
				self.lastseen = CurTime() + 2
				if (self.SteamID == nil and fstands.lvl.lb[i] ~= nil) then
					local steamid = fstands.lvl.lb[i]["SteamID"]
					
					if frame.localplayer and i == tonumber(frame.localplayer.SteamIDd) then
						pln:SetPlayer(LocalPlayer())
						self.SteamID = steamid
						self:SetText(LocalPlayer():Name())
					end
					if steamid == nil then return end
					lvl:SetText(fstands.lvl.lb[i]["Levels"])
					steamid = util.SteamIDTo64(steamid)
					pln:SetSteamID(steamid,size)
					self.SteamID = steamid
					lvl:SetText(fstands.lvl.lb[i]["Levels"])
				end
				if self:GetText() == "Loading..." and self.SteamID ~= nil then

					steamworks.RequestPlayerInfo( self.SteamID, function( steamName )
						info = steamName
						self:SetText(info)
					end )
					pln:SetSteamID(self.SteamID,size)
				end
				if self.SteamID == nil and fstands.lvl.lb[i] == nil then
					asklb(i)
				end

			end






			local br = vgui.Create("DPanel",lead)
			br:SetSize(lead:GetWide(),5)
			br.Paint = nil

			
			lead:Add( pan )
			lead:Add(br)
			if i > 50 then
			coroutine.wait(0.01)
			end
		end
		coroutine.wait(1)
		timer.Remove("loadlb")
	end
	fstands.lvl.co = coroutine.create( listw )
	coroutine.resume(fstands.lvl.co)
	local BarSize = math.max( scr.VBar:BarScale() * ( scr.VBar:GetTall() - ( scr.VBar:GetWide() * 2 ) ), 10 )
	local Track = scr.VBar:GetTall() - ( scr.VBar:GetWide() * 2 ) - BarSize
		Track = Track + 1
	scr.VBar.long = Track
	
	scr.VBar.Paint = function(self,w,h)
		if coroutine.status(fstands.lvl.co) ~= "suspended" then return end
		local Scroll = self:GetScroll() / self.CanvasSize
		Scroll = Scroll * self.long
		local res = Scroll/Track
		if res > 0.9 then
			coroutine.resume(fstands.lvl.co)
		end
	end

		
	-- MAKE CLOSE BUTTON

	local close = vgui.Create("DButton",frame)
	close:Dock(BOTTOM)
	close:SetSize(frame:GetWide(),ScrH()*0.02)
	close:Hide()
	close:SetText("Close")
	close:SetFont("CreditsText")
	close:SetTextColor(Color(255,255,255))

	local function clearlead()
		local tbl = lead:GetChildren()
		for i=1,#tbl do
			tbl[#tbl+(-i+1)]:Remove()
			coroutine.wait(0.01)
		end
	end


	close.Paint = function(self,w,h)

		draw.RoundedBox(10,0,0,w,h,Color(119,29,29))

	end
	function close:DoClick()
		scr:Scroll(0)
		close:Hide()
		bb:Show()
		frame:SetSize(400,500)
		frame:SetPos(0,0)
		frame.pop = nil
		frame:KillFocus()
		frame:SetMouseInputEnabled(false)
		frame:SetKeyboardInputEnabled(false)
		timer.Create("lbclear",10,1,function()
			local clea = coroutine.create(clearlead)
			ppos.Think = function(self)
				if frame.pop == true then
					fstands.lvl.co = coroutine.create( listw )
					coroutine.resume(fstands.lvl.co)
					self.Think = nil
					lead:PerformLayout()
					scr:PerformLayout()
					return
				end
				if coroutine.status(clea) == "suspended" then
					coroutine.resume(clea)
				elseif coroutine.status(clea) == "dead" then
					fstands.lvl.co = coroutine.create( listw )
					coroutine.resume(fstands.lvl.co)
					self.Think = nil
				end
				lead:PerformLayout()
				scr:PerformLayout()
			end
			
		end)
	end
	function bb:DoClick()
		close:Show()
		bb:Hide()
		frame.pop = true
		frame:SetPaintedManually(false)
		
		frame:MakePopup()
		
		frame:SetSize((ScrH()*400)/1000,(ScrH()*500)/1000)
		frame:Center()
		timer.Remove("lbclear")
	end

	local br = vgui.Create("DPanel",frame)
	br:Dock(BOTTOM)
	br.Paint = nil
	br:SetSize(1,frame:GetTall()*0.02)


	-- DRAW ME!

	local pan = vgui.Create("DButton",frame)
		pan:Dock(BOTTOM)
		pan:SetText("")

		pan:SetSize(lead:GetWide(),size)
		pan.Paint = function(self,w,h)
			draw.RoundedBox(5,0,0,w,h,Color(75,75,75))
		end
		local info

		local pos = vgui.Create("DLabel",pan)
		pos:Dock(LEFT)
		pos:SetText("...")
		pos:SetSize(size,size)
		pos:SetContentAlignment(5)

		local pln = vgui.Create("AvatarImage",pan)
		
		pln:Dock(LEFT)
		pln:SetSize(size,size)
		pln:SetPlayer(LocalPlayer())
		

		local name = vgui.Create("DLabel",pan)
		name:DockMargin(10,0,0,0,0)
		name:SetText(LocalPlayer():Name())
		name:SetContentAlignment(4)
		name:Dock(FILL)
		local id = 100
		function pan:DoClick()
			if name.SteamIDd == nil then return end
			scr:Scroll(name.SteamIDd)
		end
		local lvl = vgui.Create("DLabel",pan)
		lvl:Dock(RIGHT)
		lvl:SetSize(size,size)
		lvl:SetText("...")

		frame.localplayer = name
		name.SteamID = LocalPlayer():SteamID64()
		local np = name.Paint
		name.Paint = function(self)
			self.lastseen = CurTime() + 2
			if self.SteamIDd ~= nil and fstands.lvl.lb[self.SteamIDd] ~= nil and pos:GetText() == "..." then
				local steamid = fstands.lvl.lb[self.SteamIDd]["SteamID"]

				steamid = util.SteamIDTo64(steamid)
				lvl:SetText(fstands.lvl.lb[self.SteamIDd]["Levels"])
				pos:SetText(self.SteamIDd)
				me = false
			end
			if self.SteamIDd == nil then
				asklb(LocalPlayer():SteamID(),true)
			end

		end



		local br = vgui.Create("DPanel",frame)
		br:Dock(BOTTOM)
		br.Paint = nil
		br:SetSize(1,pan:GetTall()*0.2)

	
	
	
	return frame
end

--fstands.lvl.Leaderboard = IsValid(fstands.lvl.Leaderboard) and fstands.lvl.Leaderboard or fleaderboard()

net.Receive("flvllb",function()
	local w = net.ReadBool()
	if w == true then
		fstands.lvl.much = net.ReadFloat()
		if fstands ~= nil and fstands.lvl ~= nil and IsValid(fstands.lvl.Leaderboard) then
			fstands.lvl.Leaderboard:Remove()
		end
	else
		local t = net.ReadString()
		local tbl = util.JSONToTable(t)	
		if tbl[1] ~= nil and istable(tbl[1]) and tbl[1]["RowNum"] ~= nil then
			local ind = tbl[1]["RowNum"]
			ind = tonumber(ind)
			local lvl = tbl[1]["Levels"]
			fstands.lvl.Leaderboard.localplayer.SteamIDd = ind
			fstands.lvl.lb[ind] = {["SteamID"] = LocalPlayer():SteamID(), ["Levels"] = lvl}
			
			return
		end
		fstands.lvl.lb = tbl
	end

end)


function ENT:Initialize()
end

function ENT:Draw()
	fstands.lvl.Leaderboard = IsValid(fstands.lvl.Leaderboard) and fstands.lvl.Leaderboard or fleaderboard()
	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Up(),-90)
	ang:RotateAroundAxis(ang:Forward(),90)
	if fstands.lvl.Leaderboard.pop ~= nil  then return end
	vgui.Start3D2D( self:GetPos() + self:GetRight() * -400 *0.2 + self:GetUp() *500 *0.2,ang,0.2 )
		fstands.lvl.Leaderboard:Show()
		fstands.lvl.Leaderboard:Paint3D2D()
	vgui.End3D2D()
end
--PATH lua/entities/gb_rp_sign/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Spawned Sign"
ENT.Author = "Mac"
ENT.Spawnable = false
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "Text")
	self:NetworkVar("Vector", 0, "TColor")
	self:NetworkVar("Int", 0, "Type")
	self:NetworkVar("Int", 1, "Speed")
	self:NetworkVar("Int", 2, "Wide")
	self:NetworkVar("Int", 3, "On")
	self:NetworkVar("Int", 4, "FX")
end
--PATH gamemodes/starwarsrp/entities/entities/lab_base/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/lab_base/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/letter/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "letter"
ENT.Author = "Pcwizdan"
ENT.Spawnable = false

function ENT:SetupDataTables()
    self:NetworkVar("Entity",1,"owning_ent")
    self:NetworkVar("Entity",2,"signed")
end

DarkRP.declareChatCommand{
    command = "write",
    description = "Write a letter.",
    delay = 5
}

DarkRP.declareChatCommand{
    command = "type",
    description = "Type a letter.",
    delay = 5
}

DarkRP.declareChatCommand{
    command = "removeletters",
    description = "Remove all of your letters.",
    delay = 5
}

--PATH addons/[miecze] moce i hilty/lua/entities/lscs_force_base.lua:
AddCSLuaFile()

ENT.Base = "lscs_holocron_base"
DEFINE_BASECLASS( "lscs_holocron_base" )

ENT.Spawnable		= false
ENT.AdminSpawnable		= false

ENT.BeamMat = Material( "trails/electric" )
ENT.GlowMat = Material( "sprites/light_glow02_add" )
ENT.GlowCol = Color(0,127,255,255)
ENT.GlowCol2 = Color(100,150,200,255)

if SERVER then
	function ENT:Initialize()
		BaseClass.Initialize( self )
		self:PhysicsInitBox( Vector(-11,-11,-11), Vector(11,11,11) )
		self:SetColor( Color(40,40,40,255) )
		self:PlayAnimation("open")
	end
else
	local HaloCount = 0
	local HaloEnts = {}

	function ENT:Think()
		for ID = 1, self:GetBoneCount() do
			self:ManipulateBoneAngles( ID, Angle(math.cos( CurTime() * 6 ),math.sin( CurTime() * 3 ), math.cos( CurTime() * 9 ) ) )
		end
	end

	function ENT:Initialize()
		self.smDist = CurTime() + 1
		table.insert( HaloEnts, self )

		HaloCount = table.Count( HaloEnts )
	end

	function ENT:DrawTranslucent()
		self:DrawModel()

		render.SetMaterial( self.GlowMat )
		render.DrawSprite( self:GetPos(), 64, 64, self.GlowCol )

		local D = math.Clamp(1 - (self.smDist - CurTime()),0,1)
		local Dist = 9 * D

		render.SetMaterial( self.BeamMat )
		
		for Z = -1, 1, 2 do
			for X = -1, 1, 2 do
				for Y = -1, 1, 2 do
					local Center =  self:LocalToWorld( Vector(X,Y,Z) )
					local Corner = self:LocalToWorld( Vector(X * Dist,Y * Dist,Z * Dist) )

					render.DrawBeam( Center, Corner, math.Rand(1,2), math.Rand(-1,0), math.Rand(1,1.5), Color( 255, 255, 255, 255 ) )
				end
			end
		end
	
		render.SetMaterial( self.GlowMat )
	end

	function ENT:Draw()
		self:DrawModel()
	end

	function ENT:OnRemove()
		for id, e in pairs( HaloEnts ) do
			if e == self or not IsValid( e ) then HaloEnts[ id ] = nil end
		end

		HaloCount = table.Count( HaloEnts )
	end

	local haloColor = Color(0,127,255,255)
	hook.Add( "PreDrawHalos", "lscs_holocron_halo", function()
		if HaloCount == 0 then return end

		halo.Add( HaloEnts, haloColor, 1, 1, math.Rand(0.8,1.2) )
	end )
end
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_holocron_base.lua:
AddCSLuaFile()

ENT.Base = "lscs_pickupable"
DEFINE_BASECLASS( "lscs_pickupable" )

ENT.Spawnable		= false
ENT.AdminSpawnable		= false

ENT.PickupSound = "physics/metal/weapon_impact_soft3.wav"
ENT.ImpactHardSound = "Concrete_Block.ImpactHard"
ENT.ImpactSoftSound = "weapon.ImpactSoft"

if SERVER then
	function ENT:Initialize()
		self:SetModel( "models/lscs/holocron.mdl" )
		BaseClass.Initialize( self )
	end
end
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_pickupable.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.DoNotDuplicate = true

ENT.AutomaticFrameAdvance = true

function ENT:SetupDataTables()
end

function ENT:PlayAnimation( animation, playbackrate )
	playbackrate = playbackrate or 1

	local sequence = self:LookupSequence( animation )

	self:ResetSequence( sequence )
	self:SetPlaybackRate( playbackrate )
	self:SetSequence( sequence )
end

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )

		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 15 )
		ent:SetAngles( Angle(90,ply:EyeAngles().y,0) )
		ent.PreventTouch = true
		ent:Spawn()
		ent:Activate()
		ent:PhysWake()

		return ent
	end

	function ENT:Initialize()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )

		self:SetTrigger( true )

		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	function ENT:DoPickup( ply )
		ply:EmitSound( self.PickupSound )
		ply:lscsAddInventory( self )
	end

	function ENT:OnRemove()
	end

	function ENT:Use( ply )
		self:DoPickup( ply )
	end

	function ENT:Think()
		if self.DieTime and self.DieTime < CurTime() then
			self:Remove()
		end
		
		self:NextThink( CurTime() )
		return true
	end

	function ENT:OnTakeDamage( dmginfo )
		self:TakePhysicsDamage( dmginfo )
	end

	function ENT:PhysicsCollide( data, physobj )
		if data.Speed > 60 and data.DeltaTime > 0.2 then
			if data.Speed > 200 then
				self:EmitSound( self.ImpactHardSound )
			else
				self:EmitSound(  self.ImpactSoftSound )
			end
		end
	end

	function ENT:StartTouch( touch_ent )
		if self.PreventTouch then return end

		if not IsValid( touch_ent ) or not touch_ent:IsPlayer() then return end

		self:DoPickup( touch_ent )
	end

	function ENT:EndTouch( touch_ent )
	end

	function ENT:Touch( touch_ent )
	end
else
	function ENT:Initialize()
	end

	function ENT:Think()
	end

	function ENT:OnRemove()
	end

	function ENT:DrawTranslucent()
	end

	function ENT:Draw()
		self:DrawModel()
	end
end
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_stance_base.lua:
return gluapack()()
--PATH lua/entities/lvs_armor.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

ENT.RenderGroup = RENDERGROUP_BOTH 

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Float",0, "HP" )
	self:NetworkVar( "Float",1, "MaxHP" )
	self:NetworkVar( "Float",2, "IgnoreForce" )

	self:NetworkVar( "Vector",0, "Mins" )
	self:NetworkVar( "Vector",1, "Maxs" )

	self:NetworkVar( "Bool",0, "Destroyed" )

	self:NetworkVar( "String",0, "Label" )

	if SERVER then
		self:SetMaxHP( 100 )
		self:SetHP( 100 )
		self:SetLabel( "Armor Plate" )
	end
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
	end

	function ENT:Think()
		return false
	end

	function ENT:OnHealthChanged( dmginfo, old, new )
		if old == new then return end
	end

	function ENT:OnRepaired()
	end

	function ENT:OnDestroyed( dmginfo )
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:TakeTransmittedDamage( dmginfo )
		local Force = dmginfo:GetDamageForce()

		local Damage = dmginfo:GetDamage()
		local DamageForce = Force:Length()
		local IsBlastDamage = dmginfo:IsDamageType( DMG_BLAST )

		local CurHealth = self:GetHP()

		local pos = dmginfo:GetDamagePosition()
		local dir = Force:GetNormalized()

		local base = self:GetBase()

		-- translate force value to armor penetration value is Force * 0.1
		-- mm to inch is * 0.0393701
		-- so correct value is * 0.00393701
		local pLength = DamageForce * 0.00393701

		local TraceData = {
			start = pos - dir * pLength,
			endpos = pos + dir * pLength,
		}

		local trace = util.TraceLine( TraceData )

		-- parent stays the same
		local parent = trace.Entity
		local parentPos = trace.HitPos
		local parentDir = trace.HitNormal

		-- only one extra iteration should be enough ...
		if IsValid( trace.Entity ) and isfunction( trace.Entity.GetBase ) and trace.Entity:GetBase() == base then

			TraceData.filter = trace.Entity

			local FilteredTrace = util.TraceLine( TraceData )

			if FilteredTrace.Hit then
				trace = FilteredTrace
			end

			trace.Entity = base
		end

		local DotHitNormal = math.Clamp( trace.HitNormal:Dot( dir ) ,-1,1) 

		local Armor = self:GetIgnoreForce()
		local ArmorEffective = Armor / math.abs( DotHitNormal )

		if math.abs( DotHitNormal ) > 0.9 then
			ArmorEffective = Armor
		end

		local DisableBounce = false

		local Inflictor = dmginfo:GetInflictor()

		if IsValid( Inflictor ) then
			if Inflictor.DisableBallistics or Inflictor:IsNPC() or Inflictor:IsNextBot() then
				DisableBounce = true
			end
		end

		if DamageForce <= ArmorEffective and not IsBlastDamage then
			local T = CurTime()

			if trace.Entity ~= base then
				self._NextBounce = T + 1

				return false
			end

			local Ax = math.acos( DotHitNormal )
			local HitAngle = 90 - (180 - math.deg( Ax ))

			if HitAngle > 30 then
				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
					effectdata:SetNormal( -dir )
				util.Effect( "manhacksparks", effectdata, true, true )
	
				self._NextBounce = T + 1

				return false
			end

			local NewDir = dir - trace.HitNormal * math.cos( Ax ) * 2

			if (self._NextBounce or 0) > T or DisableBounce then
				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
					effectdata:SetNormal( NewDir:GetNormalized() * 0.25 )
				util.Effect( "manhacksparks", effectdata, true, true )

				return false
			end

			self._NextBounce = T + 1

			local hit_decal = ents.Create( "lvs_armor_bounce" )
			hit_decal:SetPos( trace.HitPos )
			hit_decal:SetAngles( NewDir:Angle() )
			hit_decal:Spawn()
			hit_decal:Activate()
			hit_decal:EmitSound("lvs/armor_rico"..math.random(1,6)..".wav", 95, 100, math.min( dmginfo:GetDamage() / 1000, 1 ) )

			local PhysObj = hit_decal:GetPhysicsObject()
			if not IsValid( PhysObj ) then return false end

			PhysObj:EnableDrag( false )
			PhysObj:SetVelocityInstantaneous( NewDir * 2000 + Vector(0,0,250) )
			PhysObj:SetAngleVelocityInstantaneous( VectorRand() * 250 )

			return false
		end

		local NewHealth = math.Clamp( CurHealth - Damage, 0, self:GetMaxHP() )

		self:OnHealthChanged( dmginfo, CurHealth, NewHealth )
		self:SetHP( NewHealth )

		if NewHealth <= 0 and not self:GetDestroyed() then
			self:SetDestroyed( true )
			self:OnDestroyed( dmginfo )
		end

		local hit_decal = ents.Create( "lvs_armor_penetrate" )
		hit_decal:SetPos( parentPos + parentDir * 0.2 )
		hit_decal:SetAngles( parentDir:Angle() + Angle(90,0,0) )
		hit_decal:Spawn()
		hit_decal:Activate()
		hit_decal:SetParent( parent )

		return true
	end

	return
end

function ENT:Initialize()
end

function ENT:OnRemove()
end

function ENT:Think()
end


function ENT:Draw()
end

local function DrawText( pos, text, col )
	cam.Start2D()
		local data2D = pos:ToScreen()

		if not data2D.visible then cam.End2D() return end

		local font = "TargetIDSmall"

		local x = data2D.x
		local y = data2D.y

		draw.DrawText( text, font, x + 1, y + 1, Color( 0, 0, 0, 120 ), TEXT_ALIGN_CENTER )
		draw.DrawText( text, font, x + 2, y + 2, Color( 0, 0, 0, 50 ), TEXT_ALIGN_CENTER )
		draw.DrawText( text, font, x, y, col or color_white, TEXT_ALIGN_CENTER )
	cam.End2D()
end

local LVS = LVS
local BoxMat = Material("models/wireframe")
local ColorSelect = Color(0,127,255,150)
local ColorNormal = Color(50,50,50,150)
local ColorTransBlack = Color(0,0,0,150)
local OutlineThickness = Vector(0.5,0.5,0.5)
local ColorText = Color(255,0,0,255)

function ENT:DrawTranslucent()
	if not LVS.DeveloperEnabled then return end

	local ply = LocalPlayer()

	if not IsValid( ply ) or ply:InVehicle() or not ply:KeyDown( IN_SPEED ) then return end

	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local HitPos, _, _ = util.IntersectRayWithOBB( ply:GetShootPos(), ply:GetAimVector() * 1000, boxOrigin, boxAngles, boxMins, boxMaxs )

	local InRange = isvector( HitPos )

	local Col = InRange and ColorSelect or ColorNormal

	render.SetColorMaterial()
	render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, Col )
	render.DrawBox( boxOrigin, boxAngles, boxMaxs + OutlineThickness, boxMins - OutlineThickness, ColorTransBlack )

	local boxCenter = (self:LocalToWorld( boxMins ) + self:LocalToWorld( boxMaxs )) * 0.5

	if not InRange then return end

	DrawText( boxCenter, "Armor: "..(self:GetIgnoreForce() / 100).."mm\nHealth:"..self:GetHP().."/"..self:GetMaxHP(), ColorText )
end

--PATH lua/entities/lvs_base/cl_effects.lua:
return gluapack()()
--PATH lua/entities/lvs_base/cl_seatswitcher.lua:
return gluapack()()
--PATH lua/entities/lvs_base_fakehover/cl_init.lua:
include("shared.lua")
include("sh_camera_eyetrace.lua")
include("cl_camera.lua")
include("cl_hud.lua")
--PATH lua/entities/lvs_base_fakehover/cl_camera.lua:
return gluapack()()
--PATH lua/entities/lvs_base_starfighter/cl_flyby.lua:
return gluapack()()
--PATH lua/entities/lvs_dwarfdroid/cl_init.lua:
include("shared.lua")
-- include( "cl_ikfunctions.lua" )
include( "cl_camera.lua" )
-- include( "cl_legs.lua" )
include( "cl_prediction.lua" )
-- include("sh_turret.lua")
-- include("sh_gunner.lua")

-- function ENT:OnRemoved()
-- 	if (self.TurretEnt) then
-- 		if (IsValid(self.TurretEnt)) then
-- 			self.TurretEnt:Remove()
-- 		end
-- 	end
-- end

function ENT:DamageFX()
	-- self.nextDFX = self.nextDFX or 0

	-- if self.nextDFX < CurTime() then
	-- 	self.nextDFX = CurTime() + 0.05

	-- 	if self:GetIsRagdoll() then
	-- 		if math.random(0,45) < 3 then
	-- 			if math.random(1,2) == 1 then
	-- 				local Pos = self:LocalToWorld( Vector(0,0,70) + VectorRand() * 80 )
	-- 				local effectdata = EffectData()
	-- 					effectdata:SetOrigin( Pos )
	-- 				util.Effect( "cball_explode", effectdata, true, true )
					
	-- 				sound.Play( "lvs/vehicles/atte/spark"..math.random(1,4)..".ogg", Pos, 75 )
	-- 			end
	-- 		end
	-- 	end

	-- 	local HP = self:GetHP()
	-- 	local MaxHP = self:GetMaxHP()

	-- 	if HP > MaxHP * 0.5 then return end

	-- 	local effectdata = EffectData()
	-- 		effectdata:SetOrigin( self:LocalToWorld( Vector(0,0,160) ) )
	-- 		effectdata:SetEntity( self )
	-- 	util.Effect( "lvs_engine_blacksmoke", effectdata )

	-- 	if HP <= MaxHP * 0.25 then
	-- 		local effectdata = EffectData()
	-- 			effectdata:SetOrigin( self:LocalToWorld( Vector(0,20,180) ) )
	-- 			effectdata:SetNormal( self:GetUp() )
	-- 			effectdata:SetMagnitude( math.Rand(1,3) )
	-- 			effectdata:SetEntity( self )
	-- 		util.Effect( "lvs_exhaust_fire", effectdata )

	-- 		local effectdata = EffectData()
	-- 			effectdata:SetOrigin( self:LocalToWorld( Vector(0,-20,180) ) )
	-- 			effectdata:SetNormal( self:GetUp() )
	-- 			effectdata:SetMagnitude( math.Rand(1,3) )
	-- 			effectdata:SetEntity( self )
	-- 		util.Effect( "lvs_exhaust_fire", effectdata )
	-- 	end
	-- end
end

function ENT:PreDraw()
	self:DrawTurretDriver()

	return true
end

function ENT:DrawTurretDriver()
	local pod = self:GetDriverSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL and not pod:GetThirdPersonMode()) then return end

	local ID = self:LookupAttachment( "driver" )
	local Att = self:GetAttachment( ID )

	if not Att then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(0,90,0), Att.Pos, Att.Ang )

	ply:SetSequence( "drive_jeep" )
	ply:SetRenderAngles( Ang )
	ply:DrawModel()
end

local lightMat = Material("sprites/light_ignorez")


local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

function ENT:LVSHudPaint( X, Y, ply )
	if self:GetIsCarried() then return end

	-- if ply == self:GetDriver() then
	-- 	local pod = ply:GetVehicle()

	-- 	-- if pod == self:GetTurretSeat() or pod == self:GetGunnerSeat() then
	-- 		self:PaintZoom( X, Y, ply )
	-- 	-- end

	-- 	return
	-- end

	local Pos2D = self:GetEyeTrace().HitPos:ToScreen()

	local _,_, InRange = self:GetMainAimAngles()

	local Col = InRange and white or red

	self:PaintCrosshairCenter( Pos2D, Col )
	self:PaintCrosshairOuter( Pos2D, Col )
	self:LVSPaintHitMarker( Pos2D )

	self:PaintZoom( X, Y, ply )
end

ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local Vel = self:GetVelocity():Length()
	local kmh = math.Round(Vel * 0.09144,0)

	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if self:GetIsCarried() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	else
		local Throttle = Vel / 150
		self:LVSDrawCircle( hX, hY, H * 0.35, math.min( Throttle, 1 ) )
	end
end

--PATH lua/entities/lvs_dwarfdroid/shared.lua:
return gluapack()()
--PATH addons/[tfres] lego vechicles/lua/entities/lvs_eta_advanced_lego/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 220, 150, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineCenter = Material( "vgui/circle" )
ENT.EnginePos = {
	[1] = Vector(-45,20,30),
	[2] = Vector(-45,-20,30),
}

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vwing/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 200, 50 )
	end
end

function ENT:PostDraw()
	if not self:GetEngineActive() then return end

	cam.Start3D2D( self:LocalToWorld( Vector(-50,22.5,31.5) ), self:LocalToWorldAngles( Angle(-90,0,0) ), 0.5 )
		surface.SetDrawColor( self.EngineColor )
		surface.SetMaterial( self.EngineCenter )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
		surface.SetDrawColor( color_white )
		surface.SetMaterial( self.EngineGlow )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
	cam.End3D2D()
	
	cam.Start3D2D( self:LocalToWorld( Vector(-50,-22.5,31.5) ), self:LocalToWorldAngles( Angle(-90,0,0) ), 0.5 )
		surface.SetDrawColor( self.EngineColor )
		surface.SetMaterial( self.EngineCenter )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
		surface.SetDrawColor( color_white )
		surface.SetMaterial( self.EngineGlow )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
	cam.End3D2D()
end

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-160,0.16,9.62), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-160,0.72,-30.29), 0, 20, 2, 1000, 150 )
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 60 + self:GetThrottle() * 60 + self:GetBoost()

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end


--PATH lua/entities/lvs_fakehover_barc_medical/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_iftx/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_iftx/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_fall_missel_base.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Missile"
ENT.Author = "Luna"
ENT.Information = "LVS Missile"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_explosion_small"

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Active" )
	self:NetworkVar( "Entity", 0, "NWTarget" )
end

if SERVER then
	util.AddNetworkString( "lvs_missile_hud" )

	function ENT:FindTarget( pos, forward, cone_ang, cone_len )
		local targets = {
			[1] = player.GetAll(),
			[2] = LVS:GetVehicles(),
			[3] = LVS:GetNPCs(),
		}

		local Attacker = self:GetAttacker()
		local Parent = self:GetParent()
		local Owner = self:GetOwner()
		local Target = NULL
		local DistToTarget = 0

		for _, tbl in ipairs( targets ) do
			for _, ent in pairs( tbl ) do
				if not IsValid( ent ) or ent == Parent or ent == Owner or Target == ent or Attacker == ent then continue end

				local pos_ent = ent:GetPos()
				local dir = (pos_ent - pos):GetNormalized()
				local ang = math.deg( math.acos( math.Clamp( forward:Dot( dir ) ,-1,1) ) )

				if ang > cone_ang then continue end

				local dist, _, _ = util.DistanceToLine( pos, pos + forward * cone_len, pos_ent )

				if not IsValid( Target ) then
					Target = ent
					DistToTarget = dist

					continue
				end

				if dist < DistToTarget then
					Target = ent
					DistToTarget = dist
				end
			end
		end

		self:SetTarget( Target )

		local ply = self:GetAttacker()

		if not IsValid( ply ) or not ply:IsPlayer() then return end

		net.Start( "lvs_missile_hud", true )
			net.WriteEntity( self )
		net.Send( ply )
	end

	function ENT:SetEntityFilter( filter )
		if not istable( filter ) then return end

		self._FilterEnts = {}

		for _, ent in pairs( filter ) do
			self._FilterEnts[ ent ] = true
		end
	end
	function ENT:SetTarget( ent ) self:SetNWTarget( ent ) end
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetThrust( num ) self._thrust = num end
	function ENT:SetSpeed( num ) self._speed = num end
	function ENT:SetTurnSpeed( num ) self._turnspeed = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent ) self._attacker = ent end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 100) end
	function ENT:GetRadius() return (self._radius or 250) end
	function ENT:GetSpeed() return (self._speed or 4000) end
	function ENT:GetTurnSpeed() return (self._turnspeed or 1) * 100 end
	function ENT:GetThrust() return (self._thrust or 500) end
	function ENT:GetTarget()
		if IsValid( self:GetNWTarget() ) then
			local Pos = self:GetPos()
			local tPos = self:GetTargetPos()

			local Sub = tPos - Pos
			local Len = Sub:Length()
			local Dir = Sub:GetNormalized()
			local Forward = self:GetForward()

			local AngToTarget = math.deg( math.acos( math.Clamp( Forward:Dot( Dir ) ,-1,1) ) )

			local LooseAng = math.min( Len / 100, 90 )

			if AngToTarget > LooseAng then
				self:SetNWTarget( NULL )
			end
		end

		return self:GetNWTarget()
	end
	function ENT:GetTargetPos()
		local Target = self:GetNWTarget()

		if not IsValid( Target ) then return Vector(0,0,0) end

		if isfunction( Target.GetShield ) then
			if Target:GetShield() > 0 then
				return Target:LocalToWorld( VectorRand() * math.random( -1000, 1000 ) )
			end
		end

		if isfunction( Target.GetMissileOffset ) then
			return Target:LocalToWorld( Target:GetMissileOffset() )
		end

		return Target:GetPos()
	end

	function ENT:SpawnFunction( ply, tr, ClassName )

		local ent = ents.Create( ClassName )
		ent:SetPos( ply:GetShootPos() )
		ent:SetAngles( ply:EyeAngles() )
		ent:Spawn()
		ent:Activate()
		ent:SetAttacker( ply )
		ent:Enable()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/weapons/w_missile_launch.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		local Parent = self:GetParent()

		if IsValid( Parent ) then
			self:SetOwner( Parent )
			self:SetParent( NULL )
		end

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		self:PhysWake()

		self.IsEnabled = true

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Missile terminated.")

			return
		end

		pObj:SetMass( 100 ) 
		pObj:EnableGravity( true ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( true )
		pObj:SetVelocity(self:GetForward() * 3000) -- This can replaces PhysicsSimulate to make the projectiles drop

		self:SetTrigger( true )

		self:StartMotionController()

		self:PhysWake()

		self.SpawnTime = CurTime()

		self:SetActive( true )
	end

	-- Not needed, cause I just need Velocity
/*
	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local Thrust = self:GetThrust()
		local Speed = self:GetSpeed()
		local Pos = self:GetPos()
		local velL = self:WorldToLocal( Pos + self:GetVelocity() )

		local ForceLinear = (Vector( Speed * Thrust,0,0) - velL) * deltatime
		
		local Target = self:GetTarget()

		if not IsValid( Target ) then
			return (-phys:GetAngleVelocity()/10 * deltatime), ForceLinear, SIM_LOCAL_ACCELERATION
		end
		

		local AngForce = -self:WorldToLocalAngles( (self:GetTargetPos() - Pos):Angle() )

		local ForceAngle = (Vector(AngForce.r,-AngForce.p,-AngForce.y) * self:GetTurnSpeed() - phys:GetAngleVelocity() * 5 ) * 250 * deltatime

		return ForceAngle, ForceLinear, SIM_LOCAL_ACCELERATION
	end
*/
	function ENT:Think()	
		local T = CurTime()

		self:NextThink( T + 1 )

		if not self.SpawnTime then return true end

		if (self.SpawnTime + 12) < T then
			self:Detonate()
		end

		return true
	end

	ENT.IgnoreCollisionGroup = {
		[COLLISION_GROUP_NONE] = true,
		[COLLISION_GROUP_WORLD] =  true,
	}

	function ENT:StartTouch( entity )
		if entity == self:GetAttacker() then return end

		if istable( self._FilterEnts ) and self._FilterEnts[ entity ] then return end

		if entity.GetCollisionGroup and self.IgnoreCollisionGroup[ entity:GetCollisionGroup() ] then return end

		self:Detonate( entity )
	end

	function ENT:EndTouch( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:PhysicsCollide( data )
		if istable( self._FilterEnts ) and self._FilterEnts[ data.HitEntity ] then return end

		self:Detonate()
	end

	function ENT:OnTakeDamage( dmginfo )	
	end

	function ENT:Detonate( target )
		if not self.IsEnabled or self.IsDetonated then return end

		self.IsDetonated = true

		local Pos =  self:GetPos() 

		local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
		util.Effect( self.ExplosionEffect, effectdata )

		if IsValid( target ) and not target:IsNPC() then
			Pos = target:GetPos() -- place explosion inside the hit targets location so they receive full damage. This fixes all the garbage code the LFS' missile required in order to deliver its damage
		end

		local attacker = self:GetAttacker()

		util.BlastDamage( self, IsValid( attacker ) and attacker or game.GetWorld(), Pos, self:GetRadius(), self:GetDamage() )

		SafeRemoveEntityDelayed( self, FrameTime() )
	end
else
	function ENT:Initialize()	
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		self.IsEnabled = true

		self.snd = CreateSound(self, "weapons/rpg/rocket1.wav")
		self.snd:SetSoundLevel( 80 )
		self.snd:Play()

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( self )
		util.Effect( "lvs_missiletrail", effectdata )
	end

	function ENT:CalcDoppler()
		local Ent = LocalPlayer()

		local ViewEnt = Ent:GetViewEntity()

		if Ent:lvsGetVehicle() == self then
			if ViewEnt == Ent then
				Ent = self
			else
				Ent = ViewEnt
			end
		else
			Ent = ViewEnt
		end

		local sVel = self:GetVelocity()
		local oVel = Ent:GetVelocity()

		local SubVel = oVel - sVel
		local SubPos = self:GetPos() - Ent:GetPos()

		local DirPos = SubPos:GetNormalized()
		local DirVel = SubVel:GetNormalized()

		local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

		return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
	end

	function ENT:Draw()
		if not self:GetActive() then return end

		self:DrawModel()
	end

	function ENT:Think()
		if self.snd then
			self.snd:ChangePitch( 100 * self:CalcDoppler() )
		end

		if self.IsEnabled then return end

		if self:GetActive() then
			self:Enable()
		end
	end

	function ENT:SoundStop()
		if self.snd then
			self.snd:Stop()
		end
	end

	function ENT:OnRemove()
		self:SoundStop()
	end

	local function DrawDiamond( X, Y, radius, angoffset )
		angoffset = angoffset or 0

		local segmentdist = 90
		local radius2 = radius + 1

		for ang = 0, 360, segmentdist do
			local a = ang + angoffset
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius, Y - math.sin( math.rad( a ) ) * radius, X + math.cos( math.rad( a + segmentdist ) ) * radius, Y - math.sin( math.rad( a + segmentdist ) ) * radius )
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius2, Y - math.sin( math.rad( a ) ) * radius2, X + math.cos( math.rad( a + segmentdist ) ) * radius2, Y - math.sin( math.rad( a + segmentdist ) ) * radius2 )
		end
	end

	local color_red = Color(255,0,0,255)
	local HudTargets = {}
	hook.Add( "HUDPaint", "!!!!lvs_missile_hud", function()
		local T = CurTime()

		local Index = 0

		surface.SetDrawColor( 255, 0, 0, 255 )

		for ID, _ in pairs( HudTargets ) do
			local Missile = Entity( ID )

			if not IsValid( Missile ) then
				HudTargets[ ID ] = nil

				continue
			end

			local Target = Missile:GetNWTarget()

			if not IsValid( Target ) then
				HudTargets[ ID ] = nil

				continue
			end

			local MissilePos = Missile:GetPos():ToScreen()
			local TargetPos = Target:LocalToWorld( Target:OBBCenter() ):ToScreen()

			Index =  Index + 1

			if not TargetPos.visible then continue end

			DrawDiamond( TargetPos.x, TargetPos.y, 40, ID * 1337 - T * 100 )

			if isfunction( Target.GetShield ) and Target:GetShield() > 0 then
				draw.DrawText("WEAK LOCK", "LVS_FONT", TargetPos.x + 20, TargetPos.y + 20, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			else
				draw.DrawText(" FULL LOCK", "LVS_FONT", TargetPos.x + 20, TargetPos.y + 20, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			end

			if not MissilePos.visible then continue end

			DrawDiamond( MissilePos.x, MissilePos.y, 16, ID * 1337 - T * 100 )
			draw.DrawText( Index, "LVS_FONT", MissilePos.x + 10, MissilePos.y + 10, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		
			surface.DrawLine( MissilePos.x, MissilePos.y, TargetPos.x, TargetPos.y )
		end
	end )

	net.Receive( "lvs_missile_hud", function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) then return end

		HudTargets[ ent:EntIndex() ] = true
	end )
end
--PATH lua/entities/lvs_fall_missel_cis.lua:
return gluapack()()
--PATH lua/entities/lvs_gunship_hmp/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-306.32,-529.84,149.92), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-306.32,529.84,149.92), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-314.74,-474.83,234.39), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-314.74,474.83,234.39), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineFXColor = Color(255, 192, 0)
ENT.EngineFxPos = {
	--left
	Vector(-593,311.06,238.35),
	Vector(-597.54,305.85,238.09),
	Vector(-601.49,300.42,237.94),
	Vector(-607.29,295.7,238.21),
	Vector(-610.4,289.49,238.15),
	Vector(-614.91,284.03,238.38),
	Vector(-618.13,277.97,238.14),
	Vector(-622.7,272.94,238.44),
	Vector(-627.85,267.1,238.71),
	Vector(-631.05,261.81,238.38),
	Vector(-634.33,255.62,238.26),
	Vector(-637.66,249.51,238.26),
	Vector(-643.17,244.69,238.61),
	Vector(-646.48,237.98,238.58),
	Vector(-649.64,231.77,238.5),
	Vector(-652.27,225.64,238.41),
	Vector(-657.42,220.29,238.79),
	Vector(-659.51,213.81,238.67),
	Vector(-662.24,207.18,238.74),
	Vector(-664.73,200.6,238.56),
	Vector(-669.11,194.78,238.86),
	Vector(-671.12,188.14,238.84),
	Vector(-675.44,182.48,239.09),
	Vector(-677.48,175.8,239.05),
	Vector(-679.69,169.06,238.96),
	Vector(-681.83,162.54,238.87),
	Vector(-683.76,155.7,238.88),
	Vector(-687.69,149.68,239.16),
	Vector(-689.48,142.85,239.12),
	Vector(-691.1,136.2,239.11),
	Vector(-692.81,129.32,239.17),
	Vector(-694.47,122.47,239.13),
	Vector(-695.87,115.78,239.2),
	Vector(-697.42,108.81,239.11),
	Vector(-700.06,102.45,239.34),
	Vector(-701.45,95.67,239.25),
	Vector(-702.79,88.5,239.17),
	Vector(-703.67,81.94,239.08),
	Vector(-704.7,74.91,239.38),
	Vector(-622.7,272.94,238.44),
	--right
	Vector(-593,-311.06,238.35),
	Vector(-597.54,-305.85,238.09),
	Vector(-601.49,-300.42,237.94),
	Vector(-607.29,-295.7,238.21),
	Vector(-610.4,-289.49,238.15),
	Vector(-614.91,-284.03,238.38),
	Vector(-618.13,-277.97,238.14),
	Vector(-622.7,-272.94,238.44),
	Vector(-627.85,-267.1,238.71),
	Vector(-631.05,-261.81,238.38),
	Vector(-634.33,-255.62,238.26),
	Vector(-637.66,-249.51,238.26),
	Vector(-643.17,-244.69,238.61),
	Vector(-646.48,-237.98,238.58),
	Vector(-649.64,-231.77,238.5),
	Vector(-652.27,-225.64,238.41),
	Vector(-657.42,-220.29,238.79),
	Vector(-659.51,-213.81,238.67),
	Vector(-662.24,-207.18,238.74),
	Vector(-664.73,-200.6,238.56),
	Vector(-669.11,-194.78,238.86),
	Vector(-671.12,-188.14,238.84),
	Vector(-675.44,-182.48,239.09),
	Vector(-677.48,-175.8,239.05),
	Vector(-679.69,-169.06,238.96),
	Vector(-681.83,-62.54,238.87),
	Vector(-683.76,-155.7,238.88),
	Vector(-687.69,-149.68,239.16),
	Vector(-689.48,-142.85,239.12),
	Vector(-691.1,-136.2,239.11),
	Vector(-692.81,-129.32,239.17),
	Vector(-694.47,-122.47,239.13),
	Vector(-695.87,-115.78,239.2),
	Vector(-697.42,-108.81,239.11),
	Vector(-700.06,-102.45,239.34),
	Vector(-701.45,-95.67,239.25),
	Vector(-702.79,-88.5,239.17),
	Vector(-703.67,-81.94,239.08),
	Vector(-704.7,-74.91,239.38),
	Vector(-622.7,-272.94,238.44),
	Vector(-681.36,-159.23,238.58),

}

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 25 + self:GetThrottle() * 90 + self:GetBoost() * 0.9

	render.SetMaterial( self.EngineGlow )

	for _, v in pairs( self.EngineFxPos ) do
		local pos = self:LocalToWorld( v )
		render.DrawSprite( pos, Size, Size, self.EngineFXColor )

	end
end


function ENT:OnStartBoost()
	self:EmitSound( "hmp/throttlepunch_6.mp3", 85 )
end


--PATH lua/entities/lvs_repulsorlift_gunship/cl_init.lua:
include("shared.lua")
include( "sh_mainweapons.lua" )
include( "sh_ballturret_left.lua" )
include( "sh_ballturret_right.lua" )
include( "sh_wingturret.lua" )
include( "cl_drawing.lua" )
include( "cl_prediction.lua" )
include( "cl_lights.lua" )

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
	self:AnimRearHatch()
	self:AnimLights()
	self:WingTurretProjector()
	self:BTLProjector()
	self:BTRProjector()
	self:PredictPoseParamaters()
end

function ENT:BTRProjector()
	local Fire = self:GetBTRFire()
	if Fire == self.OldFireBTR then return end

	self.OldFireBTR = Fire

	if Fire then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_right_projector", effectdata )
	end
end
	
function ENT:BTLProjector()
	local Fire = self:GetBTLFire()

	if Fire == self.OldFireBTL then return end

	self.OldFireBTL = Fire
	
	if Fire then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_left_projector", effectdata )
	end
end

function ENT:WingTurretProjector()
	local FireWingTurret = self:GetWingTurretFire()

	if FireWingTurret == self.OldWingTurretFire then return end

	self.OldWingTurretFire = FireWingTurret

	if FireWingTurret then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_wing_projector", effectdata )
	end
end

function ENT:AnimRearHatch()
	local Tval = self:GetRearHatch() and 32 or 0
	local Rate = 50 * RealFrameTime()
	
	self.smRH = self.smRH and self.smRH + math.Clamp(Tval - self.smRH,-Rate,Rate) or 0

	if not self.HatchID then
		self.HatchID = self:LookupBone( "hatch" ) 
	else
		self:ManipulateBoneAngles( self.HatchID, Angle(0,-self.smRH,0) )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "^lvs/vehicles/laat/boost_"..math.random(1,2)..".wav", 85 )
end

function ENT:OnStopBoost()
end

--PATH lua/entities/lvs_repulsorlift_gunship/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/i"
ENT.Author = "Luna"
ENT.Information = "Gunship/Troop Transport of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Gunships"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/laat.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2400
ENT.MaxThrust = 2400

ENT.MaxPitch = 60

ENT.ThrustVtol = 50
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 4000

ENT.AutomaticFrameAdvance = true

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "BTPodL" )
	self:AddDT( "Entity", "BTPodR" )

	self:AddDT( "Bool", "RearHatch" )

	self:AddDT( "Int", "DoorMode" )

	self:AddDT( "Bool", "WingTurretFire" )
	self:AddDT( "Vector", "WingTurretTarget" )

	self:AddDT( "Bool", "BTLFire" )
	self:AddDT( "Bool", "BTRFire" )

	self:AddDT( "Bool", "LightsActive" )
end

function ENT:InitWeapons()
	self:InitWeaponDriver()
	self:InitWeaponGunner()
	self:InitWeaponBTL()
	self:InitWeaponBTR()
end

sound.Add( {
	name = "LVS.LAAT.FLYBY",
	sound = {
		"lvs/vehicles/laat/flyby1.wav",
		"lvs/vehicles/laat/flyby2.wav",
		"lvs/vehicles/laat/flyby3.wav",
		"lvs/vehicles/laat/flyby4.wav",
		"lvs/vehicles/laat/flyby5.wav",
	}
} )

ENT.FlyByAdvance = 1
ENT.FlyBySound = "LVS.LAAT.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/laat/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/laat/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 110,
	},
}

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	if ply.m_bWasNoclipping then 
		ply.m_bWasNoclipping = nil 
		ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 

		if CLIENT then 
			ply:SetIK( true )
		end 
	end 

	if Pod == self:GetBTPodL() or Pod == self:GetBTPodR() then
		ply.CalcIdeal = ACT_STAND
		ply.CalcSeqOverride = ply:LookupSequence( "drive_jeep" )

		return ply.CalcIdeal, ply.CalcSeqOverride
	end

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end
--PATH lua/entities/lvs_repulsorlift_gunship/sh_ballturret_right.lua:
return gluapack()()
--PATH lua/entities/lvs_space_laat_arc/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT-I Muunilinst 10"
ENT.Author = "Dec"
ENT.Information = "ARC version of the LAAT"
ENT.Category = "[LVS] SW-Vehicles"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/fisher/laat/laatspacem10.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.DamageSounds = {
	"physics/metal/metal_sheet_impact_bullet2.wav",
	"physics/metal/metal_sheet_impact_hard2.wav",
	"physics/metal/metal_sheet_impact_hard6.wav",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2850
ENT.MaxThrust = 2850

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 6500
ENT.MaxShield = 0

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "WingTurretFire" )
	self:AddDT( "Vector", "WingTurretTarget" )
	self:NetworkVar( "Int", 23, "LampMode" )
	self:AddDT( "Float", "Activetime" )
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "SecondGunnerSeat" )
	self:NetworkVar( "Bool", 24, "SpotlightOn" )
	self:AddDT( "Bool", "SpotlightToggle" )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "laat_bf2/laat_takeoff.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end

ENT.EngineSounds = {
	{
		sound = "laat_bf2/engine_loop.mp3",
		Pitch = 90,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 85,
	},
	{
		sound = "laat_bf2/laat_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 75,
	},
}

sound.Add( {
	name = "LAAT_FIREMISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "laat_bf2/rocket_shot.mp3"
} )


function ENT:SetNextRearGunFire( delay )
	self._NextRGFire = CurTime() + delay
end

function ENT:CanFireRearGun()
	return (self._NextRGFire or 0) < CurTime()
end

function ENT:GetRearGunInRange( ent )
	return ent:AngleBetweenNormal( ent:GetAimVector(), -ent:GetForward() ) < 35
end

function ENT:HandleRearGun( ent, ShouldFire )

	local trace = ent:GetEyeTrace()

	local Pos,Ang = WorldToLocal( Vector(100,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

	if not self:GetRearGunInRange( ent ) then 
		self:SetPoseParameter("back_turret_y", 0 )

		return false
	end

	self:SetPoseParameter("back_turret_z", Ang.p )
	self:SetPoseParameter("back_turret_y", -Ang.y )

	if not ShouldFire or not self:CanFireRearGun() then self:GetRearGunInRange( ent ) return end

	local startpos = self:GetBonePosition(self:LookupBone("Rear_Gun_End"))

	self:SetNextRearGunFire( 0.2 )

	local bullet = {}
	bullet.Src 	= ent:LocalToWorld( Vector(-500,0 ,-20) )
	bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
	bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
	bullet.TracerName = "lvs_laser_blue_short"
	bullet.Force	= 10
	bullet.HullSize 	= 25
	bullet.Damage	= 65
	bullet.Velocity = 20000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_impact", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local NewHeat = ent:GetHeat() + 0.2


	ent:SetHeat( NewHeat )
	if NewHeat >= 1 then
		ent:SetOverheated( true )
	end

	if not IsValid( self.SNDTail ) then return end

	self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(100,0,103) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:InitWeapons()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	local MaxRange = 60
	local MaxTailRange = 35

	self.lor = 1

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.18
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= 20 then return true end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = ent:GetEyeTrace()

		local bullet = {}
		bullet.Spread 	= Vector( 0.02,  0.02, 0.02 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 60
		bullet.SplashDamage = 200
		bullet.SplashDamageRadius = 200
		bullet.Velocity = 28000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
	
		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(320,32 * i,37) )
			bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
				
			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local trace = ent:GetEyeTrace()

		local AimAngles = ent:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld(  Vector(256,0,36) ) ):GetNormalized():Angle() )

		ent.frontgunYaw = -AimAngles.y

		if math.abs( ent.frontgunYaw ) > 100 then
			ent:SetPoseParameter("Front_Turret_Z", 0 )
			ent:SetPoseParameter("Front_Turret_Y", 0 )

			return
		end

		ent:SetPoseParameter("Front_Turret_Z", AimAngles.p )
		ent:SetPoseParameter("Front_Turret_Y", -AimAngles.y )
	end
	self:AddWeapon( weapon )

	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.4
	weapon.HeatRateDown = 0
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.StartAttack = function( ent )
		ent.ShouldFire = true
	end
	weapon.FinishAttack = function( ent )
		ent.ShouldFire = false

		local base = ent:GetVehicle()

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		for _, sound in pairs( snd ) do
			if not IsValid( sound ) then continue end

			sound:Stop()
		end
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		local ShouldFire = (ent.ShouldFire == true) and ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) < MaxRange
	
		if base:HandleRearGun( ent, ent.ShouldFire ) then
			ShouldFire = false
		end

		if base:SetWingTurretFire() ~= ShouldFire then
			base:SetWingTurretFire( ShouldFire ) 
		end

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		if ent._oldShouldFire ~= ShouldFire then
			ent._oldShouldFire = ShouldFire
			if ShouldFire then
				for _, sound in pairs( snd ) do
					if not IsValid( sound ) then continue end

					sound:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
				end
			end
		end

		if not ShouldFire then
			for _, sound in pairs( snd ) do
				if not IsValid( sound ) then continue end
				sound:Stop()
			end

			ent:SetHeat( ent:GetHeat() - FrameTime() )

			return
		end
	
		if not active then
			return
		end

		local trace = ent:GetEyeTrace()
		local DesEndPos = trace.HitPos

		base:SetWingTurretTarget( DesEndPos )

		if not base:GetWingTurretFire() then return end
		
		local DesStartPos --= Vector(-55, 350, 90)

		if base:WorldToLocal( DesEndPos ).z < 0 then
			DesStartPos = Vector(-55, 350, 90)
		else
			DesStartPos = Vector(-55, 370, 125)
		end

		local NewHeat = ent:GetHeat()

		for i = -1,1,2 do
			local StartPos = self:LocalToWorld( DesStartPos * Vector(1,i,1)  )
			local beam = util.TraceLine( { start = StartPos, endpos = DesEndPos} )

			self:BallturretDamage( beam.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - StartPos):GetNormalized() )

			if not IsValid( snd[i] ) then continue end

			if beam.Entity ~= base then
				snd[i]:Play()
				NewHeat = NewHeat + FrameTime() * 0.25
			else
				snd[i]:Stop()
			end
		end

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = base:LocalToWorld( base:OBBCenter() ) + clamped_angles :Up() * (350 + radius * pod:GetCameraHeight())
		local EndPos = StartPos - clamped_angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS
				
				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 10
	weapon.Delay = 0 
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )

		local T = CurTime()
		local pos = 0
		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if self.lor == 1 then
			pos = Vector(-63.81,-263.11,132.86)
			self.lor = 2
		else
			pos = Vector(-65.8,271.86,131.86)
			self.lor = 1
		end

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( self:LocalToWorld( pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetDamage( 1250 )
		projectile:SetRadius( 350 )
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.2 )
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 40
	weapon.Delay = 2
	weapon.HeatRateUp = 1 
	weapon.HeatRateDown = 0.08
	weapon.Attack = function( ent )


		--if not ent:WeaponsInRange() then return true end
		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 100 then return true end

		for i = 1, 2 do
			timer.Simple( (i / 7) * 0.1, function()
				if not IsValid( ent ) then return end


				if self.lor == 1 then
					pos = Vector(99.71,69.93,276.31)
					self.lor = 2
				else
					pos = Vector(88.08,-69.92,276.24)
					self.lor = 1
				end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()

				local trace = ent:GetEyeTrace()
				local Start = pos
				local Dir = (ent:GetEyeTrace().HitPos - veh:LocalToWorld(Start)):GetNormalized()
				local projectile = ents.Create( "lvs_protontorpedo" )
				projectile:SetPos(veh:LocalToWorld(Start))
				projectile:SetAngles( ent:GetAngles() )
				projectile:SetParent( )
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-5,5) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:SetDamage( 1250 )
				projectile:SetRadius( 550 )
				projectile:Enable()
				projectile:EmitSound("LAAT_FIREMISSILE" )
			end)
			self.RocketsModel:ResetSequence("Load_Missile")

		end
	end
	weapon.FinishAttack = function( ent )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()
	
		if not IsValid( base ) then return end
	
		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )
	
		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE
	
		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 
	
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon, 2 )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/bomb.png")
	weapon.Ammo = 15
	weapon.Delay = 0.5 
	weapon.HeatRateUp = 0.5 
	weapon.HeatRateDown = .1
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.Attack = function( ent )
		local Pos 	= self:GetPos() + Vector(0,  0, -50 )
		
		local laatbomb = ents.Create( "laat_detonator" )
		laatbomb:SetPos(Pos)
		laatbomb:SetAngles( ent:GetAngles() )
		laatbomb:SetParent()
		laatbomb:Spawn()
		laatbomb:Activate()
	
		
		
		
		ent:TakeAmmo()
	end
	weapon.OnThink = function( ent, active )
	end

	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if (self.gateDown) then
			self.gateDown = false
			self:SetBodygroup(7, 0)
		else
			self:SetBodygroup(7, 1)
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if (self.gateDown) then
			self.gateDown = false
			self:SetSpotlightOn(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetSpotlightOn(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.3
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		self:ToggleHatch()
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_grabber.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		if (self.gateDown) then
			self.gateDown = false
			self:DropHeldEntity()
		else
			self:GrabEntity()
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.3
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		self:DoorOC()
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetSpotlightToggle() == true then
			self:SetSpotlightToggle(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetSpotlightToggle(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

function ENT:IsSpotlightMounted()
	return self:GetBodygroup(7) == 1
end

--PATH addons/[tfres] lego vechicles/lua/entities/lvs_space_laat_lego/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_droidtrifighter/cl_init.lua:
include("shared.lua")

ENT.EngineFXPos = {
	Vector(-104.75,0,31.59),
	Vector(-104.75,-27.74,-15.54),
	Vector(-104.75,27.74,-15.54),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-120,0,31.59), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-120,-27.74,-15.54), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-120,27.74,-15.54), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 40 + self:GetBoost() * 0.8

	render.SetMaterial( self.EngineGlow )
	render.DrawSprite( self:LocalToWorld( Vector(-120,0,31.59) ), Size, Size, Color( 255, 100, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-120,-27.74,-15.54) ), Size, Size, Color( 255, 100, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-120,27.74,-15.54) ), Size, Size, Color( 255, 100, 0, 255) )

	render.DrawSprite( self:LocalToWorld( Vector(79,16.99,9.81) ), 16, 16, Color( 255, 0, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(84,13.55,8.05) ), 12, 12, Color( 255, 0, 0, 255) )

	render.DrawSprite( self:LocalToWorld( Vector(79,-16.99,9.81) ), 16, 16, Color( 255, 0, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(84,-13.55,8.05) ), 12, 12, Color( 255, 0, 0, 255) )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, v in pairs( self.EngineFXPos ) do
		local Sub = Mirror and 1 or -1
		local vOffset = self:LocalToWorld( v )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		
		particle:SetColor( 255, 100, 200 )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/brake.wav", 85 )
end

--PATH lua/entities/lvs_starfighter_vwing/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_turbo_laser/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Turbolaser"
ENT.Author = "Dec"
ENT.Information = "Big Turbolasers make things go boom"
ENT.Category = "[LVS] SW-Vehicles"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false


ENT.MDL = "models/starwars/sky/dec_vehicle/turbolaser/turbolaser1.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}


ENT.AITEAM = 2

ENT.MaxVelocityY = 0
ENT.BoostAddVelocityY = 0

ENT.ForceAngleMultiplier = 0
ENT.ForceAngleDampingMultiplier = 0

ENT.ForceLinearMultiplier = 0
ENT.ForceLinearRate = 0

ENT.MaxVelocityZ = 0
ENT.BoostAddVelocityZ = 0

ENT.MaxHealth = 10000
ENT.MaxShield = 0
ENT.MaxVelocityX = 0
ENT.BoostAddVelocitX = 0
ENT.IgnoreWater = false

ENT.MaxTurnRate = 0

ENT.GroundTraceLength = 0
ENT.GroundTraceHull = 0

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,115) ) ):GetNormalized():Angle() )

    return AimAngles
end



function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.85
	weapon.HeatRateUp = .3
	weapon.HeatRateDown = .45
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		local trace = ent:GetEyeTrace()


		local ID_1 = self:LookupAttachment( "muzzle_r" )
		local ID_2 = self:LookupAttachment( "muzzle_l" )
		
		local Muzzle1 = self:GetAttachment( ID_1 )
		local Muzzle2 = self:GetAttachment( ID_2 )


		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
		local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Forward()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.025,  0.025, 0.025 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 100
		bullet.HullSize 	= 50
		bullet.Damage	= 500
		bullet.Velocity = 9000
		bullet.SplashDamage	= 450
		bullet.SplashDamageRadius	= 350
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_concussion_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		--effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent )
		if self:GetAI() or IsValid(self:GetGunnerSeat():GetDriver()) then
			local AimAngles = self:GetAimAngles( ent )

			self:SetPoseParameter("turbolaser_aim_pitch", (-AimAngles.p / 3) )
			self:SetPoseParameter("turbolaser_aim_yaw", (AimAngles.y - 90) )
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 360) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end

	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 1.05
	weapon.HeatRateUp = .6
	weapon.HeatRateDown = .4
	weapon.Attack = function( ent )
		for i = 1, 2 do
			local base = ent:GetVehicle()
			local ID_1 = self:LookupAttachment( "muzzle_r" )
			local ID_2 = self:LookupAttachment( "muzzle_l" )
			
			local Muzzle1 = self:GetAttachment( ID_1 )
			local Muzzle2 = self:GetAttachment( ID_2 )


			ent.MirrorPrimary = not ent.MirrorPrimary

			local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
			local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Forward()

			local bullet = {}
			bullet.Src 	= Pos
			bullet.Dir 	= Dir
			bullet.Spread 	= Vector( 0.025,  0.025, 0.025 )
			bullet.TracerName = "lvs_laser_blue"
			bullet.Force	= 100
			bullet.HullSize 	= 50
			bullet.Damage	= 800
			bullet.Velocity = 9000
			bullet.SplashDamage	= 1200
			bullet.SplashDamageRadius	= 450
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,50,255) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_concussion_explosion", effectdata )
			end

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,50,255) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( Dir )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
			ent:LVSFireBullet( bullet )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent )
		if self:GetAI() or IsValid(self:GetGunnerSeat():GetDriver()) then
			local AimAngles = self:GetAimAngles( ent )

			self:SetPoseParameter("turbolaser_aim_pitch", (-AimAngles.p / 3) )
			self:SetPoseParameter("turbolaser_aim_yaw", (AimAngles.y - 90) )
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 360) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )

end
--PATH lua/entities/lvs_turret_ai/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end

--PATH lua/entities/lvs_turret_ai/shared.lua:
ENT.Base = "lvs_base_turret"

ENT.PrintName = "Anti-Infantry Turret"
ENT.Author = "Luna"
ENT.Information = "Infantry Problem? Rotary laser cannon says 'Not Anymore.'"
ENT.Category = "[LVS] - Turrets (Republic)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/antiinfantryturret/Anti-InfantryTurret.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.MaxHealth = 4800

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,60) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 19 or AimAngles.p <= -24)
end

function ENT:InitWeapons()
	local weapon = {}
    weapon.Icon = Material("lvs/weapons/mg.png")
    weapon.Delay = 0.08
    weapon.HeatRateUp = .2
    weapon.HeatRateDown = .3
    weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID = self:LookupAttachment( "muzzle" )
		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return end	

		local Pos = Muzzle.Pos
		local Dir = Muzzle.Ang:Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.015,  0.015, 0.015 )
		bullet.TracerName = "lvs_laser_blue_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 20000
		bullet.SplashDamage	= 20
		bullet.SplashDamageRadius	= 120
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"
--PATH lua/entities/lvs_walker_atrt_flamethrower/cl_legs.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_rotary/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte_component.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte_rear.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_hsd/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_hsd/shared.lua:

ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "Homing Spider Droid"
ENT.Author = "Luna"
ENT.Information = "OG-9 Separatist Walker Droid"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Walkers"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/blu/hsd.mdl"
ENT.GibModels = {
	"models/blu/hsd_gib.mdl",
	"models/blu/hsd_foot.mdl",
	"models/blu/hsd_leg_1.mdl",
	"models/blu/hsd_leg_2.mdl",
	"models/blu/hsd_leg_3.mdl",
	"models/blu/hsd_leg_4.mdl",
}

ENT.AITEAM = 1

ENT.MaxHealth = 6000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 250
ENT.HoverTraceLength = 300
ENT.HoverHullRadius = 50

ENT.TurretTurnRate = 100

ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true,
}

ENT.lvsShowInSpawner = true

function ENT:OnSetupDataTables()
	self:AddDT( "Int", "UpdateLeg" )
	self:AddDT( "Bool", "IsRagdoll" )
	self:AddDT( "Bool", "IsMoving" )
	self:AddDT( "Bool", "NWGround" )
	self:AddDT( "Bool", "ProjectorBeam" )
	self:AddDT( "Vector", "AIAimVector" )
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:HitGround()
	return self:GetNWGround()
end

--PATH lua/entities/lvs_walker_hsd/cl_camera.lua:
return gluapack()()
--PATH lua/entities/millenium_falcon.lua:
return gluapack()()
--PATH lua/entities/millenium_falcon.lua:
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Type = "vehicle"
ENT.Base = "fighter_base"

ENT.PrintName = "Millennium Falcon"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Rebels"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = true;
ENT.AdminOnly = true;

ENT.EntModel = "models/mf/mf.mdl"
ENT.FlyModel = "models/mf/mf1.mdl"
ENT.Vehicle = "Falcon"
ENT.StartHealth = 6000;
ENT.Allegiance = "Rebels";
list.Set("SWVehicles", ENT.PrintName, ENT);
util.PrecacheModel("models/mf/mf1.mdl")


if SERVER then

ENT.FireSound = Sound("vehicles/mf/mf_shoot2.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),FireMode = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("millenium_falcon");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()
	
	self:SetNWInt("Health",self.StartHealth);
	self.CanRoll = true;
	self.CanBack = true;
	self.WeaponLocations = {
		TopRight = self:GetPos()+self:GetUp()*210+self:GetForward()*450+self:GetRight()*7,
		BottomRight = self:GetPos()+self:GetUp()*40+self:GetForward()*450+self:GetRight()*7,
		TopLeft = self:GetPos()+self:GetUp()*210+self:GetForward()*450+self:GetRight()*-9,
		BottomLeft = self:GetPos()+self:GetUp()*40+self:GetForward()*450+self:GetRight()*-9,
	}
	self.WeaponsTable = {};
	//self:SpawnWeapons();
	self.BoostSpeed = 3000;
	self.ForwardSpeed = 1500;
	self.UpSpeed = 600;
	self.AccelSpeed = 10;
	self.ExitModifier = {x=-450,y=-130,z=15}
	self.CanShoot = true;
	self.DontOverheat = true;
	self.FireDelay = 0.15
	self.AlternateFire = true;
	self.FireGroup = {"TopRight","TopLeft","BottomRight","BottomLeft"}
	self.Bullet = CreateBulletStructure(200,"red");
	self.HasLightspeed = true;
	self.BaseClass.Initialize(self)

end


function ENT:Enter(p)

	self:SetModel(self.FlyModel);
	self.BaseClass.Enter(self,p);

end

function ENT:Exit()
	
	if(self.TakeOff) then
		self:SetModel(self.EntModel);
	end		
	self.BaseClass.Exit(self);
	
end


end

if CLIENT then

	function ENT:Draw() self:DrawModel() end
	
	ENT.EnginePos = {}
	ENT.Sounds={
		Engine=Sound("vehicles/mf/mf_fly5.wav"),
	}
	
	local Health = 0;
	ENT.NextView = CurTime();
	ENT.CanFPV = true;
	function ENT:Think()
		self.BaseClass.Think(self);
		
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local IsFlying = p:GetNWBool("Flying"..self.Vehicle);
		local Wings = self:GetNWBool("Wings");
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		
		if(Flying) then
			if(!TakeOff and !Land) then
				self:FlightEffects();
			end
			Health = self:GetNWInt("Health");

		end
		
		
	end
	
    ENT.ViewDistance = 1000;
    ENT.ViewHeight = 250;
    ENT.FPVPos = Vector(160,-320,140);
	
	function ENT:FlightEffects()
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		local p = LocalPlayer()		
		local FWD = self:GetForward();
		local id = self:EntIndex();
		
		self.EnginePos = {
			self:GetPos()+self:GetUp()*135+self:GetRight()*-230+self:GetForward()*-462;
			self:GetPos()+self:GetUp()*135+self:GetRight()*-185+self:GetForward()*-482;
			self:GetPos()+self:GetUp()*135+self:GetRight()*-145+self:GetForward()*-502;
			self:GetPos()+self:GetUp()*135+self:GetRight()*-105+self:GetForward()*-522;
			
			self:GetPos()+self:GetUp()*135+self:GetRight()*-65+self:GetForward()*-532;
			self:GetPos()+self:GetUp()*135+self:GetRight()*-20+self:GetForward()*-539;
			self:GetPos()+self:GetUp()*135+self:GetRight()*20+self:GetForward()*-539;
			self:GetPos()+self:GetUp()*135+self:GetRight()*65+self:GetForward()*-532;
			
			self:GetPos()+self:GetUp()*135+self:GetRight()*230+self:GetForward()*-462;
			self:GetPos()+self:GetUp()*135+self:GetRight()*185+self:GetForward()*-482;
			self:GetPos()+self:GetUp()*135+self:GetRight()*145+self:GetForward()*-502;
			self:GetPos()+self:GetUp()*135+self:GetRight()*105+self:GetForward()*-522;
		}
		for k,v in pairs(self.EnginePos) do
				
			local blue = self.FXEmitter:Add("sprites/bluecore",v)
			blue:SetVelocity(normal)
			blue:SetDieTime(FrameTime()*1.25)
			blue:SetStartAlpha(255)
			blue:SetEndAlpha(255)
			blue:SetStartSize(37.5)
			blue:SetEndSize(25)
			blue:SetRoll(roll)
			blue:SetColor(255,255,255)
			
			local dynlight = DynamicLight(id + 4096 * k);
			dynlight.Pos = v;
			dynlight.Brightness = 5;
			dynlight.Size = 250;
			dynlight.Decay = 1024;
			dynlight.R = 100;
			dynlight.G = 100;
			dynlight.B = 255;
			dynlight.DieTime = CurTime()+1;
			
		end
	
	end
	
	local HUD = surface.GetTextureID("vgui/falcon_cockpit")
	local Glass = surface.GetTextureID("models/props_c17/frostedglass_01a_dx60")
	function FalconReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingFalcon");
		local self = p:GetNWEntity("Falcon");
		

		if(Flying and IsValid(self)) then

			local FPV = self:GetFPV();
			
			if(FPV) then
				SW_HUD_FPV(HUD);
			end
			
			SW_HUD_DrawHull(6000);
			SW_WeaponReticles(self);
			
			local x = ScrW()/4*1.3;
			local y = ScrH()/4*3.1;
			SW_HUD_Compass(self,x,y);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "FalconReticle", FalconReticle)

end
--PATH lua/entities/mk5.lua:
return gluapack()()
--PATH lua/entities/mortar_fire_shell/cl_init.lua:
return gluapack()()
--PATH lua/entities/mortar_smoke_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar Smoke Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_bacta.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_impact.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arc9_nade_base"
ENT.PrintName = "Impact Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_impact.mdl"
ENT.Armed = false

ENT.BlastDamage = {
    [0] = 60,
    [1] = 140,
    [2] = 70,
}

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSkin(self.Skin or 0)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:SetPhysicsAttacker(self:GetOwner(), 10)
    end
    
    util.PrecacheSound("kraken/explosives/impact/beep.wav")
    self:EmitSound("kraken/explosives/impact/beep.wav")
    
end

function ENT:PhysicsCollide(data, physobj)
    local tgt = data.HitEntity
    local dmginfo = DamageInfo()
    dmginfo:SetDamageType(DMG_GENERIC)
    dmginfo:SetDamage(10)
    dmginfo:SetAttacker(self:GetOwner())
    dmginfo:SetInflictor(self)
    dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
    tgt:TakeDamageInfo(dmginfo)
    if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
        local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
        timer.Simple(0, function()
            if IsValid(self) then
                self:SetAngles(ang)
                self:SetPos(pos)
                self:GetPhysicsObject():SetVelocityInstantaneous(vel)
            end
        end)
    else
        self:Detonate(data.HitEntity)
    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create( "info_particle_system" )
            explode:SetKeyValue( "effect_name", "grenade_final" )
            explode:SetOwner( self.Owner )
            explode:SetPos( self:GetPos() )
            explode:Spawn()
            explode:Activate()
            explode:Fire( "start", "", 0 )
            explode:Fire( "kill", "", 30 )
            --util.Effect("Explosion", effectdata)
            --util.Effect("hl2mmod_explosion_grenade", effectdata)
            self:EmitSound("ArcCW_Kraken.Explosives.Explosion", 120, 100, 1, CHAN_AUTO)
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        
        local pos = self:GetPos()

        for _, ent in pairs(ents.FindInSphere(pos, 350)) do
           
            local distSqr = ent:GetPos():DistToSqr(pos)
            local f = 1
            if distSqr > 9216 then -- 96 * 96
                f = Lerp((distSqr - 9216) / (122500 - 9216), 1, 0.25)
            end
            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_BLAST)
            dmginfo:SetAttacker(attacker)
            dmginfo:SetDamage(85 * f)
            dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
            dmginfo:SetInflictor(self)
            ent:TakeDamageInfo(dmginfo)
        end
        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 16))
        util.ScreenShake(self:GetPos(), 25, 4, 1, self.Radius * 4)
    end
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_incen/shared.lua:
-- Made by Matsilagi

AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

function ENT:Draw()
self:DrawModel()
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( "models/arccw/kraken/sw/explosives/world/w_thermalimploder.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		self:DrawShadow( false )
	end
	self:EmitSound("kraken/explosives/incgrenade/beep.wav")
	self.ActiveTimer = CurTime() + 1.5
	self.IgniteEnd = 0
	self.IgniteEndTimer = CurTime()
	self.IgniteStage = 0
	self.IgniteStageTimer = CurTime()
	ParticleEffectAttach("incgrenade_thrown_trail",PATTACH_POINT_FOLLOW,self,1)
	self:PhysicsInitSphere( 8 )
end

function ENT:PhysicsCollide( data,phys )
	if SERVER and self.ActiveTimer > CurTime() || data.Speed >= 150 then
		self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))
	end
	local ang = data.HitNormal:Angle()
	ang.p = math.abs( ang.p )
	ang.y = math.abs( ang.y )
	ang.r = math.abs( ang.r )
	
	if ang.p > 90 or ang.p < 60 then
		self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))

		local impulse = (data.OurOldVelocity - 2 * data.OurOldVelocity:Dot(data.HitNormal) * data.HitNormal)*0.25
		phys:ApplyForceCenter(impulse)
	else
		if SERVER then
			local molotovfire = ents.Create( "fire_spawned2" )
			molotovfire:SetPos( self:GetPos() )
			molotovfire:SetOwner( self.Owner )
			molotovfire:Spawn()
			SafeRemoveEntityDelayed(molotovfire, 8)
			
			local molotovfire = ents.Create( "fire_spawned1" )
			local pos = self:GetPos()
			molotovfire:SetPos( self:GetPos() )
			molotovfire:SetOwner( self.Owner )
			molotovfire:SetCreator( self )
			molotovfire:Spawn()
			SafeRemoveEntityDelayed(molotovfire, 8)
			
			self:SetMoveType( MOVETYPE_NONE )
			self:SetSolid( SOLID_NONE )
			self:PhysicsInit( SOLID_NONE )
			self:SetCollisionGroup( COLLISION_GROUP_NONE )
			self:SetRenderMode( RENDERMODE_TRANSALPHA )
			self:SetColor( Color( 255, 255, 255, 0 ) )
			self:DrawShadow( false )
			self:StopParticles()
		end
		self:EmitSound("ArcCW_Kraken.Explosives.IncendiaryExpl")
		self.IgniteEnd = 1
		self.IgniteEndTimer = CurTime() + 7
		self.IgniteStage = 1
		self.IgniteStageTimer = CurTime() + 0.1
	end
	SafeRemoveEntityDelayed(self, 8)
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_sonar/shared.lua:
return gluapack()()
--PATH lua/entities/nmg_eksoan_class_4ts_power_gen/cl_init.lua:
return gluapack()()
--PATH lua/entities/nmg_eksoan_class_4ts_power_gen/shared.lua:
ENT.Type        = "anim"
ENT.Base        = "base_anim"
ENT.Category    = "[Nexus Modding Group] E-Web"
ENT.PrintName   = "Eksoan Class 4TS Power Gen"
ENT.Author      = "R4V3NGaming"
ENT.Spawnable   = true

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "Energy")

    if SERVER then
        self:SetEnergy(75)
    end
end
--PATH lua/entities/nmg_mark_ii_ewhn-10/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.MuzzleAttachment = self:LookupAttachment("muzzle")
	self.shootPos = self:GetShootPos()
end

local Color_White = Color( 201, 201, 201, 230)
local Color_Outline = Color(25,25,25,100)
local Color_BlackT = Color(0, 0, 0, 230)

local function R4V3NGaming_OutlinedBox(x, y, w, h, thickness, col)
	surface.SetDrawColor(col.r, col.g, col.b, col.a)
	for i = 0, thickness - 1 do
		surface.DrawOutlinedRect(x + i, y + i, w - i * 2, h - i * 2)
	end
end

function ENT:Draw()
	self:DrawModel()

	if (self:GetTurretBase()) and (IsValid(self:GetTurretBase())) then

		local Ang = self:GetTurretBase():GetAngles()
		local Pos = self:GetTurretBase():GetPos()
		local Ammo = self:GetTAmmo()
		local Perc = math.ceil((Ammo * 100) / 500)
		Ang:RotateAroundAxis(self:GetTurretBase():GetAngles():Up(), 210)

		cam.Start3D2D(Pos + Ang:Up() * 24.7 + Ang:Forward() * -59.2 + Ang:Right() * 36.9, Ang, 0.09 )

			surface.SetDrawColor(Color_Outline)
			surface.DrawRect(0, 0, -80, -80)
			surface.SetDrawColor(Color_BlackT)
			surface.DrawRect(0, 0, -80, -80 * (Perc / 100))
			R4V3NGaming_OutlinedBox(0, 0, -80, -80, 5, Color_White)
			draw.SimpleTextOutlined(Perc .. "%", "DermaLarge", -40, -40,  Color_White, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color_Outline )

		cam.End3D2D()
	end
end
--PATH lua/entities/nmg_mark_ii_ewhn-10/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Category = "[Nexus Modding Group] E-Web"
ENT.PrintName = "Mark II EWHB-10"
ENT.Author = "R4V3NGaming"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.TurretFloatHeight = 0
ENT.TurretModelOffset = Vector(0, -50, 50)
ENT.TurretTurnMax = 0.7
ENT.LastShot = 0
ENT.ShotInterval = 0.15
ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "Shooter")
	self:NetworkVar("Entity", 1, "ShootPos")
	self:NetworkVar("Entity", 2, "TurretBase")
	self:NetworkVar("Int", 0, "TAmmo")
end

function ENT:GetShooter(plr)
	if SERVER then
		return self:GetShooter()
	elseif CLIENT then
		return self:GetShooter()
	end
end

function ENT:Use(plr)
	if not self:ShooterStillValid() then
		self:SetShooter(plr)
		self:StartShooting()
		self.ShooterLast = plr
	else
		if plr == self:GetShooter() then
			self:SetShooter(nil)
			self:FinishShooting()
		end
	end
end

function ENT:ShooterStillValid()
	local shooter = nil
	if SERVER then
		shooter = self:GetShooter()
	elseif CLIENT then
		shooter = self:GetShooter()
	end
	return IsValid(shooter) and shooter:Alive() and (self:GetPos():DistToSqr(shooter:GetPos()) <= 7000)
end

function ENT:GetCrosshairFilterEnts()
	return {self, self.turretBase, self.shootPos}
end

function ENT:LVSFireBullet(data)
	data.Entity = self
	data.Velocity = data.Velocity + self:GetVelocity():Length()
	data.SrcEntity = self:WorldToLocal(data.Src)
	LVS:FireBullet(data)
end

function ENT:DoShot()
	if self.LastShot + self.ShotInterval < CurTime() then
		if SERVER then
			if self:GetTAmmo() > 0 then
				local effectPosAng = self:GetAttachment(self.MuzzleAttachment)
				local vPoint = effectPosAng.Pos

				local muzzleEffectData = EffectData()
				muzzleEffectData:SetStart(Vector(255,50,50))
				muzzleEffectData:SetOrigin(vPoint)
				muzzleEffectData:SetNormal(self.shootPos:GetAngles():Forward() * 100)
				muzzleEffectData:SetAngles(effectPosAng.Ang)
				muzzleEffectData:SetEntity(self)
				muzzleEffectData:SetScale(100)
				util.Effect("lvs_muzzle_colorable", muzzleEffectData)
				self:EmitSound(self.ShotSound, 50, 100)

				if IsValid(self.shootPos) and SERVER then
					self.shootPos:FireBullets({
						Num = 1,
						Src = self.shootPos:GetPos() + self.shootPos:GetAngles():Forward() * 40,
						Dir = self.shootPos:GetAngles():Forward() * 1,
						Spread = Vector(0.02, 0.02, 0),
						HullSize = 30,
						Force = 2,
						Damage = 50,
						Attacker = self.Shooter,
						Callback = function(attacker, trace, dmginfo)
							local hitEffectData = EffectData()
							hitEffectData:SetStart(Vector(255,50,50))
							hitEffectData:SetOrigin(trace.HitPos)
							util.Effect("lvs_laser_explosion", hitEffectData)

							local tracerEffect = EffectData()
							tracerEffect:SetStart(self.shootPos:GetPos())
							tracerEffect:SetOrigin(trace.HitPos)
							util.Effect("red_tracer", tracerEffect)
						end
					})
					self:TakeAmmo()
					self:GetPhysicsObject():ApplyForceCenter(self:GetRight() * -500)
				end
			else
				self:EmitSound(self.EmptySound, 50, 100)
			end
		end
		self.LastShot = CurTime()
	end
end

function ENT:Think()
	if not IsValid(self.turretBase) and SERVER then
		SafeRemoveEntity(self)
	else
		if IsValid(self) then
			if SERVER then
				self.BasePos = self.turretBase:GetPos()
				self.OffsetPos = self.turretBase:GetAngles():Up() * 1

				if self.MagazineCollider then
					self.MagazineCollider:SetPos(self.turretBase:GetPos() + self.turretBase:GetUp() * 5 + self.turretBase:GetForward() * 10 + self.turretBase:GetRight() * -80)
					self.MagazineCollider:SetAngles(self.turretBase:GetAngles() + Angle(0, 90, 0))
				end
			end

			if self:ShooterStillValid() then
				if SERVER then
					local offsetAng = (self:GetAttachment(self.MuzzleAttachment).Pos - self:GetDesiredShootPos()):GetNormal()
					local offsetAngNew = offsetAng:Angle()
					offsetAngNew:RotateAroundAxis(offsetAngNew:Up(), -90)

					self.OffsetAng = offsetAngNew
					local Vertical = math.Clamp(self.OffsetAng.z, -31, 30)
					self:ManipulateBoneAngles(1, Angle(0, Vertical, 0))
				end

				local pressKey = IN_BULLRUSH
				if CLIENT and game.SinglePlayer() then
					pressKey = IN_ATTACK
				end

				self.Firing = self:GetShooter():KeyDown(pressKey)
			else
				self.Firing = false
				if SERVER then
					self:SetShooter(nil)
					self:FinishShooting()
				end
			end

			if self.Firing then
				self:DoShot()
			end

			self:NextThink(CurTime())
			return true
		end
	end
end
--PATH lua/entities/npc_nightsister_undead/cl_init.lua:
return gluapack()()
--PATH lua/entities/npc_vj_sbdnew1/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_test_humanply/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_test_humanply/shared.lua:
ENT.Base 			= "npc_vj_human_base"
ENT.Type 			= "ai"
ENT.PrintName 		= "Player NPC"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "Spawn it and fight with it!"
ENT.Instructions 	= "Click on the spawnicon to spawn it."
ENT.Category		= "VJ Base"
--PATH lua/entities/npc_vj_tridroid_f/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_tridroid_f/shared.lua:
ENT.Base 			= "npc_vj_creature_base"
ENT.Type 			= "ai"
ENT.PrintName 		= "Tri Droid (Friendly)"
ENT.Author 			= "Mayhem - zhinged"
ENT.Contact 		= "http://vrejgaming.webs.com/"
ENT.Purpose 		= ""
ENT.Instructions	= "Click on it to spawn it."
ENT.Category		= "MGR"

if (CLIENT) then
local Name = "Tri Droid (Friendly)"
local LangName = "npc_vj_tridroid_f"
language.Add(LangName, Name)
killicon.Add(LangName,"HUD/killicons/default",Color ( 255, 80, 0, 255 ) )
language.Add("#"..LangName, Name)
killicon.Add("#"..LangName,"HUD/killicons/default",Color ( 255, 80, 0, 255 ) )
end
--PATH lua/entities/npc_vj_tridroidgunfixnew_f/shared.lua:
ENT.Base 			= "npc_vj_creature_base"
ENT.Type 			= "ai"
ENT.PrintName 		= "Tri Droidgun (Friendly)"
ENT.Author 			= "Mayhem - zhinged"
ENT.Contact 		= "http://vrejgaming.webs.com/"
ENT.Purpose 		= ""
ENT.Instructions	= "Click on it to spawn it."
ENT.Category		= "MGR"

if (CLIENT) then
local Name = "Tri Droid (Friendly)"
local LangName = "npc_vj_tridroidgunfixnew_f"
language.Add(LangName, Name)
killicon.Add(LangName,"HUD/killicons/default",Color ( 255, 80, 0, 255 ) )
language.Add("#"..LangName, Name)
killicon.Add("#"..LangName,"HUD/killicons/default",Color ( 255, 80, 0, 255 ) )
end
--PATH lua/entities/obj_vj_blasterrod.lua:
return gluapack()()
--PATH lua/entities/obj_vj_empty/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_spawner_base/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_tank_shell.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_mystery_wheel/shared.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_interior_standing/cl_init.lua:
include("shared.lua")

function ENT:PostData()
end

local draw_simpletext = draw.SimpleText
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	local pos = self:GetPos()
	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), -90)

	cam.Start3D2D(pos + (self:GetUp() * 26) + (self:GetForward() * 2.4) + (self:GetRight() * 7.1), ang, 0.05)
			PerfectCasino.UI.WrapText(self.data.general.text, 15, "pCasino.Title.Static", 140, 100, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()

	ang:RotateAroundAxis(ang:Right(), 180)

	cam.Start3D2D(pos + (self:GetUp() * 26) + (self:GetForward() * -2.4) + (self:GetRight() * -7.1), ang, 0.05)
			PerfectCasino.UI.WrapText(self.data.general.text, 15, "pCasino.Title.Static", 140, 100, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_interior_wall/cl_init.lua:
include("shared.lua")

function ENT:PostData()
end

function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	local pos = self:GetPos()
	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), -90)

	cam.Start3D2D(pos + (self:GetUp() * 2.8) + (self:GetForward() * 0.1) + (self:GetRight() * 10.8), ang, 0.06)
		PerfectCasino.UI.WrapText(self.data.general.text, 25, "pCasino.Title.Static", 180, 47, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_stand/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.letters = {}
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
	
	self.data.general.text = string.sub(self.data.general.text, 1, 7)
	local letterMap = PerfectCasino.Core.Letter

	-- Right side
		-- Letter calculations
		local startPoint = (self:GetRight() * 25) + (self:GetForward() * 13.5) + (self:GetUp() * 9)
		local curLength = vector_origin
		local right = self:GetRight()
	
		for k, v in ipairs(string.Split(string.lower(self.data.general.text), "")) do
			if not letterMap[v] then -- It's either a space or a character we don't support
				curLength = curLength + (self:GetRight() * 5)
				continue
			end
	
			-- Create the letter
			local letter = ClientsideModel("models/freeman/owain_casino_alphabet.mdl")
			table.insert(self.letters, letter)
			letter:SetParent(self)
			curLength = curLength + ((self:GetRight()) * (letterMap[v].w*2))
			letter:SetPos(self:GetPos() + startPoint - curLength + ((self:GetRight()) * (letterMap[v].w)))
			letter:SetAngles(self:GetAngles())
			letter:SetBodygroup(1, letterMap[v].b)
		end
	-- Left side
		-- Letter calculations
		local startPoint = (self:GetRight() * 25) + (self:GetForward() * -13.5) + (self:GetUp() * 9)
		local curLength = vector_origin
		local right = self:GetRight()
	
		for k, v in ipairs(table.Reverse(string.Split(string.lower(self.data.general.text), ""))) do
			if not letterMap[v] then -- It's either a space or a character we don't support
				curLength = curLength + (self:GetRight() * 5)
				continue
			end
	
			-- Create the letter
			local letter = ClientsideModel("models/freeman/owain_casino_alphabet.mdl")
			table.insert(self.letters, letter)
			letter:SetParent(self)
			curLength = curLength + ((self:GetRight()) * (letterMap[v].w*2))
			letter:SetPos(self:GetPos() + startPoint - curLength + ((self:GetRight()) * (letterMap[v].w)))
			local ang = self:GetAngles()
			ang:RotateAroundAxis(ang:Up(), 180)
			letter:SetAngles(ang)
			letter:SetBodygroup(1, letterMap[v].b)
		end
end

function ENT:OnRemove()
	-- Clear the board of last rounds best
	for k, v in pairs(self.letters) do
		if not IsValid(v) then continue end

		v:Remove()
	end
end

function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_slot_machine/shared.lua:
return gluapack()()
--PATH lua/entities/pfx1_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [v_2]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]campfire1"
--PATH lua/entities/pfx1_08#.lua:
return gluapack()()
--PATH lua/entities/pfx1_09.lua:
return gluapack()()
--PATH lua/entities/pfx1_0c~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large fire"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]ground_fire_1*"
--PATH lua/entities/pfx1_0f.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Colorful Smoke Cloud"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_smoke_colorful_1"
--PATH lua/entities/pfx2_02_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Gushing Blood"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]gushing_blood"



--PATH lua/entities/pfx2_04.lua:
return gluapack()()
--PATH lua/entities/pfx3_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Tree Leafs 1"
ENT.Category         = "PPE: Nature"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[3]leaves_env"



--PATH lua/entities/pfx4_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Basic Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_f"



--PATH lua/entities/pfx4_06_1.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Green Energy Rod"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]energy_rod_g"
--PATH lua/entities/pfx4_06_3.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Yellow Energy Rod"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]energy_rod_y"
--PATH lua/entities/pfx5_00_ss.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Micro Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole_mmicro"
--PATH lua/entities/pfx5_03.lua:
return gluapack()()
--PATH lua/entities/pfx6_00.lua:
return gluapack()()
--PATH lua/entities/pfx7_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fog 1"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]areal_fog_s"
--PATH lua/entities/pfxa_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Waterleak"
ENT.Category         = "PPE: Water"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[A]waterleak_1"
--PATH lua/entities/podracer.lua:
return gluapack()()
--PATH lua/entities/pp_prop_effect.lua:
return gluapack()()
--PATH lua/entities/pp_prop_effect.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.PrintName		= ""
ENT.Author			= ""
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Spawnable		= false
ENT.AdminOnly		= false

--[[---------------------------------------------------------
	Name: Initialize
-----------------------------------------------------------]]
function ENT:Initialize()

	local Radius = 6
	local min = Vector( 1, 1, 1 ) * Radius * -0.5
	local max = Vector( 1, 1, 1 ) * Radius * 0.5

	if ( SERVER ) then

		self.AttachedEntity = ents.Create( "prop_dynamic" )
		self.AttachedEntity:SetModel( self:GetModel() )
		self.AttachedEntity:SetAngles( self:GetAngles() )
		self.AttachedEntity:SetPos( self:GetPos() )
		self.AttachedEntity:SetSkin( self:GetSkin() )
		self.AttachedEntity:Spawn()
		self.AttachedEntity:SetParent( self.Entity )
		self.AttachedEntity:DrawShadow( false )

		self:SetModel( "models/props_junk/watermelon01.mdl" )

		self:DeleteOnRemove( self.AttachedEntity )

		-- Don't use the model's physics - create a box instead
		self:PhysicsInitBox( min, max )

		-- Set up our physics object here
		local phys = self:GetPhysicsObject()
		if ( IsValid( phys ) ) then
			phys:Wake()
			phys:EnableGravity( false )
			phys:EnableDrag( false )
		end

		self:DrawShadow( false )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )

	else

		self.GripMaterial = Material( "sprites/grip" )

		-- Get the attached entity so that clientside functions like properties can interact with it
		local tab = ents.FindByClassAndParent( "prop_dynamic", self )
		if ( tab && IsValid( tab[ 1 ] ) ) then self.AttachedEntity = tab[ 1 ] end

	end

	-- Set collision bounds exactly
	self:SetCollisionBounds( min, max )

end


--[[---------------------------------------------------------
	Name: Draw
-----------------------------------------------------------]]
function ENT:Draw()

	render.SetMaterial( self.GripMaterial )

end


--[[---------------------------------------------------------
	Name: PhysicsUpdate
-----------------------------------------------------------]]
function ENT:PhysicsUpdate( physobj )

	if ( CLIENT ) then return end

	-- Don't do anything if the player isn't holding us
	if ( !self:IsPlayerHolding() && !self:IsConstrained() ) then

		physobj:SetVelocity( Vector( 0, 0, 0 ) )
		physobj:Sleep()

	end

end


--[[---------------------------------------------------------
	Name: Called after entity 'copy'
-----------------------------------------------------------]]
function ENT:OnEntityCopyTableFinish( tab )

	-- We need to store the model of the attached entity
	-- Not the one we have here.
	tab.Model = self.AttachedEntity:GetModel()

	-- Store the attached entity's table so we can restore it after being pasted
	tab.AttachedEntityInfo = table.Copy( duplicator.CopyEntTable( self.AttachedEntity ) )
	tab.AttachedEntityInfo.Pos = nil -- Don't even save angles and position, we are a parented entity
	tab.AttachedEntityInfo.Angle = nil

	-- Do NOT store the attached entity itself in our table!
	-- Otherwise, if we copy-paste the prop with the duplicator, its AttachedEntity value will point towards the original prop's attached entity instead, and that'll break stuff
	tab.AttachedEntity = nil

end


--[[---------------------------------------------------------
	Name: PostEntityPaste
-----------------------------------------------------------]]
function ENT:PostEntityPaste( ply )

	-- Restore the attached entity using the information we've saved
	if ( IsValid( self.AttachedEntity ) ) and ( self.AttachedEntityInfo ) then

		-- Apply skin, bodygroups, bone manipulator, etc.
		duplicator.DoGeneric( self.AttachedEntity, self.AttachedEntityInfo )

		if ( self.AttachedEntityInfo.EntityMods ) then
			self.AttachedEntity.EntityMods = table.Copy( self.AttachedEntityInfo.EntityMods )
			duplicator.ApplyEntityModifiers( ply, self.AttachedEntity )
		end

		if ( self.AttachedEntityInfo.BoneMods ) then
			self.AttachedEntity.BoneMods = table.Copy( self.AttachedEntityInfo.BoneMods )
			duplicator.ApplyBoneModifiers( ply, self.AttachedEntity )
		end

		self.AttachedEntityInfo = nil

	end

end

--PATH lua/entities/republic_speeder.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_e60r.lua:
AddCSLuaFile()

ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "RPG-7 Round"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 4.5

if SERVER then

    function ENT:Initialize()
        local pb_vert = 1
        local pb_hor = 1
        self:SetModel(self.Model)
        self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )
    
        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:EnableGravity(false)
        end
    
        self.SpawnTime = CurTime()
        self.motorsound = CreateSound( self, "kraken/launchers/rps/move_rpapa7_proj_flame_cls.ogg")
        self.motorsound:Play()
    
        timer.Simple(0.1, function()
            if !IsValid(self) then return end
            self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
        end)
    end
    
    function ENT:Think()
        if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
            self:Detonate()
        end
    end
    
    function ENT:OnRemove()
        self.motorsound:Stop()
    end
    
    end
    
    function ENT:Think()
        if SERVER then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
    
            if self.SpawnTime + self.FuseTime <= CurTime() then
                self:Detonate()
            end
        else
            if self.Ticks % 5 == 0 then
                local emitter = ParticleEmitter(self:GetPos())
    
                if !self:IsValid() or self:WaterLevel() > 2 then return end
                if !IsValid(emitter) then return end
    
                local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
                smoke:SetVelocity( VectorRand() * 25 )
                smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
                smoke:SetDieTime( math.Rand(1.5, 2.0) )
                smoke:SetStartAlpha( 255 )
                smoke:SetEndAlpha( 0 )
                smoke:SetStartSize( 0 )
                smoke:SetEndSize( 100 )
                smoke:SetRoll( math.Rand(-180, 180) )
                smoke:SetRollDelta( math.Rand(-0.2,0.2) )
                smoke:SetColor( 20, 20, 20 )
                smoke:SetAirResistance( 5 )
                smoke:SetPos( self:GetPos() )
                smoke:SetLighting( false )
                emitter:Finish()
            end
    
            self.Ticks = self.Ticks + 1
        end
    end
    
    function ENT:Detonate()
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
    
        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
            self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
        else
            util.Effect( "Explosion", effectdata)
            self:EmitSound("ArcCW_Kraken.Explosives.RocketImpact")
        end
    
        local attacker = self
    
        if self.Owner:IsValid() then
            attacker = self.Owner
        end
    
        util.BlastDamage(self, attacker, self:GetPos(), 550, 110)
    
        self:FireBullets({
            Attacker = attacker,
            Damage = 400,
            Tracer = 0,
            Src = src,
            Dir = dir,
            HullSize = 16,
            Distance = 128,
            IgnoreEntity = self,
            Callback = function(atk, btr, dmginfo)
                if IsValid(btr.Entity) and btr.Entity.LVS then
                    dmginfo:ScaleDamage(5)
                    dmginfo:SetDamageType(DMG_AIRBOAT + DMG_SNIPER + DMG_BLAST)
                    dmginfo:SetDamageForce(self:GetForward() * 20000)
                end
            end,
        })

        local fx = EffectData()
        fx:SetOrigin(self:GetPos())
        fx:SetStart(self:GetPos() + self:GetUp())
        fx:SetRadius(256)
        fx:SetEntity(self)
        if self:WaterLevel() > 0 then
            util.Effect("WaterSurfaceExplosion", fx)
        else
            util.Effect("cod2019_grenade_explosion", fx)
            self:EmitSound("ArcCW_Kraken.Explosives.RocketImpact")
        end
        
        for i, e in pairs(ents.FindInSphere(self:GetPos(), 32)) do
            if (e:GetClass() == "npc_strider") then
                e:Fire("Explode")
            end 
        end
    
        self:Remove()
    end
    
    function ENT:PhysicsCollide(colData, collider)
        self:Detonate()
    end
    
    function ENT:Draw()
        cam.Start3D() -- Start the 3D function so we can draw onto the screen.
            render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
            render.DrawSprite( self:GetPos(), math.random(100, 200), math.random(100, 200), Color(255, 175, 150) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
        cam.End3D()
    end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_heatfs.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_rps.lua:
AddCSLuaFile()

ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "RPG-7 Round"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 4.5

if SERVER then

    function ENT:Initialize()
        local pb_vert = 1
        local pb_hor = 1
        self:SetModel(self.Model)
        self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )
    
        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:EnableGravity(false)
        end
    
        self.SpawnTime = CurTime()
        self.motorsound = CreateSound( self, "kraken/launchers/rps/move_rpapa7_proj_flame_cls.ogg")
        self.motorsound:Play()
    
        timer.Simple(0.1, function()
            if !IsValid(self) then return end
            self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
        end)
    end
    
    function ENT:Think()
        if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
            self:Detonate()
        end
    end
    
    function ENT:OnRemove()
        self.motorsound:Stop()
    end
    
    end
    
    function ENT:Think()
        if SERVER then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
    
            if self.SpawnTime + self.FuseTime <= CurTime() then
                self:Detonate()
            end
        else
            if self.Ticks % 5 == 0 then
                local emitter = ParticleEmitter(self:GetPos())
    
                if !self:IsValid() or self:WaterLevel() > 2 then return end
                if !IsValid(emitter) then return end
    
                local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
                smoke:SetVelocity( VectorRand() * 25 )
                smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
                smoke:SetDieTime( math.Rand(1.5, 2.0) )
                smoke:SetStartAlpha( 255 )
                smoke:SetEndAlpha( 0 )
                smoke:SetStartSize( 0 )
                smoke:SetEndSize( 100 )
                smoke:SetRoll( math.Rand(-180, 180) )
                smoke:SetRollDelta( math.Rand(-0.2,0.2) )
                smoke:SetColor( 20, 20, 20 )
                smoke:SetAirResistance( 5 )
                smoke:SetPos( self:GetPos() )
                smoke:SetLighting( false )
                emitter:Finish()
            end
    
            self.Ticks = self.Ticks + 1
        end
    end
    
    function ENT:Detonate()
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
    
        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
            self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
        else
            util.Effect( "Explosion", effectdata)
            self:EmitSound("ArcCW_Kraken.Explosives.RocketImpact")
        end
    
        local attacker = self
    
        if self.Owner:IsValid() then
            attacker = self.Owner
        end
    
        util.BlastDamage(self, attacker, self:GetPos(), 550, 110)
    
        self:FireBullets({
            Attacker = attacker,
            Damage = 400,
            Tracer = 0,
            Src = src,
            Dir = dir,
            HullSize = 16,
            Distance = 128,
            IgnoreEntity = self,
            Callback = function(atk, btr, dmginfo)
                if IsValid(btr.Entity) and btr.Entity.LVS then
                    dmginfo:ScaleDamage(5)
                    dmginfo:SetDamageType(DMG_AIRBOAT + DMG_SNIPER + DMG_BLAST)
                    dmginfo:SetDamageForce(self:GetForward() * 20000)
                end
            end,
        })

        local fx = EffectData()
        fx:SetOrigin(self:GetPos())
        fx:SetStart(self:GetPos() + self:GetUp())
        fx:SetRadius(256)
        fx:SetEntity(self)
        if self:WaterLevel() > 0 then
            util.Effect("WaterSurfaceExplosion", fx)
        else
            util.Effect("cod2019_grenade_explosion", fx)
            self:EmitSound("ArcCW_Kraken.Explosives.RocketImpact")
        end
        
        for i, e in pairs(ents.FindInSphere(self:GetPos(), 32)) do
            if (e:GetClass() == "npc_strider") then
                e:Fire("Explode")
            end 
        end
    
        self:Remove()
    end
    
    function ENT:PhysicsCollide(colData, collider)
        self:Detonate()
    end
    
    function ENT:Draw()
        cam.Start3D() -- Start the 3D function so we can draw onto the screen.
            render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
            render.DrawSprite( self:GetPos(), math.random(100, 200), math.random(100, 200), Color(255, 175, 150) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
        cam.End3D()
    end
--PATH lua/entities/rw_sw_dispencer/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

local dispencer_health = GetConVar("rw_sw_dispenser_health"):GetInt()
ENT.BaseHealth = dispencer_health

ENT.PrintName		= "Ammo Dispenser"
ENT.Author			= "ChanceSphere574"
ENT.Category		= "StarWars Reworked Armory"
ENT.Spawnable 		= true
ENT.AdminSpawnable	= false

ENT.UseTimer = CurTime()
ENT.Status   = 0

ENT.LoadingSkin = 3
ENT.CurSkin = 0
--PATH lua/entities/rw_sw_dispencer_ammobox/cl_init.lua:
return gluapack()()
--PATH lua/entities/rw_sw_nade.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

function ENT:Draw()
    self:DrawModel()
end


function ENT:Initialize()
    self.Entity:SetNWBool("smoke", 10, true)
    if SERVER then
        self:SetModel( "models/weapons/tfa_starwars/w_thermal.mdl" )
        self:PhysicsInit(SOLID_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)

    local phys = self:GetPhysicsObject()
    if (IsValid(phys)) then
        phys:SetMass(1)
    end
        self:DrawShadow( true )
    end
    self.ExplodeTimer = CurTime() + 100000
    if CLIENT then
        self.emitter = ParticleEmitter( self:GetPos() , 0 )
    end
end

function ENT:PhysicsCollide( data, phys )
    if  (20 < data.Speed and 0.25 < data.DeltaTime) then
    self.ExplodeTimer = 0
    end
end

function ENT:Think()
    if SERVER and (self.ExplodeTimer and self.ExplodeTimer <= CurTime()) then
        self:Explode()
    end
    self:NextThink(CurTime())

    if CLIENT then
        local pos = self:GetPos() + self:GetForward()
        local emitter = ParticleEmitter( self:GetPos() , 0 )
        local particle = emitter:Add("particle/smokesprites_000"..math.random(1,9), pos )
        for i=1, (1) do
            if (particle) then
                particle:SetVelocity((self:GetForward() * -400)+(VectorRand()* 10) )
                particle:SetDieTime( math.Rand( 0.5, 1.5 ) )
                particle:SetStartAlpha( math.Rand( 75, 50 ) )
                particle:SetEndAlpha( 0 )
                particle:SetStartSize( math.Rand( 20, 20 ) )
                particle:SetEndSize( math.Rand( 15, 15 ) )
                particle:SetRoll( math.Rand(0, 360) )
                particle:SetRollDelta( math.Rand(-1, 1) )
                particle:SetColor( 120 , 120 , 120 ) 
                particle:SetAirResistance( 2500 ) 
                particle:SetGravity( Vector( 0, 0, 0 ) )
            end
        end
    end
    return true
end


function ENT:Think2()
end

function ENT:Explode()
	local effectdata = EffectData()
    effectdata:SetOrigin( self:GetPos() )
    util.Effect("Explosion", effectdata)
    util.BlastDamage( self, self.Owner, self:GetPos(), 300, 200 )
    
    local spos = self:GetPos()
    local trs = util.TraceLine({start=spos + Vector(0,0,64), endpos=spos + Vector(0,0,-32), filter=self})
    util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)
    self:Remove()
end

function ENT:OnRemove()
end

--PATH lua/entities/sent_streamradio/shared.lua:
return gluapack()()
--PATH lua/entities/sent_streamradio/shared.lua:
AddCSLuaFile()
DEFINE_BASECLASS( "base_streamradio_gui" )

local StreamRadioLib = StreamRadioLib
local LIBWire = StreamRadioLib.Wire

local g_isLoaded = StreamRadioLib and StreamRadioLib.Loaded
local g_isWiremodLoaded = g_isLoaded and LIBWire.HasWiremod()

ENT.Spawnable = false
ENT.AdminOnly = false
ENT.Editable = true

ENT.PrintName = "Stream Radio"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.WireDebugName = ENT.PrintName

ENT.Sounds_Tune = Sound("buttons/lightswitch2.wav")
ENT.Sounds_Noise = Sound("stream_radio/noise.wav")
ENT.Sounds_Use = Sound("common/wpn_select.wav")

function ENT:SetupDataTables( )
	if not g_isLoaded then return end
	BaseClass.SetupDataTables(self)

	self:AddDTNetworkVar("Bool", "WireMode")
	self:AddDTNetworkVar("Bool", "ToolMode")
	self:AddDTNetworkVar("Entity", "MasterRadio")

	local adv_wire = nil

	if g_isWiremodLoaded then
		adv_wire = {
			KeyName = "DisableAdvancedOutputs",
			Edit = {
				category = "Wiremod",
				title = "Disable advanced outputs",
				type = "Boolean",
				order = 70,
			}
		}
	end

	self:AddDTNetworkVar("Bool", "DisableAdvancedOutputs", adv_wire)

	self:AddDTNetworkVar("Bool", "SVMute", {
		KeyName = "SVMute",
		Edit = {
			category = "Volume",
			title = "Entity Mute",
			type = "Boolean",
			order = 20
		}
	})

	self:AddDTNetworkVar("Float", "Volume", {
		KeyName = "Volume",
		Edit = {
			category = "Volume",
			title = "Entity Volume",
			type = "Float",
			order = 21,
			min = 0,
			max = 1,
		}
	})

	self:AddDTNetworkVar("Int", "Radius", {
		KeyName = "Radius",
		Edit = {
			category = "World Sound",
			title = "Radius",
			type = "Int",
			order = 30,
			min = 0,
			max = 5000,
		}
	})

	self:AddDTNetworkVar("Bool", "Sound3D", {
		KeyName = "Sound3D",
		Edit = {
			category = "World Sound",
			title = "Enable 3D sound",
			type = "Boolean",
			order = 31
		}
	})

	self:AddDTNetworkVar("Bool", "Loop", {
		KeyName = "Loop",
		Edit = {
			category = "Loop",
			title = "Enable song loop",
			type = "Boolean",
			order = 40
		}
	})

	self:AddDTNetworkVar( "Bool", "PlaylistLoop", {
		KeyName = "PlaylistLoop",
		Edit = {
			category = "Loop",
			title = "Enable playlist loop",
			type = "Boolean",
			order = 41
		}
	})

	self:AddDTNetworkVar("Bool", "CLMute", {
		KeyName = "CLMute",
		Edit = {
			category = "Volume",
			title = "Clientside Mute",
			type = "Boolean",
			order = 22,
		}
	})

	self:AddDTNetworkVar("Float", "CLVolume", {
		KeyName = "CLVolume",
		Edit = {
			category = "Volume",
			title = "Clientside Volume",
			type = "Float",
			order = 23,
			min = 0,
			max = 1,
		}
	})

	self._radio_EditValue = self._radio_EditValue or self.EditValue
	self.EditValue = function(this, variable, value)
		-- This workaround allows for clientonly traffic on those data table vars. 

		if variable == "CLMute" then
			if SERVER then
				return
			end

			local mute = tobool(value)
			this:SetCLMute(mute)

			return
		end

		if variable == "CLVolume" then
			if SERVER then
				return
			end

			local volume = tonumber(value or 0) or 0
			this:SetCLVolume(volume)

			return
		end

		return this:_radio_EditValue(variable, value)
	end

	self:SetDTVarCallback("Loop", function(this, name, oldv, newv)
		if newv and SERVER then
			self:SetPlaylistLoop(false)
		end

		self:MarkForUpdatePlaybackLoopMode()
	end)

	self:SetDTVarCallback("PlaylistLoop", function(this, name, oldv, newv)
		if newv and SERVER then
			self:SetLoop(false)
		end

		self:MarkForUpdatePlaybackLoopMode()
	end)
end

function ENT:GetPlaybackLoopMode()
	local loop = self:GetLoop()
	local playlistLoop = self:GetPlaylistLoop()

	if loop then
		return StreamRadioLib.PLAYBACK_LOOP_MODE_SONG
	end

	if playlistLoop then
		return StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST
	end

	return StreamRadioLib.PLAYBACK_LOOP_MODE_NONE
end

function ENT:SetPlaybackLoopMode(loopMode)
	if CLIENT then return end

	self:SetLoop(false)
	self:SetPlaylistLoop(false)

	if loopMode == StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST then
		self:SetPlaylistLoop(true)
	elseif loopMode == StreamRadioLib.PLAYBACK_LOOP_MODE_SONG then
		self:SetLoop(true)
	end

	self:MarkForUpdatePlaybackLoopMode()
end

function ENT:MarkForUpdatePlaybackLoopMode()
	self._callUpdatePlaybackLoopMode = true
end

function ENT:UpdatePlaybackLoopMode()
	self._callUpdatePlaybackLoopMode = nil

	local loopMode = self:GetPlaybackLoopMode()
	local GUI_Main = self.GUI_Main

	if IsValid(GUI_Main) then
		GUI_Main:UpdatePlaybackLoopMode(loopMode)
	end

	self.OnUpdatePlaybackLoopMode(loopMode)
end

function ENT:OnUpdatePlaybackLoopMode(loopMode)
	-- Override me
end

function ENT:GetMasterRadioRecursive()
	if not g_isLoaded then
		self._supermasterradio = nil
		return nil
	end

	if IsValid(self._supermasterradio) and self._supermasterradio.__IsRadio and IsValid(self._supermasterradio.StreamObj) then
		return self._supermasterradio
	end

	self._supermasterradio = nil

	local nodouble = {}
	local function recursive(radio, count)
		if nodouble[radio] then return nil end
		nodouble[radio] = true

		if count <= 0 then
			return nil
		end

		local masterradio = radio:GetMasterRadio()
		if not IsValid(masterradio) then return radio end
		if not masterradio.__IsRadio then return radio end
		if not IsValid(masterradio.StreamObj) then return radio end

		return recursive(masterradio, count - 1)
	end

	local supermasterradio = recursive(self, 10)
	if supermasterradio == self then return nil end

	if not IsValid(supermasterradio) then return nil end
	if not supermasterradio.__IsRadio then return nil end
	if not IsValid(supermasterradio.StreamObj) then return nil end

	self._supermasterradio = supermasterradio
	return supermasterradio
end

function ENT:GetSlaveRadios()
	local mr = self:GetMasterRadioRecursive()
	if mr then
		self.slavesradios = nil
	end

	self.slavesradios = self.slavesradios or {}

	for slave, v in pairs(self.slavesradios) do
		if not IsValid(slave) then
			self.slavesradios[slave] = nil
			continue
		end

		if not slave.__IsRadio then
			self.slavesradios[slave] = nil
			continue
		end

		if not IsValid(slave.StreamObj) then
			self.slavesradios[slave] = nil
			continue
		end

		if slave == self then
			self.slavesradios[slave] = nil
			continue
		end

		local slavemasterradio = slave:GetMasterRadioRecursive()
		if slavemasterradio ~= self then
			self.slavesradios[slave] = nil
			continue
		end
	end

	return self.slavesradios
end

function ENT:IsMutedForPlayer(ply)
	local muted = BaseClass.IsMutedForPlayer(self, ply)
	if not muted then return false end

	local slaves = self:GetSlaveRadios()

	for slave, v in pairs(slaves) do
		if not IsValid(slave) then continue end
		if not slave:IsMutedForPlayer(ply) then return false end
	end

	return true
end

function ENT:OnGUIShowCheck(ply)
	local masterradio = self:GetMasterRadioRecursive()
	if not masterradio then return true end

	local master_st = masterradio.StreamObj

	if master_st:HasError() then return true end
	if not master_st:IsStopMode() then return true end
	if master_st:GetURL() ~= "" then return true end

	if master_st:IsRunning() then return true end

	return false
end

function ENT:OnGUIInteractionCheck(ply, trace, userEntity)
	local masterradio = self:GetMasterRadioRecursive()
	if not masterradio then return true end

	local master_st = masterradio.StreamObj

	if master_st:HasError() then return true end
	if not master_st:IsStopMode() then return true end
	if master_st:GetURL() ~= "" then return true end

	if master_st:IsRunning() then return true end

	return false
end

function ENT:MasterRadioSyncThink()
	if not self.old then return end

	local GUI_Main = self.GUI_Main
	local masterradio = self:GetMasterRadioRecursive()
	local oldmasterradio = self.old.masterradio
	local statechange = false

	if masterradio ~= oldmasterradio then
		statechange = true

		if not masterradio then
			if IsValid(GUI_Main) then
				GUI_Main:SetSyncMode(false)
			end
		end

		if self.StopStreamInternal then
			self:StopStreamInternal()
		end

		if IsValid(oldmasterradio) and oldmasterradio.slavesradios then
			oldmasterradio.slavesradios[self] = nil
		end

		if IsValid(masterradio) and masterradio.slavesradios then
			masterradio.slavesradios[self] = true
		end

		if self.OnMasterradioChange then
			self:OnMasterradioChange(masterradio, oldmasterradio)
		end
	end

	self.old.masterradio = masterradio
	if not masterradio then return end

	local this_st = self.StreamObj
	if not IsValid(this_st) then return end

	local master_st = masterradio.StreamObj
	if not IsValid(master_st) then return end

	self:SetPlaybackLoopMode(masterradio:GetPlaybackLoopMode())

	local name = master_st:GetStreamName()
	local url = master_st:GetURL()
	local playingstate = master_st:GetPlayingState()

	if name ~= this_st:GetStreamName() then
		this_st:SetStreamName(name)
		statechange = true
	end

	if url ~= this_st:GetURL() or statechange then
		this_st:SetURL(url)
		this_st:Update()
		statechange = true
	end

	this_st:SetPlayingState(playingstate)

	if statechange and IsValid(GUI_Main) then
		GUI_Main:SetSyncMode(true)

		GUI_Main:EnablePlaylist(false)
		GUI_Main:Play(name, url)
	end

	if SERVER then
		if statechange then
			self._lastMasterTime = nil
		end

		local targettime = master_st:GetMasterTime()
		local tickInterval = engine.TickInterval()

		local lastTargetTime = self._lastMasterTime;
		self._lastMasterTime = targettime

		local masterDelta = nil
		if lastTargetTime then
			masterDelta = math.abs(targettime - lastTargetTime)
		end

		local maxThisDelta = tickInterval * 2
		local maxMasterDelta = tickInterval * 4
		local realTime = RealTime()

		if statechange or (self._trySetTimeAgain and realTime > self._trySetTimeAgain) or (not masterDelta or masterDelta > maxMasterDelta) then
			this_st:SetTime(targettime, true)

			local thisCurtime = this_st:GetMasterTime()
			local thisDelta = math.abs(thisCurtime - targettime)

			if thisDelta > maxThisDelta then
				self._trySetTimeAgain = realTime + tickInterval * 8
			else
				self._trySetTimeAgain = nil
			end
		end
	end

	self._supermasterradio = nil
end

function ENT:PlaybackLoopModeThink()
	if not self._callUpdatePlaybackLoopMode then
		return
	end

	self:UpdatePlaybackLoopMode()
end

function ENT:PanelThink()
	local GUI_Main = self.GUI_Main

	if not IsValid(GUI_Main) then
		return
	end

	local GUI_Main_Browser = GUI_Main.Browser
	if not IsValid(GUI_Main_Browser) then
		return
	end

	local ToolButton = GUI_Main_Browser.ToolButton
	local WireButton = GUI_Main_Browser.WireButton

	if IsValid(ToolButton) then
		local hasTool = self:GetToolMode()
		ToolButton:SetEnabled(hasTool)
	end

	if IsValid(WireButton) then
		local hasWire = self:GetWireMode()
		WireButton:SetEnabled(hasWire)
	end
end

function ENT:OnToolButtonClick()
	local hasTool = self:GetToolMode()
	if not hasTool then return end
	if not self.OnToolMode then return end

	self:OnToolMode()
end

function ENT:OnWireButtonClick()
	local hasWire = self:GetWireMode()
	if not hasWire then return end
	if not g_isWiremodLoaded then return end
	if not self.OnWireMode then return end

	self:OnWireMode()
end

function ENT:StreamStopAnimModel()
	if not self.AnimStopped then
		if CLIENT then
			self:CallModelFunction("Speaker")
			self:CallModelFunction("Beat")
			self:CallModelFunction("FFT")
			self:CallModelFunction("SoundLevel")
		end

		self:CallModelFunction("AnimReset")
	end

	if self.old then
		self.old.beatlevel = nil
	end

	self.AnimStopped = true
end

function ENT:OnGUISetup(...)
	BaseClass.OnGUISetup(self, ...)

	local GUI_Main = self.GUI_Main

	if not IsValid(GUI_Main) then
		return
	end

	GUI_Main.OnPlaybackLoopModeChange = function(this, newLoopMode)
		if not IsValid(self) then return end
		self:SetPlaybackLoopMode(newLoopMode)
	end

	self:MarkForUpdatePlaybackLoopMode()
end

function ENT:OnModelSetup()
	self.AnimStopped = nil
	self:StreamStopAnimModel()
end

function ENT:OnRemoveShared()
end

--PATH lua/entities/slave.lua:
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Type = "vehicle"
ENT.Base = "fighter_base"

ENT.PrintName = "Slave One"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Empire"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = true;
ENT.AdminOnly = true;

ENT.EntModel = "models/firespray/firespray1.mdl"
ENT.Vehicle = "Slave"
ENT.StartHealth = 7000;
ENT.Allegiance = "Empire";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/slave_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),FireMode = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("slave");
	e:SetPos(tr.HitPos + Vector(0,0,175));
	e:SetAngles(Angle(-90,pl:GetAimVector():Angle().Yaw-180,0));
	e:Spawn();
	e:Activate();
	return e;
end


function ENT:Initialize()
	
	self:SetNWInt("Health",self.StartHealth);
	self.CanRoll = true;
	self.CanBack = true;
	self.WeaponLocations = {
		Left = self:GetPos()+self:GetForward()*60+self:GetUp()*70+self:GetRight()*-40,
		Right = self:GetPos()+self:GetForward()*60+self:GetUp()*70+self:GetRight()*40,
	}
	self.WeaponsTable = {};
	//self:SpawnWeapons();
	self.BoostSpeed = 3000;
	self.ForwardSpeed = 1500;
	self.UpSpeed = 600;
	self.AccelSpeed = 10;
	self.HasWings = true;
	self.ExitModifier = {x=0,y=-100,z=0};
	self.DontOverheat = true;
	self.FireDelay = 0;
	self.Bullet = CreateBulletStructure(180,"red");
	self.CanShoot = true;
	self.AlternateFire = true;
	self.FireGroup = {"Left","Right"}
	self.TakeOffVector = Vector(0,0,300);
	
	self:TestLoc(self:GetPos()+self:GetForward()*-150+self:GetUp()*407.5+self:GetRight()*60);

	self.BaseClass.Initialize(self)
	
	self:SetSkin(1);
end



function ENT:Enter(p)

	self.EnterAngles = Angle(0,self:GetAngles().y,self:GetAngles().r);
	
	self.BaseClass.Enter(self,p);
	
end

function ENT:Think()
	self.BaseClass.Think(self);
	if(self.Inflight) then
		if(IsValid(self.Pilot)) then

			self.LandAngles = Angle(-90,self:GetAngles().y,0);
		end
	end

end

end

if CLIENT then
	local Booster = Material("sprites/slave_engine");
	function ENT:Draw() 
		self:DrawModel()
	end
	
	ENT.EnginePos = {}
	ENT.Sounds={
		Engine=Sound("vehicles/slave1_fly_loop.wav"),
	}
	
	local Health = 0;
	ENT.NextView = CurTime();
	ENT.CanFPV = true;
	function ENT:Think()
		self.BaseClass.Think(self);
		
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local IsFlying = p:GetNWBool("Flying"..self.Vehicle);
		local Wings = self:GetNWBool("Wings");
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		if(Flying) then
			Health = self:GetNWInt("Health");
			if(!TakeOff and !Land) then
				self:FlightEffects();
			end
		end
		
		
	end	
	function ENT:FlightEffects()
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		local p = LocalPlayer()		
		local FWD = self:GetForward();
		local id = self:EntIndex();
		
		self.EnginePos = {
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*315+self:GetRight()*45,
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*315+self:GetRight()*-45,
			
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*407.5+self:GetRight()*50,
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*407.5+self:GetRight()*40,
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*407.5+self:GetRight()*30,
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*407.5+self:GetRight()*20,
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*407.5+self:GetRight()*10,
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*407.5,
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*407.5+self:GetRight()*-10,
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*407.5+self:GetRight()*-20,
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*407.5+self:GetRight()*-30,
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*407.5+self:GetRight()*-40,
			self:GetPos()+self:GetForward()*-152.5+self:GetUp()*407.5+self:GetRight()*-50,
		}
		
		

		for k,v in pairs(self.EnginePos) do	
			local size = 39;
			if(k > 2) then
				size = 30;
			end
			local red = self.FXEmitter:Add("sprites/orangecore1",v)
			red:SetVelocity(normal)
			//red:SetDieTime(0.035)
			red:SetDieTime(FrameTime()*1.25)
			red:SetStartAlpha(255)
			red:SetEndAlpha(255)
			red:SetStartSize(size)
			red:SetEndSize(size*0.75)
			red:SetRoll(roll)
			red:SetColor(255,255,255)
					
			
			local dynlight = DynamicLight(id + 4096 * k);
			dynlight.Pos = v+FWD*-25;
			dynlight.Brightness = 5;
			dynlight.Size = 100;
			dynlight.Decay = 1024;
			dynlight.R = 255;
			dynlight.G = 128;
			dynlight.B = 0;
			dynlight.DieTime = CurTime()+1;

		end
	
	end
    
    ENT.ViewDistance = 1000;
    ENT.ViewHeight = 500;
    ENT.FPVPos = Vector(10,0,400);
	
	local HUD = surface.GetTextureID("vgui/slave_cockpit")
	function SlaveReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingSlave");
		local self = p:GetNWEntity("Slave");
		

		if(Flying and IsValid(self)) then
			local FPV = self:GetFPV();
			
			if(FPV) then
				SW_HUD_FPV(HUD);
				SW_HUD_WingsIndicator("slave1");
			end
			SW_HUD_DrawHull(7000);
			SW_WeaponReticles(self);
			
			local x = ScrW()/4*1.15;
			local y = ScrH()/4*3.25;
			SW_HUD_Compass(self,x,y);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "SlaveReticle", SlaveReticle)

end
--PATH gamemodes/starwarsrp/entities/entities/spawned_weapon/cl_init.lua:
include("shared.lua")

local color_red = Color(140, 0, 0, 100)
local color_white = color_white

function ENT:Draw()
    local ret = hook.Call("onDrawSpawnedWeapon", nil, self)
    if ret ~= nil then return end
    self:DrawModel()

    local amount = self:Getamount()
    if amount == 1 then return end

    local Pos = self:GetPos()
    local Ang = self:GetAngles()
    local text = DarkRP.getPhrase("amount") .. amount

    surface.SetFont("HUDNumber5")
    local TextWidth = surface.GetTextSize(text)

    Ang:RotateAroundAxis(Ang:Forward(), 90)

    cam.Start3D2D(Pos + Ang:Up(), Ang, 0.11)
        draw.WordBox(2, 0, -40, text, "HUDNumber5", color_red, color_white)
    cam.End3D2D()

    Ang:RotateAroundAxis(Ang:Right(), 180)

    cam.Start3D2D(Pos + Ang:Up() * 3, Ang, 0.11)
        draw.WordBox(2, -TextWidth, -40, text, "HUDNumber5", color_red, color_white)
    cam.End3D2D()
end

--[[---------------------------------------------------------------------------
Create a shipment from a spawned_weapon
---------------------------------------------------------------------------]]
properties.Add("createShipment",
    {
        MenuLabel   =   DarkRP.getPhrase("createshipment"),
        Order       =   2003,
        MenuIcon    =   "icon16/add.png",

        Filter      =   function(self, ent, ply)
                            if not IsValid(ent) then return false end
                            return ent.IsSpawnedWeapon
                        end,

        Action      =   function(self, ent)
                            if not IsValid(ent) then return end
                            RunConsoleCommand("darkrp", "makeshipment", ent:EntIndex())
                        end
    }
)

--[[---------------------------------------------------------------------------
Interface
---------------------------------------------------------------------------]]
DarkRP.hookStub{
    name = "onDrawSpawnedWeapon",
    description = "Draw spawned weapons.",
    realm = "Client",
    parameters = {
        {
            name = "weapon",
            description = "The weapon to perform drawing operations on.",
            type = "Player"
        }
    },
    returns = {
        {
            name = "value",
            description = "Return a value to completely override drawing",
            type = "any"
        }
    }
}

--PATH addons/[miecze] moce i hilty/lua/entities/star_metor/cl_init.lua:
return gluapack()()
--PATH lua/entities/tfa_ammo_base.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "AmmoBase"
ENT.Category = "TFA Ammunition"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Class = ""
ENT.MyModel = "models/props_junk/popcan01a.mdl"
ENT.ImpactSound = "Default.ImpactSoft"
ENT.AmmoCount = 100
ENT.AmmoType = "357"
ENT.TextPosition = Vector(-2.5, -3.3, 4)
ENT.TextAngles = Vector(48, -90, 0)
ENT.TextColor = Color(240, 35, 35, 255)
ENT.DrawText = false
ENT.ShouldDrawShadow = true
ENT.ImpactSound = "Default.ImpactSoft"
ENT.DamageThreshold = 80
ENT.ExplosionOffset = Vector(0, 0, 10)
ENT.Damage = 30
ENT.TextOffX = 30
ENT.TextOffY = -20
ENT.TextScale = 1

if SERVER then
	AddCSLuaFile()

	function ENT:SpawnFunction(ply, tr, classname)
		if (not tr.Hit) then return end
		local pos = tr.HitPos + tr.HitNormal * 4
		local ent = ents.Create(classname)
		ent:SetPos(pos)
		ent:Spawn()
		ent:Activate()
		ent.Class = classname
		ent.Spawner = ply

		return ent
	end

	function ENT:Initialize()
		local model = self.MyModel
		self.Class = self:GetClass()
		self:SetModel(model)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:DrawShadow(self.ShouldDrawShadow)
		self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
		self:SetUseType(SIMPLE_USE)
		self:SetHealth(self.DamageThreshold)
		self:SetNW2Bool("ShouldRemove", false)
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()
		end
	end

	function ENT:PhysicsCollide(data, physobj)
		if (data.Speed > 60 and data.DeltaTime > 0.2) then
			self:EmitSound(self.ImpactSound)
		end
	end

	function ENT:Use(activator, caller)
		if IsValid(activator) and activator:IsPlayer() then
			activator:GiveAmmo(self.AmmoCount, self.AmmoType)
			self:SetNW2Bool("ShouldRemove", true)
		end
	end

	local bul = {}
	local randvec = Vector(0, 0, 0)
	bul.Tracer = 3
	bul.Num = 1
	bul.TracerName = "Tracer"
	bul.Spread = Vector(0, 0, 0)

	local cv_dc = GetConVar("sv_tfa_ammo_detonation_chain")
	local cv_dm = GetConVar("sv_tfa_ammo_detonation_mode")
	function ENT:OnTakeDamage(dmginfo)
		if not IsValid(self) then return end
		local at = dmginfo:GetInflictor()
		local shouldtakedamage = true

		if IsValid(at) then
			local base = at.Base

			if (base and string.find(base, "tfa_ammo_base")) or string.find(at:GetClass(), "tfa_ammo_") and not cv_dc:GetBool() then
				shouldtakedamage = false
			end
		end

		if dmginfo:GetDamage() < 1 then
			shouldtakedamage = false
		end

		self.Attacker = at

		if shouldtakedamage then
			self:SetHealth(self:Health() - dmginfo:GetDamage())
		end

		self:EmitSound(self.ImpactSound)
		local phy = self:GetPhysicsObject()

		if IsValid(phy) then
			local f = dmginfo:GetDamageForce()
			local p = dmginfo:GetDamagePosition()

			if f and p then
				phy:ApplyForceOffset(f / 4, p)
			end
		end
	end

	function ENT:Think()
		if self:GetNW2Bool("ShouldRemove", false) then
			self:Remove()

			return false
		end

		if not cv_dc:GetBool() then return true end

		if self:Health() <= 0 then
			self:EmitSound(self.ImpactSound)
			local adm = cv_dm:GetInt()
			bul.AmmoType = self.AmmoType
			bul.Damage = self.Damage
			bul.Force = math.Max(self.Damage / 25, 0.1)
			bul.Attacker = self

			if IsValid(self.Attacker) then
				bul.Attacker = self.Attacker
			end

			local upang = self:GetAngles():Up()
			bul.Dir = upang + randvec * 0.75
			local numbuls = math.random(math.Round(self.AmmoCount * 0.25), math.Round(self.AmmoCount * 0.75))
			local i = 1

			if adm == 2 then
				bul.Damage = bul.Damage / 2
			end

			bul.Dir = (upang + randvec * 0.75):GetNormalized()
			bul.Src = self:GetPos()
			self:FireBullets(bul)

			if adm ~= 1 then
				while i <= math.Clamp(numbuls, 1, 35) do
					randvec.x = math.Rand(-1, 1)
					randvec.y = math.Rand(-1, 1)
					randvec.z = math.Rand(-1, 1)
					bul.Dir = (upang + randvec * 0.75):GetNormalized()
					bul.Src = self:GetPos()
					self:FireBullets(bul)
					i = i + 1
				end
			end

			local effectdata = EffectData()
			effectdata:SetOrigin(self:GetPos())
			effectdata:SetMagnitude(0.1)
			effectdata:SetScale(0.5)

			if adm == 1 then
				bul.Damage = bul.Damage * 3 / 4
			end

			if adm > 0 then
				util.BlastDamage(bul.Attacker, bul.Attacker, bul.Src, (bul.Damage * 6 + 128) / 2, bul.Damage * 2)
				util.Effect("Explosion", effectdata)
			end

			if adm ~= 1 then
				util.Effect("cball_explode", effectdata)
			end

			self:SetNW2Bool("ShouldRemove", true)
		end
	end
end

if CLIENT then
	function ENT:Initialize()
		self.Class = self:GetClass()
	end

	function ENT:Draw()
		self:DrawModel()

		if self.TextPosition and self.TextAngles and self.DrawText then
			local pos = self:GetPos() + (self:GetUp() * self.TextPosition.z) + (self:GetRight() * self.TextPosition.x) + (self:GetForward() * self.TextPosition.y)
			local ang = self:GetAngles()
			ang:RotateAroundAxis(ang:Right(), self.TextAngles.x)
			ang:RotateAroundAxis(ang:Up(), self.TextAngles.y)
			ang:RotateAroundAxis(ang:Forward(), self.TextAngles.z)

			if not self.Text then
				self.Text = string.upper(self.AmmoType)
			end

			cam.Start3D2D(pos, ang, .07 * self.TextScale)
			draw.SimpleText(self.Text, "DermaLarge", self.TextOffX, self.TextOffY, self.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			cam.End3D2D()
		end
	end
end

--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_incendiary.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.Spawnable = false

function ENT:Draw()
self:DrawModel()
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_incendiary.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:DrawShadow( true )
	end
	self:EmitSound("weapons/tfa_starwars/Incendiary_Charge_01.wav")
	self.ActiveTimer = CurTime() + 1
	self.IgniteEnd = 0
	self.IgniteEndTimer = CurTime()
	self.IgniteStage = 0
	self.IgniteStageTimer = CurTime()
	ParticleEffectAttach("incgrenade_thrown_trail",PATTACH_POINT_FOLLOW,self,1)
	self:PhysicsInitSphere( 8 )
end

function ENT:PhysicsCollide( data,phys )
	if SERVER and self.ActiveTimer > CurTime() || data.Speed >= 2000 then
		self:EmitSound( "TFA_CSGO_SmokeGrenade.Bounce" )
	end
	local ang = data.HitNormal:Angle()
	ang.p = math.abs( ang.p )
	ang.y = math.abs( ang.y )
	ang.r = math.abs( ang.r )
	
	if ang.p > 90 or ang.p < 60 then
		self.Entity:EmitSound(Sound("TFA_CSGO_SmokeGrenade.Bounce"))
	else
		if SERVER then
			local molotovfire = ents.Create( "tfa_battlefront_fire_2" )
			molotovfire:SetPos( self:GetPos() )
			molotovfire:SetOwner( self.Owner )
			molotovfire:Spawn()
			timer.Simple( 8, function()
				if IsValid( molotovfire ) then
					molotovfire:Remove()
				end
			end )
			
			local molotovfire = ents.Create( "tfa_battlefront_fire_1" )
			local pos = self:GetPos()
			molotovfire:SetPos( self:GetPos() )
			molotovfire:SetOwner( self.Owner )
			molotovfire:SetCreator( self )
			molotovfire:Spawn()
			timer.Simple( 8, function()
				if IsValid( molotovfire ) then
					molotovfire:Remove()
				end
			end )
			
			self:SetMoveType( MOVETYPE_NONE )
			self:SetSolid( SOLID_NONE )
			self:PhysicsInit( SOLID_NONE )
			self:SetCollisionGroup( COLLISION_GROUP_NONE )
			self:SetRenderMode( RENDERMODE_TRANSALPHA )
			self:SetColor( Color( 255, 255, 255, 0 ) )
			self:DrawShadow( false )
			self:StopParticles()
		end
		self:EmitSound("TFA_CSGO_IncGrenade.Start")
		self.IgniteEnd = 1
		self.IgniteEndTimer = CurTime() + 7
		self.IgniteStage = 1
		self.IgniteStageTimer = CurTime() + 0.1
	end
end

function ENT:OnRemove()
	if SERVER then
		self:StopSound( "TFA_CSGO_Inferno.Loop" )
		self:EmitSound( "TFA_CSGO_Inferno.FadeOut" )
	end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_smoke.lua:
return gluapack()()
--PATH lua/entities/tfa_exp_base/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end

function ENT:IsTranslucent()
	return true
end
--PATH lua/entities/tfa_exp_contact.lua:
return gluapack()()
--PATH lua/entities/tfbow_arrow/shared.lua:
return gluapack()()
--PATH lua/entities/tfbow_arrow_stuck/cl_init.lua:
return gluapack()()
--PATH lua/entities/training_orb/cl_init.lua:
return gluapack()()
--PATH lua/entities/turbolaser2/cl_init.lua:
include("shared.lua")
util.PrecacheModel("models/kingpommes/starwars/venator/turbolaser_bolt2.mdl")

function ENT:Initialize()
    self.bolt = ClientsideModel("models/kingpommes/starwars/venator/turbolaser_bolt2.mdl",RENDERGROUP_BOTH)
  
end

function ENT:Draw()
    --self:DrawModel()
end

function ENT:Think()
    self.bolt:SetPos(self:GetPos())
    self.bolt:SetAngles(self:GetAngles())
    if ! self:IsValid() then
        self.bolt:Remove()
    end
end

function ENT:OnRemove()
    self.bolt:Remove()
end

language.Add("turbolaser", "Turbolaser")

/*
    - Fixed a bug where an error would be displayed.
*/

--PATH lua/effects/aq_tracer.lua:
return gluapack()()
--PATH lua/effects/arccw_muzzleeffect.lua:
function EFFECT:Init(data)
    local pos = data:GetOrigin()
    local wpn = data:GetEntity()

    if !IsValid(wpn) then return end

    local muzzle = wpn.MuzzleEffect
    local overridemuzzle = wpn:GetBuff_Override("Override_MuzzleEffect")

    local gmmuzzle = wpn:GetBuff_Override("Override_GMMuzzleEffect") or wpn.GMMuzzleEffect

    muzzle = overridemuzzle or muzzle

    if wpn.GetInUBGL and wpn:GetInUBGL() then
        muzzle = wpn:GetBuff_Override("UBGL_MuzzleEffect") or muzzle
    end

    if ArcCW.ConVars["fastmuzzles"]:GetBool() then
        muzzle = wpn.FastMuzzleEffect or "CS_MuzzleFlash"

        gmmuzzle = true

        if overridemuzzle then
            muzzle = nil
        end

        muzzle = wpn:GetBuff_Override("Override_FastMuzzleEffect") or muzzle
    end

    local att = data:GetAttachment() or 1

    local wm = false

    local Owner = wpn:GetOwner()
    if (LocalPlayer():ShouldDrawLocalPlayer() or Owner != LocalPlayer()) and !wpn.AlwaysWM then
        wm = true
        att = 1
    end

    if Owner != LocalPlayer() and !ArcCW.ConVars["muzzleeffects"]:GetBool() then
        return
    end

    local mdl = wpn:GetMuzzleDevice(wm)
    local parent = mdl

    if !wm then
        parent = LocalPlayer():GetViewModel()
    end

    if !IsValid(mdl) then return end

    pos = (mdl:GetAttachment(att) or {}).Pos
    ang = (mdl:GetAttachment(att) or {}).Ang

    if gmmuzzle then
        if muzzle then
            if !pos then return end

            local fx = EffectData()

            fx:SetOrigin(pos)
            fx:SetEntity(parent)
            fx:SetAttachment(att)
            fx:SetNormal((ang or Angle(0, 0, 0)):Forward())
            fx:SetStart(pos)
            fx:SetScale(1)

            util.Effect(muzzle, fx)
        end
    else
        if muzzle then
            ParticleEffectAttach(muzzle, PATTACH_POINT_FOLLOW, mdl, att)
        end
    end

    if !pos then return end

    if !ArcCW.ConVars["fastmuzzles"]:GetBool() and !wpn.NoFlash
            and !wpn:GetBuff_Override("Silencer")
            and !wpn:GetBuff_Override("FlashHider") then
        local light = DynamicLight(self:EntIndex())
        local clr = wpn:GetBuff_Override("Override_MuzzleFlashColor", wpn.MuzzleFlashColor) or Color(244, 209, 66)
        if (light) then
            light.Pos = pos
            light.r = clr.r
            light.g = clr.g
            light.b = clr.b
            light.Brightness = 2
            light.Decay = 2500
            light.Size = Owner == LocalPlayer() and 256 or 128
            light.DieTime = CurTime() + 0.1
        end
    end
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    return false
end
--PATH lua/effects/asa6_tracer.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/astw2_swrc_explosion_flash_grenade/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 255
            light.g = 200
            light.b = 100
            light.Brightness = 5
            light.Decay = 10
            light.Size = 324
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/swbf/explosion", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.7 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(50,75) )
    particle:SetEndSize( math.Rand(100,175) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-3,3) )
    particle:SetColor( 200, 255, 150 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )

    for i = 0,1 do
        particle = emitter:Add( "effects/swbf/flare4" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.5) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(50,75) )
        particle:SetEndSize( math.Rand(200,400) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 200,155,100 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "sprites/heatwave", self.Origin )
        particle:SetAirResistance( 0 )
        particle:SetDieTime( 1.5 )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 255 )
        particle:SetStartSize( 250 ) 
        particle:SetEndSize( 0 )
        particle:SetRoll( math.Rand(180,480) )
        particle:SetRollDelta( math.Rand(-5,5) )
        particle:SetColor( 255, 255, 255 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/astw2_swrc_wookie_rl_explosion/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 200
            light.g = 85
            light.b = 175
            light.Brightness = 8
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/swrc/explosion", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.7 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(50,75) )
    particle:SetEndSize( math.Rand(200,350) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-3,3) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )

    for i = 0,5 do
        particle = emitter:Add( "effects/swrc/DirtCloud_V2" , self.Origin )

        particle:SetVelocity( 750 * VectorRand() )
        particle:SetDieTime( math.Rand(0.5, 1.5) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(100,200) )
        particle:SetEndSize( math.Rand(250,300) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 155,155,155 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( true )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "effects/swrc/p_shockwave", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(300,375) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 200,255,100 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/bactanade/init.lua:
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)
	for i=1, 10 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity( VectorRand():GetNormalized()*math.Rand(150, 300) )
			if i <= 5 then 
				particle:SetDieTime( 60 )
			end
			particle:SetStartAlpha( math.Rand( 66, 166 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 120 )
			particle:SetEndSize( 340 )
			particle:SetRoll( math.Rand(0, 360) )
			particle:SetRollDelta( math.Rand(-1, 1)/3 )
			particle:SetColor( 125, 255, 255 ) 
			particle:SetAirResistance( 82 ) 
			//particle:SetGravity( Vector(math.Rand(-30, 30),math.Rand(-30, 30), -200 )) 	
			particle:SetCollide( true )
			particle:SetBounce( 1 )
		end
	end

end

function EFFECT:Think()
return false
end

function EFFECT:Render()

end
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/cod2019_effect_semtex.lua:
return gluapack()()
--PATH lua/effects/cod2019_effect_semtex.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	local dlight = DynamicLight(data:GetEntity():EntIndex())
	self.Attachment = data:GetAttachment() or 1
	
	dlight.pos = data:GetOrigin()
	dlight.r = 255
	dlight.g = 15
	dlight.b = 15
	dlight.brightness = -1
	dlight.Decay = 1000
	dlight.Size = 256
	dlight.DieTime = CurTime() + 0.1

    sound.Play("Cod2019.Semtex.Beep", data:GetOrigin())
    ParticleEffectAttach("semtex_beep_flare", PATTACH_POINT_FOLLOW, data:GetEntity(), self.Attachment)

    self:SetNoDraw(true)
end

function EFFECT:Think()
    return false
end
--PATH lua/effects/cod2019_tracer_fast/init.lua:
return gluapack()()
--PATH lua/effects/cod2019_tracer_small/init.lua:
EFFECT.TracerName = "mw2019_tracer_small"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    local hit = data:GetOrigin()
    local wep = data:GetEntity()
    if !IsValid(wep) then return end
	local start = (wep.GetTracerOrigin and wep:GetTracerOrigin()) or data:GetStart()
    self.Attachment = data:GetAttachment() or 1

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.StartPos = start
    self.EndPos = hit
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_ABSORIGIN, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.StartPos)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(1.2, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--PATH lua/effects/csgo_muzzle_assaultrifle_silenced/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_awp/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_para/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_pistol_elite/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_pistol_elite"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_trail/init.lua:
return gluapack()()
--PATH lua/effects/effect_astw2_swrc_laser_green/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swrc/wookie_bolt" );
local MaterialFront			= Material( "effects/swrc/a_flashgreen" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 10, 10, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 10, 0, 1, color_white );
	
end

--PATH lua/effects/effect_sw_impact_2/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/sw_laser_bit" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 32 do

			local particle = emitter:Add( "effects/sw_laser_bit", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );

		end
		emitter:Finish();
	end
	
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			local smokeTexture	= "effects/awoi_musket_smoke_01"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(1, 3));
			particle_s:SetStartAlpha(150);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(10, 20));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
	
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--PATH lua/effects/effect_sw_laser_green_long/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6000
EFFECT.Length				= 250
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 200

local MaterialMain			= Material( "effects/sw_laser_green_main" )
local MaterialFront			= Material( "effects/sw_laser_green_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/effect_sw_laser_green_sniper/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_red_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_red_main")
local MaterialFront = Material("effects/sw_laser_red_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/effect_sw_laser_red_long/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_white/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_white_main" );
local MaterialFront			= Material( "effects/sw_laser_white_front" );
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_block_active.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_effects.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

EFFECT.mat2 = Material( "sprites/heatwave" )

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()

	self.LifeTime = 1
	self.DieTime = CurTime() + self.LifeTime
	self.mat = Material( "particle/smokesprites_000"..math.random(1,9) )
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

function EFFECT:Render()
	if not IsValid( self.Ent ) then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime

	render.SetMaterial( self.mat )
	render.DrawSprite( self.Ent:LocalToWorld( self.Ent:OBBCenter() ), 150 * Scale, 150 * Scale, Color( 150,200,255,50 * Scale ) )
	render.SetMaterial( self.mat2 )
	render.DrawSprite( self.Ent:LocalToWorld( self.Ent:OBBCenter() ), 100 * Scale, 100 * Scale, Color( 255,255,255,255 ) )
end
	

--PATH addons/[miecze] moce i hilty/lua/effects/force_judgement_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos - Dir * 5,
		endpos = Pos + Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.4,0.8), math.Rand(0.4,0.8) )
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * math.Rand(120,140)
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.5 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 255, 255 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	self.Emitter = emitter
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		if self.Emitter then
			self.Emitter:Finish()
		end

		if self.snd then
			self.snd:Stop()
		end

		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")
function EFFECT:Render()
	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.mat )
		render.DrawSprite( self.Pos, 24 * Scale, 24 * Scale, Color( 255, 201, 150) )
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_judgementii.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningiii.lua:

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid( self.Ent ) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625
		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

local BeamMat = Material( "trails/electric" )
local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	if IsValid( self.Ent ) then

		local boneID = self.Ent:LookupBone( "ValveBiped.Bip01_L_Hand" )

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos
	
				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 179 --EDİT
					dlight.g = 0 --EDİT
					dlight.b = 255 --EDİT
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end


			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(200,600)

			local trace = util.TraceLine( { start = StartPos, endpos = EndPos, filter = self.Ent} )

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
						effectdata:SetNormal( -trace.HitNormal )
					util.Effect( "force_lightningiii_hit", effectdata )

					if math.random(1,3) == 3 then

						local dlight = DynamicLight( self.Ent:EntIndex() + math.random(100,9999) )
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 179 --EDİT
							dlight.g = 0 --EDİT
							dlight.b = 255 --EDİT
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end

						self:EmitSound("lscs/force/lightninghit"..math.random(1,3)..".mp3")
					end
				end
			end

			render.SetMaterial( mat )
			render.DrawSprite( StartPos, 64, 64, Color( 179, 0, 255) ) --Elden Cikan Yes
			render.DrawSprite( StartPos, 16, 16, Color( 179, 0, 255, 255) ) --Bilmiyorum

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial( BeamMat )

			render.DrawBeam( BeamStart, BeamEnd, 18, 0, 1, Color( 106, 0, 255) ) --Az Elektrik

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 179, 0 + 150 * Width, 255, 255 ) ) --Etraftaki Cok Fazla Elektrik

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 106, 0, 255, 255 ) ) --Aradakilerin yarisi 
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 179, 0, 255) ) --Kalanlar

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningiv_hit.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_push.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE


EFFECT.mat = Material( "sprites/heatwave" )
EFFECT.mat2 = Material( "effects/select_ring" )
EFFECT.mat3 = Material( "particle/smokesprites_0001" )

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then self.Ready = true return end

	self.Pos = self.Ent:GetShootPos()
	self.Dir = data:GetNormal()
	self.mat3 = Material( "particle/smokesprites_000"..math.random(1,9) )

	self.Ready = true
end

function EFFECT:Think()
	if not self.Ready then return true end

	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

function EFFECT:Render()
	if not self.Ready or not IsValid( self.Ent ) then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local InvScale =  (1 - Scale)

	render.SetMaterial( self.mat3 )
	render.DrawSprite( self.Pos + self.Dir * 200 * InvScale, 100 * Scale, 100 * Scale, Color( 150,200,255,50 ) )

	for i = 1, 3 do
		local Scale = (self.DieTime - CurTime()) / self.LifeTime / 3 * i

		local Pos = self.Pos + self.Dir * 200 * InvScale

		render.SetMaterial( self.mat )
		render.DrawSprite( Pos, 150 *  InvScale, 150 *  InvScale, Color( 255,255,255,255 ) )
	end
end
	

--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/lvs_bullet_impact.lua:
return gluapack()()
--PATH lua/effects/lvs_exhaust.lua:
return gluapack()()
--PATH lua/effects/lvs_laser_blue_short.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 300 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color( 0, 0, 255, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--PATH lua/effects/lvs_laser_charge.lua:

EFFECT.HeatWaveMat = Material( "particle/warp1_warp" )
EFFECT.GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.ID = data:GetAttachment()

	if not IsValid( self.Ent ) then return end

	
	local att = self.Ent:GetAttachment( self.ID )

	if not att then return end

	local Pos = att.Pos

	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	self.Emitter = ParticleEmitter( Pos, false )
	self.Particles = {}
end

function EFFECT:Think()
	if (self.DieTime or 0) < CurTime() or not IsValid( self.Ent ) then 
		if IsValid( self.Emitter ) then
			self.Emitter:Finish()
		end

		return false
	end

	self:DoSpark()

	return true
end

function EFFECT:DoSpark()
	local T = CurTime()

	if (self._Next or 0) > T then return end

	self._Next = T + 0.01

	if not IsValid( self.Emitter ) then return end

	if not IsValid( self.Ent ) or not self.ID then return end

	local att = self.Ent:GetAttachment( self.ID )

	if not att then return end

	local Pos = att.Pos
	local Dir = VectorRand() * 25

	for id, particle in pairs( self.Particles ) do
		if not particle then
			self.Particles[ id ] = nil

			continue
		end

		particle:SetGravity( (Pos - particle:GetPos()) * 50 )
	end

	local particle = self.Emitter:Add( "sprites/rico1", Pos + Dir )

	if not particle then return end

	particle:SetDieTime( 0.25 )
	particle:SetStartAlpha( 255 )
	particle:SetEndAlpha( 0 )
	particle:SetStartSize( math.Rand( 1, 5 ) )
	particle:SetEndSize( 0 )
	particle:SetColor( 255, 0, 0 )
	particle:SetAirResistance( 0 )
	particle:SetRoll( math.Rand(-10,10) )
	particle:SetRollDelta( math.Rand(-10,10) )

	table.insert( self.Particles, particle )
end

function EFFECT:Render()
	if not IsValid( self.Ent ) or not self.ID then return end

	local att = self.Ent:GetAttachment( self.ID )

	if not att then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime

	if Scale <= 0 then return end

	local rnd = VectorRand() * math.Rand(0,0.5)

	render.SetMaterial( self.HeatWaveMat )
	render.DrawSprite( att.Pos, 30 *(1 - Scale), 30 * (1 - Scale), Color( 255, 255, 255, 255) )

	render.SetMaterial( self.GlowMat ) 
	render.DrawSprite( att.Pos + rnd, 120 *  (1 - Scale), 120 * (1 - Scale), Color(255,0,0,255) ) 
end
	

--PATH lua/effects/lvs_laser_explosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Col = data:GetStart() or Vector(255,100,0)

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( self.Col.x,self.Col.y,self.Col.z )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 20 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.15 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( 32 )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetRollDelta( math.Rand( -1, 1 ) * 100 )
			particle:SetColor( self.Col.x,self.Col.y,self.Col.z )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	if not self.Col then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 400 * Scale, Color( self.Col.x,self.Col.y,self.Col.z, 255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255, 255, 255, 255) )
end

--PATH lua/effects/lvs_laser_green.lua:
return gluapack()()
--PATH lua/effects/lvs_physics_impact.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	if not LVS.ShowPhysicsEffects then return end

	local dir = data:GetNormal()
	local pos  = data:GetOrigin() + dir

	local emitter = ParticleEmitter( pos, false )

	for i = 0, 10 do
		local particle = emitter:Add( "effects/spark", pos )

		local vel = VectorRand() * 75 + dir * 75 + Vector(0,0,100)

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetDieTime( math.Rand(2.5,5) )
		particle:SetAirResistance( 10 ) 
		particle:SetStartAlpha( 255 )

		particle:SetStartLength( 6 )
		particle:SetEndLength(0)

		particle:SetStartSize( 3 )
		particle:SetEndSize( 0 )

		particle:SetRoll( math.Rand(-5,5) )
		particle:SetColor( 255, 200, 50 )
		particle:SetGravity( Vector(0,0,-600) )
		particle:SetCollide( true )
	end

	local smoke = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )

	if smoke then
		smoke:SetVelocity( dir * 30 + VectorRand() * 15 )
		smoke:SetDieTime( math.Rand(1.5,3) )
		smoke:SetAirResistance( 100 ) 
		smoke:SetStartAlpha( 100 )
		smoke:SetEndAlpha( 0 )
		smoke:SetStartSize( 15 )
		smoke:SetEndSize( 30 )
		smoke:SetColor(30,30,30)
		smoke:SetGravity(Vector(0,0,40))
		smoke:SetCollide( false )
		smoke:SetRollDelta( math.Rand(-1,1) )
	end

	local flash = emitter:Add( "effects/yellowflare",pos )

	if flash then
		flash:SetPos( pos )
		flash:SetStartAlpha( 200 )
		flash:SetEndAlpha( 0 )
		flash:SetColor( 255, 200, 0 )
		flash:SetEndSize( 100 )
		flash:SetDieTime( 0.1 )
		flash:SetStartSize( 0 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_tracer_orange.lua:
return gluapack()()
--PATH lua/effects/lvs_walker_stomp.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	
	local emitter = ParticleEmitter( pos, false )

	for i = 1,12 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ],pos )
		
		if not particle then continue end

		local ang = i * 30
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )
			
		particle:SetVelocity( Vector(X,Y,0) * math.Rand(3000,4000) )
		particle:SetDieTime( math.Rand(0.5,1) )
		particle:SetAirResistance( math.Rand(3000,5000) ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 20 )
		particle:SetEndSize( math.Rand(30,40) )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 60,60,60 )
		particle:SetGravity( VectorRand() * 200 + Vector(0,0,1000) )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/m9k_gdcw_cinematicboom/init.lua:
return gluapack()()
--PATH lua/effects/moby_tracer.lua:
return gluapack()()
--PATH lua/effects/nrg_tracer.lua:
return gluapack()()
--PATH lua/effects/pele_tracer.lua:
return gluapack()()
--PATH lua/effects/pulsar_tracer_red.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()

	util.ParticleTracerEx( 
		"pulsar_beam_red", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH addons/[miecze] moce i hilty/lua/effects/rb655_force_lighting_explosion.lua:
return gluapack()()
--PATH lua/effects/rw_sw_dual_laser_green.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_green_main")
local MaterialFront 		= Material("effects/sw_laser_green_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_dual_laser_yellow.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_black.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_black" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(50, 250));
			particle_s:SetDieTime(math.Rand(1, 2));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(1);
			particle_s:SetStartSize(math.Rand(12, 16));
			particle_s:SetEndSize(math.Rand(0, 0));
			particle_s:SetGravity(Vector(math.Rand(-500, 500), math.Rand(-500, 500), math.Rand(-500, 500)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(60, 90);
			particle_s:SetColor(colour, colour, colour, 255);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(1500);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_impact_lightblue.lua:
local MaterialGlow		= Material( "cs574/impacts/sw_laser_bit_lightblue" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(50, 250));
			particle_s:SetDieTime(math.Rand(1, 2));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(1);
			particle_s:SetStartSize(math.Rand(12, 16));
			particle_s:SetEndSize(math.Rand(0, 0));
			particle_s:SetGravity(Vector(math.Rand(-500, 500), math.Rand(-500, 500), math.Rand(-500, 500)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(60, 90);
			particle_s:SetColor(colour, colour, colour, 255);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(1500);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_impact_white.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_white" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_laser_grey.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_grey.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_grey.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(130,150,180)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/scifi_aftershock.lua:
return gluapack()()
--PATH lua/effects/serv_passive_stun.lua:
EFFECT.BeatMat = Material( "sprites/tp_beam001" )
EFFECT.SprMat = Material( "particle/particle_ring_wave_8_15ob_nofog" )

function EFFECT:Init( data )
	self.StartPos = data:GetOrigin()
	self.Entity = data:GetEntity()
	self.FollowPlayer = self.Entity:GetPos()

	self.Duration = data:GetScale()*6
	self.HealingAm = 0

	self.Alpha = 255
	self.Life = 0

	self.Color = Color(150,150,250,255)
end

function EFFECT:Think()
	if !self.Entity:IsValid() then return end

	self.FollowPlayer = self.Entity:GetPos()+Vector(0,0,50)

	self.Life = self.Life + FrameTime() * 6

	self.Alpha = 255 * ( 1 - self.Life )

	return ( self.Life < self.Duration )
end

function EFFECT:Render()
	-- Particles

	render.SetMaterial( self.SprMat )
	render.DrawSprite( 
		self.FollowPlayer,
		math.min(self.Life*50,100)+math.random( -25, 25 ),
		math.min(self.Life*50,100)+math.random( -25, 25 ),
		self.Color
	)

	render.SetMaterial( self.BeatMat )
	for i = 1, 5 do
		local randvec = VectorRand()
		randvec.z = -2
		render.DrawBeam( 
			self.FollowPlayer + (VectorRand()*5),
			self.FollowPlayer + (randvec*(math.min(self.Life*5,50)+math.random( -15, 45 ))),
			math.random(8,14),
			5,
			3,
			self.Color
		)
	end

end
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/spr_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()

	util.ParticleTracerEx( 
		"spr_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH lua/effects/swrp_muzzleflash_blue/init.lua:
local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if self.WeaponEnt.Owner:ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	dir = self.Forward

	if IsValid(LocalPlayer()) then
		AddVel = LocalPlayer():GetVelocity()
	end

	AddVel = AddVel * 0.05
	self.vOffset = self.Position
	dir = self.Forward
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(EyeAngles():Forward())
	local dotang = math.deg(math.acos(math.abs(dot)))
	local halofac = math.Clamp(1 - (dotang / 90), 0, 1)

	if CLIENT and not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = 22
		dlight.g = 55
		dlight.b = 255
		dlight.brightness = 10
		dlight.Decay = 1000
		dlight.Size = 88
		dlight.DieTime = CurTime() + 0.5
	end

	local emitter = ParticleEmitter(self.vOffset)
	local sparticle = emitter:Add("effects/muzzleflashX_nemole_w", self.vOffset)

	if (sparticle) then
		sparticle:SetVelocity(dir * 4 + 1.05 * AddVel)
		sparticle:SetLifeTime(0)
		sparticle:SetDieTime(0.08)
		sparticle:SetStartAlpha(math.Rand(255, 255))
		sparticle:SetEndAlpha(0)
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
		sparticle:SetStartSize(4 * (halofac * 0.8 + 0.2), 0, 1)
		sparticle:SetEndSize(12 * (halofac * 0.8 + 0.2), 0, 1)
		local r = math.Rand(-10, 10) * 3.14 / 180
		sparticle:SetRoll(r)
		sparticle:SetRollDelta(r / 5)
		sparticle:SetColor(200, 200, 200)
		sparticle:SetLighting(false)
		sparticle.FollowEnt = self.WeaponEnt
		sparticle.Att = self.Attachment
		TFA.Particles.RegisterParticleThink(sparticle, TFA.Particles.FollowMuzzle)
		sparticle:SetPos(vector_origin)
	end

	for i = 1, 1 do
		local particle = emitter:Add("effects/scotchmuzzleflashw", self.vOffset)

		if (particle) then
			particle:SetVelocity(dir * 4 + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(0.10)
			particle:SetStartAlpha(math.Rand(150, 185))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(1 * (halofac * 0.8 + 0.2), 0, 1)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2))
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(-40, 40)))
			particle:SetColor(2, 60, 255)
			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for i = 0, 5 do
		local particle = emitter:Add("particles/flamelet" .. math.random(1, 5), self.vOffset + (dir * 0.6 * i))

		if (particle) then
			particle:SetVelocity((dir * 19 * i) + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(0.075)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( math.max(5.4 - 0.55 * i,1) )
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(6 - 0.35 * i, 1) * 0.55)
			particle:SetEndSize(math.max(5.4 - 0.35 * i, 1) * 1.25)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(-40, 40)))
			particle:SetColor(25, 95, 200)
			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	for i = 0, 4 do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(6, 10))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 + dir * math.Rand(15, 20) + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(math.Rand(0.6, 0.7))
			particle:SetStartAlpha(math.Rand(7, 11))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7))
			particle:SetEndSize(math.Rand(12, 14))
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(10)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(50, 50, 205)
		end
	end

	local sparkcount = math.random(8, 12)

	for i = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity((VectorRand() + Vector(0, 0, 0.3)) * 60 * Vector(0.8, 0.8, 0.6) + dir * math.Rand(80, 120) + 1.15 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(math.Rand(0.25, 0.4))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(.35)
			particle:SetEndSize(1.15)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(Vector(0, 0, -50))
			particle:SetAirResistance(40)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)
			particle:SetColor(2, 95, 255)
			particle:SetVelocityScale(true)

			particle:SetThinkFunction(function(pa)
				pa.ranvel = pa.ranvel or VectorRand() * 4
				pa.ranvel.x = math.Approach(pa.ranvel.x, math.Rand(-4, 4), 0.5)
				pa.ranvel.y = math.Approach(pa.ranvel.y, math.Rand(-4, 4), 0.5)
				pa.ranvel.z = math.Approach(pa.ranvel.z, math.Rand(-4, 4), 0.5)
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * 1.5)
				pa:SetNextThink(CurTime() + 0.01)
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		for i = 0, 3 do
			local particle = emitter:Add("sprites/heatwave", self.vOffset + (dir * i))

			if (particle) then
				particle:SetVelocity((dir * 25 * i) + 1.05 * AddVel + VectorRand() * 5)
				particle:SetLifeTime(0)
				particle:SetDieTime(math.Rand(0.05, 0.15))
				particle:SetStartAlpha(math.Rand(200, 225))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(1, 2))
				particle:SetEndSize(math.Rand(1, 5))
				particle:SetRoll(math.Rand(0, 360))
				particle:SetRollDelta(math.Rand(-2, 2))
				particle:SetAirResistance(5)
				particle:SetGravity(Vector(0, 0, 40))
				particle:SetColor(5, 95, 205)
			end
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/tfa_dust_impact/init.lua:
return gluapack()()
--PATH lua/effects/tfa_metal_impact/init.lua:
return gluapack()()
--PATH lua/effects/tfa_metal_impact/init.lua:
local gravity_cv = GetConVar("sv_gravity")
EFFECT.VelocityRandom = 0.25
EFFECT.VelocityMin = 95
EFFECT.VelocityMax = 125
EFFECT.ParticleCountMin = 4
EFFECT.ParticleCountMax = 7
EFFECT.ParticleLife = 1.3

function EFFECT:Init(data)
	self.StartPos = data:GetOrigin()
	self.Dir = data:GetNormal()
	self.LifeTime = 0.1
	self.DieTime = CurTime() + self.LifeTime
	self.PartMult = 0.2
	self.Grav = Vector(0, 0, -gravity_cv:GetFloat())
	self.SparkLife = 1
	local emitter = ParticleEmitter(self.StartPos)
	local partcount = math.random(self.ParticleCountMin, self.ParticleCountMax)

	--Sparks
	for _ = 1, partcount do
		local part = emitter:Add("effects/yellowflare", self.StartPos)
		part:SetVelocity(Lerp(self.VelocityRandom, self.Dir, VectorRand()) * math.Rand(self.VelocityMin, self.VelocityMax))
		part:SetDieTime(math.Rand(0.25, 1) * self.SparkLife)
		part:SetStartAlpha(255)
		part:SetStartSize(math.Rand(2, 4))
		part:SetEndSize(0)
		part:SetRoll(0)
		part:SetGravity(self.Grav)
		part:SetCollide(true)
		part:SetBounce(0.55)
		part:SetAirResistance(0.5)
		part:SetStartLength(0.2)
		part:SetEndLength(0)
		part:SetVelocityScale(true)
		part:SetCollide(true)
	end

	--Impact
	local part = emitter:Add("effects/yellowflare", self.StartPos)
	part:SetStartAlpha(255)
	part:SetStartSize(15 * self.PartMult)
	part:SetDieTime(self.LifeTime * 1)
	part:SetEndSize(0)
	part:SetEndAlpha(0)
	part:SetRoll(math.Rand(0, 360))
	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
return false
end

--PATH lua/effects/tfa_muzzleflash_energy/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.15
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 1
EFFECT.Color = Color(128,192,255)
EFFECT.ColorSprites = true

--PATH lua/effects/tfa_muzzleflash_fubar_aq/init.lua:
local function rvec(vec)
	vec.x=math.Round(vec.x)
	vec.y=math.Round(vec.y)
	vec.z=math.Round(vec.z)
	return vec
end

local blankvec = Vector(0,0,0)

local function partfunc(self)
	if IsValid(self.FollowEnt) then
		if self.Att then
			local angpos = self.FollowEnt:GetAttachment(self.Att)
			if angpos and angpos.Pos then
				self:SetPos(angpos.Pos)
				self:SetNextThink(CurTime())
			end
		end
	end
end
				
function EFFECT:Init( data )
	
	self.StartPacket = data:GetStart()
	self.Attachment = data:GetAttachment()

	local AddVel = vector_origin
	
	if LocalPlayer then
		if IsValid(LocalPlayer()) then
			AddVel = LocalPlayer():GetVelocity()
		end
	end
	
	if AddVel == vector_origin then
		AddVel = Entity(1):GetVelocity()
	end
	
	self.Position = data:GetOrigin()
	self.Forward = data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	
	local wepent = Entity(math.Round(self.StartPacket.z))
	
	if IsValid(wepent) then
		if wepent.IsFirstPerson and !wepent:IsFirstPerson() then
			data:SetEntity(wepent)
			self.Position = blankvec
		end
	end
	
	local ownerent = player.GetByID(math.Round(self.StartPacket.x))
	local serverside = false
	if math.Round(self.StartPacket.y)==1 then
		serverside = true
	end
	
	local ent = data:GetEntity()
	
	if serverside then
		if IsValid(ownerent) then
			if LocalPlayer() == ownerent then
				return
			end
			ent = ownerent:GetActiveWeapon()
			AddVel = ownerent:GetVelocity()
		end
	end
	
	if (!self.Position) or ( rvec(self.Position) == blankvec ) then
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		if self.WeaponEnt and IsValid(self.WeaponEnt) then
			local rpos = self.WeaponEnt:GetAttachment(self.Attachment)
			if rpos and rpos.Pos then
				self.Position = rpos.Pos
				if data:GetNormal()==vector_origin then
					self.Forward = rpos.Ang:Up()
					self.Angle = self.Forward:Angle()
					self.Right = self.Angle:Right()
				end
			end
		end
	end
	
	self.vOffset = self.Position
	dir = self.Forward
	AddVel = AddVel * 0.05

	if IsValid(ent) then
		dlight = DynamicLight(ent:EntIndex())
	else
		dlight = DynamicLight(0)	
	end
	
    if (dlight) then
        dlight.Pos              = self.Position + dir * 1 - dir:Angle():Right()*5
        dlight.r                = 0
        dlight.g                = 109
        dlight.b                = 255
        dlight.Brightness = 7.0
        dlight.size     = 128+24
        dlight.DieTime  = CurTime() + 0.03
   end
	
	ParticleEffectAttach("tfa_muzzle_fubar_aq",PATTACH_POINT_FOLLOW,ent,data:GetAttachment())
	
	--[[
	local emitter = ParticleEmitter( self.vOffset )
		for i=0, 6 do
			local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.vOffset + (dir * 1.7 * i))
			if (particle) then
				particle:SetVelocity((dir * 19 * i) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.max(7 - 0.65 * i,1) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-40, 40) )
				particle:SetColor( 255 , 218 , 97 )
				particle:SetLighting(false)
				particle.FollowEnt = data:GetEntity()
				particle.Att = self.Attachment
				particle:SetThinkFunction( partfunc )
				particle:SetNextThink(CurTime())
			end
		end
		
		for i=0, 5 do
		
			local particle = emitter:Add( "particles/smokey", self.vOffset + dir * math.Rand(6, 10 ))
			if (particle) then
				particle:SetVelocity(VectorRand() * 5 + dir * math.Rand(27,33) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( math.Rand( 0.5, 0.5 ) )
				particle:SetStartAlpha( math.Rand( 5, 15 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(8,10) )
				particle:SetEndSize( math.Rand(2,5) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-0.8, 0.8) )
				
				particle:SetAirResistance( 10 ) 
 				 
 				particle:SetGravity( Vector( 0, 0, 60 ) ) 
				
				particle:SetColor( 255 , 255 , 255 ) 
			end
			
		end
		
		if GetTFAGasEnabled() then
			for i=0, 2 do
				local particle = emitter:Add( "sprites/heatwave", self.vOffset + (dir * i) )
				if (particle) then
					particle:SetVelocity((dir * 25 * i) + 1.05 * AddVel )
					particle:SetLifeTime( 0 )
					particle:SetDieTime( math.Rand( 0.05, 0.15 ) )
					particle:SetStartAlpha( math.Rand( 200, 225 ) )
					particle:SetEndAlpha( 0 )
					particle:SetStartSize( math.Rand(3,5) )
					particle:SetEndSize( math.Rand(8,10) )
					particle:SetRoll( math.Rand(0, 360) )
					particle:SetRollDelta( math.Rand(-2, 2) )
					
					particle:SetAirResistance( 5 ) 
					
					particle.FollowEnt = data:GetEntity()
					particle.Att = self.Attachment
					particle:SetThinkFunction( partfunc )
					 
					particle:SetGravity( Vector( 0, 0, 40 ) ) 
					
					particle:SetColor( 255 , 255 , 255 ) 
				end
			end
		end
		
	emitter:Finish() 
	]]--
end 

function EFFECT:Think( )
	return false
end

function EFFECT:Render()
end

 
--PATH lua/effects/tfa_muzzleflash_shotgun/init.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_tracer_fubar_blu/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_trail_blu", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_red/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_yellow/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(218, 165, 18)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(218, 165, 18)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 218
        dlight.g = 165
        dlight.b = 18
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 300
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_red/init.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/vj_medium_dust1/init.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
function EFFECT:Init(data)
	self.Pos = data:GetOrigin()
	local Emitter = ParticleEmitter(self.Pos)
	if Emitter == nil then return end
	
	-- Cloud of smoke that goes up
	for i = 1,20 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
		EffectCode:SetVelocity(Vector(math.random(-100,100),math.random(-100,100),math.random(50,60)))
		EffectCode:SetDieTime(math.Rand(9,11)) -- How much time until it dies
		EffectCode:SetStartAlpha(150) -- Transparency
		EffectCode:SetStartSize(math.Rand(230,270)) -- Size of the effect
		EffectCode:SetEndSize(math.Rand(300,350)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
		EffectCode:SetRoll(math.Rand(480,540))
		EffectCode:SetRollDelta(math.Rand(-0.2,0.2)) -- How fast it rolls
		EffectCode:SetColor(80,60,20) -- The color of the effect
		EffectCode:SetGravity(Vector(0, 0, 0)) -- The Gravity
		EffectCode:SetAirResistance(15)
	end
	Emitter:Finish()
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Think()
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Render()
end
--PATH lua/effects/vj_weapon_pistolshell1/init.lua:
return gluapack()()
--PATH lua/effects/vj_weapon_rifleshell1/init.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/zulu_tracer_noattach.lua:
return gluapack()()
--PATH lua/prone/sh_thirdparty_compat.lua:
-- This file adds various checks and fixes depending on the gamemode and thirdparty addons.

-- Checked for prone.CanEnter depending on the gamemode.
if DarkRP or GAMEMODE_NAME == "darkrp" or GAMEMODE.DerivedFrom == "darkrp" then
	hook.Add("prone.CanEnter", "prone.CanEnterDarkRP", function(ply)
		if prone.Config.Darkrp_RestrictJobs then
			local rank = ply:GetUserGroup()
			for i, v in ipairs(prone.Config.Darkrp_BypassRanks) do
				if v == rank then
					return true
				end
			end

			local ply_darkrpjob = ply:Team()
			for i, v in ipairs(prone.Config.Darkrp_Joblist) do
				if ply_darkrpjob == v then
					if prone.Config.Darkrp_IsWhitelist then
						return true
					else
						return false
					end
				end
			end

			-- If their job was not on the list and that list was not a whitelist then they can go prone.
			return not prone.Config.Darkrp_IsWhitelist
		end

		return true
	end)

elseif GAMEMODE_NAME == "prop_hunt" or GAMEMODE.DerivedFrom == "prop_hunt" then
	hook.Add("prone.CanEnter", "prone.CanEnterPropHunt", function(ply)
		if not GetGlobalBool("InRound", false) or (GetGlobalFloat("RoundStartTime", 0) + (HUNTER_BLINDLOCK_TIME or 0)) > CurTime() or ply:Team() ~= TEAM_HUNTERS then
			return false
		else
			return true
		end
	end)

elseif Clockwork then
	hook.Add("prone.CanEnter", "prone.CanEnterClockwork", function(ply)
		return not ply:IsRagdolled()
	end)
end

-- Disable viewmodel calcview for CW2.0
hook.Add("prone.ShouldChangeCalcViewModelView", "prone.DisableForCW2", function(localply)
	if CustomizableWeaponry then
		local weapon = localply:GetActiveWeapon()
		if IsValid(weapon) and weapon.CW20Weapon then
			return false
		end
	end
end)


-- TTT Movement support
hook.Add("TTTPlayerSpeed", "prone.RestrictMovement", function(ply)
	if ply:IsProne() then
		return prone.Config.MoveSpeed / 220	-- 220 is the default run speed in TTT
	end
end)

-- CombineControl's weird chatbox support.
if CLIENT and (GAMEMODE_NAME == "combinecontrol" or GAMEMODE.DerivedFrom == "combinecontrol") then
	local lastGetUpPrintTime = 0		-- Last time a print was made.
	local getUpWarningPrintDelay = 2	-- Time it takes before allowing another print.
	function prone.CantGetUpWarning()
		local ct = CurTime()

		if lastGetUpPrintTime < ct then
			GAMEMODE:AddChat(Color(210, 10, 10, 255), "CombineControl.ChatNormal", "There isn't enough room to stand up!", {CB_ALL, CB_IC})
			lastGetUpPrintTime = ct + getUpWarningPrintDelay
		end
	end
end

-- Disable ragdolling while prone to avoid dealing with annoying stuff.
-- This is untested but honestly Im not giving any attention to a commercial, non open-source, out-dated gamemode.
hook.Add("PlayerCanRagdoll", "prone.FixClockworkRagdoll", function(ply)
	if ply:IsProne() then
		return false
	end
end)
--PATH lua/rd_claim_boards/core/sh_config.lua:
local OBJ = RDV.CLAIMBOARDS.Config()

--[[---------------------------------]]--
--  Prefix
--[[---------------------------------]]--

OBJ:SetPrefix({
    Appension = "Claim Board",
    Color = Color(255,0,0)
})

--[[---------------------------------]]--
--  Reset Settings
--[[---------------------------------]]--

OBJ:SetArrest(true) -- Should the Claimboards be reset if the claimer is arrested?

OBJ:SetDeath(true) -- Should the Claimboards be reset if the claimer is killed?

--[[---------------------------------]]--
--  Header Settings
--[[---------------------------------]]--

OBJ:SetCustomHeaders(true)

OBJ:SetDefaultHeaders({
    "FFA",
    "OOC",
    "Tryouts",
})

--[[---------------------------------]]--
--  Battalions (These can be Job Categories or Job Names)
--[[---------------------------------]]--

--[[
OBJ:AddBattalion("212th", {
    "Citizens",
}, Color(224,180,34))

OBJ:AddBattalion("501st", {
    "Gun Dealer",
}, Color(35,35,182))
--]]

--[[---------------------------------]]--
--  Admins
--[[---------------------------------]]--

OBJ:SetAdmins({
    "superadmin",
})

--[[---------------------------------]]--
--  Commands
--[[---------------------------------]]--

OBJ:SetCommands({
    Unclaim = "!unclaim", -- Unclaims the sign the Admin is looking at.
    UnclaimAll = "!unclaim_all", -- Unclaims all signs of a selected player.
})
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/test.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/zezw.lua:
local APP = {}

APP.Name = "Zezwolenia"                   -- Nazwa
APP.Restricted = true               -- Dosłownie nic nie zmienia

APP.Derma = function(parrent)
    local x,y = parrent:GetWide(),parrent:GetTall()
	local pan = vgui.Create("DPanel",parrent)
    pan:SetSize(x,y)
    pan:Center()
    pan:SetBackgroundColor(Color(0,0,0))
    local label = vgui.Create("DLabel",pan)
	label:SetText("WORK IN PROGRESS")
	label:SizeToContents()
	label:Center()
    label:SetTextColor(Color(255,255,255))

end

return APP
--PATH lua/tfres/library/drmpanel.lua:
return gluapack()()