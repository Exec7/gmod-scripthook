--Stealed clientside server code by exechack.cc
--Hostname: [PL] [PixelMod] PelugeRP SWRP | .gg/pixelmod - Part 7/10 - 06/04/2025


--PATH lua/autorun/antiplayerstuck.lua:
/*
	Created by Heox (STEAM_0:1:8901195)
*/

if !SERVER then return end

local function CheckIfPlayerStuck()
	for k,v in pairs(player.GetAll()) do
		if IsValid(v) and v:IsPlayer() and v:Alive() then
			if !v:InVehicle() then
				local Offset = Vector(5, 5, 5)
				local Stuck = false
				
				if v.Stuck == nil then
					v.Stuck = false
				end
				
				if v.Stuck then
					Offset = Vector(2, 2, 2) //This is because we don't want the script to enable when the players touch, only when they are inside eachother. So, we make the box a little smaller when they aren't stuck.
				end

				for _,ent in pairs(ents.FindInBox(v:GetPos() + v:OBBMins() + Offset, v:GetPos() + v:OBBMaxs() - Offset)) do
					if IsValid(ent) and ent != v and ent:IsPlayer() and ent:Alive() then
					
						v:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
						v:SetVelocity(Vector(-10, -10, 0) * 20)
						
						ent:SetVelocity(Vector(10, 10, 0) * 20)
						
						Stuck = true
					end
				end
			   
				if !Stuck then
					v.Stuck = false
					v:SetCollisionGroup(COLLISION_GROUP_PLAYER)
				end
			else
				v:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
			end	
		end
	end
end
timer.Create("CheckIfPlayerStuck", 0.1, 0, CheckIfPlayerStuck)


 
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/sh_k_explosives_sounds.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_top_short.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_barrel_sniper.lua:
att.PrintName = "15s Sniper Barrel"
att.Description = "Extended barrel for DC-15s."
att.SortOrder = 40
att.Desc_Pros = {}
att.Icon = Material("interfaz/armas/swrp_att_a280c_grip.png")
att.Desc_Cons = {}

att.AutoStats = true
att.Slot = "15s_barrel"
att.ActivateElements = {"15a_barrel_extended"}

att.Override_MuzzleEffect = "wpn_muzzleflash_dc17_green"
att.Override_Tracer = "tracer_green"

att.Mult_MoveSpeed = 0.9

att.Mult_MoveDispersion = 1.25
att.Mult_SightTime = 1.15
att.Mult_Range = 2.5
att.Mult_RPM = 0.5
att.Mult_Damage = 2
att.Override_AccuracyMOA = 0.1
att.Mult_ShootPitch = 0.70

--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a280cfe_powerpack.lua:
att.PrintName = "Extended-power"
att.Icon = Material("entities/kraken/sops/atts/cfepowerpack.png", "mips smooth")
att.Description = "More tibanna compression. More damage at the cost of less magazine capacity."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "cfe_powerpack"
att.ActivateElements = {"a280cfe_powerpack"}

att.Override_ClipSize = 12
att.Mult_Range = 1.25
att.Mult_Damage = 1.1
att.Mult_DamageMin = 1.1
att.Mult_Recoil = 1.2
att.Mult_RPM = 0.75
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_bacta.lua:
att.PrintName = "Bacta Grenade Launcher"
att.Icon = Material("interfaz/iconos/kraken/jedi scoun sawbones/1520358450_3114066081.png")
att.Description = "Throwable grenade with healing capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_heal"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_dioxis.lua:
att.PrintName = "Dioxis Grenade Launcher"
att.Icon = Material("interfaz/iconos/kraken/jedi shad serenity/656834804_3939926757.png")
att.Description = "Throwable grenade with dioxis capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_poison"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH lua/arccw/shared/attachments/ammo_high.lua:
att.PrintName = "High Tibanna Density"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Cycle the potency of the platform to allow for its chambering in High Density Tibanna."
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "ammo"

att.Reload = 1
att.Mult_DamageMin = 1.15
att.Mult_Recoil = 1.25
att.Mult_SightTime = 1
att.Mult_RPM = 0.65
att.NotForNPCs = true
att.Mult_Damage = 1.25
att.Mult_MuzzleVelocity = 1.25
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_le_mod.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/bipod_specialforces.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/dc17_cooling.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_bacta.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_impact.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_stun.lua:
att.PrintName = "Grenade Launcher (Stun)"
att.Icon = Material("interfaz/armas/sw_stungrenade.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Stun)"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_stun", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/attachments/mode_g125.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_scatter_pistol.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_experimental.lua:
att.PrintName = "Experimental Scope"
att.Icon = Material("entities/acwatt_optic_micro.png")
att.Description = "test scope for swrp"

att.SortOrder = 2

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = false
att.Slot = "swoptic_module"

att.Model = "models/weapons/arccw/atts/dc17c_sight.mdl"
att.HideModel = false
att.ModelScale = Vector(1, 1, 1)
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 90, 0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 8.5, -1.73),
        Ang = Angle(0, 0, 0),
        Magnification = 1,
    }
}

att.Holosight = true
att.HolosightReticle = Material("#sw/visor/sw_ret_redux_blue.png", "smooth")
att.HolosightNoFlare = false
att.HolosightSize = 6
att.HolosightBone = "holosight"
att.HolosightPiece = "models/weapons/arccw/atts/dc17c_hsp.mdl"

att.HolosightMagnification = 2
att.HolosightBlackbox = true
att.HolosightNoHSP = false

att.Mult_SightTime = 1.08
att.Mult_SightedSpeedMult = 0.94
--PATH lua/arccw/shared/attachments/optic_valken38_scope.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_cloneairborne.lua:
att.PrintName = "Airborne Training"

att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/airborne.png")
att.Description = [[Elite paratroopers of the Galactic Republic Clone Army. Their training benefits them greatly while on air and short range engagements.]]
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true

att.Mult_AccuracyMOA = 0.95

att.Mult_HipDispersion = 1.15
att.Mult_MoveDispersion = 1.15

att.Mult_SpeedMult = 1.05
att.Mult_SightedSpeedMult = 1.15
att.Mult_ReloadTime = 1.05
att.Mult_Recoil = 0.90
att.Mult_RecoilSide = 0.90

att.Mult_JumpDispersion = 0.25
att.Mult_MoveDispersion = 0.35

att.Mult_Range = 1.05
att.Mult_Damage = 1.05
att.Mult_DamageMin = 0.90

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_westernboi.lua:
att.PrintName = "Western Boi"

att.Icon = Material("interfaz/iconos/kraken/jedi juns sharpshooter/1833947853_761929952.png")
att.Description = "Like the fastest guns in the Tatooine Old West, you can draw, aim, and shoot in the blink of an eye.\n\nTexas Red had not cleared leather 'fore a bullet fairly ripped, and the Ranger's aim was deadly with the big iron on his hip."
att.Desc_Pros = {
    "Takes out your gun faster and less time to aim."
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.SortOrder = 5
att.Mult_DrawTime = 0.5
att.Mult_SightTime = 0.85

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/rep_ubgl.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/rx21_powerpack.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/rx21_powerpack.lua:
att.PrintName = "Extended-power"
att.Icon = Material("entities/kraken/sops/atts/rx21powerpack.png", "mips smooth")
att.Description = "More tibanna compression. More damage at the cost of less magazine capacity."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "rx21_powerpack"
att.ActivateElements = {"rx21_powerpack"}

att.Override_ClipSize = 100
att.Mult_Range = 1.15
att.Mult_Damage = 0.86
att.Mult_DamageMin = 1.15
att.Mult_Recoil = 1.05
att.Mult_RPM = 0.75
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/special_poison.lua:
att.PrintName = "Poison Rounds"
att.AbbrevName = "Poison Rounds"
att.Icon = Material("interfaz/iconos/jedi/1226256349_2572987182.png")
att.Description = "Experimental overcharged plasma that can poison targets."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"special_ammo"}

att.AutoStats = true
att.Override_AmmoPerShot = 10
att.Override_Tracer = "tracer_yellow"
att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "heal", 10, 5, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end
att.Hook_GetShootSound = function(wep, sound)
    return false
end
att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("everfall/weapons/deadeye/blasters_deadeye_laser_close_var_03.mp3", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/st_cr2.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_grip_e11r.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_dc17m_60mag.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_powerpack.lua:
att.PrintName = "SW-Power Pack"
att.AbbrevName = "40-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Power pack to offer more punch"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "e11_powerpack"

att.Model = "models/arccw/sw_battlefront/props/powerpack/power_pack.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 180)
att.ModelOffset = Vector(1.659, 0, 0.299)
att.ModelScale = Vector(0.8, 0.8, 0.8)

att.AutoStats = true

att.HideIfBlocked = true
att.Mult_Damage = 1.15

att.Override_ClipSize = 40

att.Mult_SightTime = 1.05
att.Mult_Sway = 1.1
att.Mult_RPM = 0.85

att.Mult_SpeedMult = 0.95

att.Mult_DrawTime = 1.1
att.Mult_HolsterTime = 1.05

att.Mult_HipDispersion = 1.05

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/ubgl_dc15.lua:
return gluapack()()
--PATH lua/arccw/client/cl_garbage.lua:
ArcCW.CSModels       = {} -- [entid] = { Weapon = NULL, WModels = {}, VModels = {} }
ArcCW.CSModelPile    = {} -- { {Model = NULL, Weapon = NULL} }
ArcCW.FlashlightPile = {} -- { {Weapon = NULL, ProjectedTexture = NULL}}
ArcCW.ReferenceModel = NULL

local function ArcCW_CollectGarbage()
    local removed, removedents = 0, {}

    for i, k in pairs(ArcCW.CSModels) do
        if !IsValid(k.Weapon) then
            removed = removed + 1

            table.insert(removedents, i)

            if k.WModels then for _, m in pairs(k.WModels) do SafeRemoveEntity(m.Model) end end
            if k.VModels then for _, m in pairs(k.VModels) do SafeRemoveEntity(m.Model) end end
        end
    end

    for _, i in pairs(removedents) do ArcCW.CSModels[i] = nil end

    local newpile = {}

    for _, k in pairs(ArcCW.CSModelPile) do
        if IsValid(k.Weapon) then
            table.insert(newpile, k)

            continue
        end

        SafeRemoveEntity(k.Model)

        removed = removed + 1
    end

    ArcCW.CSModelPile = newpile

    if GetConVar("developer"):GetBool() and removed > 0 then
        print("Removed " .. tostring(removed) .. " CSModels")
    end
end

hook.Add("PostCleanupMap", "ArcCW_CleanGarbage", function()
    ArcCW_CollectGarbage()
end)

timer.Create("ArcCW CSModel Garbage Collector", 5, 0, ArcCW_CollectGarbage)

hook.Add("PostDrawEffects", "ArcCW_CleanFlashlights", function()
    local newflashlightpile = {}

    for _, k in pairs(ArcCW.FlashlightPile) do
        if IsValid(k.Weapon) and k.Weapon == LocalPlayer():GetActiveWeapon() then
            table.insert(newflashlightpile, k)

            continue
        end

        if k.ProjectedTexture and k.ProjectedTexture:IsValid() then
            k.ProjectedTexture:Remove()
        end
    end

    ArcCW.FlashlightPile = newflashlightpile

    local wpn = LocalPlayer():GetActiveWeapon()

    if !wpn then return end
    if !IsValid(wpn) then return end
    if !wpn.ArcCW then return end

    if GetViewEntity() == LocalPlayer() then return end

    wpn:KillFlashlightsVM()
end)

concommand.Add("arccw_dev_loadallattmodels", function()
    local e = ClientsideModel("models/weapons/v_pistol.mdl")
    print("created subject", e)
    
    for i, v in pairs(ArcCW.AttachmentTable) do
        if v.Model then
            print("\t- " .. v.Model)
            e:SetModel(v.Model)
        end
    end

    print("removed subject", e)
    e:Remove()
end)
--PATH lua/arccw/client/cl_warnings.lua:
return gluapack()()
--PATH lua/autorun/aura_lvs_display_handler.lua:
return gluapack()()
--PATH lua/autorun/aussi_cgirc_arms.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/includes/awarn3_localization.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/localizations/es-la.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/localizations/tr.lua:
local language_code = "TR"
 
AWarn.Localization:RegisterLanguage( language_code, "Türkçe" )

--[[Turkish translation by Mew]]--
--https://www.gmodstore.com/users/Mew
 
AWarn.Localization:AddDefinition( language_code, "welcome1",                    "AWarn3'e Hoş Geldin" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms",           "Bu Komutu Gerçekleştirmek İçin Yetkiniz Bulunmuyor." )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2",          "Bu Oyuncunun Uyarılarını Görmek İçin Yetkiniz Bulunmuyor." )
AWarn.Localization:AddDefinition( language_code, "commandnonexist",             "Bu Komut Geçerli Değil." )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid",             "Geçersiz Hedef ya da ID." )
AWarn.Localization:AddDefinition( language_code, "invalidtarget",               "Geçersiz Hedef." )
AWarn.Localization:AddDefinition( language_code, "reasonrequired",              "Uyarı Sebebini Yaz." )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn",           "1 Aktif Uyarıyı Sildin" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid",            "Uyarı Silindi ID" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings",           "Tüm Uyarılarını Sildin" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor",          "Tüm Uyarıları Silindi" )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole",             "Konsolu Kullanarak Menüye Erişemezsin." )
AWarn.Localization:AddDefinition( language_code, "invalidoption",               "Geçersiz Ayarlama." )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",      "Invalid Option Value Type." )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",               "Ayarlar Yüklendi!" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",                "Uyarı İçin Yeterli Cezası Yok." )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",           "Uyarılar Yüklendi!" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",        "Bu Oyuncuyu Uyaramazsın." )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",                "Yetkili %s Tarafından Belirtilen Sebeplerle Uyarıldın %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",                "Uyardın %s Sebep %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",                "%s Tarafından Uyarıldı %s Sebep %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage4",                "%s tarafından uyarıldın." )
AWarn.Localization:AddDefinition( language_code, "warnmessage5",                "Uyardın %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage6",                "%s Tarafından Uyarıldı %s." )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",                "Uyarıyla Sunucuya Bağlandı." )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",                "Son Uyarıları:" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",                "Sunucumuza Hoşgeldin! Önceden Uyarıların Mevcut Dikkatli Ol." )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",                "Uyarılarınızı Yazarak Görebilirsin" )
AWarn.Localization:AddDefinition( language_code, "closemenu",                   "Menüyü Kapat" )
AWarn.Localization:AddDefinition( language_code, "searchplayers",               "Oyuncuları Ara" )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",                "Uyarıları Gör" )
AWarn.Localization:AddDefinition( language_code, "configuration",               "Ayarlar" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",               "Kullanıcı Ayarları" )
AWarn.Localization:AddDefinition( language_code, "serveroptions",               "Sunucu Ayarları" )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",          "Renk Düzenleme" )
AWarn.Localization:AddDefinition( language_code, "colorselection",              "Rengi Seç" )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",       "Dil Düzenleme" )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",              "Dil'i Seç" )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",            "Kick Cezasını Aktif Et" )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",             "Ban Cezasını Aktif Et" )
AWarn.Localization:AddDefinition( language_code, "enabledecay",                 "Aktif Uyarıların Silinmesini Aktif Et" )
AWarn.Localization:AddDefinition( language_code, "resetafterban",               "Kişi Banlandıktan Sonra Aktif Banları Sil" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",             "Yetkilileri Uyarmayı Aktif Et" )
AWarn.Localization:AddDefinition( language_code, "pressenter",                  "Enter'a Basarak Değişiklikleri Onayla" )
AWarn.Localization:AddDefinition( language_code, "entertosave",                 "Enter'a Basarak Kaydet" )
AWarn.Localization:AddDefinition( language_code, "chatprefix",                  "Geçmiş Sohbet" )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",            "Aktif Uyarı Silinme Süresi (Dakika Olarak)" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",              "Sunucu Dili" )
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",    "Cezalandırma Ayarları" )
AWarn.Localization:AddDefinition( language_code, "addpunishment",               "Ceza Ekle" )
AWarn.Localization:AddDefinition( language_code, "warnings",                    "Uyarılar" )
AWarn.Localization:AddDefinition( language_code, "punishtype",                  "Ceza Tipi" )
AWarn.Localization:AddDefinition( language_code, "punishlength",                "Ceza Uzunluğu" )
AWarn.Localization:AddDefinition( language_code, "playermessage",               "Oyuncunun Mesajı" )
AWarn.Localization:AddDefinition( language_code, "playername",                  "Oyuncunun Adı" )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",             "Oyuncuya Mesaj" )
AWarn.Localization:AddDefinition( language_code, "servermessage",               "Sunucu Mesajı" )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",             "Sunucuya Mesaj" )
AWarn.Localization:AddDefinition( language_code, "deletewarning",               "Uyarıları Sil" )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",               "Ceza Ekleme Menüsü" )
AWarn.Localization:AddDefinition( language_code, "inminutes",                   "Dakikada" )
AWarn.Localization:AddDefinition( language_code, "0equalperma",                 "0 = Perma" )
AWarn.Localization:AddDefinition( language_code, "use%",                        "Tuşunu Kullanarak %s Oyuncuların Adını Gör" )
AWarn.Localization:AddDefinition( language_code, "setdefault",                  "Varsayılana Ayarla" )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",          "Kendi Uyarılarını Gör" )
AWarn.Localization:AddDefinition( language_code, "warnedby",                    "Uyarıldı" )
AWarn.Localization:AddDefinition( language_code, "warningserver",               "Sunucu Uyarısı" )
AWarn.Localization:AddDefinition( language_code, "warningreason",               "Uyarının Sebebi" )
AWarn.Localization:AddDefinition( language_code, "warningdate",                 "Uyarı Tarihi" )
AWarn.Localization:AddDefinition( language_code, "nothing",                     "BOŞ" )
AWarn.Localization:AddDefinition( language_code, "submit",                      "Gönder" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",            "Bağlanan Oyuncular" )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",          "Uyarıları Görebilecekler" )
AWarn.Localization:AddDefinition( language_code, "activewarnings",              "Aktif Uyarılar" )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",    "Seçilen Oyuncunun Uyarısı Bulunmamakta." )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",     "Oyuncuyu Seç ve Uyarılarını Gör." )
AWarn.Localization:AddDefinition( language_code, "warnplayer",                  "Oyuncuyu Uyar" )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",             "Aktif Uyarıyı Bir'e Düşür" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",           "Oyuncu Uyarı Menüsü" )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",            "Oyuncu Arama Menüsü" )
AWarn.Localization:AddDefinition( language_code, "warningplayer",               "Oyuncuyu Uyar" )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",              "Ceza Almayan Oyuncuları Ayrı Tut" )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",            "Oyuncuları Adlarıyla ya da SteamID'leriyle Ara" )
AWarn.Localization:AddDefinition( language_code, "name",                        "İsim" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",                  "Son Oynama" )
AWarn.Localization:AddDefinition( language_code, "lastwarned",                  "Son Uyarısı" )
AWarn.Localization:AddDefinition( language_code, "never",                       "Asla" )
AWarn.Localization:AddDefinition( language_code, "playerid",                    "Oyuncu ID" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",        "Bu Oyuncunun Uyarılarına Bak" )
AWarn.Localization:AddDefinition( language_code, "servername",                  "Sunucu Adı" )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"Katılma sırasında oyuncuya uyarı sayısını göster" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"Oyuncu uyarılarla katıldığında yöneticilere mesaj göster" )
AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"cezalar" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		"Etkinleştirilirse, AWarn3 ceza olarak oyuncuları sunucudan atabilir." )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		"Etkinleştirilirse, AWarn3 ceza olarak oyuncuları sunucudan yasaklayabilir." )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"Etkinleştirilirse, aktif uyarılar zamanla azalır." )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"Etkinleştirilirse, yöneticilerin uyarılarında bir neden belirtmeleri gerekir." )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"Etkinleştirilirse, bir kullanıcının aktif uyarıları, AWarn3 tarafından yasaklandıktan sonra 0'a sıfırlanır." )
AWarn.Localization:AddDefinition( language_code, "logevents",					"Uyarı Olaylarını Günlüğe Kaydet." )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"Etkinleştirilirse, AWarn3 içindeki eylemler bir metin dosyasına kaydedilecektir." )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"Etkinleştirilirse, yöneticiler diğer yöneticileri uyarabilir." )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","Etkinleştirilirse, sunucuya katılan kullanıcılar, uyarıları varsa sohbette bir mesaj görür." )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"Etkinleştirilirse, sunucudaki yöneticiler, uyarıları olan herhangi bir oyuncu katıldığında görür." )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		"AWarn3 komutları için kullanılan sohbet komutu. Varsayılan: !warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	"1 aktif uyarının azalması için bir oyuncunun bağlanması gereken süre (dakika olarak)." )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"Bu sunucunun adı. Bu, birden çok sunucu kurulumu için kullanışlıdır." )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	"Bu, sunucu mesajlarının görüntüleneceği dildir." )
AWarn.Localization:AddDefinition( language_code, "theme",						"Arayüz Teması" )
AWarn.Localization:AddDefinition( language_code, "themeselect",					"Tema seçin" )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					"กลุ่มลงโทษ" )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"กลุ่มที่จะตั้งค่า" )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"Oyuncu Notlarını Görüntüle" )
AWarn.Localization:AddDefinition( language_code, "playernotes",					"Oyuncu Notları" )
AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		"Arayüz Özelleştirmeleri" )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"Arka Plan Bulanıklığını Etkinleştir" )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"Bir ön ayar seçin (İsteğe bağlı)" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"ön ayarlar" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				"Ön Ayar Ekle/Düzenle" )
AWarn.Localization:AddDefinition( language_code, "presetname",					"Ön Ayar Adı" )
AWarn.Localization:AddDefinition( language_code, "presetreason",				"Önceden Ayarlanmış Neden" )

--PATH addons/[admin] awarn3/lua/localizations/zh-cn.lua:
return gluapack()()
--PATH lua/autorun/bigboss.lua:
/*
	Addon by Voikanaa	
*/

player_manager.AddValidModel( "Big Boss", 		"models/player/big_boss.mdl" );
player_manager.AddValidHands( "Big Boss", 	"models/player/big_boss_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Big Boss", 	"models/player/big_boss.mdl" );

player_manager.AddValidModel( "Big Boss 2", 		"models/player/big_boss2.mdl" );
player_manager.AddValidHands( "Big Boss 2", 	"models/player/big_boss_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Big Boss 2", 	"models/player/big_boss2.mdl" );

player_manager.AddValidModel( "Big Boss 3", 		"models/player/big_boss3.mdl" );
player_manager.AddValidHands( "Big Boss 3", 	"models/player/big_boss_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Big Boss 3", 	"models/player/big_boss3.mdl" );

player_manager.AddValidModel( "Big Boss 4", 		"models/player/big_boss4.mdl" );
player_manager.AddValidHands( "Big Boss 4", 	"models/player/big_boss_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Big Boss 4", 	"models/player/big_boss4.mdl" );

player_manager.AddValidModel( "Big Boss 5", 		"models/player/big_boss5.mdl" );
player_manager.AddValidHands( "Big Boss 5", 	"models/player/big_boss_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Big Boss 5", 	"models/player/big_boss5.mdl" );

player_manager.AddValidModel( "Big Boss 6", 		"models/player/big_boss6.mdl" );
player_manager.AddValidHands( "Big Boss 6", 	"models/player/big_boss_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Big Boss 6", 	"models/player/big_boss6.mdl" );

player_manager.AddValidModel( "Big Boss 7", 		"models/player/big_boss7.mdl" );
player_manager.AddValidHands( "Big Boss 7", 	"models/player/big_boss_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Big Boss 7", 	"models/player/big_boss7.mdl" );
--PATH lua/autorun/blizz.lua:
player_manager.AddValidModel( "Blizz",		"models/jajoff/sw/blizz.mdl" );
list.Set( "PlayerOptionsModel", "Blizz",		"models/jajoff/sw/blizz.mdl" );
--PATH addons/[misc] bodygroupr/lua/autorun/bodyman_init.lua:
return gluapack()()
--PATH addons/[misc] bodygroupr/lua/bodyman/bodyman_config.lua:
return gluapack()()
--PATH lua/autorun/craggy_addon.lua:
player_manager.AddValidModel( "Pirate Craggy", "models/player/ohanak_gang/pm_pirate_craggy.mdl" );
list.Set( "PlayerOptionsModel",  "Pirate Craggy", "models/player/ohanak_gang/pm_pirate_craggy.mdl" );


--PATH addons/[chat] advert/lua/autorun/darkrp-full-classic-advert.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/autorun/decals_init.lua:
Decals = Decals or {
    incsv = SERVER and include or function() end,
    inccl = SERVER and AddCSLuaFile or include,
    incsh = function( file ) Decals.incsv( file ) Decals.inccl( file ) end,
    inc = function( file ) Decals[ "inc" .. file:GetFileFromFilename():sub( 1, 2 ) ]( file ) end,
    cfg = {},
}

-- cfg
Decals.incsh "decals/decals_config.lua"

-- util
Decals.inc "decals/util/sh_util.lua"
Decals.inc "decals/util/cl_util.lua"
Decals.inc "decals/util/cl_parse.lua"
Decals.inc "decals/util/cl_halo.lua"
Decals.inc "decals/util/sh_properties.lua"

-- image loading
Decals.inc "decals/load/cl_load.lua"
Decals.inc "decals/load/sv_load.lua"

-- processing
Decals.inc "decals/core/sv_core.lua"
Decals.inc "decals/core/cl_core.lua"

-- vgui
Decals.inccl "decals/vgui/draw.lua"
Decals.inccl "decals/vgui/frame.lua"
Decals.inccl "decals/vgui/slider.lua"
Decals.inccl "decals/vgui/button.lua"

-- menu
Decals.inc "decals/menu/cl_menu.lua"

--PATH addons/[opt] decals/lua/decals/vgui/slider.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/menu/cl_menu.lua:
return gluapack()()
--PATH lua/gmodadminsuite/sh_core.lua:
AddCSLuaFile()

--######## LOAD CONFIG ########--

GAS:HeaderPrint("")
GAS:HeaderPrint("Loading configs...", GAS_PRINT_TYPE_INFO)

GAS.Config = {}

local function InstallConfigAddon()
	if (SERVER) then
		GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "Looks like the GmodAdminSuite Config Addon has not been installed to your server: ", {Link = "https://gmodsto.re/gmodadminsuite-config-addon"}, "\nYou need to install this addon in order to use & configure GmodAdminSuite.")
	end
end

if (not file.Exists("gmodadminsuite_config.lua", "LUA")) then
	return InstallConfigAddon()
else
	local worked = include("gmodadminsuite_config.lua")
	if (not worked) then
		if (SERVER) then
			GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "GmodAdminSuite config failed to load. You probably have an error in your config. Please read your server's console.")
			return
		end
		return
	else
		GAS:HeaderPrint("Config successfully loaded", GAS_PRINT_COLOR_GOOD, GAS_PRINT_TYPE_INFO)
	end
end

if (not file.Exists("gmodadminsuite_lua_functions.lua", "LUA")) then
	return InstallConfigAddon()
else
	local worked = include("gmodadminsuite_lua_functions.lua")
	if (not worked) then
		if (SERVER) then
			GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "GmodAdminSuite Lua functions config failed to load. You probably have an error in your config. Please read your server's console.")
			return
		end
		return
	else
		GAS:HeaderPrint("Lua functions successfully loaded", GAS_PRINT_COLOR_GOOD, GAS_PRINT_TYPE_INFO)
	end
end

if (SERVER) then
	if (not file.Exists("gmodadminsuite_mysql_config.lua", "LUA")) then
		return InstallConfigAddon()
	else
		GAS.Config.MySQL = {}
		local worked = include("gmodadminsuite_mysql_config.lua")
		if (not worked) then
			GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "GmodAdminSuite MySQL config failed to load. You probably have an error in your config. Please read your server's console.")
			return
		else
			GAS:HeaderPrint("MySQL config successfully loaded", GAS_PRINT_COLOR_GOOD, GAS_PRINT_TYPE_INFO)
		end
	end

	if (not file.Exists("gmodadminsuite_steam_apikey.lua", "LUA")) then
		return InstallConfigAddon()
	else
		GAS.SteamAPI = {}
		GAS.SteamAPI.Config = {}
		local worked = include("gmodadminsuite_steam_apikey.lua")
		if (not worked) then
			GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "GmodAdminSuite Steam API key config failed to load. You probably have an error in your config. Please read your server's console.")
			return
		end
	end
end

--######## ADD RESOURCES ########--

if (SERVER) then
	-- Fonts must be downloaded from the server
	resource.AddFile("resource/fonts/circular-bold.ttf")
	resource.AddFile("resource/fonts/circular-medium.ttf")
	resource.AddFile("resource/fonts/rubik.ttf")
	resource.AddFile("resource/fonts/rubik-bold.ttf")

	if (GAS.Config.WorkshopDL == true or GAS.Config.WorkshopDL == nil) then
		resource.AddWorkshop("1596971443")
	end
	if (GAS.Config.ServerDL == true) then
		for _,v in ipairs({"materials/gmodadminsuite/*", "sound/gmodadminsuite/*"}) do
			local files = file.Find(v, "GAME")
			for _,f in pairs(files) do
				resource.AddFile((v:gsub("%*$", "")) .. f)
			end
		end
	end
else
	for _,v in ipairs((file.Find("sound/gmodadminsuite/*", "GAME"))) do
		util.PrecacheSound("sound/gmodadminsuite/" .. v)
	end
end

--######## Account ID ########--

function GAS:SteamID64ToAccountID(steamid64)
	return GAS:SteamIDToAccountID(util.SteamIDFrom64(steamid64))
end

function GAS:SteamIDToAccountID(steamid)
	local acc32 = tonumber(steamid:sub(11))
	return (acc32 * 2) + tonumber(steamid:sub(9,9))
end

function GAS:AccountIDToSteamID(account_id)
	local sid32 = tonumber(account_id) / 2
	if (sid32 % 1 > 0) then
		return "STEAM_0:1:" .. math.floor(sid32)
	else
		return "STEAM_0:0:" .. sid32
	end
end

function GAS:AccountIDToSteamID64(account_id)
	return util.SteamIDTo64(GAS:AccountIDToSteamID(account_id))
end

--######## MISC ########--

function GAS:IsIPAddress(ip_address, forbid_port)
	local v1,v2,v3,v4,port = ip_address:match("^(%d+)%.(%d+)%.(%d+)%.(%d+)(.*)")
	return
		(v1 ~= nil and (v1 == "0" or (not v1:find("^0") and tonumber(v1) >= 1 and tonumber(v1) <= 255))) and
		(v2 ~= nil and (v2 == "0" or (not v2:find("^0") and tonumber(v2) >= 1 and tonumber(v2) <= 255))) and
		(v3 ~= nil and (v3 == "0" or (not v3:find("^0") and tonumber(v3) >= 1 and tonumber(v3) <= 255))) and
		(v4 ~= nil and (v4 == "0" or (not v4:find("^0") and tonumber(v4) >= 1 and tonumber(v4) <= 255))) and
		(
			(forbid_port == true and (port == nil or #port == 0)) or
			
			(not forbid_port and (
					(port == nil or #port == 0) or
					(port ~= nil and #port > 1 and #port <= 6 and port:sub(1,1) == ":" and
						(port:sub(2) == "0" or
							(tonumber(port:sub(2)) ~= nil and not port:sub(2):find("^0") and tonumber(port:sub(2)) >= 0 and tonumber(port:sub(2)) <= 65535)
						)
					)
				)
			)
		)
end

function GAS:BoolToBit(bool)
	if (bool == true) then
		return 1
	elseif (bool == false) then
		return 0
	end
end
function GAS:BitToBool(bit)
	if (tonumber(bit) == 1) then
		return true
	elseif (tonumber(bit) == 0) then
		return false
	end
end

function GAS:Unvectorize(vec)
	if (vec.r and vec.g and vec.b) then
		local vec_a = ""
		if (vec.a and vec.a ~= 255) then
			vec_a = "," .. vec.a
		end
		return vec.r .. "," .. vec.g .. "," .. vec.b .. vec_a
	elseif (vec.p and vec.y and vec.r) then
		return vec.p .. "," .. vec.y .. "," .. vec.r
	elseif (vec.x and vec.y and vec.z) then
		return vec.x .. "," .. vec.y .. "," .. vec.z
	end
end

function GAS:SetClipboardText(text)
	SetClipboardText(text)
	GAS:PlaySound("confirmed")
	bVGUI.MouseInfoTooltip.Create(GAS:Phrase("copied"))
end

function GAS:OpenURL(url)
	GAS:PlaySound("popup")
	gui.OpenURL(url)
end

function GAS:table_Flip(tbl)
	local new_tbl = {}
	for i,v in pairs(tbl) do
		new_tbl[v] = i
	end
	return new_tbl
end

function GAS:table_IsEmpty(tbl)
	return next(tbl) == nil
end

function GAS:table_ValuesFromKey(tab, key)
	local res = {}
	for k, v in pairs( tab ) do
		if ( v[ key ] ~= nil ) then res[ #res + 1 ] = v[ key ] end
	end
	return res
end

function GAS:table_RemoveEmptyChildren(tbl, tbl_key, parent_tbl)
	for k,v in pairs(tbl) do
		if (type(v) == "table") then
			if (GAS:table_IsEmpty(v)) then
				tbl[k] = nil
				if (tbl_key ~= nil and parent_tbl ~= nil and GAS:table_IsEmpty(tbl)) then
					parent_tbl[tbl_key] = nil
				end
			else
				tbl[k] = GAS:table_RemoveEmptyChildren(v, k, tbl)
			end
		end
	end
	if (GAS:table_IsEmpty(tbl)) then
		if (tbl_key == nil and parent_tbl == nil) then
			return {}
		else
			return nil
		end
	else
		return tbl
	end
end

function GAS:utf8_force_strip(str)
	return (utf8.force(str):gsub("�", ""))
end

--######## LUA FUNCTIONS ########--

function GAS:RunLuaFunction(lua_func_name, ...)
	if (not GAS.LuaFunctions[lua_func_name]) then
		GAS:print("Tried to run a Lua function that doesn't exist! (" .. lua_func_name .. ")", GAS.PRINT_ERROR)
	else
		return GAS.LuaFunctions[lua_func_name](...)
	end
end

--######## TEAM HELPERS ########--

local indexed_teams = {}
function GAS:TeamFromName(team_name)
	if (indexed_teams[team_name] ~= nil) then
		return indexed_teams[indexed_teams]
	else
		for i,v in pairs(team.GetAllTeams()) do
			if (v.Name == team_name) then
				indexed_teams[i] = v.Name
				return i
			end
		end
	end
end

--######## SOUND ########--

local sounds = {alert = "gmodadminsuite/alert.mp3"}
function GAS:PlaySound(sound_name)
	surface.PlaySound(sounds[sound_name] or "gmodadminsuite/" .. sound_name .. ".ogg")
end

--######## MARKUP HELPERS ########--

function GAS:MarkupToPlaintext(str)
	str = tostring(str)
	if (markup and markup.ToPlaintext) then
		return markup.ToPlaintext(str)
	else
		return (str:gsub("</?%a+=?.->",""))
	end
end

function GAS:EscapeMarkup(str)
	str = tostring(str)
	if (markup and markup.Escape) then
		return markup.Escape(str)
	else
		return (str:gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;"))
	end
end

local special_markdown_chars = {"\\","`","*","_","{","}","[","]","(",")","#","+","-",".","!"}
function GAS:EscapeMarkdown(str)
	for _,v in ipairs(special_markdown_chars) do
		str = (str:gsub("%" .. v, "\\" .. v))
	end
	return str
end

function GAS:EscapeJSON(str)
	return (str:gsub("\\", "\\\\"):gsub('"', '\\"'))
end

--######## MySQL ########--

if (SERVER) then
	GAS:EndHeader()
	GAS:StartHeader("Database")
	if (GAS.Config.MySQL.Enabled == true) then
		GAS:HeaderPrint("MySQL enabled", GAS_PRINT_TYPE_INFO)
		local mysqloo_installed = false
		if (system.IsLinux() or system.IsWindows()) then
			local module_name = system.IsLinux() and (jit.arch == "x64" and "gmsv_mysqloo_linux64.dll" or "gmsv_mysqloo_linux.dll") or (jit.arch == "x64" and "gmsv_mysqloo_win64.dll" or "gmsv_mysqloo_win32.dll")
			if (file.Exists("lua/bin/" .. module_name, "GAME")) then
				mysqloo_installed = true
			else
				GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "You do not have the required MySQLOO module installed on your server (lua/bin/" .. module_name .. ") MySQLOO is required to communicate with your MySQL Server.\n", {Link = "https://github.com/FredyH/MySQLOO#install-instructions"})
			end
		else
			GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "You must be running Linux or Windows to use MySQL and its required module, MySQLOO.\n", {Link = "https://github.com/FredyH/MySQLOO#install-instructions"})
		end
		if (mysqloo_installed) then
			GAS:HeaderPrint("MySQLOO is installed!", GAS_PRINT_COLOR_GOOD, GAS_PRINT_TYPE_INFO)
		else
			return
		end
	else
		GAS:HeaderPrint("MySQL disabled, using local server database", GAS_PRINT_TYPE_INFO)
	end

	include("sv_database.lua")
	GAS:EndHeader()
else
	GAS:EndHeader()
end

--######## NETWORKING ########--

include("sh_networking.lua")

--######## HOOKING ########--

function GAS:hook(event, identifier, func)
	GAS:unhook(event, identifier)
	hook.Add(event, "gmodadminsuite:" .. identifier, func)
end
function GAS:unhook(event, identifier)
	hook.Remove(event, "gmodadminsuite:" .. identifier)
end

if (SERVER) then include("gmodadminsuite/sv_hooks.lua") end

--######## TIMERS ########--

function GAS:timer(name, ...)
	GAS:untimer(name)
	timer.Create("gmodadminsuite:" .. name, ...)
end
function GAS:untimer(name)
	timer.Remove("gmodadminsuite:" .. name)
end

--######## CONFIGS ########--

if (not file.IsDir("gmodadminsuite/configs", "DATA")) then
	file.CreateDir("gmodadminsuite/configs", "DATA")
end
if (SERVER) then
	GAS:netInit("getconfig")
	GAS:netInit("uncacheconfig")

	function GAS:DeleteConfig(config_name)
		file.Delete("gmodadminsuite/configs/" .. config_name .. ".txt")
		GAS.ConfigCache[config_name] = nil
	end

	GAS.ConfigCache = {}
	function GAS:GetConfig(config_name, default_config)
		if (GAS.ConfigCache[config_name]) then return GAS.ConfigCache[config_name] end
		if (file.Exists("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA")) then
			local config = file.Read("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA")
			if (config) then
				config = GAS:DeserializeTable(config)
				if (config) then
					GAS.ConfigCache[config_name] = config
					return config
				end
			end
			GAS:print("Failed to load config: " .. config_name .. "; reverting to default config.", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
			GAS.BillysErrors:AddMessage({"Failed to load config: " .. config_name .. "; reverting to default config."})
		end
		if (default_config) then
			GAS:SaveConfig(config_name, default_config)
			return default_config
		end
	end
	function GAS:SaveConfig(config_name, config)
		GAS.ConfigCache[config_name] = config

		local serialized_config = GAS:SerializeTable(config)

		file.Write("gmodadminsuite/configs/" .. config_name .. ".txt", serialized_config)

		GAS:netStart("uncacheconfig")
			net.WriteString(config_name)
		net.Broadcast()

		return config
	end

	GAS:netReceive("getconfig", function(ply)
		local config_name = net.ReadString()
		if (file.Exists("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA")) then
			local data = util.Compress(file.Read("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA"))
			local data_len = #data
			GAS:netStart("getconfig")
				net.WriteString(config_name)
				net.WriteUInt(data_len, 32)
				net.WriteData(data, data_len)
			net.Send(ply)
		end
	end)
else
	GAS.ConfigCache = {}

	GAS.ConfigCallbacks = {}
	function GAS:GetConfig(config_name, callback)
		if (callback) then
			GAS.ConfigCallbacks[config_name] = callback
		end
		if (GAS.ConfigCache[config_name]) then
			if (callback) then
				callback(GAS.ConfigCache[config_name])
			end
			return GAS.ConfigCache[config_name]
		end
		GAS:netStart("getconfig")
			net.WriteString(config_name)
		net.SendToServer()
	end
	GAS:netReceive("getconfig", function()
		local config_name = net.ReadString()
		local data_len = net.ReadUInt(32)
		local data = net.ReadData(data_len)
		data = util.Decompress(data)
		data = GAS:DeserializeTable(data)

		GAS.ConfigCache[config_name] = data

		GAS.ConfigCallbacks[config_name](data)
	end)

	GAS.LocalConfigCache = {}
	function GAS:GetLocalConfig(config_name, default_config)
		if (GAS.LocalConfigCache[config_name]) then return GAS.LocalConfigCache[config_name] end

		if (file.Exists("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA")) then
			local config = file.Read("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA")
			if (config) then
				config = GAS:DeserializeTable(config)
				if (config) then
					GAS.LocalConfigCache[config_name] = config
					return config
				end
			end
		end

		if (default_config) then
			GAS:SaveLocalConfig(config_name, default_config)
			return default_config
		end
	end
	function GAS:SaveLocalConfig(config_name, config)
		GAS.LocalConfigCache[config_name] = config
		file.Write("gmodadminsuite/configs/" .. config_name .. ".txt", GAS:SerializeTable(config))
		return config
	end

	function GAS:UncacheConfig(config_name)
		GAS.ConfigCache[config_name] = nil
	end
	GAS:netReceive("uncacheconfig", function()
		GAS:UncacheConfig(net.ReadString())
	end)
end

--######## SERIALIZATION ########--

GAS.von = include("gmodadminsuite/thirdparty/von.lua")
GAS.pon = include("gmodadminsuite/thirdparty/pon.lua")
GAS.spon = include("gmodadminsuite/thirdparty/spon.lua")
function GAS:SerializeTable(tbl)
	return GAS.von.serialize(tbl)
end
function GAS:DeserializeTable(tbl)
	local succ, r = pcall(GAS.von.deserialize, tbl)
	if (not succ) then
		return GAS.spon.decode(tbl)
	else
		return r
	end
end

--######## LANGUAGE ########--

include("gmodadminsuite/sh_language.lua")

--######## OFFLINE PLAYER DATA ########--

include("gmodadminsuite/sh_offline_player_data.lua")

--######## TEAMS ########--

include("gmodadminsuite/sh_teams.lua")

--######## STEAM API ########--

if (SERVER) then include("gmodadminsuite/sv_steam_avatar.lua") end

--######## AFK ########--

include("gmodadminsuite/sh_afk.lua")

--######## COUNTRY CODES ########--

if (CLIENT) then include("gmodadminsuite/cl_country_codes.lua") end


--######## COMMANDS ########--

local CmdRegistrations = {}
function GAS:RegisterCommand(text, module_name)
	if (GAS.Commands and GAS.Commands.Loaded) then
		GAS.Commands:RegisterCommand(text, module_name)
	else
		table.insert(CmdRegistrations, {text, module_name})
	end
end
GAS:hook("gmodadminsuite:Commands:Loaded", "CommandManagerLoaded", function()
	if (not CmdRegistrations) then return end
	for _,v in ipairs(CmdRegistrations) do
		GAS.Commands:RegisterCommand(unpack(v))
	end
	CmdRegistrations = nil
end)

--######## REGISTRY TABLES ########--

include("gmodadminsuite/sh_registry_tbl.lua")

--######## XEON ########--

if (SERVER) then include("gmodadminsuite/sv_xeon.lua") end

--######## INCLUDE FILES ########--

function GAS:Init()
	include("gmodadminsuite/sh_modules.lua")
	include("gmodadminsuite/sh_permissions.lua")

	if (CLIENT) then
		include("gmodadminsuite/cl_menubar.lua")
		include("gmodadminsuite/cl_contextmenu.lua")
		include("gmodadminsuite/cl_selection_prompts.lua")
		include("gmodadminsuite/cl_menu.lua")
	else
		include("gmodadminsuite/sv_menu.lua")
	end
end
GAS:Init()
--PATH lua/gmodadminsuite/thirdparty/von.lua:
--[[	vON 1.3.4

	Copyright 2012-2014 Alexandru-Mihai Maftei
					aka Vercas

	GitHub Repository:
		https://github.com/vercas/vON

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author (Vercas) if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above obligations still apply.
	If you make any interesting modifications, try forking the GitHub repository instead.

	Instead of copying this code over for sharing, rather use the link:
		https://github.com/vercas/vON/blob/master/von.lua

	The author may not be held responsible for any damage or losses directly or indirectly caused by
	the use of vON.

	If you disagree with the above, don't use the code.

-----------------------------------------------------------------------------------------------------------------------------
	
	Thanks to the following people for their contribution:
		-	Divran						Suggested improvements for making the code quicker.
										Suggested an excellent new way of deserializing strings.
										Lead me to finding an extreme flaw in string parsing.
		-	pennerlord					Provided some performance tests to help me improve the code.
		-	Chessnut					Reported bug with handling of nil values when deserializing array components.

		-	People who contributed on the GitHub repository by reporting bugs, posting fixes, etc.

-----------------------------------------------------------------------------------------------------------------------------
	
	The vanilla types supported in this release of vON are:
		-	table
		-	number
		-	boolean
		-	string
		-	nil

	The Garry's Mod-specific types supported in this release are:
		-	Vector
		-	Angle
		+	Entities:
			-	Entity
			-	Vehicle
			-	Weapon
			-	NPC
			-	Player
			-	NextBot

	These are the types one would normally serialize.

-----------------------------------------------------------------------------------------------------------------------------
	
	New in this version:
		-	Fixed addition of extra entity types. I messed up really badly.
--]]



local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable
local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next



--[[    This section contains localized functions which (de)serialize
        variables according to the types found.                          ]]



--	This is kept away from the table for speed.
function d_findVariable(s, i, len, lastType, jobstate)
	local i, c, typeRead, val = i or 1

	--	Keep looping through the string.
	while true do
		--	Stop at the end. Throw an error. This function MUST NOT meet the end!
		if i > len then
			error("vON: Reached end of string, cannot form proper variable.")
		end

		--	Cache the character. Nobody wants to look for the same character ten times.
		c = sub(s, i, i)

		--	If it just read a type definition, then a variable HAS to come after it.
		if typeRead then
			--	Attempt to deserialize a variable of the freshly read type.
			val, i = _deserialize[lastType](s, i, len, false, jobstate)
			--	Return the value read, the index of the last processed character, and the type of the last read variable.
			return val, i, lastType

		--	@ means nil. It should not even appear in the output string of the serializer. Nils are useless to store.
		elseif c == "@" then
			return nil, i, lastType

		--	$ means a table reference will follow - a number basically.
		elseif c == "$" then
			lastType = "table_reference"
			typeRead = true

		--	n means a number will follow. Base 10... :C
		elseif c == "n" then
			lastType = "number"
			typeRead = true

		--	b means boolean flags.
		elseif c == "b" then
			lastType = "boolean"
			typeRead = true

		--	' means the start of a string.
		elseif c == "'" then
			lastType = "string"
			typeRead = true

		--	" means the start of a string prior to version 1.2.0.
		elseif c == "\"" then
			lastType = "oldstring"
			typeRead = true

		--	{ means the start of a table!
		elseif c == "{" then
			lastType = "table"
			typeRead = true


--[[    Garry's Mod types go here    ]]

		--	e means an entity ID will follow.
		elseif c == "e" then
			lastType = "Entity"
			typeRead = true
--[[
		--	c means a vehicle ID will follow.
		elseif c == "c" then
			lastType = "Vehicle"
			typeRead = true

		--	w means a weapon entity ID will follow.
		elseif c == "w" then
			lastType = "Weapon"
			typeRead = true

		--	x means a NPC ID will follow.
		elseif c == "x" then
			lastType = "NPC"
			typeRead = true
--]]
		--	p means a player ID will follow.
		--	Kept for backwards compatibility.
		elseif c == "p" then
			lastType = "Entity"
			typeRead = true

		--	v means a vector will follow. 3 numbers.
		elseif c == "v" then
			lastType = "Vector"
			typeRead = true

		--	a means an Euler angle will follow. 3 numbers.
		elseif c == "a" then
			lastType = "Angle"
			typeRead = true

--[[    Garry's Mod types end here    ]]


		--	If no type has been found, attempt to deserialize the last type read.
		elseif lastType then
			val, i = _deserialize[lastType](s, i, len, false, jobstate)
			return val, i, lastType

		--	This will occur if the very first character in the vON code is wrong.
		else
			error("vON: Malformed data... Can't find a proper type definition. Char#" .. i .. ":" .. c)
		end

		--	Move the pointer one step forward.
		i = i + 1
	end
end

--	This is kept away from the table for speed.
--	Yeah, ton of parameters.
function s_anyVariable(data, lastType, isNumeric, isKey, isLast, jobstate)
	local tp = type(data)

	if jobstate[1] and jobstate[2][data] then
		tp = "table_reference"
	end

	--	Basically, if the type changes.
	if lastType ~= tp then
		--	Remember the new type. Caching the type is useless.
		lastType = tp

		if _serialize[lastType] then
			--	Return the serialized data and the (new) last type.
			--	The second argument, which is true now, means that the data type was just changed.
			return _serialize[lastType](data, true, isNumeric, isKey, isLast, false, jobstate), lastType
		else
			error("vON: No serializer defined for type \"" .. lastType .. "\"!")
		end
	end

	--	Otherwise, simply serialize the data.
	return _serialize[lastType](data, false, isNumeric, isKey, isLast, false, jobstate), lastType
end



--[[    This section contains the tables with the functions necessary
        for decoding basic Lua data types.                               ]]



_deserialize = {
--	Well, tables are very loose...
--	The first table doesn't have to begin and end with { and }.
	["table"] = function(s, i, len, unnecessaryEnd, jobstate)
		local ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1, nil, nil, nil, 1
		--	Locals, locals, locals, locals, locals, locals, locals, locals and locals.

		if sub(s, i, i) == "#" then
			local e = find(s, "#", i + 2, true)

			if e then
				local id = tonumber(sub(s, i + 1, e - 1))

				if id then
					if jobstate[1][id] and not jobstate[2] then
						error("vON: There already is a table of reference #" .. id .. "! Missing an option maybe?")
					end

					jobstate[1][id] = ret

					i = e + 1
				else
					error("vON: Malformed table! Reference ID starting at char #" .. i .. " doesn't contain a number!")
				end
			else
				error("vON: Malformed table! Cannot find end of reference ID start at char #" .. i .. "!")
			end
		end

		--	Keep looping.
		while true do
			--	Until it meets the end.
			if i > len then
				--	Yeah, if the end is unnecessary, it won't spit an error. The main chunk doesn't require an end, for example.
				if unnecessaryEnd then
					return ret, i

				--	Otherwise, the data has to be damaged.
				else
					error("vON: Reached end of string, incomplete table definition.")
				end
			end

			--	Cache the character.
			c = sub(s, i, i)
			--print(i, "table char:", c, tostring(unnecessaryEnd))

			--	If it's the end of a table definition, return.
			if c == "}" then
				return ret, i

			--	If it's the component separator, switch to key:value pairs.
			elseif c == "~" then
				numeric = false

			elseif c == ";" then
				--	Lol, nothing!
				--	Remenant from numbers, for faster parsing.

			--	OK, now, if it's on the numeric component, simply add everything encountered.
			elseif numeric then
				--	Find a variable and it's value
				val, i, lastType = d_findVariable(s, i, len, lastType, jobstate)
				--	Add it to the table.
				ret[ind] = val

				ind = ind + 1

			--	Otherwise, if it's the key:value component...
			else
				--	If a value is expected...
				if expectValue then
					--	Read it.
					val, i, lastType = d_findVariable(s, i, len, lastType, jobstate)
					--	Add it?
					ret[key] = val
					--	Clean up.
					expectValue, key = false, nil

				--	If it's the separator...
				elseif c == ":" then
					--	Expect a value next.
					expectValue = true

				--	But, if there's a key read already...
				elseif key then
					--	Then this is malformed.
					error("vON: Malformed table... Two keys declared successively? Char#" .. i .. ":" .. c)

				--	Otherwise the key will be read.
				else
					--	I love multi-return and multi-assignement.
					key, i, lastType = d_findVariable(s, i, len, lastType, jobstate)
				end
			end

			i = i + 1
		end

		return nil, i
	end,

--	Just a number which points to a table.
	["table_reference"] = function(s, i, len, unnecessaryEnd, jobstate)
		local i, a = i or 1
		--	Locals, locals, locals, locals

		a = find(s, "[;:}~]", i)

		if a then
			local n = tonumber(sub(s, i, a - 1))

			if n then
				return jobstate[1][n] or error("vON: Table reference does not point to a (yet) known table!"), a - 1
			else
				error("vON: Table reference definition does not contain a valid number!")
			end
		end

		--	Using %D breaks identification of negative numbers. :(

		error("vON: Number definition started... Found no end.")
	end,


--	Numbers are weakly defined.
--	The declaration is not very explicit. It'll do it's best to parse the number.
--	Has various endings: \n, }, ~, : and ;, some of which will force the table deserializer to go one char backwards.
	["number"] = function(s, i, len, unnecessaryEnd, jobstate)
		local i, a = i or 1
		--	Locals, locals, locals, locals

		a = find(s, "[;:}~]", i)

		if a then
			return tonumber(sub(s, i, a - 1)) or error("vON: Number definition does not contain a valid number!"), a - 1
		end

		--	Using %D breaks identification of negative numbers. :(

		error("vON: Number definition started... Found no end.")
	end,


--	A boolean is A SINGLE CHARACTER, either 1 for true or 0 for false.
--	Any other attempt at boolean declaration will result in a failure.
	["boolean"] = function(s, i, len, unnecessaryEnd, jobstate)
		local c = sub(s,i,i)
		--	Only one character is needed.

		--	If it's 1, then it's true
		if c == "1" then
			return true, i

		--	If it's 0, then it's false.
		elseif c == "0" then
			return false, i
		end

		--	Any other supposely "boolean" is just a sign of malformed data.
		error("vON: Invalid value on boolean type... Char#" .. i .. ": " .. c)
	end,


--	Strings prior to 1.2.0
	["oldstring"] = function(s, i, len, unnecessaryEnd, jobstate)
		local res, i, a = "", i or 1
		--	Locals, locals, locals, locals

		while true do
			a = find(s, "\"", i, true)

			if a then
				if sub(s, a - 1, a - 1) == "\\" then
					res = res .. sub(s, i, a - 2) .. "\""
					i = a + 1
				else
					return res .. sub(s, i, a - 2), a
				end
			else
				error("vON: Old string definition started... Found no end.")
			end
		end
	end,

--	Strings after 1.2.0
	["string"] = function(s, i, len, unnecessaryEnd, jobstate)
		local res, i, a = "", i or 1
		--	Locals, locals, locals, locals

		while true do
			a = find(s, "\"", i, true)

			if a then
				if sub(s, a - 1, a - 1) == "\\" then
					res = res .. sub(s, i, a - 2) .. "\""
					i = a + 1
				else
					return res .. sub(s, i, a - 1), a
				end
			else
				error("vON: String definition started... Found no end.")
			end
		end
	end,
}



_serialize = {
--	Uh. Nothing to comment.
--	Ton of parameters.
--	Makes stuff faster than simply passing it around in locals.
--	table.concat works better than normal concatenations WITH LARGE-ISH STRINGS ONLY.
	["table"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		--print(string.format("data: %s; mustInitiate: %s; isKey: %s; isLast: %s; nice: %s; indent: %s; first: %s", tostring(data), tostring(mustInitiate), tostring(isKey), tostring(isLast), tostring(nice), tostring(indent), tostring(first)))

		local result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0
		--	Locals, locals, locals, locals, locals, locals, locals, locals, locals and locals.

		--	First thing to be done is separate the numeric and key:value components of the given table in two tables.
		--	pairs(data) is slower than next, data as far as my tests tell me.
		for k, v in next, data do
			--	Skip the numeric keyz.
			if type(k) ~= "number" or k < 1 or k > len or (k % 1 ~= 0) then	--	k % 1 == 0 is, as proven by personal benchmarks,
				keyvals[#keyvals + 1] = k									--	the quickest way to check if a number is an integer.
			end																--	k % 1 ~= 0 is the fastest way to check if a number
		end																	--	is NOT an integer. > is proven slower.

		keyvalsLen = #keyvals

		--	Main chunk - no initial character.
		if not first then
			result[#result + 1] = "{"
		end

		if jobstate[1] and jobstate[1][data] then
			if jobstate[2][data] then
				error("vON: Table #" .. jobstate[1][data] .. " written twice..?")
			end

			result[#result + 1] = "#"
			result[#result + 1] = jobstate[1][data]
			result[#result + 1] = "#"

			jobstate[2][data] = true
		end

		--	Add numeric values.
		if len > 0 then
			for i = 1, len do
				val, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, jobstate)
				result[#result + 1] = val
			end
		end

		--	If there are key:value pairs.
		if keyvalsLen > 0 then
			--	Insert delimiter.
			result[#result + 1] = "~"

			--	Insert key:value pairs.
			for _i = 1, keyvalsLen do
				keyvalsProgress = keyvalsProgress + 1

				val, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, jobstate)

				result[#result + 1] = val..":"

				val, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, jobstate)
				
				result[#result + 1] = val
			end
		end

		--	Main chunk needs no ending character.
		if not first then
			result[#result + 1] = "}"
		end

		return concat(result)
	end,

--	Number which points to table.
	["table_reference"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		data = jobstate[1][data]

		--	If a number hasn't been written before, add the type prefix.
		if mustInitiate then
			if isKey or isLast then
				return "$"..data
			else
				return "$"..data..";"
			end
		end

		if isKey or isLast then
			return data
		else
			return data..";"
		end
	end,


--	Normal concatenations is a lot faster with small strings than table.concat
--	Also, not so branched-ish.
	["number"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		--	If a number hasn't been written before, add the type prefix.
		if mustInitiate then
			if isKey or isLast then
				return "n"..data
			else
				return "n"..data..";"
			end
		end

		if isKey or isLast then
			return data
		else
			return data..";"
		end
	end,


--	I hope gsub is fast enough.
	["string"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		if sub(data, #data, #data) == "\\" then	--	Hah, old strings fix this best.
			return "\"" .. gsub(data, "\"", "\\\"") .. "v\""
		end

		return "'" .. gsub(data, "\"", "\\\"") .. "\""
	end,


--	Fastest.
	["boolean"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		--	Prefix if we must.
		if mustInitiate then
			if data then
				return "b1"
			else
				return "b0"
			end
		end

		if data then
			return "1"
		else
			return "0"
		end
	end,


--	Fastest.
	["nil"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		return "@"
	end,
}



--[[    This section handles additions necessary for Garry's Mod.    ]]



if gmod then	--	Luckily, a specific table named after the game is present in Garry's Mod.
	local Entity = Entity



	local extra_deserialize = {
--	Entities are stored simply by the ID. They're meant to be transfered, not stored anyway.
--	Exactly like a number definition, except it begins with "e".
		["Entity"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a = i or 1
			--	Locals, locals, locals, locals

			a = find(s, "[;:}~]", i)

			if a then
				return Entity(tonumber(sub(s, i, a - 1))), a - 1
			end

			error("vON: Entity ID definition started... Found no end.")
		end,


--	A pair of 3 numbers separated by a comma (,).
		["Vector"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a, x, y, z = i or 1
			--	Locals, locals, locals, locals

			a = find(s, ",", i)

			if a then
				x = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, ",", i)

			if a then
				y = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, "[;:}~]", i)

			if a then
				z = tonumber(sub(s, i, a - 1))
			end

			if x and y and z then
				return Vector(x, y, z), a - 1
			end

			error("vON: Vector definition started... Found no end.")
		end,


--	A pair of 3 numbers separated by a comma (,).
		["Angle"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a, p, y, r = i or 1
			--	Locals, locals, locals, locals

			a = find(s, ",", i)

			if a then
				p = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, ",", i)

			if a then
				y = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, "[;:}~]", i)

			if a then
				r = tonumber(sub(s, i, a - 1))
			end

			if p and y and r then
				return Angle(p, y, r), a - 1
			end

			error("vON: Angle definition started... Found no end.")
		end,
	}

	local extra_serialize = {
--	Same as numbers, except they start with "e" instead of "n".
		["Entity"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			data = data:EntIndex()

			if mustInitiate then
				if isKey or isLast then
					return "e"..data
				else
					return "e"..data..";"
				end
			end

			if isKey or isLast then
				return data
			else
				return data..";"
			end
		end,


--	3 numbers separated by a comma.
		["Vector"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			if mustInitiate then
				if isKey or isLast then
					return "v"..data.x..","..data.y..","..data.z
				else
					return "v"..data.x..","..data.y..","..data.z..";"
				end
			end

			if isKey or isLast then
				return data.x..","..data.y..","..data.z
			else
				return data.x..","..data.y..","..data.z..";"
			end
		end,


--	3 numbers separated by a comma.
		["Angle"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			if mustInitiate then
				if isKey or isLast then
					return "a"..data.p..","..data.y..","..data.r
				else
					return "a"..data.p..","..data.y..","..data.r..";"
				end
			end

			if isKey or isLast then
				return data.p..","..data.y..","..data.r
			else
				return data.p..","..data.y..","..data.r..";"
			end
		end,
	}

	for k, v in pairs(extra_serialize) do
		_serialize[k] = v
	end

	for k, v in pairs(extra_deserialize) do
		_deserialize[k] = v
	end

	local extraEntityTypes = { "Vehicle", "Weapon", "NPC", "Player", "NextBot" }

	for i = 1, #extraEntityTypes do
		_serialize[extraEntityTypes[i]] = _serialize.Entity
	end
end



--[[    This section exposes the functions of the library.    ]]



local function checkTableForRecursion(tab, checked, assoc)
	local id = checked.ID

	if not checked[tab] and not assoc[tab] then
		assoc[tab] = id
		checked.ID = id + 1
	else
		checked[tab] = true
	end

	for k, v in pairs(tab) do
		if type(k) == "table" and not checked[k] then
			checkTableForRecursion(k, checked, assoc)
		end
		
		if type(v) == "table" and not checked[v] then
			checkTableForRecursion(v, checked, assoc)
		end
	end
end



local _s_table = _serialize.table
local _d_table = _deserialize.table

_d_meta = {
	__call = function(self, str, allowIdRewriting)
		if type(str) == "string" then
			return _d_table(str, nil, #str, true, {{}, allowIdRewriting})
		end

		error("vON: You must deserialize a string, not a "..type(str))
	end
}
_s_meta = {
	__call = function(self, data, checkRecursion)
		if type(data) == "table" then
			if checkRecursion then
				local assoc, checked = {}, {ID = 1}

				checkTableForRecursion(data, checked, assoc)

				return _s_table(data, nil, nil, nil, nil, true, {assoc, {}})
			end

			return _s_table(data, nil, nil, nil, nil, true, {false})
		end

		error("vON: You must serialize a table, not a "..type(data))
	end
}



von = {
	version = "1.3.4",
	versionNumber = 1003004,	--	Reserving 3 digits per version component.

	deserialize = setmetatable(_deserialize,_d_meta),
	serialize = setmetatable(_serialize,_s_meta)
}



return von
--PATH lua/gmodadminsuite/sh_language.lua:
local function GmodLanguage(module_name)
	if (SERVER) then return "english" end
	local lang = GetConVar("gmod_language"):GetString()
	if (lang == "en") then return "english" end
	local module_name = module_name or "GAS"
	for lang_name, data in pairs(GAS.Languages.LanguageData[module_name]) do
		if (data.Flag == "flags16/" .. lang .. ".png") then
			return lang_name
		end
	end
	return "english"
end

GAS.Languages = {}

GAS.Languages.DefaultConfig = {
	SelectedLanguages = {},
	ShortDateFormat = false,
	LongDateFormat = false,
}

if (CLIENT) then
	GAS.Languages.Config = GAS:GetLocalConfig("languages", GAS.Languages.DefaultConfig)
else
	GAS.Languages.Config = table.Copy(GAS.Languages.DefaultConfig)
end

--######## LOAD LANGUAGE DATA ########--

GAS.Languages.LanguageData = {GAS = {}}

function GAS.Languages:LoadLanguageData()
	local languages = file.Find("gmodadminsuite/lang/*.lua", "LUA")
	for _,f in ipairs(languages) do
		local filename = (f:gsub("%.lua$",""))
		GAS.Languages.LanguageData["GAS"][filename] = include("gmodadminsuite/lang/" .. f)
		if (filename == "english" or GAS.Languages.Config.SelectedLanguages.GAS == filename) then
			GAS.Languages.LanguageData["GAS"][filename].Phrases = GAS.Languages.LanguageData["GAS"][filename].Phrases()
		end
	end

	local _,modules = file.Find("gmodadminsuite/modules/*", "LUA")
	for _,module in ipairs(modules) do
		local languages = file.Find("gmodadminsuite/modules/" .. module .. "/lang/*.lua", "LUA")
		if (#languages > 0) then
			GAS.Languages.LanguageData[module] = {}
			for _,f in ipairs(languages) do
				local filename = (f:gsub("%.lua$",""))
				GAS.Languages.LanguageData[module][filename] = include("gmodadminsuite/modules/" .. module .. "/lang/" .. f)
				if (filename == "english" or GAS.Languages.Config.SelectedLanguages[module] == filename) then
					GAS.Languages.LanguageData[module][filename].Phrases = GAS.Languages.LanguageData[module][filename].Phrases()
				end
			end
		end
	end
end
GAS.Languages:LoadLanguageData()

if (GAS.Languages.Config.SelectedLanguages.GAS == nil) then
	GAS.Languages.Config.SelectedLanguages.GAS = GmodLanguage()
end

--######## LANGUAGE FUNCTIONS ########--

function GAS.Languages:LanguageExists(language_name, module_name)
	return GAS.Languages.LanguageData[module_name or "GAS"][language_name] ~= nil
end

function GAS.Languages:GetSelectedLanguage(module_name)
	if (SERVER) then return "english" end
	if (not module_name) then
		if (GAS.Languages:LanguageExists(GAS.Languages.Config.SelectedLanguages.GAS)) then
			return GAS.Languages.Config.SelectedLanguages.GAS
		else
			return GmodLanguage()
		end
	else
		if (GAS.Languages.Config.SelectedLanguages[module_name] and GAS.Languages:LanguageExists(GAS.Languages.Config.SelectedLanguages[module_name], module_name)) then
			return GAS.Languages.Config.SelectedLanguages[module_name]
		elseif (GAS.Languages:LanguageExists(GAS.Languages.Config.SelectedLanguages.GAS, module_name)) then
			return GAS.Languages.Config.SelectedLanguages.GAS
		else
			return GmodLanguage(module_name)
		end
	end
end

function GAS.Languages:RawPhrase(str, module_name, discriminator)
	local selected_language = GAS.Languages:GetSelectedLanguage(module_name)
	local phrase_str
	if (isfunction(GAS.Languages.LanguageData[module_name or "GAS"][selected_language].Phrases)) then
		GAS.Languages.LanguageData[module_name or "GAS"][selected_language].Phrases = GAS.Languages.LanguageData[module_name or "GAS"][selected_language].Phrases()
	end
	if (discriminator) then
		phrase_str = GAS.Languages.LanguageData[module_name or "GAS"][selected_language].Phrases[discriminator][str]
	else
		phrase_str = GAS.Languages.LanguageData[module_name or "GAS"][selected_language].Phrases[str]
	end
	if (phrase_str) then
		return phrase_str
	elseif (selected_language ~= "english") then
		if (discriminator) then
			if (GAS.Languages.LanguageData[module_name or "GAS"]["english"].Phrases[discriminator] ~= nil) then
				return GAS.Languages.LanguageData[module_name or "GAS"]["english"].Phrases[discriminator][str] or str
			else
				return str
			end
		else
			return GAS.Languages.LanguageData[module_name or "GAS"]["english"].Phrases[str] or str
		end
	else
		return str
	end
end
function GAS:Phrase(str, module_name, discriminator)
	if (str == "module_name") then
		local friendly_name = GAS.Languages:RawPhrase(str, module_name)
		if (friendly_name == str) then
			return nil
		else
			return friendly_name
		end
	else
		return (GAS.Languages:RawPhrase(str, module_name, discriminator):gsub("\t",""))
	end
end
function GAS:PhraseFormat(str, module_name, ...)
	return GAS:Phrase(str, module_name):format(...)
end

--######## TIMESTAMP LOCALIZATION ########--

function GAS:FormatTimestamp(timestamp)
	if (GAS.Languages.Config.ShortDateFormat ~= false) then
		return os.date(GAS.Languages.Config.ShortDateFormat, timestamp)
	else
		if (CLIENT and (system.GetCountry() == "US" or system.GetCountry() == "CA")) then
			return os.date("%m/%d/%Y %I:%M:%S %p", timestamp)
		else
			return os.date("%d/%m/%Y %I:%M:%S %p", timestamp)
		end
	end
end
function GAS:FormatFullTimestamp(timestamp)
	if (GAS.Languages.Config.LongDateFormat ~= false) then
		return os.date(GAS.Languages.Config.LongDateFormat, timestamp)
	else
		if (CLIENT and (system.GetCountry() == "US" or system.GetCountry() == "CA")) then
			return os.date("%a %m/%d/%Y %I:%M:%S %p", timestamp)
		else
			return os.date("%a %d/%m/%Y %I:%M:%S %p", timestamp)
		end
	end
end
function GAS:SimplifySeconds(seconds)
	if (seconds < 60) then
		local sec = seconds
		local lang_str = "s_seconds"
		if (sec == 1) then lang_str = "s_second" end
		return GAS:PhraseFormat(lang_str, nil, sec)
	elseif (seconds < 3600) then
		local min = math.Round(seconds / 60)
		local lang_str = "s_minutes"
		if (min == 1) then lang_str = "s_minute" end
		return GAS:PhraseFormat(lang_str, nil, min)
	else
		local hour = math.Round(seconds / 60 / 60)
		local lang_str = "s_hours"
		if (hour == 1) then lang_str = "s_hour" end
		return GAS:PhraseFormat(lang_str, nil, hour)
	end
end
function GAS:SimplifyTimestamp(timestamp)
	local difference = os.time() - timestamp
	if (difference == 0) then
		return GAS:Phrase("just_now")
	elseif (difference < 60) then

		local sec = difference
		local lang_str = "seconds_ago"
		if (sec == 1) then lang_str = "second_ago" end
		return GAS:PhraseFormat(lang_str, nil, sec)

	elseif (difference < 3600) then

		local min = math.Round(difference / 60)
		local lang_str = "minutes_ago"
		if (min == 1) then lang_str = "minute_ago" end
		return GAS:PhraseFormat(lang_str, nil, min)

	elseif (difference < 86400) then

		local hour = math.Round(difference / 60 / 60)
		local lang_str = "hours_ago"
		if (hour == 1) then lang_str = "hour_ago" end
		return GAS:PhraseFormat(lang_str, nil, hour)

	else
		return GAS:FormatTimestamp(timestamp)
	end
end

if (SERVER) then
	local languages = file.Find("gmodadminsuite/lang/*.lua", "LUA")
	for _,f in ipairs(languages) do
		AddCSLuaFile("gmodadminsuite/lang/" .. f)
	end

	local _,modules = file.Find("gmodadminsuite/modules/*", "LUA")
	for _,module in ipairs(modules) do
		local languages = file.Find("gmodadminsuite/modules/" .. module .. "/lang/*.lua", "LUA")
		for _,f in ipairs(languages) do
			AddCSLuaFile("gmodadminsuite/modules/" .. module .. "/lang/" .. f)
		end
	end
end
--PATH lua/gmodadminsuite/modules/commands/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "Command Manager",

		no_permission = "Désolé, mais vous n'avez pas la permission d'utiliser cette commande.",
		commands = "Commandes",
		command = "Commande",
		action = "Action",
		help = "Aide",
		new_command = "+ Nouvelle Commande",
		wiki = "Wiki",
		run_command = "Executer Commande",
		edit_command = "Modifier Commande",
		form_help = "Texte d'Assistance... (facultatif)",
		form_help_tip = "C'est le texte qui sera affiché dans le menu des commandes, dans le colonne \"Aide\".",
		select_action = "Selectionnez une Action...",
		hide_in_chat = "Masquer dans le chat ?",
		hide_in_chat_tip = "Si coché, le commande ne sera pas affiché dans le chat lorsque quelqu'un l'écrira.",
		finished = "Terminé",
		commands_case_insensitive = "Toutes les commandes ne sont pas sensibles aux majuscules.",
		ok = "OK",
		cannot_create_command = "Impossible de créer la commande !",
		cancel = "Annuler",
		delete_command = "Supprimer Commander",
		copy_command = "Copier Commande",
		permissions = "Permissions",
		permissions_editor = "Ouvrir l'Editeur de Permissions",
		permissions_tip = "Vous autorise à whitelister et blacklister les groupes d'utilisateurs et les équipes/métiers.",
		can_access_command = "Peu accéder à la commande",
		teams = "Equipes",
		usergroups = "Groupes d'Utilisateurs",
		anyone_can_access = "N'importe qui peut accéder à cette commande",
		whitelisted_only = "Seuls les membres whitelistés peuvent accéder à cette commande",
		non_blacklisted_only = "Seuls les membres non-blacklistés peuvent accéder à cette commande",
		whitelisted_and_blacklisted = "Seuls les membres whitelistés (excepté les blacklistés) peuvent accéder à cette commande",
		custom_usergroup = "+ Groupe d'Utilisateurs Custom",
		custom_usergroup_text = "Entrez groupe d'utilisateurs",
		custom_usergroup_placeholder = "Groupe d'Utilisateurs...",
		reason_usergroup_blacklisted = "Votre groupe d'utilisateurs est blacklisté sur cette commande.",
		reason_usergroup_not_whitelisted = "Votre group d'utilisateur n'est pas whitelisté sur cette commande.",
		reason_team_blacklisted = "Votre équipe est blacklistée sur cette commande.",
		reason_team_not_whitelisted = "Votre équipe n'est pas whitelistée sur cette commande.",
		saved_exclamation = "Sauvegardé !",
		set_position = "Définir Position",
		position_set = "Position Définie !",
		set_position_instruction = "Go to the desired position and face in the desired direction",
		set_position_instruction_2 = "When finished, unpin the menu and the position and angle will then be saved",

		action_open_commands_menu = "Ouvrir le menu des commandes",
		action_command = "Executer commande console",
		action_chat = "Envoyer un message textuel",
		action_website = "Ouvrir Site Web",
		action_lua_function_sv = "Fonction Lua Client",
		action_lua_function_cl = "Fonction Lua Serveur",
		action_gas_module = "Ouvrir Module GAS",
		action_teleport = "Téléportation",

		form_action_command = "Commande console à éxécuter",
		form_action_chat = "Message textuel à envoyer",
		form_action_website = "Site Web à ouvrir",
		form_action_lua_function_sv = "Fonction Lua à éxécuter\nCôté Serveur",
		form_action_lua_function_cl = "Fonction Lua à éxécuter\nCôté Client",
		form_action_gas_module = "Module GAS à ouvrir",
		form_action_teleport = "Téléportation",

		error_command_exists = "Une commande avec ce nom existe déjà !",
		error_no_command = "Vous n'avez entré aucune commande.",
		error_no_command_execute = "Vous n'avez pas entré la commande à éxécuter.",
		error_no_action = "Vous n'avez pas séléctionné d'action pour cette commande.",
		error_invalid_website = "Le site web spécifié n'est pas une adresse valide.",
		error_no_lua_function = "Vous n'avez pas séléctionné de Fonction Lua à éxécuter.",
		error_no_gas_module = "Vous n'avez pas séléctionné de module GAS à ouvrir.",
		error_no_position_set = "Vous n'avez pas spécifié de position et d'angle pour cette téléportation.",

} end }
--PATH lua/gmodadminsuite/modules/fpsbooster/lang/chinese.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/playerdatabase/lang/chinese.lua:
return {
    Name = "Chinese",
    Flag = "flags16/cn.png",
    Phrases = function()
        return {
            module_name = "玩家数据库",

            right_click_to_focus = "右键点击聚焦",
            steamid = "SteamID",
            name = "名称",
            usergroup = "用户组",
            ip_address = "IP地址",
            last_seen = "最后出现",
            copy_steamid = "复制SteamID",
            copy_steamid64 = "复制SteamID64",
            copy_usergroup = "复制用户组",
            copy_ip_address = "复制IP地址",
            copy_name = "复制名称",
            copy_steam_profile_link = "复制Steam个人资料链接",
            search = "搜索",
            country = "国家",
            copy_country = "复制国家",
            search_usergroup = "搜索用户组",
            search_ip_address = "搜索IP地址",
            search_country = "搜索国家",
            search_name = "搜索名称",
            none = "< 无 >",
            cancel = "取消",
        }
    end
}

--PATH lua/gmodadminsuite/modules/secondaryusergroups/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "Secondary Usergroups",

		open_menu          = "Open Menu",
		custom_ellipsis    = "Custom...",
		usergroup_ellipsis = "Usergroup...",
		players            = "Players",
		settings           = "Settings",
		players            = "Players",
		give_usergroup     = "Give Usergroup",
		usergroup_ellipsis = "Usergroup...",
		usergroup_is_main  = "This is the user's main usergroup, and cannot be given or revoked.",
		help               = "Help",
		offline_btn        = "New Player...",
		loading_ellipsis   = "Loading...",
		unknown            = "Unknown",

} end }
--PATH lua/gmodadminsuite/modules/secondaryusergroups/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "Secondary Usergroups",

		open_menu          = "Ouvrir Menu",
		custom_ellipsis    = "Custom...",
		usergroup_ellipsis = "Groupes d'Utilisateurs...",
		players            = "Joueurs",
		settings           = "Paramètres",
		players            = "Joueurs",
		give_usergroup     = "Définir Groupe",
		usergroup_ellipsis = "Groupe d'Utilisateurs...",
		usergroup_is_main  = "C'est le groupe principal des utilisateurs, il ne peut pas être donné ou retiré.",
		help               = "Aide",
		offline_btn        = "Nouveau Joueur...",
		loading_ellipsis   = "Chargement...",
		unknown            = "Inconnu",

} end }
--PATH lua/gmodadminsuite/sh_teams.lua:
GAS.Teams = {}
GAS.Teams.Identifiers = {}
GAS.Teams.IdentifiersIndexed = {}

local ReadyCallbacks = {}
function GAS.Teams:Ready(callback)
	if (GAS.Teams.CachedIdentifiers) then
		callback()
	else
		table.insert(ReadyCallbacks, callback)
	end
end

if (SERVER) then

	local function utf8_cmp(str1, str2)
		return
			str1 == str2 or
			utf8.force(str1) == utf8.force(str2)
	end

	GAS:netInit("teams:GetIdentifiers")
	local function NetworkIdentifiers(ply)
		GAS:netStart("teams:GetIdentifiers")
			net.WriteUInt(table.Count(GAS.Teams.Identifiers), 16)
			for team_index, identifier in pairs(GAS.Teams.Identifiers) do
				net.WriteUInt(team_index, 16)
				net.WriteUInt(identifier, 16)
			end
		net.Send(ply)
	end

	local GetIdentifiersQueue = {}
	GAS:netReceive("teams:GetIdentifiers", function(ply)
		if (GAS.Teams.CachedIdentifiers) then
			NetworkIdentifiers(ply)
		else
			table.insert(GetIdentifiersQueue, ply)
		end
	end)

	GAS.Teams:Ready(function()
		for _,ply in ipairs(GetIdentifiersQueue) do
			NetworkIdentifiers(ply)
		end
		GetIdentifiersQueue = {}
	end)

	local function teams_init()
		GAS.Teams.Identifiers = {}
		GAS.Teams.IdentifiersIndexed = {}
		
		GAS:print("Populating team identification...", GAS_PRINT_TYPE_INFO)

		GAS.Database:Query("SELECT `id`, `name`, `command`, `OPENPERMISSIONS_IDENTIFIER` FROM `gas_teams` WHERE `server_id`=" .. GAS.ServerID, function(rows)
			GAS.Database:BeginTransaction()

			if (DarkRP and RPExtraTeams) then
				for _,job in ipairs(RPExtraTeams) do
					local OPENPERMISSIONS_IDENTIFIER = NULL
					if (job.OPENPERMISSIONS_IDENTIFIER ~= nil) then
						OPENPERMISSIONS_IDENTIFIER = utf8.force(job.OPENPERMISSIONS_IDENTIFIER)
					end
					local found = false
					for _,row in ipairs(rows) do
						if (
							(row.OPENPERMISSIONS_IDENTIFIER ~= nil and job.OPENPERMISSIONS_IDENTIFIER ~= nil and utf8_cmp(job.OPENPERMISSIONS_IDENTIFIER, row.OPENPERMISSIONS_IDENTIFIER)) or
							(row.command ~= nil and utf8_cmp(job.command, row.command))
						) then
							found = true
							GAS.Database:Prepare("UPDATE `gas_teams` SET `name`=?, `command`=?, `OPENPERMISSIONS_IDENTIFIER`=? WHERE `server_id`=? AND `id`=?", {utf8.force(job.name), utf8.force(job.command), OPENPERMISSIONS_IDENTIFIER, GAS.ServerID, tonumber(row.id)})
							break
						end
					end
					if (not found) then
						GAS.Database:Prepare("INSERT INTO `gas_teams` (`server_id`, `name`, `command`, `OPENPERMISSIONS_IDENTIFIER`) VALUES(?,?,?,?)", {GAS.ServerID, utf8.force(job.name), utf8.force(job.command), OPENPERMISSIONS_IDENTIFIER})
					end
				end
			else
				for i,t in ipairs(team.GetAllTeams()) do
					local found = false
					for _,row in ipairs(rows) do
						if (row.name ~= nil and utf8_cmp(t.Name, row.name)) then
							found = true
							GAS.Database:Prepare("UPDATE `gas_teams` SET `name`=?, `command`=?, `OPENPERMISSIONS_IDENTIFIER`=? WHERE `server_id`=? AND `id`=?", {utf8.force(t.Name), NULL, NULL, GAS.ServerID, tonumber(row.id)})
							break
						end
					end
					if (not found) then
						GAS.Database:Prepare("INSERT INTO `gas_teams` (`server_id`, `name`, `command`, `OPENPERMISSIONS_IDENTIFIER`) VALUES(?,?,?,?)", {GAS.ServerID, utf8.force(t.Name), NULL, NULL})
					end
				end
			end

			GAS.Database:CommitTransaction(function()

				GAS.Database:Query("SELECT `id`, `name`, `command`, `OPENPERMISSIONS_IDENTIFIER` FROM `gas_teams` WHERE `server_id`=" .. GAS.ServerID, function(rows)
					for _,row in ipairs(rows) do
						if (DarkRP and RPExtraTeams) then
							for _,job in ipairs(RPExtraTeams) do
								if (GAS.Teams.Identifiers[job.team] ~= nil) then continue end
								if (
									(row.OPENPERMISSIONS_IDENTIFIER ~= nil and job.OPENPERMISSIONS_IDENTIFIER == row.OPENPERMISSIONS_IDENTIFIER) or
									(row.command ~= nil and job.command == row.command) or
									(row.name ~= nil and job.name == row.name)
								) then
									GAS.Teams.Identifiers[job.team] = tonumber(row.id)
									GAS.Teams.IdentifiersIndexed[tonumber(row.id)] = job.team
									break
								end
							end
						else
							for i,t in ipairs(team.GetAllTeams()) do
								if (GAS.Teams.Identifiers[i] ~= nil) then continue end
								if (row.name ~= nil and t.Name == row.name) then
									GAS.Teams.Identifiers[i] = tonumber(row.id)
									GAS.Teams.IdentifiersIndexed[tonumber(row.id)] = i
									break
								end
							end
						end
					end

					GAS.Teams.CachedIdentifiers = true

					for _,callback in ipairs(ReadyCallbacks) do
						callback()
					end
					ReadyCallbacks = {}

					hook.Run("GAS:TeamIdentifiersReady")

					GAS:print("Initialized team identification", GAS_PRINT_COLOR_GOOD, GAS_PRINT_TYPE_INFO)
				end)

			end)
		end)
	end

	local function sql_init()
		GAS:GMInitialize(function()
			GAS:InitPostEntity(function()
				GAS.Database:ServerID(teams_init)
			end)
		end)
		hook.Add("DConfigOnUpdateJob", "DConfig:UpdateJobCache", teams_init)
	end

	if (GAS.Database.MySQLDatabase) then
		GAS.Database:Query([[

			CREATE TABLE IF NOT EXISTS `gas_teams` (
				`id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
				`server_id` smallint(5) unsigned NOT NULL,
				`OPENPERMISSIONS_IDENTIFIER` varchar(189) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,
				`command` varchar(189) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,
				`name` varchar(189) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
				PRIMARY KEY (`id`),
				UNIQUE KEY `command` (`server_id`,`command`),
				UNIQUE KEY `OPENPERMISSIONS_IDENTIFIER` (`server_id`,`OPENPERMISSIONS_IDENTIFIER`)
			)

		]], function()
			GAS.Database:Query("SHOW INDEX FROM gas_teams WHERE KEY_NAME='name'", function(rows)
				if (rows and #rows > 0) then
					GAS.Database:Query("DROP INDEX name ON gas_teams", sql_init)
				else
					sql_init()
				end
			end)
		end)
	else
		GAS.Database:Query([[

			CREATE TABLE IF NOT EXISTS "gas_teams" (
				"id" INTEGER PRIMARY KEY,
				"server_id" INTEGER NOT NULL,
				"OPENPERMISSIONS_IDENTIFIER" TEXT DEFAULT NULL,
				"command" TEXT DEFAULT NULL,
				"name" TEXT NOT NULL,
				UNIQUE ("server_id","command"),
				UNIQUE ("server_id","OPENPERMISSIONS_IDENTIFIER")
			)

		]], sql_init)
	end

else

	GAS:netReceive("teams:GetIdentifiers", function(len)
		for i=1,net.ReadUInt(16) do
			local team_index, identifier = net.ReadUInt(16), net.ReadUInt(16)
			GAS.Teams.Identifiers[team_index] = identifier
			GAS.Teams.IdentifiersIndexed[identifier] = team_index
		end

		GAS.Teams.CachedIdentifiers = true

		for _,callback in ipairs(ReadyCallbacks) do
			callback()
		end
		ReadyCallbacks = {}

		hook.Run("GAS:TeamIdentifiersReady")
	end)

	GAS:InitPostEntity(function()
		GAS:netStart("teams:GetIdentifiers")
		net.SendToServer()
	end)

end

function GAS.Teams:GetIdentifier(team_index)
	return GAS.Teams.Identifiers[team_index]
end
function GAS.Teams:GetFromIdentifier(identifier)
	return GAS.Teams.IdentifiersIndexed[tonumber(identifier)]
end

GAS:hook("OpenPermissions:GetTeamIdentifier", "teams:OpenPermissions:GetTeamIdentifier", function(team_index)
	return GAS.Teams:GetIdentifier(team_index)
end)
GAS:hook("OpenPermissions:GetTeamFromIdentifier", "teams:OpenPermissions:GetTeamFromIdentifier", function(team_identifier)
	return GAS.Teams:GetFromIdentifier(team_identifier)
end)
--PATH lua/gmodadminsuite/modules/fpsbooster/sh_init.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/playerdatabase/sh_init.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/secondaryusergroups/sh_init.lua:
return gluapack()()
--PATH lua/autorun/grievous_pm.lua:
return gluapack()()
--PATH lua/autorun/hologramdraw.lua:
return gluapack()()
--PATH lua/imagetool/sh_image.lua:
return gluapack()()
--PATH lua/autorun/jawawarrior.lua:
return gluapack()()
--PATH lua/autorun/krennic.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/init.lua:

if CLIENT then
	LSCS.KeyToForce = LSCS.KeyToForce or {}

	function LSCS:RefreshKeys() -- we don't know how many forcepowers we gonna expect, so a lookup table might be a good idea.
		table.Empty( LSCS.KeyToForce )
		for name, entry in pairs( LSCS.Force ) do
			local ID = entry.cmd:GetInt()

			if not LSCS.KeyToForce[ ID ] then
				LSCS.KeyToForce[ ID ] = {}
			end

			table.insert( LSCS.KeyToForce[ ID ], name ) -- it must be done like this so we can bind multiple forcepowers to the same key
		end
	end
else
	AddCSLuaFile("includes/circles/circles.lua")
end

function LSCS:RegisterDeflectableTracer( tracername )
	if not table.HasValue( LSCS.BulletTracerDeflectable, tracername ) then
		table.insert( LSCS.BulletTracerDeflectable, tracername )
	end
end

LSCS:RegisterDeflectableTracer( "laser_*" ) -- this should pretty much include all laser types, but you can add your own
LSCS:RegisterDeflectableTracer( "ar2tracer_custom" )

function LSCS:AngleBetweenVectors( Vec1, Vec2 )
	local clampDot = math.Clamp( Vec1:Dot( Vec2 ) ,-1,1) -- this clamp took me 1 whole day to figure out in 2014... If the dotproduct of both vectors that are supposedly 1 unit long goes above 1 this can be NAN and cause instant ctd when applied as force...
	local rads = math.acos( clampDot ) -- rad is for nerds

	return math.deg( rads ) -- degrees is what normal humans use
end

function LSCS:SetHilt( ply, hilt_right, hilt_left )
	if hilt_right == "" or not LSCS:GetHilt( hilt_right ) then
		ply.m_lscs_hilt_right = nil
	else
		ply.m_lscs_hilt_right = hilt_right
	end

	if hilt_left == ""  or not LSCS:GetHilt( hilt_left ) then
		ply.m_lscs_hilt_left = nil
	else
		ply.m_lscs_hilt_left = hilt_left
	end
end

function LSCS:SetBlade( ply, blade_right, blade_left )
	if blade_right == "" or not LSCS:GetBlade( blade_right ) then
		ply.m_lscs_blade_right = nil
	else
		ply.m_lscs_blade_right = blade_right
	end

	if blade_left == ""  or not LSCS:GetBlade( blade_left ) then
		ply.m_lscs_blade_left = nil
	else
		ply.m_lscs_blade_left = blade_left
	end
end

function LSCS:GetHilt( name )
	return LSCS.Hilt[ name ]
end

function LSCS:GetBlade( name )
	return LSCS.Blade[ name ]
end

function LSCS:GetStance( name )
	return LSCS.Stance[ name ]
end

function LSCS:GetForce( name )
	return LSCS.Force[ name ]
end

function LSCS:ClassToItem( class )
	if not isstring( class ) then return end

	local words = string.Explode( "_", class )
	local type = words[ 2 ]
	local id = table.concat(words, "_", 3)

	if type == "saberhilt" then
		return LSCS.Hilt[ id ]
	end
	if type == "crystal" then
		return LSCS.Blade[ id ]
	end
	if type == "stance" then
		return LSCS.Stance[ id ]
	end
	if type == "force" then
		return LSCS.Force[ id ]
	end

	return false
end

local function CreateIconMaterial( class, override )
	local filepath = isstring( override ) and override or "entities/"..class..".png"

	if file.Exists( "materials/"..filepath, "GAME" ) then return Material( filepath ) end

	if file.Exists( "materials/lscs/ui/noicon.png", "GAME" ) then return Material( "lscs/ui/noicon.png" ) end

	return Material( "debug/debugwireframe" )
end

function LSCS:RegisterForce( data )
	if not data.id then return end

	local id = string.lower( data.id )
	local class = "item_force_"..id
	local fallback = function( ply ) end

	LSCS.Force[ id ] = {
		id = id,
		name = data.PrintName,
		description = data.Description,
		author = data.Author,
		icon = CreateIconMaterial( class, data.IconOverride ),
		type = "force",
		Type = "Force",
		class = class,
		Equip = (data.Equip or fallback),
		UnEquip = (data.UnEquip or fallback),
		StartUse = (data.StartUse or fallback),
		StopUse = (data.StopUse or fallback),
	}

	if data.OnClk then
		hook.Add( "LSCS:PlayerForcePowerThink", id, data.OnClk )
	end

	if CLIENT then
		LSCS.Force[ id ].cmd = CreateClientConVar( "lscs_key_force_"..id, KEY_NONE, true, true )
		LSCS:RefreshKeys()
	end

	local ENT = {}

	ENT.Base = data.EntityBase or "lscs_force_base"

	ENT.PrintName = data.PrintName
	ENT.Author = data.Author
	ENT.Category = "[LSCS] - Force"

	ENT.Spawnable = data.Spawnable ~= false
	ENT.AdminOnly = data.AdminOnly == true

	ENT.IconOverride = data.IconOverride

	scripted_ents.Register( ENT, class )
end

function LSCS:RegisterHilt( data )
	if not data.id or not data.mdl or not data.info then return end

	local id = string.lower( data.id )
	local class = "item_saberhilt_"..id

	LSCS.Hilt[ id ] = {
		id = id,
		name = data.PrintName,
		icon = CreateIconMaterial( class, data.IconOverride ),
		type = "hilt",
		Type = "Hilt",
		class = class,
		mdl = data.mdl,
		info = data.info,
	}

	local ENT = {}

	ENT.Base = data.EntityBase or "lscs_hilt_base"

	ENT.PrintName = data.PrintName
	ENT.Author = data.Author
	ENT.Category = "[LSCS] - Hilts"

	ENT.Spawnable = data.Spawnable ~= false
	ENT.AdminOnly  = data.AdminOnly == true

	ENT.IconOverride = data.IconOverride

	ENT.MDL = data.mdl

	scripted_ents.Register( ENT, class )
end

function LSCS:RegisterBlade( data )
	if not data.id then return end

	local id = string.lower( data.id )
	local class = "item_crystal_"..id

	LSCS.Blade[ id ] = {
		id = id,
		name = data.PrintName,
		icon = CreateIconMaterial( class, data.IconOverride ),
		type = "crystal",
		Type = "Crystal",
		class = class,
		color_blur = data.color_blur or Color(0,65,255),
		color_core = data.color_core or color_white,
		length = data.length or 45,
		width = data.width or 0.9,
		widthWiggle = data.widthWiggle or 0.6,
		mdl = data.mdl,
		mdl_poseparameter = data.mdl_poseparameter,
		material_core_tip = data.material_core_tip or Material( "lscs/effects/lightsaber_tip" ),
		material_core = data.material_core or Material( "lscs/effects/lightsaber_core" ),
		material_glow = data.material_glow or Material( "lscs/effects/lightsaber_glow" ),
		material_trail = data.material_trail or Material( "lscs/effects/lightsaber_trail" ),
		dynamic_light = (data.dynamic_light == true),
		no_trail = (data.no_trail == true),
		sounds = {
			Attack = (data.sounds.Attack or "saber_hup"),
			Attack1 = (data.sounds.Attack1 or "saber_spin1"),
			Attack2 = (data.sounds.Attack2 or "saber_spin2"),
			Attack3 = (data.sounds.Attack3 or "saber_spin3"),
			Activate = (data.sounds.Activate or "saber_turnon"),
			Disable = (data.sounds.Disable or "saber_turnoff"),
			Idle =  (data.sounds.Idle or "saber/saberhum4.wav"),
		}
	}

	local ENT = {}

	ENT.Base = data.EntityBase or "lscs_crystal_base"

	ENT.PrintName = data.PrintName
	ENT.Author = data.Author
	ENT.Category = "[LSCS] - Crystals"

	ENT.Spawnable       = data.Spawnable ~= false
	ENT.AdminOnly  = data.AdminOnly == true

	ENT.IconOverride = data.IconOverride

	ENT.ID = id

	scripted_ents.Register( ENT, class )
end

local function FileIsEmpty( filename )
	if file.Size( filename, "LUA" ) <= 1 then -- this is suspicous
		local data = file.Read( filename, "LUA" )

		if data and string.len( data ) <= 1 then -- confirm its empty
			print("[LSCS] - refusing to load '"..filename.."'! File is Empty!" )

			return true
		end
	end

	return false
end

LSCS.Timeout = LSCS.Timeout or 0

LSCS.Reload = function()
	local Time = CurTime()

	if LSCS.Timeout > Time then 
		print("[LSCS] - refusing refresh ["..Time.."]")

		return
	end

	LSCS.Timeout = Time + 1

	local StartTime = SysTime()

	for _, filename in pairs( file.Find("lscs/autorun/*.lua", "LUA") ) do
		if string.StartWith( filename, "sv_") then -- sv_ prefix only load serverside
			if SERVER then
				include("lscs/autorun/"..filename)
			end

			continue
		end

		if string.StartWith( filename, "cl_") then -- cl_ prefix only load clientside
			if SERVER then
				AddCSLuaFile("lscs/autorun/"..filename)
			else
				include("lscs/autorun/"..filename)
			end

			continue
		end

		-- everything else is shared
		if SERVER then
			AddCSLuaFile("lscs/autorun/"..filename)
		end
		include("lscs/autorun/"..filename)
	end

	-- combo files
	COMBO = {} -- yeah this can cause conflicts if someone happens to have a global table with the same name somewhere in his gamemode. 
	for _, filename in pairs( file.Find("lscs/combos/*.lua", "LUA") ) do
		if FileIsEmpty( "lscs/combos/"..filename ) then continue end -- sometimes i feel like people just want to troll me. Maximum incompetence honestly.

		if SERVER then
			AddCSLuaFile("lscs/combos/"..filename)
		end

		table.Empty( COMBO )

		include("lscs/combos/"..filename)

		local id = string.lower( COMBO.id )
		local class = "item_stance_"..id

		LSCS.Stance[ id ] = {
			id = id,
			name = COMBO.PrintName,
			description = COMBO.Description,
			author = COMBO.Author,
			icon = CreateIconMaterial( class, COMBO.IconOverride ),
			type = "stance",
			Type = "Stance",
			class = class,
			HoldType = COMBO.HoldType,
			DeflectBullets = COMBO.DeflectBullets,
			AutoBlock = COMBO.AutoBlock,
			Attacks = table.Copy( COMBO.Attacks ),
			LeftSaberActive = (COMBO.LeftSaberActive == true),
			MaxBlockPoints = COMBO.MaxBlockPoints,
			BPDrainPerHit = COMBO.BPDrainPerHit,
			DamageMul = (COMBO.DamageMultiplier or 1),
			BlockDistanceNormal = COMBO.BlockDistanceNormal,
			BlockDistancePerfect = COMBO.BlockDistancePerfect,
		}

		local ENT = {}

		ENT.Base = COMBO.EntityBase or "lscs_stance_base"

		ENT.PrintName = COMBO.PrintName
		ENT.Author = COMBO.Author
		ENT.Category = "[LSCS] - Stances"

		ENT.Spawnable       = COMBO.Spawnable ~= false
		ENT.AdminOnly  = COMBO.AdminOnly == true

		ENT.IconOverride = COMBO.IconOverride

		scripted_ents.Register( ENT, class )

		table.Empty( COMBO )
	end

	-- content, such as hilts, blades, force powers
	for _, filename in pairs( file.Find("lscs/content/*.lua", "LUA") ) do
		if FileIsEmpty( "lscs/content/"..filename ) then continue end -- sometimes i feel like people just want to troll me. Maximum incompetence honestly.

		if SERVER then
			AddCSLuaFile("lscs/content/"..filename)
		end
		include("lscs/content/"..filename)
	end

	print("[LSCS] - initialized ["..math.Round((SysTime() - StartTime) * 1000,2).."ms]")
end

LSCS:Reload()

-- TODO: allow this to be changed in combo file
LSCS.ComboInterupt = {
	["____"] = "b_block_forward_riposte",
	["-45-"] = "b_block_forward_riposte",
	["+45+"] = "b_block_forward_riposte",
	["__S_"] = "b_block_forward_riposte",
	["_A__"] = "b_block_left_riposte",
	["___D"] = "b_block_right_riposte",
	["W__D"] = "b_right_riposte",
	["WA__"] = "b_block_forward_riposte",
	["__SD"] = "b_right_riposte",
	["_AS_"] = "b_block_left_riposte",
	["W___"] = "b_forward_riposte",
}

LSCS.ComboInfo = {
	["____"] = {
		name = "Base Attack",
		order = 1,
		description = "[Mouse 1]",
	},
	["W___"] = {
		name = "Forward Attack",
		order = 2,
		description = "[W]+[Mouse 1]+([Shift] to prioritize)",
	},
	["__S_"] = {
		name = "Reverse Attack",
		order = 3,
		description = "[S]+[Mouse 1]",
	},
	["_A__"] = {
		name = "Left Attack",
		order = 4,
		description = "[A]+[Mouse 1]",
	},
	["___D"] = {
		name = "Right Attack",
		order = 5,
		description = "[D]+[Mouse 1]",
	},
	["W__D"] = {
		name = "Front-Right Attack",
		order = 6,
		description = "[W]+[D]+[Mouse 1]",
	},
	["WA__"] = {
		name = "Front-Left Attack",
		order = 7,
		description = "[W]+[A]+[Mouse 1]",
	},
	["__SD"] = {
		name = "Back-Right Attack",
		order = 8,
		description = "[S]+[D]+[Mouse 1]",
	},
	["_AS_"] = {
		name = "Back-Left Attack",
		order = 9,
		description = "[A]+[S]+[Mouse 1]",
	},
	["W_S_"] = {
		name = "Special Attack",
		order = 10,
		description = "[W]+[S]+[Mouse 1]",
	},
	["-45-"] = {
		name = "Up Attack",
		order = 11,
		description = "while looking UP\nPress [Mouse 1] or [W]+[Mouse 1]",
	},
	["+45+"] = {
		name = "Down Attack",
		order = 12,
		description = "while looking DOWN\nPress [Mouse 1] or [W]+[Mouse 1]",
	},
	["FRONT_DASH"] = {
		name = "Dash Forward",
		order = 13,
		description = "HOLD [SPACE]+[W] then\nPress [Mouse 1] while still in air",
	},
	["BACKFLIP"] = {
		name = "Backflip",
		order = 14,
		description = "HOLD [SPACE]+[S] then\nPress [Mouse 1] while still in air",
	},
	["SLAM"] = {
		name = "Slam",
		order = 15,
		description = "Perform a [Backflip] then\nHOLD [Mouse 1] while still in air",
	},
	["ROLL_RIGHT"] = {
		name = "Dodge Right",
		order = 16,
		description = "HOLD [SPACE]+[D] then\nPress [Mouse 1] while still in air",
	},
	["ROLL_LEFT"] = {
		name = "Dodge Left",
		order = 17,
		description = "HOLD [SPACE]+[A] then\nPress [Mouse 1] while still in air",
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_convar.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_soundscripts.lua:
-- i just put them here so they arent always in my face

for i = 1, 5 do
	local SND =  {
		name = "saber_idle"..i,
		channel = CHAN_VOICE_BASE,
		volume = 1,
		level = 75,
		pitch = 100,
		sound = "lscs/saber/saberhum"..i..".wav",
	}
	sound.Add( SND )
end

sound.Add( {
	name = "saber_hup",
	channel = CHAN_STATIC,
	volume = 0.4,
	level = 100,
	pitch = 100,
	sound = {
		"lscs/saber/saberhup1.mp3",
		"lscs/saber/saberhup2.mp3",
		"lscs/saber/saberhup3.mp3",
		"lscs/saber/saberhup5.mp3",
		"lscs/saber/saberhup6.mp3",
		"lscs/saber/saberhup7.mp3",
		"lscs/saber/saberhup8.mp3",
		"lscs/saber/saberhup9.mp3",
	}
} )

sound.Add( {
	name = "saber_spin1",
	channel = CHAN_STATIC,
	volume = 0.8,
	level = 100,
	pitch = 100,
	sound = "lscs/saber/saberspin1.wav"
} )
sound.Add( {
	name = "saber_spin2",
	channel = CHAN_STATIC,
	volume = 0.8,
	level = 100,
	pitch = 100,
	sound = "lscs/saber/saberspin2.wav"
} )
sound.Add( {
	name = "saber_spin3",
	channel = CHAN_STATIC,
	volume = 0.8,
	level = 100,
	pitch = 100,
	sound = "lscs/saber/saberspin3.wav"
} )

sound.Add( {
	name = "saber_block",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 100,
	pitch = 100,
	sound = {
		"lscs/saber/saberblock1.mp3",
		"lscs/saber/saberblock2.mp3",
		"lscs/saber/saberblock3.mp3",
		"lscs/saber/saberblock4.mp3",
		"lscs/saber/saberblock5.mp3",
		"lscs/saber/saberblock6.mp3",
		"lscs/saber/saberblock7.mp3",
		"lscs/saber/saberblock8.mp3",
		"lscs/saber/saberblock9.mp3",
	}
} )

sound.Add( {
	name = "saber_pblock",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 100,
	pitch = { 100, 100 },
	sound = {
		"lscs/saber/saberbounce1.mp3",
		"lscs/saber/saberbounce2.mp3",
		"lscs/saber/saberbounce3.mp3",
	}
} )

sound.Add( {
	name = "saber_turnon",
	channel = CHAN_STATIC,
	volume = 0.3,
	level = 75,
	pitch = { 100, 100 },
	sound = "lscs/saber/saberon.mp3",
} )

sound.Add( {
	name = "saber_turnoff",
	channel = CHAN_STATIC,
	volume = 0.3,
	level = 75,
	pitch = { 100, 100 },
	sound = "lscs/saber/saberoff.mp3",
} )

sound.Add( {
	name = "saber_hit",
	channel = CHAN_STATIC,
	volume = 1,
	level = 125,
	pitch = 100,
	sound = {
		"lscs/saber/saberhit1.mp3",
		"lscs/saber/saberhit2.mp3",
		"lscs/saber/saberhit3.mp3",
	}
} )

sound.Add( {
	name = "saber_deflect_bullet",
	channel = CHAN_STATIC,
	volume = 0.35,
	level = 100,
	pitch = 100,
	sound = {
		"lscs/saber/reflect1.mp3",
		"lscs/saber/reflect2.mp3",
		"lscs/saber/reflect3.mp3",
	}
} )

sound.Add( {
	name = "saber_lighthit",
	channel = CHAN_STATIC,
	volume = 0.75,
	level = 100,
	pitch = 100,
	sound = {
		"lscs/saber/lighthit1.wav",
		"lscs/saber/lighthit2.wav",
		"lscs/saber/lighthit3.wav",
		"lscs/saber/lighthit4.wav",
		"lscs/saber/lighthit5.wav",
	}
} )

sound.Add( {
	name = "saber_hitwall",
	channel = CHAN_STATIC,
	volume = 0.3,
	level = 100,
	pitch = { 95, 105 },
	sound = {
		"lscs/saber/saberhitwall1.mp3",
		"lscs/saber/saberhitwall2.mp3",
		"lscs/saber/saberhitwall3.mp3",
	}
} )

sound.Add( {
	name = "saber_hitwall_spark",
	channel = CHAN_STATIC,
	volume = 0.75,
	level = 100,
	pitch = { 95, 105 },
	sound = {
		"lscs/saber/spark1.wav",
		"lscs/saber/spark2.wav",
		"lscs/saber/spark3.wav",
		"lscs/saber/spark4.wav",
		"lscs/saber/spark5.wav",
		"lscs/saber/spark6.wav",
	}
} )

sound.Add( {
	name = "nanosword_hup",
	channel = CHAN_STATIC,
	volume = 1,
	level = 110,
	pitch = { 120, 130 },
	sound = {
		"weapons/stunstick/stunstick_swing1.wav",
		"weapons/stunstick/stunstick_swing2.wav",
	}
} )

sound.Add( {
	name = "nanosword_turnon",
	channel = CHAN_STATIC,
	volume = 0.1,
	level = 75,
	pitch = 100,
	sound = "lscs/nanosword/activate.ogg",
} )

sound.Add( {
	name = "nanosword_turnoff",
	channel = CHAN_STATIC,
	volume = 0.3,
	level = 75,
	pitch = 80,
	sound = {
		"weapons/stunstick/spark1.wav",
		"weapons/stunstick/spark2.wav",
		"weapons/stunstick/spark3.wav",
	}
} )

sound.Add( {
	name = "nanosword_idle",
	channel = CHAN_STATIC,
	volume = 0.15,
	level = 75,
	pitch = 75,
	sound = "ambient/energy/electric_loop.wav",
} )

--PATH lua/lscs/combos/advanced_form2.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/aggresive.lua:
COMBO.id = "aggresive"
COMBO.PrintName = "Aggressive"
COMBO.Author = "Miller"
COMBO.Description = "Aggressive stance but poor defence."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos_arrogant_corvinus"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "phalanx_b_s4_charge",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "phalanx_a_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "phalanx_b_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["__S_"] = {
		AttackAnim = "phalanx_b_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["_A__"] = {
		AttackAnim = "phalanx_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["___D"] = {
		AttackAnim = "phalanx_r_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W__D"] = {
		AttackAnim = "phalanx_a_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	},
	["WA__"] = {
		AttackAnim = "phalanx_a_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "phalanx_a_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["_AS_"] = {
		AttackAnim = "phalanx_a_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "phalanx_b_s4_charge",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}

--PATH lua/lscs/combos/basic_form2.lua:
COMBO.id = "form2a"
COMBO.PrintName = "Basic:Makashi(II)"
COMBO.Author = "Storm"
COMBO.Description = "The Way of the Ysalamiri"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 60 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 110 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form2_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "combo4",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "mak_atk_normal",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
	["-45-"] = {
		AttackAnim = "mak2_atk4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.7,
	},
	["+45+"] = {
		AttackAnim = "mak2_atk4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.7,
	},
	["W_S_"] = {
		AttackAnim = "mak_atk_w",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )


			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["__S_"] = {
		AttackAnim = "mak_atk_s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.75,
	},
	["_A__"] = {
		AttackAnim = "mak2_atk2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["___D"] = {
		AttackAnim = "mak2_atk3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["W__D"] = { 
		AttackAnim = "mak2_atk7",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.65,
	},
	["WA__"] = {
		AttackAnim = "mak2_atk6",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["__SD"] = {
		AttackAnim = "mak_atk_sd",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["_AS_"] = {
		AttackAnim = "mak_atk_sa",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["W___"] = {
		AttackAnim = "mak2_atk11",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.75,
	},
}

--PATH lua/lscs/combos/basic_form3.lua:
COMBO.id = "form3a"
COMBO.PrintName = "Basic:Soresu(III)"
COMBO.Author = "Storm"
COMBO.Description = "Way of the Mynock."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 60 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 25 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 130 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 20

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form3_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "combo4",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "sore_atk_w_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.85,
	},
	["-45-"] = {
		AttackAnim = "sore_atk_w_85s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.85,
	},
	["+45+"] = {
		AttackAnim = "sore_atk_w_85s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.85,
	},
	["W_S_"] = {
		AttackAnim = "sore_atk_w_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1,
	},
	["__S_"] = {
		AttackAnim = "sore_atk_s_85s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.85,
	},
	["_A__"] = {
		AttackAnim = "soresu2_atk1_weighed_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.85,
	},
	["___D"] = {
		AttackAnim = "soresu2_atk2_weighed_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.85,
	},
	["W__D"] = { 
		AttackAnim = "sore_atk_d_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.85,
	},
	["WA__"] = {
		AttackAnim = "sore_atk_a_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.85,
	},
	["__SD"] = {
		AttackAnim = "soresu2_atk6_weighed_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.85,
	},
	["_AS_"] = {
		AttackAnim = "soresu2_atk5_weighed_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.85,
	},
	["W___"] = {
		AttackAnim = "sore_atk_w_85s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.85,
	},
}

--PATH lua/lscs/combos/basic_form5.lua:
COMBO.id = "form5a"
COMBO.PrintName = "Basic:Shien Djem So(V)"
COMBO.Author = "Storm"
COMBO.Description = "The Way of the Krayt Dragon"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 65 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 100 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form5_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "shien_atk_normal",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "shienv2_atk_w_75s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["-45-"] = {
		AttackAnim = "shienv2_atk_w_75s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["+45+"] = {
		AttackAnim = "shienv2_atk_w_75s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["W_S_"] = {
		AttackAnim = "shienv2_atk_w_75s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["__S_"] = {
		AttackAnim = "shienv2_atk_s_75s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["_A__"] = {
		AttackAnim = "shienv2_atk_a_75s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["___D"] = {
		AttackAnim = "shienv2_atk_d_75s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["W__D"] = {
		AttackAnim = "shienv2_atk_wd_75s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["WA__"] = {
		AttackAnim = "shienv2_atk_wa_75s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["__SD"] = {
		AttackAnim = "shienv2_atk_sd_75s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["_AS_"] = {
		AttackAnim = "shienv2_atk_sa_75s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
	["W___"] = {
		AttackAnim = "shienv2_atk_normal_75s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.75,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/default.lua:
COMBO.id = "default"
COMBO.PrintName = "No-Stance"
COMBO.Author = "Luna"
COMBO.Description = "Everyone can swing a Lightsaber, but having a Lightsaber does not make you Jedi."

COMBO.DeflectBullets = false
COMBO.AutoBlock = false

COMBO.LeftSaberActive = false

COMBO.HoldType = "melee"

COMBO.Spawnable = false 

COMBO.Attacks = {}
COMBO.Attacks["____"] = {
	AttackAnim = "range_melee",
	AttackAnimMenu = "seq_baton_swing",

	BeginAttack = function( weapon, ply )  
		weapon:DoAttackSound()
	end,
	FinishAttack = function( weapon, ply )  
	end,
	Delay = 0,
	Duration = 0.25,
}
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/faststyle.lua:
COMBO.id = "faststyle"
COMBO.PrintName = "Fast Style"
COMBO.Author = "Kong"
COMBO.Description = "Utilizing short and quick motions with the blade that could be chained and combined almost indefinitely, this style allowed for multiple attacks at an extremely fast pace."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.DamageMultiplier = 1.15
COMBO.BPDrainPerHit = 50

COMBO.HoldType = "wos-melee-type"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "h_c3_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1,
	},
	["FRONT_DASH"] = {
		AttackAnim = "h_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "h_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "h_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["___D"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["W__D"] = {
		AttackAnim = "vanguard_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["WA__"] = {
		AttackAnim = "vanguard_h_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "judge_b_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "judge_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/lusma.lua:
COMBO.id = "soresu"
COMBO.PrintName = "Lus-ma"
COMBO.Author = "Midnight"
COMBO.Description = "Lus-ma was not part of the classic combat forms of the Jedi, but its lightsaber moves and ideals are akin to those of Form III."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "wos-meleeheavy-type"

COMBO.DamageMultiplier = 1
COMBO.MaxBlockPoints = 150
COMBO.BPDrainPerHit = 35
COMBO.BlockDistanceNormal = 50 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 15 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.


COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "judge_a_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "judge_b_s3_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 200 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "b_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "phalanx_h_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "vanguard_b_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "judge_b_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.5,
	},
	["___D"] = {
		AttackAnim = "judge_b_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.6,
	},
	["W__D"] = {
		AttackAnim = "vanguard_b_s3_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.8,
	},
	["WA__"] = {
		AttackAnim = "vanguard_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.5,
	},
	["__SD"] = {
		AttackAnim = "judge_h_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_b_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.8,
	},
	["W___"] = {
		AttackAnim = "judge_b_s1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.4,
	},
}
LSCS:Reload()
--PATH lua/lscs/combos/master_form1.lua:
return gluapack()()
--PATH lua/lscs/combos/master_form2.lua:
COMBO.id = "form2c"
COMBO.PrintName = "Master:Makashi(II)"
COMBO.Author = "Storm"
COMBO.Description = "The Way of the Ysalamiri"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 60 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 20 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 130 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 25

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form2_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "combo4",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,500) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "mak_atk_normal_3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.33,
	},
	["-45-"] = {
		AttackAnim = "mak_atk_normal_3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.33,
	},
	["+45+"] = {
		AttackAnim = "mak_atk_normal_3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.33,
	},
	["W_S_"] = {
		AttackAnim = "mak_atk_w_3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.35,
	},
	["__S_"] = {
		AttackAnim = "mak_atk_s_3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(-1,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.35,
	},
	["_A__"] = {
		AttackAnim = "mak_atk_a_3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,-1,0) )
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.35,
	},
	["___D"] = {
		AttackAnim = "mak_atk_d_3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,1,0) )
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.35,
	},
	["W__D"] = { 
		AttackAnim = "mak2_atk3_3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.35,
	},
	["WA__"] = {
		AttackAnim = "mak2_atk2_3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.35,
	},
	["__SD"] = {
		AttackAnim = "mak_atk_sd_3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.25,
	},
	["_AS_"] = {
		AttackAnim = "mak_atk_sa_3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.15,
	},
	["W___"] = {
		AttackAnim = "mak2_atk1_3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 0.3, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.35,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/shiensodual.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/sumadual.lua:
COMBO.id = "arrogantexperienced"
COMBO.PrintName = "Su Ma (Dual Wield)"
COMBO.Author = "TEM4S"
COMBO.Description = "Su ma was the use of rotation in the Jedi Knight's form of lightsaber combat."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.DamageMultiplier = 1.15
COMBO.BPDrainPerHit = 50

COMBO.HoldType = "lscs_butterfly"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "pure_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1.2,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "a_combo3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "pure_b_s3_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1.3,
	},
	["__S_"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "pure_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.6,
	},
	["___D"] = {
		AttackAnim = "pure_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.6,
	},
	["W__D"] = {
		AttackAnim = "pure_r_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
	["WA__"] = {
		AttackAnim = "pure_r_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
	["__SD"] = {
		AttackAnim = "pure_b_s3_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
	["_AS_"] = {
		AttackAnim = "pure_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
	["W___"] = {
		AttackAnim = "pure_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1.1,
	},
}


--PATH addons/[miecze] moce i hilty/lua/lscs/combos/versatile.lua:
COMBO.id = "versatile"
COMBO.PrintName = "Versatile"
COMBO.Author = "Miller"
COMBO.Description = "Versatile stance, the most balanced."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "melee2"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "judge_r_s3_charge",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "vanguard_r_s1_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s1_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.2,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "ryoku_a_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["__S_"] = {
		AttackAnim = "judge_r_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["_A__"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["___D"] = {
		AttackAnim = "vanguard_r_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W__D"] = {
		AttackAnim = "phalanx_a_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	},
	["WA__"] = {
		AttackAnim = "judge_a_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "phalanx_a_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["_AS_"] = {
		AttackAnim = "judge_a_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "judge_r_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/visigothdual.lua:
COMBO.id = "visigothdual"
COMBO.PrintName = "Visigoth {Dual Wield}"
COMBO.Author = "UCCROW"
COMBO.Description = "Visigoth but with 2 hands"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "wos_visigoth_corvinus"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "cartwheel",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.5,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "ryoku_r_c1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "wos_bs_shared_recovery_attack",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["__S_"] = {
		AttackAnim = "phalanx_b_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["_A__"] = {
		AttackAnim = "pure_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["___D"] = {
		AttackAnim = "pure_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W__D"] = {
		AttackAnim = "ryoku_a_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	},
	["WA__"] = {
		AttackAnim = "ryoku_a_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "wos_bs_shared_flourish_heavy",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["_AS_"] = {
		AttackAnim = "wos_bs_shared_flourish_heavy",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "vanguard_a_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.9,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/warrior.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_choke.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_clas_cleave.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_enlargeother.lua:
local force = {}
force.PrintName = "Enlarge Other"
force.Author = "Midnight"
force.Description = "Enlarge your target using the force. Just cause."
force.id = "enlargeother" -- lowercase only

force.StartUse = function(ply)
    if ply:lscsGetForce() < 10 then return end -- Check if the player has enough Force points

    -- Perform a trace to find the target
    local tr = ply:GetEyeTrace()
    local target = tr.Entity

    -- Ensure the target is a valid player or NPC
    if IsValid(target) and (target:IsPlayer() or target:IsNPC()) then
        ply:lscsTakeForce(10) -- Deduct Force points required to use the power

        target:SetModelScale(1.5, 1) -- Scaling or smth
        ply:EmitSound("npc/combine_gunship/ping_search.wav") -- Play sound effect
        LSCS:PlayVCDSequence(ply, "gesture_signal_halt", 0) -- Play animation

        -- Optional: Reset the target's scale after 10 seconds
        timer.Create("ResetModelScale_" .. target:EntIndex(), 10, 1, function()
            if IsValid(target) then
                target:SetModelScale(1, 1) -- Reset to normal size
            end
        end)
    end
end

force.StopUse = function(ply)
    -- Called when the force power key is released
end

LSCS:RegisterForce(force)

--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_greaterpull.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_greaterpull.lua:
local force = {}
force.PrintName = "Greater Pull"
force.Author = "Blu-x92 / Luna"
force.Description = "Pull things towards yourself"
force.id = "greaterpull"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 40 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/pull.mp3")
	ply:lscsTakeForce( 40 )

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_becon", 0.8 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_pull", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 1600 ) ) do
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 20 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 1600 then
				local Vel = -Sub:GetNormalized() * 2500 + Vector(0,0,50)

				LSCS:ForceApply( Ent, Vel, ply )
				if Ent:IsNPC() then
					Ent:TakeDamage( 500, ply, ply)
				end
			end
		end
	end
end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_massheal.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_repulse.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_rook.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_rook.lua:
local force = {}
force.PrintName = "Rook"
force.Author = "UCCROW"
force.Description = ""
force.id = "rook" -- lowercase only
--force.Spawnable = false  -- uncomment to unlist in q-menu

--[[
-- adds a hook to Think with 0.1 second interval. Only uncomment if needed
force.OnClk =  function( ply, TIME )
	print(TIME)
end
]]

force.Equip = function( ply )
	print("i got equipped")
end

force.UnEquip = function( ply )
	print("i got unequipped :(")
end

force.StartUse = function(ply)
    if ply:lscsGetForce() < 24 then return end -- Yeterli miktarda force puanımız var mı?

    local targetPlayer = FindTargetPlayerInArea(ply, 300) -- 300 birimlik bir alanda hedef arayalım

    if not IsValid(targetPlayer) then return end -- Geçerli bir hedef bulunamazsa çık

    -- Burada LSCS:PlayerCanManipulate fonksiyonunu kullanarak hedefi manipüle edip edemeyeceğinizi kontrol edebilirsiniz
    -- if hook.Run( "LSCS:PlayerCanManipulate", ply, targetPlayer, false ) then return end

    ply:lscsTakeForce(24) -- Force'u harcayalım

    ply:EmitSound("npc/combine_gunship/ping_search.wav")

    LSCS:PlayVCDSequence(ply, "gesture_signal_halt", 0) -- Animasyonu oynayalım

    -- Hedef oyuncuyla yer değiştiren fonksiyonu çağıralım
    SwapPositions(ply, targetPlayer)

    -- Oyuncuların altında kıvılcım efekti ekleyen fonksiyonu çağıralım
    EmitSparksEffects(ply:GetPos(), targetPlayer:GetPos())
end

function FindTargetPlayerInArea(ply, radius)
    local targets = ents.FindInSphere(ply:GetPos(), radius)
    for _, ent in ipairs(targets) do
        if ent:IsPlayer() and ent ~= ply then
            return ent
        end
    end
    return nil
end

-- Örnek bir fonksiyon: Belirli bir görüş mesafesindeki bir oyuncuyu bulup döndüren fonksiyon
function FindTargetPlayerInView(ply, distance)
    local trace = util.TraceLine({
        start = ply:EyePos(),
        endpos = ply:EyePos() + ply:GetAimVector() * distance,
        filter = function(ent) return ent:IsPlayer() and ent ~= ply end
    })

    return trace.Entity
end

-- Örnek bir fonksiyon: Hedef oyuncuyla yer değiştiren fonksiyon
function SwapPositions(ply1, ply2)
    local pos1 = ply1:GetPos()
    local pos2 = ply2:GetPos()

    ply1:SetPos(pos2)
    ply2:SetPos(pos1)
end

-- Örnek bir fonksiyon: Oyuncuların altında kıvılcım efekti ekleyen fonksiyon
function EmitSparksEffects(pos1, pos2)
    EmitSparksEffect(pos1)
    EmitSparksEffect(pos2)
end

-- Örnek bir fonksiyon: Kıvılcım efekti ekleyen fonksiyon
function EmitSparksEffect(position)
    local effectData = EffectData()
    effectData:SetOrigin(position)
    effectData:SetMagnitude(1)
    effectData:SetScale(1)

    util.Effect("HelicopterMegaBomb", effectData)
end


force.StopUse = function( ply )
	-- called when the force power key is released
end

LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_shrinkother.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_wizforce_shield.lua:
local force = {}
force.PrintName = "Force Barrier - Dome"
force.Author = "Wiz"
force.Description = "Create a dome of protection from the force."
force.id = "wizbarrierdome" -- lowercase only
--force.Spawnable = false  -- uncomment to unlist in q-menu

force.Equip = function( ply )
    print("Force Barrier - Dome equipped")
end

force.UnEquip = function( ply )
    print("Force Barrier - Dome unequipped")
end

force.StartUse = function( ply )
    if ply:lscsGetForce() < 40 then return end -- do we have enough force points?

    ply:lscsTakeForce( 10 ) -- take amount of force we need

    ply:EmitSound("npc/combine_gunship/ping_search.wav")

    LSCS:PlayVCDSequence( ply, "wos_cast_lightning", 0 ) -- play

    local animationTime = 0

    -- Increment animation time
    animationTime = animationTime + FrameTime()

    -- Loop the animation every 1.5 seconds
    if animationTime >= 1.5 then
        animationTime = 0
        LSCS:PlayVCDSequence( ply, "gesture_signal_halt", 0 )
    end

    -- Check if the player already has a force prop
    if IsValid(ply.forceProp) then return end

    -- Check if the player is in a vehicle
    if ply:InVehicle() then
        return -- Don't create the force prop if the player is in a vehicle
    end

    -- Create a think hook to continuously update the prop's position and rotation
    hook.Add("Think", "UpdateForceProp_" .. ply:UserID(), function()
        -- If the player is out of force points, stop the power and remove the prop
        if ply:lscsGetForce() <= 0 then
            -- Stop the power
            force.StopUse(ply)
            return
        end

        if not IsValid(ply) or ply:InVehicle() then
            hook.Remove("Think", "UpdateForceProp_" .. ply:UserID())
            -- Remove the force prop if the player is in a vehicle
            if IsValid(ply.forceProp) then
                hook.Remove("ShouldCollide", "ForcePropCollision_" .. ply.forceProp:EntIndex())
                ply.forceProp:Remove()
                ply.forceProp = nil
            end
            return
        end

        -- Get player's eye position and angles
        local eyePos = ply:GetPos() + Vector(0, 0, 0) -- Adjust for player's standing eye level
        local eyeAngles = ply:EyeAngles()

        -- Calculate the position to spawn the prop (in front of the player's hull by 100 units)
        local spawnPos = eyePos + eyeAngles:Forward() * 0 -- 100 units in front of the player

        -- Define the prop model
        local propModel = "models/hunter/misc/sphere2x2.mdl"

        -- Spawn or update the prop
        if not IsValid(ply.forceProp) then
            -- Spawn the prop
            local prop = ents.Create("prop_physics")
            if not IsValid(prop) then return end

            prop:SetModel(propModel)
            prop:SetModelScale(3.5)
            prop:SetMaterial("lscs/nanosword/sword3")
            prop:SetColor(Color(255, 255, 255, 12))
            prop:SetRenderMode(RENDERMODE_TRANSCOLOR)
            prop:SetPos(spawnPos)
            prop:SetAngles(Angle(0, eyeAngles.y + 90, 0)) -- Set initial rotation
            prop:Spawn()
            prop:Activate()
            prop:SetCollisionGroup(COLLISION_GROUP_DEBRIS_TRIGGER) -- Set collision group
            prop:SetCustomCollisionCheck(true) -- Enable custom collision checks

            -- Store the prop in the player's data
            ply.forceProp = prop

            -- Custom collision behavior (existing behavior)
            hook.Add("ShouldCollide", "ForcePropCollision_" .. prop:EntIndex(), function(ent1, ent2)
                if ent1 == prop or ent2 == prop then
                    local projectile = ent1:IsPlayer() or ent2:IsPlayer()
                    return not projectile -- Allow projectiles to pass through
                end
                return true
            end)

            -- Detect when the force prop takes damage from projectiles or bullets
            hook.Add("EntityTakeDamage", "ForcePropDamage_" .. prop:EntIndex(), function(ent, dmginfo)
                if ent == prop then
                    local attacker = dmginfo:GetAttacker()

                    -- Check if the attacker is an NPC or a projectile (e.g., bullet)
                    if attacker:IsNPC() then
                        -- Reduce force points when an NPC shoots at the prop
                        if ply:lscsGetForce() > 0 then
                            ply:lscsTakeForce(1) -- Take 1 force point
                            ply:EmitSound("npc/combine_gunship/ping_search.wav", 50 , 55 ,.5) -- Sound feedback
                            print(ply:GetName() .. " lost 1 force point!")
                        end
                    end
                end
            end)
        else
            -- Update the position of the prop
            ply.forceProp:SetPos(Vector(spawnPos.x, spawnPos.y, eyePos.z)) -- Set Z position to eye level

            -- Calculate the desired rotation based on the player's view direction
            local newAngles = Angle(0, eyeAngles.y + 135, 0)

            -- Apply the rotation to the prop
            ply.forceProp:SetAngles(newAngles)
        end
    end)
end

force.StopUse = function( ply )
    -- Remove the prop when the force power key is released or force runs out
    if IsValid(ply.forceProp) then
        hook.Remove("ShouldCollide", "ForcePropCollision_" .. ply.forceProp:EntIndex())
        hook.Remove("EntityTakeDamage", "ForcePropDamage_" .. ply.forceProp:EntIndex())
        ply.forceProp:Remove()
        ply.forceProp = nil
    end

    -- Remove the think hook
    hook.Remove("Think", "UpdateForceProp_" .. ply:UserID())

    -- Check if the player is in a vehicle and stop force power
    if ply:InVehicle() then
        -- Stop any additional actions or force power
        return
    end
end

LSCS:RegisterForce( force )

--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_wizforce_shield_forward.lua:
local force = {}
force.PrintName = "Force Barrier - Wall"
force.Author = "Wiz"
force.Description = "Create a wall of protection from the force."
force.id = "wizbarrierwall" -- lowercase only
--force.Spawnable = false  -- uncomment to unlist in q-menu

force.Equip = function( ply )
    print("Force Barrier - Wall equipped")
end

force.UnEquip = function( ply )
    print("Force Barrier - Wall unequipped :(")
end

force.StartUse = function( ply )
    if ply:lscsGetForce() < 40 then return end -- do we have enough force points?

    ply:lscsTakeForce( 10 ) -- take amount of force we need

    ply:EmitSound("npc/combine_gunship/ping_search.wav")

    LSCS:PlayVCDSequence( ply, "wos_cast_lightning", 0 ) -- play

    local animationTime = 0

    -- Increment animation time
    animationTime = animationTime + FrameTime()

    -- Loop the animation every 1.5 seconds
    if animationTime >= 1.5 then
        animationTime = 0
        LSCS:PlayVCDSequence( ply, "gesture_signal_halt", 0 )
    end

    -- Check if the player already has a force prop
    if IsValid(ply.forceProp) then return end

    -- Check if the player is in a vehicle
    if ply:InVehicle() then
        return -- Don't create the force prop if the player is in a vehicle
    end

    -- Create a think hook to continuously update the prop's position and rotation
    hook.Add("Think", "UpdateForceProp_" .. ply:UserID(), function()
        -- If the player is out of force points, stop the power and remove the prop
        if ply:lscsGetForce() <= 0 then
            -- Stop the power
            force.StopUse(ply)
            return
        end

        if not IsValid(ply) or ply:InVehicle() then
            hook.Remove("Think", "UpdateForceProp_" .. ply:UserID())
            -- Remove the force prop if the player is in a vehicle
            if IsValid(ply.forceProp) then
                hook.Remove("ShouldCollide", "ForcePropCollision_" .. ply.forceProp:EntIndex())
                ply.forceProp:Remove()
                ply.forceProp = nil
            end
            return
        end

        -- Get player's eye position and angles
        local eyePos = ply:GetPos() + Vector(0, 0, 0) -- Adjust for player's standing eye level
        local eyeAngles = ply:EyeAngles()

        -- Calculate the position to spawn the prop (in front of the player's hull by 100 units)
        local spawnPos = eyePos + eyeAngles:Forward() * 0 -- 100 units in front of the player

        -- Define the prop model
        local propModel = "models/lscs/barrierwall.mdl"

        -- Spawn or update the prop
        if not IsValid(ply.forceProp) then
            -- Spawn the prop
            local prop = ents.Create("prop_physics")
            if not IsValid(prop) then return end

            prop:SetModel(propModel)
            prop:SetModelScale(1)
            prop:SetMaterial("lscs/nanosword/sword3")
            prop:SetColor(Color(255, 255, 255, 12))
            prop:SetRenderMode(RENDERMODE_TRANSCOLOR)
            prop:SetPos(spawnPos)
            prop:Spawn()
            prop:Activate()
            prop:SetCollisionGroup(COLLISION_GROUP_DEBRIS_TRIGGER) -- Set collision group
            prop:SetCustomCollisionCheck(true) -- Enable custom collision checks

            -- Store the prop in the player's data
            ply.forceProp = prop

            -- Custom collision behavior (existing behavior)
            hook.Add("ShouldCollide", "ForcePropCollision_" .. prop:EntIndex(), function(ent1, ent2)
                if ent1 == prop or ent2 == prop then
                    local projectile = ent1:IsPlayer() or ent2:IsPlayer()
                    return not projectile -- Allow projectiles to pass through
                end
                return true
            end)

            -- Detect when the force prop takes damage from projectiles or bullets
            hook.Add("EntityTakeDamage", "ForcePropDamage_" .. prop:EntIndex(), function(ent, dmginfo)
                if ent == prop then
                    local attacker = dmginfo:GetAttacker()

                    -- Check if the attacker is an NPC or a projectile (e.g., bullet)
                    if attacker:IsNPC() then
                        -- Reduce force points when an NPC shoots at the prop
                        if ply:lscsGetForce() > 0 then
                            ply:lscsTakeForce(1) -- Take 1 force point
                            ply:EmitSound("npc/combine_gunship/ping_search.wav", 50 , 55 ,.5) -- Sound feedback
                            print(ply:GetName() .. " lost 1 force point!")
                        end
                    end
                end
            end)
        else
            -- Update the position of the prop
            ply.forceProp:SetPos(Vector(spawnPos.x, spawnPos.y, eyePos.z)) -- Set Z position to eye level

            -- Calculate the desired rotation based on the player's view direction
            local newAngles = Angle(0, eyeAngles.y + 180, 0)

            -- Apply the rotation to the prop
            ply.forceProp:SetAngles(newAngles)
        end
    end)
end

force.StopUse = function( ply )
    -- Remove the prop when the force power key is released or force runs out
    if IsValid(ply.forceProp) then
        hook.Remove("ShouldCollide", "ForcePropCollision_" .. ply.forceProp:EntIndex())
        hook.Remove("EntityTakeDamage", "ForcePropDamage_" .. ply.forceProp:EntIndex())
        ply.forceProp:Remove()
        ply.forceProp = nil
    end

    -- Remove the think hook
    hook.Remove("Think", "UpdateForceProp_" .. ply:UserID())

    -- Check if the player is in a vehicle and stop force power
    if ply:InVehicle() then
        -- Stop any additional actions or force power
        return
    end
end

LSCS:RegisterForce( force )

--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_crazy.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_inq.lua:
local hilt = {}
hilt.PrintName = "Grand Inquisitor"
hilt.Author = "Miller"
hilt.id = "inq"
hilt.mdl = "models/star/venator/inqusitor_saber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Inquisitor Saberstaff"
hilt.Author = "Miller"
hilt.id = "inqdouble"
hilt.mdl = "models/wos/icypineapple/inquisitor_saber_double/inquisitor_saber_double.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Inquisitor Single"
hilt.Author = "Miller"
hilt.id = "inqsingle"
hilt.mdl = "models/wos/icypineapple/inquisitor_saber/inquisitor_saber_single.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Electrostaff"
hilt.Author = "Miller"
hilt.Spawnable = false
hilt.id = "staffel"
hilt.mdl = "models/tfa/comm/gg/prp_magna_guard_weapon_season4.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-30,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(30,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Purge Electrostaff"
hilt.Author = "Miller"
hilt.Spawnable = false
hilt.id = "purgestaff"
hilt.mdl = "models/anzati/lightsabers/electrostaff.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.5, -3, 0),
            ang = Angle(90,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.5, -3.5, 0),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Electrohammer"
hilt.Author = "Miller"
hilt.Spawnable = false
hilt.id = "elechammer"
hilt.mdl = "models/anzati/lightsabers/hammer.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.5, 0, 28),
            ang = Angle(-90,-90,-90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.5, -3, -28),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-55,2,5) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [2] = {
                pos = ent:LocalToWorld( Vector(-55,2,1) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
	   [3] = {
                pos = ent:LocalToWorld( Vector(-46,2,1) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
	   [4] = { -- Top blade
                pos = ent:LocalToWorld( Vector(-80,2,-5) ),
                dir = ent:LocalToWorldAngles( Angle(0,-180,0) ):Up(),
            },
	   [5] = { -- Blade at the top
                pos = ent:LocalToWorld( Vector(-70,2,5) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [6] = {
                pos = ent:LocalToWorld( Vector(-64,2,5) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
	   [7] = {
                pos = ent:LocalToWorld( Vector(-37,2,1) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
	   [8] = {
                pos = ent:LocalToWorld( Vector(-29,2,1) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
	   [9] = {
                pos = ent:LocalToWorld( Vector(-21,2,1) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
	   [10] = {
                pos = ent:LocalToWorld( Vector(-12,2,1) ),
                dir = ent:LocalToWorldAngles( Angle(-90,-180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Riot Baton"
hilt.Author = "Miller"
hilt.Spawnable = false
hilt.id = "riotbaton"
hilt.mdl = "models/anzati/lightsabers/riotbaton.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "VibroSword"
hilt.Author = "Miller"
hilt.Spawnable = false
hilt.id = "vibrosword1"
hilt.mdl = "models/red menace/fallenorder/props/purgetrooper/dagger.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -1.5, 0),
            ang = Angle(180,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1.5, 0),
            ang = Angle(0,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,0,5) ),
                dir = ent:LocalToWorldAngles( Angle(0,0,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )



local hilt = {}
hilt.PrintName = "VibroSword Reverse"
hilt.Author = "Miller"
hilt.Spawnable = false
hilt.id = "vibrosword2"
hilt.mdl = "models/red menace/fallenorder/props/purgetrooper/dagger.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -1.5, 0),
            ang = Angle(0,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1.5, 0),
            ang = Angle(180,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(0,0,5) ),
                dir = ent:LocalToWorldAngles( Angle(0,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )


local hilt = {}
hilt.PrintName = "VibroBat"
hilt.Author = "Miller"
hilt.Spawnable = false
hilt.id = "vibrobat"
hilt.mdl = "models/jajoff/sps/cgicum/vibrobaseball.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, 0, -6),
            ang = Angle(270,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(4, 0, -6),
            ang = Angle(270,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-25,-2,0.5) ),
                dir = ent:LocalToWorldAngles( Angle(270,0,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )


local hilt = {}
hilt.PrintName = "Vibro Katana"
hilt.Author = "Miller"
hilt.Spawnable = false
hilt.id = "vibrokatana"
hilt.mdl = "models/jajoff/sps/cgicum/vibrokatana.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(4, -2, -6),
            ang = Angle(270,270,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(4, -2, -6),
            ang = Angle(270,270,0),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_staffcrosses.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_swtor2.lua:
local hilt = {}
hilt.PrintName = "Exposed Retribution"
hilt.Author = "SWTOR"
hilt.id = "Exposed Retribution"
hilt.mdl = "models/swtor/arsenic/lightsabers/retribution'sexposedlightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -10), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 10),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Exposed Reckoning"
hilt.Author = "SWTOR"
hilt.id = "Exposed Reckoning"
hilt.mdl = "models/swtor/arsenic/lightsabers/reckoning'sexposedlightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -5), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Tythian"
hilt.Author = "SWTOR"
hilt.id = "Tythian"
hilt.mdl = "models/swtor/arsenic/lightsabers/tythianlightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -12), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1, 12),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Unsealed Vengeance"
hilt.Author = "SWTOR"
hilt.id = "Unsealed Vengeance"
hilt.mdl = "models/swtor/arsenic/lightsabers/vengeance'sunsealedlightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -2, -8), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Warden"
hilt.Author = "SWTOR"
hilt.id = "Warden"
hilt.mdl = "models/swtor/arsenic/lightsabers/warden'slightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -2, -8), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Ziost Guardian"
hilt.Author = "SWTOR"
hilt.id = "Ziost Guardian"
hilt.mdl = "models/swtor/arsenic/lightsabers/ziostguardian'slightsaber.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.5, -2, -8), -- into palm direction | Left and right | up on and down in hand
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.5, -1, 8),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) local blades = {}
		
		for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
			if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
			end
			if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
			end
		end
		
		return blades
	end,
}
LSCS:RegisterHilt( hilt )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/training_saber_blade.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/training_saber_hilt.lua:
return gluapack()()
--PATH lua/lvs_framework/init.lua:

local StartTime = SysTime()

if SERVER then
	AddCSLuaFile("includes/circles/circles.lua")
end

local function FileIsEmpty( filename )
	if file.Size( filename, "LUA" ) <= 1 then -- this is suspicous
		local data = file.Read( filename, "LUA" )

		if data and string.len( data ) <= 1 then -- confirm its empty

			print("[LVS] - refusing to load '"..filename.."'! File is Empty!" )

			return true
		end
	end

	return false
end

for _, filename in pairs( file.Find("lvs_framework/autorun/*.lua", "LUA") ) do
	if FileIsEmpty( "lvs_framework/autorun/"..filename ) then continue end

	if string.StartWith( filename, "sv_") then -- sv_ prefix only load serverside
		if SERVER then
			include("lvs_framework/autorun/"..filename)
		end

		continue
	end

	if string.StartWith( filename, "cl_") then -- cl_ prefix only load clientside
		if SERVER then
			AddCSLuaFile("lvs_framework/autorun/"..filename)
		else
			include("lvs_framework/autorun/"..filename)
		end

		continue
	end

	-- everything else is shared
	if SERVER then
		AddCSLuaFile("lvs_framework/autorun/"..filename)
	end
	include("lvs_framework/autorun/"..filename)
end

hook.Run( "LVS:Initialize" )

print("[LVS] - initialized ["..math.Round((SysTime() - StartTime) * 1000,2).."ms]")

if CLIENT then
	hook.Add( "InitPostEntity", "!!!lvscheckupdates", function()
		timer.Simple(20, function()
			LVS.CheckUpdates()

			local convar = GetConVar( "no_error_hitboxes" )

			if not convar then return end

			convar:SetBool( false )
		end)
	end )

	return
end

resource.AddWorkshop("2912816023")

local ValveWierdBlastDamageClass = {
	["npc_strider"] = true, -- takes 70 damage for each blast damage as constant value ...
	["npc_combinegunship"] = true, -- takes 44 damage as constant value ...
	["func_breakable_surf"] = true, -- this entity dont care about anything that isnt a trace attack or blast damage
}

function LVS:BlastDamage( pos, forward, attacker, inflictor, damage, damagetype, radius, force )

	local dmginfo = DamageInfo()
	dmginfo:SetAttacker( attacker )
	dmginfo:SetInflictor( inflictor )
	dmginfo:SetDamage( damage )
	dmginfo:SetDamageType( damagetype == DMG_BLAST and DMG_SONIC or damagetype )

	if damagetype ~= DMG_BLAST then
		dmginfo:SetDamagePosition( pos )
		dmginfo:SetDamageForce( forward * force )

		util.BlastDamageInfo( dmginfo, pos, radius )

		return
	end

	util.BlastDamageInfo( dmginfo, pos, radius )

	local FragmentAngle = 10
	local NumFragments = 16
	local NumFragmentsMissed = 0

	local RegisteredHits = {}

	local trace = util.TraceLine( {
		start = pos,
		endpos = pos - forward * radius,
		filter = { attacker, inflictor },
	} )

	local startpos = trace.HitPos

	for i = 1, NumFragments do
		local ang = forward:Angle() + Angle( math.random(-FragmentAngle,FragmentAngle), math.random(-FragmentAngle,FragmentAngle), 0 )
		local dir = ang:Forward()

		local endpos = pos + dir * radius

		local trace = util.TraceLine( {
			start = startpos,
			endpos = endpos,
			filter = { attacker, inflictor },
		} )

		debugoverlay.Line( startpos, trace.HitPos, 10, Color( 255, 0, 0, 255 ), true )

		if not trace.Hit then
			NumFragmentsMissed = NumFragmentsMissed + 1

			continue
		end

		if not IsValid( trace.Entity ) then continue end

		if not RegisteredHits[ trace.Entity ] then
			RegisteredHits[ trace.Entity ] = {}
		end

		table.insert( RegisteredHits[ trace.Entity ], {
			origin = trace.HitPos,
			force = forward * force,
		} )
	end

	local Hull = Vector(10,10,10)

	for _, ent in ipairs( ents.FindInSphere( pos, radius ) ) do
		if not ent.LVS or ent == inflictor or ent == attacker then continue end

		local trace = util.TraceHull( {
			start = pos,
			endpos = ent:LocalToWorld( ent:OBBCenter() ),
			mins = -Hull,
			maxs = Hull,
			whitelist = true,
			ignoreworld = true,
			filter = ent,
		} )

		debugoverlay.Line( pos, trace.HitPos, 10, Color( 255, 0, 0, 255 ), true )

		NumFragments = NumFragments + 1

		if not RegisteredHits[ ent ] then
			RegisteredHits[ ent ] = {}
		end

		table.insert( RegisteredHits[ ent ], {
			origin = trace.HitPos,
			force = forward * force,
		} )
	end

	if NumFragmentsMissed == NumFragments then return end

	local DamageBoost = NumFragments / ( NumFragments - NumFragmentsMissed )

	for ent, data in pairs( RegisteredHits ) do
		local NumHits = #data
		local AverageOrigin = vector_origin
		local AverageForce = vector_origin

		for _, HitData in pairs( data ) do
			AverageOrigin = AverageOrigin + HitData.origin
			AverageForce = AverageForce + HitData.force
		end

		AverageOrigin = AverageOrigin / NumHits
		AverageForce = AverageForce / NumHits

		local TotalDamage = ( ( NumHits * DamageBoost ) / NumFragments ) * damage

		--debugoverlay.Cross( AverageOrigin, 50, 10, Color( 255, 0, 255 ) )

		-- hack
		if ValveWierdBlastDamageClass[ ent:GetClass() ] then

			util.BlastDamage( inflictor, attacker, pos, radius, damage )

			continue
		end

		local dmginfo = DamageInfo()
		dmginfo:SetAttacker( attacker )
		dmginfo:SetInflictor( inflictor )
		dmginfo:SetDamage( TotalDamage )
		dmginfo:SetDamageForce( AverageForce )
		dmginfo:SetDamagePosition( AverageOrigin )
		dmginfo:SetDamageType( DMG_BLAST )

		ent:TakeDamageInfo( dmginfo )
	end
end

function LVS:FixVelocity()
	local tbl = physenv.GetPerformanceSettings()

	if tbl.MaxVelocity < 4000 then
		local OldVel = tbl.MaxVelocity

		tbl.MaxVelocity = 4000
		physenv.SetPerformanceSettings(tbl)

		print("[LVS] Low MaxVelocity detected! Increasing! "..OldVel.." => 4000")
	end

	if tbl.MaxAngularVelocity < 7272 then
		local OldAngVel = tbl.MaxAngularVelocity

		tbl.MaxAngularVelocity = 7272
		physenv.SetPerformanceSettings(tbl)

		print("[LVS] Low MaxAngularVelocity detected! Increasing! "..OldAngVel.." => 7272")
	end
end

hook.Add( "InitPostEntity", "!!!lvscheckupdates", function()
	timer.Simple(20, function()
		LVS.CheckUpdates()
	end)
end )
--PATH lua/lvs_framework/autorun/cl_camera.lua:

function LVS:CalcView( vehicle, ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = vehicle:OBBMins()
	local mx = vehicle:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin + ( view.angles:Forward() * -radius ) + view.angles:Up() * radius * pod:GetCameraHeight()
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

hook.Add( "CalcView", "!!!!LVS_calcview", function(ply, pos, angles, fov)
	if ply:GetViewEntity() ~= ply then return end

	local pod = ply:GetVehicle()
	local vehicle = ply:lvsGetVehicle()

	if not IsValid( pod ) or not IsValid( vehicle ) then return end

	local newfov = vehicle:LVSCalcFov( fov, ply )

	local base = pod:lvsGetWeapon()

	if IsValid( base ) then
		local weapon = base:GetActiveWeapon()

		if weapon and weapon.CalcView then
			return ply:lvsSetView( weapon.CalcView( base, ply, pos, angles, newfov, pod ) )
		else
			return ply:lvsSetView( vehicle:LVSCalcView( ply, pos, angles, newfov, pod ) )
		end
	else
		local weapon = vehicle:GetActiveWeapon()

		if weapon and weapon.CalcView then
			return ply:lvsSetView( weapon.CalcView( vehicle, ply, pos, angles, newfov, pod ) )
		else
			return ply:lvsSetView( vehicle:LVSCalcView( ply, pos, angles, newfov, pod ) )
		end
	end
end )

--PATH lua/autorun/massif.lua:
player_manager.AddValidModel( "massif", 	"models/mrpounder1/player/massif.mdl" );

--PATH lua/autorun/master_association.lua:
return gluapack()()
--PATH lua/autorun/includes/modules/eventemitter.lua:
---
-- EventEmitter
--
-- Based off of Wolfy87's JavaScript EventEmitter
--
local EventEmitter = {}

local function indexOfListener(listeners, listener)
	local value
	local i = #listeners


	while i > 0 do
		value = listeners[i]
		if type(value) == 'table' and value.listener == listener then
			return i
		end
		i = i - 1
	end

	return -1
end

function EventEmitter:new(obj)
	if obj then
		table.Inherit(obj, self)
	else
		return setmetatable({}, self)
	end
end

function EventEmitter:getListeners(evt)
	local events = self:_getEvents()
	local response

	-- TODO: accept pattern matching

	if not events[evt] then
		local tbl = {}
		tbl.__array = true
		events[evt] = tbl
	end

	response = events[evt]

	return response
end

--[[function EventEmitter:flattenListeners(listeners)

end]]

function EventEmitter:getListenersAsObject(evt)
	local listeners = self:getListeners(evt)
	local response

	if listeners.__array then
		response = {}
		response[evt] = listeners
	end

	return response or listeners, wrapped
end

function EventEmitter:addListener(evt, listener)
	local listeners = self:getListenersAsObject(evt)
	local listenerIsWrapped = type(listener) == 'table'

	for key, _ in pairs(listeners) do
		if rawget(listeners, key) and indexOfListener(listeners[key], listener) == -1 then
			local value

			if listenerIsWrapped then
				value = listener
			else
				value = {
					listener = listener,
					once = false
				}
			end

			table.insert(listeners[key], value)
		end
	end

	return self
end

EventEmitter.on = EventEmitter.addListener

function EventEmitter:addOnceListener(evt, listener)
	return self:addListener(evt, {
		listener = listener,
		once = true
	})
end

EventEmitter.once = EventEmitter.addOnceListener

function EventEmitter:removeListener(evt, listener)
	local listeners = self:getListenersAsObject(evt)
	local index

	for key, _ in pairs(listeners) do
		if rawget(listeners, key) then
			index = indexOfListener(listeners[key], listener)

			if index ~= -1 then
				table.remove(listeners[key], index)
			end
		end
	end

	return self
end

EventEmitter.off = EventEmitter.removeListener

--[[function EventEmitter:addListeners(evt, listeners)

end]]

function EventEmitter:removeEvent(evt)
	local typeStr = type(evt)
	local events = self:_getEvents()
	local key

	if typeStr == 'string' then
		events[evt] = nil
	else
		self._events = nil
	end

	return self
end

EventEmitter.removeAllListeners = EventEmitter.removeEvent

function EventEmitter:emitEvent(evt, ...)
	local listeners = self:getListenersAsObject(evt)
	local listener, i, key, response

	for key, _ in pairs(listeners) do
		if rawget(listeners, key) then
			i = #listeners[key]

			while i > 0 do
				listener = listeners[key][i]

				if listener.once == true then
					self:removeListener(evt, listener.listener)
				end

				response = listener.listener(...)

				if response == self:_getOnceReturnValue() then
					self:removeListener(evt, listener.listener)
				end

				i = i - 1
			end
		end
	end

	return self
end

EventEmitter.trigger = EventEmitter.emitEvent
EventEmitter.emit = EventEmitter.emitEvent

function EventEmitter:setOnceReturnValue(value)
	self._onceReturnValue = value
	return self
end

function EventEmitter:_getOnceReturnValue()
	if rawget(self, '_onceReturnValue') then
		return self._onceReturnValue
	else
		return true
	end
end

function EventEmitter:_getEvents()
	if not self._events then
		self._events = {}
	end

	return self._events
end

_G.EventEmitter = EventEmitter

--PATH lua/autorun/includes/modules/browserpool.lua:
if browserpool then return end -- ignore Lua refresh

local table = table
local vgui = vgui

_G.browserpool = {}

---
-- Debug variable which will allow outputting messages if enabled.
-- @type boolean
--
local DEBUG = true

---
-- Array of available, pooled browsers
-- @type table
--
local available = {}

---
-- Array of active, pooled browsers.
-- @type table
--
local active = {}

---
-- Array of pending requests for a browser.
-- @type table
--
local pending = {}

---
-- Minimum number of active browsers to be pooled.
-- @type Number
--
local numMin = 2

---
-- Maximum number of active browsers to be pooled.
-- @type Number
--
local numMax = 4

---
-- Number of currently active browsers.
-- @type Number
--
local numActive = 0

---
-- Number of currently pending browser requests.
-- @type Number
--
local numPending = 0

---
-- Number of total browser requests.
-- @type Number
--
local numRequests = 0

---
-- Default URL to set browsers on setup/teardown.
-- @type String
--
local defaultUrl = "data:text/html,"

---
-- JavaScript code to remove an object's property.
-- @type String
--
local JS_RemoveProp = "delete %s.%s;"

---
-- Helper function to setup/teardown a browser panel.
--
-- @param panel?	Browser panel to be cleaned up.
-- @return Panel	DMediaPlayerHTML panel instance.
--
local function setupPanel( panel )

	-- Create a new panel if it wasn't passed in
	if panel then
		panel:Stop()
	else
		panel = vgui.Create("DMediaPlayerHTML")
	end

	-- Hide panel
	-- panel:SetSize(0, 0)
	panel:SetPos(0, 0)

	-- Disable input
	panel:SetKeyBoardInputEnabled(false)
	panel:SetMouseInputEnabled(false)

	-- Browser panels are usually manually drawn, use a regular panel if not
	panel:SetPaintedManually(true)

	-- Fix for panel not getting cleared after 3/2017 update
	panel:SetHTML( "" )

	-- Set default URL
	panel:OpenURL( defaultUrl )

	-- Remove any added function callbacks
	for obj, tbl in pairs(panel.Callbacks) do
		if obj ~= "console" then
			for funcname, _ in pairs(tbl) do
				panel:QueueJavascript(JS_RemoveProp:format(obj, funcname))
			end
		end
	end

	return panel

end

---
-- Local function for removing cancelled browser promises via closures.
--
-- @param Promise	Browser bromise.
-- @return Boolean	Success status.
--
local function removePromise( promise )
	local id = promise:GetId()

	if not pending[id] then
		ErrorNoHalt( "browserpool: Failed to remove promise.\n" )
		print( promise, id )
		debug.Trace()
		return false
	end

	pending[id] = nil
	numPending = numPending - 1

	return true
end

---
-- Browser promise for resolving browser requests when there isn't an available
-- browser at the time of request.
--
local BrowserPromise = {}
local BrowserPromiseMeta = { __index = BrowserPromise }

function BrowserPromise:New( callback, id )
	return setmetatable(
		{ __cb = callback, __id = id or -1 },
		BrowserPromiseMeta
	)
end

function BrowserPromise:GetId()
	return self.__id
end

function BrowserPromise:Resolve( value )
	self.__cb(value)
end

function BrowserPromise:Cancel( reason )
	self.__cb(false, reason)
	removePromise(self)
end

---
-- Retrieves an available browser panel from the pool. Otherwise, a new panel
-- will be created.
--
-- @return Panel	DMediaPlayerHTML panel instance.
--
function browserpool.get( callback )

	numRequests = numRequests + 1

	if DEBUG then
		print( string.format("browserpool: get [Active: %s][Available: %s][Pending: %s]",
			numActive, #available, numPending ) )
	end

	local panel

	-- Check if there's an available panel
	if #available > 0 then

		panel = table.remove( available )
		table.insert( active, panel )

		callback( panel )

	elseif numActive < numMax then -- create a new panel

		panel = setupPanel()
		numActive = numActive + 1

		if DEBUG then
			print( "browserpool: Spawned new browser [Active: "..numActive.."]" )
		end

		table.insert( active, panel )
		callback( panel )

	else -- wait for an available browser

		local promise = BrowserPromise:New( callback, numRequests )

		pending[numRequests] = promise
		numPending = numPending + 1

		return promise

	end

end

---
-- Releases the given browser panel from the active pool.
--
-- Remember to unset references to the browser instance after releasing:
--		browserpool.release( self.Browser )
--		self.Browser = nil
--
-- @param panel		Browser panel to be released.
-- @return boolean	Whether the panel was successfully removed.
--
function browserpool.release( panel, destroy )

	if not panel then return end

	local key = table.KeyFromValue( active, panel )

	-- Unable to find active browser panel
	if not key then
		ErrorNoHalt( "browserpool: Attempted to release unactive browser.\n" )
		debug.Trace()

		-- Remove browser even if the request was invalid
		if ValidPanel(panel) then
			panel:Remove()
		end

		return false
	end

	-- Resolve an open promise if one exists
	if numPending > 0 and not destroy then

		-- Get the earliest request first
		local id = table.GetFirstKey( pending )
		local promise = pending[id]

		-- Cleanup panel
		setupPanel( panel )

		promise:Resolve( panel )
		removePromise( promise )

	else

		if not table.remove( active, key ) then
			ErrorNoHalt( "browserpool: Failed to remove panel from active browsers.\n" )
			debug.Trace()

			-- Remove browser even if the request was invalid
			if ValidPanel(panel) then
				panel:Remove()
			end

			return false
		end

		-- Remove panel if there are more active than the minimum pool size
		if numActive > numMin then

			panel:Remove()
			numActive = numActive - 1

			if DEBUG then
				print( "browserpool: Destroyed browser [Active: "..numActive.."]" )
			end

		elseif not destroy then

			-- Cleanup panel
			setupPanel( panel )

			-- Add to the pool
			table.insert( available, panel )

			if DEBUG then
				print( "browserpool: Pooled browser [Active: "..numActive.."]" )
			end

		end

	end

	return true

end

--PATH lua/mediaplayer/controls/dhtmlcontrols.lua:
--[[__                                       _
 / _| __ _  ___ ___ _ __  _   _ _ __   ___| |__
| |_ / _` |/ __/ _ \ '_ \| | | | '_ \ / __| '_ \
|  _| (_| | (_|  __/ |_) | |_| | | | | (__| | | |
|_|  \__,_|\___\___| .__/ \__,_|_| |_|\___|_| |_|
                   |_| 2010 --]]

--[[---------------------------------------------------------
	Browser controls
-----------------------------------------------------------]]

local urllib = url

local PANEL = {}

AccessorFunc( PANEL, "HomeURL", "HomeURL", FORCE_STRING )

function PANEL:Init()

	local ButtonSize = 32
	local Margins = 2
	local Spacing = 0

	self.BackButton = vgui.Create( "DIconButton", self )
	self.BackButton:SetIcon( "mp-back" )
	self.BackButton:SetSize( ButtonSize, ButtonSize )
	self.BackButton:Dock( LEFT )
	self.BackButton:DockMargin( Spacing*3, Margins, Spacing, Margins )
	self.BackButton.DoClick = function()
		self.BackButton:SetDisabled( true )
		self:HTMLBack()
		self.Cur = self.Cur - 1
		self.Navigating = true
	end

	self.ForwardButton = vgui.Create( "DIconButton", self )
	self.ForwardButton:SetIcon( "mp-forward" )
	self.ForwardButton:SetSize( ButtonSize, ButtonSize )
	self.ForwardButton:Dock( LEFT )
	self.ForwardButton:DockMargin( Spacing, Margins, Spacing, Margins )
	self.ForwardButton.DoClick = function()
		self.ForwardButton:SetDisabled( true )
		self:HTMLForward()
		self.Cur = self.Cur + 1
		self.Navigating = true
	end

	self.RefreshButton = vgui.Create( "MPRefreshButton", self )
	self.RefreshButton:SetSize( ButtonSize, ButtonSize )
	self.RefreshButton:Dock( LEFT )
	self.RefreshButton:DockMargin( Spacing, Margins, Spacing, Margins )
	self.RefreshButton.DoClick = function()
		self.RefreshButton:SetDisabled( true )
		self.Refreshing = true
		self.HTML:Refresh()
	end

	self.HomeButton = vgui.Create( "DIconButton", self )
	self.HomeButton:SetIcon( "mp-home" )
	self.HomeButton:SetSize( ButtonSize, ButtonSize )
	self.HomeButton:Dock( LEFT )
	self.HomeButton:DockMargin( Spacing, Margins, Spacing*3, Margins )
	self.HomeButton.DoClick = function()
		self.HTML:Stop()
		self.HTML:OpenURL( self:GetHomeURL() )
	end

	self.AddressBar = vgui.Create( "DTextEntry", self )
	self.AddressBar:Dock( FILL )
	self.AddressBar:DockMargin( Spacing, Margins * 3, Spacing, Margins * 3 )
	self.AddressBar.OnEnter = function()
		self.HTML:Stop()
		self.HTML:OpenURL( self.AddressBar:GetValue() )
	end

	local AddrSetText = self.AddressBar.SetText
	self.AddressBar.SetText = function (panel, text)
		AddrSetText( panel, urllib.unescape(text) )
	end

	self.RequestButton = vgui.Create( "MPRequestButton", self )
	self.RequestButton:SetDisabled( true )
	self.RequestButton:Dock( RIGHT )
	self.RequestButton:DockMargin( 8, 4, 8, 4 )
	self.RequestButton.DoClick = function()
		MediaPlayer.MenuRequest( self.HTML:GetURL() )
	end

	self:SetHeight( ButtonSize + Margins * 2 )

	self.NavStack = 0
	self.History = {}
	self.Cur = 1

	-- This is the default look, feel free to change it on your created control :)
	self:SetButtonColor( Color( 250, 250, 250, 200 ) )
	self.BorderSize = 4
	self.BackgroundColor = Color( 33, 33, 33, 255 )
	self:SetHomeURL( "http://www.google.com" )

end

function PANEL:SetHTML( html )

	self.HTML = html

	if ( html.URL ) then
		self:SetHomeURL( self.HTML.URL )
	end

	self.RefreshButton:SetHTML(html)
	self.AddressBar:SetText( self:GetHomeURL() )
	self:UpdateHistory( self:GetHomeURL() )

	local OnFinishLoading = self.HTML.OnFinishLoading
	self.HTML.OnFinishLoading = function( panel )

		local url = self.HTML:GetURL()

		self.AddressBar:SetText( url )
		self:FinishedLoading()

		if OnFinishLoading then
			OnFinishLoading( panel )
		end

	end

	local OnURLChanged = self.HTML.OnURLChanged
	self.HTML.OnURLChanged = function ( panel, url )

		self.AddressBar:SetText( url )
		self.NavStack = self.NavStack + 1
		self:StartedLoading()
		self:UpdateHistory( url )

		-- Check for valid URL
		local isValidUrl = MediaPlayer.ValidUrl( url )
		self.RequestButton:SetDisabled( not isValidUrl )

		if ( OnURLChanged ) then
			OnURLChanged( panel, url )
		end

	end

end

function PANEL:UpdateHistory( url )

	--print( "PANEL:UpdateHistory", url )
	self.Cur = math.Clamp( self.Cur, 1, table.Count( self.History ) )

	local top = self.History[self.Cur]

	-- Ignore page refresh
	if top == url then
		return
	end

	if ( self.Refreshing ) then

		self.Refreshing = false
		self.RefreshButton:SetDisabled( false )
		return

	end

	if ( self.Navigating ) then

		self.Navigating = false
		self:UpdateNavButtonStatus()
		return

	end

	-- We were back in the history queue, but now we're navigating
	-- So clear the front out so we can re-write history!!
	if ( self.Cur < table.Count( self.History ) ) then

		for i = self.Cur+1, table.Count( self.History ) do
			self.History[i] = nil
		end

	end

	self.Cur = table.insert( self.History, url )

	self:UpdateNavButtonStatus()

end

function PANEL:HTMLBack()
	if self.Cur <= 1 then return end
	self.Cur = self.Cur - 1
	self.HTML:OpenURL( self.History[ self.Cur ], true )
end

function PANEL:HTMLForward()
	if self.Cur == #self.History then return end
	self.Cur = self.Cur + 1
	self.HTML:OpenURL( self.History[ self.Cur ], true )
end

function PANEL:FinishedLoading()

	self.RefreshButton:SetDisabled( false )

end

function PANEL:StartedLoading()

	self.RefreshButton:SetDisabled( true )

end

function PANEL:UpdateNavButtonStatus()

	--print( self.Cur, table.Count( self.History ) )

	self.ForwardButton:SetDisabled( self.Cur >= table.Count( self.History ) )
	self.BackButton:SetDisabled( self.Cur == 1 )

end

function PANEL:SetButtonColor( col )

	self.BackButton:SetColor( col )
	self.ForwardButton:SetColor( col )
	self.RefreshButton:SetColor( col )
	self.HomeButton:SetColor( col )

end

function PANEL:Paint()

	draw.RoundedBoxEx( self.BorderSize, 0, 0, self:GetWide(), self:GetTall(), self.BackgroundColor, true, true, false, false )

end

derma.DefineControl( "MPHTMLControls", "", PANEL, "Panel" )


--[[---------------------------------------------------------
	Media request button
	Embedded inside of the browser controls.
-----------------------------------------------------------]]

local RequestButton = {}

-- RequestButton.DisabledColor = Color(189, 195, 199)
-- RequestButton.DepressedColor = Color(192, 57, 43)
RequestButton.HoverColor = Color(192, 57, 43)
RequestButton.DefaultColor = Color(231, 76, 60)
RequestButton.DisabledColor = RequestButton.DefaultColor
RequestButton.DepressedColor = RequestButton.DefaultColor

RequestButton.DefaultTextColor = Color(236, 236, 236)
RequestButton.DisabledTextColor = Color(158, 48, 36)

function RequestButton:Init()
	DButton.Init(self)

	local ButtonSize = 32

	self:SetSize( ButtonSize*8, ButtonSize )
	self:SetFont( "MediaRequestButton" )

	self:SetDisabled( true )
end

function RequestButton:SetDisabled( disabled )
	if disabled then
		self:SetText( "SEARCH FOR MEDIA" )
	else
		self:SetText( "REQUEST URL" )
	end

	DButton.SetDisabled( self, disabled )
end

function RequestButton:UpdateColours()
	if self:GetDisabled() then
		return self:SetTextStyleColor( self.DisabledTextColor )
	else
		return self:SetTextStyleColor( self.DefaultTextColor )
	end
end

function RequestButton:Paint( w, h )
	local col

	if self:GetDisabled() then
		col = self.DisabledColor
	elseif self.Depressed or self.m_bSelected then
		col = self.DepressedColor
	elseif self:IsHovered() then
		col = self.HoverColor
	else
		-- Pulse effect
		local h, s, v = ColorToHSV( self.DefaultColor )
		v = 0.7 + math.sin(RealTime() * 10) * 0.3

		col = HSVToColor(h,s,v)
	end

	draw.RoundedBox( 2, 0, 0, w, h, col )
end

derma.DefineControl( "MPRequestButton", "", RequestButton, "DButton" )


--[[---------------------------------------------------------
	Media refresh button
	Embedded inside of the browser controls.
-----------------------------------------------------------]]

local RefreshButton = {}

AccessorFunc( RefreshButton, "HTML", "HTML" )

function RefreshButton:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-refresh" )
	self:SetText( "" )
end

local Matrix = Matrix
local vecTranslate = Vector()
local angRotate = Angle()

function RefreshButton:Paint( w, h )

	if ValidPanel(self.HTML) and self.HTML:IsLoading() then
		local x, y = self:LocalToScreen(0,0)

		vecTranslate.x = x + w / 2
		vecTranslate.y = y + h / 2

		angRotate.y = RealTime() * 512

		local mat = Matrix()
		mat:Translate( vecTranslate )
		mat:Rotate( angRotate )
		mat:Translate( -vecTranslate )
		cam.PushModelMatrix( mat )
		self._PushedMatrix = true
	end

	self.BaseClass.Paint( self, w, h )

end

function RefreshButton:PaintOver()

	if self._PushedMatrix then
		cam.PopModelMatrix()
		self._PushedMatrix = nil
	end

end

derma.DefineControl( "MPRefreshButton", "", RefreshButton, "DIconButton" )

--PATH lua/mediaplayer/sh_cvars.lua:
MediaPlayer.Cvars = {}

MediaPlayer.Cvars.Debug = CreateConVar( "mediaplayer_debug", 0, FCVAR_DONTRECORD, "Enables media player debug mode; logs a bunch of actions into the console." )
MediaPlayer.DEBUG = MediaPlayer.Cvars.Debug:GetBool()
cvars.AddChangeCallback( "mediaplayer_debug", function(name, old, new)
	MediaPlayer.DEBUG = new == 1
end)

MediaPlayer.Cvars.AllowWebpages = CreateConVar( "mediaplayer_allow_webpages", 0, {
	FCVAR_ARCHIVE,
	FCVAR_NOTIFY,
	FCVAR_REPLICATED,
	FCVAR_SERVER_CAN_EXECUTE
}, "Allows any webpage to be requested." )

MediaPlayer.Cvars.QueueLimit = CreateConVar( "mediaplayer_queue_limit", 64, {
	FCVAR_REPLICATED,
	FCVAR_SERVER_CAN_EXECUTE
}, "Maximum size of a media player queue." )

if CLIENT then

	MediaPlayer.Cvars.Resolution	= CreateClientConVar( "mediaplayer_resolution", 480, true, false )
	MediaPlayer.Cvars.Audio3D		= CreateClientConVar( "mediaplayer_3daudio", 1, true, false )
	MediaPlayer.Cvars.Volume		= CreateClientConVar( "mediaplayer_volume", 0.15, true, false )
	MediaPlayer.Cvars.MuteUnfocused	= CreateClientConVar( "mediaplayer_mute_unfocused", 1, true, false )
	MediaPlayer.Cvars.Fullscreen	= CreateClientConVar( "mediaplayer_fullscreen", 0, false, false )
	MediaPlayer.Cvars.DrawThumbnails = CreateClientConVar( "mediaplayer_draw_thumbnails", 0, true, false )

end

--PATH lua/mediaplayer/sh_events.lua:
MP.EVENTS = {
	MEDIA_CHANGED = "mediaChanged",
	QUEUE_CHANGED = "mp.events.queueChanged",
	PLAYER_STATE_CHANGED = "mp.events.playerStateChanged"
}

if CLIENT then

	table.Merge( MP.EVENTS, {
		VOLUME_CHANGED = "mp.events.volumeChanged"
	} )

end

--PATH lua/mediaplayer/players/base/net.lua:
local net = net
local CeilPower2 = MediaPlayerUtils.CeilPower2

local EOT = "\4" -- End of transmission

MEDIAPLAYER.net = {}
local mpnet = MEDIAPLAYER.net

function mpnet.ReadDuration()
	return net.ReadUInt(16)
end

function mpnet.WriteDuration( seconds )
	net.WriteUInt( seconds, 16 )
end

function mpnet.ReadMedia()
	local uid = net.ReadString()

	if uid == EOT then
		return nil
	end

	local url = net.ReadString()
	local metadata = net.ReadTable()
	local ownerName = net.ReadString()
	local ownerSteamId = net.ReadString()

	-- Create media object
	local media = MediaPlayer.GetMediaForUrl( url, true )

	-- Set uniqud ID to match the server
	media._id = uid

	media:SetMetadata( metadata, true )
	media._OwnerName = ownerName
	media._OwnerSteamID = ownerSteamId

	return media
end

function mpnet.WriteMedia( media )
	if media then
		net.WriteString( media:UniqueID() )
		net.WriteString( media:Url() )
		net.WriteTable( media._metadata or {} )
		net.WriteString( media:OwnerName() )
		net.WriteString( media:OwnerSteamID() )
	else
		net.WriteString( EOT )
	end
end

local StateBits = CeilPower2(NUM_MP_STATE) / 2

function mpnet.ReadPlayerState()
	return net.ReadUInt(StateBits)
end

function mpnet.WritePlayerState( state )
	net.WriteUInt(state, StateBits)
end

---
-- Threshold for determining if server and client system time differ.
--
local TIME_OFFSET_THRESHOLD = 2

---
-- Adjusts time returned from the server since RealTime will always differ.
--
local function correctTime( time, serverTime )
	local curTime = RealTime()
	local diffTime = os.difftime( serverTime, curTime )

	if math.abs(diffTime) > TIME_OFFSET_THRESHOLD then
		return time - diffTime
	else
		return time
	end
end

function mpnet.ReadTime()
	local time = net.ReadInt(32)
	local sync = net.ReadBit() == 1

	if sync then
		local serverTime = net.ReadInt(32)
		return correctTime(time, serverTime)
	else
		return time
	end
end

---
-- Writes the given epoch.
--
-- @param time Epoch.
-- @param sync Whether the time should be synced on the client (default: true).
--
function mpnet.WriteTime( time, sync )
	if sync == nil then sync = true end
	sync = tobool(sync)

	net.WriteInt( time, 32 )
	net.WriteBit( sync )

	if sync then
		-- We must send the current time in case either the server or the
		-- client's system clock is offset.
		net.WriteInt( RealTime(), 32 )
	end
end

---
-- Read a vote value or count.
--
function mpnet.ReadVote()
	return net.ReadInt(9)
end

---
-- Write a vote value or count.
--
function mpnet.WriteVote( value )
	net.WriteInt( value, 9 )
end

--PATH lua/mediaplayer/services/twitch/shared.lua:
DEFINE_BASECLASS( "mp_service_base" )

SERVICE.Name 	= "Twitch.TV - Video"
SERVICE.Id 		= "twv"
SERVICE.Base 	= "browser"

function SERVICE:New( url )
	local obj = BaseClass.New(self, url)

	local info = obj:GetTwitchVideoInfo()
	obj._data = info.channel .. "_" .. info.chapterId

	return obj
end

function SERVICE:Match( url )
	-- TODO: should the parsed url be passed instead?
	return (string.match(url, "justin.tv") or
			string.match(url, "twitch.tv")) and
			string.match(url, ".tv/[%w_]+/%a/%d+")
end

function SERVICE:GetTwitchVideoInfo()

	local info

	if self._twitchInfo then

		info = self._twitchInfo

	elseif self.urlinfo then

		local url = self.urlinfo

		local channel, type, chapterId = string.match(url.path, "^/([%w_]+)/(%a)/(%d+)")

		-- Chapter videos use /c/ while archived videos use /b/
		if type ~= "c" then
			type = "b"
		end

		info = {
			channel		= channel,
			type		= type,
			chapterId	= chapterId
		}

		self._twitchInfo = info

	end

	return info

end

--PATH lua/mediaplayer/services/resource/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_service_browser" )

function SERVICE:OnBrowserReady( browser )
	BaseClass.OnBrowserReady( self, browser )

	local html = self:GetHTML()
	html = self.WrapHTML( html )

	self.Browser:SetHTML( html )
end

function SERVICE:GetHTML()
	return "<h1>SERVICE.GetHTML not yet implemented</h1>"
end

--PATH lua/autorun/properties/mediaplayer.lua:
local mporder = 3200

--
-- Adds a media player property.
--
-- Blue icons correspond to admin actions.
--
local function AddMediaPlayerProperty( name, config )
	-- Assign incrementing order ID
	config.Order = mporder
	mporder = mporder + 1

	properties.Add( name, config )
end

local function IsMediaPlayer( self, ent, ply )
	return IsValid(ent) and IsValid(ply) and
			IsValid(ent:GetMediaPlayer()) and
			gamemode.Call( "CanProperty", ply, self.InternalName, ent )
end

local function IsPrivilegedMediaPlayer( self, ent, ply )
	return IsMediaPlayer( self, ent, ply ) and
		( ply:IsAdmin() or ent:GetOwner() == ply )
end

local function HasMedia( mp )
	return mp:GetPlayerState() >= MP_STATE_PLAYING
end

AddMediaPlayerProperty( "mp-pause", {
	MenuLabel	=	"Pause",
	MenuIcon	=	"icon16/control_pause_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and mp:GetPlayerState() == MP_STATE_PLAYING
	end,

	Action		=	function( self, ent )
		MediaPlayer.Pause( ent )
	end
})

AddMediaPlayerProperty( "mp-resume", {
	MenuLabel	=	"Resume",
	MenuIcon	=	"icon16/control_play_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and mp:GetPlayerState() == MP_STATE_PAUSED
	end,

	Action		=	function( self, ent )
		MediaPlayer.Pause( ent )
	end
})

AddMediaPlayerProperty( "mp-skip", {
	MenuLabel	=	"Skip",
	MenuIcon	=	"icon16/control_end_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and HasMedia(mp)
	end,

	Action		=	function( self, ent )
		MediaPlayer.Skip( ent )
	end
})

AddMediaPlayerProperty( "mp-seek", {
	MenuLabel	=	"Seek",
	-- MenuIcon	=	"icon16/timeline_marker.png",
	MenuIcon	=	"icon16/control_fastforward_blue.png",

	Filter		=	function( self, ent, ply )
		if not IsPrivilegedMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and HasMedia(mp)
	end,

	Action		=	function( self, ent )

		Derma_StringRequest(
			"Media Player",
			"Enter a time in HH:MM:SS format (hours, minutes, seconds):",
			"", -- Default text
			function( time )
				MediaPlayer.Seek( ent, time )
			end,
			function() end,
			"Seek",
			"Cancel"
		)

	end
})

AddMediaPlayerProperty( "mp-request-url", {
	MenuLabel	=	"Request URL",
	MenuIcon	=	"icon16/link_add.png",
	Filter		=	IsMediaPlayer,

	Action		=	function( self, ent )

		MediaPlayer.OpenRequestMenu( ent )

	end
})

AddMediaPlayerProperty( "mp-copy-url", {
	MenuLabel	=	"Copy URL to clipboard",
	MenuIcon	=	"icon16/paste_plain.png",

	Filter		=	function( self, ent, ply )
		if not IsMediaPlayer(self, ent, ply) then return end
		local mp = ent:GetMediaPlayer()
		return IsValid(mp) and HasMedia(mp)
	end,

	Action		=	function( self, ent )

		local mp = ent:GetMediaPlayer()
		local media = mp and mp:CurrentMedia()
		if not IsValid(media) then return end

		SetClipboardText( media:Url() )
		LocalPlayer():ChatPrint( "Media URL has been copied into your clipboard." )

	end
})

AddMediaPlayerProperty( "mp-enable", {
	MenuLabel	=	"Turn On",
	MenuIcon	=	"icon16/lightbulb.png",

	Filter		=	function( self, ent, ply )
		return IsValid(ent) and IsValid(ply) and
				ent.IsMediaPlayerEntity and
				not IsValid(ent:GetMediaPlayer()) and
				gamemode.Call( "CanProperty", ply, self.InternalName, ent )
	end,

	Action		=	function( self, ent )
		MediaPlayer.RequestListen( ent )
	end
})

AddMediaPlayerProperty( "mp-disable", {
	MenuLabel	=	"Turn Off",
	MenuIcon	=	"icon16/lightbulb_off.png",

	Filter		=	function( self, ent, ply )
		return IsValid(ent) and IsValid(ply) and
				ent.IsMediaPlayerEntity and
				IsValid(ent:GetMediaPlayer()) and
				gamemode.Call( "CanProperty", ply, self.InternalName, ent )
	end,

	Action		=	function( self, ent )
		MediaPlayer.RequestListen( ent )
	end
})

--PATH lua/mp_menu/cl_init.lua:
return gluapack()()
--PATH lua/autorun/mediaplayer_spawnables.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/language/tr.lua:
MSD.Language["tr"] = {

	lang_name = "Türkçe",

	ok = "Tamam",
	map = "Harita",
	off = "Kapalı",
	on = "Açık",
	time_add = "Eklenecek zaman",
	type = "Tür",
	delay = "Gecikme",
	cancel = "İptal",
	enable = "Aktif Et",
	model = "Model",
	name = "İsim",
	settings = "Ayarlar",
	editor = "Düzenleyici",
	red = "Kırmızı",
	green = "Yeşil",
	blue = "Mavi",
	admin_menu = "Yetkili Menüsü",
	ui_settings = "Arayüz Ayarları",
	active = "Aktif",
	inactive = "Deaktif",
	disabled = "Devre Dışı",
	warning = "Uyarı!",
	remove = "Kaldır",
	theme = "Tema",
	dark_theme = "Karanlık Tema",
	payment = "Ödeme",
	load_autosave = "Son kaydı yükleyecek misin?",
	load_save = "Kaydı yükle",
	create_new = "Yeni oluştur",
	enable_option = "Ayarı aktif et",
	main_opt = "Ana ayarlar",
	copy_data = "Veriyi kopyala",
	save_chng = "Değişiklikleri kaydet",
	enter_name = "İsimi giriniz",
	enter_id = "ID giriniz",
	confirm_action = "Eylemlerinizi lütfen onaylayınız",
	check_fpr_errors = "Hataları kontrol et",
	enter_description = "Açıklama gir",
	cooldown_ok = "Başarı sonucu bekleme süresi",
	cooldown_fail = "Hata sonucu bekleme süresi",
	s_team_whitelist = "Takım beyaz listesini ayarla",
	whitelist_blacklist = "Beyaz liste kara liste",
	custom_val = "Özel değer ayarla",
	set_hp_full = "Sağlık değerini fulle",
	dist_to_close = "En yakınına mesafe",

	e_text = "Yazı giriniz",
	e_number = "Sayı giriniz",
	e_class = "Sınıf giriniz",
	e_value = "Değer giriniz",
	e_blank_dis = "Devre dışı bırakmak için boş bırakın",
	e_blank_default = "Varsayılan ayarlar için boş bırakın",
	e_url = "Bağlantı giriniz",
	e_model = "Model uzantısını giriniz",
	e_material = "Materyal uzantısını giriniz",
	e_wep_class = "Silah sınıfını giriniz",
	e_ent_class = "Varlık sınıfını giriniz",
	e_veh_class = "Araç sınıfını giriniz",
	e_npc_class = "NPC sınıfını giriniz",

	select_ammo = "Seçili mermi",
	amount_ammo = "Mermi asyısı",
	disable_phys = "Fiziği devre dışı bırak",
	none = "Hiç",
	custom_icon = "Özel ikon ayarla",
	weapon_name = "Silah isim",
	moveup = "Yukarı git",
	movedown = "Aşağıya git",
	movepoint = "Noktayı hareket ettir",
	swap = "Değiş",
	swapmod = "Değişim modu aktif. Tıklayarak devre dışı bırak",
	copy_from_ent = "Baktığın varlıktan kopyala",
	set_pos_self = "Pozisyonunu ayarla",
	set_pos_aim = "Baktığın noktaya ayarla",
	spawn_point = "Nokta oluştur",
	spawn_ang = "Açı oluştur",
	mark_area = "Alanı işaretle",
	time_wait = "Bekleme süresi",
	map_marker = "Harita işaretçisini ayarla",
	in_sec = "saniye olarak",
	def_units = "Varsayılan %s ünit", -- "Default 350 units" leave %s as is
	def_seconds = "Varasyılan %s saniye", -- "Default 10 seconds" leave %s as is
	ent_show_pointer = "İaşretçiyi varlığın üstünde göstr",
	ent_arcade_style = "Arcade-tarzında entitiy görünüşü",
	ent_stnd_style = "Standart varlık görünüşü",
	custom_color = "Özel rengi aktif et",
	mat_default = "Varsayılan materyal için boş bırak",

	set_ui = "Kullanıcı Arayüzü ayarları",
	set_hud = "HUD ayarları",
	set_hud_pos = "Görev HUD'u ayarları",
	set_hud_themes = "HUD Temaları",
	set_server = "Sunucu ayarları",
	set_ui_blur = "Arkaplanı bulanıklaştır",
	set_ui_mono = "Monokrom arkaplan",
	set_ui_vignette = "Arka plan için vignette efekti",
	set_ui_brightness = "Arkaplan parlaklığı",
	set_ui_color = "Ana rengi seç",
	set_ui_align_left = "Sola yatay hizalama",
	set_ui_align_right = "Sağa yatay hizalama",
	set_ui_align_top = "Yukarıya dikey hizalama",
	set_ui_align_bottom = "Aşağıya dikey hizalama",
	set_ui_offset_h = "Yatay Ofset",
	set_ui_offset_v = "Dikey Ofset",

	upl_changes = "Değişiklikleri sunucuya yükle",
	res_changes = "Değişimleri eski haline getir",

	-- Player

	dead = "Öldün",
	time_ex = "Zaman doldu",
	vehicle_bum = "Aracın yok oldu",
	left_area = "Bölgeyi terk ettin",
	m_blew = "Görevi batırdın",
	m_failed = "Görev başarısız",
	m_success = "Görev başarılı",
	m_loop = "Görev güncellemesi",

	-- Errors

	inv_quest = "Geçersiz görev",
	team_bl = "Takımın karalistede",
	no_players = "Bunu yapman için sunucuda daha fazla oyuncu olması gerekmekte",
	no_players_team = "Bunu yapman için belirli takımlarda daha fazla oyuncu olması gerekmekte",
	need_admin = "Sadece adminler bu eylemi gerçekleştirebilir",

	-- Quests

	active_quest = "Aktif bir görevin var",
	inactive_quest = "Bu görevi oynayamazsın",
	quest_editor = "Görev Düzenleyicisi",
	quest_list = "Görev Listesi",
	quests = "Görevler",
	leave_pnt = "Noktadan ayrıl",

	q_editobj = "hedefleri düzenle",
	q_incvobj = "Geçersiz hedef",
	q_setobj = "Hedef ayarları",
	q_newobj = "Yeni bir hedef oluştur",
	q_editrwd = "Ödülleri düzenle",
	q_rwdeditor = "Ödül Düzenleyicisir",
	q_rwdlist = "Ödül Listesi",
	q_rwdsets = "Ödül Ayarları",
	q_findmap = "Diğer haritalardan görev bul",
	q_obj_des = "Hedef açıklaması",
	q_dist_point = "Noktaya olan uzaklık",
	q_dist_from_point = "Noktadan olan uzaklık",
	q_ignore_veh = "Görev aracını görmezden gel",
	q_timer_show = "Oyuncuya zamanlayıcıyı göster",
	q_area_stay = "Oyuncu bölgede kalmalı",
	q_start = "Görevi başlat",
	q_new = "Yeni görev",
	q_submit = "Görevi sun",
	q_addnew = "Yeni görev ekle",
	q_remove = "Görevi kaldır",
	q_id_unique = "Her bir görevin ID'si kendine özel olmalı",
	q_complete_msg = "Görevi bitirme mesajı",
	q_dotime = "Görev süresi",
	q_dotime_ok = "Süre bitince görev başarıyla tamamlansın",
	q_dotime_fail = "Süre bitince görev başarısız olsun",
	q_death_fail = "Oyuncu öldüğünde görevi iptal et",
	q_loop = "Görevleri tekrara al",
	q_loop_reward = "Her bir tekrarda oyuncuyu ödüllendir",
	q_enable = "Görevi aktif et",
	q_events = "Etkinlikler",
	q_eventadd = "Etkinlik Ekle",
	q_eventedit = "etkinlik düzenle",
	q_eventremove = "Etkinlik kaldır",
	q_in_progress = "Görev işlem sürecinde",
	q_time_left = "Kalan süre",
	q_ply_limit = "Görev için azami oyuncu sayısı",
	q_ply_team_limit = "Takım limitlerini ayarla",
	q_ply_team_need = "Gerekli takım oyuncuları",
	q_ply_need = "Başlamak için gereken oyuncu sayısı",
	q_play_limit = "Görevi kaç oyuncunun oynayabileceğinin limiti",
	q_must_stay_area = "Bu bölgenin içinde kalman gerekiyor yoksa görev başarısız olur",
	q_time_wait = "Bu görevi tekrarlaman için beklemen lazım",
	q_dotime_reset = "Görevin süresini sıfırla",
	q_dotime_add = "Göreve yapma süresi ekle",
	q_noreplay = "Bu görevi tekrar yapamazsın",
	q_dis_replay = "Görev tekrarını iptal et",
	q_needquest = "İlk başka bir görevi yapman gerekmekte",
	q_needquest_menu = "Bitirilmiş görev gerekmektedir",
	q_enterror = "Görev varlıkları oluşmamakta, görev kurulumunu kontrol et",
	q_get = "Bu NPC'lerden görev alabilirsin",
	q_noquests = "Görev yapabileceğin herhangi bir yol bulunmamakta :(",
	q_ent_draw = "Görev varlığı çizim mesafesi",
	q_loop_stop_key = "Görev tekrarlama durdurma tuşu",
	q_hold_key_stop = "görevi durdurmak için [%s] tuşuna basılı tutun", -- To stop quest hold [P]
	q_enter_veh = "Aracına bin",
	q_npc_link = "Görevi bir NPC'ye bağla",
	q_icon68 = ".PNG ve 68x68 pixel olucak şekilde bir bağlantı giriniz",
	q_ent_pos_show = "Varlık lokasyonlarını oyunculara göster",
	q_area_size = "Bölge boyutu",
	q_area_pos = "Bölge pozisyonu",
	q_s_area_size = "Bölge boyutunu ara",
	q_s_area_pos = "Bölge pozisyonunu ara",
	q_npc_answer_ok = "Oyuncunun pozitif cevabı",
	q_npc_answer_no = "Oyuncunun negatif cevabı",
	q_npc_answer_noq = "Görev yoksa oyuncunun cevabı",
	q_npc_quest_no = "Görev yoksa NPC'nin konuşması",
	q_money_give = "Verilecek para",

	-- Simple NPCs

	npc_editor = "NPC Düzenleyicisi",
	npc_new = "Yeni NPC",
	npc_select = "Bir NPC seçin",
	npc_e_speech = "NPC konuşması giriniz",
	npc_submit = "NPC oluşumunu onayla",
	npc_update = "NPC'yi güncelle",
	npc_remove = "NPC'yi kaldır",
	npc_q_enable = "Görev NPC'lerini aktif et",
	npc_did_open = "Dialog ID'si açılırken gereksin",
	npc_q_target = "NPC objektif bir hedef",
	npc_hostile = "Düşman NPC",


	-- Update 1.1.0

	cam_start = "Kamera başlama parametreleri",
	cam_end = "Kamera parametrelerini bitir",
	cam_pos = "Kamera pozisyonu",
	cam_ang = "Kamera açısı",
	cam_fov = "Kamera FOV'u",
	cam_effect = "Kamera kapanma efekti",
	q_open_target = "Diğer oyuncuların NPCleri öldürmelerine izin ver",
	q_npc_mind = "NPClere olan Min. uzaklık",
	not_spawned = "spawnlanmamış",
	dis_text = "Sergilenen Yazı",
	cam_speed = "Kamera hızı (düşük sayı - düşük hız)",
	fov_speed = "FOV değişme hızı (düşük sayı - düşük hız)",
	category_des = "Görev kategorisi, görevleri sınıflamak için kullanılır",
	sortquests_cat = "Görevleri kategoriye göre düzenle",
	search_q = "Görev ara",
	quest_tools = "Görev araçları",
	set_anim = "Animasyon ayarla",
	s_quest_blacklist = "Görev karalistesi oluştur",
	s_quest_blacklist_desc = "Bitirildiğinde bu görevi engelleyecek görevleri seçin",
	hold_use = "Basılı Tut [%s]",
	duplicate = "Çiftle",
	unsorted = "Sınıflandırılmamış",
	search = "Ara",
	duration = "Süre",
	category = "Kategori",
	blacklist = "Karaliste",


	--  Update 1.2.0

	restore_wep = "Görev sonunda silahları geri yükle",
	e_cmd = "Konsol komutunu girin",
	e_args = "Komut bağımsız değişkenlerini girin",
	hint_cmd = "Otomatik doldurma kısayolları: \n$uid - Kullanıcı Kimliği, \n$sid - SteamID, \n$s64 - SteamID 64, \n$n - Oyuncu adı",
	youaretracked = "Konumunuzu artık diğer oyuncular da görebiliyor!",
	border_rounded = "Yuvarlak kenarlık tasarımı",
	border_square = "Kare kenarlık tasarımı",
	access_settings = "Menü erişimi",
	compact_obj = "Görevler için kompakt hedef listesi",
	e_usergroup = "Kullanıcı grubu girin",
	ug_isanadmin = "Bu kullanıcı grubu zaten tam erişime sahip",
	find_player_id32 = "SteamID 32 ile oyuncu verilerini bulun",
	user_data = "Kullanıcı verileri düzenleyicisi",
	access_editors = "Görev düzenleyicilerinin erişimini ayarla",
	access_admins = "Tam erişimi ayarla",
	add_usergroup = "Kullanıcı grubu ekle",
	edit_objmod = "Objektif sırasını düzenle",
	editmod = "Düzenleme modu",
	move = "Taşı",
	q_errorloop = "Görev sonsuz bir döngüye girdi",
	q_cooldow_perply = "Genel bekleme süresi sayacı",
	q_cooldow_publick = "Oyuncu Başına bekleme süresi sayacı",
	q_stop_anytime = "Görevi manuel olarak bırakmaya izin ver",
	quest_abandon = "Görevi terk ettin",
	q_dotime_set = "Görev yapma zamanını ayarla",

	-- Ranks

	enter_path_or_url = "Klasör yolu ya da url girin",
	rank_edit = "Rütbe Ayarla",
	rank_list = "Rütbe Listesi",
	group_list = "Grup Listesi",
	group_addnew = "Yeni grup ekle",
	blank = "Boş",
	mrs_show_all = "Tüm oyunculara rütbeleri göster",
	mrs_show_team = "Sadece gruplara rütbeleri göster",
	mrs_use_sn = "Rütbe kısaltmalarını göster",
	use_url = "URL kullan",
	enter_srt_name = "Kısaltma gir",
	srt_name = "Kısaltma",
	mrs_prom_demote = "Sıradaki 2 ayar sadece düşük rütbeleri etkileyecek. Bu rütbeye sahip oyuncular, diğer oyuncuları daha yüksek rütbelere veya aynı rütbeye terfi ettiremezler.",
	mrs_whilelist = "Bir iş için rütbe gereksinimini seçerseniz, oyuncu bu işi ancak rütbesi seçilen veya daha yüksek olanla eşleşirse oynayabilir.",
	can_promote = "Oyuncuları terfi ettirebilir",
	can_demote = "Oyuncuların rütbesini düşürebilir",
	edit_player_model = "Özel oyuncu modelini düzenle",
	enable_player_model = "Özel oyuncu modelini aktifleştir",
	disable_player_model = "Özel oyuncu modelini deaktif et",
	edit_custom_stats = "Özel oyuncu istatistiklerini düzenle",
	autoprom = "Sonraki rütbeye otomatik yükselt",
	in_min = "dakika içinde",
	mrs_promoted = "Terfi aldın",
	mrs_demoted = "Rütben düşürüldü",
	mrs_job_smallrank = "%s ya da daha üst bir rütbeye değilsen %s olarak oynayamazsın", -- You must be Sergeant II or higher to play as Watch Commander
	show_group = "Rütbe grup ismini göster",
	hide_rank = "Sadece rütbe ikonunu göster",
	mrs_hud_follow = "Arayüzü oyuncunun bakış açısına göre döndür",
	set_overhead = "Oyuncu bilgisi arayüzü",
	offline_users = "Çevrimdışı oyuncular",
	mrs_noranks = "Şu anki mesleğinin rütbesi yok",
	mrs_nopower = "Şu anki rütbenin ekstra izini yok",
	promotion = "Terfi",
	on_duty = "Görevde",
	other_players = "Diğer oyuncular",
	mrs_change_jobname = "Meslek ismini rütbe ismi olarak değiştir",
	mrs_set_prefix = "Rütbe ismini mesleğin başına ekle",
	copy_all_data = "Bütün verileri kopyala",
	copy_only_stats = "Sadece istatistikleri ve oyuncu modelini kopyala",
	mrs_change_plyname = "Oyuncunun ismini rütbe ismi yap",
	mrs_set_prefix_ply = "Rütbe ismini önek gibi oyuncunun isminin önüne koy",

}

-- Other phrases
local lng = "tr"

MSD.Language[lng]["Move to point"] = "Noktaya git"
MSD.Language[lng]["Leave area"] = "Bölgeden ayrıl"
MSD.Language[lng]["Kill NPC"] = "NPC'yi öldür"
MSD.Language[lng]["Collect quest ents"] = "Görev varlıklarını topla"
MSD.Language[lng]["Talk to NPC"] = "NPC ile konuş"
MSD.Language[lng]["There is no quests available"] = "Mevcut görev bulunmamakta"
MSD.Language[lng]["Give weapon"] = "Silah ver"
MSD.Language[lng]["Give ammo"] = "Mermi ver"
MSD.Language[lng]["Strip Weapon"] = "Silaha el koy"
MSD.Language[lng]["Spawn quest entity"] = "Görev varlığı oluştur"
MSD.Language[lng]["Spawn entity"] = "Varlık oluştur"
MSD.Language[lng]["Spawn npc"] = "NPC oluştur"
MSD.Language[lng]["Manage do time"] = "Yapım süresini yönet"
MSD.Language[lng]["Spawn vehicle"] = "Araç oluştur"
MSD.Language[lng]["Remove vehicle"] = "Aracı kaldır"
MSD.Language[lng]["Remove all entites"] = "Tüm varlıkları kaldır"
MSD.Language[lng]["Set HP"] = "Can Ayarla"
MSD.Language[lng]["Set Armor"] = "Zırh Ayarla"
MSD.Language[lng]["DarkRP Money"] = "DarkRP Parası"
MSD.Language[lng]["Quest NPCs are disabled"] = "Görev NPC'leri devre dışı"
MSD.Language[lng]["You can enable them in settings"] = "Ayarlardan aktif edebilirsin"
--PATH lua/autorun/mvp_phands_clones2.lua:
hook.Add("mvp.phands.RegisterThemes", "mvp.phands.Clones2Themes", function()
    local P = mvp.package.Get("perfecthands")

    P.themes.Register("clones2", {
        ["armsbehind"] = Material("mvp/perfecthands/themes/clone2/armsbehind.png", "mips smooth"),
        ["armsbehindhead"] = Material("mvp/perfecthands/themes/clone2/armsbehindhead.png", "mips smooth"),
        ["armsinfront"] = Material("mvp/perfecthands/themes/clone2/armsinfront.png", "mips smooth"),
        ["armsonbelt"] = Material("mvp/perfecthands/themes/clone2/armsonbelt.png", "mips smooth"),
        ["comlink"] = Material("mvp/perfecthands/themes/clone2/comlink.png", "mips smooth"),
        ["highfive"] = Material("mvp/perfecthands/themes/clone2/highfive.png", "mips smooth"),
        ["hololink"] = Material("mvp/perfecthands/themes/clone2/hololink.png", "mips smooth"),
        ["pensive"] = Material("mvp/perfecthands/themes/clone2/pensive.png", "mips smooth"),
        ["point"] = Material("mvp/perfecthands/themes/clone2/point.png", "mips smooth"),
        ["salute"] = Material("mvp/perfecthands/themes/clone2/salute.png", "mips smooth"),
        ["surrender"] = Material("mvp/perfecthands/themes/clone2/surrender.png", "mips smooth"),
        ["typing"] = Material("mvp/perfecthands/themes/clone2/typing.png", "mips smooth"),
    })

    mvp.language.Register("en", {
        ["phands.themes.clones2"] = "Clone Phase II"
    })
end)
--PATH lua/autorun/mvp_terminal.lua:
return gluapack()()
--PATH lua/mvp/cl_init.lua:
mvp = mvp or {}

include("mvp/core/sh_loader.lua")
--PATH lua/mvp/sh_init.lua:
--- @module mvp

mvp = mvp or {}

--- A table of variable types that are used throughout the framework. It represents types as a table with the keys being the
-- name of the type, and the values being some number value. **You should never directly use these number values!** Using the
-- values from this table will ensure backwards compatibility if the values in this table change.
--
-- This table also contains the numerical values of the types as keys. This means that if you need to check if a type exists, or
-- if you need to get the name of a type, you can do a table lookup with a numerical value. Note that special types are not
-- included since they are not real types that can be compared with.
-- @table mvp.type
-- @realm shared
-- @field string A regular string.
-- @field number Any number.
-- @field player Any player that matches the given query string in `mvp.util.FindPlayer`.
-- @field steamid A string that matches the Steam ID format of `STEAM_X:X:XXXXXXXX`.
-- @field bool A string representation of a bool - `false` and `0` will return `false`, anything else will return `true`.
-- @field color A color represented by its red/green/blue/alpha values.
-- @field vector A 3D vector represented by its x/y/z values.
-- @field array Any table.
-- @usage -- checking if type exists
-- print(mvp.type[2] ~= nil)
-- > true
--
-- -- getting name of type
-- print(mvp.type[mvp.type.string])
-- > 'string'

mvp.type = {
    [2] = "string",
    [4] = "text",
    [8] = "number",
    [16] = "player",
    [32] = "steamid",
    [64] = "bool",
    [512] = "table", -- array
    [1024] = "color",
    [2048] = "vector",

    string = 2,
    text = 4,
    number = 8,
    player = 16,
    steamid = 32,
    bool = 64,
    color = 1024,
    vector = 2048,

    optional = 256,
    array = 512,
    table = 512 -- alias
} 

mvp.colors = mvp.colors or {}

mvp.colors.Background = Color(32, 32, 32)
mvp.colors.SecondaryBackground = Color(51, 51, 51)
mvp.colors.BackgroundHover = Color(63, 63, 63)
mvp.colors.Accent = Color(255, 192, 92)
mvp.colors.SecondaryAccent = Color(82, 82, 82)

mvp.colors.Red = Color(255, 92, 92)
mvp.colors.Blue = Color(92, 92, 255)
mvp.colors.Green = Color(46, 204, 113) -- rgb(46, 204, 113)
mvp.colors.Yellow = Color(255, 255, 46)
mvp.colors.Purple = Color(255, 92, 255)
mvp.colors.Cyan = Color(92, 255, 255)
mvp.colors.Orange = Color(255, 128, 0)

mvp.colors.Text = Color(255, 255, 255)

mvp.LOG = {
    INFO = 1,
    WARN = 2,
    ERROR = 3,
    FATAL = 4,
    DEBUG = 5,

    [1] = "INFO",
    [2] = "WARN",
    [3] = "ERROR",
    [4] = "FATAL",
    [5] = "DEBUG"
}

mvp.NOTIFICATION = {
    INFO = 1,
    WARN = 2,
    ERROR = 3,
    SUCCESS = 4,
    FAIL = 5,

    [1] = "INFO",
    [2] = "WARN",
    [3] = "ERROR",
    [4] = "SUCCESS",
    [5] = "FAIL"
}

mvp.loader.LoadFile("core/sh_data.lua")
mvp.loader.LoadFile("core/sh_quick.lua") -- this file is loaded last, since it uses all other files

--[[ 

    Logger
    This loads core of the logger and then loads all loggers, since we need to have logging before anything else

]]--
mvp.loader.LoadFolder("core/logger")
mvp.loader.LoadFolder("loggers")

mvp.q.LogInfo("Terminal", "Loading Terminal...")

mvp.loader.LoadFile("core/sh_types.lua")
mvp.loader.LoadFile("core/sh_permissions.lua")


--[[ 

    Thirdparty
    This loads thirdparty libraries, we need to load them before anything else

]]--
mvp.loader.LoadFolder("thirdparty", true) -- true means load recursively

mvp.loader.LoadFolder("core/ui")
mvp.loader.LoadFile("core/cl_fonts.lua")

mvp.loader.LoadFolder("core/notification")

mvp.loader.LoadFile("core/sh_language.lua")
mvp.language.Init()

--[[ 

    Utilities
    This loads core of the utilities

]]--
mvp.loader.LoadFolder("core/util")

--[[ 

    Configurations
    This loads core of the configurations

]]--
mvp.loader.LoadFolder("core/config")
mvp.config.Init()

mvp.loader.LoadFolder("core/credits")
mvp.loader.LoadFolder("credits") -- there is no need to initialize credits, they are loaded automatically

mvp.loader.LoadFolder("core/command")
mvp.command.Init() 

--[[ 

    Packages
    This loads core of the packages

]]--
mvp.loader.LoadFolder("core/package") 
mvp.package.Init()

--[[
    Gamemodes support
]]-- 
mvp.loader.LoadFolder("core/gamemode")
mvp.gamemode.Init() 

mvp.loader.LoadFolder("vgui", true)
mvp.loader.LoadFolder("menus", true) -- files will load first, then folders, so we can load folder recursively

mvp.permissions.AddPermission("mvp.terminal", "superadmin", "Allows access to the Terminal menu", 1)
mvp.permissions.AddPermission("mvp.terminal.configs", "superadmin", "Allows to change Terminal configurations", 2)
mvp.permissions.AddPermission("mvp.terminal.packages", "superadmin", "Allows to control what packages are being loaded", 3)

mvp.q.LogInfo("Terminal", "Terminal loaded successfully!")
--PATH lua/mvp/core/sh_quick.lua:
return gluapack()()
--PATH lua/mvp/core/logger/sh_logger.lua:
return gluapack()()
--PATH lua/mvp/core/logger/sh_logger.meta.lua:
return gluapack()()
--PATH lua/mvp/languages/en.lua:
return gluapack()()
--PATH lua/mvp/configs/server.lua:
local SERVER_SECTION = mvp.config.RegisterSection("server", 1)

local SETTINGS_GROUP = mvp.config.RegisterCategory("gamemode", SERVER_SECTION, 1)

mvp.config.Add("gamemode", "blank", {
    description = "The gamemode you using on your server.",

    category = SETTINGS_GROUP, 

    ui = {
        type = "dropdown",
        choices = function()
            local gamemodes = mvp.gamemode.GetList()

            local choices = {}

            for k, v in pairs(gamemodes) do
                choices[v:GetID()] = v:GetName()
            end

            return choices
        end
    }
})

local BRANDING_GROUP = mvp.config.RegisterCategory("branding", SERVER_SECTION, 2)

mvp.config.Add("logo", "blank", {
    description = "The logo you want to use on your server. Should be a path to a image in you server's materials folder.",

    category = BRANDING_GROUP,
}, 1) 

mvp.config.Add("servername", "Example Server", {
    description = "The name of your server.",

    category = BRANDING_GROUP,
}, 2)
 
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/sh_package.lua:
local P = mvp.meta.package:New()

P:SetIcon(Material("mvp/perfecthands/package_icon.png", "smooth"))
P:SetName("Perfect Hands")
P:SetVersion("3.0.3")
P:SetDescription("Perfect hands, addon which adds perfect hands SWEP, as its name says!")
P:SetAuthor("Kot")

P:AddDependency("radialmenu")

P:AddConfigsFolder()
P:AddFolder("languages")
P:AddFolder("animations")
P:AddFile("sh_themes.lua")
P:AddFile("cl_credits.lua")

hook.Add("mvp.package.Registered", "mvp.phands.RegisterThemes", function(pckg)
    if (pckg ~= P) then
        return
    end

    mvp.q.LogInfo("Perfect Hands", "Registering themes")
    hook.Run("mvp.phands.RegisterThemes")
    mvp.q.LogInfo("Perfect Hands", "Themes registered")
end)

mvp.package.Register(P)
--PATH lua/mvp/packages/radialmenu/cl_radialmenu.meta.lua:
return gluapack()()
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/languages/ru.lua:
return gluapack()()
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/sh_themes.lua:
local P = mvp.package.Get()

P.themes = P.themes or {}
P.themes.list = P.themes.list or {}

function P.themes.GetAll()
    return P.themes.list
end

function P.themes.Get(name)
    return P.themes.list[name]
end

function P.themes.Register(id, data)
    P.themes.list[id] = data

    mvp.q.LogInfo("Perfect Hands", "Registered theme " .. id)
end
--PATH lua/mvp/packages/simpledefcons/languages/de.lua:
return gluapack()()
--PATH lua/mvp/packages/simpledefcons/manage/cl_manage.lua:
local P = mvp.package.Get()

P.manage = P.manage or {}
P.manage.notification = P.manage.notification or {}
P.activeDefcon = P.activeDefcon or 1

net.Receive("mvp.simpledefcons.Sync", function()
    P.activeDefcon = net.ReadUInt(8)
end)

local topRightGraphics = Material("mvp/simpledefcons/top_right.png", "smooth")
local topLeftGraphics = Material("mvp/simpledefcons/top_left.png", "smooth")

function P.manage.Notify(defcon, actor)
    if (IsValid(P.manage.notification)) then
        P.manage.notification:Remove()
    end

    local notificationPnl = vgui.Create("DPanel")
    notificationPnl:SetPos(0, 0)
    notificationPnl:SetSize(ScrW(), ScrH() * .5)

    notificationPnl.topGraphicsWidth = 0
    notificationPnl.defconOpacity = 0
    notificationPnl.descriptionOpacity = 0

    local defconAnimationDuration = 3

    local activeDefcon = mvp.config.Get("simpledefcons.defcons")[defcon or P.activeDefcon]
    local defconFont = mvp.q.Font(64, 800)
    local descriptionFont = mvp.q.Font(24, 600)

    local topGrapicsSizeX = mvp.ui.Scale(290) * 1.5
    local topGrapicsSizeY = mvp.ui.Scale(55) * 1.5
    local graphincsSeparation = mvp.ui.Scale(150)

    local defconText = activeDefcon.name
    local descriptionText = string.Split(mvp.utils.WrapText(activeDefcon.description, descriptionFont, ScrW() * .5), "\n")
    local defconColor = activeDefcon.color or mvp.colors.Accent

    function notificationPnl:Animate()
        self.topGraphicsWidth = 0
        self.defconOpacity = 0
        self.descriptionOpacity = 0

        self:Lerp("topGraphicsWidth", topGrapicsSizeX, defconAnimationDuration)

        timer.Simple(defconAnimationDuration * .3, function()
            if (not IsValid(self)) then return end

            if (activeDefcon.sound) then
                EmitSound(activeDefcon.sound, LocalPlayer():GetPos(), -2, CHAN_AUTO, 1, 100, 0, 100)
            end

            self:Lerp("defconOpacity", 1, 2, function()
                self:Lerp("descriptionOpacity", 1, 1)
            end)
        end)
    end

    function notificationPnl:AnimateOut()
        self:Lerp("descriptionOpacity", 0, 1, function()
            self:Lerp("defconOpacity", 0, 1, function()
                self:Lerp("topGraphicsWidth", 0, 1, function()
                    self:Remove()
                end)
            end)
        end)
    end

    function notificationPnl:Paint(w, h)
        local centerPoint = w * .5
        local startY = mvp.ui.Scale(90)

        local aplhaMult = math.Remap(self.topGraphicsWidth, 0, topGrapicsSizeX, 0, 1)
            
        local graphincsColor = Color(mvp.colors.Text.r, mvp.colors.Text.g, mvp.colors.Text.b, 255)
        local modulatedDefconColor = Color(defconColor.r * 1.1, defconColor.g * 1.1, defconColor.b * 1.1, 255)
    
        -- cycle color between white and defconColor
        local cycleTime = 5
        local cycle = math.sin(CurTime() * math.pi * 2 / cycleTime)
        graphincsColor.r = Lerp(cycle * .5 + .5, 255, modulatedDefconColor.r)
        graphincsColor.g = Lerp(cycle * .5 + .5, 255, modulatedDefconColor.g)
        graphincsColor.b = Lerp(cycle * .5 + .5, 255, modulatedDefconColor.b)
    
        do
            surface.SetAlphaMultiplier(aplhaMult)

            local tw = draw.SimpleText(mvp.q.Lang("simpledefcons.attention"), mvp.q.Font(48, 700), centerPoint, startY, graphincsColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            graphincsSeparation = math.max(graphincsSeparation, tw)

            surface.SetAlphaMultiplier(1)
        end

        do
            local actualDefconColor = ColorAlpha(defconColor, 255 * self.defconOpacity)
            local defconTextPosY = startY + topGrapicsSizeY - mvp.ui.Scale(15) * self.defconOpacity

            local tw, th = draw.SimpleText(defconText, defconFont, centerPoint, defconTextPosY, actualDefconColor, TEXT_ALIGN_CENTER)

            surface.SetDrawColor(actualDefconColor)
            surface.DrawRect(centerPoint - tw * .5, startY + topGrapicsSizeY - mvp.ui.Scale(20) + th, tw, mvp.ui.Scale(4))
        end

        local descriptionY = startY + topGrapicsSizeY + mvp.ui.Scale(80)
        for i, line in ipairs(descriptionText) do
            local opacity = 255 * (self.descriptionOpacity * #descriptionText) - (i - 1) * 255

            local _, th = draw.SimpleText(line, descriptionFont, centerPoint, descriptionY, Color(255, 255, 255, opacity), TEXT_ALIGN_CENTER, nil)
            descriptionY = descriptionY + th
        end

        surface.SetDrawColor(graphincsColor)

        render.SetScissorRect(centerPoint + graphincsSeparation - self.topGraphicsWidth + topGrapicsSizeX, startY, centerPoint + graphincsSeparation + topGrapicsSizeX, startY + topGrapicsSizeY, true)
        
        surface.SetMaterial(topRightGraphics)
        surface.DrawTexturedRect(centerPoint + graphincsSeparation, startY, topGrapicsSizeX, topGrapicsSizeY)

        render.SetScissorRect(0, 0, 0, 0, false)

        render.SetScissorRect(centerPoint - graphincsSeparation - topGrapicsSizeX, startY, centerPoint - graphincsSeparation - topGrapicsSizeX + self.topGraphicsWidth, startY + topGrapicsSizeY, true)

        surface.SetMaterial(topLeftGraphics)
        surface.DrawTexturedRect(centerPoint - graphincsSeparation - topGrapicsSizeX, startY, topGrapicsSizeX, topGrapicsSizeY)

        render.SetScissorRect(0, 0, 0, 0, false)
    end

    P.manage.notification = notificationPnl

    local fadeOutTime = defconAnimationDuration

    if (activeDefcon.sound and activeDefcon.sound ~= "") then
        fadeOutTime = fadeOutTime + SoundDuration(activeDefcon.sound)
    else
        fadeOutTime = fadeOutTime + mvp.config.Get("simpledefcons.timeOnScreen", 5)
    end

    timer.Simple(fadeOutTime, function()
        if (IsValid(notificationPnl)) then
            notificationPnl:AnimateOut()
        end
    end)

    notificationPnl:Animate()

    if (actor) then
        mvp.utils.ChatPrint(mvp.q.Lang("simpledefcons.initiated_by", mvp.utils.ColorToFormattedString(defconColor, true), defconText, mvp.utils.ColorToFormattedString(team.GetColor(actor:Team()), true), actor:Name()))
    end
end

net.Receive("mvp.simpledefcons.Set", function()
    local defcon = net.ReadUInt(8)
    P.activeDefcon = defcon

    local hasActor = net.ReadBool()
    
    if (hasActor) then
        local actor = net.ReadEntity()

        P.manage.Notify(defcon, actor)
    else
        P.manage.Notify(defcon)
    end
end)

function P.manage.Open()
    local canAccess = P.manage.CheckPermissions(LocalPlayer())

    if (not canAccess) then
        mvp.q.NotifyFail(mvp.q.Lang("simpledefcons.managerEntity"), mvp.q.Lang("general.no_permission"), nil)
        return
    end

    local spacing = mvp.ui.Scale(10)
    local defcons = mvp.config.Get("simpledefcons.defcons")
    local currentDefcon = defcons[P.activeDefcon]

    local currentDefconColor = currentDefcon.color or mvp.colors.Accent
    local mutedCurrentDefconColor = Color(currentDefconColor.r * .7, currentDefconColor.g * .7, currentDefconColor.b * .7)

    if (IsValid(P.manage.frame)) then
        P.manage.frame:Remove()
    end

    local frame = vgui.Create("mvp.Frame")
    frame:SetTitle(mvp.q.Lang("simpledefcons.managerEntity"))
    frame:SetSize(mvp.ui.Scale(600), ScrH() * .5)
    frame:Center()
    frame:SetupIcon(Material("mvp/simpledefcons/alert.png", "smooth"), nil, {
        startCol = currentDefconColor,
        endCol = mutedCurrentDefconColor
    })
    frame:MakePopup()

    P.manage.frame = frame

    local defconList = vgui.Create("mvp.ScrollPanel", frame)
    defconList:Dock(FILL)
    defconList:DockMargin(spacing, 0, spacing, spacing)

    for defconId, defconData in ipairs(defcons) do
        local pnl = vgui.Create("DPanel", defconList)
        pnl:Dock(TOP)
        pnl:DockMargin(0, 0, 0, spacing)
        pnl:InvalidateParent(true)
        pnl:SetTall(mvp.ui.Scale(64))

        function pnl:Paint(w, h)
            local color = defconData.color or mvp.colors.Accent
            
            draw.RoundedBox(mvp.ui.Scale(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 150))
            draw.SimpleText(defconData.name, mvp.q.Font(28, 700), spacing, h * .5, color, nil, TEXT_ALIGN_CENTER)
        end

        local setButton = vgui.Create("mvp.Button", pnl)
        setButton:Dock(RIGHT)
        setButton:DockMargin(spacing, spacing, spacing, spacing)
        setButton:SetWide(mvp.ui.Scale(100))
        setButton:SetRoundness(mvp.ui.ScaleWithFactor(8))
        setButton:SetStyle("secondary")
        
        setButton:SetEnabled(defconId ~= P.activeDefcon)
        setButton:SetText(defconId == P.activeDefcon and mvp.q.Lang("simpledefcons.active") or mvp.q.Lang("simpledefcons.set"))

        function setButton:DoClick()
            net.Start("mvp.simpledefcons.Set")
            net.WriteUInt(defconId, 8)
            net.SendToServer()

            frame:Remove()
        end
    end
end

net.Receive("mvp.simpledefcons.Open", function()
    P.manage.Open()
end)

concommand.Add("mvp_simpledefcons_open", function()
    P.manage.Open()
end)
--PATH lua/mvp/packages/simpledefcons/cl_hud.lua:
return gluapack()()
--PATH lua/mvp/packages/simpledefcons/configs/simpledefcons.lua:
return gluapack()()
--PATH lua/mvp/core/gamemode/sh_gamemode.meta.lua:
mvp = mvp or {}
mvp.meta.gamemode = mvp.meta.gamemode or {}

mvp.meta.gamemode.__proto = mvp.meta.gamemode

function mvp.meta.gamemode:New()
    local o = table.Copy(mvp.meta.gamemode.__proto)

    setmetatable(o, mvp.meta.gamemode)
    o.__index = self

    local cwd = debug.getinfo(2, "S").short_src
    local gamemodeFile = string.match(cwd, "mvp/gamemodes/([^/]+)%.lua")

    o:SetID(gamemodeFile)

    return o
end

AccessorFunc(mvp.meta.gamemode, "_id", "ID", FORCE_STRING)

mvp.meta.gamemode.__proto._name = "Unnamed gamemode"
AccessorFunc(mvp.meta.gamemode, "_name", "Name", FORCE_STRING)

mvp.meta.gamemode.__proto._description = "No description"
AccessorFunc(mvp.meta.gamemode, "_description", "Description", FORCE_STRING)

mvp.meta.gamemode.__proto._author = "Unknown"
AccessorFunc(mvp.meta.gamemode, "_author", "Author", FORCE_STRING)

mvp.meta.gamemode.__proto._version = "0.0.0"
AccessorFunc(mvp.meta.gamemode, "_version", "Version", FORCE_STRING)

mvp.meta.gamemode.__proto._license = "Unknown"
AccessorFunc(mvp.meta.gamemode, "_license", "License", FORCE_STRING)

--[[
    Economy functions
]]--
function mvp.meta.gamemode:GetMoney(player)
    error("Not implemented")
end
function mvp.meta.gamemode:CanAfford(player, sum)
    error("Not implemented")
end
function mvp.meta.gamemode:AddMoney(player, sum)
    error("Not implemented")
end
function mvp.meta.gamemode:TakeMoney(player, sum)
    error("Not implemented")
end
function mvp.meta.gamemode:FormatMoney(player, sum)
    error("Not implemented")
end
--PATH lua/mvp/gamemodes/darkrp.lua:
return gluapack()()
--PATH lua/mvp/gamemodes/helix.lua:
return gluapack()()
--PATH lua/mvp/vgui/cl_scrollpanel.lua:
local PANEL = {}

function PANEL:Init()
    local vbar = self:GetVBar()
    vbar:SetHideButtons(true)
    vbar:SetWide(mvp.ui.Scale(15))
    
    vbar.Paint = function(pnl, w, h)
        draw.RoundedBox(mvp.ui.ScaleWithFactor(h * .5), 0, 0, w, h, mvp.colors.SecondaryBackground)
    end

    vbar.btnGrip.backgroundColor = mvp.colors.Background

    vbar.btnGrip.colors = {
        Background = mvp.colors.Background,
        BackgroundHover = mvp.colors.SecondaryAccent,
    }

    vbar.btnGrip.OnCursorEntered = function(pnl)
        pnl:LerpColor("backgroundColor", pnl.colors.BackgroundHover, 0.2)
    end

    vbar.btnGrip.OnCursorExited = function(pnl)
        pnl:LerpColor("backgroundColor", pnl.colors.Background, 0.2)
    end

    vbar.btnGrip.Paint = function(pnl, w, h)
        draw.RoundedBox(mvp.ui.ScaleWithFactor(h * .5), 2, 2, w - 4, h - 4, pnl.backgroundColor)
    end

end

function PANEL:PerformLayoutInternal()
    local tall = self.pnlCanvas:GetTall()
    local wide = self:GetWide()

    local y = 0

    self:Rebuild()

    self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
    y = self.VBar:GetOffset()

    if ( self.VBar.Enabled ) then wide = wide - mvp.ui.Scale(3) - self.VBar:GetWide() end

    self.pnlCanvas:SetPos( 0, y )
    self.pnlCanvas:SetWide( wide )

    self:Rebuild()

    if ( tall != self.pnlCanvas:GetTall() ) then
        self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
    end
end

vgui.Register("mvp.ScrollPanel", PANEL, "DScrollPanel")
--PATH lua/mvp/vgui/button/cl_button_group.lua:
return gluapack()()
--PATH lua/mvp/vgui/dropdown/cl_dropdown.lua:
local PANEL = {}

DEFINE_BASECLASS("DMenu")

AccessorFunc(PANEL, "roundness", "Roundness")

function PANEL:Init()
    BaseClass.Init(self)

    self:SetPadding(0)
    self:SetAlpha(0)
    self:AlphaTo(255, 0.1, 0)

    self:SetRoundness(mvp.ui.Scale(16))

    self.colors = {
        Background = mvp.colors.Background
    }

    self.backgroundColor = self.colors.Background
end

function PANEL:PerformLayout( w, h )

	local w = self:GetMinimumWidth()

	for k, pnl in pairs( self:GetCanvas():GetChildren() ) do
		pnl:InvalidateLayout( true )
		w = math.max( w, pnl:GetWide() )
	end

	self:SetWide( w )

	local y = self:GetPadding()

	for k, pnl in pairs( self:GetCanvas():GetChildren() ) do
		pnl:SetWide( w )
		pnl:SetPos( 0, y )

		y = y + pnl:GetTall()
	end

	y = math.min( y, self:GetMaxHeight() )

	self:SetTall( y + self:GetPadding() )

	DScrollPanel.PerformLayout( self, w, h )
end

function PANEL:AddOption(name, func)
    local option = vgui.Create("mvp.DropdownMenuOption", self)
    option:SetMenu(self)
    option:SetText(name)
    option:SetFont(mvp.Font(18, 500))
    option:SetTall(mvp.ui.Scale(40))
    option:SetRoundness(self.roundness)

    option.colors.Background = Color(0, 0, 0, 0)
    option.backgroundColor = option.colors.Background

    if (func and isfunction(func)) then
        option.DoClick = func
    end

    self:AddPanel(option)

    return option
end

function PANEL:AddSpacer()
    local spacer = vgui.Create("DPanel", self)
    spacer:SetTall(1)
    spacer.Paint = function(pnl, w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 100))
    end

    self:AddPanel(spacer)
end

function PANEL:Paint(w, h)
    draw.RoundedBox(self.roundness, 0, 0, w, h, self.backgroundColor)
end

vgui.Register("mvp.DropdownMenu", PANEL, "DMenu")
--PATH lua/mvp/vgui/sidebar/cl_sidebar.lua:
return gluapack()()
--PATH lua/mvp/menus/cl_admin.lua:
mvp = mvp or {}
mvp.menus = mvp.menus or {}

mvp.menus.admin = mvp.menus.admin or {}
mvp.menus.admin.frame = nil

function mvp.menus.admin.Open(defaultTab, ...)
    if (IsValid(mvp.menu)) then
        mvp.menu:Remove()
    end

    local extra = {...}
    local frame = vgui.Create("mvp.Menu")
    mvp.menu = frame
    mvp.menus.admin.frame = frame

    frame:SetSize(ScrW() * 0.8, ScrH() * 0.8)
    frame:Center()
    frame:MakePopup()

    local buttons = {}
    buttons["home"] = frame:AddButton(mvp.q.Lang("ui.home"), "mvp/terminal/icons/dashboard.png", function()
        local canvas = frame:GetCanvas()

        mvp.menus.admin.Home(canvas)
    end)

    if (mvp.permissions.CheckSome(LocalPlayer(), {"mvp.terminal.configs", "mvp.terminal.packages"})) then
        frame:AddSeparator()
    end

    if (mvp.permissions.Check(LocalPlayer(), "mvp.terminal.configs")) then
        buttons["settings"] = frame:AddButton(mvp.q.Lang("ui.config"), "mvp/terminal/icons/settings.png", function(_, section)
            local canvas = frame:GetCanvas()

            if (not section) then
                section = extra[1] or nil
                extra = {}
            end

            
            mvp.menus.admin.Settings(canvas, section)
        end)

        buttons["permissions"] = frame:AddButton(mvp.q.Lang("ui.permissions"), "mvp/terminal/icons/permissions.png", function()
            local canvas = frame:GetCanvas()

            mvp.menus.admin.Permissions(canvas)
        end)
    end

    if (mvp.permissions.Check(LocalPlayer(), "mvp.terminal.packages")) then
        buttons["packages"] = frame:AddButton(mvp.q.Lang("ui.packages"), "mvp/terminal/icons/package.png", function()
            local canvas = frame:GetCanvas()

            mvp.menus.admin.Packages(canvas)
        end)
    end

    frame:AddSeparator()

    buttons["credits"] = frame:AddButton(mvp.q.Lang("ui.credits"), "mvp/terminal/icons/credits.png", function(_, section)
        local canvas = frame:GetCanvas()

        if (not section) then
            section = extra[1] or nil
            extra = {}
        end

        mvp.menus.admin.Credits(canvas)
    end)

    if (not buttons[defaultTab]) then
        defaultTab = "home"
    end
    buttons[defaultTab]:DoClick()
end

hook.Add("mvp.config.Synchronized", "CreateDefaultWarnings", function()
    local nameValue = mvp.config.GetStored("servername")
    local logoValue = mvp.config.GetStored("logo")
    local gamemodeValue = mvp.config.GetStored("gamemode")

    if (nameValue.value == nameValue.default and not mvp.menus.admin.HasNotification("servername")) then
        mvp.menus.admin.AddNotification(
            "servername",
            mvp.q.Lang("ui.notifications.servername.title"), 
            mvp.q.Lang("ui.notifications.servername.description", nameValue.default), 
            mvp.colors.Red,
            {
                {
                    text = mvp.q.Lang("ui.notifications.servername.action.1"),
                    callback = function()
                        mvp.menus.admin.Open("settings", "server")
                    end
                }
            })

        mvp.logger.Log(mvp.LOG.DEBUG, nil, "Adding notification for server name not set")
    end

    if (logoValue.value == logoValue.default and not mvp.menus.admin.HasNotification("logo")) then
        mvp.menus.admin.AddNotification(
            "logo",
            mvp.q.Lang("ui.notifications.logo.title"), 
            mvp.q.Lang("ui.notifications.logo.description", logoValue.default),
            mvp.colors.Red,
            {
                {
                    text = mvp.q.Lang("ui.notifications.logo.action.1"),
                    callback = function()
                        mvp.menus.admin.Open("settings", "server")
                    end
                }
            })
        
        mvp.logger.Log(mvp.LOG.DEBUG, nil, "Adding notification for server logo not set")
    end

    if (gamemodeValue.value == gamemodeValue.default and not mvp.menus.admin.HasNotification("gamemode")) then
        mvp.menus.admin.AddNotification(
            "gamemode",
            mvp.q.Lang("ui.notifications.gamemode.title"), 
            mvp.q.Lang("ui.notifications.gamemode.description", gamemodeValue.default),
            mvp.colors.Yellow,
            {
                {
                    text = mvp.q.Lang("ui.notifications.gamemode.action.1"),
                    callback = function()
                        mvp.menus.admin.Open("settings", "server")
                    end
                }
            })

        mvp.logger.Log(mvp.LOG.DEBUG, nil, "Adding notification for gamemode not set")
    end
end)

local checkKeys = {
    ["servername"] = true,
    ["logo"] = true,
    ["gamemode"] = true
}
hook.Add("mvp.config.Updated", "ManageDefaultWarnings", function(key, value)
    if (not checkKeys[key]) then return end

    local storedValue = mvp.config.GetStored(key)

    if (value ~= storedValue.default) then
        mvp.menus.admin.RemoveNotification(key)
    end
end)

concommand.Add("mvp_terminal", function()
    if (mvp.permissions.Check(LocalPlayer(), "mvp.terminal")) then
        mvp.menus.admin.Open()
    else
        chat.AddText(mvp.colors.Red, mvp.q.Lang("general.no_permission"))
    end
end)
--PATH lua/mvp/menus/admin/cl_permissions.lua:
return gluapack()()
--PATH lua/ncs_shared/cl_overhead.lua:
local SOVERHEADS = {}
local OVERHEADS = {}

function NCS_SHARED.EditOverhead(ent, line, newval)
    if !OVERHEADS[ent] then return end

    local KEY = OVERHEADS[ent]
    local TAB = SOVERHEADS[KEY]

    if !TAB or !TAB.Lines or !TAB.Lines[line] then return end

    -- Improve Later
    local w, h = 0, 0

    for k, v in ipairs(TAB.Lines) do
        if !v.Font then table.remove(TAB.Lines, k) continue end
        if !v.Text then table.remove(TAB.Lines, k) continue end

        surface.SetFont( v.Font )

        local nw, nh = surface.GetTextSize( v.Text )

        h = (h + nh)

        if nw > w then
            w = nw
        end
    end

    TAB.w, TAB.h = (w + 20), (h + 5)
    --

    TAB.Lines[line] = newval
end

function NCS_SHARED.AddOverhead(ent, data)
    if !istable(data) or !data.Lines then return end
    if !data.Accent then data.Accent = Color(255,255,255) end
    if !data.Position then data.Position = true end

    if OVERHEADS[ent] then
        table.remove(SOVERHEADS, OVERHEADS[ent])
    end

    data.ENTITY = ent

    local w, h = 0, 0

    for k, v in ipairs(data.Lines) do
        if !v.Font then table.remove(data.Lines, k) continue end
        if !v.Text then table.remove(data.Lines, k) continue end

        surface.SetFont( v.Font )

        local nw, nh = surface.GetTextSize( v.Text )

        h = (h + nh)

        if nw > w then
            w = nw
        end
    end

    data.w, data.h = (w + 20), (h + 5)

    local KEY = table.insert(SOVERHEADS, data)

    OVERHEADS[ent] = KEY
end

local COL_1 = Color(0,0,0,180)
local COL_2 = Color(255,255,255)

hook.Add("PostDrawTranslucentRenderables", "NCS_SHARED_AddOverhead", function()
    for k, v in ipairs(SOVERHEADS) do
        local ENTITY = v.ENTITY

        if !IsValid(ENTITY) then table.remove(SOVERHEADS, k) continue end 

        if !v.Distance or !isnumber(v.Distance) then
            v.Distance = 20000
        end

        if ( ENTITY:GetPos():DistToSqr(LocalPlayer():GetPos()) > v.Distance ) then
            continue
        end
        
        local CENTER = ENTITY:OBBCenter()

        local w, h = (v.w or 0), (v.h or 0)

        local POS = v.Position

        if ( v.Position == true ) then
            local physBone = ENTITY:LookupBone("ValveBiped.Bip01_Head1") 
            local bone_pos
        
            if (physBone) then
                bone_pos = ENTITY:GetBonePosition(physBone) 
            end
        
            if (bone_pos) then
                POS = bone_pos + Vector(0, 0, 15) 
            else
                POS = ENTITY:LocalToWorld(Vector(CENTER.x, CENTER.y, ENTITY:OBBMaxs().z)) + Vector(0, 0, 10)
            end
        elseif isnumber(v.Position) then
            POS = ENTITY:GetPos() + Vector(0, 0, v.Position)
        end

        if !isvector(POS) then return end
        
        local ANG = Angle(0, Angle(0, (LocalPlayer():GetPos() - ENTITY:GetPos()):Angle().y + 90, 90).y, 90)

        cam.Start3D2D(POS, ANG, 0.1)
            draw.RoundedBox(0, -( w / 2 ), 0, w, h, COL_1)
            draw.RoundedBox(0, -( w / 2), h - (h / 12), w, (h / 12), v.Accent)

            for a, b in ipairs(v.Lines) do
                draw.SimpleText(b.Text, b.Font, 0, (a * 30) - 30, ( b.Color or COL_2 ), TEXT_ALIGN_CENTER)
            end
        cam.End3D2D()
    end
end )
--PATH lua/ncs_shared/characters/list/sh_helix.lua:
return gluapack()()
--PATH lua/ncs_shared/characters/list/sh_helix.lua:
NCS_SHARED.AddCharacterSystem("helix", {
    GetCharacterID = function(P)    
        return ( P:GetCharacter() and P:GetCharacter():GetID() )
    end,
    hooks = {
        ["CharacterDeleted"] = function(P, SLOT)
            hook.Run("NCS_SHARED_CharacterDeleted", P, SLOT)
        end,
        ["CharacterLoaded"] = function(CHAR)
            local P = CHAR:GetPlayer()

            if not IsValid(P) then return end
    
            hook.Run("NCS_SHARED_CharacterLoaded", P, CHAR:GetID())
        end,
        ["PrePlayerLoadedCharacter"] = function(P, NEW, OLD)
            if not OLD then return end
    
            if NEW ~= OLD then
                hook.Run("NCS_SHARED_CharacterChanged", P, NEW, OLD)
            end
        end,
    }
})
--PATH lua/ncs_shared/modules/configuration/default/sh_defaultoptions.lua:
hook.Add("NCS_SHARED_LanguageRegistered", "LanguageRegisteredCore", function()
    local T = {}

    for k, v in pairs(NCS_SHARED.GetLangs()) do
        table.insert(T, k)
    end 

    NCS_SHARED.CreateDataOption("Language", {
        dataCategory = "Library",
        saveData = true,
        multiSelect = false,
        selectData = T,
        dataType = TYPE_TABLE,
        defaultValue = "en",
        sortValue = 4,
    })
end )

--[[------------------------------------]]--
--  Currency System Options
--[[------------------------------------]]--

local T = {}

for k, v in pairs(NCS_SHARED.CURRENCIES) do
    table.insert(T, k)
end 

NCS_SHARED.CreateDataOption("Currency", {
    dataCategory = "Library",
    saveData = true,
    multiSelect = false,
    selectData = T,
    dataType = TYPE_TABLE,
    defaultValue = "darkrp",
    sortValue = 3,
})

--[[------------------------------------]]--
--  Character System Options
--[[------------------------------------]]--

NCS_SHARED.CreateDataOption("Character System Enabled", {
    dataCategory = "Library",
    saveData = true,
    dataType = TYPE_BOOL,
    defaultValue = false,
    sortValue = 2,
})

local T = {}

for k, v in pairs(NCS_SHARED.CharSystems) do
    table.insert(T, k)
end

NCS_SHARED.CreateDataOption("Character System", {
    dataCategory = "Library",
    saveData = true,
    multiSelect = false,
    selectData = T,
    dataType = TYPE_TABLE,
    defaultValue = "helix",
    sortValue = 1,
})

--[[------------------------------------]]--
--  Admin Groups
--[[------------------------------------]]--

NCS_SHARED.CreateDataOption("Admin Groups", {
    dataCategory = "Library",
    saveData = true,
    multiSelect = true,
    selectData = T,
    dataType = TYPE_TABLE,
    defaultValue = {
        ["superadmin"] = "World",
    },
    sortValue = 5,
    verifyData = function(TAB, DATA)
        if !DATA["superadmin"] then
            DATA["superadmin"] = "World"

            TAB:setInternalData(DATA)

            return false
        end
    end,
    customMenuFunction = function(TAB, S)
        local currentValues = table.Copy(TAB.currentValue) or {}
        local w, h = S:GetParent():GetSize()

        local TX_USERGROUP
        local TX_UGLIST
    
        local LABEL_TOP = S:Add("DLabel")
        LABEL_TOP:Dock(TOP)
        LABEL_TOP:SetTall(LABEL_TOP:GetTall() * 1.5)
        LABEL_TOP:SetText("")
        LABEL_TOP:SetMouseInputEnabled(true)
        LABEL_TOP:DockMargin(w * 0.025, h * 0.025, w * 0.025, h * 0.025)

        local ADD = LABEL_TOP:Add("DButton")
        ADD:SetImage("icon16/add.png")
        ADD:Dock(LEFT)
        ADD:SetText("")
        ADD:SetWide(ADD:GetWide() * 0.4)
        ADD.DoClick = function(s)
            if !istable(currentValues) then return end

            local UG = TX_USERGROUP:GetValue()
    
            if ( !UG or UG == "" ) then return end
    
            local LINE = TX_UGLIST:AddLine(UG, LocalPlayer():SteamID64())
            LINE.USERGROUP = UG

            currentValues[UG] = LocalPlayer():SteamID64()

            TX_USERGROUP:SetText("")
            
            TAB:setInternalData(currentValues)
        end
    
        TX_USERGROUP = vgui.Create("DTextEntry", LABEL_TOP)
        TX_USERGROUP:Dock(LEFT)
        TX_USERGROUP:SetKeyboardInputEnabled(true)
        TX_USERGROUP:SetPlaceholderText("Admin Groups")
        TX_USERGROUP:SetWide(TX_USERGROUP:GetWide() * 2)
    
        local LABEL = vgui.Create("DLabel", S)
        LABEL:SetText("")
        LABEL:SetHeight(h * 0.3)
        LABEL:Dock(TOP)
        LABEL:SetMouseInputEnabled(true)
        LABEL:DockMargin(w * 0.025, h * 0.025, w * 0.025, h * 0.025)
        LABEL:SetMouseInputEnabled(true)

        TX_UGLIST = vgui.Create("DListView", LABEL)
        TX_UGLIST:Dock(FILL)
        TX_UGLIST:AddColumn( "Admin Groups", 1 )
        TX_UGLIST:AddColumn( "Added By", 2 )

        TX_UGLIST.OnRowRightClick = function(sm, ID, LINE)
            local UG = LINE.USERGROUP
            
            if ( UG == "superadmin" ) then return end

            if currentValues[UG] then
                currentValues[UG] = nil
            end
    
            TX_UGLIST:RemoveLine(ID)

            TAB:setInternalData(currentValues)
        end
        TX_UGLIST.OnRowSelected = function(_, I, ROW)
            ROW:SetSelected(false)
        end

        if currentValues then
            for k, v in pairs(currentValues) do
                local LINE = TX_UGLIST:AddLine(k, v)
                LINE.USERGROUP = k
            end
        end
    end,
})
--PATH lua/ncs_shared/vgui/cl_collapsiblecategory.lua:
local PANEL = {}

function PANEL:Init()
    local CAT_LABEL = self:GetChildren()[1]

    CAT_LABEL:SetTextColor(Color(252,180,9,255))
    CAT_LABEL:SetContentAlignment(5)
    CAT_LABEL:SetFont("NCS_SHARED_FRAME_TITLE")
    CAT_LABEL:SetTall(CAT_LABEL:GetTall() * 1.5) 
    CAT_LABEL.Paint = function(s, w, h) 
        surface.SetDrawColor( Color(122,132,137, 180) )
        surface.DrawOutlinedRect( 0, 0, w, h )
    end
end

function PANEL:OnToggle(B)
    local CAT_LABEL = self:GetChildren()[1]

    if B then
        CAT_LABEL:SetTextColor(Color(252,180,9,255))
    else
        CAT_LABEL:SetTextColor(color_white)
    end
end

function PANEL:Paint(w, h)
    surface.SetDrawColor( Color(122,132,137, 180) )
    surface.DrawOutlinedRect( 0, 0, w, h )
end



vgui.Register("NCS_SHARED_CollapsibleCategory", PANEL, "DCollapsibleCategory")
--PATH lua/autorun/netstream.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/sh_init_framework.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/sh_init_framework.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_1.lua')
AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_2.lua')
AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_3.lua')
AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_4.lua')

onyx.IncludeFolder('onyx/framework/libs/thirdparty/')
onyx.IncludeFolder('onyx/framework/libs/')
onyx.IncludeFolder('onyx/framework/core/')

if (SERVER) then
    onyx.lang = {Get = function(phraseID)
        return phraseID
    end}
    onyx.lang.GetWFallback = onyx.lang.Get
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_1.lua:
return {[97] = 65,[98] = 66,[99] = 67,[100] = 68,[101] = 69,[102] = 70,[103] = 71,[104] = 72,[105] = 73,[106] = 74,[107] = 75,[108] = 76,[109] = 77,[110] = 78,[111] = 79,[112] = 80,[113] = 81,[114] = 82,[115] = 83,[116] = 84,[117] = 85,[118] = 86,[119] = 87,[120] = 88,[121] = 89,[122] = 90,[181] = 924,[224] = 192,[225] = 193,[226] = 194,[227] = 195,[228] = 196,[229] = 197,[230] = 198,[231] = 199,[232] = 200,[233] = 201,[234] = 202,[235] = 203,[236] = 204,[237] = 205,[238] = 206,[239] = 207,[240] = 208,[241] = 209,[242] = 210,[243] = 211,[244] = 212,[245] = 213,[246] = 214,[248] = 216,[249] = 217,[250] = 218,[251] = 219,[252] = 220,[253] = 221,[254] = 222,[255] = 376,[257] = 256,[259] = 258,[261] = 260,[263] = 262,[265] = 264,[267] = 266,[269] = 268,[271] = 270,[273] = 272,[275] = 274,[277] = 276,[279] = 278,[281] = 280,[283] = 282,[285] = 284,[287] = 286,[289] = 288,[291] = 290,[293] = 292,[295] = 294,[297] = 296,[299] = 298,[301] = 300,[303] = 302,[305] = 73,[307] = 306,[309] = 308,[311] = 310,[314] = 313,[316] = 315,[318] = 317,[320] = 319,[322] = 321,[324] = 323,[326] = 325,[328] = 327,[331] = 330,[333] = 332,[335] = 334,[337] = 336,[339] = 338,[341] = 340,[343] = 342,[345] = 344,[347] = 346,[349] = 348,[351] = 350,[353] = 352,[355] = 354,[357] = 356,[359] = 358,[361] = 360,[363] = 362,[365] = 364,[367] = 366,[369] = 368,[371] = 370,[373] = 372,[375] = 374,[378] = 377,[380] = 379,[382] = 381,[383] = 83,[384] = 579,[387] = 386,[389] = 388,[392] = 391,[396] = 395,[402] = 401,[405] = 502,[409] = 408,[410] = 573,[414] = 544,[417] = 416,[419] = 418,[421] = 420,[424] = 423,[429] = 428,[432] = 431,[436] = 435,[438] = 437,[441] = 440,[445] = 444,[447] = 503,[453] = 452,[454] = 452,[456] = 455,[457] = 455,[459] = 458,[460] = 458,[462] = 461,[464] = 463,[466] = 465,[468] = 467,[470] = 469,[472] = 471,[474] = 473,[476] = 475,[477] = 398,[479] = 478,[481] = 480,[483] = 482,[485] = 484,[487] = 486,[489] = 488,[491] = 490,[493] = 492,[495] = 494,[498] = 497,[499] = 497,[501] = 500,[505] = 504,[507] = 506,[509] = 508,[511] = 510,[513] = 512,[515] = 514,[517] = 516,[519] = 518,[521] = 520,[523] = 522,[525] = 524,[527] = 526,[529] = 528,[531] = 530,[533] = 532,[535] = 534,[537] = 536,[539] = 538,[541] = 540,[543] = 542,[547] = 546,[549] = 548,[551] = 550,[553] = 552,[555] = 554,[557] = 556,[559] = 558,[561] = 560,[563] = 562,[572] = 571,[578] = 577,[583] = 582,[585] = 584,[587] = 586,[589] = 588,[591] = 590,[595] = 385,[596] = 390,[598] = 393,[599] = 394,[601] = 399,[603] = 400,[608] = 403,[611] = 404,[616] = 407,[617] = 406,[619] = 11362,[623] = 412,[626] = 413,[629] = 415,[637] = 11364,[640] = 422,[643] = 425,[648] = 430,[649] = 580,[650] = 433,[651] = 434,[652] = 581,[658] = 439,[837] = 921,[891] = 1021,[892] = 1022,[893] = 1023,[940] = 902,}
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_3.lua:
return {[7689] = 7688,[7691] = 7690,[7693] = 7692,[7695] = 7694,[7697] = 7696,[7699] = 7698,[7701] = 7700,[7703] = 7702,[7705] = 7704,[7707] = 7706,[7709] = 7708,[7711] = 7710,[7713] = 7712,[7715] = 7714,[7717] = 7716,[7719] = 7718,[7721] = 7720,[7723] = 7722,[7725] = 7724,[7727] = 7726,[7729] = 7728,[7731] = 7730,[7733] = 7732,[7735] = 7734,[7737] = 7736,[7739] = 7738,[7741] = 7740,[7743] = 7742,[7745] = 7744,[7747] = 7746,[7749] = 7748,[7751] = 7750,[7753] = 7752,[7755] = 7754,[7757] = 7756,[7759] = 7758,[7761] = 7760,[7763] = 7762,[7765] = 7764,[7767] = 7766,[7769] = 7768,[7771] = 7770,[7773] = 7772,[7775] = 7774,[7777] = 7776,[7779] = 7778,[7781] = 7780,[7783] = 7782,[7785] = 7784,[7787] = 7786,[7789] = 7788,[7791] = 7790,[7793] = 7792,[7795] = 7794,[7797] = 7796,[7799] = 7798,[7801] = 7800,[7803] = 7802,[7805] = 7804,[7807] = 7806,[7809] = 7808,[7811] = 7810,[7813] = 7812,[7815] = 7814,[7817] = 7816,[7819] = 7818,[7821] = 7820,[7823] = 7822,[7825] = 7824,[7827] = 7826,[7829] = 7828,[7835] = 7776,[7841] = 7840,[7843] = 7842,[7845] = 7844,[7847] = 7846,[7849] = 7848,[7851] = 7850,[7853] = 7852,[7855] = 7854,[7857] = 7856,[7859] = 7858,[7861] = 7860,[7863] = 7862,[7865] = 7864,[7867] = 7866,[7869] = 7868,[7871] = 7870,[7873] = 7872,[7875] = 7874,[7877] = 7876,[7879] = 7878,[7881] = 7880,[7883] = 7882,[7885] = 7884,[7887] = 7886,[7889] = 7888,[7891] = 7890,[7893] = 7892,[7895] = 7894,[7897] = 7896,[7899] = 7898,[7901] = 7900,[7903] = 7902,[7905] = 7904,[7907] = 7906,[7909] = 7908,[7911] = 7910,[7913] = 7912,[7915] = 7914,[7917] = 7916,[7919] = 7918,[7921] = 7920,[7923] = 7922,[7925] = 7924,[7927] = 7926,[7929] = 7928,[7936] = 7944,[7937] = 7945,[7938] = 7946,[7939] = 7947,[7940] = 7948,[7941] = 7949,[7942] = 7950,[7943] = 7951,[7952] = 7960,[7953] = 7961,[7954] = 7962,[7955] = 7963,[7956] = 7964,[7957] = 7965,[7968] = 7976,[7969] = 7977,[7970] = 7978,[7971] = 7979,[7972] = 7980,[7973] = 7981,[7974] = 7982,[7975] = 7983,[7984] = 7992,[7985] = 7993,[7986] = 7994,[7987] = 7995,[7988] = 7996,[7989] = 7997,[7990] = 7998,[7991] = 7999,[8000] = 8008,[8001] = 8009,[8002] = 8010,[8003] = 8011,[8004] = 8012,[8005] = 8013,[8017] = 8025,[8019] = 8027,[8021] = 8029,[8023] = 8031,[8032] = 8040,[8033] = 8041,[8034] = 8042,[8035] = 8043,[8036] = 8044,[8037] = 8045,[8038] = 8046,[8039] = 8047,[8048] = 8122,[8049] = 8123,[8050] = 8136,[8051] = 8137,[8052] = 8138,[8053] = 8139,[8054] = 8154,[8055] = 8155,[8056] = 8184,[8057] = 8185,[8058] = 8170,[8059] = 8171,[8060] = 8186,[8061] = 8187,[8064] = 8072,[8065] = 8073,[8066] = 8074,[8067] = 8075,[8068] = 8076,[8069] = 8077,[8070] = 8078,[8071] = 8079,[8080] = 8088,[8081] = 8089,[8082] = 8090,[8083] = 8091,[8084] = 8092,[8085] = 8093,[8086] = 8094,[8087] = 8095,[8096] = 8104,[8097] = 8105,[8098] = 8106,[8099] = 8107,[8100] = 8108,[8101] = 8109,[8102] = 8110,[8103] = 8111,[8112] = 8120,[8113] = 8121,[8115] = 8124,[8126] = 921,[8131] = 8140,[8144] = 8152,[8145] = 8153,[8160] = 8168,[8161] = 8169,[8165] = 8172,[8179] = 8188,[8526] = 8498,[8560] = 8544,[8561] = 8545,[8562] = 8546,[8563] = 8547,[8564] = 8548,[8565] = 8549,[8566] = 8550,[8567] = 8551,[8568] = 8552,[8569] = 8553,[8570] = 8554,[8571] = 8555,[8572] = 8556,[8573] = 8557,[8574] = 8558,[8575] = 8559,[8580] = 8579,[9424] = 9398,[9425] = 9399,}
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/cl_lang.lua:
--[[

Author: tochonement
Email: tochonement@gmail.com

28.09.2021

--]]

onyx.lang = onyx.lang or {}
onyx.lang.phrases = onyx.lang.phrases or {}
onyx.lang.id = onyx.lang.id or 'default'

local lang = onyx.lang

function lang:AddPhrase(langID, phraseID, text)
    self.phrases[langID] = self.phrases[langID] or {}
    self.phrases[langID][phraseID] = text
end

function lang:AddPhrases(langID, phrasesTable)
    for phraseID, text in pairs(phrasesTable) do
        self:AddPhrase(langID, phraseID, text)
    end
end

do
    local gsub = string.gsub
    local tostring = tostring
    local pairs = pairs

    function lang:Get(phraseID, arguments, translateArguments)
        local basePhrases = self.phrases.english or {}
        local localPhrases = self.phrases[self.id] or {}
        local text

        -- Search in the local phrases table
        if localPhrases[phraseID] then
            text = localPhrases[phraseID]
            goto process
        end

        -- Search in the base phrases table
        if basePhrases[phraseID] then
            text = basePhrases[phraseID]
            goto process
        end

        ::process::

        -- Place the arguments into the found text
        if text and arguments then
            for key, value in pairs(arguments) do
                value = tostring(value)

                local argument = translateArguments and lang:Get(value) or value

                text = gsub(text, '{' .. key .. '}', argument, 1)
            end
        end

        return text or phraseID
    end

    function lang:GetWFallback(phraseID, fallback)
        local phrase = self:Get(phraseID)
        if (phrase == phraseID) then
            return (fallback or phrase)
        else
            return phrase
        end
    end
end

do
    local languageReference = {
        en = 'english',
        ru = 'russian',
        de = 'german',
        fr = 'french',
        it = 'italian',
        tr = 'turkish',
        da = 'danish',
        pl = 'polish',
        ['es-ES'] = 'spanish'
    }

    function lang:GetGameLanguage()
        local current = GetConVar('gmod_language'):GetString()
        return languageReference[current]
    end

    function lang:SetBestLanguage()
        local found = self:GetGameLanguage()
        if (found) then
            self.id = found
        else
            self.id = 'default'
        end
    end

    lang:SetBestLanguage()

    cvars.AddChangeCallback('gmod_language', function()
        lang:SetBestLanguage()
    end, 'onyx.lang')
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_addon.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/05/2023

--]]

local ADDON = {}
ADDON.__index = ADDON

function ADDON:RegisterOption(id, data)
    data.addon = self.id

    if (SERVER) then
        data.onSet = function(value)
            self.db:Queue([[REPLACE INTO `onyx_]] .. self.id .. [[_settings` VALUES(']] .. self.db:Escape(id) .. [[', ']] .. self.db:Escape(onyx.TypeToString(value)) .. [[');]])
        end
    end

    onyx.inconfig:Register(self.id .. '_' .. id, data)
end

function ADDON:GetOptionValue(id)
    return onyx.inconfig:Get(self.id .. '_' .. id)
end

if (SERVER) then
    function ADDON:SetupDatabase(mysqlEnabled, credentials)
        local moduleName = 'sqlite'
        local data = {}

        if (mysqlEnabled) then
            moduleName = 'mysqloo'
            data = {
                hostname = credentials.Hostname,
                username = credentials.Username,
                password = credentials.Password,
                database = credentials.Schema,
                port = credentials.Port,
            }
        end

        if (self.db and self.db:IsConnected()) then
            self.db:Log('Connection recycled.')
        else
            self.db = onyx.sql.Create(moduleName, self.id, data)
        end

        self:CreateSettingsTable()
        self:LoadSettings()

        hook.Run('onyx.' .. self.id .. '.DatabaseInit')
    end

    function ADDON:CreateSettingsTable()
        local id = self.id

        local q = self.db:Create('onyx_' .. id .. '_settings')
            q:Create('id', 'VARCHAR(64) NOT NULL')
            q:Create('value', 'VARCHAR(255) NOT NULL')
            q:PrimaryKey('id')
        q:Execute()
    end

    function ADDON:LoadSettings()
        local addonID = self.id
        onyx.WaitForGamemode('onyx.' .. addonID .. '.LoadSettings', function()
            local q = self.db:Select('onyx_' .. addonID .. '_settings')
                q:Callback(function(result)

                    self:Print('Loaded settings.')
                    if (result and #result > 0) then
                        for _, row in ipairs(result) do
                            local optionID = addonID .. '_' .. row.id
                            local value = onyx.StringToType(row.value)

                            onyx.inconfig.values[optionID] = value
                        end
                    end

                end)
            q:Execute()
        end)
    end
end

do
    local accent = Color(174, 0, 255)
    local accent2 = Color(38, 185, 160)
    local white = color_white
    local red = Color(255, 73, 73)
    local green = Color(121, 255, 68)
    local orange = Color(255, 180, 68)

    local function format(text, ...)
        for _, arg in ipairs({...}) do
            if isentity(arg) and arg:IsPlayer() then
                arg = arg:Name() .. ' (' .. arg:SteamID() .. ')'
            else
                arg = tostring(arg)
            end

            text = string.gsub(text, '#', arg, 1)
        end

        return text
    end

    local function printWPrefix(id, color, prefix, text, ...)
        MsgC(
            white, '(', accent, 'ONYX', white, ') ',
            white, '(', accent2, id, white, ') ',
            white, '(', color, prefix, white, ') ',
            format(text, ...),
            '\n'
        )
    end

    function ADDON:Print(text, ...)
        local id = string.upper(self.id)
        MsgC(
            white, '(', accent, 'ONYX', white, ') ',
            white, '(', accent2, id, white, ') ',
            format(text, ...),
            '\n'
        )
    end

    function ADDON:PrintError(text, ...)
        local id = string.upper(self.id)
        printWPrefix(id, red, 'ERROR', text, ...)
    end

    function ADDON:PrintWarning(text, ...)
        local id = string.upper(self.id)
        printWPrefix(id, orange, 'WARNING', text, ...)
    end

    function ADDON:PrintSuccess(text, ...)
        local id = string.upper(self.id)
        printWPrefix(id, green, 'SUCCESS', text, ...)
    end

    function ADDON:PrintDebug(...)
        onyx:PrintDebug(...)
    end
end

--[[------------------------------
Public function
--------------------------------]]

function onyx:Addon(id, data)
    assert(isstring(id), Format('bad argument #1 (expected string, got %s)', type(id)))
    assert(istable(data), Format('bad argument #2 (expected table, got %s)', type(data)))

    if (self[id] == nil) then
        data.id = id

        self[id] = setmetatable(data, ADDON)
        self[id]:Print('Initialized.')
    else
        self[id]:Print('Refreshing.')
    end

    return self[id]
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_netvar.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/05/2023

--]]

--[[------------------------------
Requires `sh_net_extension.lua`, though doesn't need to be loaded before that
--------------------------------]]

if (SERVER) then
    util.AddNetworkString('onyx.netvar:Sync')
    util.AddNetworkString('onyx.netvar:Clear')
    util.AddNetworkString('onyx.netvar:DeleteEntity')
end

onyx.netvar = onyx.netvar or {}
onyx.netvar.list = onyx.netvar.list or {}
onyx.netvar.data = onyx.netvar.data or {}
onyx.netvar.public = onyx.netvar.public or {}

local netvar = onyx.netvar
local types = {
    [TYPE_BOOL] = {write = net.WriteBool, read = net.ReadBool},
    [TYPE_NUMBER] = {
        write = function(value, bits, unsigned)
            if (unsigned) then
                net.WriteUInt(value, bits)
            else
                net.WriteInt(value, bits)
            end
        end,
        read = function(bits, unsigned)
            if (unsigned) then
                return net.ReadUInt(bits)
            else
                return net.ReadInt(bits)
            end
        end
    },
    [TYPE_STRING] = {
        write = net.WriteString,
        read = net.ReadString,
    }
}

local function syncNetVar(entIndex, data, id, value, receiver)
    local write = types[data.type].write

    net.Start('onyx.netvar:Sync')

    net.WriteUInt(entIndex, 16)
    net.WriteString(id)
    write(value, data.bits, data.unsigned)

    -- could be invalid player
    if (receiver == nil) then
        net.Broadcast()
    else
        -- 100% is a player
        net.Send(receiver)
    end
end

function netvar:Register(id, data)
    data.id = id
    self.list[id] = data

    if (data.public) then
        self.public[id] = value
    end
end

do
    local ENTITY = FindMetaTable('Entity')

    function ENTITY:onyx_SetNetVar(id, value)
        if (CLIENT) then return end

        assert(isstring(id), Format('bad argument #1 to `onyx_SetNetVar` (expected string, got %s)', type(id)))
        assert(value ~= nil, 'bad argument #2 to `onyx_SetNetVar` (expected anything, got nil)')

        local data = netvar.list[id]

        assert(data, string.format('trying to set invalid netvar \'%s\' to %s', tostring(id), tostring(self)))

        local entIndex = self:EntIndex()

        netvar.data[entIndex] = netvar.data[entIndex] or {}
        netvar.data[entIndex][id] = value

        syncNetVar(entIndex, data, id, value, (not data.public and self or nil))
    end

    function ENTITY:onyx_ClearNetVar(id)
        if (CLIENT) then return end

        local entIndex = self:EntIndex()

        if (not netvar.data[entIndex]) then return end

        local data = netvar.list[id]

        netvar.data[entIndex][id] = nil

        net.Start('onyx.netvar:Clear')

        net.WriteUInt(entIndex, 16)
        net.WriteString(id)

        if (data.public) then
            net.Broadcast()
        else
            net.Send(self) -- must be a player
        end
    end

    function ENTITY:onyx_GetNetVar(id, fallback)
        local storage = netvar.data[self:EntIndex()]
        if (storage) then
            return (storage[id] or fallback)
        end
    end
end

if (CLIENT) then
    net.Receive('onyx.netvar:Sync', function(len)
        local entIndex = net.ReadUInt(16)

        local id = net.ReadString()
        local data = netvar.list[id]
        local read = types[data.type].read
        local value = read(data.bits, data.unsigned)

        netvar.data[entIndex] = netvar.data[entIndex] or {}
        netvar.data[entIndex][id] = value
    end)
else
    hook.Add('onyx.PlayerNetworkReady', 'onyx.netvar', function(ply)
        for entIndex, storage in pairs(netvar.data) do

            local isClient = (ply:EntIndex() == entIndex)

            for id, value in pairs(storage) do
                local data = netvar.list[id]
                if (data.public or isClient) then
                    syncNetVar(entIndex, data, id, value, ply)
                end
            end

        end
    end)
end

if (SERVER) then
    hook.Add('EntityRemoved', 'onyx.netvar', function(ent)
        -- lol it gets called by engine on clientside for all entities after data has been synced
        local entIndex = ent:EntIndex()

        netvar.data[entIndex] = nil

        net.Start('onyx.netvar:DeleteEntity')
            net.WriteUInt(entIndex, 16)
        net.Broadcast()
    end)
else
    net.Receive('onyx.netvar:DeleteEntity', function(len)
        local entIndex = net.ReadUInt(16)

        netvar.data[entIndex] = nil
    end)

    net.Receive('onyx.netvar:Clear', function(len)
        local entIndex = net.ReadUInt(16)
        local netvarID = net.ReadString()

        if (netvar.data[entIndex]) then
            netvar.data[entIndex][netvarID] = nil
        end
    end)
end


-- print(Entity(1):EntIndex())
-- PrintTable(netvar.data)
-- Entity(1):onyx_SetNetVar('store_loaded', true)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_gui.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

15/04/2022

--]]

onyx.gui = {}
onyx.gui.funcs = {}

local gui = onyx.gui

function gui.Register(name, metatable, parent)
    gui.Extend(metatable)
    vgui.Register(name, metatable, parent)
end

function gui.Extend(obj)
    for name, fn in pairs(onyx.gui.funcs) do
        obj[name] = fn
    end
end

function gui.RegisterFunc(name, fn)
    onyx.gui.funcs[name] = fn
end

-- Events

function gui.AddEvent(panel, name, fn)
    panel.onyxEvents = panel.onyxEvents or {}
    panel.onyxEvents[name] = panel.onyxEvents[name] or {
        count = 0
    }

    local storage = panel.onyxEvents[name]
    local index = storage.count + 1

    storage.count = index
    storage[index] = fn

    return index
end

function gui.RemoveEvent(panel, name, index)
    if (not panel.onyxEvents) then return false end

    local cache = panel.onyxEvents[name]
    if (not cache) then return false end

    local func = cache[index]
    if (not func) then return false end

    cache[index] = nil

    return true
end

function gui.CallEvent(panel, name, ignoreRaw, ...)
    local events = panel.onyxEvents or {}

    if not ignoreRaw and panel[name] then
        local val = panel[name](panel, ...)
        if val then
            return val
        end
    end

    local storage = events[name]
    if storage then
        for i = 1, storage.count do
            local fn = storage[i]
            if fn then
                local val = fn(panel, ...)
                if val then
                    return val
                end
            end
        end
    end
end

function gui.InjectEventHandler(panel, fnName)
    panel.onyxEventHandlers = panel.onyxEventHandlers or {}

    if panel.onyxEventHandlers[fnName] then
        return false
    end

    local oldFn = panel[fnName]

    panel[fnName] = function(self, a1, a2, a3, a4, a5, a6)
        if oldFn then
            oldFn(self, a1, a2, a3, a4, a5, a6)
        end

        -- call all events except the old function
        gui.CallEvent(self, fnName, true, a1, a2, a3, a4, a5, a6)
    end

    panel.onyxEventHandlers[fnName] = true

    return true
end

function gui.HasEventHandler(panel, fnName)
    if panel.onyxEventHandlers then
        return panel.onyxEventHandlers[fnName]
    end
end

function gui.Test(class, w, h, fn)
    if IsValid(gui.oldDebugPanel) then
        gui.oldDebugPanel:Remove()
    end

    local pnl = vgui.Create(class)
    if IsValid(pnl) then
        pnl:SetSize(ScrW() * w, ScrH() * h)
        pnl:Center()
        fn(pnl, pnl:GetWide(), pnl:GetTall())
    end
    gui.oldDebugPanel = pnl
end

gui.Register('onyx.Panel', {Init = function() end})
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/core/cl_panel_functions.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_polish.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_spanish.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/core/sh_core.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

function onyx.f4.GetPlayerLevel(ply, fallback)
    if (ply.getLevel) then
        return ply:getLevel()
    elseif (LevelSystemConfiguration) then
        return ply:getDarkRPVar('level')
    end
    return fallback
end

CAMI.RegisterPrivilege({
    Name = 'onyx_f4_edit',
    MinAccess = 'superadmin',
    Description = 'Allows to configure Onyx F4'
})

onyx.f4:RegisterOption('title', {
    title = 'f4.title.name',
    desc = 'f4.title.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = 'ONYX F4'
})

onyx.f4:RegisterOption('colored_items', {
    title = 'f4.colored_items.name',
    desc = 'f4.colored_items.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('edit_job_colors', {
    title = 'f4.edit_job_colors.name',
    desc = 'f4.edit_job_colors.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('hide_admins', {
    title = 'f4.hide_admins.name',
    desc = 'f4.hide_admins.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('hide_donate_tab', {
    title = 'f4.hide_donate_tab.name',
    desc = 'f4.hide_donate_tab.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('admin_on_duty', {
    title = 'f4.admin_on_duty.name',
    desc = 'f4.admin_on_duty.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('admin_on_duty_job', {
    title = 'f4.admin_on_duty_job.name',
    desc = 'f4.admin_on_duty_job.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = 'Admin on Duty'
})

onyx.f4:RegisterOption('item_columns', {
    title = 'f4.item_columns.name',
    desc = 'f4.item_columns.desc',
    category = 'Items',
    cami = 'onyx_f4_edit',
    type = 'int',
    min = 1,
    max = 3,
    default = 3
})

onyx.f4:RegisterOption('item_show_unavailable', {
    title = 'f4.item_show_unavailable.name',
    desc = 'f4.item_show_unavailable.desc',
    category = 'Items',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('job_columns', {
    title = 'f4.job_columns.name',
    desc = 'f4.job_columns.desc',
    category = 'Jobs',
    cami = 'onyx_f4_edit',
    type = 'int',
    min = 1,
    max = 3,
    default = 2
})

onyx.f4:RegisterOption('job_show_unavailable', {
    title = 'f4.job_show_unavailable.name',
    desc = 'f4.job_show_unavailable.desc',
    category = 'Jobs',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('job_show_requirejob', {
    title = 'f4.job_show_requirejob.name',
    desc = 'f4.job_show_requirejob.desc',
    category = 'Jobs',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('model_3d', {
    title = 'f4.model_3d.name',
    desc = 'f4.model_3d.desc',
    category = 'Performance',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

--[[------------------------------
URL
--------------------------------]]

onyx.f4:RegisterOption('website_ingame', {
    title = 'f4.website_ingame.name',
    desc = 'f4.website_ingame.desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('discord_url', {
    title = 'f4.discord_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('forum_url', {
    title = 'f4.forum_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('steam_url', {
    title = 'f4.steam_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('rules_url', {
    title = 'f4.rules_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('donate_url', {
    title = 'f4.donate_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_admin_stats.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/sh_init.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/07/2024

--]]

onyx:Addon( 'hud', {
    color = Color( 99, 65, 211 ),
    author = 'tochnonement',
    version = '1.0.14',
    licensee = '76561198196280105'
} )

----------------------------------------------------------------

onyx.Include( 'sv_sql.lua' )
onyx.IncludeFolder( 'onyx/modules/hud/languages/' )
onyx.IncludeFolder( 'onyx/modules/hud/core/', true )
onyx.IncludeFolder( 'onyx/modules/hud/cfg/', true )
onyx.IncludeFolder( 'onyx/modules/hud/elements/' )
onyx.IncludeFolder( 'onyx/modules/hud/ui/' )

onyx.hud:Print( 'Finished loading.' )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_french.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/cfg/cl_themes.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/cfg/cl_themes.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

21/08/2024

--]]

--[[
    ***************
      WARNING
      This configuration is intended for advanced users familiar with Lua scripting. 
      Modifying this file without proper knowledge may result in unintended behavior or instability.
    ***************
]]

onyx.hud:CreateTheme( 'default', {
    colors = {
        primary = onyx:Config( 'colors.primary' ),
        secondary = onyx:Config( 'colors.secondary' ),
        tertiary = onyx:Config( 'colors.tertiary' ),
        accent = onyx:Config( 'colors.accent' ),
    }
} )

onyx.hud:CreateTheme( 'gray', {
    colors = {
        primary = Color( 172, 172, 172),
        secondary = Color( 197, 197, 197),
        tertiary = Color( 225, 225, 225),
        accent = Color( 101, 40, 206),
    }
} )

onyx.hud:CreateTheme( 'golden_dawn', {
    colors = {
        primary = Color( 195, 189, 154),
        secondary = Color( 224, 207, 143),
        tertiary = Color( 230, 205, 129),
        accent = Color( 44, 44, 255),
        textPrimary = Color( 40, 35, 19),
        textSecondary = Color( 59, 50, 14),
        textTertiary = Color( 90, 83, 53),
    }
} )

onyx.hud:CreateTheme( 'sky_blue', {
    colors = {
        primary = Color(186, 227, 252),
        secondary = Color(210, 235, 255),
        tertiary = Color(232, 243, 255),
        accent = Color(0, 89, 255),
        textPrimary = Color(25, 45, 60),
        textSecondary = Color(50, 75, 100),
        textTertiary = Color(80, 110, 140),
    }
} )

onyx.hud:CreateTheme( 'mint_light', {
    colors = {
        primary = Color(202, 230, 217),
        secondary = Color(223, 241, 232),
        tertiary = Color(240, 250, 244),
        accent = Color(0, 162, 78),
        textPrimary = Color(34, 52, 42),
        textSecondary = Color(57, 82, 69),
        textTertiary = Color(92, 118, 104),
    }
} )

onyx.hud:CreateTheme( 'lavender', {
    colors = {
        primary = Color(230, 230, 250),
        secondary = Color(245, 245, 255),
        tertiary = Color(255, 250, 255),
        accent = Color(138, 43, 226),
        textPrimary = Color(50, 50, 80),
        textSecondary = Color(70, 70, 100),
        textTertiary = Color(100, 100, 130),
    }
} )

onyx.hud:CreateTheme( 'green_apple', {
    colors = {
        primary = Color(144, 238, 144),
        secondary = Color(168, 255, 168),
        tertiary = Color(192, 255, 192),
        accent = Color(218, 24, 24),  -- Насыщенный зеленый
        textPrimary = Color(40, 70, 40),
        textSecondary = Color(60, 90, 60),
        textTertiary = Color(90, 120, 90),
    }
} )

onyx.hud:CreateTheme( 'elegance', {
    colors = {
        primary = Color(34, 40, 48),
        secondary = Color(32, 36, 42),
        tertiary = Color(40, 45, 53),
        accent = Color(60, 179, 113),
    }
} )

onyx.hud:CreateTheme( 'ocean_wave', {
    colors = {
        primary = Color(24, 32, 44),
        secondary = Color(30, 40, 52),
        tertiary = Color(37, 50, 61),
        quaternary = Color(24, 32, 44),
        accent = Color(70, 130, 180),
    }
} )

onyx.hud:CreateTheme( 'violet_night', {
    colors = {
        primary = Color(48, 25, 52),
        secondary = Color(58, 31, 63),
        tertiary = Color(72, 40, 78),
        quaternary = Color(48, 25, 52),
        accent = Color(186, 85, 211),
    }
} )

onyx.hud:CreateTheme( 'forest', {
    colors = {
        primary = Color(34, 44, 34),
        secondary = Color(42, 54, 42),
        tertiary = Color(50, 64, 50),
        quaternary = Color(34, 44, 34),
        accent = Color(152, 251, 152),
    }
} )

onyx.hud:CreateTheme( 'rose_garden', {
    colors = {
        primary = Color(44, 24, 34),
        secondary = Color(52, 28, 42),
        tertiary = Color(61, 33, 50),
        quaternary = Color(44, 24, 34),
        accent = Color(255, 105, 180),
    }
} )

onyx.hud:CreateTheme( 'rustic_ember', {
    colors = {
        primary = Color(44, 29, 24),
        secondary = Color(52, 34, 29),
        tertiary = Color(61, 40, 34),
        quaternary = Color(44, 29, 24),
        accent = Color(255, 99, 71),
    }
} )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_ammo.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_english.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_polish.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_russian.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_turkish.lua:
--[[

Author: maellwoe
Email: maellwoe@hotmail.com

14/03/2024

--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Panoya kopyalandı'
LANG['scoreboard_search'] = 'Ara... (Name/SteamID)'
LANG['you'] = 'Sen'
LANG['friend'] = 'Arkadaş'
LANG['addon_return_u'] = 'GERI'

-- Columns
LANG['scoreboard_col_team'] = 'Takım'
LANG['scoreboard_col_job'] = 'Meslek'
LANG['scoreboard_col_money'] = 'Para'
LANG['scoreboard_col_rank'] = 'Yetki'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'OynamaSuresi'
LANG['scoreboard_col_health'] = 'Can'
LANG['scoreboard_col_level'] = 'Seviye'
LANG['scoreboard_col_none'] = 'Hicbiri'
LANG['scoreboard_col_gang'] = 'Gang'
LANG['scoreboard_col_ashop_badges'] = 'Rozetler'

-- Name Effects
LANG['scoreboard_eff_default'] = 'Varsayılan'
LANG['scoreboard_eff_glow'] = 'Parıltı'
LANG['scoreboard_eff_rainbow'] = 'Gökkuşağı'
LANG['scoreboard_eff_scanning_vertical'] = 'Taranıyor (Dikey)'
LANG['scoreboard_eff_scanning_horizontal'] = 'Taranıyor (Yatay)'
LANG['scoreboard_eff_gradient_invert'] = 'Gradyan (Rengi Ters Çevir)'
LANG['scoreboard_eff_wavy_dual'] = 'Dalgalı (Çift Renk)'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Profili aç'
LANG['scoreboard_btn_freeze'] = 'Dondur'
LANG['scoreboard_btn_goto'] = 'Git'
LANG['scoreboard_btn_bring'] = 'Getir'
LANG['scoreboard_btn_return'] = 'Geri Gonder'
LANG['scoreboard_btn_respawn'] = 'Yeniden Dogur'
LANG['scoreboard_btn_slay'] = 'Öldür'
LANG['scoreboard_btn_spectate'] = 'İzle'

-- Words
LANG['rank_id'] = 'Yetki Tanımlayıcı'
LANG['name'] = 'İsim'
LANG['effect'] = 'Effekt'
LANG['color'] = 'Renk'
LANG['preview'] = 'Ön izleme'
LANG['creation'] = 'Oluşturum'
LANG['save'] = 'Kayıt'
LANG['dead'] = 'Ölü'
LANG['create_new'] = 'Yeni Oluştur'
LANG['column'] = 'Kolon'

-- Settings
LANG['addon_settings_u'] = 'AYARLAR'
LANG['scoreboard_ranks_u'] = 'YETKILER'
LANG['scoreboard_columns_u'] = 'KOLONLAR'

LANG['scoreboard.title.name'] = 'Başlık'
LANG['scoreboard.title.desc'] = 'Çerçeve için bir başlık gir'

LANG['scoreboard.group_teams.name'] = 'Grup Takımları'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Grupları iş kategorilerine göre gruplandırın'

LANG['scoreboard.colored_players.name'] = 'Renklendirilmiş Gradyan'
LANG['scoreboard.colored_players.desc'] = 'Oyuncu satırında renklendirilmiş gradyanı göster'

LANG['scoreboard.blur.name'] = 'Blur Teması'
LANG['scoreboard.blur.desc'] = 'Blur temasını etkinleştir'

LANG['scoreboard.scale.name'] = 'Çerçeve Boyutu Ölçeği'
LANG['scoreboard.scale.desc'] = 'Skor tablosunun çerçeve boyutunu ölçeklendirin'

onyx.lang:AddPhrases('turkish', LANG)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/columns/cl_columns.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

net.Receive('onyx.scoreboard:SyncColumns', function()
    local amount = net.ReadUInt(8)

    onyx.scoreboard.columnsCustomizable = {}

    for _ = 1, amount do
        local index = net.ReadUInt(8)
        local id = net.ReadString()
        onyx.scoreboard.columnsCustomizable[index] = id
    end

    onyx.scoreboard:Print('Synchronized # columns.', amount)

    hook.Run('onyx.scoreboard.SyncedColumns')
end)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/ranks/cl_ranks.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_player_list.lua:
return gluapack()()
--PATH lua/openpermissions/cl.lua:
local L = OpenPermissions.L
local Lf = OpenPermissions.Lf

local function DMenuOption_ColorIcon(option, color)
	option:SetIcon("icon16/box.png")
	function option.m_Image:Paint(w,h)
		surface.SetDrawColor(color)
		surface.DrawRect(0,0,w,h)
	end
end
local function GreenToRed_DMenu(i, max, option)
	DMenuOption_ColorIcon(option, Color(i / max * 255, 1 - (i / max) * 255, 0))
end

surface.CreateFont("OpenPermissions_14px", {
	font = "Roboto",
	size = 14,
})
surface.CreateFont("OpenPermissions_Tip", {
	font = "Roboto",
	size = 22,
})

function OpenPermissions:AddTooltip(pnl, options)
	pnl.OpenPermissions_Tooltip_OnCursorEntered = pnl.OnCursorEntered
	pnl.OpenPermissions_Tooltip_OnCursorExited = pnl.OnCursorExited

	function pnl:OnCursorEntered(...)
		pnl.OpenPermissions_Tooltip = vgui.Create("OpenPermissions.Tooltip")
		pnl.OpenPermissions_Tooltip:SetText(options.Text)
		pnl.OpenPermissions_Tooltip.VGUI_Element = pnl

		if (self.OpenPermissions_Tooltip_OnCursorEntered) then
			return self.OpenPermissions_Tooltip_OnCursorEntered(self, ...)
		end
	end

	function pnl:OnCursorExited(...)
		if (IsValid(self.OpenPermissions_Tooltip)) then
			self.OpenPermissions_Tooltip:Remove()
		end
		self.OpenPermissions_Tooltip = nil
		if (self.OpenPermissions_Tooltip_OnCursorExited) then
			return self.OpenPermissions_Tooltip_OnCursorExited(self, ...)
		end
	end
end
function OpenPermissions:RemoveTooltip(pnl)
	if (IsValid(pnl.OpenPermissions_Tooltip)) then
		pnl.OpenPermissions_Tooltip:Remove()
	end
	pnl.OpenPermissions_Tooltip = nil
	pnl.OnCursorEntered = pnl.OpenPermissions_Tooltip_OnCursorEntered
	pnl.OnCursorExited = pnl.OpenPermissions_Tooltip_OnCursorExited
end

local blur = Material("pp/blurscreen")
function OpenPermissions:OpenMenu(specific_addon)
	if (IsValid(OpenPermissions_Menu)) then
		OpenPermissions_Menu:Close()
	end

	OpenPermissions_Menu = vgui.Create("DFrame")

	local AccessGroups
	local PermissionsSave

	local Menu = OpenPermissions_Menu
	Menu:SetSize(850,500)
	Menu:SetTitle("OpenPermissions")
	Menu:SetIcon("icon16/shield.png")
	Menu:Center()
	Menu:MakePopup()

	local Tabs = vgui.Create("DPropertySheet", Menu)
	Tabs:Dock(FILL)

	local PermissionsTab = vgui.Create("DPanel", Tabs)
	PermissionsTab.Paint = nil

		local AccessGroupsDivider = vgui.Create("OpenPermissions.HorizontalDivider", PermissionsTab)
		AccessGroupsDivider:Dock(FILL)
		AccessGroupsDivider:SetDividerWidth(5)
		AccessGroupsDivider:SetLeftWidth(200)
		AccessGroupsDivider:SetRightMin(465)
		AccessGroupsDivider:SetLeftMin(150)

		local AddonsContainer = vgui.Create("OpenPermissions.ColumnLayout", AccessGroupsDivider)
		AccessGroupsDivider:SetRight(AddonsContainer)
		AddonsContainer:SetColumns(OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW, OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW, OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW)
		AddonsContainer:SetPaddings(5,5)

		local AddonContentContainer = vgui.Create("DPanel", PermissionsTab)
		AddonContentContainer.Paint = nil
		AddonContentContainer:SetVisible(false)
		AddonContentContainer:Dock(FILL)
		AddonContentContainer:DockMargin(5,0,0,0)

			local AddonContent = vgui.Create("DPropertySheet", AddonContentContainer)
			AddonContent:Dock(FILL)
			function AddonContent:PaintOver(w,h)
				if (not self.ShowOverlay) then return end
				local x,y = self:LocalToScreen(0,0)
				local scrW,scrH = ScrW(), ScrH()
				surface.SetDrawColor(255,255,255)
				surface.SetMaterial(blur)
				for i=1,2 do
					blur:SetFloat("$blur", (i / 2) * 2)
					blur:Recompute()
					render.UpdateScreenEffectTexture()
					surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
				end

				surface.SetDrawColor(0,0,0,240)
				surface.DrawRect(0,0,w,h)

				draw.SimpleTextOutlined(L"select_an_access_group", "OpenPermissions_Tip", w / 2, h / 2, OpenPermissions.COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, OpenPermissions.COLOR_BLACK)
			end

			local PermissionsContent = vgui.Create("OpenPermissions.HorizontalDivider", AddonContent)
			PermissionsContent:SetDividerWidth(5)
			PermissionsContent:SetRightMin(150)
			PermissionsContent:SetLeftMin(150)
			PermissionsContent.Paint = nil

				local PermissionsTree = vgui.Create("OpenPermissions.Tree", PermissionsContent)

				local PropertiesContent = vgui.Create("OpenPermissions.ScrollPanel", PermissionsContent)
				PropertiesContent:DockMargin(5,0,0,0)
				PropertiesContent:SetWide(150)
				PropertiesContent:SetDrawBackground(true)
				function PropertiesContent:AddProperty(options, indent_level, no_checkbox)
					local permission_row = vgui.Create("DPanel", PropertiesContent)
					permission_row.Paint = nil
					permission_row:Dock(TOP)
					permission_row:SetTall(16)
					permission_row:DockMargin(5 + ((indent_level or 0) * (16 + 5)),5,5,0)

					OpenPermissions:AddTooltip(permission_row, {Text = options.Tip or options.Label})

					local checkbox
					if (not no_checkbox) then
						permission_row:SetMouseInputEnabled(true)
						permission_row:SetCursor("hand")

						checkbox = vgui.Create("OpenPermissions.Checkbox", permission_row)
						checkbox:SetCrossable(true)
						checkbox:Dock(LEFT)
						checkbox:DockMargin(0,0,5,0)

						function permission_row:OnMouseReleased(m)
							if (m == MOUSE_LEFT) then
								checkbox:DoClick()
							elseif (m == MOUSE_RIGHT) then
								checkbox:DoRightClick()
							end
						end
					end

					if (options.Icon) then
						local icon = vgui.Create("DImage", permission_row)
						icon:Dock(LEFT)
						icon:SetSize(16,16)
						icon:DockMargin(0,0,5,0)
						icon:SetImage(options.Icon)
						icon:SetMouseInputEnabled(false)
					elseif (options.Color) then
						local col_icon = vgui.Create("DPanel", permission_row)
						col_icon:Dock(LEFT)
						col_icon:SetSize(16,16)
						col_icon:DockMargin(0,0,5,0)
						col_icon:SetMouseInputEnabled(false)
						function col_icon:Paint(w,h)
							surface.SetDrawColor(options.Color)
							surface.DrawRect(0,0,w,h)
						end
					end

					local label = vgui.Create("DLabel", permission_row)
					label:Dock(FILL)
					label:SetTextColor(OpenPermissions.COLOR_BLACK)
					label:SetText(options.Label)
					label:SetContentAlignment(4)
					label:SetMouseInputEnabled(false)

					return checkbox
				end

				PermissionsContent:SetLeft(PermissionsTree)
				PermissionsContent:SetRight(PropertiesContent)
				PermissionsContent:BalanceWidths()

			AddonContent:AddSheet(L"permissions", PermissionsContent, "icon16/group.png")

			local OperationsContainer = vgui.Create("OpenPermissions.ScrollPanel", AddonContent)
			AddonContent:AddSheet(L"operations", OperationsContainer, "icon16/wrench_orange.png")

			function AddonContent:SetShowOverlay(show)
				self.ShowOverlay = show
				self:SetMouseInputEnabled(not show)
				for _,v in ipairs(self:GetItems()) do
					v.Panel:SetMouseInputEnabled(not show)
				end
			end
			AddonContent:SetShowOverlay(true)

				local DeleteAccessGroup = vgui.Create("DButton", OperationsContainer)
				DeleteAccessGroup:SetSize(250,30)
				DeleteAccessGroup:SetText(L"delete_access_group")
				DeleteAccessGroup:SetIcon("icon16/delete.png")

				local CopyPasteContainer = vgui.Create("DPanel", OperationsContainer)
				CopyPasteContainer.Paint = nil
				CopyPasteContainer:SetSize(250,30)
				CopyPasteContainer:AlignTop(DeleteAccessGroup:GetTall() + 5)

					local CopyPermissions = vgui.Create("DButton", CopyPasteContainer)
					CopyPermissions:SetText(L"copy")
					CopyPermissions:SetIcon("icon16/page_copy.png")
					CopyPermissions:DockMargin(0,0,5,0)

					local PastePermissions = vgui.Create("DButton", CopyPasteContainer)
					PastePermissions:SetText(L"paste")
					PastePermissions:SetIcon("icon16/page_paste.png")
					PastePermissions:DockMargin(0,0,5,0)
					PastePermissions:SetDisabled(true)

					function CopyPermissions:DoClick()
						PastePermissions:SetDisabled(false)
						PastePermissions.PermissionsData = {}
						local copied_clashes = false
						for _,line in ipairs(AccessGroups:GetSelected()) do
							local identifier = line.Data.Enum .. " " .. line.Data.Value
							if (not OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or not OpenPermissions.PermissionsRegistryEditing[line.Data.Value]) then continue end
							for access_group, perms in pairs(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum]) do
								for permission_id, checked in pairs(perms) do
									if (PastePermissions.PermissionsData[permission_id] == nil) then
										local has_clashed = false
										for _,line_2 in ipairs(AccessGroups:GetSelected()) do
											local identifier_2 = line_2.Data.Enum .. " " .. line_2.Data.Value
											if (not OpenPermissions.PermissionsRegistryEditing[line_2.Data.Enum] or not OpenPermissions.PermissionsRegistryEditing[line_2.Data.Value]) then continue end
											if (identifier_2 == identifier) then continue end
											if (OpenPermissions.PermissionsRegistryEditing[line_2.Data.Enum][line_2.Data.Value][permission_id] ~= checked) then
												copied_clashes, has_clashed = true, true
												break
											end
										end
										if (not has_clashed) then
											PastePermissions.PermissionsData[permission_id] = checked
										else
											PastePermissions.PermissionsData[permission_id] = nil
										end
									elseif (PastePermissions.PermissionsData[permission_id] ~= checked) then
										copied_clashes = true
										PastePermissions.PermissionsData[permission_id] = nil
									end
								end
							end
						end
						if (copied_clashes) then
							Derma_Message(L"permission_clash_msg", "OpenPermissions", L"ok")
						end
					end
					function PastePermissions:DoClick()
						for _,line in ipairs(AccessGroups:GetSelected()) do
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] or {}
							table.Merge(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value], PastePermissions.PermissionsData)
						end
					end

					function CopyPasteContainer:PerformLayout(w,h)
						CopyPermissions:SetSize((w - 2.5) / 2,h)
						CopyPermissions:AlignLeft(0)
						PastePermissions:SetSize((w - 2.5) / 2,h)
						PastePermissions:AlignRight(0)
					end

			local AddonNav = vgui.Create("DPanel", AddonContentContainer)
			AddonNav.Paint = nil
			AddonNav:Dock(BOTTOM)
			AddonNav:DockMargin(0,5,0,0)
			AddonNav:SetTall(30)

				PermissionsSave = vgui.Create("DButton", AddonNav)
				PermissionsSave:Dock(LEFT)
				PermissionsSave:SetWide(100)
				PermissionsSave:DockMargin(0,0,5,0)
				PermissionsSave:SetText(L"save")
				PermissionsSave:SetIcon("icon16/disk.png")
				PermissionsSave:SetDisabled(true)

				function PermissionsSave:RememberPermission(permission_id, checked)
					local is_disabled = true
					for _,line in ipairs(AccessGroups:GetSelected()) do
						if (checked == OpenPermissions.CHECKBOX.INHERIT or checked == false) then
							if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) then
								OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] = nil
								if (OpenPermissions:table_IsEmpty(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value])) then
									OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = nil
									if (OpenPermissions:table_IsEmpty(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum])) then
										OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = nil
									end
								end
							end
						else
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] = checked
						end
						if (is_disabled) then
							if ((OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) ~= (OpenPermissions.PermissionsRegistry[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value] ~= nil)) then
								is_disabled = false
							else
								if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] ~= OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value][permission_id]) then
									is_disabled = false
								elseif (not OpenPermissions:table_IsIdentical(OpenPermissions.PermissionsRegistryEditing, OpenPermissions.PermissionsRegistry)) then
									is_disabled = false
								end
							end
						end
					end
					self:SetDisabled(is_disabled)
				end
				function PermissionsSave:CheckedFromMemory(permission_id, checkbox)
					local checked
					for _,line in ipairs(AccessGroups:GetSelected()) do
						local should_be_checked = OpenPermissions.CHECKBOX.INHERIT
						if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] ~= nil) then
							should_be_checked = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id]
						elseif (OpenPermissions.DefaultPermissions[permission_id] ~= nil) then
							should_be_checked = OpenPermissions.DefaultPermissions[permission_id]
						end
						if (checked == nil) then
							checked = should_be_checked
						else
							if (should_be_checked ~= checked) then
								checkbox:SetAmbigious(true)
								return
							end
						end
					end
					checkbox:SetChecked(checked)
					checkbox:SetAmbigious(false)
				end
				function PermissionsSave:DoClick()
					OpenPermissions.PermissionsRegistry = table.Copy(OpenPermissions.PermissionsRegistryEditing)
					self:SetDisabled(true)
					surface.PlaySound("garrysmod/content_downloaded.wav")
					
					OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE)
					net.Start("OpenPermissions.SavePermissions")
						OpenPermissions:StartNetworkTable(OpenPermissions.PermissionsRegistry)
					net.SendToServer()
					file.Delete("openpermissions_v2.dat")
				end

				local AddonBack = vgui.Create("DButton", AddonNav)
				AddonBack:Dock(LEFT)
				AddonBack:SetWide(100)
				AddonBack:DockMargin(0,0,5,0)
				AddonBack:SetText(L"back_btn")
				function AddonBack:DoClick()
					AddonsContainer:SetVisible(true)
					AddonContentContainer:SetVisible(false)

					AccessGroupsDivider:SetRight(AddonsContainer)
				end

				local AddonSelect = vgui.Create("OpenPermissions.ComboBox", AddonNav)
				AddonSelect:Dock(FILL)
				AddonSelect.AddonBtns = {}

				AddonSelect:SetSortItems(false)
				AddonSelect:AddChoice(L"all_addons", true, false, "icon16/layers.png")
				AddonSelect:AddSpacer()

				function AddonSelect:OnSelect(i, v, d)
					PropertiesContent:Clear()
					if (d == true) then
						function AccessGroups:OnRowSelected(i, row)
							AddonContent:SetShowOverlay(false)
							PermissionsTree:Clear()
							PropertiesContent:Clear()
							for id, data in pairs(OpenPermissions.Addons) do
								PermissionsTab:LoadPermissions(id, data, true)
							end
						end
						if (AccessGroups:GetSelectedLine() ~= nil) then
							AccessGroups:OnRowSelected()
						end
					else
						self.AddonBtns[d]:DoClick()
					end
				end

		local NavContent = vgui.Create("DPanel", PermissionsTab)
		AccessGroupsDivider:SetLeft(NavContent)
		NavContent.Paint = nil
		NavContent:Dock(LEFT)
		NavContent:SetWide(200)

			AccessGroups = vgui.Create("OpenPermissions.ListView", NavContent)
			AccessGroups:AddColumn(L"type"):SetFixedWidth(65)
			AccessGroups:AddColumn(L"access_group")
			AccessGroups:Dock(FILL)
			AccessGroups.Data = {}

			local KeyCategory = vgui.Create("DCollapsibleCategory", NavContent)
			KeyCategory:Dock(TOP)
			KeyCategory:SetTall(130)
			KeyCategory:DockMargin(0,0,0,5)
			KeyCategory:SetLabel(L"key")
			KeyCategory:SetExpanded(false)

				local KeyInfo = vgui.Create("OpenPermissions.ScrollPanel", NavContent)
				KeyInfo:SetDrawBackground(true)

				for name, enum in pairs(OpenPermissions.ACCESS_GROUP) do
					local Key = vgui.Create("DPanel", KeyInfo)
					Key:Dock(TOP)
					Key:DockMargin(5,5,5,0)

					local KeyColor = OpenPermissions.ACCESS_GROUP_KEY[enum]
					local KeyName = L("ACCESS_GROUP_" .. name)
					local KeyPoly = {
						{x = 9, y = 0},
						{x = 18, y = 9},
						{x = 9, y = 18},
						{x = 0, y = 9},
					}
					function Key:Paint(w,h)
						surface.SetDrawColor(KeyColor)
						draw.NoTexture()
						surface.DrawPoly(KeyPoly)

						draw.SimpleText(KeyName, "DermaDefault", 18 + 5, 8, OpenPermissions.COLOR_BLACK, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
					end
				end

				KeyCategory:SetContents(KeyInfo)
			
			local MultipleTip = vgui.Create("DLabel", NavContent)
			MultipleTip:Dock(TOP)
			MultipleTip:SetContentAlignment(5)
			MultipleTip:DockMargin(0,0,0,5)
			MultipleTip:SetText(L"hold_ctrl_to_select_multiple")
			MultipleTip:SetTextColor(OpenPermissions.COLOR_BLACK)

			local AddAccessGroup = vgui.Create("DButton", NavContent)
			AddAccessGroup:SetText(L"add_access_group")
			AddAccessGroup:SetIcon("icon16/add.png")
			AddAccessGroup:Dock(BOTTOM)
			AddAccessGroup:DockMargin(0,5,0,0)
			AddAccessGroup:SetTall(30)

			function AddAccessGroup:Add(enum, text, value)
				local val = value or text
				if (AccessGroups.Data[enum] and AccessGroups.Data[enum][val]) then
					Derma_Message(L"access_group_exists", L"error", L"ok")
				else
					local type
					for name, _enum in pairs(OpenPermissions.ACCESS_GROUP) do
						if (_enum == enum) then
							type = name
							break
						end
					end
					local line = AccessGroups:AddLine(L("ACCESS_GROUP_" .. type), text)
					line.Data = {
						Enum = enum,
						Value = val
					}
					function line:Paint(w,h)
						derma.SkinHook("Paint", "ListViewLine", self, w, h)

						surface.SetDrawColor(OpenPermissions.ACCESS_GROUP_KEY[enum])
						surface.DrawRect(0,0,w,h)
					end
					AccessGroups.Data[enum] = AccessGroups.Data[enum] or {}
					AccessGroups.Data[enum][val] = true
				end
			end
			for enum, accessors in pairs(OpenPermissions.PermissionsRegistry) do
				for val, vals in pairs(accessors) do
					enum = tonumber(enum)
					if (enum == OpenPermissions.ACCESS_GROUP.STEAMID) then
						AddAccessGroup:Add(enum, OpenPermissions:AccountIDToSteamID(tonumber(val)), tonumber(val))
					elseif (enum == OpenPermissions.ACCESS_GROUP.TEAM) then
						local team_index = OpenPermissions:GetTeamFromIdentifier(val)
						if (team_index) then
							AddAccessGroup:Add(enum, team.GetName(team_index), val)
						end
					elseif (enum == OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY) then
						if (OpenPermissions.IsDarkRP) then
							local category_index = OpenPermissions:DarkRP_GetCategoryFromIdentifier(val)
							if (category_index) then
								AddAccessGroup:Add(enum, DarkRP.getCategories().jobs[category_index].name, val)
							end
						end
					else
						AddAccessGroup:Add(enum, val)
					end
				end
			end

			function AddAccessGroup:DoClick()
				local menu = DermaMenu()
				
				local ACCESS_GROUP_USERGROUP, _ = menu:AddSubMenu(L"ACCESS_GROUP_USERGROUP") _:SetIcon("icon16/group.png")

					ACCESS_GROUP_USERGROUP:AddOption(L"custom_ellipsis", function()
						Derma_StringRequest(L"add_access_group", L"enter_usergroup", LocalPlayer():GetUserGroup(), function(usergroup)
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.USERGROUP, usergroup)
						end)
					end):SetIcon("icon16/pencil.png")

					local usergroups = {superadmin = true, admin = true, user = true}
					for _,ply in ipairs(player.GetHumans()) do
						for usergroup in pairs(OpenPermissions:GetUserGroups(ply)) do
							usergroups[usergroup] = true
						end
					end
					usergroups = table.GetKeys(usergroups)
					table.sort(usergroups)
					for i,usergroup in ipairs(usergroups) do
						GreenToRed_DMenu(i, #usergroups, ACCESS_GROUP_USERGROUP:AddOption(usergroup, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.USERGROUP, usergroup)
						end))
					end

				local ACCESS_GROUP_STEAMID, _ = menu:AddSubMenu(L"ACCESS_GROUP_STEAMID") _:SetIcon("icon16/user_gray.png")

					ACCESS_GROUP_STEAMID:AddOption(L"custom_ellipsis", function()
						Derma_StringRequest(L"add_access_group", Lf("enter_steamid", LocalPlayer():SteamID(), LocalPlayer():SteamID64()), LocalPlayer():SteamID(), function(_input)
							local steamid64
							if (_input:find("^STEAM_%d:%d:%d+$")) then
								steamid64 = util.SteamIDTo64(_input)
							elseif (_input:find("^7656119%d+$")) then
								steamid64 = _input
							else
								Derma_Message(L"invalid_steamid", L"error", L"ok")
								return
							end
							local steamid = util.SteamIDFrom64(steamid64)
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.STEAMID, steamid, OpenPermissions:SteamIDToAccountID(steamid))
						end)
					end):SetIcon("icon16/pencil.png")

					local steamids = {}
					for _,ply in ipairs(player.GetHumans()) do
						table.insert(steamids, {Distance = ply:GetPos():DistToSqr(LocalPlayer():GetPos()), Name = ply:Nick(), SteamID = ply:SteamID(), AccountID = ply:AccountID(), Color = team.GetColor(ply:Team())})
					end
					table.SortByMember(steamids, "Distance", true)
					for i,item in ipairs(steamids) do
						DMenuOption_ColorIcon(ACCESS_GROUP_STEAMID:AddOption(item.Name, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.STEAMID, item.SteamID, item.AccountID)
						end), item.Color)
					end

				local ACCESS_GROUP_TEAM, _ = menu:AddSubMenu(L"ACCESS_GROUP_TEAM") _:SetIcon("icon16/flag_green.png")

					if (OpenPermissions.IsDarkRP) then
						local categories = {}
						for i,c in ipairs(DarkRP.getCategories().jobs) do
							if (GAS:table_IsEmpty(c.members)) then continue end
							table.insert(categories, {name = c.name, color = c.color, members = c.members})
						end
						table.SortByMember(categories, "name", true)
						for i,c in ipairs(categories) do
							local submenu, _submenu = ACCESS_GROUP_TEAM:AddSubMenu(c.name)
							DMenuOption_ColorIcon(_submenu, c.color)

							local members = {}
							for _,member in ipairs(c.members) do
								table.insert(members, {name = member.name, color = member.color, index = member.team})
							end
							table.SortByMember(members, "name", true)
							for _,member in ipairs(members) do
								DMenuOption_ColorIcon(submenu:AddOption(member.name, function()
									AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.TEAM, member.name, OpenPermissions:GetTeamIdentifier(member.index))
								end), member.color)
							end
						end
					else
						local teams = {}
						for i,t in ipairs(team.GetAllTeams()) do
							table.insert(teams, {Name = t.Name, Index = i, Color = t.Color})
						end
						table.SortByMember(teams, "Name", true)
						for i,item in ipairs(teams) do
							DMenuOption_ColorIcon(ACCESS_GROUP_TEAM:AddOption(item.Name, function()
								AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.TEAM, item.Name, OpenPermissions:GetTeamIdentifier(i))
							end), item.Color)
						end
					end

				local ACCESS_GROUP_LUA_FUNCTION, _ = menu:AddSubMenu(L"ACCESS_GROUP_LUA_FUNCTION") _:SetIcon("icon16/script.png")
					local lua_functions = table.GetKeys(OpenPermissions.LuaFunctions)
					if (#lua_functions == 0) then
						ACCESS_GROUP_LUA_FUNCTION:AddOption(L"none_info")
					else
						table.sort(lua_functions)
						for i,lua_func_name in ipairs(lua_functions) do
							GreenToRed_DMenu(i, #lua_functions, ACCESS_GROUP_LUA_FUNCTION:AddOption(lua_func_name, function()
								AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.LUA_FUNCTION, lua_func_name)
							end))
						end
					end

				if (OpenPermissions.IsDarkRP) then
					local ACCESS_GROUP_DARKRP_CATEGORY, _ = menu:AddSubMenu(L"ACCESS_GROUP_DARKRP_CATEGORY") _:SetIcon("icon16/wrench_orange.png")
					local darkrp_categories = {}
					for i,category in ipairs(DarkRP.getCategories().jobs) do
						table.insert(darkrp_categories, {Name = category.name, Color = category.color, Category = category})
					end
					table.SortByMember(darkrp_categories, "Name", true)
					for i,item in ipairs(darkrp_categories) do
						DMenuOption_ColorIcon(ACCESS_GROUP_DARKRP_CATEGORY:AddOption(item.Name, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY, item.Name, OpenPermissions:DarkRP_GetCategoryIdentifier(i))
						end), item.Color)
					end
				end

				hook.Run("OpenPermissions:AddAccessGroup", menu)

				menu:Open()
			end

		local function permissions_node_clicked(self, addon_id, v)
			PropertiesContent:Clear()

			local indent_level = 0
			local function _r(tbl, permission_id, my_parent, i)
				i = (i or 0) + 1
				local final_checkbox
				for i,v in ipairs(tbl) do
					local my_permission_id = permission_id
					if (v[2].Value) then
						my_permission_id = my_permission_id .. "/" .. v[2].Value
					end
					local new_checkbox = PropertiesContent:AddProperty(v[2], indent_level)
					final_checkbox = new_checkbox
					v[3] = new_checkbox
					v[4] = my_parent

					function new_checkbox:CheckAmbigious()
						if (my_parent) then
							local all_state
							local ambigious = false
							for _,_v in ipairs(my_parent[1]) do
								if (not IsValid(_v[3])) then continue end
								if (_v[3]:IsAmbigious()) then
									ambigious = true
									break
								elseif (all_state == nil) then
									all_state = _v[3]:GetChecked()
								elseif (all_state ~= _v[3]:GetChecked()) then
									ambigious = true
									break
								end
							end
							my_parent[3]:SetAmbigious(ambigious)
							if (not ambigious) then
								my_parent[3]:SetChecked(all_state)
							end
							my_parent[3]:CheckAmbigious()
						end
					end
					function new_checkbox:OnChange()
						self:CheckAmbigious()
						if (#v[1] > 0) then
							local function __r(tbl)
								for _,_v in ipairs(tbl) do
									_v[3]:SetChecked(self:GetChecked())
									_v[3]:OnChange()
									__r(_v[1])
								end
							end
							__r(v[1])
						else
							PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
						end
					end

					PermissionsSave:CheckedFromMemory(my_permission_id, new_checkbox)

					if (#v[1] > 0) then
						indent_level = indent_level + 1
						_r(v[1], my_permission_id, v, i)
					end
				end
				if (final_checkbox) then
					final_checkbox:CheckAmbigious()
				end
				indent_level = indent_level - 1
			end
			_r(v[1], addon_id)
		end
		function PermissionsTab:LoadPermissions(addon_id, addon_data, shouldnt_clear)
			PermissionsTab.AddonID, PermissionsTab.AddonData = addon_id, addon_data

			if (not shouldnt_clear) then
				PermissionsTree:Clear()
				PropertiesContent:Clear()
			end

			local tree = addon_data[1]
			local addon_options = addon_data[2]

			local root_node = PermissionsTree:AddNode(addon_options.Name or addon_id, addon_options.Icon)
			if (not shouldnt_clear) then root_node:SetExpanded(true) end
			function root_node:DoClick()
				-- show all permissions
				permissions_node_clicked(self, addon_id, addon_data)
			end

			local is_root = true
			local function r(tbl, node, permission_id, prev_options)
				local lowest_level = true
				for _,v in ipairs(tbl) do
					if (#v[1] > 0) then
						lowest_level = false
						break
					end
				end
				if (not is_root and lowest_level) then
					-- if we can't go any deeper then show property checkboxes
					-- when the node is clicked
					function node:DoClick()
						PropertiesContent:Clear()

						if (#tbl > 1) then
							local checkboxes = {}
							local master_checkbox = PropertiesContent:AddProperty(prev_options)
							function master_checkbox:OnChange()
								self:SetAmbigious(false)
								for _,v in ipairs(checkboxes) do
									v:SetChecked(self:GetChecked())
									v:OnChange()
								end
							end

							for i,v in ipairs(tbl) do
								local my_permission_id = permission_id
								if (v[2].Value) then
									my_permission_id = my_permission_id .. "/" .. v[2].Value
								end
								local checkbox = PropertiesContent:AddProperty(v[2], 1)
								table.insert(checkboxes, checkbox)
								function checkbox:CheckAmbigious()
									local all_state
									local ambigious = false
									for _,v in ipairs(checkboxes) do
										if (v:IsAmbigious()) then
											ambigious = true
											break
										elseif (all_state == nil) then
											all_state = v:GetChecked()
										elseif (all_state ~= v:GetChecked()) then
											ambigious = true
											break
										end
									end
									master_checkbox:SetAmbigious(ambigious)
									if (not ambigious) then master_checkbox:SetChecked(all_state) end
								end
								function checkbox:OnChange()
									PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
									self:CheckAmbigious()
								end
								PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
							end
							checkboxes[1]:CheckAmbigious()
						else
							local my_permission_id = permission_id
							if (tbl[1][2].Value) then
								my_permission_id = my_permission_id .. "/" .. tbl[1][2].Value
							end
							local checkbox = PropertiesContent:AddProperty(tbl[1][2])
							function checkbox:OnChange()
								PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
							end
							PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
						end
					end
				else
					is_root = false
				end

				for _,v in ipairs(tbl) do
					local my_permission_id = permission_id
					if (v[2].Value) then
						my_permission_id = my_permission_id .. "/" .. v[2].Value
					end
					local new_node = node:AddNode(v[2].Label)
					if (v[2].Icon) then
						new_node:SetIcon(v[2].Icon)
					elseif (v[2].Color) then
						function new_node.Icon:PaintOver(w,h)
							surface.SetDrawColor(v[2].Color)
							surface.DrawRect(0,0,w,h)
						end
					end
					if (#v[1] == 0) then
						function new_node:DoClick()
							PropertiesContent:Clear()
							local checkbox = PropertiesContent:AddProperty(v[2])
							function checkbox:OnChange()
								PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
							end
							PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
						end
					else
						function new_node:DoClick()
							permissions_node_clicked(self, my_permission_id, v)
						end
						r(v[1], new_node, my_permission_id, v[2])
					end
				end
			end
			r(tree, root_node, addon_id)
		end

	local TesterTab = vgui.Create("DPanel", Tabs)
	TesterTab.Paint = nil

	local HelpTabContent = vgui.Create("DPanel", Tabs)
	HelpTabContent.Paint = nil

	Tabs:AddSheet(L"permissions", PermissionsTab, "icon16/group.png")
	Tabs:AddSheet(L"tester", TesterTab, "icon16/wrench_orange.png")
	local HelpTab = Tabs:AddSheet(L"help", HelpTabContent, "icon16/help.png")

	local HelpContent
	function Tabs:OnActiveTabChanged(old, new)
		if (new == HelpTab.Tab) then
			if (IsValid(HelpContent)) then
				HelpContent:SetVisible(true)
			else
				HelpContent = vgui.Create("DPanel", HelpTabContent)
				HelpContent.Paint = nil
				HelpContent:Dock(FILL)

				local HelpControls = vgui.Create("DHTMLControls", HelpContent)
				HelpControls:Dock(TOP)
				HelpControls.HomeURL = "https://gmodadminsuite.github.io/OpenPermissions"

				local HelpHTML = vgui.Create("DHTML", HelpContent)
				HelpHTML:Dock(FILL)
				HelpHTML:OpenURL(HelpControls.HomeURL)

				HelpControls:SetHTML(HelpHTML)
			end
		elseif (IsValid(HelpContent)) then
			HelpContent:SetVisible(false)
		end
	end

	--## Create Dynamic Content ##--

	function DeleteAccessGroup:DoClick()
		for i,line in pairs(AccessGroups:GetLines()) do
			if (not line:IsLineSelected()) then continue end
			if (AccessGroups.Data[line.Data.Enum][line.Data.Value] ~= nil) then
				AccessGroups.Data[line.Data.Enum][line.Data.Value] = nil
			end
			if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) then
				OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = nil
			end
			AccessGroups:RemoveLine(i)
		end
		AddonContent:SetShowOverlay(true)
		AddonContent:SwitchToName(L"permissions")
		PermissionsTree:Clear()
		PropertiesContent:Clear()

		PermissionsSave:SetDisabled(false)
	end

	local sorted_addons = {}
	for id, data in pairs(OpenPermissions.Addons) do
		local options = data[2]
		table.insert(sorted_addons, {name = options.Name or id, id = id, data = data})
	end
	table.SortByMember(sorted_addons, "name", true)

	local AddonQueue = {}
	local ActiveAddon
	for _,addon_data in ipairs(sorted_addons) do
		local id, data = addon_data.id, addon_data.data
		local options = data[2]
		AddonSelect:AddChoice(options.Name or id, id, false, options.Icon)

		local Addon = vgui.Create("OpenPermissions.Addon", AddonsContainer)

		if (specific_addon == id) then
			ActiveAddon = Addon
		end

		AddonSelect.AddonBtns[id] = Addon

		Addon:SetSize(200,120)
		Addon:Setup(id, options)
		if (Addon.Addon.Logo) then
			OpenPermissions:AddTooltip(Addon, {
				Text = options.Name
			})
		end

		function Addon:DoClick()
			PropertiesContent:Clear()

			AddonSelect:SetValue(options.Name or id)

			AddonsContainer:SetVisible(false)
			AddonContentContainer:SetVisible(true)

			AccessGroupsDivider:SetRight(AddonContentContainer)

			CopyPermissions:SetDisabled(#AccessGroups:GetSelected() > 1)
			PastePermissions:SetDisabled(true)

			function AccessGroups:OnRowSelected(i, row)
				AddonContent:SetShowOverlay(false)
				PropertiesContent:Clear()
				PermissionsTab:LoadPermissions(id, data)
			end
			if (AccessGroups:GetSelectedLine() ~= nil) then
				AccessGroups:OnRowSelected()
			end
		end

		table.insert(AddonQueue, Addon)
		if (#AddonQueue == 3) then
			AddonsContainer:AddRow(AddonQueue[1], AddonQueue[2], AddonQueue[3])
			AddonQueue = {}
		end
	end
	if (#AddonQueue > 0) then
		AddonsContainer:AddRow(AddonQueue[1], AddonQueue[2], AddonQueue[3])
	end
	if (ActiveAddon) then
		ActiveAddon:DoClick()
	end
end

net.Receive("OpenPermissions.OpenMenu", function()
	OpenPermissions.Addons = OpenPermissions:ReceiveNetworkTable()
	OpenPermissions.PermissionsRegistryEditing = table.Copy(OpenPermissions.PermissionsRegistry)

	local specific_addon = net.ReadBool()
	if (specific_addon) then
		OpenPermissions:OpenMenu(net.ReadString())
	else
		OpenPermissions:OpenMenu()
	end
end)

concommand.Add("openpermissions", function(_, __, args)
	net.Start("OpenPermissions.OpenMenu")
		net.WriteString(table.concat(args, " "))
	net.SendToServer()
end, function(cmd, args)
	local stuff = {}
	if (OpenPermissions.Addons ~= nil) then
		if (#string.Trim(args) > 0) then
			for name in pairs(OpenPermissions.Addons) do
				if (name:lower():find(string.Trim(args):lower())) then
					stuff[#stuff + 1] = "openpermissions " .. name
				end
			end
		else
			for name in pairs(OpenPermissions.Addons) do
				stuff[#stuff + 1] = "openpermissions " .. name
			end
		end
	end
	table.sort(stuff)
	return stuff
end)

net.Receive("OpenPermissions.NoPermissions", function()
	OpenPermissions:ChatPrint(L"operator_only_menu", "[ERROR]", OpenPermissions.COLOR_RED)
end)

net.Receive("OpenPermissions.NotAnAddon", function()
	OpenPermissions:ChatPrint(L"not_an_addon", "[ERROR]", OpenPermissions.COLOR_RED)
end)
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/derma/cl_fonts.lua:
-- This just creates the font. to keep them organised
surface.CreateFont("pCasino.Header.Static", {
	font = "Roboto",
	size = 35,
})
surface.CreateFont("pCasino.Title.Static", {
	font = "Roboto",
	size = 36,
})
surface.CreateFont("pCasino.Entity.Bid", {
	font = "Roboto",
	size = 40,
})
surface.CreateFont("pCasino.Entity.Arrows", {
	font = "Roboto",
	size = 60,
})
surface.CreateFont("pCasino.SubTitle.Static", {
	font = "Roboto",
	size = 24,
})
surface.CreateFont("pCasino.Main.Static", {
	font = "Roboto",
	size = 28,
})
surface.CreateFont("pCasino.Nav.Static", {
	font = "Roboto",
	size = 25,
})
surface.CreateFont("pCasino.Textbox.Static", {
	font = "Roboto",
	size = 20,
	weight = 500,
})
surface.CreateFont("pCasino.Button.Micro", {
	font = "Roboto",
	size = 15,
	weight = 500,
})
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/sh_core.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/sh_chip.lua:
-- All the types of chips
PerfectCasino.Chips.Types = {1, 5, 10, 25, 50, 100, 250, 500, 1000, 2000, 5000, 25000, 50000, 100000, 250000, 500000, 1000000, 10000000, 100000000, 1000000000, 10000000000}
-- Builds a stack of chips to equal the number given
function PerfectCasino.Chips:GetFromNumber(num)
	local total = num
	local chips = {}

	-- Loop the chip set and break it into chips
	for i = #PerfectCasino.Chips.Types, 1, -1 do
		local chip = PerfectCasino.Chips.Types[i]
		-- We offset by 1 to account for skins starting at 0
		chips[i-1] = math.floor(total/chip)
		total = total - (chips[i-1]*chip)

		-- Don't include it if it's empty
		if chips[i-1] == 0 then
			chips[i-1] = nil
		end
	end

	return chips
end

--PATH lua/autorun/prison_npc.lua:
return gluapack()()
--PATH lua/reality_development/client/sh_warning.lua:
return gluapack()()
--PATH lua/reality_development/client/sh_warning.lua:
hook.Add("RDV_LIB_RegisterConfigOptions", "RDV.LIBRARY.CHARACTERS", function()
    RDV.LIBRARY.AddConfigOption("LIB_warnEnabled", {
        TYPE = RDV.LIBRARY.TYPE.BL,
        DEFAULT = true,
        CATEGORY = "[RDV] Library", 
        DESCRIPTION = "Should the RDV Library warning be sent to Admins?", 
        SECTION = "Other",
    })
end)
--PATH lua/reality_development/functions/text_wrap/cl_functions.lua:
return gluapack()()
--PATH lua/reality_development/libs/characters/sh_register.lua:
return gluapack()()
--PATH lua/reality_development/libs/characters/list/sh_nutscript.lua:
local OBJ = RDV.LIBRARY.RegisterCharacter("nutscript")

function OBJ:GetCharacterID(p)
    return p:getChar():getID()
end

function OBJ:OnCharacterLoaded(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("CharacterLoaded", function(SLOT)
        local CHAR = nut.char.loaded[SLOT]

        local CLIENT = CHAR:getPlayer()

        if not IsValid(CLIENT) then
            return
        end

        CALLBACK(CLIENT, SLOT)
    end)
end

function OBJ:OnCharacterDeleted(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("OnCharacterDelete", function(CLIENT, SLOT)
        CALLBACK(CLIENT, SLOT)
    end)
end

function OBJ:OnCharacterChanged(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("PlayerLoadedChar", function(client, new, old)
        if not old then
            return
        end

        if new ~= old then
            CALLBACK(client, new:getID(), old:getID())
        end
    end)
end
--PATH lua/reality_development/libs/characters/list/sh_voidchar.lua:
local OBJ = RDV.LIBRARY.RegisterCharacter("voidchar")

function OBJ:GetCharacterID(p)
    return tonumber(p:GetCharacterID())
end

function OBJ:OnCharacterLoaded(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("VoidChar.CharacterSelected", function(ply, charobj)
        if not IsValid(ply) then
            return
        end

        local slot = tonumber(charobj.id)

        CALLBACK(ply, slot)
    end)
end

function OBJ:OnCharacterDeleted(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("VoidChar.CharacterDeleted", function(player, charobj)
        CALLBACK(player, tonumber(charobj.id))
    end)
end

function OBJ:OnCharacterChanged(CALLBACK)
    RDV.LIBRARY.AddCharacterHook("VoidChar.CharacterSelected", function(client, new, old)
        if not old then
            return
        end

        if new ~= old then
            CALLBACK(client, tonumber(new.id), tonumber(old.id))
        end
    end)
end
--PATH lua/reality_development/libs/currencies/list/sh_gwg.lua:
local OBJ = RDV.LIBRARY.RegisterCurrency("gatewaygaming")

function OBJ:AddMoney(p, amount)
    p:AddBalance(amount)
end

function OBJ:CanAfford(p, amount)
    if p:GetBalance() >= amount then
        return true
    else
        return false
    end
end

function OBJ:FormatMoney(money)
    return string.Comma(money).."RC"
end
--PATH lua/reality_development/libs/currencies/list/sh_nutscript.lua:
return gluapack()()
--PATH lua/autorun/rdv_intercom_init.lua:
timer.Simple(0, function()
    local VALID = RDV.LIBRARY.RegisterProduct("Intercom", {}, "5oCOXFJ")

    if !VALID then return end

    RDV.INTERCOM = RDV.INTERCOM or {
        CFG = {},
    }

    local rootDir = "rdv_intercom_config"

    local function AddFile(File, dir)
        local fileSide = string.lower(string.Left(File , 3))

        if SERVER and fileSide == "sv_" then
            include(dir..File)
        elseif fileSide == "sh_" then
            if SERVER then 
                AddCSLuaFile(dir..File)
            end
            include(dir..File)
        elseif fileSide == "cl_" then
            if SERVER then 
                AddCSLuaFile(dir..File)
            elseif CLIENT then
                include(dir..File)
            end
        end
    end

    local function IncludeDir(dir)
        dir = dir .. "/"
        local File, Directory = file.Find(dir.."*", "LUA")

        for k, v in ipairs(File) do
            if string.EndsWith(v, ".lua") then
                AddFile(v, dir)
            end
        end
        
        for k, v in ipairs(Directory) do
            IncludeDir(dir..v)
        end

    end
    IncludeDir(rootDir)
end)
--PATH addons/[admin] sam-160/lua/autorun/sam.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/libs/message_pack/sh_messagepack.lua:
if SAM_LOADED then return end
--
-- lua-MessagePack : <https://fperrad.frama.io/lua-MessagePack/>
--
local SIZEOF_NUMBER = string.pack and #string.pack('n', 0.0) or 8
local maxinteger
local mininteger
local assert = assert
local error = error
local pairs = pairs
local pcall = pcall
local setmetatable = setmetatable
local tostring = tostring
local char = string.char
local format = string.format
local floor = math.floor
local tointeger = floor
local frexp = math.frexp
local ldexp = math.ldexp
local huge = math.huge
local tconcat = table.concat
local type = sam.type
local isnumber = sam.isnumber
local _ENV = nil
local m = {}

--[[ debug only
local function hexadump (s)
	return (s:gsub('.', function (c) return format('%02X ', c:byte()) end))
end
m.hexadump = hexadump
--]]
local function argerror(caller, narg, extramsg)
	error("bad argument #" .. tostring(narg) .. " to " .. caller .. " (" .. extramsg .. ")")
end

local function typeerror(caller, narg, arg, tname)
	argerror(caller, narg, tname .. " expected, got " .. type(arg))
end

local function checktype(caller, narg, arg, tname)
	if type(arg) ~= tname then
		typeerror(caller, narg, arg, tname)
	end
end

local packers = setmetatable({}, {
	__index = function(t, k)
		if k == 1 then return end -- allows ipairs
		error("pack '" .. k .. "' is unimplemented")
	end
})

m.packers = packers

packers["nil"] = function(buffer)
	buffer[#buffer + 1] = char(0xC0) -- nil
end

packers["boolean"] = function(buffer, bool)
	if bool then
		buffer[#buffer + 1] = char(0xC3) -- true
	else
		buffer[#buffer + 1] = char(0xC2) -- false
	end
end

packers["string_compat"] = function(buffer, str)
	local n = #str

	if n <= 0x1F then
		buffer[#buffer + 1] = char(0xA0 + n) -- fixstr
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDA, floor(n / 0x100), n % 0x100) -- str16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDB, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- str32
	else
		error"overflow in pack 'string_compat'"
	end

	buffer[#buffer + 1] = str
end

packers["_string"] = function(buffer, str)
	local n = #str

	if n <= 0x1F then
		buffer[#buffer + 1] = char(0xA0 + n) -- fixstr
	elseif n <= 0xFF then
		buffer[#buffer + 1] = char(0xD9, n) -- str8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDA, floor(n / 0x100), n % 0x100) -- str16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDB, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- str32
	else
		error("overflow in pack 'string'")
	end

	buffer[#buffer + 1] = str
end

packers["binary"] = function(buffer, str)
	local n = #str

	if n <= 0xFF then
		buffer[#buffer + 1] = char(0xC4, n) -- bin8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xC5, floor(n / 0x100), n % 0x100) -- bin16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xC6, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- bin32
	else
		error("overflow in pack 'binary'")
	end

	buffer[#buffer + 1] = str
end

local set_string = function(str)
	if str == "string_compat" then
		packers["string"] = packers["string_compat"]
	elseif str == "string" then
		packers["string"] = packers["_string"]
	elseif str == "binary" then
		packers["string"] = packers["binary"]
	else
		argerror("set_string", 1, "invalid option '" .. str .. "'")
	end
end

m.set_string = set_string

packers["map"] = function(buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer + 1] = char(0x80 + n) -- fixmap
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDE, floor(n / 0x100), n % 0x100) -- map16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDF, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- map32
	else
		error("overflow in pack 'map'")
	end

	for k, v in pairs(tbl) do
		packers[type(k)](buffer, k)
		packers[type(v)](buffer, v)
	end
end

packers["array"] = function(buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer + 1] = char(0x90 + n) -- fixarray
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDC, floor(n / 0x100), n % 0x100) -- array16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDD, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- array32
	else
		error("overflow in pack 'array'")
	end

	for i = 1, n do
		local v = tbl[i]
		packers[type(v)](buffer, v)
	end
end

local set_array = function(array)
	if array == "without_hole" then
		packers["_table"] = function(buffer, tbl)
			local is_map, n, max = false, 0, 0

			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end

				n = n + 1
			end

			-- there are holes
			if max ~= n then
				is_map = true
			end

			if is_map then
				packers["map"](buffer, tbl, n)
			else
				packers["array"](buffer, tbl, n)
			end
		end
	elseif array == "with_hole" then
		packers["_table"] = function(buffer, tbl)
			local is_map, n, max = false, 0, 0

			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end

				n = n + 1
			end

			if is_map then
				packers["map"](buffer, tbl, n)
			else
				packers["array"](buffer, tbl, max)
			end
		end
	elseif array == "always_as_map" then
		packers["_table"] = function(buffer, tbl)
			local n = 0

			for k in pairs(tbl) do
				n = n + 1
			end

			packers["map"](buffer, tbl, n)
		end
	else
		argerror("set_array", 1, "invalid option '" .. array .. "'")
	end
end

m.set_array = set_array

packers["table"] = function(buffer, tbl)
	packers["_table"](buffer, tbl)
end

packers["unsigned"] = function(buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer + 1] = char(n) -- fixnum_pos
		elseif n <= 0xFF then
			buffer[#buffer + 1] = char(0xCC, n) -- uint8
		elseif n <= 0xFFFF then
			buffer[#buffer + 1] = char(0xCD, floor(n / 0x100), n % 0x100) -- uint16
		elseif n <= 4294967295.0 then
			buffer[#buffer + 1] = char(0xCE, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- uint32
		else
			buffer[#buffer + 1] = char(0xCF, 0, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- uint64 -- only 53 bits from double
		end
	else
		if n >= -0x20 then
			buffer[#buffer + 1] = char(0x100 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer + 1] = char(0xD0, 0x100 + n) -- int8
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0xFF, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	end
end

packers["signed"] = function(buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer + 1] = char(n) -- fixnum_pos
		elseif n <= 0x7FFF then
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n <= 0x7FFFFFFF then
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	else
		if n >= -0x20 then
			buffer[#buffer + 1] = char(0xE0 + 0x20 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer + 1] = char(0xD0, 0x100 + n) -- int8
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0xFF, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	end
end

local set_integer = function(integer)
	if integer == "unsigned" then
		packers["integer"] = packers["unsigned"]
	elseif integer == "signed" then
		packers["integer"] = packers["signed"]
	else
		argerror("set_integer", 1, "invalid option '" .. integer .. "'")
	end
end

m.set_integer = set_integer

packers["float"] = function(buffer, n)
	local sign = 0

	if n < 0.0 then
		sign = 0x80
		n = -n
	end

	local mant, expo = frexp(n)

	if mant ~= mant then
		buffer[#buffer + 1] = char(0xCA, 0xFF, 0x88, 0x00, 0x00) -- nan
	elseif mant == huge or expo > 0x80 then
		if sign == 0 then
			buffer[#buffer + 1] = char(0xCA, 0x7F, 0x80, 0x00, 0x00) -- inf
		else
			buffer[#buffer + 1] = char(0xCA, 0xFF, 0x80, 0x00, 0x00) -- -inf
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
		buffer[#buffer + 1] = char(0xCA, sign, 0x00, 0x00, 0x00) -- zero
	else
		expo = expo + 0x7E
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 24))
		buffer[#buffer + 1] = char(0xCA, sign + floor(expo / 0x2), (expo % 0x2) * 0x80 + floor(mant / 0x10000), floor(mant / 0x100) % 0x100, mant % 0x100)
	end
end

packers["double"] = function(buffer, n)
	local sign = 0

	if n < 0.0 then
		sign = 0x80
		n = -n
	end

	local mant, expo = frexp(n)

	if mant ~= mant then
		buffer[#buffer + 1] = char(0xCB, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- nan
	elseif mant == huge or expo > 0x400 then
		if sign == 0 then
			buffer[#buffer + 1] = char(0xCB, 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- inf
		else
			buffer[#buffer + 1] = char(0xCB, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- -inf
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x3FE then
		buffer[#buffer + 1] = char(0xCB, sign, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- zero
	else
		expo = expo + 0x3FE
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 53))
		buffer[#buffer + 1] = char(0xCB, sign + floor(expo / 0x10), (expo % 0x10) * 0x10 + floor(mant / 0x1000000000000), floor(mant / 0x10000000000) % 0x100, floor(mant / 0x100000000) % 0x100, floor(mant / 0x1000000) % 0x100, floor(mant / 0x10000) % 0x100, floor(mant / 0x100) % 0x100, mant % 0x100)
	end
end

local set_number = function(number)
	if number == "float" then
		packers["number"] = function(buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers["integer"](buffer, n)
			else
				packers["float"](buffer, n)
			end
		end
	elseif number == "double" then
		packers["number"] = function(buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers["integer"](buffer, n)
			else
				packers["double"](buffer, n)
			end
		end
	else
		argerror("set_number", 1, "invalid option '" .. number .. "'")
	end
end

m.set_number = set_number

for k = 0, 4 do
	local n = tointeger(2 ^ k)
	local fixext = 0xD4 + k

	packers["fixext" .. tostring(n)] = function(buffer, tag, data)
		assert(#data == n, "bad length for fixext" .. tostring(n))
		buffer[#buffer + 1] = char(fixext, tag < 0 and tag + 0x100 or tag)
		buffer[#buffer + 1] = data
	end
end

packers["ext"] = function(buffer, tag, data)
	local n = #data

	if n <= 0xFF then
		buffer[#buffer + 1] = char(0xC7, n, tag < 0 and tag + 0x100 or tag) -- ext8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xC8, floor(n / 0x100), n % 0x100, tag < 0 and tag + 0x100 or tag) -- ext16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xC9, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100, tag < 0 and tag + 0x100 or tag) -- ext&32
	else
		error("overflow in pack 'ext'")
	end

	buffer[#buffer + 1] = data
end

function m.pack(data)
	local buffer = {}
	packers[type(data)](buffer, data)

	return tconcat(buffer)
end

local unpackers -- forward declaration

local function unpack_cursor(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local val = s:byte(i)
	c.i = i + 1

	return unpackers[val](c, val)
end

m.unpack_cursor = unpack_cursor

local function unpack_str(c, n)
	local s, i, j = c.s, c.i, c.j
	local e = i + n - 1

	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i + n - 1
	end

	c.i = i + n

	return s:sub(i, e)
end

local function unpack_array(c, n)
	local t = {}

	for i = 1, n do
		t[i] = unpack_cursor(c)
	end

	return t
end

local function unpack_map(c, n)
	local t = {}

	for i = 1, n do
		local k = unpack_cursor(c)
		local val = unpack_cursor(c)

		if k == nil or k ~= k then
			k = m.sentinel
		end

		if k ~= nil then
			t[k] = val
		end
	end

	return t
end

local function unpack_float(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x2 + floor(b2 / 0x80)
	local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4

	if sign then
		sign = -1
	else
		sign = 1
	end

	local n

	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0xFF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0 / 0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 0x800000, expo - 0x7F)
	end

	c.i = i + 4

	return n
end

local function unpack_double(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x10 + floor(b2 / 0x10)
	local mant = ((((((b2 % 0x10) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8

	if sign then
		sign = -1
	else
		sign = 1
	end

	local n

	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0x7FF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0 / 0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 4503599627370496.0, expo - 0x3FF)
	end

	c.i = i + 8

	return n
end

local function unpack_uint8(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local b1 = s:byte(i)
	c.i = i + 1

	return b1
end

local function unpack_uint16(c)
	local s, i, j = c.s, c.i, c.j

	if i + 1 > j then
		c:underflow(i + 1)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2 = s:byte(i, i + 1)
	c.i = i + 2

	return b1 * 0x100 + b2
end

local function unpack_uint32(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	c.i = i + 4

	return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
end

local function unpack_uint64(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	c.i = i + 8

	return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
end

local function unpack_int8(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local b1 = s:byte(i)
	c.i = i + 1

	if b1 < 0x80 then
		return b1
	else
		return b1 - 0x100
	end
end

local function unpack_int16(c)
	local s, i, j = c.s, c.i, c.j

	if i + 1 > j then
		c:underflow(i + 1)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2 = s:byte(i, i + 1)
	c.i = i + 2

	if b1 < 0x80 then
		return b1 * 0x100 + b2
	else
		return ((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) - 1
	end
end

local function unpack_int32(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	c.i = i + 4

	if b1 < 0x80 then
		return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
	else
		return ((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) - 1
	end
end

local function unpack_int64(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	c.i = i + 8

	if b1 < 0x80 then
		return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	else
		return ((((((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) * 0x100 + (b5 - 0xFF)) * 0x100 + (b6 - 0xFF)) * 0x100 + (b7 - 0xFF)) * 0x100 + (b8 - 0xFF)) - 1
	end
end

function m.build_ext(tag, data)
	return nil
end

local function unpack_ext(c, n, tag)
	local s, i, j = c.s, c.i, c.j
	local e = i + n - 1

	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i + n - 1
	end

	c.i = i + n

	return m.build_ext(tag, s:sub(i, e))
end

local fn_1 = function(c, val) return val end
local fn_2 = function(c, val) return unpack_map(c, val % 0x10) end
local fn_3 = function(c, val) return unpack_array(c, val % 0x10) end
local fn_4 = function(c, val) return unpack_str(c, val % 0x20) end
local fn_5 = function(c, val) return val - 0x100 end

unpackers = setmetatable({
	[0xC0] = function() return nil end,
	[0xC2] = function() return false end,
	[0xC3] = function() return true end,
	[0xC4] = function(c) return unpack_str(c, unpack_uint8(c)) end, -- bin8
	[0xC5] = function(c) return unpack_str(c, unpack_uint16(c)) end, -- bin16
	[0xC6] = function(c) return unpack_str(c, unpack_uint32(c)) end, -- bin32
	[0xC7] = function(c) return unpack_ext(c, unpack_uint8(c), unpack_int8(c)) end,
	[0xC8] = function(c) return unpack_ext(c, unpack_uint16(c), unpack_int8(c)) end,
	[0xC9] = function(c) return unpack_ext(c, unpack_uint32(c), unpack_int8(c)) end,
	[0xCA] = unpack_float,
	[0xCB] = unpack_double,
	[0xCC] = unpack_uint8,
	[0xCD] = unpack_uint16,
	[0xCE] = unpack_uint32,
	[0xCF] = unpack_uint64,
	[0xD0] = unpack_int8,
	[0xD1] = unpack_int16,
	[0xD2] = unpack_int32,
	[0xD3] = unpack_int64,
	[0xD4] = function(c) return unpack_ext(c, 1, unpack_int8(c)) end,
	[0xD5] = function(c) return unpack_ext(c, 2, unpack_int8(c)) end,
	[0xD6] = function(c) return unpack_ext(c, 4, unpack_int8(c)) end,
	[0xD7] = function(c) return unpack_ext(c, 8, unpack_int8(c)) end,
	[0xD8] = function(c) return unpack_ext(c, 16, unpack_int8(c)) end,
	[0xD9] = function(c) return unpack_str(c, unpack_uint8(c)) end,
	[0xDA] = function(c) return unpack_str(c, unpack_uint16(c)) end,
	[0xDB] = function(c) return unpack_str(c, unpack_uint32(c)) end,
	[0xDC] = function(c) return unpack_array(c, unpack_uint16(c)) end,
	[0xDD] = function(c) return unpack_array(c, unpack_uint32(c)) end,
	[0xDE] = function(c) return unpack_map(c, unpack_uint16(c)) end,
	[0xDF] = function(c) return unpack_map(c, unpack_uint32(c)) end
}, {
	__index = function(t, k)
		if k < 0xC0 then
			if k < 0x80 then
				return fn_1
			elseif k < 0x90 then
				return fn_2
			elseif k < 0xA0 then
				return fn_3
			else
				return fn_4
			end
		elseif k > 0xDF then
			return fn_5
		else
			return function()
				error("unpack '" .. format("%#x", k) .. "' is unimplemented")
			end
		end
	end
})

local function cursor_string(str)
	return {
		s = str,
		i = 1,
		j = #str,
		underflow = function()
			error"missing bytes"
		end
	}
end

local function cursor_loader(ld)
	return {
		s = '',
		i = 1,
		j = 0,
		underflow = function(self, e)
			self.s = self.s:sub(self.i)
			e = e - self.i + 1
			self.i = 1
			self.j = 0

			while e > self.j do
				local chunk = ld()

				if not chunk then
					error"missing bytes"
				end

				self.s = self.s .. chunk
				self.j = #self.s
			end
		end
	}
end

function m.unpack(s)
	checktype("unpack", 1, s, "string")
	local cursor = cursor_string(s)
	local data = unpack_cursor(cursor)

	if cursor.i <= cursor.j then
		error("extra bytes")
	end

	return data
end

function m.unpacker(src)
	if type(src) == "string" then
		local cursor = cursor_string(src)

		return function()
			if cursor.i <= cursor.j then return cursor.i, unpack_cursor(cursor) end
		end
	elseif type(src) == "function" then
		local cursor = cursor_loader(src)

		return function()
			if cursor.i > cursor.j then
				pcall(cursor.underflow, cursor, cursor.i)
			end

			if cursor.i <= cursor.j then return true, unpack_cursor(cursor) end
		end
	else
		argerror("unpacker", 1, "string or function expected, got " .. type(src))
	end
end

set_string("string")
set_integer("unsigned")

if SIZEOF_NUMBER == 4 then
	maxinteger = 16777215
	mininteger = -maxinteger
	m.small_lua = true
	unpackers[0xCB] = nil -- double
	unpackers[0xCF] = nil -- uint64
	unpackers[0xD3] = nil -- int64
	set_number("float")
else
	maxinteger = 9007199254740991
	mininteger = -maxinteger
	set_number("double")

	if SIZEOF_NUMBER > 8 then
		m.long_double = true
	end
end

set_array("always_as_map")
m._VERSION = "0.5.2"
m._DESCRIPTION = "lua-MessagePack : a pure Lua implementation"
m._COPYRIGHT = "Copyright (c) 2012-2019 Francois Perrad"

return m
--
-- This library is licensed under the terms of the MIT/X11 license,
-- like Lua itself.
--

--PATH addons/[admin] sam-160/lua/sam/sh_util.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam_language.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/includes/modules/sui.lua:
if sui then return end

AddCSLuaFile()

sui = {}

do
	local wspace_chs = {} -- whitespace  characters except a normal space " "
	for k, v in ipairs({0x0c, 0x0a, 0x0d, 0x09, 0x0b}) do
		wspace_chs[string.char(v)] = true
	end
	sui.wspace_chs = wspace_chs

	local cntrl_chs = {string.char(0x7f)} -- control characters
	for i = 0x00, 0x1f do
		cntrl_chs[string.char(i)] = true
	end
	sui.cntrl_chs = cntrl_chs
end

if SERVER then
	AddCSLuaFile("sui/libs/tdlib/cl_tdlib.lua")
	AddCSLuaFile("sui/libs/bshadows.lua")
	AddCSLuaFile("sui/libs/gif_loader.lua")
	AddCSLuaFile("sui/libs/png_encoder.lua")
	AddCSLuaFile("sui/libs/types.lua")
	AddCSLuaFile("sui/cl_base.lua")
else
	include("sui/libs/tdlib/cl_tdlib.lua")
	include("sui/libs/bshadows.lua")
	include("sui/libs/types.lua")
	include("sui/cl_base.lua")
end

if SERVER then
	for _, f in ipairs(file.Find("sui/vgui/*.lua", "LUA")) do
		AddCSLuaFile("sui/vgui/" .. f)
	end
end
--PATH addons/[lib] sui/lua/sui/vgui/sui_image.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/libs/png_encoder.lua:
local string = string
local table = table
local bit = bit

local char = string.char
local byte = string.byte

local insert = table.insert
local concat = table.concat

local bor = bit.bor
local bxor = bit.bxor
local band = bit.band
local bnot = bit.bnot
local lshift = bit.lshift
local rshift = bit.rshift

local ceil = math.ceil

local SIGNATURE = char(137, 80, 78, 71, 13, 10, 26, 10)

local crc_table = {}; do
	local n = 0
	while n < 256 do
		local c = n
		local k = 0
		while k < 8 do
			if band(c, 1) ~= 0 then
				c = bxor(0xedb88320, rshift(c, 1))
			else
				c = rshift(c, 1)
			end
			k = k + 1
		end
		crc_table[n + 1] = c
		n = n + 1
	end
end

local crc = function(buf)
	local c = 0xffffffff
	for i = 1, #buf do
		c = bxor(crc_table[band(bxor(c, byte(buf, i)), 0xff) + 1], rshift(c, 8))
	end
	return bxor(c, 0xffffffff)
end

local dword_as_string = function(dword)
	return char(
		rshift(band(dword, 0xff000000), 24),
		rshift(band(dword, 0x00ff0000), 16),
		rshift(band(dword, 0x0000ff00), 8),
		band(dword, 0x000000ff)
	)
end

local create_chunk = function(type, data, length)
	local CRC = crc(type .. data)
	return concat({
		dword_as_string(length or #data),
		type,
		data,
		dword_as_string(CRC)
	}, "", 1, 4)
end

local create_IHDR; do
	local ARGS = (
		-- bit depth
		char(8) ..
		-- color type: 6=truecolor with alpha
		char(6) ..
		-- compression method: 0=deflate, only allowed value
		char(0) ..
		-- filtering: 0=adaptive, only allowed value
		char(0) ..
		-- interlacing: 0=none
		char(0)
	)

	create_IHDR = function(w, h)
		return create_chunk("IHDR", concat({
			dword_as_string(w),
			dword_as_string(h),
			ARGS
		}, "", 1, 3), 13)
	end
end

local deflate_pack; do
	local BASE = 6552
	local NMAX = 5552
	local adler32 = function(str)
		local s1 = 1
		local s2 = 0
		local n = NMAX

		for i = 1, #str do
			s1 = s1 + byte(str, i)
			s2 = s2 + s1

			n = n - 1
			if n == 0 then
				s1 = s1 % BASE
				s2 = s2 % BASE
				n = NMAX
			end
		end

		s1 = s1 % BASE
		s2 = s2 % BASE

		return bor(lshift(s2, 16), s1)
	end

	local splitChunks = function(chunk, chunkSize)
		local len = ceil(#chunk / chunkSize)
		local ret = {}
		for i = 1, len do
			ret[i - 1] = chunk:sub(((i - 1) * chunkSize) + 1, chunkSize)
		end
		return ret
	end

	deflate_pack = function(str)
		local ret = {"\x78\x9c"}

		local chunks = splitChunks(str, 0xFFFF)
		local len = #chunks

		local i = 0
		while i < (len + 1) do
			local chunk = chunks[i]
			local chunk_n = #chunk

			insert(ret, i < len and "\x00" or "\x01")
			insert(ret, char(band(chunk_n, 0xff), band(rshift(chunk_n, 8), 0xff)))
			insert(ret, char(band(bnot(chunk_n), 0xff), band(rshift(bnot(chunk_n), 8), 0xff)))
			insert(ret, chunk)
			i = i + 1
		end

		local t = adler32(str)
		t = char(
			band(rshift(t, 24), 0xff),
			band(rshift(t, 16), 0xff),
			band(rshift(t, 8), 0xff),
			band(t, 0xff)
		)

		insert(ret, t)

		return concat(ret)
	end
end

local create_IDAT; do
	local slice = function(a, s, e)
		local ret, j = {}, 0
		for i = s, e - 1 do
			ret[j] = char(band(a[i] or 0, 0xFF))
			j = j + 1
		end
		return ret
	end

	local array_split_chunks = function(w, h, array, chunkSize)
		local ret = {}
		local i = 0
		local len = ceil((w * h * 4 + 4) / chunkSize)
		while i < len do
			ret[i] = slice(array, i * chunkSize, (i + 1) * chunkSize)
			i = i + 1
		end
		return ret
	end

	create_IDAT = function(w, h, chunk)
		local scanlines = array_split_chunks(w, h, chunk, w * 4)

		local image_bytes = {}
		for i = 0, #scanlines do
			local scanline = scanlines[i]
			insert(image_bytes, char(band(0, 0xFF)))
			insert(image_bytes, concat(scanline, "", 0, #scanline))
		end
		image_bytes = deflate_pack(concat(image_bytes))

		return create_chunk("IDAT", image_bytes)
	end
end

local IEND = create_chunk("IEND", "", 0)
local to_return = {SIGNATURE, nil, nil, IEND}
local generate_png = function(w, h, chunk)
	local IHDR = create_IHDR(w, h)
	local IDAT = create_IDAT(w, h, chunk)

	to_return[2] = IHDR
	to_return[3] = IDAT

	return concat(to_return, "", 1, 4)
end

return generate_png
--PATH addons/[lib] sui/lua/sui/vgui/sui_number_slider.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_text_entry.lua:
local sui = sui

local surface = surface
local utf8 = sui.utf8
local draw = draw
local math = math

local IsValid = IsValid
local tostring = tostring
local tonumber = tonumber

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor
local TEXT_ENTRY_FONT = SUI.CreateFont("TextEntry", "Roboto Regular", 16)

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_FontName", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_Editable", "Editable", FORCE_BOOL)
AccessorFunc(Panel, "m_Placeholder", "Placeholder", FORCE_STRING)
AccessorFunc(Panel, "m_MaxChars", "MaxChars", FORCE_NUMBER)
AccessorFunc(Panel, "m_Numeric", "Numeric", FORCE_BOOL)
AccessorFunc(Panel, "m_NoBar", "NoBar", FORCE_BOOL)
AccessorFunc(Panel, "m_BarColor", "BarColor")
AccessorFunc(Panel, "m_Background", "Background")
AccessorFunc(Panel, "m_Radius", "Radius")
AccessorFunc(Panel, "m_NoEnter", "NoEnter")

Panel:SetRadius(3)

function Panel:Init()
	self:ScaleInit()

	self:SetupTransition("TextEntryReady", 0.9, function()
		return self:IsEditing() or self:GetBarColor() ~= nil
	end)

	self:SetUpdateOnType(true)
	self:SetCursor("beam")
	self:SetFont(TEXT_ENTRY_FONT)
	self:SetPlaceholder("Placeholder text")

	self:SetSize(200, 22)

	self.allowed_numeric_characters = "1234567890.-"

	self.history = {}
	self.history_pos = 1
	self.can_use_history = true

	self:OnScaleChange()
end

function Panel:SetCaretPos(pos)
	DTextEntry.SetCaretPos(self, math.Clamp(pos, 0, utf8.len(self:GetText())))
end

function Panel:SetValue(value)
	self:SetText(value)
	self:OnValueChange(value)
end

function Panel:AllowInput(ch)
	if self:CheckNumeric(ch) then return true end

	if sui.wspace_chs[ch] or sui.cntrl_chs[ch] then
		return true
	end

	local max_chars = self:GetMaxChars()
	if max_chars and #self:GetText() >= max_chars then
		surface.PlaySound("resource/warning.wav")
		return true
	end
end

function Panel:AddValue(v, i, j)
	local original_text = self:GetText()

	local start
	if i then
		start = original_text:sub(1, i)
	else
		start = utf8.sub(original_text, 1, self:GetCaretPos())
	end

	local text = start .. v
	local caret_pos = utf8.len(text)

	local _end
	if j then
		_end = original_text:sub(j)
	else
		_end = utf8.sub(original_text, utf8.len(start) + 1)
	end
	text = text .. _end

	local max_chars = self:GetMaxChars()
	if max_chars then
		text = text:sub(1, max_chars)
	end

	self:SetValue(text)
	self:SetCaretPos(caret_pos)
end

function Panel:OnKeyCodeTyped(code)
	if self.no_down then
		self.no_down = nil
		return
	end

	if code == KEY_UP or code == KEY_DOWN then
		if not self:UpdateFromHistory(code) then
			return true
		end

		local lines, caret_line = self:GetNumLines()

		if lines == 1 then
			return true
		end

		--
		-- this fixes a weird issue
		-- make the text entry has at least 2 lines, go up then go down, you won't be able to go up again
		--
		if code == KEY_DOWN and lines == caret_line + 1 then
			self.no_down = true
			gui.InternalKeyCodeTyped(KEY_DOWN)
		end
	end

	self:OnKeyCode(code)

	if code == KEY_ENTER then
		if IsValid(self.Menu) then
			self.Menu:Remove()
		end

		if not self:GetNoEnter() then
			self:FocusNext()
			self:OnEnter()
		end
	end
end

function Panel:DisallowFloats(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%.", "", 1)
	elseif not self.allowed_numeric_characters:find(".", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "."
	end
end

function Panel:DisallowNegative(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%-", "", 1)
	elseif not self.allowed_numeric_characters:find("-", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "-"
	end
end

function Panel:CheckNumeric(value)
	if not self:GetNumeric() then return false end

	if not self.allowed_numeric_characters:find(value, 1, true) then
		return true
	end

	local new_value = ""
	local current_value = tostring(self:GetText())

	local caret_pos = self:GetCaretPos()
	for i = 0, #current_value do
		new_value = new_value .. current_value:sub(i, i)
		if i == caret_pos then
			new_value = new_value .. value
		end
	end

	if #current_value ~= 0 and not tonumber(new_value) then
		return true
	end

	return false
end

function Panel:AddHistory(txt)
	if not txt or txt == "" then return end
	local history = self.history
	if history[#history] ~= txt then
		table.insert(history, txt)
	end
end

function Panel:UpdateFromHistory(code)
	if not self.can_use_history then return end

	local lines, caret_line = self:GetNumLines()

	if code == KEY_UP then
		if caret_line > 1 then return true end -- enable the caret to move up and down

		if self.history_pos <= 1 then return end

		self.history_pos = self.history_pos - 1
	elseif code == KEY_DOWN then
		if caret_line ~= lines then return true end

		if self.history_pos >= #self.history then
			self:SetValue("")
			self:SetCaretPos(0)
			self.history_pos = #self.history + 1
			return
		end

		self.history_pos = self.history_pos + 1
	end

	local text = self.history[self.history_pos]
	if not text then return end

	self:SetValue(text)
	self:SetCaretPos(utf8.len(text))
end

function Panel:OnTextChanged()
	self.history_pos = #self.history + 1

	local text = self:GetText()

	self.can_use_history = text == "" and true or false

	if self:GetUpdateOnType() then
		self:UpdateConvarValue()
		self:OnValueChange(text)
	end

	self:OnChange()
end

function Panel:OnScaleChange()
	self:InvalidateLayout()
	self:InvalidateLayout(true)
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", self:GetRadius(), 0, 0, w, h, GetColor("text_entry_bg") or self:GetBackground())

	local text_entry_3 = GetColor("text_entry_3")

	if self:GetText() == "" then
		local old_text = self:GetText()
		self:SetText(self:GetPlaceholder())
		self:DrawTextEntryText(GetColor("text_entry_2"), text_entry_3, text_entry_3)
		self:SetText(old_text)
	else
		self:DrawTextEntryText(GetColor("text_entry"), text_entry_3, text_entry_3)
	end

	if not self:GetNoBar() then
		local bar_color = self:GetBarColor()

		self:RoundedBox("Bar1", 0, 0, h - 1, w, 1, GetColor("text_entry_bar_color"))

		local bar = math.Round(w * self.TextEntryReady)
		if bar > 0 then
			self:RoundedBox("Bar2", 0, (w / 2) - (bar / 2), h - 1, bar, 1, bar_color or text_entry_3)
		end
	end
end

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/vgui2/vgui_controls/TextEntry.cpp#L969
function Panel:GetNumLines(wide)
	local num_lines = 1

	wide = wide or self:GetWide() - 2

	local char_width
	local x = 3

	local word_start_index = 1
	local word_start_len
	local word_length = 0
	local has_word = false
	local just_started_new_line = true
	local word_started_on_new_line = true

	local start_char = 1

	surface.SetFont(self:GetFont())

	local i = start_char
	local text, n = utf8.force(self:GetText())
	local caret_line = 0
	local caret_pos = self:GetCaretPos()
	local caret_i = 1
	while i <= n do
		local ch_len = utf8.char_bytes(text:byte(i))
		local ch = text:sub(i, i + ch_len - 1)

		if ch ~= " " then
			if not has_word then
				word_start_index = i
				word_start_len = ch_len
				has_word = true
				word_started_on_new_line = just_started_new_line
				word_length = 0
			end
		else
			has_word = false
		end

		char_width = surface.GetTextSize(ch)
		just_started_new_line = false

		if (x + char_width) >= wide then
			x = 3

			just_started_new_line = true
			has_word = false

			if word_started_on_new_line then
				num_lines = num_lines + 1
			else
				num_lines = num_lines + 1
				i = (word_start_index + word_start_len) - ch_len
			end

			word_length = 0
		end

		x = x + char_width
		word_length = word_length + char_width

		if caret_i == caret_pos then
			caret_line = num_lines
		end

		i = i + ch_len
		caret_i = caret_i + 1
	end

	return num_lines, caret_line
end

function Panel:SetCheck(func, col)
	function self:OnValueChange(text)
		if func(text) == false then
			self.valid = false
			self:SetBarColor(GetColor("close_hover"))
			self:SetNoEnter(true)
		else
			self.valid = true
			self:SetBarColor(col)
			self:SetNoEnter(false)
		end
	end
	self:SetValue(self:GetText())
end

sui.register("TextEntry", Panel, "DTextEntry")

--PATH addons/[lib] sui/lua/sui/vgui/sui_threegrid.lua:
local math = math
local table = table
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local Panel = {}

AccessorFunc(Panel, "horizontalMargin", "HorizontalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "verticalMargin", "VerticalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "columns", "Columns", FORCE_NUMBER)
AccessorFunc(Panel, "Wide2", "Wide2", FORCE_NUMBER)

function Panel:Init()
	self:SetHorizontalMargin(0)
	self:SetVerticalMargin(0)
	self.Rows = {}
	self.Cells = {}
end

function Panel:AddCell(pnl)
	local cols = self:GetColumns()
	local idx = math.floor(#self.Cells / cols) + 1

	local rows = self.Rows[idx]
	if not rows then
		rows = self:CreateRow()
		self.Rows[idx] = rows
	end

	local margin = self:GetHorizontalMargin()

	local dockl, dockt, _, dockb = pnl:GetDockMargin()
	pnl:SetParent(rows)
	pnl:Dock(LEFT)
	pnl:DockMargin(dockl, dockt, #rows.Items + 1 < cols and self:GetHorizontalMargin() or 0, dockb)
	pnl:SetWide(((self:GetWide2() or self:GetWide()) - margin * (cols - 1)) / cols)

	table.insert(rows.Items, pnl)
	table.insert(self.Cells, pnl)

	self:CalculateRowHeight(rows)
end

function Panel:CreateRow()
	local row = self:Add("Panel")
	row:Dock(TOP)
	row:DockMargin(0, 0, 0, self:GetVerticalMargin())
	row.Items = {}

	return row
end

function Panel:CalculateRowHeight(row)
	local height = 0

	for k, v in ipairs(row.Items) do
		local _, t, _, b = v:GetDockMargin()
		height = math.max(height, v:GetTall() + t + b)
	end

	row:SetTall(height)
end

function Panel:Skip()
	local cell = vgui.Create("Panel")
	self:AddCell(cell)
end

function Panel:CalculateRowHeights()
	for _, row in ipairs(self.Rows) do
		self:CalculateRowHeight(row)
	end
end

function Panel:Clear()
	for _, row in ipairs(self.Rows) do
		for _, cell in ipairs(row.Items) do
			cell:Remove()
		end

		row:Remove()
	end

	self.Cells, self.Rows = {}, {}
end

Panel.OnRemove = Panel.Clear
sui.register("ThreeGrid", Panel, NAME .. ".ScrollPanel")
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/bans.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/config/reports.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/players.lua:
if SAM_LOADED then return end

local sam = sam
local SQL = sam.SQL
local SUI = sam.SUI
local netstream = sam.netstream

sam.permissions.add("manage_players", nil, "superadmin")

local get_pages_count = function(count)
	count = count / 35
	local i2 = math.floor(count)
	return count ~= i2 and i2 + 1 or count
end

if SERVER then
	local check = function(ply)
		return ply:HasPermission("manage_players") and ply:sam_check_cooldown("MenuViewPlayers", 0.1)
	end

	local limit = 35

	local get_page_count = function(callback, res, page, column, order_by, sort_by, keyword)
		local query = [[
			SELECT
				COUNT(`steamid`) AS `count`
			FROM
				`sam_players`]]
		if keyword then
			if column == "steamid" and sam.is_steamid64(keyword) then
				keyword = util.SteamIDFrom64(keyword)
			end

			query = string.format("%s WHERE `%s` LIKE %s", query, column, SQL.Escape("%" .. keyword .. "%"))
		end
		SQL.Query(query, callback, true, {res, page, column, order_by, sort_by, keyword})
	end

	local valid_columns = {
		steamid = true,
		name = true,
		rank = true
	}

	local valid_sorts = {
		id = true,
		name = true,
		rank = true,
		play_time = true,
		last_join = true
	}

	local resolve_promise = function(data, arguments)
		local res = arguments[1]
		arguments[1] = data
		res(arguments)
	end

	local get_players = function(count_data, arguments)
		local res, page, column, order_by, sort_by, keyword = unpack(arguments)
		local count = count_data.count

		local current_page
		if page < 1 then
			page, current_page = 1, 1
		end

		local pages_count = get_pages_count(count)
		if page > pages_count then
			page, current_page = pages_count, pages_count
		end

		local query = [[
			SELECT
				`steamid`,
				`name`,
				`rank`,
				`expiry_date`,
				`first_join`,
				`last_join`,
				`play_time`
			FROM
				`sam_players`
		]]

		local args = {}

		if keyword then
			args[1] = column
			args[2] = "%" .. keyword .. "%"

			query = query .. [[
				WHERE
					`{1f}` LIKE {2}
			]]
		end

		args[3] = sort_by
		if order_by == "DESC" then
			query = query .. [[
				ORDER BY `{3f}` DESC
			]]
		else
			query = query .. [[
				ORDER BY `{3f}` ASC
			]]
		end

		args[4] = limit
		args[5] = math.abs(limit * (page - 1))

		query = query .. [[
			LIMIT {4} OFFSET {5}
		]]

		SQL.FQuery(query, args, resolve_promise, false, {res, count, current_page})
	end

	netstream.async.Hook("SAM.GetPlayers", function(res, ply, page, column, order_by, sort_by, keyword)
		if not isnumber(page) then return end
		if not valid_columns[column] then return end
		if order_by ~= "ASC" and order_by ~= "DESC" then return end
		if not valid_sorts[sort_by] then return end
		if keyword ~= nil and not sam.isstring(keyword) then return end

		get_page_count(get_players, res, page, column, order_by, sort_by, keyword)
	end, check)

	return
end

local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

local COLUMN_FONT = SUI.CreateFont("Column", "Roboto", 18)
local LINE_FONT = SUI.CreateFont("Line", "Roboto", 16)
local NEXT_FONT = SUI.CreateFont("NextButton", "Roboto", 18)

local button_click = function(s)
	local v = s.v

	local dmenu = vgui.Create("SAM.Menu")
	dmenu:SetInternal(s)
	if v.name and v.name ~= "" then
		dmenu:AddOption("Copy Name", function()
			SetClipboardText(v.name)
		end)
	end

	dmenu:AddOption("Copy SteamID", function()
		SetClipboardText(v.steamid)
	end)

	dmenu:AddOption("Copy Rank", function()
		SetClipboardText(v.rank)
	end)

	dmenu:AddOption("Copy Play Time", function()
		SetClipboardText(sam.reverse_parse_length(tonumber(v.play_time) / 60))
	end)

	dmenu:AddSpacer()

	dmenu:AddOption("Change Rank", function()
		local querybox = vgui.Create("SAM.QueryBox")
		querybox:SetTitle(string.format("Change rank for '%s'", v.name or v.steamid))
		querybox:SetWide(360)

		local ranks = querybox:Add("SAM.ComboBox")
		ranks:SetTall(28)

		for rank_name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
			if v.rank ~= rank_name then
				ranks:AddChoice(rank_name, nil, true)
			end
		end

		querybox:Done()
		querybox.save:SetEnabled(true)

		querybox:SetCallback(function()
			RunConsoleCommand("sam", "setrankid", v.steamid, ranks:GetValue())
		end)
	end)

	dmenu:Open()
end

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/user.png", function(column_sheet)
	local refresh, pages
	local current_page, current_column, current_order, current_sort, keyword = nil, "steamid", "DESC", "id", nil

	local players_body = column_sheet:Add("Panel")
	players_body:Dock(FILL)
	players_body:DockMargin(0, 1, 0, 0)
	players_body:DockPadding(10, 10, 10, 10)

	local toggle_loading, is_loading = sam.menu.add_loading_panel(players_body)

	local title = players_body:Add("SAM.Label")
	title:Dock(TOP)
	title:SetFont(SAM_TAB_TITLE_FONT)
	title:SetText("Players")
	title:SetTextColor(GetColor("menu_tabs_title"))
	title:SizeToContents()

	local total = players_body:Add("SAM.Label")
	total:Dock(TOP)
	total:DockMargin(0, 6, 0, 0)
	total:SetFont(SAM_TAB_DESC_FONT)
	total:SetText("60 total players")
	total:SetTextColor(GetColor("menu_tabs_title"))
	total:SetPos(10, SUI.Scale(40))
	total:SizeToContents()

	local search_entry
	do
		local container = players_body:Add("SAM.Panel")
		container:Dock(TOP)
		container:DockMargin(0, 6, 10, 0)
		container:SetTall(30)

		local sort_by = container:Add("SAM.ComboBox")
		sort_by:Dock(RIGHT)
		sort_by:DockMargin(4, 0, 0, 0)
		sort_by:SetWide(106)
		sort_by:SetValue("Sort By (ID)")
		sort_by:AddChoice("ID")
		sort_by:AddChoice("Name")
		sort_by:AddChoice("Rank")
		sort_by:AddChoice("Play Time")

		function sort_by:OnSelect(_, value)
			value = value:lower():gsub(" ", "_")
			if current_sort ~= value then
				current_sort = value
				refresh()
			end
		end

		local sort_order = container:Add("SAM.ComboBox")
		sort_order:Dock(RIGHT)
		sort_order:SetWide(96)
		sort_order:SetValue("Desc")
		sort_order:AddChoice("Desc")
		sort_order:AddChoice("Asc")

		function sort_order:OnSelect(_, value)
			value = value:upper()
			if current_order ~= value then
				current_order = value
				refresh()
			end
		end

		local column = container:Add("SAM.ComboBox")
		column:Dock(RIGHT)
		column:DockMargin(0, 0, 4, 0)
		column:SetWide(140)

		column:SetValue("Search (SteamID)")
		column:AddChoice("SteamID")
		column:AddChoice("Name")
		column:AddChoice("Rank")

		function column:OnSelect(_, value)
			value = value:lower()
			if current_column ~= value then
				current_column = value
				refresh()
			end
		end

		search_entry = container:Add("SAM.TextEntry")
		search_entry:Dock(LEFT)
		search_entry:SetNoBar(true)
		search_entry:SetPlaceholder("Search...")
		search_entry:SetRadius(4)
		search_entry:SetWide(220)

		function search_entry:OnEnter(no_refresh)
			local value = self:GetValue()
			if keyword ~= value then
				keyword = value ~= "" and value or nil
				if not no_refresh then
					refresh()
				end
			end
		end
	end

	Line(players_body, nil, -5, SUI.Scale(15), -5, 0)

	do
		local columns = players_body:Add("Panel")
		columns:Dock(TOP)
		columns:DockMargin(0, 10, 0, 0)

		local info = columns:Add("SAM.Label")
		info:Dock(LEFT)
		info:DockMargin(4, 0, 0, 0)
		info:SetFont(COLUMN_FONT)
		info:SetText("Player")
		info:SetTextColor(GetColor("player_list_titles"))
		info:SetWide(SUI.Scale(280) + SUI.Scale(34))
		info:SizeToContentsY(3)

		local play_time = columns:Add("SAM.Label")
		play_time:Dock(LEFT)
		play_time:DockMargin(-4, 0, 0, 0)
		play_time:SetFont(COLUMN_FONT)
		play_time:SetText("Play Time")
		play_time:SetTextColor(GetColor("player_list_titles"))
		play_time:SetWide(SUI.Scale(180))
		play_time:SizeToContentsY(3)

		local rank_expiry = columns:Add("SAM.Label")
		rank_expiry:Dock(LEFT)
		rank_expiry:DockMargin(-4, 0, 0, 0)
		rank_expiry:SetFont(COLUMN_FONT)
		rank_expiry:SetText("Rank Expiry")
		rank_expiry:SetTextColor(GetColor("player_list_titles"))
		rank_expiry:SetWide(SUI.Scale(280))
		rank_expiry:SizeToContentsY(3)

		columns:SizeToChildren(false, true)
	end

	local body = players_body:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:DockMargin(0, 10, 0, 0)
	body:SetVBarPadding(6)

	local set_data = function(data)
		body:GetCanvas():Clear()
		body.VBar.Scroll = 0

		local players, players_count, current_page_2 = unpack(data)
		total:SetText(players_count .. " total players")

		pages = get_pages_count(players_count)
		current_page.i = pages == 0 and 0 or current_page_2 or current_page.i
		current_page:SetText(current_page.i .. "/" .. pages)

		body:Line()

		for k, v in ipairs(players) do
			local line = body:Add("SAM.PlayerLine")
			line:DockMargin(0, 0, 0, 10)

			local name = v.name ~= "" and v.name or nil
			line:SetInfo({
				steamid = v.steamid,
				name = name,
				rank = v.rank
			})

			local play_time = line:Add("SAM.Label")
			play_time:Dock(LEFT)
			play_time:DockMargin(4, 0, 0, 0)
			play_time:SetFont(LINE_FONT)
			play_time:SetText(sam.reverse_parse_length(tonumber(v.play_time) / 60))
			play_time:SetTextColor(GetColor("player_list_data"))
			play_time:SetContentAlignment(4)
			play_time:SetWide(SUI.Scale(180))

			local expiry_date = tonumber(v.expiry_date)
			local rank_expiry = line:Add("SAM.Label")
			rank_expiry:Dock(LEFT)
			rank_expiry:DockMargin(-3, 0, 0, 0)
			rank_expiry:SetFont(LINE_FONT)
			rank_expiry:SetText(expiry_date == 0 and "Never" or sam.reverse_parse_length((expiry_date - os.time()) / 60))
			rank_expiry:SetTextColor(GetColor("player_list_data"))
			rank_expiry:SetContentAlignment(4)
			rank_expiry:SizeToContents()

			local but = line:Actions()
			but.v = v
			but:On("DoClick", button_click)

			body:Line()
		end
	end

	refresh = function()
		if not is_loading() and LocalPlayer():HasPermission("manage_players") then
			search_entry:OnEnter(true)
			local refresh_query = netstream.async.Start("SAM.GetPlayers", toggle_loading, current_page.i, current_column, current_order, current_sort, keyword)
			refresh_query:done(set_data)
		end
	end

	local bottom_panel = players_body:Add("SAM.Panel")
	bottom_panel:Dock(BOTTOM)
	bottom_panel:DockMargin(0, 6, 0, 0)
	bottom_panel:SetTall(30)
	bottom_panel:Background(GetColor("page_switch_bg"))

	local previous_page = bottom_panel:Add("SAM.Button")
	previous_page:Dock(LEFT)
	previous_page:SetWide(30)
	previous_page:SetText("<")
	previous_page:SetFont(NEXT_FONT)

	previous_page:On("DoClick", function()
		if current_page.i <= 1 then return end

		current_page.i = current_page.i - 1
		refresh()
	end)

	current_page = bottom_panel:Add("SAM.Label")
	current_page:Dock(FILL)
	current_page:SetContentAlignment(5)
	current_page:SetFont(SAM_TAB_DESC_FONT)
	current_page:SetText("loading...")
	current_page.i = 1

	local next_page = bottom_panel:Add("SAM.Button")
	next_page:Dock(RIGHT)
	next_page:SetWide(30)
	next_page:SetText(">")
	next_page:SetFont(NEXT_FONT)

	next_page:On("DoClick", function()
		if current_page.i == pages then return end

		current_page.i = current_page.i + 1
		refresh()
	end)

	function bottom_panel:Think()
		next_page:SetEnabled(current_page.i ~= pages)
		previous_page:SetEnabled(current_page.i > 1)
	end

	do
		local refresh_2 = function()
			timer.Simple(1, refresh)
		end

		for k, v in ipairs({"SAM.AuthedPlayer", "SAM.ChangedPlayerRank", "SAM.ChangedSteamIDRank"}) do
			hook.Add(v, "SAM.MenuPlayers", refresh_2)
		end
	end

	refresh()

	return players_body
end, function()
	return LocalPlayer():HasPermission("manage_players")
end, 2)
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/ranks.lua:
if SAM_LOADED then return end
if SERVER then return end

local sam = sam
local SUI = sam.SUI

local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line
local AnimatedSetVisible = sui.TDLib.LibClasses.AnimatedSetVisible

local RANK_NAME = SUI.CreateFont("RankName", "Roboto Bold", 18)
local RANK_INFO = SUI.CreateFont("RankInfo", "Roboto Medium", 12)

local CREATE_RANK = SUI.CreateFont("CreateRank", "Roboto Bold", 16, 200)
local RANK_TITLE = SUI.CreateFont("RankTitle", "Roboto Bold", 20)

local rank_menu = function(rank, data)
	local valid = sui.valid_options()

	local imm, banlim
	if rank then
		imm, banlim = data.immunity, data.ban_limit
	end

	local edit_rank = vgui.Create("SAM.QueryBox")
	edit_rank:SetWide(470)
	edit_rank:SetTitle(rank and string.format("Edit Rank '%s'", rank) or "Create Rank")

	local new_name = rank
	if not sam.ranks.is_default_rank(rank) then
		local name = edit_rank:Add("SAM.LabelPanel")
		name:SetLabel("Rank Name")

		local entry = name:Add("SAM.TextEntry")
		entry:SetSize(210, 28)
		entry:SetNoBar(false)
		entry:SetPlaceholder("")
		entry:SetValue(rank or "")
		entry:SetCheck(function(_name)
			new_name = _name

			if _name == rank then return end
			if _name == "" or sam.ranks.is_rank(_name) then
				return false
			end
		end)

		valid.Add(entry)
	end

	local new_immunity = imm
	do
		local immunity = edit_rank:Add("SAM.LabelPanel")
		immunity:SetLabel("Immunity (2~99)")
		immunity:DockMargin(0, 5, 0, 0)

		local entry = immunity:Add("SAM.TextEntry")
		entry:SetSize(210, 28)
		entry:SetNumeric(true)
		entry:DisallowFloats(true)
		entry:DisallowNegative(true)
		entry:SetPlaceholder("")
		entry:SetValue(imm or "2")
		entry:SetCheck(function(_immunity)
			new_immunity = _immunity

			if _immunity == "" then
				return false
			end

			_immunity = tonumber(_immunity)
			new_immunity = _immunity
			if _immunity < 2 or _immunity > 99 then
				return false
			end
		end)

		valid.Add(entry)
	end

	local new_banlimit = banlim
	do
		local banlimit = edit_rank:Add("SAM.LabelPanel")
		banlimit:SetLabel("Ban Limit (1y 1mo 1w 1d 1h 1m)")
		banlimit:DockMargin(0, 5, 0, 0)

		local entry = banlimit:Add("SAM.TextEntry")
		entry:SetSize(210, 28)
		entry:SetNoBar(false)
		entry:SetPlaceholder("")
		entry:SetValue(banlim and sam.reverse_parse_length(banlim) or "2w")
		entry:SetCheck(function(_banlimit)
			new_banlimit = sam.parse_length(_banlimit)
			if not new_banlimit and _banlimit ~= banlim then
				return false
			end
		end)

		valid.Add(entry)
	end

	local inherit = rank and sam.ranks.get_rank(rank).inherit or "user"
	local new_inherit = inherit
	do
		local inherits_from = edit_rank:Add("SAM.LabelPanel")
		inherits_from:SetLabel("Inherits From")
		inherits_from:DockMargin(0, 5, 0, 0)

		local entry = inherits_from:Add("SAM.ComboBox")
		entry:SetSize(210, 28)
		entry:SetValue(inherit)

		for name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
			if name ~= rank and not sam.ranks.inherits_from(name, rank) then
				entry:AddChoice(name)
			end
		end

		function entry:OnSelect(_, value)
			new_inherit = value
		end
	end


	edit_rank:Done()
	edit_rank.save:SetEnabled(true)
	edit_rank.save:SetText("SAVE")

	if rank then
		edit_rank:SetCallback(function()
			local to_run = {}

			if new_immunity ~= imm then
				table.insert(to_run, {"changerankimmunity", rank, new_immunity})
			end

			if new_banlimit ~= banlim then
				table.insert(to_run, {"changerankbanlimit", rank, new_banlimit})
			end

			if new_inherit ~= inherit then
				table.insert(to_run, {"changeinherit", rank, new_inherit})
			end

			if new_name ~= rank then
				table.insert(to_run, {"renamerank", rank, new_name})
			end
			sam.command.run_commands(to_run)
		end)
	else
		edit_rank:SetCallback(function()
			RunConsoleCommand("sam", "addrank", new_name, new_inherit, new_immunity, new_banlimit)
		end)
	end

	function edit_rank.save:Think()
		self:SetEnabled(valid.IsValid())
	end
end

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/military_rank.png", function(column_sheet)
	local current_rank

	local parent = column_sheet:Add("Panel")
	parent:Dock(FILL)
	parent:DockMargin(0, 1, 0, 0)

	local title = parent:Add("SAM.Label")
	title:Dock(TOP)
	title:DockMargin(10, 10, 0, 0)
	title:SetFont(SAM_TAB_TITLE_FONT)
	title:SetText("Ranks")
	title:SetTextColor(GetColor("menu_tabs_title"))
	title:SizeToContents()

	local total = parent:Add("SAM.Label")
	total:Dock(TOP)
	total:DockMargin(10, 6, 0, 0)
	total:SetFont(SAM_TAB_DESC_FONT)
	total:SetText(table.Count(sam.ranks.get_ranks()) .. " total ranks")
	total:SetTextColor(GetColor("menu_tabs_title"))
	total:SizeToContents()

	local search_entry
	do
		local container = parent:Add("SAM.Panel")
		container:Dock(TOP)
		container:DockMargin(10, 6, 10, SUI.Scale(15))
		container:SetTall(30)

		search_entry = container:Add("SAM.TextEntry")
		search_entry:Dock(LEFT)
		search_entry:SetNoBar(true)
		search_entry:SetPlaceholder("Search...")
		search_entry:SetRadius(4)
		search_entry:SetWide(220)
	end

	local create_rank = parent:Add("SAM.Button")
	create_rank:SetFont(CREATE_RANK)
	create_rank:SetText("Create Rank")
	create_rank:Dock(BOTTOM)
	create_rank:DockMargin(10, 0, 10, 10)

	create_rank:On("DoClick", function()
		rank_menu()
	end)

	local right_body = parent:Add("Panel")
	right_body:Dock(RIGHT)
	right_body:DockMargin(0, 5, 10, 10)
	right_body:SetWide(0)
	right_body:SetZPos(-1)

	local rank_title = right_body:Add("SAM.Label")
	rank_title:Dock(TOP)
	rank_title:DockMargin(0, 0, 0, 5)
	rank_title:SetFont(RANK_TITLE)
	rank_title:SetTextColor(GetColor("menu_tabs_title"))

	local permissions_body = right_body:Add("SAM.CollapseCategory")
	permissions_body:Dock(FILL)
	permissions_body:GetCanvas():DockPadding(0, 0, 5, 0)

	local function refresh_access()
		if not IsValid(current_rank) then return end

		for k, v in ipairs(permissions_body.items) do
			AnimatedSetVisible(v.img, sam.ranks.has_permission(current_rank.name, v.name))
		end
	end

	for k, v in ipairs({"SAM.ChangedInheritRank", "SAM.RankPermissionGiven", "SAM.RankPermissionTaken"}) do
		hook.Add(v, "SAM.Menu.RefreshPermissions ", refresh_access)
	end

	local function refresh_permissions()
		permissions_body:GetCanvas():Clear()
		table.Empty(permissions_body.items)
		table.Empty(permissions_body.categories)

		local item_click = function(s)
			local rank = current_rank.name
			if not sam.ranks.has_permission(rank, s.name) then
				RunConsoleCommand("sam", "givepermission", rank, s.name)
			else
				RunConsoleCommand("sam", "takepermission", rank, s.name)
			end
		end

		for k, v in ipairs(sam.permissions.get()) do
			local item = permissions_body:add_item(v.name, v.category)
			item:SetContentAlignment(4)
			item:SetTextInset(6, 0)
			item:SizeToContentsY(SUI.Scale(10))
			item:SetZPos(k)
			item.name = v.name
			item.DoClick = item_click

			local img = item:Add("SAM.Image")
			img:Dock(RIGHT)
			img:DockMargin(4, 4, 4, 4)
			img:InvalidateParent(true)
			img:SetWide(img:GetTall())
			img:SetImageColor(Color(52, 161, 224))
			img:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/check_mark.png")

			item.img = img
		end
	end

	local limits_body

	do
		local permissions_search = right_body:Add("SAM.TextEntry")
		permissions_search:Dock(TOP)
		permissions_search:DockMargin(0, 0, 5, 10)
		permissions_search:SetNoBar(true)
		permissions_search:SetPlaceholder("Search...")
		permissions_search:SetRadius(4)
		permissions_search:SetTall(30)

		function permissions_search:OnValueChange(text)
			if limits_body and limits_body:IsVisible() then
				local children = limits_body:GetCanvas():GetChildren()
				for k, v in ipairs(children) do
					v:AnimatedSetVisible(v.title:find(text, nil, true) ~= nil)
				end
				limits_body:InvalidateLayout(true)
			else
				permissions_body:Search(text:lower())
			end
		end

		Line(right_body):SetZPos(2)
	end

	local function load_limits()
		if sam.limit_types then
			if limits_body then return end
		else
			if limits_body then
				limits_body:SetVisible(false)
				permissions_body:AnimatedSetVisible(true)
				limits_body:Remove()
				limits_body = nil
			end
			return
		end

		limits_body = right_body:Add("SAM.ScrollPanel")
		limits_body:Dock(FILL)
		limits_body:GetCanvas():DockPadding(0, 0, 5, 0)
		limits_body:SetVisible(false)

		local item_enter = function(s)
			if not IsValid(current_rank) then return end

			local rank = current_rank.name

			local limit = math.Clamp(s:GetValue(), -1, 1000)
			if limit ~= sam.ranks.get_limit(rank, s.limit_type) then
				RunConsoleCommand("sam", "changeranklimit", rank, s.limit_type, limit)
			else
				s:SetText(tostring(sam.ranks.get_limit(rank, s.limit_type)))
			end
		end

		local not_empty = function(s)
			return s and s ~= ""
		end

		local limit_values = {}
		for k, v in ipairs(sam.limit_types) do
			local immunity = limits_body:Add("SAM.LabelPanel")
			immunity:SetLabel(v)
			immunity:DockMargin(5, 0, 0, 5)

			local entry = immunity:Add("SAM.TextEntry")
			entry:SetSize(60, 26)
			entry:SetNumeric(true)
			entry:DisallowFloats(true)
			entry:SetPlaceholder("")
			entry:SetCheck(not_empty)
			entry.limit_type = v
			entry.OnEnter = item_enter

			table.insert(limit_values, entry)
		end

		function limits_body:Refresh()
			if not IsValid(current_rank) then return end

			local rank = current_rank.name
			for k, v in ipairs(limit_values) do
				v:SetValue(tostring(sam.ranks.get_limit(rank, v.limit_type)))
			end
		end

		local right_current_rank = right_body:Add("SAM.Button")
		right_current_rank:Dock(BOTTOM)
		right_current_rank:DockMargin(0, 5, 0, 0)
		right_current_rank:SetFont(CREATE_RANK)
		right_current_rank:SetText("Switch to Limits")
		right_current_rank:On("DoClick", function()
			limits_body:AnimatedToggleVisible()
			permissions_body:AnimatedToggleVisible()

			if permissions_body:AnimatedIsVisible() then
				right_current_rank:SetText("Switch to Limits")
			else
				right_current_rank:SetText("Switch to Permissions")
			end
		end)

		limits_body:On("OnRemove", function()
			right_current_rank:Remove()
		end)
		limits_body:Refresh()
	end

	local function refresh_all()
		timer.Create("SAM.Menu.Ranks.Refresh", 1, 1, function()
			load_limits()
			refresh_permissions()
			refresh_access()
		end)
	end

	sam.config.hook({"Restrictions.Limits"}, refresh_all)

	for k, v in ipairs({"SAM.AddedPermission", "SAM.PermissionModified", "SAM.RemovedPermission"}) do
		hook.Add(v, "SAM.Menu.RefreshPermissions", refresh_all)
	end

	local body = parent:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:DockMargin(10, 0, 5, 10)
	body:SetVBarPadding(6)

	body:Line():SetZPos(-101)

	local select_rank = function(s)
		if not IsValid(s) then
			current_rank = nil
			right_body:SizeTo(0, -1, 0.3)
			return
		end

		if IsValid(current_rank) then
			current_rank.Selected = false

			if current_rank == s then
				current_rank = nil
				right_body:SizeTo(0, -1, 0.3)
				return
			end
		end

		s.Selected = true
		current_rank = s
		refresh_access()
		if limits_body then
			limits_body:Refresh()
		end
		right_body:SizeTo(SUI.Scale(300), -1, 0.3)

		rank_title:SetText(s.name)
		rank_title:SizeToContents()
	end

	local ranks = {}

	function search_entry:OnValueChange()
		local value = self:GetValue()
		for k, v in pairs(ranks) do
			local show = k:find(value, nil, true)
			show = show ~= nil
			v.line:AnimatedSetVisible(show)
			v:GetParent():AnimatedSetVisible(show)
		end
	end

	local add_rank = function(rank_name, data)
		if rank_name == "superadmin" then return end
		if not IsValid(body) then return end

		local line = body:Add("SAM.Panel")
		line:Dock(TOP)
		line:DockMargin(0, 0, 0, 10)
		line:SetTall(34)
		line:SetZPos(-data.immunity)
		line:InvalidateLayout(true)

		local container = line:Add("SAM.Button")
		container:Dock(FILL)
		container:DockMargin(0, 0, 5, 0)
		container:DockPadding(5, 5, 0, 5)
		container:SetText("")
		container:SetContained(false)
		container.name = rank_name

		ranks[rank_name] = container

		container:On("DoClick", select_rank)

		function container:DoRightClick()
			rank_name = container.name

			if rank_name == "user" then return end

			local dmenu = vgui.Create("SAM.Menu")
			dmenu:SetSize(w, h)
			dmenu:SetInternal(container)

			dmenu:AddOption("Edit Rank", function()
				rank_menu(rank_name, sam.ranks.get_rank(rank_name))
			end)

			if not sam.ranks.is_default_rank(rank_name) then
				dmenu:AddSpacer()

				dmenu:AddOption("Remove Rank", function()
					local remove_rank = vgui.Create("SAM.QueryBox")
					remove_rank:SetWide(350)

					local check = remove_rank:Add("SAM.Label")
					check:SetText("Are you sure that you want to remove '" .. rank_name .. "'?")
					check:SetFont("SAMLine")
					check:SetWrap(true)
					check:SetAutoStretchVertical(true)

					remove_rank:Done()
					remove_rank.save:SetEnabled(true)
					remove_rank.save:SetText("REMOVE")
					remove_rank.save:SetContained(false)
					remove_rank.save:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))

					remove_rank.cancel:SetContained(true)
					remove_rank.cancel:SetColors()

					remove_rank:SetCallback(function()
						RunConsoleCommand("sam", "removerank", rank_name)
					end)
				end)
			end

			dmenu:Open()
			dmenu:SetPos(input.GetCursorPos())
		end

		do
			local name = container:Add("SAM.Label")
			name:Dock(TOP)
			name:DockMargin(0, 0, 0, 2)
			name:SetTextColor(GetColor("player_list_names"))
			name:SetFont(RANK_NAME)
			name:SetText(rank_name)
			name:SizeToContents()

			local immunity = container:Add("SAM.Label")
			immunity:Dock(TOP)
			immunity:SetTextColor(GetColor("player_list_steamid"))
			immunity:SetFont(RANK_INFO)
			immunity:SetText("Immunity: " .. data.immunity)
			immunity:SizeToContents()

			local banlimit = container:Add("SAM.Label")
			banlimit:Dock(TOP)
			banlimit:SetTextColor(GetColor("player_list_steamid"))
			banlimit:SetFont(RANK_INFO)
			banlimit:SetText("Ban limit: " .. sam.reverse_parse_length(sam.parse_length(data.ban_limit)))
			banlimit:SizeToContents()

			local inherit = container:Add("SAM.Label")
			inherit:Dock(TOP)
			inherit:SetTextColor(GetColor("player_list_steamid"))
			inherit:SetFont(RANK_INFO)
			inherit:SetText("Inherits from: " .. (sam.isstring(data.inherit) and data.inherit or "none"))
			inherit:SizeToContents()
		end

		container:InvalidateLayout(true)
		container:SizeToChildren(false, true)
		line:SizeToChildren(false, true)

		local _line = body:Line()
		_line:SetZPos(-data.immunity)

		container.line = _line
		container.data = data
	end

	for rank_name, v in pairs(sam.ranks.get_ranks()) do
		add_rank(rank_name, v)
	end

	hook.Add("SAM.AddedRank", "SAM.RefreshRanksList", function(name, rank)
		add_rank(name, rank)
	end)

	hook.Add("SAM.RemovedRank", "SAM.RefreshRanksList", function(name)
		local line = ranks[name]
		if not IsValid(line) then return end

		line.line:Remove()
		line:GetParent():Remove()
		ranks[name] = nil

		if line == current_rank then
			select_rank()
		end
	end)

	-- This is just better than caching panels for stuff that ain't gonna be called a lot
	hook.Add("SAM.RankNameChanged", "SAM.RefreshRanksList", function(name, new_name)
		local line = ranks[name]
		if not IsValid(line) then return end

		-- if current_rank == name then
		-- 	rank_name:SetText(new_name)
		-- end

		line:GetChildren()[1]:SetText(new_name)

		ranks[new_name], ranks[name] = line, nil
		line.name = new_name
	end)

	hook.Add("SAM.RankImmunityChanged", "SAM.RefreshRanksList", function(name, immunity)
		local line = ranks[name]
		if not IsValid(line) then return end

		line:GetChildren()[2]:SetText("Immunity: " .. immunity)
		line:GetParent():SetZPos(-immunity)

		-- SetZPos is kinda weird to deal with
		line.line:SetZPos(-immunity + 1)
		line.line:SetZPos(-immunity)
	end)

	hook.Add("SAM.RankBanLimitChanged", "SAM.RefreshRanksList", function(name, new_limit)
		local line = ranks[name]
		if IsValid(line) then
			line:GetChildren()[3]:SetText("Ban limit: " .. sam.reverse_parse_length(new_limit))
		end
	end)

	hook.Add("SAM.ChangedInheritRank", "SAM.RefreshRanksList", function(name, new_inherit)
		local line = ranks[name]
		if IsValid(line) then
			line:GetChildren()[4]:SetText("Inherits from: " .. new_inherit)
		end
	end)

	return parent
end, function()
	return LocalPlayer():HasPermission("manage_ranks")
end, 3)
--PATH addons/[admin] sam-160/lua/sam/modules/command_notify_for_ranks.lua:
--
-- Make command notifying only for ranks you select.
-- permission is command_notify. (by default admin+ has it)
-- You can NOT use this with 'command_hide_admin_name.lua'
--
if SAM_LOADED then return end

sam.permissions.add("command_notify", nil, "admin")

if SERVER then
	local get_players = function()
		local players = {}
		for _, v in ipairs(player.GetAll()) do
			if v:HasPermission("command_notify") then
				table.insert(players, v)
			end
		end
		return players
	end

	sam.player.old_send_message = sam.player.old_send_message or sam.player.send_message
	function sam.player.send_message(ply, msg, tbl)
		if ply == nil and debug.traceback():find("lua/sam/command/", 1, true) then
			sam.player.old_send_message(get_players(), msg, tbl)
		else
			sam.player.old_send_message(ply, msg, tbl)
		end
	end
end
--PATH addons/[admin] sam-160/lua/sam/modules/darkrp.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/sh_reserved_slots.lua:
--=--=
-- Permission is "reserved_slots". (By default admin+ has it.)
--=--=

if SAM_LOADED then return end

--
-- Amount of reserved slots
--
local reserved_slots = 6

--
-- Hide reserved slots?
-- Eg. your server has 32 slots, and reserved slots are 2 then the amount of slots the player
-- will see on the menu is 30 slots
--
local hide_reserved_slots = true

--
-- Kick a player with shortest session time if the server is full to free a slot for players with reserved slots access? (Won't kick players with reserved slots access.)
-- I really really really really don't recommend this option for your server.
--
local kick_if_full = true

--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=
--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=

-- Messages are appended with a "dot" by default.

--
-- What's the message that players with no access to reserved slots will get?
-- If "hide_reserved_slots" is set to true then the message will be "Server is full"
--
local reserved_message = "Left slots are reserved, sorry"

--
-- Only used when "kick_if_full" is set to "true"
-- What's the message that players will get when they kicked for freeing a slot?
--
local kick_message = "Freeing slot. Sorry, you had the shortest session time"

--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=
--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=
-- DO NOT TOUCH
--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=
--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=

local sam = sam

sam.permissions.add("reserved_slots", nil, "admin")

if CLIENT then return end

local max_slots = game.MaxPlayers()
if hide_reserved_slots then
	reserved_message = "Server is full"
	RunConsoleCommand("sv_visiblemaxplayers", max_slots - reserved_slots)
end

local has_reserved_access; do
	local cached_ranks; do
		local fn = hook.GetTable()["SAM.ChangedSteamIDRank"]["RemoveIfCached"]
		cached_ranks = select(2, debug.getupvalue(fn, 1))
	end

	local use_secondary_ranks = sam.player.set_secondary_rank and true or false

	local query
	if use_secondary_ranks then
		query = [[
			SELECT
				`sam_players`.`rank`,
				`sam_players_secondary`.`rank` AS `secondary_rank`
			FROM
				`sam_players`
			LEFT OUTER JOIN
				`sam_players_secondary`
			ON
				`sam_players`.`steamid` = `sam_players_secondary`.`steamid`
			WHERE
				`sam_players`.`steamid` = {1}
		]]
	else
		query = [[
			SELECT
				`rank`
			FROM
				`sam_players`
			WHERE
				`steamid` = {1}
		]]
	end

	local has_permission = sam.ranks.has_permission
	local internal_has_access = function(data, steamid, callback)
		local rank, secondary_rank = "user", "user"
		if data then
			rank, secondary_rank = data.rank, data.secondary_rank
			if rank == "NULL" then
				rank = "user"
			end
			if secondary_rank == "NULL" then
				secondary_rank = "user"
			end
		end

		cached_ranks[steamid] = data ~= nil and data or false

		return callback(has_permission(rank, "reserved_slots") or has_permission(secondary_rank, "reserved_slots"))
	end

	function has_reserved_access(steamid, callback)
		local cache = cached_ranks[steamid]
		if cache then
			return internal_has_access(cache, steamid, callback)
		elseif cache == false then
			return callback(has_permission("user", "reserved_slots"))
		end

		local has_access, msg = false, nil
		sam.SQL.FQuery(query, {steamid}, function(data)
			has_access, msg = internal_has_access(data, steamid, callback)
		end, true)

		return has_access, msg
	end
end

local math = math
local player = player

timer.Simple(0, function()
	local GM = GM or GAMEMODE

	GM.OldCheckPassword = GM.OldCheckPassword or GM.CheckPassword

	function GM:CheckPassword(steamid64, ...)
		if GM:OldCheckPassword(steamid64, ...) == false then
			return false
		end

		local use_kick = false

		local steamid = util.SteamIDFrom64(steamid64)
		local bool, msg = has_reserved_access(steamid, function(has_access)
			local left_slots = max_slots - player.GetCount()
			if left_slots == 0 then return end

			if not has_access and left_slots <= reserved_slots then
				if use_kick then
					sam.player.kick_id(steamid, reserved_message)
				end
				return false, reserved_message .. "."
			end

			if not kick_if_full then return end
			if left_slots - 1 > 0 then return end

			local chosen_player
			local shortest_time = math.huge

			local players = player.GetAll()
			for i = 1, #players do
				local ply = players[i]
				if not ply:HasPermission("reserved_slots") then
					local session_time = ply:sam_get_nwvar("is_authed") and ply:sam_get_session_time() or -1
					if session_time < shortest_time then
						chosen_player = ply
						shortest_time = session_time
					end
				end
			end

			if chosen_player then
				chosen_player:Kick(kick_message)
			end
		end)

		use_kick = true

		return bool, msg
	end
end)
--PATH addons/[admin] sam-160/lua/sam/modules/teleport.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Teleport")

local find_empty_pos -- https://github.com/FPtje/DarkRP/blob/b147d6fa32799136665a9fd52d35c2fe87cf7f78/gamemode/modules/base/sv_util.lua#L149
do
	local is_empty = function(vector, ignore)
		local point = util.PointContents(vector)
		local a = point ~= CONTENTS_SOLID
			and point ~= CONTENTS_MOVEABLE
			and point ~= CONTENTS_LADDER
			and point ~= CONTENTS_PLAYERCLIP
			and point ~= CONTENTS_MONSTERCLIP
		if not a then return false end

		local ents_found = ents.FindInSphere(vector, 35)
		for i = 1, #ents_found do
			local v = ents_found[i]
			if (v:IsNPC() or v:IsPlayer() or v:GetClass() == "prop_physics" or v.NotEmptyPos) and v ~= ignore then
				return false
			end
		end

		return true
	end

	local distance, step, area = 600, 30, Vector(16, 16, 64)
	local north_vec, east_vec, up_vec = Vector(0, 0, 0), Vector(0, 0, 0), Vector(0, 0, 0)

	find_empty_pos = function(pos, ignore)
		if is_empty(pos, ignore) and is_empty(pos + area, ignore) then
			return pos
		end

		for j = step, distance, step do
			for i = -1, 1, 2 do
				local k = j * i

				-- North/South
				north_vec.x = k
				if is_empty(pos + north_vec, ignore) and is_empty(pos + north_vec + area, ignore) then
					return pos + north_vec
				end

				-- East/West
				east_vec.y = k
				if is_empty(pos + east_vec, ignore) and is_empty(pos + east_vec + area, ignore) then
					return pos + east_vec
				end

				-- Up/Down
				up_vec.z = k
				if is_empty(pos + up_vec, ignore) and is_empty(pos + up_vec + area, ignore) then
					return pos + up_vec
				end
			end
		end

		return pos
	end
end

command.new("bring")
	:DisallowConsole()
	:SetPermission("bring", "admin")

	:AddArg("player", {cant_target_self = true})

	:Help("bring_help")

	:OnExecute(function(ply, targets)
		if not ply:Alive() then
			return ply:sam_send_message("dead")
		end

		if ply:InVehicle() then
			return ply:sam_send_message("leave_car")
		end

		if ply:sam_get_exclusive(ply) then
			return ply:sam_send_message(ply:sam_get_exclusive(ply))
		end

		local teleported = {admin = ply}
		local all = targets.input == "*"

		for i = 1, #targets do
			local target = targets[i]

			if target:sam_get_exclusive(ply) then
				if not all then
					ply:sam_send_message(target:sam_get_exclusive(ply))
				end
				continue
			end

			if not target:Alive() then
				target:Spawn()
			end

			target.sam_tele_pos, target.sam_tele_ang = target:GetPos(), target:EyeAngles()

			target:ExitVehicle()
			target:SetVelocity(Vector(0, 0, 0))
			target:SetPos(find_empty_pos(ply:GetPos(), target))
			target:SetEyeAngles((ply:EyePos() - target:EyePos()):Angle())

			table.insert(teleported, target)
		end

		if #teleported > 0 then
			sam.player.send_message(nil, "bring", {
				A = ply, T = teleported
			})
		end
	end)
:End()

command.new("goto")
	:DisallowConsole()
	:SetPermission("goto", "admin")

	:AddArg("player", {single_target = true, allow_higher_target = true, cant_target_self = true})

	:Help("goto_help")

	:OnExecute(function(ply, targets)
		if ply:sam_get_exclusive(ply) then
			return ply:sam_send_message(ply:sam_get_exclusive(ply))
		end

		if not ply:Alive() then
			ply:Spawn()
		end

		local target = targets[1]
		ply.sam_tele_pos, ply.sam_tele_ang = ply:GetPos(), ply:EyeAngles()

		ply:ExitVehicle()
		ply:SetVelocity(Vector(0, 0, 0))
		ply:SetPos(find_empty_pos(target:GetPos(), ply))
		ply:SetEyeAngles((target:EyePos() - ply:EyePos()):Angle())

		sam.player.send_message(nil, "goto", {
			A = ply, T = targets
		})
	end)
:End()

command.new("return")
	:SetPermission("return", "admin")

	:AddArg("player", {single_target = true, optional = true})

	:Help("return_help")

	:OnExecute(function(ply, targets)
		local target = targets[1]

		local last_pos, last_ang = target.sam_tele_pos, target.sam_tele_ang
		if not last_pos then
			return sam.player.send_message(ply, "no_location", {
				T = targets
			})
		end

		if target:sam_get_exclusive(ply) then
			return ply:sam_send_message(target:sam_get_exclusive(ply))
		end

		if not target:Alive() then
			return ply:sam_send_message(target:Name() .. " is dead!")
		end

		target:ExitVehicle()
		target:SetVelocity(Vector(0, 0, 0))
		target:SetPos(last_pos)
		target:SetEyeAngles(last_ang)

		target.sam_tele_pos, target.sam_tele_ang = nil, nil

		sam.player.send_message(nil, "returned", {
			A = ply, T = targets
		})
	end)
:End()
--PATH addons/[admin] sam-160/lua/sam/modules/user.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("User Management")

command.new("setrank")
	:Aliases("adduser", "changerank", "giverank")

	:SetPermission("setrank")

	:AddArg("player", {single_target = true})
	:AddArg("rank", {check = function(rank, ply)
		return ply:CanTargetRank(rank)
	end})
	:AddArg("length", {optional = true, default = 0})

	:Help("setrank_help")

	:OnExecute(function(ply, targets, rank, length)
		targets[1]:sam_set_rank(rank, length)

		sam.player.send_message(nil, "setrank", {
			A = ply, T = targets, V = rank, V_2 = sam.format_length(length)
		})
	end)
:End()

command.new("setrankid")
	:Aliases("adduserid", "changerankid", "giverankid")

	:SetPermission("setrankid")

	:AddArg("steamid")
	:AddArg("rank", {check = function(rank, ply)
		return ply:CanTargetRank(rank)
	end})
	:AddArg("length", {optional = true, default = 0})

	:Help("setrankid_help")

	:OnExecute(function(ply, promise, rank, length)
		local a_name = ply:Name()

		promise:done(function(data)
			local steamid, target = data[1], data[2]
			if target then
				target:sam_set_rank(rank, length)

				sam.player.send_message(nil, "setrank", {
					A = ply, T = {target, admin = ply}, V = rank, V_2 = sam.format_length(length)
				})
			else
				sam.player.set_rank_id(steamid, rank, length)

				sam.player.send_message(nil, "setrank", {
					A = a_name, T = steamid, V = rank, V_2 = sam.format_length(length)
				})
			end
		end)
	end)
:End()

command.new("addrank")
	:SetPermission("manage_ranks")

	:AddArg("text", {hint = "rank name", check = function(rank)
		return not sam.ranks.is_rank(rank)
	end})
	:AddArg("rank", {hint = "inherit from"})
	:AddArg("number", {hint = "immunity", min = 2, max = 99, optional = true})
	:AddArg("length", {hint = "ban limit", optional = true})

	:Help("addrank_help")

	:MenuHide()

	:OnExecute(function(ply, rank, inherit, immunity, ban_limit)
		sam.ranks.add_rank(rank, inherit, immunity, ban_limit)

		sam.player.send_message(nil, "addrank", {
			A = ply, V = rank
		})
	end)
:End()

command.new("removerank")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return not sam.ranks.is_default_rank(rank)
	end})

	:Help("removerank_help")

	:MenuHide()

	:OnExecute(function(ply, rank)
		sam.ranks.remove_rank(rank)

		sam.player.send_message(nil, "removerank", {
			A = ply, V = rank
		})
	end)
:End()

command.new("renamerank")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return not sam.ranks.is_default_rank(rank)
	end})
	:AddArg("text", {hint = "new name", check = function(rank)
		return not sam.ranks.is_rank(rank)
	end})

	:Help("renamerank_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_name)
		sam.ranks.rename_rank(rank, new_name)

		sam.player.send_message(nil, "renamerank", {
			A = ply, T = rank, V = new_name
		})
	end)
:End()

command.new("changeinherit")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "user" and rank ~= "superadmin"
	end})
	:AddArg("rank", {hint = "inherits from"})

	:Help("changeinherit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, inherit)
		if rank == inherit then return end

		sam.ranks.change_inherit(rank, inherit)

		sam.player.send_message(nil, "changeinherit", {
			A = ply, T = rank, V = inherit
		})
	end)
:End()

command.new("changerankimmunity")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "user" and rank ~= "superadmin"
	end})
	:AddArg("number", {hint = "new immunity", min = 2, max = 99})

	:Help("changerankimmunity_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_immunity)
		sam.ranks.change_immunity(rank, new_immunity)

		sam.player.send_message(nil, "rank_immunity", {
			A = ply, T = rank, V = new_immunity
		})
	end)
:End()

command.new("changerankbanlimit")
	:SetPermission("manage_ranks")

	:AddArg("rank", {check = function(rank)
		return rank ~= "superadmin"
	end})
	:AddArg("length")

	:Help("changerankbanlimit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, new_limit)
		sam.ranks.change_ban_limit(rank, new_limit)

		sam.player.send_message(nil, "rank_ban_limit", {
			A = ply, T = rank, V = sam.format_length(new_limit)
		})
	end)
:End()

command.new("givepermission")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "permission"})

	:Help("givepermission_help")

	:MenuHide()

	:OnExecute(function(ply, rank, permission)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.give_permission(rank, permission)

		sam.player.send_message(nil, "giveaccess", {
			A = ply, V = permission, T = rank
		})
	end)
:End()

command.new("takepermission")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "permission"})

	:Help("takepermission_help")

	:MenuHide()

	:OnExecute(function(ply, rank, permission)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.take_permission(rank, permission)

		sam.player.send_message(nil, "takeaccess", {
			A = ply, V = permission, T = rank
		})
	end)
:End()

command.new("changeranklimit")
	:SetPermission("manage_ranks")

	:AddArg("rank")
	:AddArg("text", {hint = "limit"})
	:AddArg("number", {hint = "value"})

	:Help("changeranklimit_help")

	:MenuHide()

	:OnExecute(function(ply, rank, limit, value)
		if rank == "superadmin" then
			return ply:sam_send_message("super_admin_access")
		end

		sam.ranks.set_limit(rank, limit, value)

		sam.player.send_message(nil, "changeranklimit", {
			A = ply, T = rank, V = limit, V_2 = value
		})
	end)
:End()
--PATH addons/[admin] sam-160/lua/sam/reports/cl_reports.lua:
if SAM_LOADED then return end

local sam = sam
local netstream = sam.netstream
local SUI = sam.SUI

local config = sam.config

local Trim = string.Trim

local muted_var = CreateClientConVar("sam_mute_reports", "0", false, false, "", 0, 1)

local position = config.get_updated("Reports.Position", "Left")
local max_reports = config.get_updated("Reports.MaxReports", 4)
local always_show = config.get_updated("Reports.AlwaysShow", true)
local pad_x = config.get_updated("Reports.XPadding", 5)
local pad_y = config.get_updated("Reports.YPadding", 5)

local duty_jobs = {}
config.hook({"Reports.DutyJobs"}, function()
	local jobs = config.get("Reports.DutyJobs", ""):Split(",")
	for i = #jobs, 1, -1 do
		local v = Trim(jobs[i])
		if v ~= "" then
			jobs[v] = true
		end
		jobs[i] = nil
	end
	duty_jobs = jobs
end)

local commands = {}
config.hook({"Reports.Commands"}, function()
	local cmds = config.get("Reports.Commands", ""):Split(",")
	for i = 1, #cmds do
		local v = Trim(cmds[i])
		if v ~= "" then
			cmds[i] = {
				name = v,
				func = function(_, ply)
					if IsValid(ply) then
						RunConsoleCommand("sam", v, "#" .. ply:EntIndex())
					end
				end
			}
		end
	end
	commands = cmds
end)

local reports = {}
local queued_reports = {}

local new_report, remove_report, check_queued, get_report, append_report

get_report = function(ply, index)
	for i = 1, #reports do
		local v = reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v end
	end

	for i = 1, #queued_reports do
		local v = queued_reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v, i end
	end
end

remove_report = function(ply)
	local report, delayed_i = get_report(ply)

	if delayed_i then
		return table.remove(queued_reports, delayed_i)
	end

	local panel = report.panel
	panel:MoveToNewX(position.value == "Right" and ScrW() or -panel:GetWide(), function()
		for i = report.pos + 1, #reports do
			local v = reports[i]
			v.pos = v.pos - 1
			v.panel:MoveToNewY(v.panel:GetY())
		end

		panel:Remove()
		table.remove(reports, report.pos)

		check_queued()
	end)
end

check_queued = function()
	while (max_reports.value - #reports > 0 and #queued_reports > 0) do
		new_report(table.remove(queued_reports, 1))
	end
end

append_report = function(ply, text)
	local report, delayed = get_report(ply)
	if delayed then
		table.insert(report.comments, text)
	else
		report.panel:AddComment(text)
	end
end

new_report = function(report)
	if #reports >= max_reports.value then
		return table.insert(queued_reports, report)
	end

	report.pos = table.insert(reports, report)

	local panel = vgui.Create("SAM.Report")
	panel:SetReport(report)

	for k, v in ipairs(commands) do
		panel:AddButton(v.name:gsub("^%l", string.upper), v.func)
	end

	local claim = panel:AddButton("Claim", function(self, ply)
		if panel:HasReport() then
			return LocalPlayer():sam_send_message("You have an active case, close it first.")
		end

		self.DoClick = function()
		end

		local claim_query = netstream.async.Start("ClaimReport", nil, ply)
		claim_query:done(function(claimed)
			if not IsValid(panel) then return end

			if claimed then
				panel:SetHasReport(ply)

				self:SetText("Close")

				self.background = Color(231, 76, 60, 200)
				self.hover = Color(255, 255, 255, 25)

				panel:FixWide()

				for k, v in ipairs(panel:GetChildren()[3]:GetChildren()) do
					v:SetDisabled(false)
					v:SetCursor("hand")
				end

				self.DoClick = function()
					panel:Close()
				end
			else
				panel:SetClaimed()
			end
		end)
	end)

	panel.claim = claim

	claim:SetCursor("hand")
	claim:SetDisabled(false)

	claim.background = Color(39, 174, 96, 200)
	claim.hover = Color(255, 255, 255, 25)

	panel:FixWide()

	local x = pad_x.value
	if position.value == "Right" then
		x = (ScrW() - panel:GetWide()) - x
	end

	panel:MoveToNewX(x)
	panel:MoveToNewY(panel:GetY())

	panel.new = true
	for k, v in ipairs(report.comments) do
		panel:AddComment(v)
	end
	panel.new = nil
end

netstream.Hook("Report", function(ply, comment)
	if not IsValid(ply) then return end

	if muted_var:GetBool() then return end

	local report = get_report(ply)
	if not report then
		report = {
			ply = ply,
			index = ply:EntIndex(),
			comments = {comment}
		}

		if not always_show.value and not duty_jobs[team.GetName(LocalPlayer():Team())] then
			LocalPlayer():sam_send_message("({S Blue}) {S_2 Red}: {S_3}", {
				S = "Report", S_2 = ply:Name(), S_3 = comment
			})
		else
			new_report(report)
		end
	else
		append_report(ply, comment)
	end
end)

netstream.Hook("ReportClaimed", function(ply)
	local report, delayed = get_report(ply)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClaimed()
	end
end)

netstream.Hook("ReportClosed", function(index)
	local report, delayed = get_report(index, true)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClosed()
	end
end)

do
	local REPORTS_HEADER = SUI.CreateFont("ReportHeader", "Roboto", 14, 540)
	local REPORT_COMMENT = SUI.CreateFont("ReportComment", "Roboto", 13, 540)
	local REPORT_BUTTONS = SUI.CreateFont("ReportButtons", "Roboto", 13, 550)

	local Panel = {}

	function Panel:Init()
		sui.TDLib.Start()

		self:Blur()
			:Background(Color(30, 30, 30, 240))

		local p_w, p_h = SUI.Scale(300), SUI.Scale(125)
		self:SetSize(p_w, p_h)

		local x = p_w * 2

		if position.value == "Right" then
			x = ScrW() + x
		else
			x = -x
		end

		self:SetPos(x, -p_h)

		local top_panel = self:Add("Panel")
		top_panel:Dock(TOP)
		top_panel:SetTall(SUI.Scale(24))
		top_panel:Background(Color(60, 60, 60, 200))

		local ply_name = top_panel:Add("DLabel")
		ply_name:Dock(LEFT)
		ply_name:DockMargin(5, 0, 0, 0)
		ply_name:SetTextColor(Color(200, 200, 200))
		ply_name:SetFont(REPORTS_HEADER)
		self.ply_name = ply_name

		local scroll = self:Add("SAM.ScrollPanel")
		scroll:Dock(FILL)
		scroll:DockMargin(5, 5, 5, 5)
		scroll.Paint = nil
		self.scroll = scroll

		local comment = scroll:Add("DLabel")
		comment:Dock(TOP)
		comment:SetText("")
		comment:SetTextColor(Color(200, 200, 200))
		comment:SetFont(REPORT_COMMENT)
		comment:SetMultiline(true)
		comment:SetWrap(true)
		comment:SetAutoStretchVertical(true)
		self.comment = comment

		local bottom = self:Add("Panel")
		bottom:Dock(BOTTOM)
		bottom:SetTall(SUI.Scale(24))
		self.bottom = bottom

		sui.TDLib.End()
	end

	function Panel:GetY()
		return (self:GetTall() + 5) * (self.report.pos - 1) + pad_y.value
	end

	function Panel:Close()
		remove_report(self.report.ply)
	end

	local change_state = function(self, text)
		self.claim:SetText(text)
		self.claim.DoClick = function() end

		self.claim:SUI_TDLib()
			:Background(Color(41, 128, 185, 200))

		timer.Simple(5, function()
			if IsValid(self) then
				self:Close()
			end
		end)

		if self:HasReport() == self.report.ply then
			self:SetHasReport()
		end

		self:FixWide()
	end

	function Panel:SetClaimed()
		change_state(self, "Case clamied!")
	end

	function Panel:SetClosed()
		change_state(self, "Case closed!")
	end

	function Panel:SetReport(report)
		surface.PlaySound("garrysmod/balloon_pop_cute.wav")

		report.panel = self

		self.report = report
		self.ply_name:SetText(report.ply:Name())
		self.ply_name:SetWide(self:GetWide())
	end

	local disabled = Color(60, 60, 60, 200)
	local click = Color(255, 255, 255, 30)
	local button_paint = function(self, w, h)
		draw.RoundedBox(0, 0, 0, w, h, self.background)

		if self:GetDisabled() then
			draw.RoundedBox(0, 0, 0, w, h, disabled)
		else
			if self:IsHovered() then
				draw.RoundedBox(0, 0, 0, w, h, self.hover)
			end

			if self.Depressed then
				draw.RoundedBox(0, 0, 0, w, h, click)
			end
		end
	end

	local button_click = function(self)
		self.cb(self, self.report.ply)
	end

	local background = Color(60, 60, 60, 200)
	local hover = Color(14, 134, 204, 100)
	function Panel:AddButton(text, cb)
		local button = self.bottom:Add("DButton")
		button:Dock(LEFT)
		button:SetText(text)
		button:SetTextColor(Color(200, 200, 200))
		button:SetFont(REPORT_BUTTONS)
		button:SetDisabled(true)
		button:SetCursor("arrow")

		button.Paint = button_paint
		button.DoClick = button_click

		button.background = background
		button.hover = hover

		button.cb = cb
		button.report = self.report

		return button
	end

	function Panel:FixWide()
		local wide = 0

		for _, v in ipairs(self.bottom:GetChildren()) do
			v:SizeToContents()
			v:SetWide(v:GetWide() + 6)
			wide = wide + v:GetWide()
		end

		self:SetWide(wide)

		return wide
	end

	function Panel:OnRemove()
		local reporter = self:HasReport()
		if reporter then
			netstream.Start("CloseReport", reporter)
			self:SetHasReport()
		end
	end

	function Panel:AddComment(text)
		local comment = self.comment

		local old_text = comment:GetText()
		if old_text ~= "" then
			old_text = old_text .. "\n"
		end

		if not self.new then
			surface.PlaySound("ambient/water/drip4.wav")
		end

		comment:SetText(old_text .. "- " .. text)
		comment:SizeToContents()

		self.scroll:ScrollToBottom()
	end

	function Panel:HasReport()
		return LocalPlayer().sam_has_report
	end

	function Panel:SetHasReport(v)
		LocalPlayer().sam_has_report = v
	end

	local new_animation = function(panel, name)
		local new_name = "anim_" .. name
		panel["MoveToNew" .. name:upper()] = function(self, new, cb)
			if self[new_name] then
				table.RemoveByValue(self.m_AnimList, self[new_name])
			end

			self[new_name] = self:NewAnimation(0.2, 0, -1, function()
				self[new_name] = nil
				if cb then cb() end
			end)

			self[new_name].Think = function(_, _, frac)
				self[name] = Lerp(frac, self[name], new)
			end
		end
	end

	new_animation(Panel, "x")
	new_animation(Panel, "y")

	vgui.Register("SAM.Report", Panel, "EditablePanel")
end
--PATH addons/[lib] sui/lua/sui/vgui/sui_panel.lua:
local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
end

sui.register("Panel", PANEL, "Panel")
--PATH addons/[lib] sui/lua/sui/vgui/sui_property_sheet.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_zbutton.lua:
local draw = draw
local render = render

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local BUTTON_FONT = SUI.CreateFont("Button", "Roboto Medium", 16)

local color_white = color_white
local color_transparent = Color(0, 0, 0, 0)

local PANEL = {}

AccessorFunc(PANEL, "m_Background", "Background")
AccessorFunc(PANEL, "m_bContained", "Contained", FORCE_BOOL)

sui.TDLib.Install(PANEL)
sui.scaling_functions(PANEL)

PANEL:ClearPaint()
PANEL:SetContained(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local IsMouseInputEnabled = Panel.IsMouseInputEnabled
local SetCursor = Panel.SetCursor
local SetContentAlignment = Panel.SetContentAlignment
function PANEL:Init()
	self:ScaleInit()

	self.vertices, self.vertices_2 = {}, {}

	SetMouseInputEnabled(self, true)
	SetCursor(self, "hand")
	SetContentAlignment(self, 5)

	self:SetSize(90, 30)
	self:SetFont(BUTTON_FONT)

	self:CircleClick(nil, 7)

	self.OldPaint, self.Paint = self.Paint, self.Paint2

	self.cur_col = Color(0, 0, 0, 0)
end

function PANEL:SetEnabled(b)
	SetMouseInputEnabled(self, b)
end

function PANEL:IsEnabled()
	return IsMouseInputEnabled(self)
end

function PANEL:ContainedPaint(w, h)
	local enabled = self:IsEnabled()
	local col
	if enabled then
		col = self:GetBackground() or SUI.GetColor("button")
		self:SetTextColor(SUI.GetColor("button_text"))
	else
		col = SUI.GetColor("button_disabled")
		self:SetTextColor(SUI.GetColor("button_disabled_text"))
	end
	self:RoundedBox("Background", 4, 0, 0, w, h, col)

	if not enabled then return end

	self.circle_click_color = SUI.GetColor("button_click")

	if self.Hovered or self.Selected then
		self:RoundedBox("Hover", 4, 0, 0, w, h, SUI.GetColor("button_hover"))
	end
end

function PANEL:SetColors(hover_color, text_color)
	self.hover = hover_color
	self.text_color = text_color
end

function PANEL:Paint2(w, h)
	if self:GetContained() then
		self:ContainedPaint(w, h)
		self:OldPaint(w, h)
		return
	end

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_ZERO)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(1)

	TDLib.RoundedBox(self.vertices, 4, 0, 0, w, h, color_white)

	render.SetStencilFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(1)

	local cur_col = self.cur_col
	if self.Selected then
		lerp_color(cur_col, SUI.GetColor("button2_selected"))
	elseif self.Hovered then
		lerp_color(cur_col, self.hover or SUI.GetColor("button2_hover"))
	else
		lerp_color(cur_col, color_transparent)
	end

	TDLib.RoundedBox(self.vertices_2, 4, 0, 0, w, h, cur_col)

	if self.text_color then
		self.circle_click_color = self.text_color
		self:SetTextColor(self.text_color)
	else
		local col = contrast_color(cur_col)
		self.circle_click_color = col
		self:SetTextColor(col)
	end

	self:OldPaint(w, h)

	render.SetStencilEnable(false)
	render.ClearStencil()
end

sui.register("Button", PANEL, NAME .. ".Label")
--PATH addons/[chat] scb-29/lua/scb/cl_util.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/settings/tabs/emojis.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/cl_overrides.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/scb/vgui/scb_emojis.lua:
if SCB_LOADED then return end

local draw = draw
local IsValid = IsValid
local math = math
local pairs = pairs
local table = table
local SortedPairsByMemberValue = SortedPairsByMemberValue
local timer = timer

local scb = scb
local sui = sui
local SUI = scb.SUI
local language = scb.language

local Panel = {}

local flag = "flag_" .. (system.GetCountry() or ""):lower()
local categories = {
	People = {1, "grinning"},
	Nature = {2, "cat"},
	Food = {3, "watermelon"},
	Activities = {4, "person_in_lotus_position"},
	Travel = {5, "desert_island"},
	Objects = {6, "coffee"},
	Symbols = {7, "question"},
	Flags = {8, scb.emojis[flag] and flag or "flag_eg"},
	Custom = {9, "unlock"}
}

local generate_emojis = function()
	for k, v in pairs(categories) do
		local key = tostring(v[1])
		local emojis = {}

		local i, max_pos = 1, -math.huge
		for name, cat in pairs(scb.emojis) do
			local pos = i
			if not scb.is_custom_emoji(cat) then
				cat, pos = cat:sub(1, 1), tonumber(cat:sub(2))
			end

			if cat ~= key and (k ~= "Custom" or not scb.is_custom_emoji(cat)) then continue end

			emojis[pos] = name
			max_pos = math.max(max_pos, pos)

			i = i + 1
		end

		v[3] = emojis
		v[4] = max_pos
	end
end
generate_emojis()
hook.Add("SCB.EmojisModified", "FixEmojis", generate_emojis)

local DoClick = function(s)
	local text_entry = scb.chatbox.text_entry
	text_entry:RequestFocus()
	text_entry:AddValue(":" .. s.name .. ": ")

	s.parent:Remove()
end

local hovered_color = Color(50, 50, 50, 150)
local emoji_Paint = function(s, w, h)
	if s.parent.selected == s then
		s.search_field:SetPlaceholder(":" .. s.name .. ":")
		draw.RoundedBox(0, 0, 0, w, h, hovered_color)
	end
end

local emoji_OnCursorEntered = function(s, w, h)
	s.parent.selected = s
end

local category_list_Paint = function(_, w, h)
	draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
end

local make_category_list = function(parent, columns)
	local category_list = parent:Add("SCB.ThreeGrid")
	category_list:Dock(FILL)
	category_list:DockMargin(2, 0, 2, 2)
	category_list:GetCanvas():DockPadding(2, 2, 2, 2)
	category_list:InvalidateParent(true)
	category_list:SetWide2(category_list:GetWide() - (SUI.Scale(4) * 2))
	category_list:InvalidateParent(true)

	category_list:SetColumns(columns)
	category_list:SetHorizontalMargin(4)

	category_list.Paint = category_list_Paint

	return category_list
end

local add_emoji = function(self, emoji, category_list, search_field)
	if not IsValid(category_list) then return end

	local emoji_size = SUI.ScaleEven(28)

	local pnl = vgui.Create("DButton")
	pnl:SetTall(emoji_size)
	category_list:AddCell(pnl)

	pnl:SetSize(emoji_size, emoji_size)
	pnl:SetText("")
	pnl:SetTooltip(emoji)

	pnl.parent = self
	pnl.name = emoji
	pnl.search_field = search_field
	pnl.Paint = emoji_Paint
	pnl.OnCursorEntered = emoji_OnCursorEntered
	pnl.DoClick = DoClick

	local img = pnl:Add("SCB.Image")
	img:Dock(FILL)
	img:DockMargin(3, 3, 3, 3)
	img:SetMouseInputEnabled(false)

	local info = scb.emojis[emoji]
	img:SetImage(scb.is_custom_emoji(info) and info or ("scb/emojis/" .. emoji .. ".png"))
end

function Panel:Init()
	local has_permission = scb.has_permission(LocalPlayer(), "custom_emojis")
	local categories_n = table.Count(categories) - (has_permission and 0 or 1)

	self.tabs_tall = 30
	self.tab_scroller:SetTall(SUI.Scale(self.tabs_tall))

	self:SetFont(SCB_14)

	self.w = self.tab_scroller:GetTall() * categories_n
	self.h = self.w + 10

	self:InvalidateLayout(true)

	self.tab_scroller:Dock(BOTTOM)

	local emoji_size = SUI.ScaleEven(28)
	local columns = math.floor(self.w / emoji_size) - 1

	local search_field = self:Add("SCB.TextEntry")
	search_field:Dock(TOP)
	search_field:DockMargin(2, 2, 2, 2)
	search_field:SetPlaceholder(language.search)
	search_field:SetMouseInputEnabled(true)
	search_field:SetNoBar(true)

	local old_Paint = search_field.Paint
	function search_field:Paint(w, h)
		local outline = SUI.GetColor("scroll_panel_outline")
		if outline then
			sui.TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
		else
			draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
		end

		old_Paint(self, w, h)
	end

	function search_field.OnValueChange(s, value)
		if value == "" then
			if IsValid(s.search_body) then
				s.search_body:Remove()
			end
			self:SetActiveTab(self.tabs[1])
			search_field:SetPlaceholder(language.search)
			return
		end

		value = value:gsub(":", ""):lower()

		local search_body = s.search_body
		if not IsValid(search_body) then
			self:SetActiveTab(nil)

			search_body = self:Add("Panel")
			s.search_body = search_body
		end

		search_body:Dock(FILL)
		search_body:InvalidateParent(true)
		search_body:Clear()

		local category_list = make_category_list(search_body, columns)

		local main_i = 0
		for k, v in SortedPairsByMemberValue(categories, 1) do
			local emojis, n = v[3], v[4]
			for i = 1, n do
				local emoji = emojis[i]
				if not emoji then continue end
				if not emoji:find(value) then continue end

				timer.Simple(main_i * 0.004, function()
					add_emoji(self, emoji, category_list, search_field)
				end)

				main_i = main_i + 1
			end
		end
	end

	function self.tab_scroller:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, SUI.GetColor("header"))
	end

	for k, v in SortedPairsByMemberValue(categories, 1) do
		if k == "Custom" and not has_permission then continue end

		self:AddSheet(SUI.Material("scb/emojis/" .. v[2] .. ".png"), function(parent)
			local category_list = make_category_list(parent, columns)

			local emojis, n = v[3], v[4]
			for i = 1, n do
				local emoji = emojis[i]
				if not emoji then continue end

				timer.Simple(i * 0.004, function()
					add_emoji(self, emoji, category_list, search_field)
				end)
			end

			return category_list
		end):SetTooltip(k)
	end

	self:MakePopup()
	self:ParentToHUD()

	search_field:RequestFocus()

	hook.Add("VGUIMousePressed", self, function(_, panel, mouse_code)
		if self == panel then return end
		if self:IsOurChild(panel) then return end
		if mouse_code ~= MOUSE_LEFT then return end
		if panel == self.button then return end
		if panel == scb.chatbox.header then return end

		self:Remove()
	end)
end

function Panel:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		sui.TDLib.BlurPanel(self)
	end

	draw.RoundedBox(0, 0, 0, w, h, SUI.GetColor("frame"))
end

function Panel:OnKeyCodePressed(key_code)
	if key_code == KEY_ENTER and IsValid(self.selected) then
		self.selected:DoClick()
	end
end

local anim_speed = 0.2
function Panel:FixPos()
	local w, h = self.w, self.h

	self:SetSize(s, w * 1.1, h * 1.1)
	self:SetPos(self:_GetPos())
	self:SetAlpha(0)

	self:SizeTo(w, h, anim_speed, 0, -1)
	local x, y = self:_GetPos(w, h)
	self:MoveTo(x, y, anim_speed, 0, -1)
	self:AlphaTo(255, anim_speed + 0.02, 0, function()
		self.Think = self._Think
	end)
end

function Panel:_GetPos(m_w, m_h)
	local button = self.button

	if not m_w then
		m_w, m_h = self:GetSize()
	end

	local x, y, w = button:GetBounds()
	x, y = button:LocalToScreen(0, 0)
	x = x - (m_w / 2 - w / 2)
	y = y - m_h - 4

	return x, y
end

function Panel:_Think()
	self:SetPos(self:_GetPos())
	self:MoveToFront()
end

sui.register("EmojiList", Panel, "SCB.PropertySheet")
--PATH lua/autorun/sck_bone_fix.lua:

if SERVER then util.AddNetworkString("sckbonefix_reset_bones") end

local function resetViewBones(ply, vm)
	local vm = vm or ply:GetViewModel()
	if !IsValid(vm) then return end
	
	if SERVER then 
		net.Start("sckbonefix_reset_bones")
		net.Send(ply)
		return
	end
	
	if (!vm:GetBoneCount()) then return end
	for i=0, vm:GetBoneCount() do
		vm:ManipulateBoneScale(i, Vector(1, 1, 1))
		vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
		vm:ManipulateBonePosition(i, Vector(0, 0, 0))
	end
end

hook.Add("Initialize", "sckbonefix_setup", function()
	local player_table = FindMetaTable("Player")
	player_table.ResetViewBones = resetViewBones
end)


if CLIENT then
	net.Receive("sckbonefix_reset_bones", function()
		local p = LocalPlayer()
		if p.ResetViewBones then
			LocalPlayer():ResetViewBones()
		end
	end)
	
	return
end

hook.Add("PlayerSwitchWeapon", "sckbonefix_wepswitch", function(ply)
	ply:ResetViewBones()
end)

hook.Add("PlayerSpawn", "sckbonefix_plyspawn", function(ply)
	timer.Simple(0.1, function()
		if !IsValid(ply) or ply.ResetViewBones == nil then return end
		
		ply:ResetViewBones()
	end)
end)

--PATH lua/arc9/common/localization/content_base_en.lua:
L = {}

//////// Folders
L["folder.arc9"] = "ARC9"
L["folder.arc9.community"] = "Community"

L["attachment.sticker"] = "Sticker"

//////// Flat Camo
L["camo_arc9_base_flat_od.printname"] = "Olive Drab"
L["camo_arc9_base_flat_od.compactname"] = "OD"
L["camo_arc9_base_flat_od.description"] = "Standard Olive Drab camouflage."

L["camo_arc9_base_flat_deserttan.printname"] = "Desert Tan"
L["camo_arc9_base_flat_deserttan.compactname"] = "Tan"
L["camo_arc9_base_flat_deserttan.description"] = "Standard Desert Tan camouflage."

L["camo_arc9_base_flat_arctic.printname"] = "Arctic White"
L["camo_arc9_base_flat_arctic.compactname"] = "Arctic"
L["camo_arc9_base_flat_arctic.description"] = "Standard Arctic White camouflage."

L["camo_arc9_base_flat_black.printname"] = "Factory Black"
L["camo_arc9_base_flat_black.compactname"] = "Black"
L["camo_arc9_base_flat_black.description"] = "Standard Factory Issue Black."

L["camo_arc9_base_flat_urbangray.printname"] = "Urban Gray"
L["camo_arc9_base_flat_urbangray.compactname"] = "Urban"
L["camo_arc9_base_flat_urbangray.description"] = "Standard Urban Gray camouflage."

L["camo_arc9_base_flat_forestgreen.printname"] = "Forest Green"
L["camo_arc9_base_flat_forestgreen.compactname"] = "Forest"
L["camo_arc9_base_flat_forestgreen.description"] = "Standard Forest Green camouflage."

L["camo_arc9_base_flat_navy.printname"] = "Navy Blue"
L["camo_arc9_base_flat_navy.compactname"] = "Navy"
L["camo_arc9_base_flat_navy.description"] = "Standard Navy Blue color."

L["camo_arc9_base_flat_mountbattenpink.printname"] = "Mountbatten Pink"
L["camo_arc9_base_flat_mountbattenpink.compactname"] = "MP"
L["camo_arc9_base_flat_mountbattenpink.description"] = "Standard Mountbatten Pink camouflage.\nShockingly effective in desert conditions."

L["camo_arc9_base_flat_fde.printname"] = "Flat Dark Earth"
L["camo_arc9_base_flat_fde.compactname"] = "FDE"
L["camo_arc9_base_flat_fde.description"] = "Standard Flat Dark Earth camouflage."

//////// Flat Colour
L["camo_arc9_base_flat_red.printname"] = "Red"
L["camo_arc9_base_flat_red.compactname"] = "Red"
L["camo_arc9_base_flat_red.description"] = "Basic red color."

L["camo_arc9_base_flat_orange.printname"] = "Orange"
L["camo_arc9_base_flat_orange.compactname"] = "Orange"
L["camo_arc9_base_flat_orange.description"] = "Basic orange color."

L["camo_arc9_base_flat_yellow.printname"] = "Yellow"
L["camo_arc9_base_flat_yellow.compactname"] = "Yellow"
L["camo_arc9_base_flat_yellow.description"] = "Basic yellow color."

L["camo_arc9_base_flat_green.printname"] = "Green"
L["camo_arc9_base_flat_green.compactname"] = "Green"
L["camo_arc9_base_flat_green.description"] = "Basic green color."

L["camo_arc9_base_flat_blue.printname"] = "Blue"
L["camo_arc9_base_flat_blue.compactname"] = "Blue"
L["camo_arc9_base_flat_blue.description"] = "Basic blue color."

L["camo_arc9_base_flat_purple.printname"] = "Purple"
L["camo_arc9_base_flat_purple.compactname"] = "Purple"
L["camo_arc9_base_flat_purple.description"] = "Basic purple color."

L["camo_arc9_base_flat_pink.printname"] = "Pink"
L["camo_arc9_base_flat_pink.compactname"] = "Pink"
L["camo_arc9_base_flat_pink.description"] = "Eye searingly bright pink color."

L["camo_arc9_base_flat_arc9orange.printname"] = "ARC9 Orange"
L["camo_arc9_base_flat_arc9orange.compactname"] = "ARC9 Orange"
L["camo_arc9_base_flat_arc9orange.description"] = "The perfect shade of orange for that cute little ARC9 Logo sticker."

//////// Charms
L["charm_gs_killcounter.printname"] = "Kill Counter"
L["charm_gs_killcounter.compactname"] = "KILL"
L["charm_gs_killcounter.description"] = "Device for tracking your weapon's kill stats."

L["charm_gs_clock.printname"] = "Basic Clock"
L["charm_gs_clock.compactname"] = "CLOCK"
L["charm_gs_clock.description"] = "Device that displays the real-world time."

L["charm_gs_sticker.printname"] = "Sticker Panel"
L["charm_gs_sticker.compactname"] = "STICKER"
L["charm_gs_sticker.description"] = "Device that allows a custom sticker to be applied onto its screen."

//////// Stickers, Base
L["sticker_spray.printname"] = "Player Spray"
L["sticker_spray.compactname"] = "Spray"
L["sticker_spray.description"] = [[Your own spray as a sticker!
You will only be able to see your own and not ones from other players.

Sticker included in the ARC9 Base.]]

L["sticker_arc9.printname"] = "ARC9 Logo (Low Vis.)"
L["sticker_arc9.compactname"] = "ARC9"
L["sticker_arc9.description"] = [[Dark version of the ARC9 logo.
Design by The Villain.

Sticker included in the ARC9 Base.]]

L["sticker_arc9_lowvis.printname"] = "ARC9 Logo"
L["sticker_arc9_lowvis.compactname"] = "ARC9"
L["sticker_arc9_lowvis.description"] = [[Here's to you.
Design by The Villain.

Sticker included in the ARC9 Base.]]

L["sticker_a9k.printname"] = "ARCTICTHRON 9.000 WEAPON BASE"
L["sticker_a9k.compactname"] = "A9K"
L["sticker_a9k.description"] = [[this is what "arc9" actually means

Sticker included in the ARC9 Base.]]

L["sticker_a9cylo.printname"] = "ARC9 Concept logo by CyloWalker"
L["sticker_a9cylo.compactname"] = "A9 Cylo"
L["sticker_a9cylo.description"] = [[One of the first concepts for ARC9 logo/icon by CyloWalker (he's cool!)

Sticker included in the ARC9 Base.]]

L["sticker_sus9.printname"] = "Sus 9"
L["sticker_sus9.compactname"] = "Sus 9"
L["sticker_sus9.description"] = [[The impostor could be anywhere among us...
Design by Darsu.

Sticker included in the ARC9 Base.]]

//////// Stickers, Com. Wave 1
L["sticker_alien_lean.printname"] = "Legalize Alien Lean"
L["sticker_alien_lean.compactname"] = "Alien Lean"
L["sticker_alien_lean.description"] = [[Hop down to Agartha with the white boys for a cup of alien lean and... other things.
Design by Opt1ca.

Sticker included in the ARC9 Base.]]

L["sticker_tomatocat.printname"] = "Tomato Cat"
L["sticker_tomatocat.compactname"] = "Tomato Cat"
L["sticker_tomatocat.description"] = [[Sometimes people ask whether tomatoes are fruits or vegetables... This one might be a tougher question.
Design by Ender2Point0.

Sticker included in the ARC9 Base.]]

L["sticker_actionbird.printname"] = "Action Bird"
L["sticker_actionbird.compactname"] = "Action Bird"
L["sticker_actionbird.description"] = [[This is what Arctic looks like in real life.
Design by CyloWalker.

Sticker included in the ARC9 Base.]]

L["sticker_warcrimes.printname"] = "War Crimes"
L["sticker_warcrimes.compactname"] = "War Crimes"
L["sticker_warcrimes.description"] = [[You're already doing them, so why not shout it out loud? Who's gonna stop you, the UN?
Design by Rimuchii. Made using Project Sekai sticker base.

Sticker included in the ARC9 Base.]]

L["sticker_sillycat.printname"] = "Silly Cat"
L["sticker_sillycat.compactname"] = "Silly Cat"
L["sticker_sillycat.description"] = [[imsillyimsillyimsillyimsillyimsillyimsillyimsillyimsilly
Design by Stan_Jacobs.

Sticker included in the ARC9 Base.]]

L["sticker_muertosskull.printname"] = "Dia De Los Muertos Calavera"
L["sticker_muertosskull.compactname"] = "Los Muertos"
L["sticker_muertosskull.description"] = [["this should be my final version i think, unless anyone gives me suggestions to change it, the name: "Dia de los muertos calavera" the description: i cant think of one, something about day of the dead skull mexico blah blah blah"
Design by rooneyviz.

Sticker included in the ARC9 Base.]]

L["sticker_bandaid.printname"] = "Band-Aid"
L["sticker_bandaid.compactname"] = "Band-Aid"
L["sticker_bandaid.description"] = [[Put it on your boo-boo and kiss it all better.
Design by Itzal.

Sticker included in the ARC9 Base.]]

L["sticker_peacedove.printname"] = "Peace Through Superior Firepower"
L["sticker_peacedove.compactname"] = "PTSF"
L["sticker_peacedove.description"] = [[The dove brings peace, but the gun brings peace through superior firepower.
Design by Xipil.

Sticker included in the ARC9 Base.]]

L["sticker_borntomodify.printname"] = "Born To Modify"
L["sticker_borntomodify.compactname"] = "BTM"
L["sticker_borntomodify.description"] = [[Another sight - another scope - a grenade launcher, here and there...
Design by Duck.

Sticker included in the ARC9 Base.]]

L["sticker_cad.printname"] = "cad"
L["sticker_cad.compactname"] = "cad"
L["sticker_cad.description"] = [[cad
Design by Opt1ca.

Sticker included in the ARC9 Base.]]

L["sticker_fumo.printname"] = "Fumo"
L["sticker_fumo.compactname"] = "Fumo"
L["sticker_fumo.description"] = [[D-don't look at me like that, raifu-kun...
Design by Itzal.

Sticker included in the ARC9 Base.]]

L["sticker_hotlead.printname"] = "Hot Lead"
L["sticker_hotlead.compactname"] = "Hot Lead"
L["sticker_hotlead.description"] = [[Careful! It's hot!
Design by Arqu.

Sticker included in the ARC9 Base.]]

L["sticker_steamhappy.printname"] = ":steamhappy:"
L["sticker_steamhappy.compactname"] = ":steamhappy:"
L["sticker_steamhappy.description"] = [[Happy about it
Design from Steam.

Sticker included in the ARC9 Base.]]

L["sticker_amidstus.printname"] = "Amidstus"
L["sticker_amidstus.compactname"] = "Amidstus"
L["sticker_amidstus.description"] = [[Why settle for the original when you could have a cheap knockoff?!
Design from Optica.

Sticker included in the ARC9 Base.]]

L["sticker_arcglory.printname"] = "Glory!"
L["sticker_arcglory.compactname"] = "Glory!"
L["sticker_arcglory.description"] = [[Took nine brain cells to scribble this
Design from Optica.

Sticker included in the ARC9 Base.]]

L["sticker_wp.printname"] = "World Peace!"
L["sticker_wp.compactname"] = "World Peace!"
L["sticker_wp.description"] = [[A delusion!
Design from Fidget.

Sticker included in the ARC9 Base.]]

L["sticker_tonkr.printname"] = "Send It"
L["sticker_tonkr.compactname"] = "Send It"
L["sticker_tonkr.description"] = [[Yeah, it's that heavy. Yeah, it's that powerful.
Design from CyloWalker.

Sticker included in the ARC9 Base.]]

L["sticker_s6amblem.printname"] = "Section 6"
L["sticker_s6amblem.compactname"] = "Section 6"
L["sticker_s6amblem.description"] = [[Reach for the stars. Forward to Glory!
Design from CyloWalker.

Sticker included in the ARC9 Base.]]

L["sticker_babies.printname"] = "Baby Hazard"
L["sticker_babies.compactname"] = "Baby Hazard"
L["sticker_babies.description"] = [[Children ages 0-3 should be kept away from this.. firearm.
Design from Itzal.

Sticker included in the ARC9 Base.]]

L["sticker_drawberf.printname"] = "Berf"
L["sticker_drawberf.compactname"] = "Berf"
L["sticker_drawberf.description"] = [[Draw Berf.
Design by The Villain.

Sticker included in the ARC9 Base.]]

L["sticker_arcbird.printname"] = "Arc Bird"
L["sticker_arcbird.compactname"] = "Arc Bird"
L["sticker_arcbird.description"] = [[Arc Bird.
Design by Nori/Chewable.

Sticker included in the ARC9 Base.]]

--PATH lua/arc9/common/localization/content_base_ru.lua:
return gluapack()()
--PATH lua/arc9/shared/sh_0_precache.lua:
return gluapack()()
--PATH lua/arc9/common/attachments_bulk/camos_base_flat_camo.lua:
return gluapack()()
--PATH lua/arc9/common/attachments_bulk/stickers_base.lua:
return gluapack()()
--PATH lua/arc9/common/attachments_bulk/stickers_base.lua:
local ATT

ATT = {}

ATT.PrintName = [[ARC9 Logo (Low Vis)]]
ATT.CompactName = "ARC9 LOWVIS"
ATT.Description = [[Dark version of the ARC9 Logo.
Design by The Villain.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/arc9_lowvis")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ATT.StickerMaterial = "stickers/arc9_lowvis"

ARC9.LoadAttachment(ATT, "sticker_arc9")

ATT = {}

ATT.PrintName = [[ARC9 Logo]]
ATT.CompactName = "ARC9"
ATT.Description = [[Here's to you.
Design by The Villain.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/arc9")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ATT.StickerMaterial = "stickers/arc9"

ARC9.LoadAttachment(ATT, "sticker_arc9_lowvis")

ATT = {}

ATT.PrintName = [[ARCTICTHRON 9.000 WEAPON BASE]]
ATT.CompactName = "A9K"
ATT.Description = [[this is what "arc9" actually means

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/a9k")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ATT.StickerMaterial = "stickers/a9k"


ARC9.LoadAttachment(ATT, "sticker_a9k")

ATT = {}

ATT.PrintName = [[ARC9 Concept logo by CyloWalker]]
ATT.CompactName = "A9 Cylo"
ATT.Description = [[One of the first concepts for ARC9 logo/icon by CyloWalker (he's cool!)

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/a9cylo")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ATT.StickerMaterial = "stickers/a9cylo"

ARC9.LoadAttachment(ATT, "sticker_a9cylo")

ATT = {}

ATT.PrintName = [[Legalize Alien Lean]]
ATT.CompactName = "Alien Lean"
ATT.Description = [[Hop down to Agartha with the white boys for a cup of alien lean and... other things.
Design by Opt1ca.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/alien_lean")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/alien_lean"

ARC9.LoadAttachment(ATT, "sticker_alien_lean")


ATT = {}

ATT.PrintName = [[Your Spray Here]]
ATT.CompactName = "Custom"
ATT.Description = [[Sadly, you will only see your own spray, and not others'.

Sticker included in ARC9 Base.]]
-- ATT.Icon = Material("decals/playerlogo01")
ATT.Icon = Material("stickers/spray")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"

-- ATT.StickerMaterial = "decals/playerlogo01"
ATT.StickerMaterial = "stickers/spray"

ARC9.LoadAttachment(ATT, "sticker_spray")

ATT = {}

ATT.PrintName = [[Tomato Cat]]
ATT.CompactName = "Tomato Cat"
ATT.Description = [[Sometimes people ask whether tomatoes are fruits or vegetables... This one might be a tougher question.
Design by Ender2Point0.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/tomatocat")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/tomatocat"

ARC9.LoadAttachment(ATT, "sticker_tomatocat")

ATT = {}

ATT.PrintName = [[Action Bird]]
ATT.CompactName = "Action Bird"
ATT.Description = [[This is what Arctic looks like in real life.
Design by CyloWalker.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/actionbird")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/actionbird"

ARC9.LoadAttachment(ATT, "sticker_actionbird")

ATT = {}

ATT.PrintName = [[War Crimes]]
ATT.CompactName = "War Crimes"
ATT.Description = [[You're already doing them, so why not shout it out loud? Who's gonna stop you, the UN?
Design by Rimuchii. Made using Project Sekai sticker base.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/warcrimes")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/warcrimes"

ARC9.LoadAttachment(ATT, "sticker_warcrimes")

ATT = {}

ATT.PrintName = [[Silly Cat]]
ATT.CompactName = "Silly Cat"
ATT.Description = [[imsillyimsillyimsillyimsillyimsillyimsillyimsillyimsilly
Design by Stan_Jacobs.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/sillycat")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/sillycat"

ARC9.LoadAttachment(ATT, "sticker_sillycat")

ATT = {}

ATT.PrintName = [[Dia De Los Muertos Calavera]]
ATT.CompactName = "Dia De Los Muertos Calavera"
ATT.Description = [["this should be my final version i think, unless anyone gives me suggestions to change it, the name: "Dia de los muertos calavera" the description: i cant think of one, something about day of the dead skull mexico blah blah blah"
Design by rooneyviz.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/muertosskull")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/muertosskull"

ARC9.LoadAttachment(ATT, "sticker_muertosskull")

ATT = {}

ATT.PrintName = [[Band-Aid]]
ATT.CompactName = "Band-Aid"
ATT.Description = [[Put it on your boo-boo and kiss it all better.
Design by Itzal.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/bandaid")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/bandaid"

ARC9.LoadAttachment(ATT, "sticker_bandaid")

ATT = {}

ATT.PrintName = [[Peace Through Superior Firepower]]
ATT.CompactName = "Peace Through Superior Firepower"
ATT.Description = [[The dove brings peace, but the gun brings peace through superior firepower.
Design by Xipil.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/peacedove")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/peacedove"

ARC9.LoadAttachment(ATT, "sticker_peacedove")

ATT = {}

ATT.PrintName = [[Born To Modify]]
ATT.CompactName = "Born To Modify"
ATT.Description = [[Another sight - another scope - a grenade launcher, here and there...
Design by Duck.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/borntomodify")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/borntomodify"

ARC9.LoadAttachment(ATT, "sticker_borntomodify")

ATT = {}

ATT.PrintName = [[cad]]
ATT.CompactName = "cad"
ATT.Description = [[cad
Design by Opt1ca.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/cad")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/cad"

ARC9.LoadAttachment(ATT, "sticker_cad")

ATT = {}

ATT.PrintName = [[Fumo]]
ATT.CompactName = "Fumo"
ATT.Description = [[D-don't look at me like that, raifu-kun...
Design by Itzal.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/fumo")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/fumo"

ARC9.LoadAttachment(ATT, "sticker_fumo")

ATT = {}

ATT.PrintName = [[Hot Lead]]
ATT.CompactName = "Hot Lead"
ATT.Description = [[Careful! It's hot!
Design by Arqu.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/hotlead")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/hotlead"

ARC9.LoadAttachment(ATT, "sticker_hotlead")

ATT = {}

ATT.PrintName = [[Sus 9]]
ATT.CompactName = "Sus 9"
ATT.Description = [[The impostor could be anywhere among us...
Design by Darsu.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/sus9")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ATT.StickerMaterial = "stickers/sus9"

ARC9.LoadAttachment(ATT, "sticker_sus9")

ATT = {}

ATT.PrintName = [[:steamhappy:]]
ATT.CompactName = ":steamhappy:"
ATT.Description = [[Happy about it
Design from Steam.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/steamhappy")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/steamhappy"

ARC9.LoadAttachment(ATT, "sticker_steamhappy")

ATT = {}

ATT.PrintName = [[Amidstus]]
ATT.CompactName = "Amidstus"
ATT.Description = [[Why settle for the original when you could have a cheap knockoff?!
Design from Optica.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/amidstus")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/amidstus"

ARC9.LoadAttachment(ATT, "sticker_amidstus")

ATT = {}

ATT.PrintName = [[Glory!]]
ATT.CompactName = "Glory!"
ATT.Description = [[Took nine brain cells to scribble this
Design from Optica.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/arcglory")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/arcglory"

ARC9.LoadAttachment(ATT, "sticker_arcglory")

ATT = {}

ATT.PrintName = [[World Peace!]]
ATT.CompactName = "World Peace"
ATT.Description = [[A delusion!
Design from Fidget.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/wp")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/wp"

ARC9.LoadAttachment(ATT, "sticker_wp")

ATT = {}

ATT.PrintName = [[Send It]]
ATT.CompactName = "Send It"
ATT.Description = [[Yeah, it's that heavy. Yeah, it's that powerful.
Design from CyloWalker.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/tonkr")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/tonkr"

ARC9.LoadAttachment(ATT, "sticker_tonkr")

ATT = {}

ATT.PrintName = [[Section 6]]
ATT.CompactName = "Section 6"
ATT.Description = [[Reach for the stars. Forward to Glory!
Design from CyloWalker.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/s6amblem")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/s6amblem"

ARC9.LoadAttachment(ATT, "sticker_s6amblem")

ATT = {}

ATT.PrintName = [[Baby Hazard]]
ATT.CompactName = "Baby Hazard"
ATT.Description = [[Children ages 0-3 should be kept away from this.. firearm.
Design from Itzal.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/babies")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/babies"

ARC9.LoadAttachment(ATT, "sticker_babies")

ATT = {}

ATT.PrintName = [[Berf]]
ATT.CompactName = "Berf"
ATT.Description = [[Draw Berf.
Design by The Villain.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/drawberf")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/drawberf"

ARC9.LoadAttachment(ATT, "sticker_drawberf")

ATT = {}

ATT.PrintName = [[Arc Bird]]
ATT.CompactName = "Arc Bird"
ATT.Description = [[Arc Bird.
Design by Nori/Chewable.

Sticker included in ARC9 Base.]]
ATT.Icon = Material("stickers/arc_bird")

ATT.SortOrder = 0
ATT.Free = true

ATT.Category = "stickers"
ATT.Folder = ARC9:GetPhrase("folder.arc9") .. "/" .. ARC9:GetPhrase("folder.arc9.community")

ATT.StickerMaterial = "stickers/arc_bird"

ARC9.LoadAttachment(ATT, "sticker_arcbird")
--PATH lua/arc9/client/cl_font.lua:
local font_cvar = (game.SinglePlayer() or CLIENT) and GetConVar("arc9_font")
local fontaddsize_cvar = (game.SinglePlayer() or CLIENT) and GetConVar("arc9_font_addsize")

function ARC9:GetFont()
    local f = font_cvar and font_cvar:GetString()
    if !f or f == "" then f = ARC9:GetPhrase("font") or "Venryn Sans" end
    --if !f or f == "" then f = "Venryn Sans" end
    return f
end

function ARC9:GetUnscaledFont()
    local f = ARC9:GetPhrase("unscaled_font") or "HD44780A00 5x8"
    return f
end

local arc9_hud_scale = GetConVar("arc9_hud_scale")
if !ARC9.ScreenScale then ARC9.ScreenScale = function(size) return size * (ScrW() / 640) * arc9_hud_scale:GetFloat() * 0.9 end end -- idk

local sizes_to_make = {
    4,
    6,
    7,
    8,
    9,
    10,
    12,
    16,
    20,
    24,
    32
}

local unscaled_sizes_to_make = {
    12,
    16,
    24,
    32,
    48,
    64
}

local function generatefonts()
    local font = ARC9:GetFont()
    local unscaled_font = ARC9:GetUnscaledFont()
    local addsize = fontaddsize_cvar:GetInt() or 0

    for _, i in pairs(sizes_to_make) do

        surface.CreateFont( "ARC9_" .. tostring(i), {
            font = font,
            size = ARC9.ScreenScale(i + addsize),
            weight = i < 16 and 650 or 600,
            antialias = true,
            extended = true, -- Required for non-latin fonts
        } )

        surface.CreateFont( "ARC9_" .. tostring(i) .. "_Slim", {
            font = font,
            size = ARC9.ScreenScale(i + addsize),
            weight = 300,
            antialias = true,
            extended = true,
        } )

        surface.CreateFont( "ARC9_" .. tostring(i) .. "_Glow", {
            font = font,
            size = ARC9.ScreenScale(i + addsize),
            weight = 600,
            antialias = true,
            blursize = ARC9.ScreenScale(i * 0.2),
            extended = true,
        } )

    end

    for _, i in pairs(unscaled_sizes_to_make) do

        surface.CreateFont( "ARC9_" .. tostring(i) .. "_Unscaled", {
            font = unscaled_font,
            size = i,
            weight = 500,
            antialias = true,
            extended = true,
        } )

        surface.CreateFont( "ARC9_" .. tostring(i) .. "_Unscaled_Glow", {
            font = unscaled_font,
            size = i,
            weight = 500,
            antialias = true,
            blursize = i * 0.2,
            extended = false,
        } )

        surface.CreateFont( "ARC9_" .. tostring(i) .. "_LCD", {
            font = "HD44780A00 5x8",
            size = i,
            weight = 500,
            antialias = true,
            extended = true,
        } )

        surface.CreateFont( "ARC9_" .. tostring(i) .. "_LCD_Glow", {
            font = "HD44780A00 5x8",
            size = i,
            weight = 500,
            antialias = true,
            blursize = i * 0.2,
            extended = false,
        } )

    end

end

surface.CreateFont( "ARC9_Deco_8_Unscaled", {
    font = "Consolas",
    size = 8,
    weight = 500,
    antialias = true,
    extended = true,
} )

generatefonts()

timer.Simple(2, generatefonts) -- im sorry but new hud default 0.9 mult doesn't want to work on fonts otherwise

function ARC9.Regen()
    generatefonts()
end

concommand.Add("arc9_font_reload", ARC9.Regen)

hook.Add("OnScreenSizeChanged", "ARC9.FontRegen", function(oldWidth, oldHeight)
    print("Warning: Resolution was changed. If ARC9 fonts are too small/big now, try type  arc9_font_reload  in console ")
    timer.Simple(5, ARC9.Regen)
end)

-- cvars.AddChangeCallback("arc9_font", ARC9.Regen, "reload_fonts")

--PATH lua/arc9/client/cl_hud.lua:
return gluapack()()
--PATH lua/arc9/client/cl_net.lua:
return gluapack()()
--PATH lua/arc9/client/cl_npc.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/autorun/sh_handcuffs.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- sh_handcuffs.lua         SHARED --
--                                 --
-- Shared handcuff stuff.          --
-------------------------------------

if CLIENT then
local darkness_pda_font_scale = 0.32
surface.CreateFont( "Darkness_PDA_Skills_Price", {
    font = "QuickInfo",
    extended = false,
    size = darkness_pda_font_scale*ScreenScale( 15 ),
    weight = 500,
    blursize = 0,
    scanlines = 2,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false,
} )
end

AddCSLuaFile()

//
// Config
local ProtectedJobs = {
	"TEAM_ADMIN", "TEAM_MOD", "TEAM_MODERATOR",
}

// 
// Utility
local function GetTrace( ply )
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
		local cuffed,wep = tr.Entity:IsHandcuffed()
		if cuffed then return tr,wep end
	end
end

//
// PLAYER extensions
local PLAYER = FindMetaTable( "Player" )
function PLAYER:IsHandcuffed()
	local wep = self:GetActiveWeapon()
	if IsValid(wep) and wep.IsHandcuffs then
		return true,wep
	end
	
	return false
end

//
// Override Movement
hook.Add( "SetupMove", "Cuffs Move Penalty", function(ply, mv, cmd)
	local cuffed, cuffs = ply:IsHandcuffed()
	if not (cuffed and IsValid(cuffs)) then return end
	
	mv:SetMaxClientSpeed( mv:GetMaxClientSpeed()*0.6 )
	
	if cuffs:GetRopeLength()<=0 then return end // No forced movement
	if not IsValid(cuffs:GetKidnapper()) then return end // Nowhere to move to
	
	local kidnapper = cuffs:GetKidnapper()
	if kidnapper==ply then return end
	
	local TargetPoint = (kidnapper:IsPlayer() and kidnapper:GetShootPos()) or kidnapper:GetPos()
	local MoveDir = (TargetPoint - ply:GetPos()):GetNormal()
	local ShootPos = ply:GetShootPos() + (Vector(0,0, (ply:Crouching() and 0)))
	local Distance = cuffs:GetRopeLength()
	
	local distFromTarget = ShootPos:Distance( TargetPoint )
	if distFromTarget<=(Distance+5) then return end
	if ply:InVehicle() then
		if SERVER and (distFromTarget>(Distance*3)) then
			ply:ExitVehicle()
		end
		
		return
	end
	
	local TargetPos = TargetPoint - (MoveDir*Distance)
	
	local xDif = math.abs(ShootPos[1] - TargetPos[1])
	local yDif = math.abs(ShootPos[2] - TargetPos[2])
	local zDif = math.abs(ShootPos[3] - TargetPos[3])
	
	local speedMult = 3+ ( (xDif + yDif)*0.5)^1.01
	local vertMult = math.max((math.Max(300-(xDif + yDif), -10)*0.08)^1.01  + (zDif/2),0)
	
	if kidnapper:GetGroundEntity()==ply then vertMult = -vertMult end
	
	local TargetVel = (TargetPos - ShootPos):GetNormal() * 10
	TargetVel[1] = TargetVel[1]*speedMult
	TargetVel[2] = TargetVel[2]*speedMult
	TargetVel[3] = TargetVel[3]*vertMult
	local dir = mv:GetVelocity()
	
	local clamp = 50
	local vclamp = 20
	local accel = 200
	local vaccel = 30*(vertMult/50)
	
	dir[1] = (dir[1]>TargetVel[1]-clamp or dir[1]<TargetVel[1]+clamp) and math.Approach(dir[1], TargetVel[1], accel) or dir[1]
	dir[2] = (dir[2]>TargetVel[2]-clamp or dir[2]<TargetVel[2]+clamp) and math.Approach(dir[2], TargetVel[2], accel) or dir[2]
	
	if ShootPos[3]<TargetPos[3] then
		dir[3] = (dir[3]>TargetVel[3]-vclamp or dir[3]<TargetVel[3]+vclamp) and math.Approach(dir[3], TargetVel[3], vaccel) or dir[3]
		
		if vertMult>0 then ply.Cuff_ForceJump=ply end
	end
	
	mv:SetVelocity( dir )
	
	if SERVER and mv:GetVelocity():Length()>=(mv:GetMaxClientSpeed()*10) and ply:IsOnGround() and CurTime()>(ply.Cuff_NextDragDamage or 0) then
		ply:SetHealth( ply:Health()-1 )
		if ply:Health()<=0 then ply:Kill() end
		
		ply.Cuff_NextDragDamage = CurTime()+0.1
	end
end)

//
// Vehicles
hook.Add( "CanPlayerEnterVehicle", "Cuffs PreventVehicle", function( ply )
	-- if ply:IsHandcuffed() then return false end
end)

//
// Internal Cuffs hooks
hook.Add( "CuffsCanHandcuff", "Cuff ProtectAdmin", function( ply, target )
	if IsValid(target) and target:IsPlayer() and ProtectedJobs then
		for i=1,#ProtectedJobs do
			if ProtectedJobs[i] and _G[ ProtectedJobs[i] ] and target:Team()==_G[ ProtectedJobs[i] ] then return false end
		end
	end
end)

if CLIENT then
	//
	// HUD
	local Col = {
		Text = Color(255,255,255), TextShadow=Color(0,0,0), Rope = Color(255,255,255),
		
		BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),
	}
	local matGrad = Material( "gui/gradient" )
	hook.Add( "HUDPaint", "Cuffs CuffedInteractPrompt", function()
		if LocalPlayer():IsHandcuffed() then return end
		
		local tr,cuff = GetTrace( LocalPlayer() )
		if not (tr and IsValid(cuff)) then return end
		
		local w,h = (ScrW()/2), (ScrH()/2)
		
		local TextPos = h-40
		
		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w-101, TextPos-1, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, TextPos, 200, 20 )
		
		render.SetScissorRect( w-100, TextPos, (w-100)+((cuff:GetCuffBroken()/100)*200), TextPos+20, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w-100,TextPos, 200,20 )
			
			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w-100,TextPos, 200,20 )
		render.SetScissorRect( 0,0,0,0, false )
		TextPos = TextPos-25
		
		if IsValid(cuff:GetFriendBreaking()) then
			if cuff:GetFriendBreaking()==LocalPlayer() then
				draw.SimpleText( "Uwalnianie...", "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
				draw.SimpleText( "Uwalnianie...", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
				TextPos = TextPos-20
			end
		else
			local str = string.format( "%s aby uwolnić", (input.LookupBinding("+use") or "[USE]"):upper() )
			draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
			TextPos = TextPos-20
		end
		
		if cuff:GetRopeLength()>0 then
			if IsValid(cuff:GetKidnapper()) then
				if cuff:GetKidnapper()==LocalPlayer() then
					local str = string.format( "%s aby przestać ciągnąć", (input.LookupBinding("+reload") or "[Reload]"):upper() )
					draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
					draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
					TextPos = TextPos-20
				end
			else
				local str = string.format( "%s aby ciągnąć", (input.LookupBinding("+reload") or "[Reload]"):upper() )
				draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
				draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
				TextPos = TextPos-20
			end
		end
		
		if cuff:GetCanBlind() then
			local str = string.format( "%s aby %s", (input.LookupBinding("+attack2") or "[PRIMARY FIRE]"):upper(), cuff:GetIsBlind() and "odsłonić widok" or "zakryć widok" )
			draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
			TextPos = TextPos-20
		end
		
		if cuff:GetCanGag() then
			local str = string.format( "%s aby %s", (input.LookupBinding("+attack") or "[PRIMARY FIRE]"):upper(), cuff:GetIsGagged() and "odciszyć" or "uciszyć" )
			draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
			TextPos = TextPos-20
		end
		if input.LookupKeyBinding(30) ~= nil then
			local str = string.format(input.LookupBinding( input.LookupKeyBinding(30))):upper().." aby przeszukać"
				draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
				draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
				TextPos = TextPos-20
		end
	end)
	
	//
	// Bind hooks
	hook.Add( "PlayerBindPress", "Cuffs CuffedInteract", function(ply, bind, pressed)
		if ply~=LocalPlayer() then return end
		
		if bind:lower()=="+attack" and pressed then
			if ply:KeyDown( IN_USE ) then
				local isDragging = false
				for _,c in pairs(ents.FindByClass("weapon_handcuffed")) do
					if c.GetRopeLength and c.GetKidnapper and c:GetRopeLength()>0 and c:GetKidnapper()==ply then
						isDragging=true
						break
					end
				end
				if isDragging then
					net.Start("Cuffs_TiePlayers") net.SendToServer()
					return true
				end
			end
			local tr,cuffs = GetTrace( ply )
			if tr and cuffs:GetCanGag() then
				net.Start( "Cuffs_GagPlayer" )
					net.WriteEntity( tr.Entity )
					net.WriteBit( not cuffs:GetIsGagged() )
				net.SendToServer()
				return true
			end
		elseif bind:lower()=="+attack2" and pressed then
			local tr,cuffs = GetTrace( ply )
			if tr and cuffs:GetCanBlind() then
				net.Start( "Cuffs_BlindPlayer" )
					net.WriteEntity( tr.Entity )
					net.WriteBit( not cuffs:GetIsBlind() )
				net.SendToServer()
				return true
			end
		elseif bind:lower()=="+reload" and pressed then
			local tr,cuffs = GetTrace( ply )
			if tr and cuffs:GetRopeLength()>0 then
				net.Start( "Cuffs_DragPlayer" )
					net.WriteEntity( tr.Entity )
					net.WriteBit( LocalPlayer()~=cuffs:GetKidnapper() )
				net.SendToServer()
				return true
			end
		elseif bind:lower()=="+use" and pressed then
			local tr,cuffs = GetTrace( ply )
			if tr then
				net.Start( "Cuffs_FreePlayer" )
					net.WriteEntity( tr.Entity )
				net.SendToServer()
				return true
			else
				local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
				if IsValid(tr.Entity) and tr.Entity:GetNWBool("Cuffs_TieHook") then
					net.Start("Cuffs_UntiePlayers") net.SendToServer()
				end
			end
		elseif bind:lower()=="impulse 201" and pressed then
			local tr,cuffs = GetTrace( ply )
			if tr then
				net.Start( "Cuffs_Przeszukanie" )
					net.WriteEntity( tr.Entity )
				net.SendToServer()
				return true
			end
		end
	end)
	
	if CLIENT then
		net.Receive( "Cuffs_Przeszukanie", function()
			local weapons_table = net.ReadTable()
			local playerTarget = net.ReadEntity()
			local przeszukanieWeaponsFrame = vgui.Create("DFrame")
				przeszukanieWeaponsFrame:SetSize(300, 400)
				przeszukanieWeaponsFrame:SetTitle("Bronie przeszukanego gracza:")
				przeszukanieWeaponsFrame:Center()
				przeszukanieWeaponsFrame:MakePopup()
				przeszukanieWeaponsFrame.Paint = function( self, w, h )
					draw.RoundedBox(10, 0, 0, w, h, Color(10, 10, 10, 254))
				end
			
			local przeszukanieWeaponsScroll = vgui.Create( "DScrollPanel", przeszukanieWeaponsFrame )
				przeszukanieWeaponsScroll:SetPos( 0, 30 )
				przeszukanieWeaponsScroll:SetSize( przeszukanieWeaponsFrame:GetWide(), przeszukanieWeaponsFrame:GetTall()-(0.15*przeszukanieWeaponsFrame:GetTall()))
				przeszukanieWeaponsScroll.Paint = function( self, w, h )
				---	draw.RoundedBox(2, 0, 0, w, h, Color(255, 255, 255, 100))
				end
			
			local przeszukanieWeaponsList = vgui.Create( "DIconLayout", przeszukanieWeaponsScroll )
				przeszukanieWeaponsList:Dock( FILL )
				przeszukanieWeaponsList:SetSpaceY( 5 )
				przeszukanieWeaponsList:SetSpaceX( 1 )
				
			
			for k, v in ipairs(weapons_table) do
				print(przeszukanie_config.safeWeapons[v:GetClass()])
				if przeszukanie_config.safeWeapons[v:GetClass()] == true then print(v:GetClass()) continue end
				local przeszukanieWeaponButton = przeszukanieWeaponsList:Add( "DButton" )
					przeszukanieWeaponButton:SetSize( przeszukanieWeaponsFrame:GetWide(), 0.06*przeszukanieWeaponsFrame:GetTall() )
					przeszukanieWeaponButton:SetText( "" )
					przeszukanieWeaponButton.marked = false
					przeszukanieWeaponButton.weapon = v
					if !v:IsValid() then return end
					przeszukanieWeaponButton.Paint = function( self, w, h )
						if !v:IsValid() then return end
						local color
						if przeszukanieWeaponButton.marked == false then color = Color(104, 132, 168)
						elseif przeszukanieWeaponButton.marked == true then color = Color(207, 134, 134)
						end
						draw.RoundedBox(0, 0, 0, w, h, color)
						draw.DrawText( v:GetPrintName(), "Darkness_PDA_Skills_Price", w/2, h/4, color_white, TEXT_ALIGN_CENTER)
					end
					przeszukanieWeaponButton.DoClick = function()
						if przeszukanieWeaponButton.marked == false then
							przeszukanieWeaponButton.marked = true
						else przeszukanieWeaponButton.marked = false
						end
					end
			end
			
			local przeszukanieRekwirowanieButton = vgui.Create( "DButton", przeszukanieWeaponsFrame )
				przeszukanieRekwirowanieButton:SetSize( przeszukanieWeaponsFrame:GetWide(), 0.07*przeszukanieWeaponsFrame:GetTall() )
				przeszukanieRekwirowanieButton:SetPos( 0, przeszukanieWeaponsFrame:GetTall()-przeszukanieRekwirowanieButton:GetTall() )
				przeszukanieRekwirowanieButton:SetText( "" )
				przeszukanieRekwirowanieButton.Paint = function( self, w, h )
					draw.RoundedBox(10, 0, 0, w, h, Color(72, 161, 115, 100))
					draw.DrawText( "Rekwiruj Bronie", "Darkness_PDA_Skills_Price", w/2, h/4, color_white, TEXT_ALIGN_CENTER)
				end
				przeszukanieRekwirowanieButton.DoClick = function()
					local weaponsRekwirowanieList = {}
					for k, v in pairs(przeszukanieWeaponsList:GetChildren()) do
						if v.marked == true then
							if IsValid(v.weapon) then
								table.insert( weaponsRekwirowanieList, v.weapon:GetClass() )
							end
						end
					end
					net.Start("Cuffs_Przeszukanie_strip")
						net.WriteEntity( playerTarget )
						net.WriteTable( weaponsRekwirowanieList )
					net.SendToServer()
					LocalPlayer():EmitSound( "buttons/blip2.wav" , 50, 140, 0.2)
					chat.AddText( Color(255, 148, 148),'Pomyślnie odebrałeś/aś przedmioty '..playerTarget:GetName().."." )
					przeszukanieWeaponsFrame:Close()
				end
		end)
		net.Receive( "Cuffs_Przeszukanie_strip", function()
			local target = net.ReadEntity()
			local weapons = net.ReadTable()
			chat.AddText( Color(255, 148, 148),target:GetName()..' odebrał/a Ci następujące przedmioty:')
			for k, v in pairs(weapons) do
				chat.AddText( Color(255, 242, 0), v)
			end
		end)
	end
	
	//
	// Render
	local DragBone = "ValveBiped.Bip01_R_Hand"
	local DefaultRope = Material("cable/rope")
	hook.Add( "PostDrawOpaqueRenderables", "Cuffs DragRope", function()
		local allCuffs = ents.FindByClass( "weapon_handcuffed" )
		for i=1,#allCuffs do
			local cuff = allCuffs[i]
			if not (IsValid(cuff) and IsValid(cuff.Owner) and cuff.GetRopeLength and cuff:GetRopeLength()>0 and cuff.GetKidnapper and IsValid(cuff:GetKidnapper())) then continue end
			
			local kidnapper = cuff:GetKidnapper()
			local kidPos = (kidnapper:IsPlayer() and kidnapper:GetPos() + Vector(0,0,37)) or kidnapper:GetPos()
			
			local pos = cuff.Owner:GetPos()
			local bone = cuff.Owner:LookupBone( DragBone )
			if bone then
				pos = cuff.Owner:GetBonePosition( bone )
				if (pos.x==0 and pos.y==0 and pos.z==0) then pos = cuff.Owner:GetPos() end
			end
			
			if not cuff.RopeMat then cuff.RopeMat = DefaultRope end
			render.SetMaterial( cuff.RopeMat )
			render.DrawBeam( kidPos, pos, 0.7, 0, 5, Col.Rope )
			render.DrawBeam( pos, kidPos, -0.7, 0, 5, Col.Rope )
		end
	end)
	
	local HeadBone = "ValveBiped.Bip01_Head1"
	local RenderPos = {
		Blind = {Vector(3.5,3,2.6), Vector(3.8,4.8,0), Vector(3.5,3,-2.8), Vector(2.4,-2,-3.8), Vector(1.5,-4.5,0), Vector(2.4,-2,3.8)},
		Gag = {Vector(1.0,4.2,2), Vector(1.0,5.5,-0.1), Vector(1.0,4.5,-2), Vector(0,0,-3.4), Vector(-0.8,-3,0), Vector(0,0,3.4)},
	}
	hook.Add( "PostPlayerDraw", "Cuffs DrawGag", function( ply )
		if not IsValid(ply) then return end
		
		local cuffed, cuff = ply:IsHandcuffed()
		if not (cuffed and IsValid(cuff)) then return end
		
		render.SetMaterial( DefaultRope )
		if cuff:GetIsBlind() then
			local pos,ang
			local bone = cuff.Owner:LookupBone( HeadBone )
			if bone then
				pos, ang = cuff.Owner:GetBonePosition( bone )
			end
			if pos and ang then
				local firstpos = pos + (ang:Forward()*RenderPos.Blind[1].x) + (ang:Right()*RenderPos.Blind[1].y) + (ang:Up()*RenderPos.Blind[1].z)
				local lastpos = firstpos
				for i=2,#RenderPos.Blind do
					local newPos = pos + (ang:Forward()*RenderPos.Blind[i].x) + (ang:Right()*RenderPos.Blind[i].y) + (ang:Up()*RenderPos.Blind[i].z)
					render.DrawBeam( newPos, lastpos, 1.5, 0, 1, Col.Rope )
					lastpos = newPos
				end
				render.DrawBeam( lastpos, firstpos, 1.5, 0, 1, Col.Rope )
			end
		end
		if cuff:GetIsGagged() then
			local pos,ang
			local bone = cuff.Owner:LookupBone( HeadBone )
			if bone then
				pos, ang = cuff.Owner:GetBonePosition( bone )
			end
			if pos and ang then
				local firstpos = pos + (ang:Forward()*RenderPos.Gag[1].x) + (ang:Right()*RenderPos.Gag[1].y) + (ang:Up()*RenderPos.Gag[1].z)
				local lastpos = firstpos
				for i=2,#RenderPos.Gag do
					local newPos = pos + (ang:Forward()*RenderPos.Gag[i].x) + (ang:Right()*RenderPos.Gag[i].y) + (ang:Up()*RenderPos.Gag[i].z)
					render.DrawBeam( newPos, lastpos, 1.5, 0, 1, Col.Rope )
					lastpos = newPos
				end
				render.DrawBeam( lastpos, firstpos, 1.5, 0, 1, Col.Rope )
			end
		end
	end)
end


--PATH lua/pixelui/core/sh_formatting.lua:
return gluapack()()
--PATH lua/pixelui/core/sh_formatting.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

do
    local currencySymbol = "$"
    local currencyLeft = true

    local function load()
        local config = (GM or GAMEMODE or {}).Config
        if not config then return end

        if config.currency ~= nil then currencySymbol = config.currency end
        if config.currencyLeft ~= nil then currencyLeft = config.currencyLeft end
    end
    load()
    hook.Add("PostGamemodeLoaded", "PIXEL.UI.GetMoneyFormatSettings", load)

    local function addCurrency(str)
        return currencyLeft and (currencySymbol .. str) or (str .. currencySymbol)
    end

    do
        local tostring = tostring
        local find = string.find
        local abs = math.abs
        local round = math.Round

        function PIXEL.FormatMoney(val)
            if not val then return addCurrency("0") end

            val = round(val)

            if val >= 1e14 then return addCurrency(tostring(val)) end
            if val <= -1e14 then return "-" .. addCurrency(tostring(abs(val))) end

            local negative = val < 0

            val = tostring(abs(val))
            local dp = find(val, "%.") or #val + 1

            for i = dp - 4, 1, -3 do
                val = val:sub(1, i) .. "," .. val:sub(i + 1)
            end

            if val[#val - 1] == "." then
                val = val .. "0"
            end

            return (negative and "-" or "") .. addCurrency(val)
        end
    end
end

local floor, format = math.floor, string.format
function PIXEL.FormatTime(time)
    if not time then return end

    local s = time % 60
    time = floor(time / 60)

    local m = time % 60
    time = floor(time / 60)

    local h = time % 24
    time = floor(time / 24)

    local d = time % 7
    local w = floor(time / 7)

    if w ~= 0 then
        return format("%iw %id %ih %im %is", w, d, h, m, s)
    elseif d ~= 0 then
        return format("%id %ih %im %is", d, h, m, s)
    elseif h ~= 0 then
        return format("%ih %im %is", h, m, s)
    end

    return format("%im %is", m, s)
end
--PATH lua/pixelui/elements/cl_avatar.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_avatar.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "MaskSize", "MaskSize", FORCE_NUMBER)

function PANEL:Init()
    self.Avatar = vgui.Create("AvatarImage", self)
    self.Avatar:SetPaintedManually(true)

    self.CirclePoly = {}
    self:SetMaskSize(1)
end

function PANEL:PerformLayout(w, h)
    self.Avatar:SetSize(w, h)

    self.CirclePoly = {}
    local maskSize = self:GetMaskSize()

    local t = 0
    for i = 1, 360 do
        t = math.rad(i * 720) / 720
        self.CirclePoly[i] = {x = w / 2 + math.cos(t) * maskSize, y = h / 2 + math.sin(t) * maskSize}
    end
end

function PANEL:SetPlayer(ply, size)
    self.Avatar:SetPlayer(ply, size)
end

function PANEL:SetSteamID(id, size)
    self.Avatar:SetSteamID(id, size)
end

local render = render
local surface = surface
local whiteTexture = surface.GetTextureID("vgui/white")
function PANEL:Paint(w, h)
    render.ClearStencil()
    render.SetStencilEnable(true)

    render.SetStencilWriteMask(1)
    render.SetStencilTestMask(1)

    render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
    render.SetStencilPassOperation(STENCILOPERATION_ZERO)
    render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
    render.SetStencilReferenceValue(1)

    surface.SetTexture(whiteTexture)
    surface.SetDrawColor(255, 255, 255, 255)
    surface.DrawPoly(self.CirclePoly)

    render.SetStencilFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
    render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
    render.SetStencilReferenceValue(1)

    self.Avatar:SetPaintedManually(false)
    self.Avatar:PaintManual()
    self.Avatar:SetPaintedManually(true)

    render.SetStencilEnable(false)
    render.ClearStencil()
end

vgui.Register("PIXEL.Avatar", PANEL, "Panel")
--PATH lua/pixelui/elements/cl_label.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "Font", "Font", FORCE_STRING)
AccessorFunc(PANEL, "TextAlign", "TextAlign", FORCE_NUMBER)
AccessorFunc(PANEL, "TextColor", "TextColor")
AccessorFunc(PANEL, "Ellipses", "Ellipses", FORCE_BOOL)
AccessorFunc(PANEL, "AutoHeight", "AutoHeight", FORCE_BOOL)
AccessorFunc(PANEL, "AutoWidth", "AutoWidth", FORCE_BOOL)
AccessorFunc(PANEL, "AutoWrap", "AutoWrap", FORCE_BOOL)

PIXEL.RegisterFont("UI.Label", "Open Sans SemiBold", 14)

function PANEL:Init()
    self:SetText("Label")
    self:SetFont("UI.Label")
    self:SetTextAlign(TEXT_ALIGN_LEFT)
    self:SetTextColor(PIXEL.Colors.SecondaryText)
end

function PANEL:SetText(text)
    self.Text = text
    self.OriginalText = text
end

function PANEL:CalculateSize()
    PIXEL.SetFont(self:GetFont())
    return PIXEL.GetTextSize(self:GetText())
end

function PANEL:PerformLayout(w, h)
    local desiredW, desiredH = self:CalculateSize()

    if self:GetAutoWidth() then
        self:SetWide(desiredW)
    end

    if self:GetAutoHeight() then
        self:SetTall(desiredH)
    end

    if self:GetAutoWrap() then
        self.Text = PIXEL.WrapText(self.OriginalText, w, self:GetFont())
    end
end

function PANEL:Paint(w, h)
    local align = self:GetTextAlign()
    local text = self:GetEllipses() and PIXEL.EllipsesText(self:GetText(), w, self:GetFont()) or self:GetText()

    if align == TEXT_ALIGN_CENTER then
        PIXEL.DrawText(text, self:GetFont(), w / 2, 0, self:GetTextColor(), TEXT_ALIGN_CENTER)
        return
    elseif align == TEXT_ALIGN_RIGHT then
        PIXEL.DrawText(text, self:GetFont(), w, 0, self:GetTextColor(), TEXT_ALIGN_RIGHT)
        return
    end

    PIXEL.DrawText(text, self:GetFont(), 0, 0, self:GetTextColor())
end

vgui.Register("PIXEL.Label", PANEL, "Panel")
--PATH lua/pixelui/elements/cl_slider.lua:
--[[
	PIXEL UI - Copyright Notice
	© 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

function PANEL:Init()
    self.Fraction = 0

    self.Grip = vgui.Create("PIXEL.ImageButton", self)
    self.Grip:NoClipping(true)

    self.Grip:SetImageURL("https://pixel-cdn.lythium.dev/i/g6e8z4pz")
    self.Grip:SetNormalColor(PIXEL.CopyColor(PIXEL.Colors.Primary))
    self.Grip:SetHoverColor(PIXEL.OffsetColor(PIXEL.Colors.Primary, -15))
    self.Grip:SetClickColor(PIXEL.OffsetColor(PIXEL.Colors.Primary, 15))

    self.Grip.OnCursorMoved = function(pnl, x, y)
        if not pnl.Depressed then return end

        x, y = pnl:LocalToScreen(x, y)
        x = self:ScreenToLocal(x, y)

        self.Fraction = math.Clamp(x / self:GetWide(), 0, 1)

        self:OnValueChanged(self.Fraction)
        self:InvalidateLayout()
    end

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 20)
    self.FillCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 10)
end

function PANEL:OnMousePressed()
    local w = self:GetWide()

    self.Fraction = math.Clamp(self:CursorPos() / w, 0, 1)
    self:OnValueChanged(self.Fraction)
    self:InvalidateLayout()
end

function PANEL:OnValueChanged(fraction) end

function PANEL:Paint(w, h)
    local rounding = h * .5
    PIXEL.DrawRoundedBox(rounding, 0, 0, w, h, self.BackgroundCol)
    PIXEL.DrawRoundedBox(rounding, 0, 0, self.Fraction * w, h, self.FillCol)
end

function PANEL:PerformLayout(w, h)
    local gripSize = h + PIXEL.Scale(6)
    local offset = PIXEL.Scale(3)
    self.Grip:SetSize(gripSize, gripSize)
    self.Grip:SetPos((self.Fraction * w) - (gripSize * .5), -offset)
end

vgui.Register("PIXEL.Slider", PANEL, "PIXEL.Button")
--PATH addons/[misc] siadanie/lua/sitanywhere/helpers.lua:
return gluapack()()
--PATH addons/[misc] siadanie/lua/sitanywhere/client/sit.lua:
local TAG = "SitAny_"
local useAlt = CreateClientConVar("sitting_use_walk", "1.00", true, true, "Makes sitting require the use of walk, disable this to sit simply by using use", 0, 1)
local forceBinds = CreateClientConVar("sitting_force_left_alt", "0", true, true, "Forces left alt to always act as a walk key for sitting", 0, 1)
local SittingNoAltServer = CreateConVar("sitting_force_no_walk", "0", {FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Disables the need for using walk to sit anywhere on the server", 0, 1)

CreateClientConVar("sitting_allow_on_me", "1.00", true, true, "Allows people to sit on you", 0, 1)

local function ShouldSit(ply)
	return hook.Run("ShouldSit", ply)
end

local arrow, drawScale, traceDist = Material("widgets/arrow.png"), 0.1, 20
local traceScaled = traceDist / drawScale

local function StartSit(trace)
	local wantedAng = nil
	local cancelled = false
	local start = CurTime()
	local ply = LocalPlayer()

	hook.Add("PostDrawOpaqueRenderables", TAG .. "PostDrawOpaqueRenderables", function(depth, skybox)
		if CurTime() - start <= 0.25 then return end
		if trace.StartPos:Distance(ply:EyePos()) > 10 then
			cancelled, wantedAng = true, nil
			hook.Remove("PostDrawOpaqueRenderables", TAG .. "PostDrawOpaqueRenderables")
			return
		end

		local vec = util.IntersectRayWithPlane(ply:EyePos(), ply:EyeAngles():Forward(), trace.HitPos, Vector(0, 0, 1))
		if not vec then
			return
		end

		local posOnPlane = WorldToLocal(vec, Angle(0, 90, 0), trace.HitPos, Angle(0, 0, 0))
		local testVec = posOnPlane:GetNormal() * traceScaled
		local currentAng = (trace.HitPos - vec):Angle()
		wantedAng = currentAng

		if posOnPlane:Length() < 2 then
			wantedAng = nil
			return
		end

		if wantedAng then
			local goodSit = SitAnywhere.CheckValidAngForSit(trace.HitPos, trace.HitNormal:Angle(), wantedAng.y)
			if not goodSit then wantedAng = nil end
			cam.Start3D2D(trace.HitPos + Vector(0, 0, 1), Angle(0, 0, 0), drawScale)
				surface.SetDrawColor(goodSit and Color(255, 255, 255, 255) or Color(255, 0, 0, 255))
				surface.SetMaterial(arrow)
				surface.DrawTexturedRectRotated(testVec.x * 0.5, testVec.y * -0.5, 2 / drawScale, traceScaled, currentAng.y + 90)
			cam.End3D2D()
		end
	end)

	return function()
		hook.Remove("PostDrawOpaqueRenderables", TAG .. "PostDrawOpaqueRenderables")
		if cancelled then return end

		if CurTime() - start < 0.25 then
			RunConsoleCommand("sit")
			return
		end

		if wantedAng then
			net.Start("SitAnywhere")
				net.WriteInt(SitAnywhere.NET.SitWantedAng, 4)
				net.WriteFloat(wantedAng.y)
				net.WriteVector(trace.StartPos)
				net.WriteVector(trace.Normal)
			net.SendToServer()
			wantedAng = nil
		end
	end
end

local function DoSit(trace)
	if not trace.Hit then return end

	local surfaceAng = trace.HitNormal:Angle() + Angle(-270, 0, 0)

	local playerTrace = not trace.HitWorld and IsValid(trace.Entity) and trace.Entity:IsPlayer()

	local goodSit = SitAnywhere.GetAreaProfile(trace.HitPos + Vector(0, 0, 0.1), 24, true)
	if math.abs(surfaceAng.pitch) >= 15 or not goodSit or playerTrace then
		RunConsoleCommand"sit"
		return
	end

	local valid = SitAnywhere.ValidSitTrace(LocalPlayer(), trace)
	if not valid then
		return
	end

	return StartSit(trace)
end

local currSit
concommand.Add("+sit", function(ply, cmd, args)
	if currSit then return end
	if not IsValid(ply) or not ply.GetEyeTrace then return end
	currSit = DoSit(ply:GetEyeTrace())
end)

concommand.Add("-sit", function(ply, cmd, args)
	if currSit then
		currSit()
		currSit = nil
	end
end)


hook.Add("KeyPress", TAG .. "KeyPress", function(ply, key)
	if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
	if currSit then return end

	if key ~= IN_USE then return end
	local good = not useAlt:GetBool()
	local alwaysSit = ShouldSit(ply)

	if forceBinds:GetBool() then
		if useAlt:GetBool() and input.IsKeyDown(KEY_LALT) then
			good = true
		end
	else
		if useAlt:GetBool() and ply:KeyDown(IN_WALK) then
			good = true
		end
	end

	if SittingNoAltServer:GetBool() then
		good = true
	end

	if alwaysSit == true then
		good = true
	elseif alwaysSit == false then
		good = false
	end

	if not good then return end
	local trace = LocalPlayer():GetEyeTrace()

	if trace.Hit then
		currSit = DoSit(trace)
		hook.Add("KeyRelease", TAG .. "KeyRelease", function(releasePly, releaseKey)
			if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
			if ply ~= releasePly or releaseKey ~= IN_USE then return end
			hook.Remove("KeyRelease", TAG .. "KeyRelease")
			if not currSit then return end

			currSit()
			currSit = nil
		end)
	end
end)
--PATH lua/slib/vgui/cl_sscrollpanel.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_ssearchbar.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_cppi.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/client/cl_gprotect.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/languages/sh_french.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/languages/sh_german.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/client/cl_blockedmodels.lua:
local deleteNames = {
	["#spawnmenu.menu.delete"] = true,
	["#collision_off"] = true,
	["#spawnmenu.menu.spawn_with_toolgun"] = true
}

local function addOptions(menu, type, tbl, copy, prespacer, postspacer)
	tbl = util.TableToJSON(tbl)
	if prespacer then
		menu:AddSpacer()
	end

	menu:AddOption( gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, type == "model" and "add-blocked-models" or "add-blacklisted-ents"), function()
		net.Start("gP:Networking")
		net.WriteUInt(2,2)
		net.WriteUInt(type == "model" and 1 or 2, 2)
		net.WriteString(tbl)
		net.WriteBool(true)
		net.SendToServer()
	end ):SetIcon("icon16/add.png")

	menu:AddOption( gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, type == "model" and "remove-blocked-models" or "remove-blacklisted-ents"), function()
		net.Start("gP:Networking")
		net.WriteUInt(2,2)
		net.WriteUInt(type == "model" and 1 or 2, 2)
		net.WriteString(tbl)
		net.WriteBool(false)
		net.SendToServer()
	end ):SetIcon("icon16/delete.png")

	if copy then
		menu:AddOption( gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, "copy-clipboard"), function()
			SetClipboardText(copy)
		end ):SetIcon("icon16/page_copy.png")
	end

	if postspacer then
		menu:AddSpacer()
	end
end

local function HandleMenuOptions(state, menu, name)
	local hovered = vgui.GetHoveredPanel()
	local data = IsValid(hovered) and hovered:GetTable() or {}
	local ply = LocalPlayer()
	if IsValid(hovered) and deleteNames[name] then
		if state == "pre" then
			if data.m_strModelName and name ~= "#spawnmenu.menu.spawn_with_toolgun" then
				addOptions(menu, "model", {[data.m_strModelName] = true}, data.m_strModelName, false, true)
			end
		else
			if data.m_Type == "entity" then
				addOptions(menu, "entity", {[data.m_SpawnName] = true}, data.m_SpawnName, true, true)
			end

			if hovered.ClassName == "ContextMenu" then
				local ent = ply:GetEyeTrace().Entity
				if IsValid(ent) then
					if string.find(ent:GetClass(), "prop_") then
						local mdl = ent:GetModel()
						addOptions(menu, "model", {[mdl] = true}, mdl, true)
					else
						local classname = ent:GetClass()
						addOptions(menu, "entity", {[classname] = true}, classname, true, true)
					end
				end
			end
		end
	end
end

hook.Add("gP:PreAddedDMenuOption", "gP:OverrideMenuOptions", HandleMenuOptions)
hook.Add("gP:PostAddedDMenuOption", "gP:OverrideMenuOptions", HandleMenuOptions)

timer.Simple(1, function()
	local dmenu = baseclass.Get("DMenu")
	slib.wrapFunction(dmenu, "AddOption", function(menu, str) hook.Run("gP:PreAddedDMenuOption", "pre", menu, str) end, function(menu, str) hook.Run("gP:PostAddedDMenuOption", "post", menu, str) end)

	hook.Add( "SpawnlistOpenGenericMenu", "DragAndDropSelectionMenu", function( canvas )

		local selected = canvas:GetSelectedChildren()
		local allow = {}

		for k, v in pairs(selected) do
			if !IsValid(v) then continue end
			local data = v:GetTable()
			if data.m_Type == "entity" then allow["entity"] = true end
			if data.m_strModelName then allow["prop"] = true break end
		end

		local menu = DermaMenu()
	
		-- This is less than ideal
		local spawnicons = 0
		local icon = nil
		for id, pnl in pairs( selected ) do
			if ( pnl.InternalAddResizeMenu ) then
				spawnicons = spawnicons + 1
				icon = pnl
			end
		end
	
		if ( spawnicons > 0 ) then
			icon:InternalAddResizeMenu( menu, function( w, h )
	
				for id, pnl in pairs( selected ) do
					if ( !pnl.InternalAddResizeMenu ) then continue end
					pnl:SetSize( w, h )
					pnl:InvalidateLayout( true )
					pnl:GetParent():OnModified()
					pnl:GetParent():Layout()
					pnl:SetModel( pnl:GetModelName(), pnl:GetSkinID(), pnl:GetBodyGroup() )
				end
	
			end, language.GetPhrase( "spawnmenu.menu.resizex" ):format( spawnicons ) )
	
			menu:AddOption( language.GetPhrase( "spawnmenu.menu.rerenderx" ):format( spawnicons ), function()
				for id, pnl in pairs( selected ) do
					if ( !pnl.RebuildSpawnIcon ) then continue end
					pnl:RebuildSpawnIcon()
				end
			end ):SetIcon( "icon16/picture.png" )
		end

		if allow["prop"] and gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") then
			local models = {}
			for k, v in pairs( selected ) do
				if !IsValid(v) then continue end
				local data = v:GetTable()
				if !data.m_strModelName then continue end
				models[data.m_strModelName] = true
			end

			addOptions(menu, "model", models, false, true, true)
		end

		if allow["entity"] and gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") then
			local entities = {}
			for k, v in pairs( selected ) do
				if !IsValid(v) then continue end
				local data = v:GetTable()
				if !data.m_SpawnName then continue end
				entities[data.m_SpawnName] = true
			end

			addOptions(menu, "entity", entities, false, true, true)
		end

		menu:AddOption( language.GetPhrase( "spawnmenu.menu.deletex" ):format( #selected ), function()

			for k, v in pairs( selected ) do
				v:Remove()
			end
	
			hook.Run( "SpawnlistContentChanged" )
	
		end ):SetIcon( "icon16/bin_closed.png" )

		menu:Open()

	end )
end)
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/modules/sh_playtime.lua:
sReward.CheckAllPlaytimes = function(ply, sec)
    if ply.GetUTimeTotalTime and ply:GetUTimeTotalTime() >= sec then return true end

    return false
end
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_basewars.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_basewars.lua:
sReward.RegisterReward("basewars_money", function(ply, amount)
    if !isfunction(ply.GiveMoney) then return end
    ply:GiveMoney(amount)
end, Material("sreward/money.png", "smooth"))

sReward.RegisterReward("basewars_level", function(ply, level)
    if !isfunction(ply.AddLevel) then return end
    ply:AddLevel(level)
end, Material("sreward/level.png", "smooth"))
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_coupon.lua:
sReward.RegisterReward("coupon", function(ply, type)
    sReward.GiveCoupon(ply, type)
end, Material("sreward/coupon.png"))
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_customcommand.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_glorifiedleveling.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_pointshop.lua:
sReward.RegisterReward("ps1_points", function(ply, points)
    if !isfunction(ply.PS_GivePoints) then return end
    ply:PS_GivePoints(points)
end, Material("sreward/points.png", "smooth"))

sReward.RegisterReward("ps2_standard_points", function(ply, points)
    if !isfunction(ply.PS2_AddStandardPoints) then return end
    ply:PS2_AddStandardPoints(points)
end, Material("sreward/points.png", "smooth"))

sReward.RegisterReward("ps2_premium_points", function(ply, points)
    if !isfunction(ply.PS2_AddPremiumPoints) then return end
    ply:PS2_AddPremiumPoints(points)
end, Material("sreward/points.png", "smooth"))

sReward.RegisterReward("sh_ps_standard_points", function(ply, points)
    if !isfunction(ply.SH_AddStandardPoints) then return end
    ply:SH_AddStandardPoints(points)
end, Material("sreward/points.png", "smooth"))

sReward.RegisterReward("sh_ps_premium_points", function(ply, points)
    if !isfunction(ply.SH_AddPremiumPoints) then return end
    ply:SH_AddPremiumPoints(points)
end, Material("sreward/points.png", "smooth"))

sReward.RegisterReward("sh_ps_item", function(ply, item)
    if !isfunction(ply.PS_GiveItem) then return end
    ply:PS_GiveItem(item)
end, Material("sreward/giftbox.png", "smooth"))
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_tokens.lua:
return gluapack()()
--PATH lua/streamradio_core/hook.lua:
return gluapack()()
--PATH lua/streamradio_core/network.lua:
return gluapack()()
--PATH lua/streamradio_core/models/kresopolski_radio.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Antoni Kresopolski: Headphone Radio Receiver
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=2891337724
RADIOMDL.model = "models/radio/antoni_kresopolski/antoni_kresopolski.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0, 0, 5)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 89.5, 1, 5)

                               --     F,     R,     U
RADIOMDL.DisplayOffset    = Vector(-4.20, -7.60, 9.38) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(-6.50, 8.5, 9.38) -- Bottom Right

RADIOMDL.DisplayWidth = 1400
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(
	RADIOMDL.DisplayOffset,
	RADIOMDL.DisplayOffsetEnd,
	RADIOMDL.DisplayWidth,
	RADIOMDL.DISPLAY_POS_TOP
)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {20,	1000},
	Error	= {17,	700},
	Default	= {20,	700},
	Tooltip	= {20,	1000},
	Big		= {20,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Error)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Error)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Error)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Error)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 27)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 27)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 3, y = 4})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 4})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 25)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 25)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 16)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 3
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/minecraft_noteblock.lua:
return gluapack()()
--PATH lua/streamradio_core/models/minecraft_noteblock.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Minecraft Noteblock
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=116592647
RADIOMDL.model = "models/mcmodelpack/blocks/noteblock.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false
RADIOMDL.SoundPosOffset = Vector( 0, 0, 18 )
RADIOMDL.SoundAngOffset = Angle( 0, 0, 0 )

return true


--PATH lua/streamradio_core/models/portal_radio.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Portal Radio
RADIOMDL.model = "models/props/radio_reference.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(3.6, 0, 3.1)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,     R,    U
RADIOMDL.DisplayOffset    = Vector(3.60, -4.70, 4.80) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(0.00,  4.70, 1.00) -- Bottom Right

RADIOMDL.DisplayWidth = 768
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {21,	1000},
	Default	= {20,	700},
	Tooltip	= {18,	800},
	Big		= {22,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 5})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 5})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 35)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 35)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 16)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/portal_speaker_big.lua:
return gluapack()()
--PATH lua/streamradio_core/models/wire_subwoofer_small.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Wire Subwoofer, Small
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=160250458
RADIOMDL.model = "models/bull/various/subwoofer.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = true

return true


--PATH lua/streamradio_core/classes/base.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/base_listener.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local LIBNetwork = StreamRadioLib.Network
local LIBNet = StreamRadioLib.Net
local LIBUtil = StreamRadioLib.Util

local emptyTableSafe = LIBUtil.EmptyTableSafe

local BASE = CLASS:GetBaseClass()

local g_listeners = {}
local g_super_listeners = {}

local g_hookname = "classsystem_listen"
local g_listengroups = 8
local g_nextgroup = 1
local g_hookruns = false
local g_fasthooksruns = false

local g_minRate = 0

for i = 1, g_listengroups do
	g_listeners[i] = {}
end

StreamRadioLib.Hook.Remove("Think", g_hookname)

local function g_listentogroup()
	-- think function with load balancing between frames for registered instances of the class system

	for i = 1, g_listengroups do
		local found = nil

		local thisgroup = g_nextgroup
		local group = g_listeners[thisgroup]

		for id, listener in pairs(group) do
			if not IsValid(listener) then
				g_listeners[thisgroup][id] = nil
				continue
			end

			if listener._markedforremove then
				g_listeners[thisgroup][id] = nil
				continue
			end

			if not listener.ThinkInternal then
				g_listeners[thisgroup][id] = nil
				continue
			end

			if not listener.Created then
				continue
			end

			local listengroupid = listener.listengroupid

			if thisgroup ~= listengroupid then
				g_listeners[thisgroup][id] = nil

				if listengroupid then
					g_listeners[listengroupid][id] = listener
				end

				continue
			end

			local listentimeout = listener._listentimeout
			if listentimeout then
				if listentimeout <= 0 then
					g_listeners[thisgroup][id] = nil
					continue
				end

				listener._listentimeout = listentimeout - 1
			end

			listener:ThinkInternal()
			found = listener
		end

		g_nextgroup = (thisgroup % g_listengroups) + 1

		-- only run the next group if this one was empty (found = nil)
		if found then
			return found
		end
	end

	return nil
end

local function g_listenfunc()
	local starttime = SysTime()

	local found = g_listentogroup()

	if found then
		found:SetGlobalVar("base_listener_thinktime", SysTime() - starttime)
		found:SetGlobalVar("base_listener_current_listeners_count", 0)
	end
end


local function g_fastlistenfunc()
	-- think function with faster rate for registered instances of the class system

	local now = RealTime()

	g_minRate = 0

	if CLIENT then
		if StreamRadioLib.IsRenderTarget() then
			g_minRate = 1 / StreamRadioLib.GetRenderTargetFPS()
			g_minRate = math.min(g_minRate, 0.1)
		end
	end

	local starttime = SysTime()

	local found = nil
	for id, listener in pairs(g_super_listeners) do
		if not IsValid(listener) then
			g_super_listeners[id] = nil
			continue
		end

		if listener._markedforremove then
			g_super_listeners[id] = nil
			continue
		end

		if not listener.FastThink then
			g_super_listeners[id] = nil
			continue
		end

		if not listener.Created then
			continue
		end

		local nextCall = listener.fastThinkNextCall or 0

		if nextCall > now then
			found = listener
			continue
		end

		listener:FastThink()

		local fastThinkRate = math.max(listener.fastThinkRate or 0, g_minRate)
		listener.fastThinkNextCall = now + fastThinkRate

		found = listener
	end

	if found then
		found:SetGlobalVar("base_listener_fastthinktime", SysTime() - starttime)
	end
end

local function g_register_thinkfunc()
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end

	if g_hookruns then return end
	if g_fasthooksruns then return end

	StreamRadioLib.Hook.Add("Think", g_hookname, function()
		if g_hookruns then
			g_listenfunc()
		end

		if g_fasthooksruns then
			g_fastlistenfunc()
		end
	end)
end

LIBNetwork.AddNetworkString(g_hookname)

LIBNet.Receive(g_hookname, function(len, ply)
	if SERVER and not IsValid(ply) then
		return
	end

	local nwent = net.ReadEntity()
	local nwname = LIBNet.ReceiveIdentifier()
	local id = LIBNet.ReceiveIdentifier()

	if not IsValid(nwent) then return end
	if not nwname then return end
	if not id then return end

	if nwname == "" then return end
	if id == "" then return end

	local classobjs_nw_register = nwent._3dstraemradio_classobjs_nw_register
	if not classobjs_nw_register then return end

	local this = classobjs_nw_register[nwname]
	if not IsValid(this) then
		return
	end

	if not this._netreceivefuncs then
		return
	end

	local thisnwent = this:GetEntity()
	if nwent ~= thisnwent then
		return
	end

	local thisnwname = this:GetNWName()
	if nwname ~= thisnwname then
		return
	end

	local func = this:GetFunction(this._netreceivefuncs[id])
	if not func then
		return
	end

	func(this, id, len, ply)
end)

function CLASS:AssignToListenGroup()
	return self:GetID()
end

function CLASS:Create()
	BASE.Create(self)

	self._profiler = {}
	self._profilertimes = {}
	self._callqueue = {}
	self._callqueueonce = {}
	self._callqueuetemp = {}
	self._netreceivefuncs = {}
	self.CanListen = true
	self.Entity = nil
	self.NWName = ''

	self.Network = self:CreateListener({
		Active = false,
	}, function(this, k, v)
		if v then
			self:ActivateNetworkedMode()
			self:ApplyNetworkedMode()
		else
			self:DeactivateNetworkedMode()
		end
	end)

	self:ApplyNetworkedMode()
end

function CLASS:Remove()
	emptyTableSafe(self._watch)
	emptyTableSafe(self._old)
	emptyTableSafe(self._profile)
	emptyTableSafe(self._callqueue)
	emptyTableSafe(self._callqueueonce)
	emptyTableSafe(self._events)

	self:RemoveFromNwRegisterInternal(self.entityClassobjsNwRegister)
	self.entityClassobjsNwRegister = nil
	self._entityTableGetter = nil

	self.Network.Active = false

	self:StopListen()
	self:StopFastThink()

	BASE.Remove(self)
end

function CLASS:CallHook(name, ...)
	self:CallEvent(name, ...)

	local func = self:GetFunction(name)
	if not func then
		return nil
	end

	local r = func(self, ...)
	return r
end

function CLASS:CallEvent(eventname, ...)
	eventname = tostring(eventname or "")

	if not self._events then return end
	if not self._events[eventname] then return end

	for k, v in pairs(self._events[eventname]) do
		local func = self:GetFunction(v)
		if not func then continue end

		func(self, ...)
	end
end

function CLASS:SetEvent(eventname, name, func)
	eventname = tostring(eventname or "")
	name = tostring(name or "")

	self._events = self._events or {}
	self._events[eventname] = self._events[eventname] or {}
	self._events[eventname][name] = func
end

function CLASS:RemoveEvent(eventname, name)
	eventname = tostring(eventname or "")
	name = tostring(name or "")

	if not self._events then return end
	if not self._events[eventname] then return end

	self._events[eventname][name] = nil
end

function CLASS:TimerGetName(identifier)
	identifier = tostring(identifier or "")

	local name = string.format("OBJ[%s][%i]_%s", self:GetClassname(), self:GetID(), identifier)
	return name
end

function CLASS:TimerInterval(identifier, delay, repetitions, func)
	local name = self:TimerGetName(identifier)

	StreamRadioLib.Timer.Remove(name)
	StreamRadioLib.Timer.Interval(name, delay, repetitions, function()
		if not IsValid(self) then
			StreamRadioLib.Timer.Remove(name)
			return
		end

		func = self:GetFunction(func)
		if not func then
			StreamRadioLib.Timer.Remove(name)
			return
		end

		func(self)
	end)
end

function CLASS:TimerOnce(identifier, delay, func)
	local name = self:TimerGetName(identifier)

	StreamRadioLib.Timer.Remove(name)
	StreamRadioLib.Timer.Once(name, delay, function()
		if not IsValid(self) then
			StreamRadioLib.Timer.Remove(name)
			return
		end

		func = self:GetFunction(func)
		if not func then return end

		func(self)
	end)
end

function CLASS:TimerUntil(identifier, delay, func)
	local name = self:TimerGetName(identifier)

	StreamRadioLib.Timer.Remove(name)
	StreamRadioLib.Timer.Until(name, delay, function()
		if not IsValid(self) then
			StreamRadioLib.Timer.Remove(name)
			return true
		end

		func = self:GetFunction(func)
		if not func then
			return true
		end

		return func(self)
	end)
end

function CLASS:TimerRemove(identifier)
	local name = self:TimerGetName(identifier)
	StreamRadioLib.Timer.Remove(name)
end

function CLASS:GetListengroup()
	return self.listengroupid
end

local function CopyValue(value)
	local t = type(value)

	if IsColor(value) then
		return Color(value.r, value.g, value.b, value.a)
	end

	if t == "Vector" then
		return Vector(value.x, value.y, value.z)
	end

	if t == "Angle" then
		return Angle(value.p, value.y, value.r)
	end

	if t == "table" then
		return table.Copy( value )
	end

	return value
end

function CLASS:CreateListener(val, func)
	local listener = {
		values = {},
		callbacks = {},
	}

	local mt = {}
	mt.__index = listener.values

	mt.__newindex = function(t, k, v)
		local values = rawget(t, "values")
		local callbacks = rawget(t, "callbacks")

		if not values then
			return
		end

		local oldv = rawget(values, k)

		if not istable(v) and not istable(oldv) and v == oldv then
			return
		end

		rawset(values, k, CopyValue(v))

		if not IsValid(self) then
			return
		end

		for i, callback in ipairs(callbacks) do
			callback = self:GetFunction(callback)

			if not callback then
				continue
			end

			callback(self, k, v, oldv)
		end
	end

	mt.__add = function(t, callback)
		if not callback then
			return t
		end

		local callbacks = rawget(t, "callbacks")
		table.insert(callbacks, callback)

		return t
	end
	mt.__concat = mt.__add

	mt.__sub = function(t, callback)
		if not callback then
			return t
		end

		local callbacks = rawget(t, "callbacks")
		table.RemoveByValue(callbacks, callback)
		return t
	end

	mt.__len = function(t, callback)
		local callbacks = rawget(t, "callbacks")
		return #callbacks
	end

	setmetatable( listener, mt )

	listener = listener + func

	for k, v in pairs(val or {}) do
		local values = rawget(listener, "values")
		if not values then break end

		rawset(values, k, CopyValue(v))
	end

	return listener
end

function CLASS:ThinkInternal()
	if not self.CanListen then
		self:StopListen()
		return
	end

	local needThink = false

	if self.Think then
		local now = RealTime()
		local nextCall = self.thinkNextCall or 0

		if nextCall < now then
			self:Think()

			local thinkRate = math.max(self.thinkRate or 0.05, g_minRate)
			self.thinkNextCall = now + thinkRate
		end

		needThink = true
	end

	local callqueuetemp = self._callqueuetemp
	local callqueue = self._callqueue
	local callqueueonce = self._callqueueonce

	if callqueuetemp then
		for k, data in pairs(callqueuetemp) do
			local func = data.func
			local args = data.args

			if not func then
				continue
			end

			func(self, unpack(args))
			needThink = true
		end
	end

	emptyTableSafe(callqueuetemp)

	if callqueue then
		for k, data in ipairs(callqueue) do
			local func = data.func

			func = self:GetFunction(func)
			if not func then
				continue
			end

			callqueuetemp[k] = {
				func = func,
				args = data.args,
			}

			needThink = true
		end
	end

	emptyTableSafe(callqueue)
	emptyTableSafe(callqueueonce)

	if not needThink then
		self:StopListen()
	end
end

function CLASS:AssignToListenGroupInternal()
	if not self.AssignToListenGroup then
		return
	end

	local listengroupid = self:AssignToListenGroup()
	listengroupid = tonumber(listengroupid)

	if not listengroupid then
		return
	end

	listengroupid = (listengroupid % g_listengroups) + 1

	self.listengroupid = listengroupid
end

function CLASS:AssignListenGroup()
	if not self.CanListen then
		return
	end

	if not self.listengroupid then
		self:AssignToListenGroupInternal()
		return
	end

	local listengroupid = self.listengroupid
	if not listengroupid then
		return
	end

	local id = self:GetID()

	g_listeners[listengroupid][id] = self
end

function CLASS:StartListen()
	if not self.CanListen then
		return
	end

	self._listentimeout = nil

	StreamRadioLib.Timedcall(function()
		if not IsValid(self) then return end
		self:AssignListenGroup()
	end)

	if g_hookruns then return end

	g_register_thinkfunc()
	g_hookruns = true
end

function CLASS:StopListen()
	if self._listentimeout then
		return
	end

	self._listentimeout = 5
end

function CLASS:StartFastThink()
	self:QueueCall("_StartFastThink")
end

function CLASS:_StartFastThink()
	self:StopFastThink()

	local id = self:GetID()
	g_super_listeners[id] = self

	if not g_fasthooksruns then
		g_register_thinkfunc()
		g_fasthooksruns = true
	end
end

function CLASS:StopFastThink()
	local id = self:GetID()
	g_super_listeners[id] = nil
end

function CLASS:SetThinkRate(rate)
	self.thinkRate = tonumber(rate or 0) or 0
end

function CLASS:GetThinkRate()
	return self.thinkRate or 0
end

function CLASS:GetThinkNextCall()
	return self.thinkNextCall or 0
end

function CLASS:SetFastThinkRate(rate)
	self.fastThinkRate = tonumber(rate or 0) or 0
end

function CLASS:GetFastThinkRate()
	return self.fastThinkRate or 0
end

function CLASS:GetFastThinkNextCall()
	return self.fastThinkNextCall or 0
end

function CLASS:IsListening()
	local id = self:GetID()
	local listengroupid = self.listengroupid

	if not listengroupid then
		return false
	end

	if not g_hookruns then
		return false
	end

	if not g_listeners[listengroupid] then
		return false
	end

	if not g_listeners[listengroupid][id] then
		return false
	end

	return false
end

function CLASS:ProfilerStart(name)
	name = tostring(name or "")

	if self._profiler[name] then
		return false
	end

	local past = SysTime()
	self._profiler[name] = past
	self._profilertimes[name] = nil

	return true
end

function CLASS:ProfilerEnd(name)
	name = tostring(name or "")
	local past = self._profiler[name]

	if not past then
		return -1
	end

	self._profiler[name] = nil

	local now = SysTime()
	local time = now - past

	self._profilertimes[name] = time
	return time
end

function CLASS:ProfilerTime(name)
	name = tostring(name or "")

	if self._profiler[name] then
		return self:ProfilerEnd(name)
	end

	return self._profilertimes[name] or -1
end

function CLASS:QueueCall(func, ...)
	if not func then return end

	if self._callqueueonce[func] then
		return
	end

	local data = {
		func = func,
		args = {...}
	}

	self._callqueueonce[func] = true
	table.insert(self._callqueue, data)

	self:StartListen()
end

function CLASS:LoadToDupeInternal(dupeTable)
	if not SERVER then return end
	if not istable(dupeTable) then return end

	local name = self:GetName()
	if name == "" then return end

	dupeTable[name] = self:CallHook("PreDupe")
end

function CLASS:LoadToDupe(dupeTable)
	if not SERVER then return end
	if not istable(dupeTable) then return end

	self:LoadToDupeInternal(dupeTable)
end

function CLASS:LoadFromDupeInternal(dupeTable)
	if not SERVER then return end
	if not istable(dupeTable) then return end

	local name = self:GetName()
	if name == "" then return end

	local data = dupeTable[name]
	if data == nil then return end

	self:CallHook("PostDupe", data)
end

function CLASS:LoadFromDupe(dupeTable)
	if not SERVER then return end
	if not istable(dupeTable) then return end

	self:LoadFromDupeInternal(dupeTable)
end

function CLASS:SetName(name)
	name = tostring(name or "")
	name = string.gsub(name, "[%/%\\%s]", "_")

	self.Name = name
end

function CLASS:GetReferenceClassobjsNWRegister()
	return self.entityClassobjsNwRegister
end

function CLASS:SetReferenceClassobjsNWRegister(nwRegister)
	if not istable(nwRegister) then
		return
	end

	self.entityClassobjsNwRegister = nwRegister
end

function CLASS:AddToNwRegisterInternal(nwRegister)
	if not istable(nwRegister) then
		return
	end

	local nwname = self:GetNWName()
	if not nwname then
		return
	end

	if nwname == "" then
		return
	end

	nwRegister[nwname] = self
	self:SetReferenceClassobjsNWRegister(nwRegister)
end

function CLASS:RemoveFromNwRegisterInternal(nwRegister)
	if not istable(nwRegister) then
		return
	end

	local nwname = self:GetNWName()
	if not nwname then
		return
	end

	if nwname == "" then
		return
	end

	nwRegister[nwname] = nil
	self:SetReferenceClassobjsNWRegister(nwRegister)
end

function CLASS:AddToNwRegister(nwRegister)
	self:AddToNwRegisterInternal(nwRegister)
end

function CLASS:RemoveFromNwRegister(nwRegister)
	self:RemoveFromNwRegisterInternal(nwRegister)
end

function CLASS:GetEntity()
	return self.Entity
end

function CLASS:GetEntityTable()
	if not self._entityTableGetter then
		return nil
	end

	return self._entityTableGetter()
end

function CLASS:SetEntity(ent)
	if not IsValid(ent) then
		self.Entity = nil
		self._entityTableGetter = nil

		self:RemoveFromNwRegister(self.entityClassobjsNwRegister)

		self:ApplyNetworkedMode()
		return
	end

	self.Entity = ent
	local entTable = ent:GetTable()

	self._entityTableGetter = function()
		-- avoid storing the entity table directly, so we dont leak memory
		return entTable
	end

	self:SetReferenceClassobjsNWRegister(entTable._3dstraemradio_classobjs_nw_register)

	self:ApplyNetworkedMode()
end

function CLASS:SetNWName(nwname)
	nwname = tostring(nwname or "")
	nwname = string.gsub(nwname, "[%/%\\%s]", "_")

	self.NWName = nwname
	self:ApplyNetworkedMode()
end

function CLASS:GetNWName(name)
	return self.NWName or ""
end

do
	local loopThis = function(funcName, func)
		if not isfunction(func) then return end

		if funcName == "SetNWVarCallback" then return end
		if not string.find(funcName, "^[G|S]etNW") then return end

		CLASS[funcName] = function(this, key, value, ...)
			if not this.Valid then return value end

			local entTable = this:GetEntityTable()
			if not entTable then return value end

			local prefix = this:GetNWName()  .. "/"
			key = prefix .. tostring(key or "")

			local r = func(entTable, key, value, ...)

			if r == nil then
				r = value
			end

			return r
		end
	end

	for funcName, func in pairs(LIBNetwork) do
		loopThis(funcName, func)
	end
end

function CLASS:SetNWVarCallback(key, datatype, func, ...)
	if not self.Valid then return end

	local entTable = self:GetEntityTable()
	if not entTable then return end

	func = self:GetFunction(func)
	assert(func, "argument #2 must be a function!")

	local prefix = self:GetNWName() .. "/"
	key = prefix .. tostring(key or "")

	local prefixReg = "^" .. string.PatternSafe(prefix)

	local proxyfunc = function(this, nwkey, ...)
		if not IsValid(self) then return end
		if not self.Network.Active then return end

		nwkey = string.gsub(nwkey, prefixReg, "", 1 )

		self._nw_proxycall = true
		local ret = {func(self, nwkey, ...)}
		self._nw_proxycall = nil

		return unpack(ret)
	end

	return LIBNetwork.SetNWVarCallback(entTable, datatype, key, proxyfunc, ...)
end

function CLASS:NetReceive(id, func)
	id = tostring(id or "")
	if id == "" then return end

	local nwname = self:GetNWName()

	if nwname and nwname ~= "" then
		LIBNetwork.AddNetworkString(nwname)
	end

	LIBNetwork.AddNetworkString(id)
	self._netreceivefuncs[id] = func
end

function CLASS:NetSend(id, func, sendfunc, ...)
	if not self.Network.Active then return end

	id = tostring(id or "")
	if id == "" then return end

	local ent = self:GetEntity()
	local nwname = self:GetNWName()

	if not IsValid(ent) then return end
	if not nwname then return end
	if nwname == "" then return end

	LIBNetwork.AddNetworkString(nwname)
	LIBNetwork.AddNetworkString(id)

	LIBNet.Start(g_hookname, false)

	net.WriteEntity(ent)
	LIBNet.SendIdentifier(nwname)
	LIBNet.SendIdentifier(id)

	func = self:GetFunction(func)
	if func then
		func(self)
	end

	if CLIENT then
		net.SendToServer()
		return
	end

	if not sendfunc then
		net.Broadcast()
		return
	end

	sendfunc(...)
end

function CLASS:NetSendToPlayers(id, func, playerlist)
	if CLIENT then
		return
	end

	local playerlist = table.ClearKeys(playerlist or {})
	if #playerlist <= 0 then return end

	self:NetSend(id, func, net.Send, playerlist)
end

function CLASS:ApplyNetworkedMode()
	if not self.Network.Active then return end
	self:QueueCall("ActivateNetworkedMode")
end

function CLASS:ApplyNetworkVars()
	if not CLIENT then return end
	if not self.Network.Active then return end
	if self._nw_proxycall then return end
	if self._nw_applycall then return end

	self._nw_applycall = true
	self:ApplyNetworkVarsInternal()
	self._nw_applycall = nil
end

function CLASS:ApplyNetworkVarsInternal()
	-- override me
end

function CLASS:ActivateNetworkedMode()
	self.Network.Active = true

	if CLIENT then
		self._nw_applycall = true
		self:ApplyNetworkVarsInternal()
		self._nw_applycall = nil
	end

	local nwname = self:GetNWName()
	LIBNetwork.AddNetworkString(nwname)

	self:AddToNwRegister(self:GetReferenceClassobjsNWRegister())
end

function CLASS:DeactivateNetworkedMode()
	self.Network.Active = false
end

function CLASS:PreDupe()
	return nil
end

function CLASS:PostDupe(data)
end

return true


--PATH lua/streamradio_core/classes/ui/debug.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/scrollbar.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

local g_mat_up = StreamRadioLib.GetPNGIcon("scroll_up", true)
local g_mat_down = StreamRadioLib.GetPNGIcon("scroll_down", true)
local g_mat_left = StreamRadioLib.GetPNGIcon("scroll_left", true)
local g_mat_right = StreamRadioLib.GetPNGIcon("scroll_right", true)

function CLASS:Create()
	BASE.Create(self)

	self.Layout.IsHorizontal = true

	self.Scroll = self:CreateListener({
		Pos = 0,
		Max = 0,
	}, function(this, k, v)
		self:InvalidateLayout()

		if k == "Max" then
			if v < 0 then
				v = 0
				self.Scroll.Max = v
				return
			end

			self:SetNWInt("ScrollMax", v)
			self:CallHook("OnScroll", self:GetScroll())
		end

		if k == "Pos" then
			if v < 0 then
				v = 0
				self.Scroll.Pos = v
				return
			end

			self:SetNWInt("ScrollPos", v)
			self:CallHook("OnScroll", v)
		end
	end)

	self.BarButton = self:AddPanelByClassname("button", true)
	self.BarButton:SetName("bar")
	self.BarButton:SetNWName("bar")
	self.BarButton:SetSkinIdentifyer("bar")
	self:_TreatIconAsText(self.BarButton)

	self.BarButton.DoClick = function()
		if self:IsInputDisabled() then return end
		self:DoClick()

		self.BarButton.IsPressed = false
		self.IsPressed = true

		local sp = self:GetSuperParent()
		sp.LastClickedPanel = self
	end

	self.BarButton.OnMouseReleased = function()
		if self:IsInputDisabled() then return end
		self:OnMouseReleased()
	end

	self.LeftUpButton = self:AddPanelByClassname("button", true)
	self.LeftUpButton:SetName("left-up")
	self.LeftUpButton:SetNWName("lup")
	self.LeftUpButton:SetSkinIdentifyer("button")
	self:_TreatIconAsText(self.LeftUpButton)

	self.LeftUpButton.DoClick = function()
		if self:IsInputDisabled() then return end
		self:SetScroll(self:GetScroll() - 1)
	end

	self.RightDownButton = self:AddPanelByClassname("button", true)
	self.RightDownButton:SetName("right-down")
	self.RightDownButton:SetNWName("rdn")
	self.RightDownButton:SetSkinIdentifyer("button")
	self:_TreatIconAsText(self.RightDownButton)

	self.RightDownButton.DoClick = function()
		if self:IsInputDisabled() then return end
		self:SetScroll(self:GetScroll() + 1)
	end

	self:QueueCall("ClearInvisible")
end

function CLASS:_TreatIconAsText(button)
	if not IsValid(button) then return end

	button.SkinMap = button.SkinMap or {}

	button.SkinMap["color_foreground"] = {
		set = "SetIconColor",
		get = "GetIconColor",
	}

	button.SkinMap["color_foreground_hover"] = {
		set = "SetIconHoverColor",
		get = "GetIconHoverColor",
	}

	button.SkinMap["color_foreground_disabled"] = {
		set = "SetIconDisabledColor",
		get = "GetIconDisabledColor",
	}

	button.SkinMap["color_icon"] = nil
	button.SkinMap["color_icon_hover"] = nil
	button.SkinMap["color_icon_disabled"] = nil

	button:SetText("")
	button.SetText = (function() end)
end


local function GetBarSpaceSize(len, margin, buttonsize)
	return len - (buttonsize + margin) * 2
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	local lu_button = self.LeftUpButton
	local rd_button = self.RightDownButton
	local bar_button = self.BarButton

	if not IsValid(lu_button) then
		return
	end

	if not IsValid(rd_button) then
		return
	end

	if not IsValid(bar_button) then
		return
	end

	local ishorizontal = self:GetHorizontal()
	local buttonsize = self:GetSquareSize()

	lu_button:SetSize(buttonsize, buttonsize)
	rd_button:SetSize(buttonsize, buttonsize)

	-- Force position change trigger
	lu_button:SetPos(0, 1)
	lu_button:SetPos(0, 0)

	local w, h = self:GetClientSize()
	local margin = self:GetMargin()
	local scoll = self:GetScroll()
	local maxscoll = self:GetMaxScroll() + 1
	local minbarsize = buttonsize / 2

	local noscroll = maxscoll <= 1

	lu_button:SetDisabled(noscroll or scoll <= 0)
	rd_button:SetDisabled(noscroll or scoll >= (maxscoll - 1))
	bar_button:SetDisabled(noscroll)
	self:SetDisabled(noscroll)

	if ishorizontal then
		local len = GetBarSpaceSize(w, margin, buttonsize)
		self.ScrollLen = len

		local barsize = len / maxscoll
		local barpos = buttonsize + margin + barsize * scoll

		if barsize < minbarsize then
			barsize = minbarsize
		end

		local maxbarpos = len - barsize + buttonsize + margin
		if barpos > maxbarpos then
			barpos = maxbarpos
		end

		bar_button:SetPos(barpos, 0)
		bar_button:SetSize(barsize, buttonsize)
		rd_button:SetPos(w - buttonsize, 0)

		lu_button:SetIcon(g_mat_left)
		rd_button:SetIcon(g_mat_right)
	else
		local len = GetBarSpaceSize(h, margin, buttonsize)
		self.ScrollLen = len

		local barsize = len / maxscoll
		local barpos = buttonsize + margin + barsize * scoll

		if barsize < minbarsize then
			barsize = minbarsize
		end

		local maxbarpos = len - barsize + buttonsize + margin
		if barpos > maxbarpos then
			barpos = maxbarpos
		end

		bar_button:SetPos(0, barpos)
		bar_button:SetSize(buttonsize, barsize)
		rd_button:SetPos(0, h - buttonsize)

		lu_button:SetIcon(g_mat_up)
		rd_button:SetIcon(g_mat_down)
	end

	lu_button:QueueCall("ClearInvisible")
	rd_button:QueueCall("ClearInvisible")
	bar_button:QueueCall("ClearInvisible")
end

function CLASS:DoScroll()
	BASE.CursorChangedInternal(self)

	local lu_button = self.LeftUpButton
	local rd_button = self.RightDownButton
	local bar_button = self.BarButton
	local scrolllen = self.ScrollLen

	if not IsValid(lu_button) then
		return
	end

	if not IsValid(rd_button) then
		return
	end

	if not IsValid(bar_button) then
		return
	end

	if not scrolllen then
		return
	end

	local cx, cy = self:GetCursorRelative()

	local ishorizontal = self:GetHorizontal()
	local buttonsize = self:GetSquareSize()

	local margin = self:GetMargin()
	local shadow = bar_button:GetShadowWidth()
	local maxscoll = self:GetMaxScroll() + 1
	local scroll = 0

	cx = cx - buttonsize
	cy = cy - buttonsize

	local maxcx = buttonsize - shadow
	local maxcy = maxcx

	if ishorizontal then
		local barsize = scrolllen / maxscoll
		if barsize <= 0 then return end

		scroll = cx / barsize
	else
		local barsize = scrolllen / maxscoll
		if barsize <= 0 then return end

		scroll = cy / barsize
	end

	if scroll < 0 then return end
	if scroll > maxscoll then return end

	self:SetScroll(scroll)
end

function CLASS:Think()
	self.thinkRate = 0.1

	local lu_button = self.LeftUpButton
	local rd_button = self.RightDownButton
	local scrolllen = self.ScrollLen

	if not IsValid(lu_button) then
		self.tmpscroll = nil
		return
	end

	if not IsValid(rd_button) then
		self.tmpscroll = nil
		return
	end

	if not scrolllen then
		self.tmpscroll = nil
		return
	end

	if not lu_button.IsPressed and not rd_button.IsPressed then
		self.tmpscroll = nil
		return
	end

	if lu_button.IsPressed and rd_button.IsPressed then
		self.tmpscroll = nil
		return
	end

	local acive_button = lu_button
	local scolldir = -1

	if rd_button.IsPressed then
		acive_button = rd_button
		scolldir = 1
	end

	local scoll = self.tmpscroll or self:GetScroll()
	local maxscoll = self:GetMaxScroll()
	local scollrate = 10

	local lastclicktime = acive_button.LastClickTime or 0
	local clickdistance = RealTime() - lastclicktime

	local lastthink = self.lastthink or RealTime()
	self.lastthink = RealTime()

	local thinkdistance = RealTime() - lastthink

	if clickdistance > 0.5 then
		self.tmpscroll = scoll + scolldir * thinkdistance * scollrate
		self:SetScroll(self.tmpscroll)
	end
end

function CLASS:CursorChangedInternal()
	BASE.CursorChangedInternal(self)

	if not self.IsPressed then return end
	self:DoScroll()
end

function CLASS:DoClick()
	self:DoScroll()
end

function CLASS:OnMouseReleased()
	self:DoScroll()
end

function CLASS:SetScroll(scroll)
	self.Scroll.Pos = math.Clamp(math.floor(scroll or 0), 0, self.Scroll.Max)
end

function CLASS:GetScroll()
	return math.Clamp(self.Scroll.Pos, 0, self.Scroll.Max)
end

function CLASS:SetMaxScroll(max)
	max = max or 0

	if max <= 0 then
		max = 0
	end

	self.Scroll.Max = math.floor(max)
end

function CLASS:GetMaxScroll()
	return self.Scroll.Max or 0
end

function CLASS:IsScrollAble()
	return self:GetMaxScroll() > 0
end

function CLASS:SetHorizontal(horizontal)
	self.Layout.IsHorizontal = horizontal or false
end

function CLASS:GetHorizontal()
	return self.Layout.IsHorizontal or false
end

function CLASS:AutoSetHorizontal()
	local w, h = self:GetClientSize()
	self:SetHorizontal(w >= h)
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)
	if SERVER then
		self:SetNWInt("ScrollPos", self.Scroll.Pos or 0)
		self:SetNWInt("ScrollMax", self:GetMaxScroll())

		return
	end

	self:SetNWVarCallback("ScrollPos", "Int", function(this, nwkey, oldvar, newvar)
		self.Scroll.Pos = newvar
	end)

	self:SetNWVarCallback("ScrollMax", "Int", function(this, nwkey, oldvar, newvar)
		self:SetMaxScroll(newvar)
	end)

	self.Scroll.Pos = self:GetNWInt("ScrollPos", 0)
	self:SetMaxScroll(self:GetNWInt("ScrollMax", 0))
end

function CLASS:PreDupe()
	local data = {}

	data.Scroll = self:GetScroll()

	return data
end

function CLASS:PostDupe(data)
	self:SetScroll(data.Scroll)
	self.DupeData = data
end

function CLASS:SetColor(...)
	if SERVER then return end

	self.LeftUpButton:SetColor(...)
	self.RightDownButton:SetColor(...)
	self.BarButton:SetColor(...)
end

function CLASS:GetColor(...)
	if SERVER then return end
	return self.BarButton:GetColor(...)
end

function CLASS:SetHoverColor(...)
	if SERVER then return end

	self.LeftUpButton:SetHoverColor(...)
	self.RightDownButton:SetHoverColor(...)
	self.BarButton:SetHoverColor(...)
end

function CLASS:GetHoverColor(...)
	if SERVER then return end
	return self.BarButton:GetHoverColor(...)
end

function CLASS:SetDisabledColor(...)
	if SERVER then return end

	self.LeftUpButton:SetDisabledColor(...)
	self.RightDownButton:SetDisabledColor(...)
	self.BarButton:SetDisabledColor(...)
end

function CLASS:GetDisabledColor(...)
	if SERVER then return end
	return self.BarButton:GetDisabledColor(...)
end

function CLASS:SetTextColor(...)
	if SERVER then return end

	self.LeftUpButton:SetTextColor(...)
	self.RightDownButton:SetTextColor(...)
	self.BarButton:SetTextColor(...)
end

function CLASS:GetTextColor(...)
	if SERVER then return end
	return self.BarButton:GetTextColor(...)
end

function CLASS:SetTextHoverColor(...)
	if SERVER then return end

	self.LeftUpButton:SetTextHoverColor(...)
	self.RightDownButton:SetTextHoverColor(...)
	self.BarButton:SetTextHoverColor(...)
end

function CLASS:GetTextHoverColor(...)
	if SERVER then return end
	return self.BarButton:GetTextHoverColor(...)
end

function CLASS:SetTextDisabledColor(...)
	if SERVER then return end

	self.LeftUpButton:SetTextDisabledColor(...)
	self.RightDownButton:SetTextDisabledColor(...)
	self.BarButton:SetTextDisabledColor(...)
end

function CLASS:GetTextDisabledColor(...)
	if SERVER then return end
	return self.BarButton:GetTextDisabledColor(...)
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.font then
		self:SetFont(setup.font)
	end
end

return true


--PATH lua/streamradio_core/classes/ui/tooltip.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.TextPanel = self:AddPanelByClassname("text", true)
	self.TextPanel:SetPos(0, 0)
	self.TextPanel:SetSize(350, 1)
	self.TextPanel:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	self.TextPanel:SetName("text")
	self.TextPanel:SetNWName("txt")
	self.TextPanel:SetSkinIdentifyer("text")
	self.TextPanel:SetStartLine(0)

	self:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

	self.SkinMap["color_foreground"] = {
		set = "SetTextColor",
		get = "GetTextColor",
	}

	self.TextPanel.OnTextChange = function(pnl)
		if not IsValid(self) then return end
		self.TextPanel:FitToText(75, self:GetMaxWidth())
		self:InvalidateLayout()
		self:CallHook("OnTextChange")
	end

	self.TextPanel.OnFontChange = function(pnl)
		if not IsValid(self) then return end
		self.TextPanel:FitToText(75, self:GetMaxWidth())
		self:InvalidateLayout()
		self:CallHook("OnFontChange")
	end

	self.TextPanel.OnAlignChange = function(pnl)
		if not IsValid(self) then return end
		self:InvalidateLayout()
		self:CallHook("OnAlignChange")
	end

	if CLIENT then
		self.Colors.Main = Color(0, 0, 0, 192)
		self:SetTextColor(Color(255, 255, 255, 255))
	end

	local CalcSize = function(this, k, v)
		if k ~= "MaxWidth" then return end

		if not IsValid(self.TextPanel) then
			return
		end

		self.TextPanel:FitToText(75, v)
		self:InvalidateLayout()
	end

	self.Size = self.Size + CalcSize

	self.Clickable = false
	self.SkinAble = false

	self:SetPadding(10)
	self:SetMaxWidth(350)
	self:InvalidateLayout()
end

function CLASS:SetMaxWidth(maxw)
	self.Size.MaxWidth = math.max(maxw or 0, 75)
end

function CLASS:GetMaxWidth()
	return self.Size.MaxWidth or 0
end

function CLASS:Render()
	local text_panel = self.TextPanel
	if not IsValid(text_panel) then
		return
	end

	local x, y = self:GetRenderPos()
	local w, h = self:GetSize()

	local colText = self:GetTextColor()
	colText = colText or color_white

	local colMain = self.Colors.Main or color_black

	local thickness = 2
	local padding = 2

	surface.SetDrawColor(colText:Unpack())

	for i = 0, thickness - 1 do
		local t = i + padding
		local tt = t * 2

		surface.DrawOutlinedRect(x + t, y + t, w - tt, h - tt)
	end

	surface.SetDrawColor(colMain:Unpack())
	surface.DrawRect(x, y, w, h)

	BASE.Render(self)
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	local text_panel = self.TextPanel
	if not IsValid(text_panel) then
		return
	end

	local padding = self:GetPadding()
	local w, h = text_panel:GetSize()
	local nw, nh = w + padding * 2, h + padding * 2

	self:SetSize(nw, nh)
end

function CLASS:GetTextAlign(...)
	return self:GetAlign(...)
end

function CLASS:SetTextAlign(...)
	return self:SetAlign(...)
end

function CLASS:GetAlign(...)
	return self.TextPanel:GetAlign(...)
end

function CLASS:SetAlign(...)
	return self.TextPanel:SetAlign(...)
end

function CLASS:SetText(...)
	return self.TextPanel:SetText(...)
end

function CLASS:GetText(...)
	return self.TextPanel:GetText(...)
end

function CLASS:SetFont(...)
	return self.TextPanel:SetFont(...)
end

function CLASS:GetFont(...)
	return self.TextPanel:GetFont(...)
end

function CLASS:SetTextColor(...)
	return self.TextPanel:SetColor(...)
end

function CLASS:GetTextColor(...)
	return self.TextPanel:GetColor(...)
end

function CLASS:IsInBounds(x, y)
	return false
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.font then
		self:SetFont(setup.font)
	end
end

return true


--PATH lua/streamradio_core/classes/ui/radio/list_playlists.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/clientconvar.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

local g_types = {
	["string"] = {
		get = function(this, cv)
			return cv:GetString()
		end,

		set = function(this, cv, val)
			cv:SetString(tostring(val or ""))
		end,

		panel_function = function(this, mainpanel, ...)
			return mainpanel:TextEntry(
				this:GetPanellabel(),
				this:GetCMD()
			)
		end,
	},

	["float"] = {
		get = function(this, cv)
			local val = cv:GetFloat()
			val = math.Clamp(val, this:GetMin(), this:GetMax())

			return val
		end,

		set = function(this, cv, val)
			local val = tonumber(val or 0) or 0
			val = math.Clamp(val, this:GetMin(), this:GetMax())

			cv:SetFloat(val)
		end,

		panel_function = function(this, mainpanel, ...)
			return mainpanel:NumSlider(
				this:GetPanellabel(),
				this:GetCMD(),
				this:GetMin(),
				this:GetMax(),
				3
			)
		end,
	},

	["int"] = {
		get = function(this, cv)
			local val = cv:GetInt()
			val = math.Clamp(val, this:GetMin(), this:GetMax())

			return val
		end,

		set = function(this, cv, val)
			local val = tonumber(val or 0) or 0
			val = math.Clamp(val, this:GetMin(), this:GetMax())

			cv:SetInt(val)
		end,

		panel_function = function(this, mainpanel, ...)
			return mainpanel:NumSlider(
				this:GetPanellabel(),
				this:GetCMD(),
				this:GetMin(),
				this:GetMax(),
				0
			)
		end,
	},

	["bool"] = {
		get = function(this, cv)
			return cv:GetBool()
		end,

		set = function(this, cv, val)
			cv:SetBool(tobool(val) and (val ~= ""))
		end,

		panel_function = function(this, mainpanel, ...)
			return mainpanel:CheckBox(
				this:GetPanellabel(),
				this:GetCMD()
			)
		end,
	},

	["numpad"] = {
		get = function(this, cv)
			local val = cv:GetInt()
			val = math.Clamp(val, 0, 255)

			return val
		end,

		set = function(this, cv, val)
			local val = tonumber(val or 0) or 0
			val = math.Clamp(val, 0, 255)

			cv:SetInt(val)
		end,

		panel_function = function(this, mainpanel, ...)
			local ctrlNumPad = vgui.Create("CtrlNumPad", mainpanel)
			ctrlNumPad:SetConVar1(this:GetCMD())
			ctrlNumPad:SetLabel1(this:GetPanellabel())

			mainpanel:AddPanel(ctrlNumPad)
			return ctrlNumPad
		end,
	},
}

function CLASS:Create()
	BASE.Create(self)

	self.cmd = ""
	self.defaultvalue = ""
	self.save = true
	self.userdata = false
	self.helptext = ""
	self.type = "string"
	self.hidden = false
	self.disabled = false
	self.options = {}

	self._convar = nil
end

function CLASS:SetCMD(var)
	if self._convar then return end
	self.cmd = tostring(var or "")
end

function CLASS:GetCMD()
	return self.cmd or ""
end

function CLASS:SetDefault(var)
	if self._convar then return end
	self.defaultvalue = tostring(var or "")
end

function CLASS:GetDefault()
	return self.defaultvalue or ""
end

function CLASS:SetSave(var)
	if self._convar then return end
	self.save = var or false
end

function CLASS:GetSave()
	return self.save or false
end

function CLASS:SetUserdata(var)
	if self._convar then return end
	self.userdata = var or false
end

function CLASS:GetUserdata()
	return self.userdata or false
end

function CLASS:SetDefault(var)
	if self._convar then return end
	self.defaultvalue = tostring(var or "")
end

function CLASS:GetDefault()
	return self.defaultvalue or ""
end

function CLASS:SetHelptext(var)
	if self._convar then return end
	self.helptext = tostring(var or "")
end

function CLASS:GetHelptext()
	return self.helptext or ""
end

function CLASS:SetOptions(var)
	if self._convar then return end
	self.options = var or {}
end

function CLASS:GetOptions()
	return self.options or {}
end

function CLASS:SetHidden(var)
	self.hidden = var or false
end

function CLASS:GetHidden()
	return self.hidden or false
end

function CLASS:SetDisabled(var)
	self.disabled = var or false
end

function CLASS:GetDisabled()
	return self.disabled or false
end

function CLASS:SetPanellabel(var)
	self.panellabel = tostring(var or "")
end

function CLASS:GetPanellabel()
	return self.panellabel or ""
end

function CLASS:GetConvar()
	return self._convar
end

function CLASS:SetType(var)
	if self._convar then return end

	var = tostring(var or "")
	var = string.lower(var)
	var = string.Trim(var)

	if var == "" then
		var = "string"
	end

	self.type = var
end

function CLASS:GetType(var)
	return self.type or ""
end

function CLASS:GetTypeData()
	local t = self:GetType()
	local data = g_types[t] or g_types["string"] or {}

	return data
end

function CLASS:GetMax()
	return self.MaxValue or 0
end

function CLASS:GetMin()
	return self.MinValue or 0
end

function CLASS:SetMax(var)
	if self._convar then return end
	self.MaxValue = var or 0
end

function CLASS:SetMin(var)
	if self._convar then return end
	self.MinValue = var or 0
end

function CLASS:GetValue(...)
	if not self._convar then
		return nil
	end

	local td = self:GetTypeData()
	local getter = td.get

	if not getter then
		return nil
	end

	return getter(self, self._convar, ...)
end

function CLASS:SetValue(...)
	if not self._convar then
		return nil
	end

	local td = self:GetTypeData()
	local setter = td.set

	if not setter then
		return nil
	end

	return setter(self, self._convar, ...)
end

function CLASS:BuildPanel(mainpanel, ...)
	if not self._convar then
		return nil
	end

	if not IsValid(mainpanel) then
		return nil
	end

	local td = self:GetTypeData()
	local panel_function = td.panel_function

	if not panel_function then
		return nil
	end

	if self:GetHidden() then
		return nil
	end

	local panel = panel_function(self, mainpanel, ...)
	if not IsValid(panel) then
		return nil
	end

	if self:GetDisabled() then
		panel:SetEnabled(false)
	end

	return panel
end

function CLASS:Setup()
	if SERVER then return end

	local cmd = self:GetCMD()

	self._convar = CreateClientConVar(cmd, self:GetDefault(), self:GetSave(), self:GetUserdata(), self:GetHelptext())
	if not self._convar then return end

	self:AddCallback()
end

function CLASS:RemoveCallback()
	if SERVER then return end
	if not self._convar then return end

	local cmd = self:GetCMD()
	cvars.RemoveChangeCallback(cmd, cmd .. "_callback")
end

function CLASS:AddCallback()
	if SERVER then return end
	if not self._convar then return end

	self:RemoveCallback()

	local oldvalue = self:GetValue()

	local cmd = self:GetCMD()
	cvars.AddChangeCallback(cmd, function()
		if not IsValid(self) then return end

		local newvalue = self:GetValue()
		if oldvalue == newvalue then return end

		self:CallHook("OnChange", oldvalue, newvalue)

		oldvalue = newvalue
	end, cmd .. "_callback")
end

function CLASS:Remove()
	self:RemoveCallback()
	self._convar = nil
	BASE.Remove(self)
end

return true


--PATH lua/streamradio_core/vr.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.VR = StreamRadioLib.VR or {}

local LIB = StreamRadioLib.VR
table.Empty(LIB)

function LIB.IsInstalled()
	return istable(vrmod)
end

function LIB.IsActive(ply)
	if not LIB.IsInstalled() then return false end

	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then return false end
	if not ply:IsPlayer() then return false end
	if ply:IsBot() then return false end

	return vrmod.IsPlayerInVR(ply)
end

function LIB.Debug(txt)
	if not LIB.IsActive() then return end

	txt = tostring(txt)
	if txt == "" then return end

	if CLIENT then
		chat.AddText(txt)
	else
		MsgN(txt)
	end
end

function LIB.GetControlPosDir(ply)
	if not LIB.IsInstalled() then return nil end

	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then return nil end

	-- Only allow for Hands
	if not LIB.HandsEquipped(ply) then
		return nil
	end

	-- Check if the player can make inputs at all
	if not LIB.GetVREnableTrigger(ply) and not LIB.GetVREnableTouch(ply) then
		return nil
	end

	-- Only allow if there is no focus on any menu
	if LIB.MenuIsOpen() then
		return nil
	end

	local pos, ang = vrmod.GetRightHandPose(ply)
	if not pos or not ang then
		return nil
	end

	local dir = ang:Forward()
	return pos, dir
end

function LIB.GetCameraPos(ply)
	if not LIB.IsInstalled() then return nil end

	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then return nil end

	local pos, ang = vrmod.GetHMDPose(ply)
	if not pos then
		return nil
	end

	if not ang then
		return nil
	end

	return pos, ang
end

function LIB.HandsEquipped(ply)
	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then
		return false
	end

	if ply:InVehicle() then
		return true
	end

	return vrmod.UsingEmptyHands(ply)
end

function LIB.GetTriggerPressed()
	if not CLIENT then
		return false
	end

	if not LIB.IsActive() then
		return false
	end

	if not LIB.GetVREnableTrigger() then
		return false
	end

	if not LIB.HandsEquipped() then
		return false
	end

	return vrmod.GetInput("boolean_primaryfire") or false
end

function LIB.GetRadioTouched()
	if not CLIENT then
		return false
	end

	if not LIB.GetVREnableTouch() then
		return false
	end

	if not LIB.HandsEquipped() then
		return false
	end

	local trace = LIB.TraceHand()
	if not trace then
		return false
	end

	if not trace.Hit then
		return false
	end

	local ent = trace.Entity

	if not IsValid(ent) then
		return false
	end

	if not ent.__IsRadio then
		return false
	end

	return true
end

local g_PlayerHandTraceCache = nil
local g_PlayerHandTrace = {}

g_PlayerHandTrace.output = {}
g_PlayerHandTrace.filter = {}

function LIB.TraceHand()
	if not CLIENT then
		return nil
	end

	if not LIB.IsActive() then
		g_PlayerHandTraceCache = nil
		return nil
	end

	if g_PlayerHandTraceCache and StreamRadioLib.Util.IsSameFrame("StreamRadioLib.VR.TraceHand") then
		return g_PlayerHandTraceCache
	end

	g_PlayerHandTraceCache = nil

	local pos, dir = LIB.GetControlPosDir()

	if not pos then
		return nil
	end

	if not dir then
		return nil
	end

	local start_pos = pos
	local end_pos = pos + dir * 6.5

	g_PlayerHandTrace.start = start_pos
	g_PlayerHandTrace.endpos = end_pos

	local ply = LocalPlayer()
	local plyVehicle = ply.GetVehicle and ply:GetVehicle() or false

	local tmp = {}

	tmp[ply] = ply
	tmp[plyVehicle] = plyVehicle

	local filter = g_PlayerHandTrace.filter
	table.Empty(filter)

	for _, filterEnt in pairs(tmp) do
		if not IsValid(filterEnt) then continue end
		table.insert(filter, filterEnt)
	end

	util.TraceLine(g_PlayerHandTrace)
	g_PlayerHandTraceCache = g_PlayerHandTrace.output

	return g_PlayerHandTraceCache
end

function LIB.GetVREnableTouch(ply)
	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not LIB.IsActive(ply) then return false end
	return tobool(ply:GetInfo("cl_streamradio_vr_enable_touch"))
end

function LIB.GetVREnableTrigger(ply)
	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not LIB.IsActive(ply) then return false end
	return tobool(ply:GetInfo("cl_streamradio_vr_enable_trigger"))
end

function LIB.GetMenuUid(panel)
	if not panel then
		return nil
	end

	if isstring(panel) then
		if panel == "" then
			return nil
		end

		return panel, LIB.g_openMenus and LIB.g_openMenus[panel]
	end

	local curPanel = panel

	while true do
		if not IsValid(curPanel) then
			return nil
		end

		if curPanel == g_SpawnMenu then
			return "spawnmenu", curPanel
		end

		if curPanel == g_ContextMenu then
			return "spawnmenu", curPanel
		end

		local uid = tostring(curPanel._streamradio_vr_uid or "")
		if uid ~= "" then
			return uid, curPanel
		end

		curPanel = curPanel:GetParent()
	end

	return nil
end

function LIB.MenuIsOpen(panelOrUid)
	if not CLIENT then
		return false
	end

	if not LIB.IsActive() then
		return false
	end

	if not panelOrUid then
		panelOrUid = vrmod.MenuFocused()
	end

	panelOrUid = LIB.GetMenuUid(panelOrUid)

	if not panelOrUid then
		return false
	end

	if not vrmod.MenuExists(panelOrUid) then
		return false
	end

	return true
end

function LIB.CloseMenu(panel)
	if not CLIENT then
		return
	end

	local uid, mainPanel = LIB.GetMenuUid(panel)
	if not uid then
		return
	end

	if not IsValid(mainPanel) then
		mainPanel = panel
	end

	LIB.g_openMenus = LIB.g_openMenus or {}
	LIB.g_openMenus[uid] = nil

	if ispanel(mainPanel) then
		mainPanel:Close()
	end

	if not LIB.MenuIsOpen(uid) then
		return
	end

	vrmod.MenuClose(uid)
end

function LIB.RenderMenu(panel)
	if not CLIENT then
		return
	end

	local uid, mainPanel = LIB.GetMenuUid(panel)
	if not uid then
		return
	end

	if not LIB.MenuIsOpen(uid) then
		return
	end

	if not IsValid(mainPanel) then
		mainPanel = panel
	end

	if ispanel(mainPanel) then
		timer.Simple(0.1, function()
			if not LIB.MenuIsOpen(uid) then
				return
			end

			if not IsValid(mainPanel) then
				return
			end

			vrmod.MenuRenderStart(uid)

			StreamRadioLib.Util.CatchAndErrorNoHaltWithStack(function()
				mainPanel:PaintManual()
			end)

			vrmod.MenuRenderEnd(uid)
		end)
	end
end

function LIB.MenuOpen(uid, panel, cursorEnabled, closeFunc)
	if not CLIENT then
		return
	end

	if not IsValid(panel) then
		return
	end

	uid = tostring(uid or "")
	if uid == "" then
		return
	end

	panel._streamradio_vr_uid = uid
	LIB.CloseMenu(panel)

	LIB.g_openMenus = LIB.g_openMenus or {}
	LIB.g_openMenus[uid] = panel

	panel:SetVisible(true)
	panel:MakePopup()
	panel:InvalidateLayout(true)

	if not LIB.IsActive() then
		return
	end

	local campos, camang = LIB.GetCameraPos()

	if not campos then
		return
	end

	if not camang then
		return
	end

	local scale = 0.04

	local w, h = panel:GetSize()

	local ang = Angle(0, camang.y - 90, 85)
	local pos = campos + Vector(0, 0, -10) + Angle(0, camang.y, 0):Forward() * 30 - ang:Forward() * w / 2 * scale - ang:Right() * h / 2 * scale
	local originPos, originAng = vrmod.GetOrigin()

	pos, ang = WorldToLocal(pos, ang, originPos, originAng)

	vrmod.MenuCreate(uid, w, h, panel, 4, pos, ang, scale, cursorEnabled, closeFunc)
end

if CLIENT then
	local function clearMenus()
		for k, v in pairs(LIB.g_openMenus or {}) do
			LIB.CloseMenu(v)
		end

		LIB.g_openMenus = nil
	end

	StreamRadioLib.Hook.Add("VRUtilStart", "CloseMenusOnVRStart", function()
		clearMenus()
	end)

	StreamRadioLib.Hook.Add("VRUtilExit", "CloseMenusOnVRExit", function()
		clearMenus()
	end)

	clearMenus()
end

return true


--PATH lua/streamradio_core/wire.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Wire = StreamRadioLib.Wire or {}

local LIB = StreamRadioLib.Wire
table.Empty(LIB)

local LIBUtil = StreamRadioLib.Util

local emptyTableSafe = LIBUtil.EmptyTableSafe

local g_HasWiremod = nil

function LIB.HasWiremod()
	if g_HasWiremod ~= nil then
		return g_HasWiremod
	end

	g_HasWiremod = false

	local wmod = _G.WireAddon or _G.WIRE_CLIENT_INSTALLED
	if not wmod then return false end
	if not _G.WireLib then return false end

	g_HasWiremod = true
	return true
end

local function findCallingWireUserEntityFunction()
	for i = 1, 100 do
		local data = debug.getinfo(i, "fS")
		if not data then
			break
		end

		local func = data.func
		if not func then
			break
		end

		local short_src = data.short_src
		if not short_src then
			break
		end

		short_src = string.lower(short_src)

		if not string.find(short_src, "entities/gmod_wire_user.lua", 1, true) then
			continue
		end

		data.index = i
		return data
	end

	return nil
end

local function findCallingWireUserEntityLocals(data)
	if not data then
		return nil
	end

	local locals = {}

	local i = 1

	while true do
		local name, value = debug.getlocal(data.index, i)
		if not name then
			break
		end

		locals[name] = value
		i = i + 1
	end

	return locals
end

function LIB.FindCallingWireUserEntityData()
	if not LIB.HasWiremod() then
		return nil
	end

	local data = findCallingWireUserEntityFunction()
	local locals = findCallingWireUserEntityLocals(data)
	if not locals then
		return nil
	end

	local userEntity = locals["self"]
	if not LIB.IsWireUser(userEntity) then
		return nil
	end

	local trace = locals["trace"]
	if not trace then
		return nil
	end

	local ent = trace.Entity
	if not IsValid( ent ) then
		return nil
	end

	if not ent.__IsRadio then
		return nil
	end

	local result = {
		userEntity = userEntity,
		trace = table.Copy(trace),
	}

	return result
end

function LIB.IsWireUser(ent)
	if not LIB.HasWiremod() then
		return false
	end

	if not IsValid(ent) then
		return false
	end

	if not ent.IsWire then
		return false
	end

	if ent:GetClass() ~= "gmod_wire_user" then
		return false
	end

	return true
end

function LIB.GetUserPos(ent)
	if not LIB.IsWireUser(ent) then
		return nil
	end

	local pos = ent:GetPos()

	return pos
end

function LIB.GetUserPosDir(ent)
	if not LIB.IsWireUser(ent) then
		return nil, nil
	end

	local pos = ent:GetPos()
	local dir = ent:GetUp()

	return pos, dir
end

local g_WireUserTraceCache = {}
local g_WireUserTraceCacheCount = 0
local g_WireUserTrace = {}

function LIB.WireUserTrace(ent)
	if not LIB.IsWireUser(ent) then
		return nil
	end

	local cacheID = tostring(ent or "")
	local cacheItem = g_WireUserTraceCache[cacheID]

	if cacheItem and StreamRadioLib.Util.IsSameFrame("StreamRadioLib.Wire.WireUserTrace_" .. cacheID) then
		return cacheItem
	end

	g_WireUserTraceCache[cacheID] = nil

	local pos, dir = LIB.GetUserPosDir(ent)

	if not pos then
		return nil
	end

	if not dir then
		return nil
	end

	local len = ent:GetBeamLength()
	if not len then
		return nil
	end

	local start_pos = pos
	local end_pos = pos + dir * len

	g_WireUserTrace.start = start_pos
	g_WireUserTrace.endpos = end_pos
	g_WireUserTrace.filter = ent

	local trace = util.TraceLine(g_WireUserTrace)

	-- prevent the cache from overflowing
	if g_WireUserTraceCacheCount > 1024 then
		emptyTableSafe(g_WireUserTraceCache)
		g_WireUserTraceCacheCount = 0
	end

	g_WireUserTraceCache[cacheID] = trace

	if not cacheItem then
		g_WireUserTraceCacheCount = g_WireUserTraceCacheCount + 1
	end

	return g_WireUserTraceCache[cacheID]
end

return true


--PATH lua/streamradio_core/client/cl_settings.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Settings = StreamRadioLib.Settings or {}

local LIB = StreamRadioLib.Settings
table.Empty(LIB)

LIB.g_CV =  {}
LIB.g_CV_CMD = {}
LIB.g_CV_List = {}
LIB.g_panels = LIB.g_panels or {}

function LIB.AddConVar(namespace, name, cmd, default, data)
	if not namespace then return nil end
	if not name then return nil end
	if not cmd then return nil end
	if not default then return nil end
	if not data then return nil end

	local CV = StreamRadioLib.CreateOBJ("clientconvar")
	CV:SetName(name)
	CV:SetCMD(cmd)

	CV:SetType(data.type)
	CV:SetMin(data.min)
	CV:SetMax(data.max)
	CV:SetOptions(data.options)

	CV:SetDefault(default)

	if data.save ~= nil then
		CV:SetSave(data.save)
	end

	if data.userdata ~= nil then
		CV:SetUserdata(data.userdata)
	end

	if data.help ~= nil then
		CV:SetHelptext(data.help)
	end

	if data.hidden ~= nil then
		CV:SetHidden(data.hidden)
	end

	if data.disabled ~= nil then
		CV:SetDisabled(data.disabled)
	end

	CV:SetPanellabel(data.label)
	CV:Setup()

	LIB.g_CV[name] = CV
	LIB.g_CV_CMD[cmd] = CV
	LIB.g_CV_List[namespace] = LIB.g_CV_List[namespace] or {}
	table.insert(LIB.g_CV_List[namespace], CV)

	return CV
end

function LIB.GetConVar(name)
	name = tostring(name or "")
	return LIB.g_CV[name] or LIB.g_CV_CMD[name]
end

function LIB.GetConVarValue(name)
	local CV = LIB.GetConVar(name)
	if not CV then return nil end

	return CV:GetValue()
end

function LIB.SetConVarValue(name, ...)
	local CV = LIB.GetConVar(name)
	if not CV then return end

	CV:SetValue(...)
end

function LIB.GetConVarListByNamespace(namespace)
	namespace = tostring(namespace or "")
	return LIB.g_CV_List[namespace] or {}
end

function LIB.AddBuildMenuPanelHook(namespace, title, buildFunction)
	namespace = tostring(namespace or "")
	title = tostring(title or "")

	StreamRadioLib.Hook.Add("PopulateToolMenu", "SettingsPanel_" .. namespace, function()
		spawnmenu.AddToolMenuOption( "Utilities", "Stream Radio", "StreamRadioSettingsPanel_" .. namespace, title, "", "", buildFunction, {} )
	end)
end

return true


--PATH lua/streamradio_core/client/settings/admin.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_vgui_editor.lua:
return gluapack()()
--PATH lua/streamradio_core/interfaces/cache.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/addon-web-radio.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

local g_addonname = "Web-Radio"
local g_addonid = ""

RADIOFS.name = g_addonname
RADIOFS.type = g_addonname
RADIOFS.icon = StreamRadioLib.GetPNGIcon("format_radio", true)

RADIOFS.addonname = g_addonname
RADIOFS.addonid = g_addonid

RADIOFS.priority = 90
RADIOFS.nocreate = true
RADIOFS.loadToWhitelist = true

RADIOFS._filepath = "webradiobookmarks.txt"
RADIOFS._filename = g_addonname
RADIOFS._filenamelower = string.lower(RADIOFS._filename)

function RADIOFS:IsInFolder(vpath)
	local levels = self:GetPathLevels(vpath)
	local firstlevel = levels[1] or ""

	if firstlevel ~= ":addons" then
		return false
	end

	return true
end

function RADIOFS:IsAddonFile(vpath)
	if not self:IsInFolder(vpath) then
		return false
	end

	vpath = string.lower(string.GetFileFromFilename(vpath))

	if vpath ~= self._filenamelower then
		return false
	end

	return true
end

function RADIOFS:IsInstalled()
	if CLIENT then
		return true
	end

	if self._isInstalled ~= nil then
		return self._isInstalled
	end

	if not file.Exists(self._filepath, "DATA") then
		self._isInstalled = false
		return self._isInstalled
	end

	self._isInstalled = true
	return self._isInstalled
end

function RADIOFS:IsType(globalpath, vpath)
	return self:IsAddonFile(vpath)
end

function RADIOFS:Find(globalpath, vfolder, callback)
	if not self:IsInstalled() then
		callback(false, nil, nil)
		return false
	end

	if vfolder == "" then
		callback(true, nil, {":addons"})
		return true
	end

	if not self:IsInFolder(vfolder) then
		callback(false, nil, nil)
		return false
	end

	callback(true, {self._filename}, nil)
	return true
end

function RADIOFS:Exists(globalpath, vpath)
	if not self:IsInstalled() then
		return false
	end

	if not self:IsAddonFile(vpath) then
		return false
	end

	return true
end

RADIOFS.Delete = nil

local function decodeAddonfile(RawPlaylist)
	local RawPlaylistTab = string.Split( RawPlaylist, "\n" )
	local Playlist = {}

	for i = 1, #RawPlaylistTab do
		local entry = string.Split( RawPlaylistTab[i], "#:#" )
		local name = string.Trim( entry[1] or "" )
		local url = string.Trim( entry[2] or "" )

		if name == "" then
			name = url
		end

		if url == "" then
			continue
		end

		local item = {
			name = name,
			url = url
		}

		table.insert(Playlist, item)
	end

	return Playlist
end

function RADIOFS:Read(globalpath, vpath, callback)
	globalpath = self._filepath

	file.AsyncRead(globalpath, "DATA", function(fileName, gamePath, status, data)
		if status ~= FSASYNC_OK then
			callback(false, nil)
			return
		end

		local RawPlaylist = string.Trim(data or "")
		if RawPlaylist == "" then
			callback(true, {})
			return
		end

		local Playlist = decodeAddonfile(RawPlaylist)
		if not Playlist then
			callback(false, nil)
			return
		end

		callback(true, Playlist)
	end)

	return true
end

function RADIOFS:Write(globalpath, vpath, data, callback)
	globalpath = self._filepath
	if not self:CreateDirectoryForFile(globalpath) then
		callback(false)
		return false
	end

	local f = file.Open(globalpath, "w", "DATA")
	if not f then
		callback(false)
		return false
	end

	local dataOut = {}
	local Seperator = "#:#"

	for i, v in ipairs(data) do
		local name = string.Trim( string.Replace( v.name, Seperator, "" ) )
		local url = string.Trim( string.Replace( v.url, Seperator, "" ) )

		dataOut[#dataOut + 1] = string.format( "%s" .. Seperator .. "%s" .. Seperator .. "Radio Stream\n", name, url )
	end

	local DataString = table.concat(dataOut, "")

	DataString = string.Trim(DataString)

	f:Write(DataString)
	f:Close()

	callback(true)
	return true
end

return true


--PATH lua/streamradio_core/filesystem/m3u.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

RADIOFS.name = "M3U"
RADIOFS.type = "m3u"
RADIOFS.extension = "m3u"
RADIOFS.icon = StreamRadioLib.GetPNGIcon("table_sound", true)

RADIOFS.priority = 10000
RADIOFS.default = true
RADIOFS.loadToWhitelist = true

local function decodeM3U(RawPlaylist)
	local RawPlaylistTab = string.Split( RawPlaylist, "\n" )
	local AdvancedM3U = string.lower( string.Trim( RawPlaylistTab[1] or "" ) ) == "#extm3u"
	local Playlist = {}

	if not AdvancedM3U then
		for i = 1, #RawPlaylistTab do
			local url = string.Trim( RawPlaylistTab[i] or "" )
			local name = url

			if url == "" then
				continue
			end

			if url[1] == "#" then
				continue
			end

			local item = {
				name = name,
				url = url
			}

			table.insert(Playlist, item)
		end

		callback(true, Playlist)
		return true
	end

	for i = 2, #RawPlaylistTab, 2 do
		local name = string.Trim( string.match( RawPlaylistTab[i], "%s*#EXTINF:%s*%d%s*,%s*([^\n]+)" ) or "" )
		local url = string.Trim( RawPlaylistTab[i + 1] or "" )

		if name == "" then
			name = url
		end

		if url == "" then
			continue
		end

		local item = {
			name = name,
			url = url
		}
		table.insert(Playlist, item)
	end

	return Playlist
end

function RADIOFS:Read(globalpath, vpath, callback)
	file.AsyncRead(globalpath, "DATA", function(fileName, gamePath, status, data)
		if status ~= FSASYNC_OK then
			callback(false, nil)
			return
		end

		local RawPlaylist = string.Trim(data or "")
		if RawPlaylist == "" then
			callback(true, {})
			return
		end

		local Playlist = decodeM3U(RawPlaylist)
		if not Playlist then
			callback(false, nil)
			return
		end

		callback(true, Playlist)
	end)

	return true
end

function RADIOFS:Write(globalpath, vpath, data, callback)
	if not self:CreateDirectoryForFile(globalpath) then
		callback(false)
		return false
	end

	local f = file.Open(globalpath, "w", "DATA")
	if not f then
		callback(false)
		return false
	end

	local dataOut = {}
	local Seperator = "\n"

	dataOut[#dataOut + 1] = "#EXTM3U\n"

	for i, v in ipairs(data) do
		local name = string.Trim(string.Replace(v.name, Seperator, ""))
		local url = string.Trim(string.Replace(v.url, Seperator, ""))

		dataOut[#dataOut + 1] = string.format("#EXTINF:0,%s" .. Seperator .. "%s\n", name, url)
	end

	local DataString = table.concat(dataOut, "")

	DataString = string.Trim(DataString)
	DataString = DataString .. "\n\n"

	f:Write(DataString)
	f:Close()

	callback(true)
	return true
end

return true


--PATH lua/streamradio_core/filesystem/vdf.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/autorun/talkmodes_load.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_languages.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
TalkModes = TalkModes || {}
TalkModes.Languages = TalkModes.Languages || {}
TalkModes.Languages.Available = TalkModes.Languages.Available || {}
TalkModes.Languages.Active = TalkModes.Languages.Active || "English" -- Don't touch this line, change language using the in-game admin menu

function TalkModes.Languages:Register(strLanguage, tblPhrases)
    self.Available[strLanguage] = tblPhrases
end

function TalkModes.Languages:GetPhrase(strPhrase)
    return self.Available[TalkModes.Config:GetSetting("General", "Language")][strPhrase] || "phrase_not_found"
end
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_english.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
local LANGUAGE = {}
LANGUAGE["General"] = "General"
LANGUAGE["Theme"] = "Theme"
LANGUAGE["Modes"] = "Modes"
LANGUAGE["Whisper"] = "Whisper"
LANGUAGE["Whisper_Desc"] = "What distance should Whisper reach?"
LANGUAGE["Yell"] = "Yell"
LANGUAGE["Yell_Desc"] = "What distance should Yell reach?"
LANGUAGE["Talk"] = "Talk" 
LANGUAGE["Talk_Desc"] = "What distance should Talk reach?"
LANGUAGE["3D Voice"] = "3D Voice"
LANGUAGE["3D Voice_Desc"] = "Should 3D Voice be turned on?"
LANGUAGE["Language"] = "Language"
LANGUAGE["Language_Desc"] = "Which language should be used?"
LANGUAGE["Selection Key"] = "Selection Key"
LANGUAGE["Selection Key_Desc"] = "Which key should open the selection menu?"
LANGUAGE["Talking Dead"] = "Talking Dead"
LANGUAGE["Talking Dead_Desc"] = "Should dead people be able to talk?"
LANGUAGE["Selection Menu Position"] = "Selection Menu Position"
LANGUAGE["Selection Menu Position_Desc"] = "Where should the menu be located?"
LANGUAGE["Save"] = "Save"
LANGUAGE["Reset"] = "Reset"
LANGUAGE["Preview"] = "Preview"
LANGUAGE["PreviewHeader"] = "PRESS [%s] TO EXIT PREVIEW"
LANGUAGE["PreviewText"] = "CURRENTLY PREVIEWING RANGE: %s UNITS"
LANGUAGE["Background"] = "Background"
LANGUAGE["Background_Desc"] = "Which color should be used for the background?"
LANGUAGE["Foreground"] = "Foreground"
LANGUAGE["Foreground_Desc"] = "Which color should be used for the foreground?"
LANGUAGE["Hover"] = "Accent"
LANGUAGE["Hover_Desc"] = "Which color should be used for the accent?"
LANGUAGE["White"] = "White"
LANGUAGE["White_Desc"] = "Which color should be used as white?"
LANGUAGE["Gray"] = "Gray"
LANGUAGE["Gray_Desc"] = "Which color should be used as gray?"
LANGUAGE["WelcomeMessage"] = "This server is using the Talk Modes script, hold %s to select your talk mode!"
LANGUAGE["Turn Off"] = "Turn OFF"
LANGUAGE["Using Mode"] = "Using Mode"
LANGUAGE["Auto-Hide"] = "Auto Hide"
LANGUAGE["Auto-Hide_Desc"] = "Should selection menu automatically hide when unused?"
LANGUAGE["Mode Change Message"] = "Mode Notification"
LANGUAGE["Mode Change Message_Desc"] = "Should players be notified when their talk mode is changed?"

TalkModes.Languages:Register("English", LANGUAGE)
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_languages.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_binder.lua:
local THEME = TalkModes.Client.ActiveTheme

local PANEL = {}
function PANEL:Init()
    self:SetTextColor(THEME["White"])
    self:SetFont("TalkModes:Small")
end

function PANEL:Paint(intW, intH)
    draw.RoundedBox(6, 0, 0, intW, intH, THEME["Background"])
end

function PANEL:DoClick()
	self:SetText("PRESS A KEY")
	self.intW, self.intH = self:GetContentSize()
    self:SetSize(self.intW + 24, self.intH + 4)
	input.StartKeyTrapping()
	self.Trapping = true
end

function PANEL:UpdateText()
	local str = input.GetKeyName( self:GetSelectedNumber() )
	if ( !str ) then str = "NONE" end
	str = language.GetPhrase( str )
	self:SetText(string.upper(str))
	self.intW, self.intH = self:GetContentSize()
    self:SetSize(self.intW + 24, self.intH + 4)
end
vgui.Register("TalkModes.Binder", PANEL, "DBinder")
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_docker.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_selection.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_switch.lua:
return gluapack()()
--PATH lua/autorun/tfa_base_autorun.lua:
return gluapack()()
--PATH lua/tfa/enums/locomotion.lua:
return gluapack()()
--PATH lua/tfa/enums/sights.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_commands.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_darkrp.lua:
local TFA_PocketBlock = {}
TFA_PocketBlock["tfa_ammo_357"] = true
TFA_PocketBlock["tfa_ammo_ar2"] = true
TFA_PocketBlock["tfa_ammo_buckshot"] = true
TFA_PocketBlock["tfa_ammo_c4"] = true
TFA_PocketBlock["tfa_ammo_frags"] = true
TFA_PocketBlock["tfa_ammo_ieds"] = true
TFA_PocketBlock["tfa_ammo_nervegas"] = true
TFA_PocketBlock["tfa_ammo_nuke"] = true
TFA_PocketBlock["tfa_ammo_pistol"] = true
TFA_PocketBlock["tfa_ammo_proxmines"] = true
TFA_PocketBlock["tfa_ammo_rockets"] = true
TFA_PocketBlock["tfa_ammo_smg"] = true
TFA_PocketBlock["tfa_ammo_smg1_grenade"] = true
TFA_PocketBlock["tfa_ammo_smg1_grenade_large"] = true
TFA_PocketBlock["tfa_ammo_sniper_rounds"] = true
TFA_PocketBlock["tfa_ammo_stickynades"] = true
TFA_PocketBlock["tfa_ammo_winchester"] = true

local function TFA_PockBlock(ply, wep) --Get it, because cockblock, hehe.....  so mature.
	if not IsValid(wep) then return end
	local class = wep:GetClass()
	if TFA_PocketBlock[class] then return false end
end

hook.Add("canPocket", "TFA_PockBlock", TFA_PockBlock)

--PATH lua/tfa/modules/tfa_melee_autorun.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_soundscripts.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_tttpatch.lua:
if engine.ActiveGamemode() ~= "terrortown" then return end

local cv_enabled = CreateConVar("sv_tfa_ttt_patch_weapons", "1", {FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_NOTIFY}, "Patch TFA Base weapons to automatically spawn")

-- luacheck: globals WEAPON_NONE WEAPON_MELEE WEAPON_PISTOL WEAPON_HEAVY WEAPON_NADE WEAPON_CARRY WEAPON_EQUIP1 WEAPON_EQUIP2 WEAPON_ROLE WEAPON_EQUIP WEAPON_UNARMED ROLE_INNOCENT ROLE_TRAITOR ROLE_DETECTIVE ROLE_NONE
WEAPON_NONE = WEAPON_NONE or 0
WEAPON_MELEE = WEAPON_MELEE or 1
WEAPON_PISTOL = WEAPON_PISTOL or 2
WEAPON_HEAVY = WEAPON_HEAVY or 3
WEAPON_NADE = WEAPON_NADE or 4
WEAPON_CARRY = WEAPON_CARRY or 5
WEAPON_EQUIP1 = WEAPON_EQUIP1 or 6
WEAPON_EQUIP2 = WEAPON_EQUIP2 or 7
WEAPON_ROLE = WEAPON_ROLE or 8
WEAPON_EQUIP = WEAPON_EQUIP or WEAPON_EQUIP1
WEAPON_UNARMED = WEAPON_UNARMED or -1
ROLE_INNOCENT = ROLE_INNOCENT or 0
ROLE_TRAITOR = ROLE_TRAITOR or 1
ROLE_DETECTIVE = ROLE_DETECTIVE or 2
ROLE_NONE = ROLE_NONE or ROLE_INNOCENT

local KindTable = {
	[0] = WEAPON_MELEE,
	[1] = WEAPON_PISTOL,
	[2] = WEAPON_HEAVY,
	[3] = WEAPON_HEAVY,
	[4] = WEAPON_HEAVY,
	[5] = WEAPON_EQUIP1,
	[6] = WEAPON_EQUIP2
}

local TypeStrings = {
	[WEAPON_NONE] = "Invalid",
	[WEAPON_MELEE] = "Melee",
	[WEAPON_PISTOL] = "Pistol",
	[WEAPON_HEAVY] = "Heavy",
	[WEAPON_NADE] = "Grenade",
	[WEAPON_CARRY] = "Carry",
	[WEAPON_EQUIP1] = "Equipment",
	[WEAPON_EQUIP2] = "Equipment",
	[WEAPON_ROLE] = "Role"
}

local function PatchWep(wep)
	if not weapons.IsBasedOn(wep, "tfa_gun_base") then return end
	if wep:find("base") then return end

	local tbl = weapons.GetStored(wep)
	if not tbl then return end

	tbl.AllowSprintAttack = true -- no sprinting ever, running convar is a dumb idea

	if (not tbl.Kind) or (not isnumber(tbl.Kind)) then
		tbl.Kind = KindTable[tbl.Slot or 2] or WEAPON_HEAVY

		if (tbl.ProjectileVelocity and tbl.ProjectileVelocity < 1000 and tbl.ProjectileVelocity > 0) or string.find(tbl.Base or "", "nade") then
			tbl.Kind = WEAPON_NADE
		end

		if tbl.IsMelee then
			tbl.Kind = WEAPON_MELEE
		end

		if not tbl.Spawnable then
			tbl.Kind = WEAPON_NONE
		end
	end

	--if not tbl.Icon then
	--	tbl.Icon = nil--"vgui/entities/" .. wep
	--end
	tbl.model = tbl.model or tbl.WorldModel

	if not tbl.CanBuy then
		--if tbl.Spawnable then
		--	tbl.CanBuy = { ROLE_TRAITOR, ROLE_DETECTIVE }
		--else
		tbl.CanBuy = {}
		--end
	end

	for _, v in pairs(tbl.CanBuy) do
		if v ~= ROLE_TRAITOR and v ~= ROLE_DETECTIVE then
			table.RemoveByValue(tbl.CanBuy, v)
		end
	end

	if (not tbl.Icon) or (string.len(tbl.Icon) <= 0) then
		tbl.Icon = nil
		if file.Exists("materials/entities/" .. wep .. ".png", "GAME") then
			tbl.Icon = "entities/" .. wep .. ".png"
		elseif file.Exists("materials/vgui/entities/" .. wep .. ".vmt", "GAME") then
			tbl.Icon = "vgui/entities/" .. wep
		end
	end

	if tbl.LimitedStock == nil then
		tbl.LimitedStock = false
	end

	if not tbl.EquipMenuData then
		tbl.EquipMenuData = {
			["type"] = TypeStrings[tbl.Kind],
			["desc"] = tbl.PrintName or wep
		}
	end

	if tbl.IsSilent == nil then
		tbl.IsSilent = false
	end

	if tbl.NoSights == nil then
		if tbl.data then
			tbl.NoSights = tbl.Secondary.IronSightsEnabled == false or tbl.data and tbl.data.ironsights ~= 0 or false
		end

		if tbl.NoSights == nil then
			tbl.NoSights = false
		end
	end

	if tbl.AutoSpawnable == nil then
		tbl.AutoSpawnable = tbl.Spawnable
	end
end

local function Patch()
	if not cv_enabled:GetBool() then return end

	for _, v in pairs(weapons.GetList()) do
		local wep = v.ClassName

		if wep then
			PatchWep(wep)
		end
	end
end

if SERVER then
	hook.Add("Initialize", "TFAPatchTTT", Patch)
end
if CLIENT then
	hook.Add("HUDPaint", "TFAPatchTTT", function()
		if LocalPlayer():IsValid() then
			Patch()
			hook.Remove("HUDPaint","TFAPatchTTT")
		end
	end)
end

--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1		end
	
--PATH lua/tfa/modules/cl_tfa_hitmarker.lua:
local ScrW, ScrH = ScrW, ScrH

local markers = {}

local cl_drawhud = GetConVar("cl_drawhud")
local enabledcvar = GetConVar("cl_tfa_hud_hitmarker_enabled")
local solidtimecvar = GetConVar("cl_tfa_hud_hitmarker_solidtime")
local fadetimecvar = GetConVar("cl_tfa_hud_hitmarker_fadetime")
local scalecvar = GetConVar("cl_tfa_hud_hitmarker_scale")
local tricross_cvar = GetConVar("cl_tfa_hud_crosshair_triangular")

local rcvar = GetConVar("cl_tfa_hud_hitmarker_color_r")
local gcvar = GetConVar("cl_tfa_hud_hitmarker_color_g")
local bcvar = GetConVar("cl_tfa_hud_hitmarker_color_b")
local acvar = GetConVar("cl_tfa_hud_hitmarker_color_a")

net.Receive("tfaHitmarker", function()
	if not enabledcvar:GetBool() then return end

	local marker = {
		time = RealTime()
	}

	table.insert(markers, marker)
end)

net.Receive("tfaHitmarker3D", function()
	if not enabledcvar:GetBool() then return end

	local marker = {
		pos = net.ReadVector(),
		time = RealTime()
	}

	table.insert(markers, marker)
end)

local mat_regular = Material("vgui/tfa_hitmarker.png", "smooth mips")
local mat_triang = Material("vgui/tfa_hitmarker_triang.png", "smooth mips")

local cl_tfa_hud_crosshair_enable_custom = GetConVar("cl_tfa_hud_crosshair_enable_custom")

hook.Add("HUDPaint", "tfaDrawHitmarker", function()
	if not enabledcvar:GetBool() or not cl_drawhud:GetBool() then return end

	local solidtime = solidtimecvar:GetFloat()
	local fadetime = math.max(fadetimecvar:GetFloat(), 0.001)

	local r = rcvar:GetFloat()
	local g = gcvar:GetFloat()
	local b = bcvar:GetFloat()
	local a = acvar:GetFloat()

	local w, h = ScrW(), ScrH()
	local sprh = math.floor((h / 1080) * 64 * scalecvar:GetFloat())
	local sprh2 = sprh / 2
	local mX, mY = w / 2, h / 2
	local ltime = RealTime()

	if cl_tfa_hud_crosshair_enable_custom:GetBool() and isnumber(TFA.LastCrosshairPosX) and isnumber(TFA.LastCrosshairPosY) then
		local weapon = LocalPlayer():GetActiveWeapon()

		if IsValid(weapon) and weapon.IsTFAWeapon then
			mX, mY = TFA.LastCrosshairPosX, TFA.LastCrosshairPosY
		end
	end

	for k, v in pairs(markers) do
		if v.time then
			local alpha = math.Clamp(v.time - ltime + solidtime + fadetime, 0, fadetime) / fadetime

			if alpha > 0 then
				local x, y = mX, mY
				local visible = true

				if v.pos then
					local pos = v.pos:ToScreen()
					x, y = pos.x, pos.y
					visible = pos.visible
				end

				if visible then
					surface.SetDrawColor(r, g, b, a * alpha)
					surface.SetMaterial(tricross_cvar:GetBool() and mat_triang or mat_regular)
					surface.DrawTexturedRect(x - sprh2, y - sprh2, sprh, sprh)
				end
			else
				markers[k] = nil
			end
		else
			markers[k] = nil
		end
	end
end)

--PATH lua/tfa/modules/cl_tfa_inspection.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_models.lua:
TFA.ClientsideModels = TFA.ClientsideModels or {}

timer.Create("TFA_UpdateClientsideModels", 0.1, 0, function()
	local i = 1

	while i <= #TFA.ClientsideModels do
		local t = TFA.ClientsideModels[i]

		if not t then
			table.remove(TFA.ClientsideModels, i)
		elseif not IsValid(t.wep) then
			t.mdl:Remove()
			table.remove(TFA.ClientsideModels, i)
		elseif IsValid(t.wep:GetOwner()) and t.wep:GetOwner().GetActiveWeapon and t.wep ~= t.wep:GetOwner():GetActiveWeapon() then
			t.mdl:Remove()
			table.remove(TFA.ClientsideModels, i)
		elseif t.wep.IsHidden and t.wep:IsHidden() then
			t.mdl:Remove()
			table.remove(TFA.ClientsideModels, i)
		else
			i = i + 1
		end
	end

	if #TFA.ClientsideModels == 0 then
		timer.Stop("TFA_UpdateClientsideModels")
	end
end)

if #TFA.ClientsideModels == 0 then
	timer.Stop("TFA_UpdateClientsideModels")
end

function TFA.RegisterClientsideModel(cmdl, wepv) -- DEPRECATED
	-- don't use please
	-- pleaz
	TFA.ClientsideModels[#TFA.ClientsideModels + 1] = {
		["mdl"] = cmdl,
		["wep"] = wepv
	}

	timer.Start("TFA_UpdateClientsideModels")
end

local function NotifyShouldTransmit(ent, notdormant)
	if notdormant or not ent.IsTFAWeapon then return end
	if ent:GetOwner() == LocalPlayer() then return end

	ent:CleanModels(ent:GetStatRaw("ViewModelElements", TFA.LatestDataVersion))
	ent:CleanModels(ent:GetStatRaw("WorldModelElements", TFA.LatestDataVersion))
end

local function EntityRemoved(ent)
	if not ent.IsTFAWeapon then return end

	ent:CleanModels(ent:GetStatRaw("ViewModelElements", TFA.LatestDataVersion))
	ent:CleanModels(ent:GetStatRaw("WorldModelElements", TFA.LatestDataVersion))
end

hook.Add("NotifyShouldTransmit", "TFA_ClientsideModels", NotifyShouldTransmit)
hook.Add("EntityRemoved", "TFA_ClientsideModels", EntityRemoved)

--PATH lua/tfa/modules/cl_tfa_projtex.lua:
local ply = LocalPlayer()
local LocalPlayer = LocalPlayer

hook.Add("PreRender", "TFACleanupProjectedTextures", function()
	if not IsValid(ply) then
		ply = LocalPlayer()
		if not IsValid(ply) then return end
	end

	local wep = ply:GetActiveWeapon()

	if not IsValid(wep) or not wep.IsTFAWeapon then
		if IsValid(ply.TFAFlashlightGun) then
			ply.TFAFlashlightGun:Remove()
		end

		if IsValid(ply.TFALaserDot) then
			ply.TFALaserDot:Remove()
		end
	end
end)

hook.Add("PrePlayerDraw", "TFACleanupProjectedTextures", function(plyv)
	local wep = plyv:GetActiveWeapon()

	if not IsValid(wep) or not wep.IsTFAWeapon then
		if IsValid(plyv.TFAFlashlightGun) then
			plyv.TFAFlashlightGun:Remove()
		end

		if IsValid(plyv.TFALaserDot) then
			plyv.TFALaserDot:Remove()
		end
	end
end)

--PATH lua/tfa/att/base.lua:
return gluapack()()
--PATH lua/tfa/att/si_rt_base.lua:
return gluapack()()
--PATH lua/tfa/attbatch/0_base_attachments.lua:
return gluapack()()
--PATH lua/autorun/tri_pcf_precache_autorun.lua:
-- Dark Souls --
game.AddParticles("particles/Dark_Souls/ds3_sister_friede.pcf")
game.AddParticles("particles/Dark_Souls/ds_artorias_fx.pcf")
game.AddParticles("particles/Dark_Souls/ds_ornstein_fx.pcf")
game.AddParticles("particles/Dark_Souls/ds3_fx.pcf")
game.AddParticles("particles/Dark_Souls/abyss_watcher.pcf")
game.AddParticles("particles/Dark_Souls/cinder_fx_ds3.pcf")
game.AddParticles("particles/Dark_Souls/danksouls.pcf")
game.AddParticles("particles/Dark_Souls/ds3_bosssteps.pcf")
game.AddParticles("particles/Dark_Souls/gael.pcf")
game.AddParticles("particles/Dark_Souls/gael_smoke.pcf")
game.AddParticles("particles/Dark_Souls/gael_dirt2.pcf")
game.AddParticles("particles/Dark_Souls/nking_1.pcf")
game.AddParticles("particles/Dark_Souls/nking_2.pcf")
game.AddParticles("particles/Dark_Souls/nking_3.pcf")

game.AddParticles("particles/Dark_Souls/dmc_particles.pcf")

-- Alien Swarm --
game.AddParticles("particles/Alien_Swarm/asw_environmental_fx.pcf")
game.AddParticles("particles/Alien_Swarm/asw_muzzle_fx.pcf")
game.AddParticles("particles/Alien_Swarm/asw_tracer_fx.pcf")
game.AddParticles("particles/Alien_Swarm/asw_weapon_fx.pcf")
game.AddParticles("particles/Alien_Swarm/asw_welding_fx.pcf")
game.AddParticles("particles/Alien_Swarm/burningplayer.pcf")
game.AddParticles("particles/Alien_Swarm/fire_fx.pcf")
game.AddParticles("particles/Alien_Swarm/mnb_fire.pcf")
game.AddParticles("particles/Alien_Swarm/mnb_flamethrower.pcf")

-- Day of Infamy Swarm --
game.AddParticles("particles/Day_Of_Infamy/doi_destructible_fx.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosion_fx.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosion_fx_b.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosion_fx_c.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosion_fx_grenade.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosion_fx_new.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_explosions_smoke.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_impact_fx.pcf")
game.AddParticles("particles/Day_Of_Infamy/doi_weapon_fx.pcf")

-- Insurgency --
game.AddParticles("particles/Insurgency/ammo_cache_ins.pcf")
game.AddParticles("particles/Insurgency/blood_fx.pcf")
game.AddParticles("particles/Insurgency/explosion_fx_ins.pcf")
game.AddParticles("particles/Insurgency/explosion_fx_ins_b.pcf")
game.AddParticles("particles/Insurgency/footstep_fx.pcf")
game.AddParticles("particles/Insurgency/impact_fx_ins.pcf")
game.AddParticles("particles/Insurgency/ins_burning_fx.pcf")
game.AddParticles("particles/Insurgency/ins_rockettrail.pcf")
game.AddParticles("particles/Insurgency/ins_smokegrenade.pcf")
game.AddParticles("particles/Insurgency/weapon_fx_ins.pcf")
game.AddParticles("particles/Insurgency/weapon_fx_ins_b.pcf")
game.AddParticles("particles/Insurgency/weapon_fx_tracers.pcf")
game.AddParticles("particles/Insurgency/world_fx_ins.pcf")

-- Left 4 Dead --
game.AddParticles("particles/L4D/insect_fx.pcf")
game.AddParticles("particles/L4D/rain_fx.pcf")
game.AddParticles("particles/L4D/rain_fx_unused.pcf")

-- CoD --
game.AddParticles("particles/CoD/blackops3zombies_fx.pcf")
game.AddParticles("particles/CoD/hound.pcf")

-- Half-Life Alyx --
game.AddParticles("particles/Half-Life_Alyx/hla_antlion_blue_fx.pcf")
game.AddParticles("particles/Half-Life_Alyx/tridroid_particles.pcf")
game.AddParticles("particles/Half-Life_Alyx/hla_antlion_orange_fx.pcf")
game.AddParticles("particles/Half-Life_Alyx/AntlionFX.pcf")

-- Horror --
game.AddParticles("particles/Horror/bloodsplosion.pcf")

-- Doom 3 --
game.AddParticles("particles/DOOM/doom_fx.pcf")

-- Armor --
game.AddParticles( "particles/npcarmor.pcf" )
PrecacheParticleSystem( "npcarmor_break" )
PrecacheParticleSystem( "npcarmor_hit" )
PrecacheParticleSystem( "eml_generic_shock" )

-- Starship Troopers --
game.AddParticles("particles/Starship_Troopers/arach_drool.pcf")
game.AddParticles("particles/Starship_Troopers/sst_acidbug_fx.pcf")

-- Fallout --
game.AddParticles("particles/Fallout/centaur_spit.pcf")
game.AddParticles("particles/Fallout/glowingone.pcf")
game.AddParticles("particles/Fallout/goregrenade.pcf")
game.AddParticles("particles/Fallout/magmalurk_flame.pcf")
game.AddParticles("particles/Fallout/fo3_radiation_shockwave.pcf")
game.AddParticles("particles/Fallout/spore1.pcf")
game.AddParticles("particles/Fallout/sporecarrier_glow.pcf")
game.AddParticles("particles/Fallout/sporecarrier_radiation.pcf")
game.AddParticles("particles/Fallout/fo3_fx.pcf")

-- Halo --
game.AddParticles("particles/Halo/main_effects.pcf")
game.AddParticles("particles/Halo/halo_beam.pcf")
game.AddParticles("particles/FlexParticles.pcf")

-- Monster Hunter --
game.AddParticles("particles/mh_scream.pcf")

-- Mass Effect --
game.AddParticles("particles/Mass_Effect/thresher_fx.pcf")
local particlename = {
------------------------------------------------------------------------------------------------------------------------------------
--// Dark Souls Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Friede Particle Effects --
-- phase 2 --
"ds3_friede_bf_flameblast",			-- Single
"ds3_friede_bf_scythe",				-- Continuous
"ds3_friede_bf_super",				-- Single

-- phase 1 --
"ds3_friede_icecast",				-- Single
"ds3_friede_icecastlarge",			-- Single
"ds3_friede_icewave_base",			-- Single
"ds3_friede_icecrystal_spawn",		-- Single
"ds3_friede_icewave_flareup",		-- Single
"ds3_friede_jump",
"ds3_friede_leftdodge",
"ds3_friede_rightdodge",
"ds3_friede_leftcloak",
"ds3_friede_rightcloak",
"ds3_friede_scythe_charge",			-- Continuous
"ds3_friede_scythe_charged",		-- Single
"ds3_friede_scythe_hit",			-- Single
"ds3_friede_scythe_metalhit",		-- Single
"ds3_friede_scythe_idle",			-- Continuous
"ds3_friede_scythe_scrape",			-- Continuous
"ds3_friede_scythe_slam",			-- Single
"ds3_friede_scythe_swing",			-- Continuous
"ds3_friede_sprint",
---------------------------------
-- Shared Particle Effects --
"dskart_death",
"ds3_basil_breath",
"ds3_basil_breath_0",
"ds3_basil_breath_1",
"ds3_basil_breath_2",
"ds3_basil_breath_child",
"ds3_basil_hit",
"ds3_dw_mist",
"ds3_dw_mist_1",
"ds3_dw_mist_1a",
"ds3_dw_mist_2",
"ds3_dw_mist_2a",
"ds3_dw_mist_3",
"ds3_dw_mist_3a",
"ds3_dw_mist_4",
"ds3_dw_mist_4a",
"ds3_dw_mist_a",
"ds3_boss_dissolve",
"ds3_boss_dissolve_cheap",
"ds3_gundyr_eyes",
"ds3_eyes_red",
"ds3_eyes_green",
"ds3_eyes_gold",
"ds3_eyes_purple",
"dsorn_electric",
"ornstein_hit",
"ornstein_tracer",
"ds3_bloodsword_swing_left",
"ds3_bloodsword_swing_right",
"ds3_bloodsword_left_em",
"ds3_bloodsword_right_em",
"ds3_bs_left_em_med",
"ds3_bs_right_em_med",
"ds3_bs_left_em_lrg",
"ds3_bs_right_em_lrg",
"ds3_bs_swing_left_med",
"ds3_bs_swing_right_med",
"ds3_bs_swing_left_lrg",
"ds3_bs_swing_right_lrg",
"ds3_maria_fire_impact",
"ds3_maria_impact",
"ds3_maria_blood",
"ds3_flamesword_swing",
"ds3_flamesword_swing_left",
"ds3_flamesword_swing_right",

"dante_cinder_heal",
"dante_cinder_heal_glow",
"dante_cinder_heal_wave",
"dante_cinder_heal_glyph",
"dante_cinder_heal_embers",
"dante_cinder_heal_initialglyph",
"dante_cinder_heal_vertglyph",
"dante_cinder_heal_vertglyph2",
"dante_cinder_heal_rays",
---------------------------------
-- Footstep Particle Effects --
"ds3_bossfs_land",
"ds3_bossfs_water",
"ds3_bossfs_water_nowarp",
---------------------------------
-- Abyss Watcher Particle Effects --
"ds3_watcher_dirt_circular",
"ds3_watcher_dirt_kickup",
"ds3_watcher_fire_circular",
"ds3_watcher_fire_impact",
"ds3_watcher_fire_pillar",
"ds3_watcher_impact",
"ds3_watcher_sword_flame",
"ds3_watcher_thrust",
---------------------------------
-- Soul of Cinder Particle Effects --
"ds3_cinder_bless",
"ds3_cinder_bless_cast",
"ds3_cinder_buffedaura",
"ds3_cinder_buffedblast",
"ds3_cinder_buffedsword",
"ds3_cinder_death",
"ds3_cinder_heal",
"ds3_cinder_heal_aura",
"ds3_cinder_heal_cast",
"ds3_cinder_innerpower",
"ds3_cinder_magicblast_trail",
"ds3_cinder_magicbolt_hit",
"ds3_cinder_magicbolt_trail",
"ds3_cinder_poisonbreath",
"ds3_poison_mist_cloud",
"ds3_cinder_power_aura",
"ds3_cinder_power_cast",
"ds3_cinder_spear_bigasslightning",
"ds3_cinder_spear_core",
"ds3_cinder_spear_hit",
"ds3_cinder_spear_impact",
"ds3_cinder_spear_lightning",
"ds3_cinder_spear_trail",
"soc_sword_embers",
---------------------------------
-- Gael Particle Effects --
"gael_sword_skulls",
"gael_dirt_kickup",
"gael_dirt_kickup_dir_bck",
"gael_dirt_kickup_dir_fwd",
"gael_dirt_kickup_dir_lft",
"gael_dirt_kickup_dir_rit",
"gael_dirt_land",
"gael_smoke_impact_small",
"gael_smoke_impact_large",
"gael_smoke_impact_continuous",
"gael_sword_impact_att10",
"gael_sword_impact_large",
"gael_sword_impact_small",

------------------------------------------------------------------------------------------------------------------------------------
--// Alien Swarm Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
"asw_debris_generic_random_2",
"asw_Dust_Ceiling_Rumble_256Line",
"asw_Flies",
"asw_landingbay_lift_fog_volume",
"asw_landingbay_lift_start_dust",
"asw_landingbay_lift_steam_jet",
"asw_landingbay_slime_gas_bottom",
"asw_landingbay_slime_gas_top",
"asw_lava_smoke_256x256",
"asw_leaky_pipe_light_172h",
"asw_leaky_roof_sml_180h",
"asw_pipe_drips_a_180x256",
"asw_snow_drift_through_door_1",
"asw_sprinker_system_180_180h",
"asw_sprinker_system_360_180h",
"asw_steam_jet_50",
"asw_steam_jet_80",
"asw_steam_low_vent_1",
"asw_steam_simple_directional_sml",
"asw_steam_test_1",
"asw_vent_steam_light_64x64",
"asw_muzzle_autogun",
"asw_muzzle_charged_crit",
"asw_muzzle_default",
"asw_muzzle_pdw",
"asw_muzzle_pistol",
"asw_muzzle_proto_rifle",
"asw_muzzle_railgun",
"asw_muzzle_rifle",
"asw_muzzle_sentrygun",
"asw_muzzle_shotgun",
"asw_muzzle_sniper_rifle",
"asw_muzzle_vindicator",
"asw_tracer_att_chem",
"asw_tracer_att_electric",
"asw_tracer_att_explo",
"asw_tracer_att_fire",
"asw_tracer_att_freeze",
"asw_tracer_autogun",
"asw_tracer_default",
"asw_tracer_minigun",
"asw_tracer_pdw",
"asw_tracer_pistol",
"asw_tracer_railgun",
"asw_tracer_rifle",
"asw_tracer_shotgun",
"asw_tracer_sniper_rifle",
"asw_tracer_vindicator",
"asw_ammo_satchel_take_lrg",
"asw_ammo_satchel_take_med",
"asw_ammo_satchel_take_sml",
"asw_fireextinguisher",
"asw_freezer_spray",
"asw_barrel_rad_gas_cloud",
"asw_barrel_rad_gas_jet",
"asw_electric_weapon_shot_continuous",
"asw_electric_weapon_shot_continuous_off",
"asw_electric_weapon_zap",
"asw_fast_reload",
"asw_flare_fx_main",
"asw_grenade_freeze_main_trail",
"asw_grenade_main_trail",
"asw_laser_mine",
"asw_laser_mine_friendly",
"asw_mining_laser_beam",
"asw_mining_laser_charging",
"asw_mining_laser_exhaust",
"asw_muzzleflash_grenadelauncher_main",
"asw_piercing_spark",
"asw_prifle_grenade_fx",
"asw_reload_fail",
"asw_rifle_grenade_fx",
"asw_rocket_trail_small",
"asw_tesla_trap_fx",
"asw_tesla_zap_fx",
"asw_weapon_laser_sight",
"asw_weapon_shell_casing_rifle",
"asw_weapon_shell_casing_rifle_fallback",
"asw_weapon_shell_casing_shotgun",
"asw_weapon_shell_casing_shotgun_fallback",
"asw_welding_door_cut",
"asw_welding_door_seal",
"asw_burningplayer_blue",
"asw_burningplayer_corpse",
"asw_burningplayer_red",
"asw_flamethrower",
"asw_biomass_dissolve",
"asw_burned_alien_death",
"asw_dropship_rear_engine_mini",
"asw_ent_on_fire",
"asw_fire_droppod_main",
"asw_ground_fire",
"asw_immolate_hover_main",
"asw_mine_fire",
"asw_vindicator_grenade",
"asw_generic_crater_smoke_big",
"asw_molotov_explosion",
"asw_mnb_flamethrower_detonate",
"asw_smokegrenade_a",
"asw_einstoss_flamethrower",
"asw_einstoss_flamethrower_impact",
"asw_mnb_flamethrower",
"asw_mnb_flamethrower_fire_startup",
"asw_mnb_flamethrower_fire_startup_2",
"asw_mnb_flamethrower_heat",
"asw_mnb_flamethrower_pilotlight",

------------------------------------------------------------------------------------------------------------------------------------
--// Day Of Infamy Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
"doi_destructible_wall",
"doi_artillery_explosion_OLD",
"doi_grenade_explosionOLD",
"doi_WParty_explosion",
"doi_WPgrenade_explosion",
"doi_WProcket_explosion",
"doi_generic_crater_smoke",
"doi_generic_crater_smoke_big",
"doi_compB_explosionOLD",
"doi_frag_explosionOLD",
"doi_mortar_explosionOLD",
"doi_flak88_explosion",
"doi_petrol_explosion",
"doi_petrol_leak",
"doi_ceilingDust_large",
"doi_ceilingDust_small",
"doi_frag_explosion",
"doi_grenade_explosion",
"doi_mortar_explosion",
"doi_splinter_explosion",
"doi_artillery_explosion",
"doi_compB_explosion",
"doi_gunrun_impact",
"doi_stuka_explosion",
"doi_smoke_artillery",
"doi_impact_asphalt",
"doi_impact_brick",
"doi_impact_cardboard",
"doi_impact_carpet",
"doi_impact_computer",
"doi_impact_concrete",
"doi_impact_dirt",
"doi_impact_fruit",
"doi_impact_glass",
"doi_impact_grass",
"doi_impact_gravel",
"doi_impact_leaves",
"doi_impact_metal",
"doi_impact_mud",
"doi_impact_paper",
"doi_impact_physics_dust",
"doi_impact_plaster",
"doi_impact_plastic",
"doi_impact_puddle",
"doi_impact_rock",
"doi_impact_rubber",
"doi_impact_sand",
"doi_impact_snow",
"doi_impact_tile",
"doi_impact_upholstery",
"doi_impact_water",
"doi_impact_wet",
"doi_impact_wood",
"doi_pumpkin_explode",
"doi_radio_explode",
"doi_muzzleflash_1911_1p",
"doi_muzzleflash_bar_1p",
"doi_muzzleflash_bar_3p",
"doi_muzzleflash_garand_1p",
"doi_muzzleflash_garand_3p",
"doi_muzzleflash_ithica_1p",
"doi_muzzleflash_ithica_3p",
"doi_muzzleflash_k98_1p",
"doi_muzzleflash_k98_3p",
"doi_muzzleflash_luger_1p",
"doi_muzzleflash_m1919_1p",
"doi_muzzleflash_m1919_3rd",
"doi_muzzleflash_m1carbine_1p",
"doi_muzzleflash_mg34_1p",
"doi_muzzleflash_mg42_1p",
"doi_muzzleflash_mg42_3p",
"doi_muzzleflash_mp40_1p",
"doi_muzzleflash_mp40_3p",
"doi_muzzleflash_smoke_large_linger",
"doi_muzzleflash_smoke_medium_linger",
"doi_muzzleflash_smoke_medium_variant_1",
"doi_muzzleflash_smoke_small_variant_1",
"doi_muzzleflash_smoke_small_variant_2",
"doi_muzzleflash_smoke_small_variant_3",
"doi_muzzleflash_smoke_small_variant_4",
"doi_muzzleflash_smoke_small_variant_5",
"doi_muzzleflash_smoke_tiny",
"doi_muzzleflash_sten_1p",
"doi_muzzleflash_sten_3p",
"doi_muzzleflash_stg44_1p",
"doi_muzzleflash_stg44_3p",
"doi_muzzleflash_suppressed_1p",
"doi_muzzleflash_thompson_1p",
"doi_muzzleflash_thompson_3p",
"doi_shell_eject",
"doi_shell_eject_b",
"doi_shell_eject_c",
"doi_weapon_compB_fuse",
"doi_weapon_muzzle_smoke",
"doi_weapon_muzzle_smoke_b",
"doi_weapon_muzzle_smoke_c",

------------------------------------------------------------------------------------------------------------------------------------
--// Insurgency Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
"ins_ammo_explosion",
"ins_blood_dismember_limb",
"ins_blood_impact_generic",
"ins_blood_impact_headshot",
"ins_blood_incapacitated",
"ins_C4_explosion",
"ins_flashbang_explosion",
"ins_grenade_explosion",
"ins_m203_explosion",
"ins_rpg_explosion",
"ins_water_explosion",
"ins_weapon_m203",
"ins_muzzleflash_flaregun",
"ins_AAA",
"ins_car_explosion",
"ins_molotov_explosion",
"ins_thermite_explosion",
"ins_footstep_dirt",
"ins_footstep_grass",
"ins_footstep_mud",
"ins_footstep_puddle",
"ins_footstep_wet",
"ins_slide_dirt",
"ins_bag_explode",
"ins_impact_asphalt",
"ins_impact_asphalt_cheap",
"ins_impact_brick",
"ins_impact_cardboard",
"ins_impact_cardboard_cheap",
"ins_impact_cardboardb",
"ins_impact_carpet",
"ins_impact_carpet_cheap",
"ins_impact_computer",
"ins_impact_computer_cheap",
"ins_impact_concrete",
"ins_impact_dirt",
"ins_impact_fruit",
"ins_impact_glass",
"ins_impact_grass",
"ins_impact_gravel",
"ins_impact_leaves",
"ins_impact_leaves_cheap",
"ins_impact_metal",
"ins_impact_mud",
"ins_impact_mud_cheap",
"ins_impact_paper",
"ins_impact_paper_cheap",
"ins_impact_plaster",
"ins_impact_plastic",
"ins_impact_plastic_cheap",
"ins_impact_puddle",
"ins_impact_puddle_cheap",
"ins_impact_rock",
"ins_impact_rubber",
"ins_impact_rubber_cheap",
"ins_impact_sand",
"ins_impact_snow",
"ins_impact_tile",
"ins_impact_upholstery",
"ins_impact_upholstery_cheap",
"ins_impact_water",
"ins_impact_water_cheap",
"ins_impact_wet",
"ins_impact_wet_cheap",
"ins_impact_wood",
"ins_pumpkin_explode",
"ins_burning_character_large",
"ins_burning_character",
"ins_rockettrail",
"ins_m203_smokegrenade",
"ins_smokegrenade",
"ins_weapon_at4_frontblast",
"ins_weapon_rpg_backblast",
"ins_weapon_rpg_frontblast",
"ins_molotov_rag",
"ins_molotov_lighter",
"ins_molotov_trail",
"ins_muzzleflash_akm_1p",
"ins_muzzleflash_akm_1p_b",
"ins_muzzleflash_akm_3rd",
"ins_muzzleflash_fal_1p",
"ins_muzzleflash_fal_1p_b",
"ins_muzzleflash_fal_3rd",
"ins_muzzleflash_m14_1p",
"ins_muzzleflash_m14_1p_b",
"ins_muzzleflash_m14_3rd",
"ins_muzzleflash_m16_1p",
"ins_muzzleflash_m16_1p_b",
"ins_muzzleflash_m16_3rd",
"ins_muzzleflash_m249_1p",
"ins_muzzleflash_m249_1p_b",
"ins_muzzleflash_m249_1p_c",
"ins_muzzleflash_m249_3rd",
"ins_muzzleflash_m590_1p",
"ins_muzzleflash_m590_3rd",
"ins_muzzleflash_m9_1p",
"ins_muzzleflash_m9_1p_b",
"ins_muzzleflash_m9_3rd",
"ins_muzzleflash_makarov_1p",
"ins_muzzleflash_makarov_1p_b",
"ins_muzzleflash_makarov_3rd",
"ins_muzzleflash_mp40_1p",
"ins_muzzleflash_mp40_3rd",
"ins_muzzleflash_mp5_1p",
"ins_muzzleflash_mp5_3rd",
"ins_muzzleflash_sks_1p",
"ins_muzzleflash_sks_3rd",
"ins_muzzleflash_toz_1p",
"ins_muzzleflash_toz_3rd",
"ins_muzzleflash_ump_1p",
"ins_muzzleflash_ump_3rd",
"ins_muzzleflash_ak74_1p",
"ins_muzzleflash_ak74_1p_b",
"ins_muzzleflash_ak74_3rd",
"ins_weapon_tracers",
"ins_weapon_tracers_akm",
"ins_weapon_tracers_c",
"ins_weapon_tracers_c_green",
"ins_weapon_tracers_green",
"ins_weapon_tracers_m14",
"ins_weapon_tracers_m16",
"ins_weapon_tracers_mosin",
"ins_weapon_tracers_mp40",
"ins_weapon_tracers_mp40a1",
"ins_weapon_tracers_mp5",
"ins_weapon_tracers_penetration",
"ins_weapon_tracers_pistol",
"ins_weapon_tracers_red",
"ins_weapon_tracers_sks",
"ins_weapon_tracers_white",
"ins_amb_spring",
"ins_amb_spring_b",
"ins_amb_spring_c",
"ins_amb_spring_d",
"ins_ceiling_dustfall",
"ins_ceiling_fan_Dust",
"ins_dust_screen",
"ins_elevator_smoke",
"ins_flame_jet",
"ins_Flies_Bigger",
"ins_fog_bank",
"ins_fog_low",
"ins_Garbage_1",
"ins_Garbage_1_Night",
"ins_Garbage_Flies",
"ins_Newspapers",
"ins_river_splash_large",
"ins_river_splash_medium",
"ins_river_splash_small",
"ins_river_splash_wide",
"ins_skybox_cumulus",
"ins_skybox_gunrun",
"ins_skybox_lightning",
"ins_skybox_mountain_clouds_flats",
"ins_skybox_mountain_clouds_thick",
"ins_skybox_mountain_clouds_thin",
"ins_skybox_smoke_thin",
"ins_skybox_thundercloud",
"ins_snow_drift",
"ins_sprinkler",
"ins_steam_spray",
"ins_vol_dust_256",
"ins_vol_dust_wide",
"ins_water_rain_splash",
"ins_water_roof_drip",
"ins_water_roof_drip_wide",
"ins_water_roof_stream",
"ins_water_roof_stream_wide",
"ins_water_spray",
"ins_water_spray_impact",
"ins_whirlwind",

------------------------------------------------------------------------------------------------------------------------------------
--// Left 4 Dead Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
"l4d_bug_zapper_cloud",
"l4d_flies_large",
"l4d_Moths",
"l4d_moths_smaller",
"l4d_moths_smallest",
"l4d_roaches_few",
"l4d_roaches_lot",
"l4d_roaches_many",
"l4d_roaches_swarm_432_496",
"l4d_roaches_swarm_512",
"l4d_roaches_swarm_custom",

------------------------------------------------------------------------------------------------------------------------------------
--// Black Ops 3 Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Cosmonaut FX --
"bo3_astronaut_incoming",
"bo3_astronaut_pulse",
---------------------------------
-- Hellhound FX --
"bo3_hellhound_aura",
---------------------------------
-- RAZ Unit FX --
"bo3_mangler_blast",
"bo3_mangler_charge",
"bo3_mangler_pulse",
---------------------------------
-- Margwa FX --
"bo3_margwa_death",
"bo3_margwa_slam",
---------------------------------
-- Nova 6 Crawler FX --
"bo3_n6crawler_aura",
---------------------------------
-- Napalm Zombie FX --
"bo3_napalm_explosion",
"bo3_napalm_fs",
---------------------------------
-- Panzer FX --
"bo3_panzer_elec_blast",
"bo3_panzer_elec_nade",
"bo3_panzer_engine",
"bo3_panzer_explosion",
"bo3_panzer_flame",
"bo3_panzer_landing",
---------------------------------
-- Shrieker FX --
"bo3_shrieker_scream",
---------------------------------
-- Spider FX --
"bo3_spider_impact",
"bo3_spider_projectile",
"bo3_spider_spit",
---------------------------------
-- Thrasher FX --
"bo3_thrasher_aura",
"bo3_thrasher_blood",
---------------------------------
-- Base Zombie FX --
"bo3_zombie_spawn",
"bo3_zombie_eyeglow_orange",
"bo3_zombie_eyeglow_red",
"bo3_zombie_eyeglow_white",

------------------------------------------------------------------------------------------------------------------------------------
--// Half-Life: Alyx - Antlion Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Antlion FX Orange --
"spit_impact_orange",
"spit_impact_lowperf_orange",
"spit_trail_orange",
"spit_trail_glowing_red",
"splat_orange",
"splat_nophys_orange",
---------------------------------
-- Antlion FX Blue --
"spit_impact_blue",
"spit_impact_lowperf_blue",
"spit_trail_blue",
"splat_blue",
"splat_nophys_blue",
---------------------------------
-- Antlion FX --
"AntlionFX_UnBurrow",
"AntlionFX_Burrow",
"AntlionFX_UndGroundMov",

------------------------------------------------------------------------------------------------------------------------------------
--// Horror Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Horror Death FX --
"horror_bloodgibs",
"horror_bloodsplosion",

------------------------------------------------------------------------------------------------------------------------------------
--// Doom 3 Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Shared --
"doom_dissolve",
"doom_dissolve_flameburst",
"doom_hellunit_aura",
"doom_hellunit_spawn_large",
"doom_hellunit_spawn_medium",
"doom_hellunit_spawn_small",
---------------------------------
-- BFG --
"doom_bfg_explosion",
"doom_bfg_explosion_hq",
"doom_bfg_projectile",
"doom_bfg_projectile_hq",
---------------------------------
-- Arch Vile --
"doom_avile_hand",
"doom_avile_blast",
"doom_avile_wave",
"doom_avile_spitfire",
---------------------------------
-- Caco Demon --
"doom_caco_blast",
"doom_caco_blaze",
"doom_caco_nade",
---------------------------------
-- Cyber Demon --
"doom_cyberdemon_breath",
"doom_cyberdemon_jet",
---------------------------------
-- Hellknight --
"doom_hknight_blast",
"doom_hknight_pball",
---------------------------------
-- Imp --
"doom_imp_fireball",
"doom_imp_fireball_cheap",
"doom_imp_fireblast",
---------------------------------
-- Lost Soul --
"doom_lostsoul",
"doom_lostsoul_death",
---------------------------------
-- Mancubus --
"doom_mancu_blast",
"doom_mancu_muzzle",
"doom_mancu_nade",
---------------------------------
-- Revenant --
"doom_rev_missile_blast",
"doom_rev_missile_trail",
"doom_rev_muzzle",
---------------------------------
-- Wraith --
"doom_wraith_postdeath_mist",
"doom_wraith_teleport",

------------------------------------------------------------------------------------------------------------------------------------
--// Arachnid Remade Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Shared FX --
"arach_drool_lower",
"arach_drool_upper",
---------------------------------
-- Acid FX --
"acidbug_spit_impact",
"acidbug_spit_impact_lowperf",
"acidbug_spit_trail",
"acidbug_splat",
"acidbug_splat_nophys",

------------------------------------------------------------------------------------------------------------------------------------
--// Fallout Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Centaur --
"centaur_spit",
---------------------------------
-- Feral Ghoul --
"glowingone_testA",
"glowingone_testB",
"glowingone_testC",
"goregrenade_splash",
"radiation_shockwave",
"radiation_shockwave_debris",
"radiation_shockwave_ring",
"radswave",
---------------------------------
-- Mirelurk --
"magmalurk_flame",
"magmalurk_flame_pilot",
"fo3_mirelurk_charge",
"fo3_mirelurk_pulse",
"fo3_mirelurk_hybrid",
---------------------------------
-- Spore Carrier --
"spore_splash",
"spore_splash_02",
"spore_splash_03",
"spore_splash_05",
"spore_splash_player",
"spore_splash_player_splat",
"spore_trail",
"sporecarrier_glow",
"sporecarrier_radiation",
"sporecarrier_radiation_debris",
"sporecarrier_radiation_ring",
------------------------------------------------------------------------------------------------------------------------------------
--// Thresher Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
"tm_ground",
"tm_ground_inf",

------------------------------------------------------------------------------------------------------------------------------------
--// Halo Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Shield FX --
"hcea_shield_impact",
"hcea_shield_recharged",
"hcea_shield_enabled",
"hcea_shield_disperse",
---------------------------------
-- Hunter AB FX --
"hcea_hunter_ab_charge",
"hcea_hunter_ab_explode",
"hcea_hunter_ab_muzzle",
"hcea_hunter_ab_proj",
---------------------------------
-- Hunter FRG FX --
"hcea_hunter_frg_charge",
"hcea_hunter_frg_explode",
"hcea_hunter_frg_muzzle",
"hcea_hunter_frg_proj",
"hcea_hunter_frg_proj_lightning_trcr_e",
---------------------------------
-- Hunter Shade Cannon FX --
"hcea_hunter_shade_cannon_trigger_muzzle",
"hcea_hunter_shade_cannon_proj",
"hcea_hunter_shade_cannon_explode_ground",
"hcea_hunter_shade_cannon_explode_air",
---------------------------------
-- Hunter Canister FX --
"hcea_hunter_canister_green",
"hcea_hunter_canister_purple",
"hcea_hunter_canister_orange",
---------------------------------
-- Flood FX --
"hcea_flood_carrier_death",
"hcea_flood_infected_death",
"hcea_flood_runner_death",
---------------------------------
-- Hunter FX --
"hcea_hunter_particle_carbine",
"hcea_hunter_particle_carbine_impact",
"hcea_hunter_needler_muzzle",
"hcea_hunter_needler_proj",
"hcea_hunter_needler_pistol_impact",
"hcea_hunter_plasma_rifle_fire",
"hcea_hunter_plasma_rifle_proj",
"hcea_hunter_plasma_rifle_impact",
"hcea_hunter_plasma_pistol_fire",
"hcea_hunter_plasma_pistol_proj",
"hcea_hunter_plasma_pistol_impact",
---------------------------------
-- Beam FX --
"halo_beam_main",
"halo_beam_trail_1",
"halo_beam_trail_2",
"halo_beam_trail_3",
"halo_beam_trail_glow_1",
"halo_beam_trail_glow_2",
"halo_beam_trail_glow_3",
---------------------------------
-- Flood FX --
"hcea_flood_car_death",
"hcea_flood_car_death_core",
"hcea_flood_car_death_dirt",
"hcea_flood_car_death_frag",
"hcea_flood_car_death_frag_2",
"hcea_flood_car_death_gibs",
"hcea_flood_car_death_smoke",
"hcea_flood_car_death_smoke_2",
"hcea_flood_car_death_splat",
"hcea_flood_car_death_splat_2",
"hcea_flood_car_death_splatter",
"hcea_flood_car_death_swave_xy",
"hcea_flood_car_death_swave_xz",
"hcea_flood_inf_death",
"hcea_flood_inf_death_core",
"hcea_flood_inf_death_gibs",
"hcea_flood_inf_death_largesplat",
---------------------------------
-- Hunter Shared FX --
"hcea_gold_hunter_charge",
"hcea_red_hunter_charge",
"hcea_purple_hunter_charge",
"hcea_hunter_charge",
"hcea_hunter_frnade_hit",
"hcea_hunter_frnade_nade",
"hcea_red_hunter_nade",
"hcea_hunter_cannister",
"hcea_gold_hunter_cannister",
"hcea_red_hunter_cannister",
"hcea_purple_hunter_cannister",
"hcea_hunter_impact_generic",
"hcea_red_hunter_muzzle",
"hcea_gold_hunter_muzzle",
"hcea_red_hunter_hit",
"hcea_gold_hunter_hit",
---------------------------------
-- Plasma Pistol FX --
"hcea_t25p_charge",
"hcea_t25p_charge_core",
"hcea_t25p_charge_glow",
"hcea_t25p_hit",
"hcea_t25p_hit_blitz",
"hcea_t25p_hit_collide",
"hcea_t25p_hit_flicker",
"hcea_t25p_hit_glow",
"hcea_t25p_muzzle",
"hcea_t25p_muzzle_charged",
"hcea_t25p_muzzle_charged_core",
"hcea_t25p_muzzle_core",
"hcea_t25p_muzzle_core_2",
"hcea_t25p_muzzle_embers",
"hcea_t25p_muzzle_flames",
"hcea_t25p_muzzle_glow",
"hcea_t25p_muzzle_heat",
"hcea_t25p_muzzle_lghtning",
"hcea_t25p_tracer",
"hcea_t25p_tracer_charged",
"hcea_t25p_tracer_charged_fadeglow",
"hcea_t25p_tracer_charged_sparks",
"hcea_t25p_tracer_fadeglow",
"hcea_t25p_tracer_line",
---------------------------------
-- Plasma Rifle FX --
"hcea_t25r_core",
"hcea_t25r_core_2",
"hcea_t25r_embers",
"hcea_t25r_flames",
"hcea_t25r_flames_0a",
"hcea_t25r_flames_2",
"hcea_t25r_glow",
"hcea_t25r_lghtning",
"hcea_t25r_muzzle",
"hcea_t25r_tracer",
"hcea_t25r_tracer_fadeglow",
"hcea_t25r_tracer_halo_nopunintended",
"hcea_t25r_tracer_line",
------------------------------------------------------------------------------------------------------------------------------------
--// Monster Hunter Particle FX \\--
------------------------------------------------------------------------------------------------------------------------------------
-- Roar --
"mh_monster_scream_large",
}
for _,v in ipairs(particlename) do PrecacheParticleSystem(v) end
--PATH lua/autorun/turk_addon.lua:
player_manager.AddValidModel( "Pirate Turk", "models/player/ohanak_gang/pm_pirate_turk.mdl" );
list.Set( "PlayerOptionsModel",  "Pirate Turk", "models/player/ohanak_gang/pm_pirate_turk.mdl" );


--PATH lua/autorun/twk_slave_dancer_addon.lua:
return gluapack()()
--PATH lua/autorun/twk_slave_dancer_addon.lua:
player_manager.AddValidModel( "Twi'lek Slave Dancer", "models/player/slave/twilek_slave_female_dancer.mdl" );
list.Set( "PlayerOptionsModel",  "Twi'lek Slave Dancer", "models/player/slave/twilek_slave_female_dancer.mdl" );


--PATH lua/autorun/venator_border_toggle.lua:
return gluapack()()
--PATH lua/autorun/venator_visual_alarm.lua:
return gluapack()()
--PATH lua/autorun/vj_base_autorun.lua:
/*--------------------------------------------------
	=============== VJ Base Autorun ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.

	██    ██      ██     ██████   █████  ███████ ███████
	██    ██      ██     ██   ██ ██   ██ ██      ██
	██    ██      ██     ██████  ███████ ███████ █████
	 ██  ██  ██   ██     ██   ██ ██   ██      ██ ██
	  ████    █████      ██████  ██   ██ ███████ ███████

--------------------------------------------------*/
if CLIENT then print("Loading VJ Base (Client)...") else print("Loading VJ Base (Server)...") end

VJBASE_VERSION = "2.16.0c"

-- Shared --
AddCSLuaFile("autorun/vj_menu_spawninfo.lua")
AddCSLuaFile("autorun/vj_base_autorun.lua")
AddCSLuaFile("autorun/vj_controls.lua")
AddCSLuaFile("autorun/vj_globals.lua")
AddCSLuaFile("autorun/vj_convars.lua")
AddCSLuaFile("autorun/vj_files.lua")
AddCSLuaFile("autorun/vj_files_language.lua")
AddCSLuaFile("autorun/vj_files_particles.lua")
AddCSLuaFile("autorun/vj_menu_main.lua")
AddCSLuaFile("autorun/vj_menu_properties.lua")

-- Client --
AddCSLuaFile("autorun/client/vj_menu_main_client.lua")
AddCSLuaFile("autorun/client/vj_menu_plugins.lua")
AddCSLuaFile("autorun/client/vj_menu_snpc.lua")
AddCSLuaFile("autorun/client/vj_menu_weapon.lua")

-- Modules --
AddCSLuaFile("includes/modules/ai_vj_schedule.lua")
AddCSLuaFile("includes/modules/ai_vj_task.lua")
//AddCSLuaFile("includes/modules/sound_vj_track.lua")

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Main Hooks / Functions ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if SERVER then
	util.AddNetworkString("vj_welcome_msg")
	util.AddNetworkString("vj_meme")
elseif CLIENT then
	hook.Add("AddToolMenuTabs", "VJ_CREATETOOLTAB", function()
		spawnmenu.AddToolTab("DrVrej", "DrVrej", "vj_base/icons/vrejgaming.png") // "icon16/plugin.png"
		spawnmenu.AddToolCategory("DrVrej", "Main Menu", "#vjbase.menu.tabs.mainmenu")
		spawnmenu.AddToolCategory("DrVrej", "SNPCs", "#vjbase.menu.tabs.settings.snpc")
		spawnmenu.AddToolCategory("DrVrej", "Weapons", "#vjbase.menu.tabs.settings.weapon")
		spawnmenu.AddToolCategory("DrVrej", "HUDs", "#vjbase.menu.tabs.settings.hud")
		spawnmenu.AddToolCategory("DrVrej", "Tools", "#vjbase.menu.tabs.tools")
		spawnmenu.AddToolCategory("DrVrej", "SNPC Configures", "#vjbase.menu.tabs.configures.snpc")
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PlayerInitialSpawn", "VJBaseSpawn", function(ply, transition)
	-- Simple message for the users
	timer.Simple(1, function()
		net.Start("vj_welcome_msg")
		net.Send(ply)
	end)
	
	if !game.SinglePlayer() && ply:SteamID() == "STEAM_0:0:22688298" then
		PrintMessage(HUD_PRINTTALK, "DrVrej Has Joined The Game!")
		PrintMessage(HUD_PRINTCENTER, "DrVrej Has Joined The Game!")
		local sd = CreateSound(game.GetWorld(), "vj_misc/illuminati_confirmed.mp3")
		sd:SetSoundLevel(0)
		sd:Play()
		timer.Simple(10, function() if sd then sd:Stop() end end)
	end
end)
---------------------------------------------------------------------------------------------------------------------------------------------
net.Receive("vj_meme", function(len, pl)
	if pl:IsPlayer() && pl:SteamID() == "STEAM_0:0:22688298" then
		PrintMessage(HUD_PRINTTALK, "DrVrej is in the server!")
		local sd = CreateSound(game.GetWorld(), "vj_misc/illuminati_confirmed.mp3")
		sd:SetSoundLevel(0)
		sd:Play()
	end
end)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Outdated GMod Version Check ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if SERVER && !isfunction(FindMetaTable("Entity").SetSurroundingBoundsType) then
	timer.Simple(1, function()
		if !VJBASE_ERROR_GAME_OUTDATED then
			VJBASE_ERROR_GAME_OUTDATED = true
			timer.Create("VJBASE_ERROR_GAME_OUTDATED", 2, 1, function()
				PrintMessage(HUD_PRINTTALK, "--- Outdated version of Garry's Mod detected! ---")
				PrintMessage(HUD_PRINTTALK, "Major parts of VJ Base AI are now disabled! Expect errors & AI issues!")
				PrintMessage(HUD_PRINTTALK, "REASON: Game is running on 64-bit or Chromium or is pirated!")
			end)
		end
	end)
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ SLV Base Check ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if (SLVBase) then
	timer.Simple(1, function()
		if !VJBASE_ERROR_CONFLICT then
			VJBASE_ERROR_CONFLICT = true
			if CLIENT then
				chat.AddText(Color(255,100,0),"Confliction Detected!",
				Color(0,255,0)," VJ Base ",
				Color(255,255,255),"is being overridden by another addon!")
				chat.AddText(Color(0,200,200),"Incompatible Addons: http://steamcommunity.com/sharedfiles/filedetails/?id=1129493108")

				local frame = vgui.Create("DFrame")
				frame:SetSize(600, 200)
				frame:SetPos((ScrW() - frame:GetWide()) / 2, (ScrH() - frame:GetTall()) / 2)
				frame:SetTitle("VJ Base Error: Confliction Detected!")
				frame:SetBackgroundBlur(true)
				frame:MakePopup()
	
				local labelTitle = vgui.Create("DLabel", frame)
				labelTitle:SetPos(130, 30)
				labelTitle:SetText("CONFLICTION DETECTED!")
				labelTitle:SetFont("VJFont_Trebuchet24_Large")
				labelTitle:SetTextColor(Color(255,128,128))
				labelTitle:SizeToContents()
				
				local label1 = vgui.Create("DLabel", frame)
				label1:SetPos(70, 70)
				label1:SetText("VJ Base is being overridden by another addon!")
				label1:SetFont("VJFont_Trebuchet24_Medium")
				label1:SizeToContents()
				
				local label2 = vgui.Create("DLabel", frame)
				label2:SetPos(10, 100)
				label2:SetText("You have an addon installed that is overriding something in VJ Base. Uninstall the conflicting addon, and then restart your\n game to fix it. Click the link below to view all known incompatible addons. If you find any addons that are conflicting with\n                    VJ Base, be sure to leave a comment in the collection with a link to the incompatible addon!")
				label2:SizeToContents()
				
				local link = vgui.Create("DLabelURL", frame)
				link:SetSize(300, 20)
				link:SetPos(180, 140)
				link:SetText("Incompatible_addons_(Steam_Workshop_Collection)")
				link:SetURL("http://steamcommunity.com/sharedfiles/filedetails/?id=1129493108")
				
				local buttonClose = vgui.Create("DButton", frame)
				buttonClose:SetText("CLOSE")
				buttonClose:SetPos(260, 160)
				buttonClose:SetSize(80, 35)
				buttonClose.DoClick = function()
					frame:Close()
				end
			elseif SERVER then
				timer.Create("VJBASE_ERROR_CONFLICT", 5, 0, function()
					print("VJ Base is being overridden by another addon! Incompatible Addons: http://steamcommunity.com/sharedfiles/filedetails/?id=1129493108")
				end)
			end
		end
	end)
end

if CLIENT then print("VJ Base client files initialized!") else print("VJ Base server files initialized!") end
--PATH lua/autorun/vj_files_particles.lua:
/*--------------------------------------------------
	=============== Particles ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
INFO: Used to load Particles for VJ Base
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Half Life 2 Episode 2 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
VJ.AddParticle("particles/antlion_gib_01.pcf",{
	"antlion_gib_01",
	"antlion_gib_01_juice",
	"antlion_gib_01_trailsA",
	"antlion_gib_01_trailsb",
})
VJ.AddParticle("particles/antlion_gib_02.pcf",{
	"antlion_gib_02",
	"antlion_gib_02_blood",
	"antlion_gib_02_floaters",
	"antlion_gib_02_gas",
	"antlion_gib_02_juice",
	"antlion_gib_02_slime",
	"antlion_gib_02_trailsA",
	"antlion_gib_02_trailsB",
})
VJ.AddParticle("particles/antlion_worker.pcf",{
	"antlion_spit",
	"antlion_spit_02",
	"antlion_spit_03",
	"antlion_spit_05",
	"antlion_spit_player",
	"antlion_spit_player_splat",
	"antlion_spit_trail",
})
VJ.AddParticle("particles/grub_blood.pcf",{
	"GrubBlood",
	"GrubSquashBlood",
	"GrubSquashBlood2",
})
VJ.AddParticle("particles/fire_01.pcf",{
	"burning_engine_01",
	"burning_engine_fire",
	"burning_gib_01",
	"burning_gib_01_drag",
	"burning_gib_01_follower1",
	"burning_gib_01_follower2",
	"burning_gib_01b",
	"burning_vehicle",
	"burning_wood_01",
	"burning_wood_01b",
	"burning_wood_01c",
	"embers_large_01",
	"embers_large_02",
	"embers_medium_01",
	"embers_medium_03",
	"embers_small_01",
	"env_embers_large",
	"env_embers_medium",
	"env_embers_medium_spread",
	"env_embers_small",
	"env_embers_small_spread",
	"env_embers_tiny",
	"env_fire_large",
	"env_fire_tiny_smoke",
	"explosion_huge",
	"explosion_huge_b",
	"explosion_silo",
	"fire_jet_01",
	"fire_jet_01_flame",
	"fire_large_01",
	"fire_large_02",
	"fire_large_02_filler",
	"fire_large_02_fillerb",
	"fire_large_base",
	"fire_medium_01",
	"fire_medium_01_glow",
	"fire_medium_02",
	"fire_medium_02_nosmoke",
	"fire_medium_heatwave",
	"fire_small_01",
	"fire_small_02",
	"fire_small_03",
	"fire_small_base",
	"fire_small_flameouts",
	"fire_verysmall_01",
	"smoke_burning_engine_01",
	"smoke_exhaust_01",
	"smoke_exhaust_01a",
	"smoke_exhaust_01b",
	"smoke_gib_01",
	"smoke_large_01",
	"smoke_large_01b",
	"smoke_large_02",
	"smoke_large_02b",
	"smoke_medium_01",
	"smoke_medium_02",
	"smoke_medium_02 Version #2",
	"smoke_medium_02b",
	"smoke_medium_02b Version #2",
	"smoke_medium_02c",
	"smoke_medium_02d",
	"smoke_small_01",
	"smoke_small_01b",
})
VJ.AddParticle("particles/Advisor_FX.pcf",{
	"Advisor_Pod_Steam_Continuous",
})
VJ.AddParticle("particles/striderbuster.pcf",{
	"striderbuster_attach",
	"striderbuster_break",
	"striderbuster_break_explode",
	"striderbuster_explode_core",
})
VJ.AddParticle("particles/steampuff.pcf",{
	"steam_jet_50",
	"steam_jet_50_steam",
	"steam_jet_80",
	"steam_jet_80_drops",
	"steam_jet_80_dropsteam",
	"steam_jet_80_steam",
	"steam_large_01",
	"steampuff",
})
VJ.AddParticle("particles/weapon_fx.pcf",{
	"Rocket_Smoke",
	"explosion_turret_break",
	"explosion_turret_fizzle",
	"explosion_turret_break_b",
	"explosion_turret_break_chunks",
	"explosion_turret_break_embers",
	"explosion_turret_break_fire",
	"explosion_turret_break_fire_over",
	"explosion_turret_break_flash",
	"explosion_turret_break_pre_flash",
	"explosion_turret_break_pre_smoke",
	"explosion_turret_break_pre_smoke Version #2",
	"explosion_turret_break_pre_sparks",
	"explosion_turret_break_sparks",
	"Weapon_Combine_Ion_Cannon",
	"Weapon_Combine_Ion_Cannon_a",
	"Weapon_Combine_Ion_Cannon_b",
	"Weapon_Combine_Ion_Cannon_c",
	"Weapon_Combine_Ion_Cannon_d",
	"Weapon_Combine_Ion_Cannon_e",
	"Weapon_Combine_Ion_Cannon_Backup",
	"Weapon_Combine_Ion_Cannon_Beam",
	"Weapon_Combine_Ion_Cannon_Black",
	"Weapon_Combine_Ion_Cannon_Explosion",
	"Weapon_Combine_Ion_Cannon_Explosion_b",
	"Weapon_Combine_Ion_Cannon_Exlposion_c",
	"Weapon_Combine_Ion_Cannon_Explosion_d",
	"Weapon_Combine_Ion_Cannon_Explosion_e",
	"Weapon_Combine_Ion_Cannon_Explosion_f",
	"Weapon_Combine_Ion_Cannon_Explosion_g",
	"Weapon_Combine_Ion_Cannon_Explosion_h",
	"Weapon_Combine_Ion_Cannon_Explosion_i",
	"Weapon_Combine_Ion_Cannon_Explosion_j",
	"Weapon_Combine_Ion_Cannon_Explosion_k",
	"Weapon_Combine_Ion_Cannon_f",
	"Weapon_Combine_Ion_Cannon_g",
	"Weapon_Combine_Ion_Cannon_h",
	"Weapon_Combine_Ion_Cannon_h Version #2",
	"Weapon_Combine_Ion_Cannon_i",
	"Weapon_Combine_Ion_Cannon_Intake",
	"Weapon_Combine_Ion_Cannon_Intake_b",
})
VJ.AddParticle("particles/aurora_sphere2.pcf",{
	"aurora_shockwave",
	"aurora_shockwave_debris",
	"aurora_shockwave_ring",
	"demo_aurora_01",
})

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Black Mesa Source ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
VJ.AddParticle("particles/vj_bms_turret.pcf",{
	"vj_bms_turret_full",
	"vj_bms_turret_muzzle_core",
	"vj_bms_turret_muzzle_glow",
	"vj_bms_turret_muzzle_smoke",
	"vj_bms_turret_muzzle_sparks",
	"vj_bms_turret_muzzle_sparks2",
})

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ VJ Base ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
VJ.AddParticle("particles/vj_blood1.pcf",{
	"vj_bleedout_blue",
	"vj_bleedout_blue_small",
	"vj_bleedout_blue_tiny",
	"vj_bleedout_green",
	"vj_bleedout_green_small",
	"vj_bleedout_green_tiny",
	"vj_bleedout_oil",
	"vj_bleedout_oil_small",
	"vj_bleedout_oil_tiny",
	"vj_bleedout_orange",
	"vj_bleedout_orange_small",
	"vj_bleedout_orange_tiny",
	"vj_bleedout_purple",
	"vj_bleedout_purple_small",
	"vj_bleedout_purple_tiny",
	"vj_bleedout_red",
	"vj_bleedout_red_small",
	"vj_bleedout_red_tiny",
	"vj_bleedout_white",
	"vj_bleedout_white_small",
	"vj_bleedout_white_tiny",
	"vj_bleedout_yellow",
	"vj_bleedout_yellow_small",
	"vj_bleedout_yellow_tiny",
})
VJ.AddParticle("particles/vj_impact1.pcf",{
	"vj_impact1_black",
	"vj_impact1_blue",
	"vj_impact1_green",
	"vj_impact1_orange",
	"vj_impact1_purple",
	"vj_impact1_red",
	"vj_impact1_white",
	"vj_impact1_yellow",
	"vj_impact1_centaurspit",
})
VJ.AddParticle("particles/vj_explosions1.pcf",{
	"vj_explosion1",
	"vj_explosion2",
	"vj_explosion3",
	"vj_explosionfire1",
	"vj_explosionfire2",
	"vj_explosionfire3",
	"vj_explosionfire4",
	"vj_explosionfire5",
	"vj_explosionflash1",
	"vj_explosionflash2",
	"vj_explosionspark1",
	"vj_explosionspark2",
	"vj_explosionspark3",
	"vj_explosionspark4",
	"vj_shockwave1",
	"vj_shockwave2",
	"vj_smoke1",
	"vj_smoke2",
	"vj_smokespike1",
	"vj_rocks1",
	"vj_rocks2",
	"vj_debris1",
	"vj_dirt1",
})
VJ.AddParticle("particles/vj_rpgtrails1.pcf",{
	"vj_rpg1_fulltrail",
	"vj_rpg1_flare",
	"vj_rpg1_smoke",
})
VJ.AddParticle("particles/vj_rpgtrails2.pcf",{
	"vj_rpg2_fulltrail",
	"vj_rpg2_smoke1",
	"vj_rpg2_smoke2",
	"vj_rpg2_fire",
	"vj_rpg2_flare",
	"vj_rpg2_glow",
})
VJ.AddParticle("particles/vj_weaponfx_rifle.pcf",{
	"vj_rifle_smoke",
	"vj_rifle_smoke_dark",
	"vj_rifle_sparks1",
	"vj_rifle_sparks2",
	-- Regular
	"vj_rifle_full",
	"vj_rifle_glow",
	"vj_rifle_glow_large",
	"vj_rifle_inner",
	"vj_rifle_side",
	"vj_rifle_side_glow",
	"vj_rifle_smoke_flash",
	"vj_rifle_top",
	"vj_rifle_top_glow",
	"vj_rifle_top_left_glow",
	-- Blue
	"vj_rifle_full_blue",
	"vj_rifle_glow_blue",
	"vj_rifle_glow_large_blue",
	"vj_rifle_inner_blue",
	"vj_rifle_side_blue",
	"vj_rifle_side_glow_blue",
	"vj_rifle_smoke_flash_blue",
	"vj_rifle_top_blue",
	"vj_rifle_top_glow_blue",
	"vj_rifle_top_left_glow_blue",
})
--PATH lua/autorun/vj_globals.lua:
/*--------------------------------------------------
	=============== Global Functions & Variables ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
include('autorun/vj_controls.lua')
-- Localized static values
local CurTime = CurTime
local IsValid = IsValid
local GetConVar = GetConVar
local CreateSound = CreateSound
local istable = istable
local isstring = isstring
local isnumber = isnumber
local tonumber = tonumber
local string_find = string.find
local string_Replace = string.Replace
local string_StartWith = string.StartWith
local string_lower = string.lower
local table_remove = table.remove
local math_clamp = math.Clamp
local math_random = math.random
local math_round = math.Round
local math_floor = math.floor
local bAND = bit.band
local bShiftL = bit.lshift
local bShiftR = bit.rshift
local sdEmitHint = sound.EmitHint
local defAng = Angle(0, 0, 0)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Global Functions & Variables ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
VJ_CVAR_IGNOREPLAYERS = GetConVar("ai_ignoreplayers"):GetInt() != 0

-- NPC movement types, information is located inside the NPC bases...
VJ_MOVETYPE_GROUND = 1
VJ_MOVETYPE_AERIAL = 2
VJ_MOVETYPE_AQUATIC = 3
VJ_MOVETYPE_STATIONARY = 4
VJ_MOVETYPE_PHYSICS = 5

-- NPC behavior types, information is located inside the NPC bases...
VJ_BEHAVIOR_AGGRESSIVE = 1
VJ_BEHAVIOR_NEUTRAL = 2
VJ_BEHAVIOR_PASSIVE = 3
VJ_BEHAVIOR_PASSIVE_NATURE = 4

-- NPC AI states
VJ_STATE_NONE = 0 -- No state is set (Default)
VJ_STATE_FREEZE = 1 -- AI Completely freezes, basically applies Disable AI on the NPC (Including relationship system!)
VJ_STATE_ONLY_ANIMATION = 100 -- Only plays animation tasks, attacks. Disables: Movements, turning and other non-animation tasks!
VJ_STATE_ONLY_ANIMATION_CONSTANT = 101 -- Same as VJ_STATE_ONLY_ANIMATION + Idle animation will not play!
VJ_STATE_ONLY_ANIMATION_NOATTACK = 102 -- Same as VJ_STATE_ONLY_ANIMATION + Attacks will be disabled

-- NPC attack type
VJ_ATTACK_NONE = 0 -- No state is set (Default)
VJ_ATTACK_CUSTOM = 1 -- Custom attack (Used by developers to make custom attacks)
VJ_ATTACK_MELEE = 2 -- Melee attack
VJ_ATTACK_RANGE = 3 -- Ranged attack
VJ_ATTACK_LEAP = 4 -- Leap attack
VJ_ATTACK_GRENADE = 5 -- Grenade attack

-- NPC attack status
VJ_ATTACK_STATUS_NONE = 0 -- No state is set (Default)
VJ_ATTACK_STATUS_DONE = 1 -- The current attack has been executed completely and is marked as done
VJ_ATTACK_STATUS_STARTED = 2 -- The current attack has started and is expected to execute soon
VJ_ATTACK_STATUS_EXECUTED = 10 -- The current attack has been executed at least once
VJ_ATTACK_STATUS_EXECUTED_HIT = 11 -- The current attack has been executed at least once AND hit an entity at least once (Melee & Leap attacks)

-- NPC weapon states for the human base
VJ_WEP_STATE_READY = 0 -- No state is set (Default)
VJ_WEP_STATE_HOLSTERED = 1 -- Weapon is holstered
VJ_WEP_STATE_RELOADING = 2 -- Weapon is reloading

-- NPC weapon inventory status
VJ_WEP_INVENTORY_NONE = 0 -- Currently using no weapon (Default)
VJ_WEP_INVENTORY_PRIMARY = 1 -- Currently using its primary weapon
VJ_WEP_INVENTORY_SECONDARY = 2 -- Currently using its secondary weapon
VJ_WEP_INVENTORY_MELEE = 3 -- Currently using its melee weapon
VJ_WEP_INVENTORY_ANTI_ARMOR = 4 -- Currently using its anti-armor weapon

-- NPC facing status
VJ_FACING_NONE = 0 -- No status is set (Default)
VJ_FACING_ENEMY = 1 -- Currently attempting to face the enemy
VJ_FACING_ENTITY = 2 -- Currently attempting to face a specific entity
VJ_FACING_POSITION = 3 -- Currently attempting to face a specific position

-- NPC model animation set
VJ_MODEL_ANIMSET_NONE = 0 -- No model animation set detected (Default)
VJ_MODEL_ANIMSET_COMBINE = 1 -- Current model's animation set is combine
VJ_MODEL_ANIMSET_METROCOP = 2 -- Current model's animation set is metrocop
VJ_MODEL_ANIMSET_REBEL = 3 -- Current model's animation set is citizen / rebel
VJ_MODEL_ANIMSET_PLAYER = 4 -- Current model's animation set is player
VJ_MODEL_ANIMSET_CUSTOM = 10 -- Use this when defining a custom model set

-- Source NPC condition definitions because they are not defined in GMod for some reason ??
COND_BEHIND_ENEMY = 29
COND_BETTER_WEAPON_AVAILABLE = 46
COND_CAN_MELEE_ATTACK1 = 23
COND_CAN_MELEE_ATTACK2 = 24
COND_CAN_RANGE_ATTACK1 = 21
COND_CAN_RANGE_ATTACK2 = 22
COND_ENEMY_DEAD = 30
COND_ENEMY_FACING_ME = 28
COND_ENEMY_OCCLUDED = 13
COND_ENEMY_TOO_FAR = 27
COND_ENEMY_UNREACHABLE = 31
COND_ENEMY_WENT_NULL = 12
COND_FLOATING_OFF_GROUND = 61
COND_GIVE_WAY = 48
COND_HAVE_ENEMY_LOS = 15
COND_HAVE_TARGET_LOS = 16
COND_HEALTH_ITEM_AVAILABLE = 47
COND_HEAR_BUGBAIT = 52
COND_HEAR_BULLET_IMPACT = 56
COND_HEAR_COMBAT = 53
COND_HEAR_DANGER = 50
COND_HEAR_MOVE_AWAY = 58
COND_HEAR_PHYSICS_DANGER = 57
COND_HEAR_PLAYER = 55
COND_HEAR_SPOOKY = 59
COND_HEAR_THUMPER = 51
COND_HEAR_WORLD = 54
COND_HEAVY_DAMAGE = 18
COND_IDLE_INTERRUPT = 2
COND_IN_PVS = 1
COND_LIGHT_DAMAGE = 17
COND_LOST_ENEMY = 11
COND_LOST_PLAYER = 33
COND_LOW_PRIMARY_AMMO = 3
COND_MOBBED_BY_ENEMIES = 62
COND_NEW_ENEMY = 26
COND_NO_CUSTOM_INTERRUPTS = 70
COND_NO_HEAR_DANGER = 60
COND_NO_PRIMARY_AMMO = 4
COND_NO_SECONDARY_AMMO = 5
COND_NO_WEAPON = 6
COND_NONE = 0
COND_NOT_FACING_ATTACK = 40
COND_NPC_FREEZE = 67
COND_NPC_UNFREEZE = 68
COND_PHYSICS_DAMAGE = 19
COND_PLAYER_ADDED_TO_SQUAD = 64
COND_PLAYER_PUSHING = 66
COND_PLAYER_REMOVED_FROM_SQUAD = 65
COND_PROVOKED = 25
COND_RECEIVED_ORDERS = 63
COND_REPEATED_DAMAGE = 20
COND_SCHEDULE_DONE = 36
COND_SEE_DISLIKE = 9
COND_SEE_ENEMY = 10
COND_SEE_FEAR = 8
COND_SEE_HATE = 7
COND_SEE_NEMESIS = 34
COND_SEE_PLAYER = 32
COND_SMELL = 37
COND_TALKER_RESPOND_TO_QUESTION = 69
COND_TARGET_OCCLUDED = 14
COND_TASK_FAILED = 35
COND_TOO_CLOSE_TO_ATTACK = 38
COND_TOO_FAR_TO_ATTACK = 39
COND_WAY_CLEAR = 49
COND_WEAPON_BLOCKED_BY_FRIEND = 42
COND_WEAPON_HAS_LOS = 41
COND_WEAPON_PLAYER_IN_SPREAD = 43
COND_WEAPON_PLAYER_NEAR_TARGET = 44
COND_WEAPON_SIGHT_OCCLUDED = 45
---------------------------------------------------------------------------------------------------------------------------------------------
if SERVER then
	util.AddNetworkString("vj_music_run")
	
	require("ai_vj_schedule")
	local getSched = ai_vj_schedule.New
	function ai_vj_schedule.New(name)
		local actualSched = getSched(name)
		actualSched.Name = name
		return actualSched
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_PICK(tbl)
	if not tbl then return false end -- Yete table pame choone meche, veratartsour false!
	if istable(tbl) then
		if #tbl < 1 then return false end -- Yete table barabe (meg en aveli kich), getsoor!
		tbl = tbl[math_random(1, #tbl)]
		return tbl
	else
		return tbl -- Yete table che, veratartsour abranke
	end
	return false
end
-- !!!!!!!!!!!!!! DO NOT USE THIS FUNCTION !!!!!!!!!!!!!! [Backwards Compatibility!]
	function VJ_PICKRANDOMTABLE(tbl)
		if not tbl then return false end -- Yete table pame choone meche, veratartsour false!
		if istable(tbl) then
			if #tbl < 1 then return false end -- Yete table barabe (meg en aveli kich), getsoor!
			tbl = tbl[math_random(1,#tbl)]
			return tbl
		else
			return tbl -- Yete table che, veratartsour abranke
		end
		return false
	end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_STOPSOUND(sdName)
	if sdName then sdName:Stop() end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_Set(a, b) -- A set of 2 numbers: a, b
	return {a = a, b = b}
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_HasValue(tbl, val)
	if !istable(tbl) then return false end
	for x = 1, #tbl do
		if tbl[x] == val then
			return true
		end
	end
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_RoundToMultiple(num, multiple) -- Credits to Bizzclaw for pointing me to the right direction!
	if math_round(num / multiple) == num / multiple then
		return num
	else
		return math_round(num / multiple) * multiple
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_Color2Byte(color)
	return bShiftL(math_floor(color.r*7/255), 5) + bShiftL(math_floor(color.g*7/255), 2) + math_floor(color.b*3/255)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_Color8Bit2Color(bits)
	return Color(bShiftR(bits,5)*255/7, bAND(bShiftR(bits,2), 0x07)*255/7, bAND(bits,0x03)*255/3)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_FindInCone(pos, dir, dist, deg, extraOptions)
	extraOptions = extraOptions or {}
		local allEntities = extraOptions.AllEntities or false -- Should it detect all types of entities? | False = NPCs and Players only!
	local foundEnts = {}
	local cosDeg = math.cos(math.rad(deg))
	for _,v in ipairs(ents.FindInSphere(pos, dist)) do
		if ((allEntities == true) or (allEntities == false && (v:IsNPC() or v:IsPlayer()))) && (dir:Dot((v:GetPos() - pos):GetNormalized()) > cosDeg) then
			foundEnts[#foundEnts + 1] = v
		end
	end
	return foundEnts
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_CreateSound(ent, sdFile, sdLevel, sdPitch, customFunc)
	if not sdFile then return end
	if istable(sdFile) then
		if #sdFile < 1 then return end -- If the table is empty then end it
		sdFile = sdFile[math_random(1, #sdFile)]
	end
	if ent.OnCreateSound then -- Will allow people to alter sounds before they are played
		sdFile = ent:OnCreateSound(sdFile)
	end
	local sdID = CreateSound(ent, sdFile)
	sdID:SetSoundLevel(sdLevel or 75)
	if (customFunc) then customFunc(sdID) end
	sdID:PlayEx(1, sdPitch or 100)
	ent.LastPlayedVJSound = sdID
	if ent.OnPlayCreateSound then
		ent:OnPlayCreateSound(sdID, sdFile)
	end
	return sdID
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_EmitSound(ent, sdFile, sdLevel, sdPitch, sdVolume, sdChannel)
	if not sdFile then return end
	if istable(sdFile) then
		if #sdFile < 1 then return end -- If the table is empty then end it
		sdFile = sdFile[math_random(1, #sdFile)]
	end
	if ent.OnCreateSound then -- Will allow people to alter sounds before they are played
		sdFile = ent:OnCreateSound(sdFile)
	end
	ent:EmitSound(sdFile, sdLevel, sdPitch, sdVolume, sdChannel)
	ent.LastPlayedVJSound = sdFile
	if ent.OnPlayEmitSound then ent:OnPlayEmitSound(sdFile) end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_AnimationExists(ent, anim)
	if anim == nil or isbool(anim) then return false end
	
	-- Get rid of the gesture prefix
	if string_find(anim, "vjges_") then
		anim = string_Replace(anim, "vjges_", "")
		if ent:LookupSequence(anim) == -1 then
			anim = tonumber(anim)
		end
	end
	
	if isnumber(anim) then -- Activity
		if (ent:SelectWeightedSequence(anim) == -1 or ent:SelectWeightedSequence(anim) == 0) && (ent:GetSequenceName(ent:SelectWeightedSequence(anim)) == "Not Found!" or ent:GetSequenceName(ent:SelectWeightedSequence(anim)) == "No model!") then
			return false
		end
	elseif isstring(anim) then -- Sequence
		if string_find(anim, "vjseq_") then anim = string_Replace(anim, "vjseq_", "") end
		if ent:LookupSequence(anim) == -1 then return false end
	end
	return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_GetSequenceDuration(ent, anim)
	if VJ_AnimationExists(ent, anim) == false then return 0 end -- Invalid animation, so 0
	
	-- Get rid of the gesture prefix
	if string_find(anim, "vjges_") then
		anim = string_Replace(anim, "vjges_", "")
		if ent:LookupSequence(anim) == -1 then
			anim = tonumber(anim)
		end
	end
	
	if isnumber(anim) then -- Activity
		return ent:SequenceDuration(ent:SelectWeightedSequence(anim))
	elseif isstring(anim) then -- Sequence
		if string_find(anim, "vjseq_") then
			anim = string_Replace(anim, "vjseq_", "")
		end
		return ent:SequenceDuration(ent:LookupSequence(anim))
	end
	return 0
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_GetSequenceName(ent, anim)
	if VJ_AnimationExists(ent, anim) == false then return 0 end -- Invalid animation, so 0
	if string_find(anim, "vjges_") then anim = string_Replace(anim,"vjges_","") if ent:LookupSequence(anim) == -1 then anim = tonumber(anim) end end
	if isnumber(anim) then return ent:GetSequenceName(ent:SelectWeightedSequence(anim)) end
	if isstring(anim) then if string_find(anim, "vjseq_") then anim = string_Replace(anim,"vjseq_","") end return ent:GetSequenceName(ent:LookupSequence(anim)) end
	return nil
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_SequenceToActivity(ent, anim)
	if isstring(anim) then -- Sequence
		local result = ent:GetSequenceActivity(ent:LookupSequence(anim))
		if result == nil or result == -1 then
			return false
		else
			return result
		end
	elseif isnumber(anim) then -- If it's a number, then it's already an activity!
		return anim
	else
		return false
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_IsCurrentAnimation(ent, anim)
	anim = anim or {}
	if istable(anim) then
		if #anim < 1 then return false end -- If the table is empty then end it
	else
		anim = {anim}
	end

	for _, v in ipairs(anim) do
		if isnumber(v) && v != -1 then v = ent:GetSequenceName(ent:SelectWeightedSequence(v)) end -- Translate activity to sequence
		if string_lower(v) == string_lower(ent:GetSequenceName(ent:GetSequence())) then
			return true
		end
	end
	//if anim == ent:GetSequenceName(ent:GetSequence()) then return true end
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_RemoveAnimExtensions(ent, anim)
	if string_find(anim, "vjseq_") then
		anim = string_Replace(anim, "vjseq_", "")
	end
	if string_find(anim, "vjges_") then
		anim = string_Replace(anim, "vjges_", "")
	end
	return anim
end
---------------------------------------------------------------------------------------------------------------------------------------------
local props = {prop_physics=true, prop_physics_multiplayer=true, prop_physics_respawnable=true}
--
function VJ_IsProp(ent)
	return props[ent:GetClass()] == true -- Without == check, it would return nil on false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function VJ_IsAlive(ent)
	return ent:Health() > 0 && !ent.Dead
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Causes a Combine turret to self destruct, useful to run this in attacks to make sure turrets can be destroyed
		- selfEnt = The entity that is destroying the turret
		- ent = The turret to destroy (If it's NOT a turret, it will return false)
	Returns
		- false, turret was NOT destroyed
		- true, turret was destroyed
-----------------------------------------------------------]]
function VJ_DestroyCombineTurret(selfEnt, ent)
	if ent:GetClass() == "npc_turret_floor" then
		ent:Fire("selfdestruct")
		ent:SetHealth(0)
		local phys = ent:GetPhysicsObject()
		if IsValid(phys) then
			phys:EnableMotion(true)
			phys:ApplyForceCenter(selfEnt:GetForward()*10000)
		end
		return true
	end
	return false
end
--------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Applies speed effect to the given NPC/Player, if another speed effect is already applied, it will skip!
		- ent = The entity to apply the speed modification
		- speed = The speed, 1.0 is the normal speed
		- setTime = How long should this be in effect? | DEFAULT = 1
	Returns
		- false, effect did NOT apply
		- true, effect applied
-----------------------------------------------------------]]
function VJ_ApplySpeedEffect(ent, speed, setTime)
    ent.VJ_SpeedEffectT = ent.VJ_SpeedEffectT or 0
    if ent.VJ_SpeedEffectT < CurTime() then
        ent.VJ_SpeedEffectT = CurTime() + (setTime or 1)
		local orgPlayback = ent:GetPlaybackRate()
		local plyOrgWalk, plyOrgRun;
		if ent:IsPlayer() then
			plyOrgWalk = ent:GetWalkSpeed()
			plyOrgRun = ent:GetRunSpeed()
		end
        local hookName = "VJ_SpeedEffect" .. ent:EntIndex()
        hook.Add("Think", hookName, function()
            if !IsValid(ent) then
                hook.Remove("Think", hookName)
                return
			elseif (ent.VJ_SpeedEffectT < CurTime()) or (ent:Health() <= 0) then
                hook.Remove("Think", hookName)
				if ent.IsVJBaseSNPC then ent.AnimationPlaybackRate = orgPlayback end
				ent:SetPlaybackRate(orgPlayback)
				if ent:IsPlayer() then
					ent:SetWalkSpeed(plyOrgWalk)
					ent:SetRunSpeed(plyOrgRun)
				end
                return
            end
			if ent.IsVJBaseSNPC then ent.AnimationPlaybackRate = speed end
			ent:SetPlaybackRate(speed)
            if ent:IsPlayer() then
                ent:SetWalkSpeed(plyOrgWalk * speed)
                ent:SetRunSpeed(plyOrgRun * speed)
            end
        end)
		return true
    end
	return false
end
--------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Makes the entity utilize its ragdoll for collisions rather than the normal box collision.
		Note: Collision bounds should still be set, otherwise certain position functions will not work correctly!
		- ent = The entity to apply the ragdoll collision
		- mdl = The model to override and use for the collision. By default it should be nil unless you're trying stuff
	Returns
		- false, bone follower as NOT created
		- Entity, the bone follower entity that was created
-----------------------------------------------------------]]
local boneFollowerClass = "phys_bone_follower"
--
function VJ_CreateBoneFollower(ent, mdl)
	if !IsValid(ent) then return false end
	local ragdoll = mdl or ent:GetModel()
	if !util.IsValidRagdoll(ragdoll) then return false end

	ent:SetCustomCollisionCheck(true) -- Required for the "ShouldCollide" hook!
	
	local boneFollower = ents.Create("obj_vj_bonefollower")
	boneFollower:SetModel(ragdoll)
	boneFollower:SetPos(ent:GetPos())
	boneFollower:SetAngles(ent:GetAngles())
	boneFollower:SetParent(ent)
	boneFollower:AddEffects(EF_BONEMERGE)
	boneFollower:Spawn()
	boneFollower:SetOwner(ent)
	ent:DeleteOnRemove(boneFollower)
	ent.VJ_BoneFollowerEntity = boneFollower
	
	hook.Add("ShouldCollide", boneFollower, function(self, ent1, ent2)
		if (ent1 == ent && ent2:GetClass() == boneFollowerClass) or (ent2 == ent && ent1:GetClass() == boneFollowerClass) then
			return false
		end
		return true
	end)

	return boneFollower
end
---------------------------------------------------------------------------------------------------------------------------------------------
-- Run in Console: lua_run for k,v in ipairs(ents.GetAll()) do if v:GetClass() == "prop_dynamic" then v:Remove() end end
function VJ_CreateTestObject(pos, ang, color, time, mdl)
	local obj = ents.Create("prop_dynamic")
	obj:SetModel(mdl or "models/hunter/blocks/cube025x025x025.mdl")
	obj:SetPos(pos)
	obj:SetAngles(ang or defAng)
	obj:SetColor(color or Color(255, 0, 0))
	obj:Spawn()
	obj:Activate()
	timer.Simple(time or 3, function() if IsValid(obj) then obj:Remove() end end)
	return obj
end
---------------------------------------------------------------------------------------------------------------------------------------------
/* Do multiple test and compare the 2 results using this: https://calculla.com/columnar_addition_calculator
	VJ_StressTest(1000, function()
	end)
*/
function VJ_StressTest(count, func)
	count = count or 1
	local startTime = SysTime()
    for _ = 1, count do
		func()
    end
	local totalTime = SysTime() - startTime
	print("Total: " .. string.format("%f", totalTime) .. " sec | Average: " .. string.format("%f", totalTime / count) .. " sec")
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ NPC / Player Functions ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
local Entity_MetaTable = FindMetaTable("Entity")
local NPC_MetaTable = FindMetaTable("NPC")
//local Player_MetaTable = FindMetaTable("Player")
---------------------------------------------------------------------------------------------------------------------------------------------
function NPC_MetaTable:VJ_Controller_InitialMessage(ply)
	if !IsValid(ply) then return end
	ply:ChatPrint("#vjbase.print.npccontroller.entrance")
	if self.IsVJBaseSNPC == true then
		self:Controller_IntMsg(ply, controlEnt)
	end
end
/* Disabled for now until further testing (especially performance-wise)
---------------------------------------------------------------------------------------------------------------------------------------------
local AddEntityRelationship = NPC_MetaTable.AddEntityRelationship
function NPC_MetaTable:AddEntityRelationship(...)
	local args = {...}
	local ent = args[1]
	local disp = args[2]

	self.StoredDispositions = self.StoredDispositions or {}
	self.StoredDispositions[ent] = disp
	return AddEntityRelationship(self,...)
end
---------------------------------------------------------------------------------------------------------------------------------------------
local Disposition = NPC_MetaTable.Disposition
function NPC_MetaTable:Disposition(...)
	local args = {...}
	local ent = args[1]

	self.StoredDispositions = self.StoredDispositions or {}
	if IsValid(ent) && self:GetModel() == ent:GetModel() then
		return self.StoredDispositions[ent] or D_ER
	end
	return Disposition(self,...)
end
*/
---------------------------------------------------------------------------------------------------------------------------------------------
-- override = Used internally by the base, overrides the result and returns Val instead (Useful for variables that allow "false" to let the base decide the time)
function NPC_MetaTable:DecideAnimationLength(anim, override, decrease)
	if isbool(anim) then return 0 end
	
	if override == false then -- Base decides
		return (VJ_GetSequenceDuration(self, anim) - (decrease or 0)) / self:GetPlaybackRate()
	elseif isnumber(override) then -- User decides
		return override / self:GetPlaybackRate()
	else
		return 0
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function Entity_MetaTable:CalculateProjectile(projType, startPos, endPos, projVel)
	if projType == "Line" then -- Suggested to disable gravity!
		return ((endPos - startPos):GetNormal()) * projVel
	elseif projType == "Curve" then
		-- Oknoutyoun: https://gamedev.stackexchange.com/questions/53552/how-can-i-find-a-projectiles-launch-angle
		-- Negar: https://wikimedia.org/api/rest_v1/media/math/render/svg/4db61cb4c3140b763d9480e51f90050967288397
		local result = Vector(endPos.x - startPos.x, endPos.y - startPos.y, 0) -- Verchnagan deghe
		local pos_x = result:Length()
		local pos_y = endPos.z - startPos.z
		local grav = physenv.GetGravity():Length()
		local sqrtcalc1 = (projVel * projVel * projVel * projVel)
		local sqrtcalc2 = grav * ((grav * (pos_x * pos_x)) + (2 * pos_y * (projVel * projVel)))
		local calcsum = sqrtcalc1 - sqrtcalc2 -- Yergou tevere aveltsour
		if calcsum < 0 then -- Yete teve nevas e, ooremen sharnage
			calcsum = math.abs(calcsum)
		end
		local angsqrt =  math.sqrt(calcsum)
		local angpos = math.atan(((projVel * projVel) + angsqrt) / (grav * pos_x))
		local angneg = math.atan(((projVel * projVel) - angsqrt) / (grav * pos_x))
		local pitch = 1
		if angpos > angneg then
			pitch = angneg -- Yete asiga angpos enes ne, aveli veregele
		else
			pitch = angpos
		end
		result.z = math.tan(pitch) * pos_x
		return result:GetNormal() * projVel
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Uses the given number to return a scaled number that accounts for the selected difficulty
		- int = The number to scale
	Returns
		- number, the scaled number
-----------------------------------------------------------]]
function NPC_MetaTable:VJ_GetDifficultyValue(int)
	if self.SelectedDifficulty == -3 then
		return math_clamp(int - (int * 0.99), 1, int)
	elseif self.SelectedDifficulty == -2 then
		return math_clamp(int - (int * 0.75), 1, int)
	elseif self.SelectedDifficulty == -1 then
		return int / 2
	elseif self.SelectedDifficulty == 1 then
		return int + (int * 0.5)
	elseif self.SelectedDifficulty == 2 then
		return int * 2
	elseif self.SelectedDifficulty == 3 then
		return int + (int * 1.5)
	elseif self.SelectedDifficulty == 4 then
		return int + (int * 2.5)
	elseif self.SelectedDifficulty == 5 then
		return int + (int * 3.5)
	elseif self.SelectedDifficulty == 6 then
		return int + (int * 5.0)
	end
	return int -- Normal
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Tags ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
-- Variables that are used by VJ Base as tags --
[Variable]							[Description]
VJ_IsBeingControlled				NPC that is being controlled by the VJ NPC Controller
VJ_IsBeingControlled_Tool			NPC that is being controlled by the VJ NPC Mover Tool
VJ_AddEntityToSNPCAttackList		Entity that should be attacked by Creature NPCs if it's in the way
VJ_IsDetectableDanger				Entity that should be detected as danger by human NPCs
VJ_IsDetectableGrenade				Entity that should be detected as a grenade danger by human NPCs
VJ_IsPickupableDanger				Entity that CAN be picked up by human NPCs (Ex: Grenades)
VJ_IsPickedUpDanger					Entity that is currently picked up by a human NPC and most likely throwing it away (Ex: Grenades)
VJ_LastInvestigateSd				Last time this NPC/Player has made a sound that should be investigated by enemy NPCs
VJ_LastInvestigateSdLevel			The sound level of the above variable
VJ_IsHugeMonster					NPC that is considered to be very large or a boss
*/

-- Variable:		self.VJTags
-- Access: 			self.VJTags[VJ_TAG_X]
-- Remove: 			self.VJTags[VJ_TAG_X] = nil
-- Add: 			self:VJTags_Add(VJ_TAG_X, VJ_TAG_Y, ...)

-- Enums
VJ_TAG_HEALING = 1 -- Ent is healing (either itself or by another ent)
VJ_TAG_EATING = 2 -- Ent is eating something (Ex: a corpse)
VJ_TAG_BEING_EATEN = 3 -- Ent is being eaten by something
VJ_TAG_VJ_FRIENDLY = 4 -- Friendly to VJ NPCs

VJ_TAG_SD_PLAYING_MUSIC = 10 -- Ent is playing a sound track

VJ_TAG_HEADCRAB = 20
VJ_TAG_POLICE = 21
VJ_TAG_CIVILIAN = 22
VJ_TAG_TURRET = 23
VJ_TAG_VEHICLE = 24
VJ_TAG_AIRCRAFT = 25

---------------------------------------------------------------------------------------------------------------------------------------------
function Entity_MetaTable:VJTags_Add(...)
	if !self.VJTags then self.VJTags = {} end
	//PrintTable({...})
	for _, tag in ipairs({...}) do
		self.VJTags[tag] = true
	end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Hooks ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("Initialize", "VJ_Initialize", function()
	RunConsoleCommand("sv_pvsskipanimation", "0") -- Fix attachments, bones, positions, angles etc. being broken in NPCs!
end)
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PhysgunPickup", "VJ_PhysgunPickup", function(ply, ent)
	if ent:GetClass() == "sent_vj_ply_spawnpoint" then
		return ply:IsAdmin()
	end
end)
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PlayerSelectSpawn", "VJ_PlayerSelectSpawn", function(ply)
	local points = {}
	for _,v in ipairs(ents.FindByClass("sent_vj_ply_spawnpoint")) do
		if (v.Active == true) then
			points[#points + 1] = v
		end
	end
	local result = VJ_PICK(points)
	if result != false then
		return result
	end
end)
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PlayerSpawnedNPC", "VJ_PlayerSpawnedNPC", function(ply, ent)
	if ent.IsVJBaseSNPC == true or ent.IsVJBaseSpawner == true then
		ent:SetCreator(ply)
	end
end)
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PlayerInitialSpawn", "VJ_PlayerInitialSpawn", function(ply)
	if IsValid(ply) then
		ply.VJTags = {}
		ply.VJ_LastInvestigateSd = 0
		ply.VJ_LastInvestigateSdLevel = 0
		if !VJ_CVAR_IGNOREPLAYERS then
			local EntsTbl = ents.GetAll()
			for x = 1, #EntsTbl do
				local v = EntsTbl[x]
				if v:IsNPC() && v.IsVJBaseSNPC == true then
					v.CurrentPossibleEnemies[#v.CurrentPossibleEnemies+1] = ply
				end
			end
		end
	end
	-- Old system
	/*local getall = ents.GetAll()
	for k,v in ipairs(getall) do
		v.VJ_LastInvestigateSd = 0
		v.VJ_LastInvestigateSdLevel = 0
		if v.IsVJBaseSNPC == true && (v.IsVJBaseSNPC_Human == true or v.IsVJBaseSNPC_Creature == true) then
			v.CurrentPossibleEnemies = v:DoHardEntityCheck(getall)
		end
	end*/
end)
---------------------------------------------------------------------------------------------------------------------------------------------
if SERVER then
	local ignoreEnts = {monster_generic=true, monster_furniture=true, npc_furniture=true, monster_gman=true, npc_grenade_frag=true, bullseye_strider_focus=true, npc_bullseye=true, npc_enemyfinder=true, hornet=true}
	local grenadeEnts = {npc_grenade_frag=true,grenade_hand=true,obj_spore=true,obj_grenade=true,obj_handgrenade=true,doom3_grenade=true,fas2_thrown_m67=true,cw_grenade_thrown=true,obj_cpt_grenade=true,cw_flash_thrown=true,ent_hl1_grenade=true}
	local grenadeThrowBackEnts = {npc_grenade_frag=true,obj_spore=true,obj_handgrenade=true,obj_cpt_grenade=true,cw_grenade_thrown=true,cw_flash_thrown=true,cw_smoke_thrown=true,ent_hl1_grenade=true}
	--
	hook.Add("OnEntityCreated", "VJ_OnEntityCreated", function(ent)
		local myClass = ent:GetClass()
		ent.VJTags = {}
		if ent:IsNPC() then
			if !ignoreEnts[myClass] then
				local isVJ = ent.IsVJBaseSNPC
				if isVJ then
					ent.NextProcessT = CurTime() + 0.15
				end
				timer.Simple(0.1, function() -- Make sure the NPC is initialized properly
					if IsValid(ent) then
						if isVJ == true && ent.CurrentPossibleEnemies == nil then ent.CurrentPossibleEnemies = {} end
						local EntsTbl = ents.GetAll()
						local count = 1
						local cvSeePlys = !VJ_CVAR_IGNOREPLAYERS
						local isPossibleEnemy = ((ent:IsNPC() && ent:Health() > 0 && (ent.Behavior != VJ_BEHAVIOR_PASSIVE_NATURE)) or (ent:IsPlayer()))
						for x = 1, #EntsTbl do
							local v = EntsTbl[x]
							if (v:IsNPC() or v:IsPlayer()) && !ignoreEnts[v:GetClass()] then
								-- Add enemies to the created entity (if it's a VJ Base SNPC)
								if isVJ == true then
									ent:EntitiesToNoCollideCode(v)
									if (v:IsNPC() && (v:GetClass() != myClass && (v.Behavior != VJ_BEHAVIOR_PASSIVE_NATURE)) && v:Health() > 0) or (v:IsPlayer() && cvSeePlys /*&& v:Alive()*/) then
										ent.CurrentPossibleEnemies[count] = v
										count = count + 1
									end
								end
								-- Add the created entity to the list of possible enemies of VJ Base SNPCs
								if isPossibleEnemy && myClass != v:GetClass() && v.IsVJBaseSNPC then
									v.CurrentPossibleEnemies[#v.CurrentPossibleEnemies+1] = ent //v.CurrentPossibleEnemies = v:DoHardEntityCheck(getall)
								end
							end
						end
					end
				end)
			end
		elseif grenadeEnts[myClass] then
			ent.VJ_IsDetectableGrenade = true
			if grenadeThrowBackEnts[myClass] then
				ent.VJ_IsPickupableDanger = true
			end
		end
		-- Old system
		/*if ent:GetClass() != "npc_grenade_frag" && ent:GetClass() != "bullseye_strider_focus" && ent:GetClass() != "npc_bullseye" && ent:GetClass() != "npc_enemyfinder" && ent:GetClass() != "hornet" then
			timer.Simple(0.15,function()
				if IsValid(ent) then
					local getall = ents.GetAll()
					for k,v in ipairs(getall) do
						if IsValid(v) && v != ent && v.IsVJBaseSNPC == true && (v.IsVJBaseSNPC_Human == true or v.IsVJBaseSNPC_Creature == true) then
							v.CurrentPossibleEnemies = v:DoHardEntityCheck(getall)
						end
					end
				end
			end)
		end*/
	end)
	
	/*
	-- Retrieving outputs from NPCs or other entities | Outputs: https://developer.valvesoftware.com/wiki/Base.fgd/Garry%27s_Mod
	local triggerLua = ents.Create("lua_run")
	triggerLua:SetName("triggerhook")
	triggerLua:Spawn()
	
	hook.Add("OnEntityCreated", "VJ_OnEntityCreated", function(ent)
		if ent:IsNPC() && ent.IsVJBaseSNPC == true then
			-- Format: <output name> <targetname>:<inputname>:<parameter>:<delay>:<max times to fire, -1 means infinite>
			self:Fire("AddOutput", "OnIgnite triggerhook:RunPassedCode:hook.Run( 'OnOutput' ):0:-1")
		end
	end)

	hook.Add("OnOutput", "OnOutput", function()
		local activator, caller = ACTIVATOR, CALLER
		print(activator, caller)
	end )
	*/
end
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("EntityEmitSound", "VJ_EntityEmitSound", function(data)
	local ent = data.Entity
	if IsValid(ent) then
		-- Investigate System
		if SERVER && (ent:IsPlayer() or ent:IsNPC()) && data.SoundLevel >= 75 then
			//print("---------------------------")
			//PrintTable(data)
			local quiet = (string_StartWith(data.OriginalSoundName, "player/footsteps") and (ent:IsPlayer() && (ent:Crouching() or ent:KeyDown(IN_WALK)))) or false
			if quiet != true && ent.Dead != true then
				ent.VJ_LastInvestigateSd = CurTime()
				ent.VJ_LastInvestigateSdLevel = (data.SoundLevel * data.Volume) + (((data.Volume <= 0.4) and 15) or 0)
			end
		-- Disable the built-in footstep sounds for the player footstep sound for VJ NPCs unless specified otherwise
			-- Plays only on client-side, making it useless to play material-specific
		elseif ent:IsNPC() && ent.IsVJBaseSNPC == true && (string.EndsWith(data.OriginalSoundName, "stepleft") or string.EndsWith(data.OriginalSoundName, "stepright")) then
			return ent:MatFootStepQCEvent(data)
		end
	end
end)
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("EntityFireBullets", "VJ_NPC_FIREBULLET", function(ent, data)
	if IsValid(ent) && ent:IsNPC() && ent.IsVJBaseSNPC == true then
		local wep = ent:GetActiveWeapon()
		local ene = ent:GetEnemy()
		local edited = false
		if IsValid(wep) && IsValid(ene) then
			if wep.IsVJBaseWeapon then
				-- Ammo counter for VJ weapons
				wep:SetClip1(wep:Clip1() - 1)
				//ent.Weapon_TimeSinceLastShot = CurTime() -- We don't want to change this here!
			else
				-- START: Bullet spawn for non-VJ weapons --
				local getmuzzle;
				for i = 1, #wep:GetAttachments() do
					if wep:GetAttachments()[i].name == "muzzle" then
						getmuzzle = "muzzle" break
					elseif wep:GetAttachments()[i].name == "muzzleA" then
						getmuzzle = "muzzleA" break
					elseif wep:GetAttachments()[i].name == "muzzle_flash" then
						getmuzzle = "muzzle_flash" break
					elseif wep:GetAttachments()[i].name == "muzzle_flash1" then
						getmuzzle = "muzzle_flash1" break
					elseif wep:GetAttachments()[i].name == "muzzle_flash2" then
						getmuzzle = "muzzle_flash2" break
					elseif wep:GetAttachments()[i].name == "ValveBiped.muzzle" then
						getmuzzle = "ValveBiped.muzzle" break
					else 
						getmuzzle = false
					end
				end
				if !getmuzzle then
					if ent:LookupBone("ValveBiped.Bip01_R_Hand") then
						data.Src = ent:GetBonePosition(ent:LookupBone("ValveBiped.Bip01_R_Hand"))
					else -- No attachment found, just use eye pos
						data.Src = ent:EyePos()
					end
				else
					data.Src = wep:GetAttachment(wep:LookupAttachment(getmuzzle)).Pos
				end
				-- END: Bullet spawn for non-VJ weapons --
			end
			
			-- Bullet spread
			// ent:GetPos():Distance(ent.VJ_TheController:GetEyeTrace().HitPos) -- Was used when NPC was being controlled
			local fSpread = (ent:GetPos():Distance(ene:GetPos()) / 28) * (ent.WeaponSpread or 1) * (wep.NPC_CustomSpread or 1)
			data.Spread = Vector(fSpread, fSpread, 0)
			
			-- Bullet direction
			// data.Dir = ent.VJ_TheController:GetAimVector() -- Was used when NPC was being controlled
			if ent.WeaponUseEnemyEyePos == true then
				data.Dir = (ene:EyePos() + ene:GetUp()*-5) - data.Src
			else
				data.Dir = (ene:GetPos() + ene:OBBCenter()) -  data.Src
			end
			//ent.WeaponUseEnemyEyePos = false
			edited = true
		end
		ent:OnFireBullet(ent, data)
		if edited then return true end
	end
end)
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("EntityTakeDamage", "VJ_EntityTakeDamage", function(target, dmginfo)
	local attacker = dmginfo:GetAttacker()
	if IsValid(target) && IsValid(attacker) && target.IsVJBaseSNPC && attacker:IsNPC() && dmginfo:IsBulletDamage() && attacker:Disposition(target) != D_HT && (attacker:GetClass() == target:GetClass() or target:Disposition(attacker) == D_LI /*or target:Disposition(attacker) == 4*/) then
		dmginfo:SetDamage(0)
	end
end)
---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_NPCPLY_DEATH(npc, attacker, inflictor)
	if IsValid(attacker) && attacker.IsVJBaseSNPC == true then
		attacker:DoKilledEnemy(npc, attacker, inflictor)
		attacker:SetupRelationships()
	end
end
hook.Add("OnNPCKilled", "VJ_OnNPCKilled", VJ_NPCPLY_DEATH)
hook.Add("PlayerDeath", "VJ_PlayerDeath", function(victim, inflictor, attacker)
	VJ_NPCPLY_DEATH(victim, attacker, inflictor) -- Arguments are flipped between the hooks for some reason...
	
	-- Let allied SNPCs know that the player died
	for _,v in ipairs(ents.FindInSphere(victim:GetPos(), 400)) do
		if v.IsVJBaseSNPC == true && v:Disposition(victim) == D_LI then
			v:CustomOnAllyDeath(victim)
			v:PlaySoundSystem("AllyDeath")
		end
	end
end)
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PlayerCanPickupWeapon", "VJ_PLAYER_CANPICKUPWEAPON", function(ply, wep)
	if wep.IsVJBaseWeapon then
		if ply.VJ_CurPickupWithoutUse == wep:GetClass() && !ply:HasWeapon(wep:GetClass()) then
			ply.VJ_CurPickupWithoutUse = nil
			return true
		end
		//if wep.VJ_CurPickupWithoutUse then return true end
		return GetConVar("vj_npc_plypickupdropwep"):GetInt() == 1 && ply:KeyPressed(IN_USE) && ply:GetEyeTrace().Entity == wep
	end
end)
---------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("PlayerGiveSWEP", "VJ_PLAYER_GIVESWEP", function(ply, class, swep)
	//PrintTable(swep)
	//if swep.IsVJBaseWeapon == true then
		ply.VJ_CurPickupWithoutUse = class
		timer.Simple(0.1, function() if IsValid(ply) then ply.VJ_CurPickupWithoutUse = nil end end)
	//end
end)
---------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Corpse & Stink System ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if SERVER then
	VJ_Corpses = {}
	VJ_StinkyEnts = {}
	--
	local function VJ_Stink_StartThink()
		timer.Create("vj_stink_think", 0.3, 0, function()
			for k, ent in RandomPairs(VJ_StinkyEnts) do
				if IsValid(ent) then
					sdEmitHint(SOUND_CARCASS, ent:GetPos(), 400, 0.15, ent)
				else -- No longer valid, remove it from the list
					table_remove(VJ_StinkyEnts, k)
					if #VJ_StinkyEnts == 0 then -- If this is the last stinky ent then destroy the timer!
						timer.Remove("vj_stink_think")
					end
				end
			end
		end)
	end
	---------------------------------------------------------------------------------------------------------------------------------------------
	local stinkyMatTypes = {alienflesh=true, antlion=true, armorflesh=true, bloodyflesh=true, flesh=true, zombieflesh=true, player=true}
	-- Material types: https://developer.valvesoftware.com/wiki/Material_surface_properties
	--
	--[[---------------------------------------------------------
		Adds an entity to the stinky entity list and makes it produce a stink
			- ent = The entity to add to the list
			- checkMat = Should it check the entity's material type?
		Returns
			- false, Entity NOT added to stinky the list
			- true, Entity added to the stinky list
	-----------------------------------------------------------]]
	function VJ_AddStinkyEnt(ent, checkMat)
		local physObj = ent:GetPhysicsObject()
		-- Clear out all removed ents from the table
		for k, v in ipairs(VJ_StinkyEnts) do
			if !IsValid(v) then
				table_remove(VJ_StinkyEnts, k)
			end
		end
		-- Add the entity to the stinky list (if possible)
		if (!checkMat) or (IsValid(physObj) && stinkyMatTypes[physObj:GetMaterial()]) then
			VJ_StinkyEnts[#VJ_StinkyEnts + 1] = ent -- Add entity to the table
			if !timer.Exists("vj_stink_think") then VJ_Stink_StartThink() end -- Start the stinky timer if it does NOT exist
			return true
		end
		return false
	end
	---------------------------------------------------------------------------------------------------------------------------------------------
	--[[---------------------------------------------------------
		Adds an entity to the VJ corpse list (Entities here respect all VJ rules including corpse limit!)
			- ent = The entity to add to the corpse list
	-----------------------------------------------------------]]
	function VJ_AddCorpse(ent)
		-- Clear out all removed corpses from the table
		for k, v in ipairs(VJ_Corpses) do
			if !IsValid(v) then
				table_remove(VJ_Corpses, k)
			end
		end
		
		local count = #VJ_Corpses + 1
		VJ_Corpses[count] = ent
		
		-- Check if we surpassed the limit, if we did, remove the oldest corpse
		if count > GetConVar("vj_npc_globalcorpselimit"):GetInt() then
			local oldestCorpse = table_remove(VJ_Corpses, 1)
			if IsValid(oldestCorpse) then
				local fadeType = oldestCorpse.FadeCorpseType
				if fadeType then oldestCorpse:Fire(fadeType, "", 0) end -- Fade out
				timer.Simple(1, function() if IsValid(oldestCorpse) then oldestCorpse:Remove() end end) -- Make sure it's removed
			end
		end
	end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Convar Callbacks ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
cvars.AddChangeCallback("ai_ignoreplayers", function(convar_name, oldValue, newValue)
	if tonumber(newValue) == 0 then -- Turn off ignore players
		VJ_CVAR_IGNOREPLAYERS = false
		local getPlys = player.GetAll()
		local getAll = ents.GetAll()
		for x = 1, #getAll do
			local v = getAll[x]
			if v:IsNPC() && v.IsVJBaseSNPC then
				for _, ply in ipairs(getPlys) do
					v.CurrentPossibleEnemies[#v.CurrentPossibleEnemies + 1] = ply
				end
			end
		end
	else -- Turn on ignore players
		VJ_CVAR_IGNOREPLAYERS = true
		for _, v in ipairs(ents.GetAll()) do
			if v.IsVJBaseSNPC then
				if v.FollowingPlayer == true then v:FollowReset() end -- Reset the NPC's follow system if it's following a player
				//v.CurrentPossibleEnemies = v:DoHardEntityCheck(getall)
				local posEnemies = v.CurrentPossibleEnemies
				local it = 1
				while it <= #posEnemies do
					local x = posEnemies[it]
					if IsValid(x) && x:IsPlayer() then
						v:AddEntityRelationship(x, D_NU, 10) -- Make the player neutral
						if IsValid(v:GetEnemy()) && v:GetEnemy() == x then v:ResetEnemy() end -- Reset the NPC's enemy if it's a player
						table_remove(posEnemies, it) -- Remove the player from possible enemy table
					else
						it = it + 1
					end
				end
			end
		end
	end
end)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Net Messages ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	net.Receive("vj_music_run",function(len)
		VJ_MUSIC_QUEUE_LIST = VJ_MUSIC_QUEUE_LIST or {}
		local ent = net.ReadEntity()
		local sdTbl = net.ReadTable()
		local sdVol = net.ReadFloat()
		local sdPlayback = net.ReadFloat()
		-- Flags: "noplay" = Forces the sound not to play as soon as this function is called
		sound.PlayFile("sound/" .. VJ_PICK(sdTbl), "noplay", function(sdChan, errorID, errorName)
			if IsValid(sdChan) then
				if #VJ_MUSIC_QUEUE_LIST <= 0 then sdChan:Play() end
				sdChan:EnableLooping(true)
				sdChan:SetVolume(sdVol)
				sdChan:SetPlaybackRate(sdPlayback)
				table.insert(VJ_MUSIC_QUEUE_LIST, {npc=ent, channel=sdChan})
			else
				print("[VJ Base Music] Error adding sound track!", errorID, errorName)
			end
		end)
		timer.Create("vj_music_think", 1, 0, function()
			//PrintTable(VJ_MUSIC_QUEUE_LIST)
			for k, v in pairs(VJ_MUSIC_QUEUE_LIST) do
				//PrintTable(v)
				if !IsValid(v.npc) then
					v.channel:Stop()
					v.channel = nil
					table_remove(VJ_MUSIC_QUEUE_LIST, k)
				end
			end
			if #VJ_MUSIC_QUEUE_LIST <= 0 then
				timer.Remove("vj_music_think")
				VJ_MUSIC_QUEUE_LIST = {}
			else
				for _,v in pairs(VJ_MUSIC_QUEUE_LIST) do
					if IsValid(v.npc) && IsValid(v.channel) then
						v.channel:Play() break
					end
				end
			end
		end)
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
/*if CLIENT then
	require("sound_vj_track")
	sound_vj_track.Add("VJ_SpiderQueenThemeMusic","vj_dm_spidermonster/Dark Messiah - Avatar of the Spider Goddess.wav",161)
end*/
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Utility Functions ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Customizable function that deals radius damage with the given properties
		- attacker = The entity that is dealing the damage | REQUIRED
		- inflictor = The entity that is inflicting the damage | REQUIRED
		- startPos = Start position of the radius | DEFAULT = attacker:GetPos()
		- dmgRadius = How far the damage radius goes | DEFAULT = 150
		- dmgMax = Maximum amount of damage it deals to an entity | DEFAULT = 15
		- dmgType = The damage type | DEFAULT = DMG_BLAST
		- ignoreInnocents = Should it ignore NPCs/Players that are friendly OR have no-target on (Including ignore players) | DEFAULT = true
		- realisticRadius = Should it use a realistic radius? Entities farther away receive less damage and force | DEFAULT = true
		- extraOptions = Table that holds extra options to modify parts of the code
			- DisableVisibilityCheck = Should it disable the visibility check? | DEFAULT = false
			- Force = The force to apply when damage is applied | DEFAULT = false
			- UpForce = Optional setting for extraOptions.Force that override the up force | DEFAULT = extraOptions.Force
			- DamageAttacker = Should it damage the attacker as well? | DEFAULT = false
			- UseConeDegree = If set to a number, it will use a cone-based radius | DEFAULT = nil
			- UseConeDirection = The direction (position) the cone goes to | DEFAULT = attacker:GetForward()
		- customFunc(ent) = Use this to edit the entity which is given as parameter "ent"
	Returns
		- table, the entities it damaged (Can be empty!)
-----------------------------------------------------------]]
local specialDmgEnts = {npc_strider=true, npc_combinedropship=true, npc_combinegunship=true, npc_helicopter=true}
--
function util.VJ_SphereDamage(attacker, inflictor, startPos, dmgRadius, dmgMax, dmgType, ignoreInnocents, realisticRadius, extraOptions, customFunc)
	startPos = startPos or attacker:GetPos()
	dmgRadius = dmgRadius or 150
	dmgMax = dmgMax or 15
	extraOptions = extraOptions or {}
		local disableVisibilityCheck = extraOptions.DisableVisibilityCheck or false
		local baseForce = extraOptions.Force or false
	local dmgFinal = dmgMax
	local hitEnts = {}
	for _, v in ipairs((isnumber(extraOptions.UseConeDegree) and VJ_FindInCone(startPos, extraOptions.UseConeDirection or attacker:GetForward(), dmgRadius, extraOptions.UseConeDegree or 90, {AllEntities=true})) or ents.FindInSphere(startPos, dmgRadius)) do
		if (attacker.VJ_IsBeingControlled == true && attacker.VJ_TheControllerBullseye == v) or (v:IsPlayer() && v.IsControlingNPC == true) then continue end -- Don't damage controller bullseye and player
		local nearestPos = v:NearestPoint(startPos) -- From the enemy position to the given position
		if realisticRadius != false then -- Decrease damage from the nearest point all the way to the enemy point then clamp it!
			dmgFinal = math_clamp(dmgFinal * ((dmgRadius - startPos:Distance(nearestPos)) + 150) / dmgRadius, dmgMax / 2, dmgFinal)
		end
		
		if (disableVisibilityCheck == false && (v:VisibleVec(startPos) or v:Visible(attacker))) or (disableVisibilityCheck == true) then
			local function DoDamageCode()
				if (customFunc) then customFunc(v) end
				hitEnts[#hitEnts + 1] = v
				if specialDmgEnts[v:GetClass()] then
					v:TakeDamage(dmgFinal, attacker, inflictor)
				else
					local dmgInfo = DamageInfo()
					dmgInfo:SetDamage(dmgFinal)
					dmgInfo:SetAttacker(attacker)
					dmgInfo:SetInflictor(inflictor)
					dmgInfo:SetDamageType(dmgType or DMG_BLAST)
					dmgInfo:SetDamagePosition(nearestPos)
					if baseForce != false then
						local force = baseForce
						local forceUp = extraOptions.UpForce or false
						if VJ_IsProp(v) or v:GetClass() == "prop_ragdoll" then
							local phys = v:GetPhysicsObject()
							if IsValid(phys) then
								if forceUp == false then forceUp = force / 9.4 end
								//v:SetVelocity(v:GetUp()*100000)
								if v:GetClass() == "prop_ragdoll" then force = force * 1.5 end
								phys:ApplyForceCenter(((v:GetPos() + v:OBBCenter() + v:GetUp() * forceUp) - startPos) * force) //+attacker:GetForward()*vForcePropPhysics
							end
						else
							force = force * 1.2
							if forceUp == false then forceUp = force end
							dmgInfo:SetDamageForce(((v:GetPos() + v:OBBCenter() + v:GetUp() * forceUp) - startPos) * force)
						end
					end
					v:TakeDamageInfo(dmgInfo)
					VJ_DestroyCombineTurret(attacker, v)
				end
			end
			
			-- Self
			if v:EntIndex() == attacker:EntIndex() then
				if extraOptions.DamageAttacker then DoDamageCode() end -- If it can't self hit, then skip
			-- NPCs / Players
			elseif (ignoreInnocents == false) or (v:IsNPC() && v:Disposition(attacker) != D_LI && v:Health() > 0 && (v:GetClass() != attacker:GetClass())) or (v:IsPlayer() && !VJ_CVAR_IGNOREPLAYERS && v:Alive() && !v:IsFlagSet(FL_NOTARGET)) then
				DoDamageCode()
			-- Other types of entities
			elseif !v:IsNPC() && !v:IsPlayer() then
				DoDamageCode()
			end
		end
	end
	return hitEnts
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Tests ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Working test but no uses at the moment
/*
local metaNPC = FindMetaTable("NPC")
local metaVJ = {}
local function __index(self, key)
	local val = metaVJ[key]
	if val != nil then return val end
	//if ( key == "Example1" ) then return self.Example2 end
	return metaNPC.__index(self, key)
end

function metaVJ:GetIdealMoveSpeed(example)
	if example == true then
		return 1000
	else
		return metaNPC.GetIdealMoveSpeed(self)
	end
end

hook.Add("OnEntityCreated", "vjmetatabletest", function(ent)
	if scripted_ents.IsBasedOn(ent:GetClass(), "npc_vj_creature_base") or scripted_ents.IsBasedOn(ent:GetClass(), "npc_vj_human_base") then
		local mt = table.Merge({}, debug.getmetatable(ent)) -- Create a new table to avoid overflow!
		mt.__index = __index
		debug.setmetatable(ent, mt)
	end
end)
*/

-- Version for individual NPCs (Tests show loss of performance, avoid)
/*
local metaOrg = debug.getmetatable(self)
local metaVJ = {}
local function newIndex(ent, key)
	local val = metaVJ[key]
	if val != nil then return val end
	return metaOrg.__index(ent, key)
end
function metaVJ:SetMaxLookDistance(dist)
	metaOrg.SetMaxLookDistance(self, dist)
end
local mt = table.Merge({}, metaOrg) -- Create a new table to avoid overflow!
mt.__index = newIndex
debug.setmetatable(self, mt)
*/
--PATH lua/autorun/vj_menu_properties.lua:
/*--------------------------------------------------
	=============== VJ Properties ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

AddCSLuaFile()

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
hook.Add("CanProperty", "VJ_PLY_CAN_PROPERTY", function(ply, property, ent)
	if GetConVar("vj_npc_admin_properties"):GetInt() == 1 && !ply:IsAdmin() && property == "vj_npc_properties" then ply:ChatPrint("#vjbase.menuproperties.print.adminonly") return false end
end)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ SNPC Controlling ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
properties.Add("vj_pr_npc_control",{
	MenuLabel = "#vjbase.menuproperties.control", -- Name to display on the context menu
	Order = 50000, -- The order to display this property relative to other properties
	MenuIcon = "icon16/controller.png", -- The icon to display next to the property
	PrependSpacer = true, -- Whether to add a spacer before this property. This should generally be true for the first property in a group of properties.

	Filter = function(self, ent, ply) -- A function that determines whether an entity is valid for this property
		if (!IsValid(ent)) then return false end
		if (ent:IsPlayer()) or !ent:IsNPC() then return false end
		if (!gamemode.Call("CanProperty", ply, "vj_npc_properties", ent)) then return false end
		if ent.IsVJBaseSNPC != true then return false end
		return true
	end,
	
	Action = function(self, ent) -- The action to perform upon using the property (Clientside)
		self:MsgStart()
			net.WriteEntity(ent)
		self:MsgEnd()
	end,
	
	Receive = function(self, length, ply) -- The action to perform upon using the property (Serverside)
		local ent = net.ReadEntity()
		if (!self:Filter(ent, ply)) then return end
		if !ply:Alive() then return end -- Keep the player from becoming a zombie =)
		if ply.IsControlingNPC then ply:ChatPrint("Can't control "..ent:GetName().." because you are already controlling another NPC!") return end
		if ent.VJ_IsBeingControlled != true then
			if ent:Health() > 0 then
				local obj = ents.Create("obj_vj_npccontroller")
				obj.VJCE_Player = ply
				obj:SetControlledNPC(ent)
				obj:Spawn()
				obj:StartControlling()
			else
				ply:ChatPrint("Can't control "..ent:GetName().." its health is 0 or below.")
			end
		else
			ply:ChatPrint("Can't control "..ent:GetName().." it's already being controlled.")
		end
	end
})
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ SNPC Guarding ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
properties.Add("vj_pr_npc_guard",{
	MenuLabel = "#vjbase.menuproperties.guard", -- Name to display on the context menu
	Order = 50001, -- The order to display this property relative to other properties
	MenuIcon = "icon16/shield.png", -- The icon to display next to the property
	PrependSpacer = true, -- Whether to add a spacer before this property. This should generally be true for the first property in a group of properties.

	Filter = function(self, ent, ply) -- A function that determines whether an entity is valid for this property
		if (!IsValid(ent)) then return false end
		if (ent:IsPlayer()) or !ent:IsNPC() then return false end
		if (!gamemode.Call("CanProperty", ply, "vj_npc_properties", ent)) then return false end
		if ent.IsVJBaseSNPC != true then return false end
		return true
	end,
	
	Action = function(self, ent) -- The action to perform upon using the property (Clientside)
		self:MsgStart()
			net.WriteEntity(ent)
		self:MsgEnd()
	end,
	
	Receive = function(self, length, ply) -- The action to perform upon using the property (Serverside)
		local ent = net.ReadEntity()
		if (!self:Filter(ent, ply)) then return end
		if ent.VJ_IsBeingControlled != true then
			if ent.IsGuard == true then
				ply:ChatPrint("Disabled Guarding for "..ent:GetName()..".")
				ent.IsGuard = false
			else
				ply:ChatPrint("Enabled Guarding for "..ent:GetName()..".")
				ent:StopMoving()
				ent.IsGuard = true
			end
		else
			ply:ChatPrint("Unable to change setting for "..ent:GetName()..".")
		end
	end
})
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ SNPC Wandering ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
properties.Add("vj_pr_npc_wander",{
	MenuLabel = "#vjbase.menuproperties.wander", -- Name to display on the context menu
	Order = 50002, -- The order to display this property relative to other properties
	MenuIcon = "icon16/arrow_rotate_clockwise.png", -- The icon to display next to the property

	Filter = function(self, ent, ply) -- A function that determines whether an entity is valid for this property
		if (!IsValid(ent)) then return false end
		if (ent:IsPlayer()) or !ent:IsNPC() then return false end
		if (!gamemode.Call("CanProperty", ply, "vj_npc_properties", ent)) then return false end
		if ent.IsVJBaseSNPC != true then return false end
		return true
	end,
	
	Action = function(self, ent) -- The action to perform upon using the property (Clientside)
		self:MsgStart()
			net.WriteEntity(ent)
		self:MsgEnd()
	end,
	
	Receive = function(self, length, ply) -- The action to perform upon using the property (Serverside)
		local ent = net.ReadEntity()
		if (!self:Filter(ent, ply)) then return end
		if ent.VJ_IsBeingControlled != true then
			if ent.DisableWandering == true then
				ply:ChatPrint("Enabled Wandering for "..ent:GetName()..".")
				ent.DisableWandering = false
			else
				ply:ChatPrint("Disabled Wandering for "..ent:GetName()..".")
				ent:StopMoving()
				ent.DisableWandering = true
			end
		else
			ply:ChatPrint("Unable to change setting for "..ent:GetName()..".")
		end
	end
})
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ SNPC Toggle Medic ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
properties.Add("vj_pr_npc_medic",{
	MenuLabel = "#vjbase.menuproperties.medic", -- Name to display on the context menu
	Order = 50003, -- The order to display this property relative to other properties
	MenuIcon = "icon16/asterisk_yellow.png", -- The icon to display next to the property

	Filter = function(self, ent, ply) -- A function that determines whether an entity is valid for this property
		if (!IsValid(ent)) then return false end
		if (ent:IsPlayer()) or !ent:IsNPC() then return false end
		if (!gamemode.Call("CanProperty", ply, "vj_npc_properties", ent)) then return false end
		if ent.IsVJBaseSNPC != true then return false end
		return true
	end,
	
	Action = function(self, ent) -- The action to perform upon using the property (Clientside)
		self:MsgStart()
			net.WriteEntity(ent)
		self:MsgEnd()
	end,
	
	Receive = function(self, length, ply) -- The action to perform upon using the property (Serverside)
		local ent = net.ReadEntity()
		if (!self:Filter(ent, ply)) then return end
		if ent.IsMedicSNPC == true then
			ply:ChatPrint(ent:GetName().." Is no longer a medic.")
			ent.IsMedicSNPC = false
		else
			ply:ChatPrint(ent:GetName().." Is now a medic.")
			ent.IsMedicSNPC = true
		end
	end
})
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ SNPC Ally Me ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
properties.Add("vj_pr_npc_allyme",{
	MenuLabel = "#vjbase.menuproperties.allyme", -- Name to display on the context menu
	Order = 50004, -- The order to display this property relative to other properties
	MenuIcon = "icon16/heart_add.png", -- The icon to display next to the property

	Filter = function(self, ent, ply) -- A function that determines whether an entity is valid for this property
		if (!IsValid(ent)) then return false end
		if (ent:IsPlayer()) or !ent:IsNPC() then return false end
		if (!gamemode.Call("CanProperty", ply, "vj_npc_properties", ent)) then return false end
		if ent.IsVJBaseSNPC != true then return false end
		return true
	end,
	
	Action = function(self, ent) -- The action to perform upon using the property (Clientside)
		self:MsgStart()
			net.WriteEntity(ent)
		self:MsgEnd()
	end,
	
	Receive = function(self, length, ply) -- The action to perform upon using the property (Serverside)
		local ent = net.ReadEntity()
		if (!self:Filter(ent, ply)) then return end
		table.insert(ent.VJ_AddCertainEntityAsFriendly,ply)
		for k,v in ipairs(ent.VJ_AddCertainEntityAsEnemy) do
			if v:IsPlayer() && v:GetName() == ply:GetName() then
				table.remove(ent.VJ_AddCertainEntityAsEnemy,k)
			end
		end
		ply:ChatPrint(ent:GetName().." Became an ally to you.")
	end
})
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ SNPC Hostile Me ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
properties.Add("vj_pr_npc_hostileme",{
	MenuLabel = "#vjbase.menuproperties.hostileme", -- Name to display on the context menu
	Order = 50005, -- The order to display this property relative to other properties
	MenuIcon = "icon16/heart_delete.png", -- The icon to display next to the property

	Filter = function(self, ent, ply) -- A function that determines whether an entity is valid for this property
		if (!IsValid(ent)) then return false end
		if (ent:IsPlayer()) or !ent:IsNPC() then return false end
		if (!gamemode.Call("CanProperty", ply, "vj_npc_properties", ent)) then return false end
		if ent.IsVJBaseSNPC != true then return false end
		return true
	end,
	
	Action = function(self, ent) -- The action to perform upon using the property (Clientside)
		self:MsgStart()
			net.WriteEntity(ent)
		self:MsgEnd()
	end,
	
	Receive = function(self, length, ply) -- The action to perform upon using the property (Serverside)
		local ent = net.ReadEntity()
		if (!self:Filter(ent, ply)) then return end
		table.insert(ent.VJ_AddCertainEntityAsEnemy,ply)
		for k,v in ipairs(ent.VJ_AddCertainEntityAsFriendly) do
			if v:IsPlayer() && v:GetName() == ply:GetName() then
				table.remove(ent.VJ_AddCertainEntityAsFriendly,k)
			end
		end
		ply:ChatPrint(ent:GetName().." Became hostile to you.")
	end
})
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ SNPC Slay ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
properties.Add("vj_pr_npc_slay",{
	MenuLabel = "#vjbase.menuproperties.slay", -- Name to display on the context menu
	Order = 50006, -- The order to display this property relative to other properties
	MenuIcon = "icon16/cancel.png", -- The icon to display next to the property

	Filter = function(self, ent, ply) -- A function that determines whether an entity is valid for this property
		if (!IsValid(ent)) then return false end
		if (ent:IsPlayer()) or !ent:IsNPC() then return false end
		if (!gamemode.Call("CanProperty", ply, "vj_npc_properties", ent)) then return false end
		if ent.IsVJBaseSNPC != true then return false end
		return true
	end,
	
	Action = function(self, ent) -- The action to perform upon using the property (Clientside)
		self:MsgStart()
			net.WriteEntity(ent)
		self:MsgEnd()
	end,
	
	Receive = function(self, length, ply) -- The action to perform upon using the property (Serverside)
		local ent = net.ReadEntity()
		if (!self:Filter(ent, ply)) then return end
		ent:SetHealth(0)
		ent:TakeDamage(ent:Health() + 99999,ply,ply)
		ply:ChatPrint("Slayed "..ent:GetName()..".")
	end
})
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ SNPC Gib ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
properties.Add("vj_pr_npc_gib",{
	MenuLabel = "#vjbase.menuproperties.gib", -- Name to display on the context menu
	Order = 50007, -- The order to display this property relative to other properties
	MenuIcon = "icon16/bomb.png", -- The icon to display next to the property

	Filter = function(self, ent, ply) -- A function that determines whether an entity is valid for this property
		if (!IsValid(ent)) then return false end
		if (ent:IsPlayer()) or !ent:IsNPC() then return false end
		if (!gamemode.Call("CanProperty", ply, "vj_npc_properties", ent)) then return false end
		if ent.IsVJBaseSNPC != true then return false end
		return true
	end,
	
	Action = function(self, ent) -- The action to perform upon using the property (Clientside)
		self:MsgStart()
			net.WriteEntity(ent)
		self:MsgEnd()
	end,
	
	Receive = function(self, length, ply) -- The action to perform upon using the property (Serverside)
		local ent = net.ReadEntity()
		if (!self:Filter(ent, ply)) then return end
		ent:SetHealth(0)
		local dmg = DamageInfo()
		dmg:SetAttacker(ply)
		dmg:SetInflictor(ply)
		dmg:SetDamage(ent:Health() + 99999)
		dmg:SetDamageType(DMG_ALWAYSGIB)
		ent:TakeDamageInfo(dmg)
		ply:ChatPrint("Gibbed "..ent:GetName()..".")
	end
})
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ SNPC Developer Mode ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
properties.Add("vj_pr_npc_devmode",{
	MenuLabel = "#vjbase.menuproperties.devmode", -- Name to display on the context menu
	Order = 50008, -- The order to display this property relative to other properties
	MenuIcon = "icon16/tag.png", -- The icon to display next to the property

	Filter = function(self, ent, ply) -- A function that determines whether an entity is valid for this property
		if (!IsValid(ent)) then return false end
		if (ent:IsPlayer()) or !ent:IsNPC() then return false end
		if (!gamemode.Call("CanProperty", ply, "vj_npc_properties", ent)) then return false end
		if ent.IsVJBaseSNPC != true then return false end
		return true
	end,
	
	Action = function(self, ent) -- The action to perform upon using the property (Clientside)
		self:MsgStart()
			net.WriteEntity(ent)
		self:MsgEnd()
	end,
	
	Receive = function(self, length, ply) -- The action to perform upon using the property (Serverside)
		local ent = net.ReadEntity()
		if (!self:Filter(ent, ply)) then return end
		if ent.VJ_DEBUG == true then
			ply:ChatPrint("Disabled Developer Mode for "..ent:GetName()..".")
			ent.VJ_DEBUG = false
		else
			ply:ChatPrint("Enabled Developer Mode for "..ent:GetName()..". Navigate to the SNPC developer menu to toggle items you want.")
			ent.VJ_DEBUG = true
		end
	end
})
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/loader/loader.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/core/sh_metatable.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/dualblade.lua:
local DATA = {}
DATA.Name = "DualBlade"
DATA.HoldType = "wos-dual-blade"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "wos_ryoku_r_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "balanced_jump", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================

--PATH lua/wos/anim_extension/holdtypes/form2.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/g_combo3.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/g_combo32.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/g_combo4.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/g_restart.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_restart"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "restart_base_layer" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "restart_base_layer" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "wos_judge_a_idle"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/melee2great.lua:
local DATA = {}
DATA.Name = "melee3"
DATA.HoldType = "wos-meleestamina-type"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "b_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "r_idle", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "h_jump", Weight = 1 },
}


wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/versalite.lua:
return gluapack()()
--PATH lua/wos/dynabase/core/sh_mounting.lua:
wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}
local added = {}

////////////////////////////////////// BASELINE STUFF //////////////////////////////////////
local model_table = {}
model_table[ WOS_DYNABASE.SHARED  ] = "models/player/wiltos/anim_dynamic_pointer.mdl"
model_table[ WOS_DYNABASE.MALE  ] = "models/player/wiltos/anim_dynamic_maleptr.mdl"
model_table[ WOS_DYNABASE.FEMALE  ] = "models/player/wiltos/anim_dynamic_femaler.mdl"
model_table[ WOS_DYNABASE.ZOMBIE  ] = "models/player/wiltos/anim_dynamic_zombier.mdl"

local model_ext = {}
model_ext[ WOS_DYNABASE.MALE  ] = "_male"
model_ext[ WOS_DYNABASE.FEMALE  ] = "_female"
model_ext[ WOS_DYNABASE.ZOMBIE  ] = "_zombie"

local INCLUDE_MODEL_START = 737
local INCLUDE_MODEL_END_SHARED = 806

// "Hard code the math idiot" says the guy who doesn't realize I'm making it easier on myself to change their names or expand in the future
// I also can't count letters, only numbers?? GENIUS. NICE ONE
local INCLUDE_MODEL_END_MALE = INCLUDE_MODEL_END_SHARED + ( #"_male" )*2
local INCLUDE_MODEL_END_FEMALE = INCLUDE_MODEL_END_SHARED + ( #"_female" )*2 
local INCLUDE_MODEL_END_ZOMBIE = INCLUDE_MODEL_END_SHARED + ( #"_zombie" )*2

////////////////////////////////////////////////////////////////////////////////////////////

function IncludeModel( mdl )
	if not mdl then return end
	if wOS.DynaBase.PreservedModels[ mdl ] then mdl = wOS.DynaBase.PreservedModels[ mdl ] end
	if table.HasValue( added, mdl ) then return end //This isn't needed but let's not bloat the mount file
	table.insert( added, 1, mdl )
end

local function IntToByte( num )
	if not num then return end
	local t = {}
	t[1] = num % 256
	for i=1, 3 do
		t[i+1] = math.modf( num / ( 256^i ) ) % ( 256 )
	end
	return t
end

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// If you don't know what this does do not mess with it or you're gonna mess up your player model
// There'll be a lot of repeated code here for now while we get some TESTING done
local function WRITE_TO_LOCAL( start, finish, type )
	if not type then return end
	local base_path = model_table[ type  ]
	if not base_path then return end

	local mdl_file = file.Open( base_path, "r", "GAME" )
	local dat = {}
	local str = ""
	for i=0, mdl_file:Size() do
		local byte = mdl_file:ReadByte()
		table.insert( dat, byte )
		if not byte then continue end
		str = str .. string.char( byte )
	end

	
	local endchar = str[finish]
	local tstr = ""
	for i=0, #str do
		if i == start then
			for _, newmodel in ipairs( added ) do
				tstr = tstr .. newmodel .. endchar
			end
		end
		if i >= start and i <= finish then continue end
		local char = str[i]
		tstr = tstr .. char
	end

	local includenum = IntToByte( #added )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 336 + i, string.char( includenum[i] ) )
	end

	local final_line = "models/player/wiltos/anim_dynamic_pointer/."
	local endptr = #tstr - #final_line

	local null_insert = IntToByte( 0 )

    // You can manipulate the list here to remove anything you don't want for this type
	hook.Call( "PreCreateLocalAnimation", nil, type, added )

	local first_num = 60 + ( #added - 1 )*8
	local includenum = IntToByte( first_num )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 680 + i, string.char( includenum[i] ) )
	end

	for i=1, #added - 1 do

		local anim_pos = first_num - 7*i
		for j=1, i do
			anim_pos = anim_pos + #added[j]
		end
		local anim_num = IntToByte( anim_pos )

		local start_pos = 676 + 8*i
		local start_half = string.sub( tstr, 1, start_pos )
		for j=1, 4 do
			start_half = start_half .. string.char( null_insert[j] )
		end
		for j=1, 4 do
			start_half = start_half .. string.char( anim_num[j] )
		end
		endptr = endptr + 8
		tstr = start_half .. string.sub( tstr, start_pos + 1 )
	end


	local endincludeaddr = IntToByte( endptr )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 684 + 8*(#added - 1 ) + i, string.char( endincludeaddr[i] ) )
	end

	for i=0, #added - 1 do
		tstr = tstr .. endchar
	end

	local datalen = IntToByte( #tstr )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 76 + i, string.char( datalen[i] ) )
	end

	local ext = model_ext[ type  ] or "_shared"
	file.Write( "wos/dynabase/local" .. ext .. WOS_DYNABASE_FILE_EXTENSION, tstr )
    hook.Call( "PostCreateLocalAnimation", nil, type, added )
end

// If you don't know what this does do not mess with it or you're gonna mess up your player model
local function WRITE_TO_POINTER( start, finish, type )
	if not type then return end
	local base_path = model_table[ type ]
	if not base_path then return end

	local mdl_file = file.Open( base_path, "r", "GAME" )
	local str = ""
	for i=0, mdl_file:Size() do
		local byte = mdl_file:ReadByte()
		if not byte then continue end
		str = str .. string.char( byte )
	end

	
	local endchar = str[finish]
	local tstr = ""
	for i=0, #str do
		if i == start then
			for _, newmodel in ipairs( added ) do
				tstr = tstr .. newmodel .. endchar
			end
		end
		if i >= start and i <= finish then continue end
		local char = str[i]
		tstr = tstr .. char
	end

	local includenum = IntToByte( #added )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 336 + i, string.char( includenum[i] ) )
	end

	local final_line = "models/player/wiltos/anim_dynamic_pointer/."
	local endptr = #tstr - #final_line

	local null_insert = IntToByte( 0 )

    // You can manipulate the list here to remove anything you don't want for this type
	hook.Call( "PreMountAnimation", nil, type, added )

	local first_num = 60 + ( #added - 1 )*8
	local includenum = IntToByte( first_num )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 680 + i, string.char( includenum[i] ) )
	end

	for i=1, #added - 1 do

		local anim_pos = first_num - 7*i
		for j=1, i do
			anim_pos = anim_pos + #added[j]
		end
		local anim_num = IntToByte( anim_pos )

		local start_pos = 676 + 8*i
		local start_half = string.sub( tstr, 1, start_pos )
		for j=1, 4 do
			start_half = start_half .. string.char( null_insert[j] )
		end
		for j=1, 4 do
			start_half = start_half .. string.char( anim_num[j] )
		end
		endptr = endptr + 8
		tstr = start_half .. string.sub( tstr, start_pos + 1 )
	end


	local endincludeaddr = IntToByte( endptr )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 684 + 8*(#added - 1 ) + i, string.char( endincludeaddr[i] ) )
	end

	for i=0, #added - 1 do
		tstr = tstr .. endchar
	end

	local datalen = IntToByte( #tstr )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 76 + i, string.char( datalen[i] ) )
	end

	local ext = model_ext[ type  ] or ""
	file.Write( "wos/dynabase/anim_dynamic" .. ext .. WOS_DYNABASE_FILE_EXTENSION, tstr )
    hook.Call( "PostMountAnimation", nil, type, added )
end

/////////////////////////////////////////////////////////////////////////////////////////////////////////

local function AdjustMountOrder( tbl, typ )
	if not tbl then return end

	local reference = wOS.DynaBase.FilteredLoadOrder[ typ ]
	local blacklist = wOS.DynaBase.FilteredBlacklist[ typ ]
	local plyref = wOS.DynaBase.FilteredPlayerOrder[ typ ]
	local plyblacklist = wOS.DynaBase.FilteredPlayerBlacklist[ typ ]

	local new_tbl = {}

	if WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() > 0 then
		local cust_mount = wOS.DynaBase:GetSource( "Local Player Animations" )
		if cust_mount then
			if typ == WOS_DYNABASE.MALE then
				table.RemoveByValue( tbl, cust_mount.Male )
			elseif typ == WOS_DYNABASE.FEMALE then
				table.RemoveByValue( tbl, cust_mount.Female )
			elseif typ == WOS_DYNABASE.ZOMBIE then
				table.RemoveByValue( tbl, cust_mount.Zombie )
			else
				table.RemoveByValue( tbl, cust_mount.Shared )
			end
		end
	end

	if reference then
		for _, path in ipairs( reference ) do
			path = wOS.DynaBase.PreservedModels[ path ] or path
			if !table.HasValue( tbl, path ) then continue end
			table.insert( new_tbl, path )
			table.RemoveByValue( tbl, path )
		end
	end

	// If we aren't allowed to use any other addon than the ones that are dictated, don't merge any extra models
	if WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() >= 2 and reference then return new_tbl end

	if plyref then
		for _, path in ipairs( plyref ) do
			path = wOS.DynaBase.PreservedModels[ path ] or path
			if !table.HasValue( tbl, path ) then continue end
			table.insert( new_tbl, path )
			table.RemoveByValue( tbl, path )
		end
	end

	if plyblacklist then
		for _, path in ipairs( plyblacklist ) do
			path = wOS.DynaBase.PreservedModels[ path ] or path
			table.RemoveByValue( tbl, path )
		end	
	end

	// Add the ones we don't care about now
	table.Add( new_tbl, tbl )

	// Server gets final word what we can use
	if blacklist then
		for _, path in ipairs( blacklist ) do
			path = wOS.DynaBase.PreservedModels[ path ] or path
			table.RemoveByValue( new_tbl, path )
		end	
	end


	return new_tbl
end

function wOS.DynaBase:ReloadAnimations()

	if self.LIVE_RELOAD then
		local seq = LocalPlayer():LookupSequence( "_dynamic_wiltos_enabled_" )
		if seq <= 0 then
			chat.AddText( Color( 255, 0, 0 ), "[wOS-Dynabase] Dynamic Animation Base failed due to conflicting animation base. Enter wos_dynabase_help into console to find the conflict, unsubscribe from the addon, and restart Garry's Mod.\n\nIf you are on someone's server, contact the owner to ensure they do not have a conflicting animation addon as required content." )
			return
		end
	end

	added = table.Copy( self.DefaultTable.Male )
	hook.Call( "PreLoadAnimations", nil, WOS_DYNABASE.MALE, added )
	local ntable = AdjustMountOrder( added, WOS_DYNABASE.MALE )
	added = ntable or added
	WRITE_TO_POINTER( INCLUDE_MODEL_START, INCLUDE_MODEL_END_MALE, WOS_DYNABASE.MALE )
	
	added = table.Copy( wOS.DynaBase.DefaultTable.Female )
	hook.Call( "PreLoadAnimations", nil, WOS_DYNABASE.FEMALE, added )
	ntable = AdjustMountOrder( added, WOS_DYNABASE.FEMALE )
	added = ntable or added
	WRITE_TO_POINTER( INCLUDE_MODEL_START, INCLUDE_MODEL_END_FEMALE, WOS_DYNABASE.FEMALE )

	added = table.Copy( wOS.DynaBase.DefaultTable.Zombie )
	hook.Call( "PreLoadAnimations", nil, WOS_DYNABASE.ZOMBIE, added )
	ntable = AdjustMountOrder( added, WOS_DYNABASE.ZOMBIE )
	added = ntable or added
	WRITE_TO_POINTER( INCLUDE_MODEL_START, INCLUDE_MODEL_END_ZOMBIE, WOS_DYNABASE.ZOMBIE )

	added = table.Copy( wOS.DynaBase.DefaultTable.Shared  )
	hook.Call( "PreLoadAnimations", nil, WOS_DYNABASE.SHARED, added )
	ntable = AdjustMountOrder( added, WOS_DYNABASE.SHARED )
	added = ntable or added
	WRITE_TO_POINTER( INCLUDE_MODEL_START, INCLUDE_MODEL_END_SHARED, WOS_DYNABASE.SHARED )

	if SERVER then
		hook.Call( "PostLoadAnimations" ) --Server doesn't need to worry about render stuff so we load here
		return
	end

	if wOS.DynaBase.InitCompleted and not WOS_DYNABASE_SHOULDHOTLOAD_CVAR:GetBool() then return end
	wOS.DynaBase.ReloadModelBool = true
end

function wOS.DynaBase:ReloadLocalAnimations( order )

	if not order then
		order = file.Read( "wos/dynabase/usermounts/preference.txt", "DATA" ) or "{}"
		order = util.JSONToTable( order )
	end

	local shared_tbl = {}
	local male_tbl = {}
	local female_tbl = {}
	local zombie_tbl = {}

	for _, mount in ipairs( order ) do
		if not mount.Toggled then continue end
		local data = self:GetUserMount( mount.Name )
		if not data then continue end
		
		if data.Shared and not table.HasValue( shared_tbl, data.Shared ) then
			table.insert( shared_tbl, data.Shared )
		end

		if data.Male and not table.HasValue( male_tbl, data.Male ) then
			table.insert( male_tbl, data.Male )
		end

		if data.Female and not table.HasValue( female_tbl, data.Female ) then
			table.insert( female_tbl, data.Female )
		end

		if data.Zombie and not table.HasValue( zombie_tbl, data.Zombie ) then
			table.insert( zombie_tbl, data.Zombie )
		end

	end

	added = male_tbl
	WRITE_TO_LOCAL( INCLUDE_MODEL_START, INCLUDE_MODEL_END_MALE, WOS_DYNABASE.MALE )
	
	added = female_tbl
	WRITE_TO_LOCAL( INCLUDE_MODEL_START, INCLUDE_MODEL_END_FEMALE, WOS_DYNABASE.FEMALE )

	added = zombie_tbl
	WRITE_TO_LOCAL( INCLUDE_MODEL_START, INCLUDE_MODEL_END_ZOMBIE, WOS_DYNABASE.ZOMBIE )

	added = shared_tbl
	WRITE_TO_LOCAL( INCLUDE_MODEL_START, INCLUDE_MODEL_END_SHARED, WOS_DYNABASE.SHARED )
end

file.CreateDir("wos/dynabase/usermounts")
--PATH lua/wos/dynabase/core/cl_net.lua:
return gluapack()()
--PATH lua/wos/dynabase/registers/riddick_register.lua:
return gluapack()()
--PATH lua/wos/dynabase/registers/stormnewlscs_extend.lua:
return gluapack()()
--PATH lua/wos/dynabase/registers/stormnewlscs_extend.lua:

wOS.DynaBase:RegisterSource({
    Name = "Storm LSCS Extension",
    Type =  WOS_DYNABASE.EXTENSION,
    Shared = "models/player/wiltos/anim_storm_lscs.mdl",
})

hook.Add( "PreLoadAnimations", "wOS.DynaBase.StormLSCS", function( gender )
    if gender != WOS_DYNABASE.SHARED then return end
    IncludeModel( "models/player/wiltos/anim_storm_lscs.mdl" )
end )
--PATH lua/xeninui/settings/settings.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/main.lua:
XeninUI.Configurator = XeninUI.Configurator || {}

function XeninUI.Configurator:PrintMessage(msg)
  MsgC(XeninUI.Theme.Yellow, "[Xenin Configurator] ", color_white, msg .. "\n")
end

--PATH lua/xeninui/libs/configurator/ui/frame.lua:
local PANEL = {}

function PANEL:Init()
  if IsValid(XeninUI.Configurator.AdminMenu) then XeninUI.Configurator.AdminMenu:Remove()end

  XeninUI.Configurator.AdminMenu = self

  self:SetSize(1020, 800)
  self:Center()
  self:MakePopup()

  self.Top = self:Add("Xenin.Configurator.Admin.Top")
  self.Top:Dock(TOP)
  self.Top:DockMargin(16, 16, 16, 16)
  self.Top:SetText({
    "Title",
    "Subtitle"
  })

  self.Sidebar = self:Add("Xenin.Configurator.Admin.Sidebar")
  self.Sidebar:Dock(LEFT)
end

function PANEL:AddTab(...)
  self.Sidebar:AddTab(...)
end

function PANEL:SetActive(id)
  self.Sidebar:SetActive(id)
end

function PANEL:PerformLayout(w, h)
  self.Top:SetTall(40)
  self.Sidebar:SetWide(200)
end

function PANEL:Paint(w, h)
  local x, y = self:LocalToScreen()

  BSHADOWS.BeginShadow()
  draw.RoundedBox(6, x, y, w, h, XeninUI.Theme.Background)
  BSHADOWS.EndShadow(1, 2, 2, 255, 0, 0)

  draw.RoundedBoxEx(6, 0, 0, w, 40 + 32, XeninUI.Theme.Primary, true, true, false, false)
end

function PANEL:SetScript(script)
  local __laux_type = (istable(script) and script.__type and script:__type()) or type(script)
  assert(__laux_type == "string", "Expected parameter `script` to be type `string` instead of `" .. __laux_type .. "`")
  self.script = script
  local ctr = XeninUI.Configurator:FindControllerByScriptName(script)
  local tabs = ctr:getTabs()
  for i, v in ipairs(tabs) do
    self.Sidebar:AddTab(v.name, v.icon, v.color, v.panel, script, v)
  end
  self.Top:SetScript(script, ctr)
  self.Top:SetText(ctr:getTitle())
  self.Sidebar:SetActive(1)
end

vgui.Register("Xenin.Configurator.Admin", PANEL, "EditablePanel")

concommand.Add("xenin_config", function(ply, cmd, args)
  assert(XeninUI.Permissions:canAccessFramework(ply), "You don't have access to this config")
  local script = args[1]
  assert(isstring(script), "You need the script ID you're looking for")
  local controller = XeninUI.Configurator:FindControllerByScriptName(script)
  assert(controller != nil, "That script does not exist")

  local frame = vgui.Create("Xenin.Configurator.Admin")
  frame:SetScript(script)
end, function(cmd, args)
  local script = string.lower(string.Trim(args))
  local tbl = {}
  for i, v in ipairs(XeninUI.Configurator:GetControllers()) do
    if (#script > 0 and !v:getScript():find(script)) then continue end

    table.insert(tbl, "xenin_config " .. v:getScript())
  end


  table.sort(tbl, function(a, b)
    return a > b end)

  return tbl
end)

--PATH lua/xeninui/libs/configurator/ui/search_bar.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/color.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/keyvalue.lua:
local x

--PATH lua/xeninui/libs/configurator/ui/inputs/range.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/selectbox.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/inputs/textentrylist.lua:
local x

--PATH lua/xeninui/libs/players/ui/notifications/main.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Players.Notifications", 20)

function PANEL:Init()
  self:DockPadding(16, 16, 16, 16)

  self.Top = self:Add("Panel")
  self.Top:Dock(TOP)

  self.Top.Title = self.Top:Add("DLabel")
  self.Top.Title:Dock(LEFT)
  self.Top.Title:SetFont("XeninUI.Players.Notifications")
  self.Top.Title:SetTextColor(Color(222, 222, 222))
  self.Top.Title:SetText("Latest Notifications")

  self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)
  self.Scroll:DockMargin(0, 8, 0, 0)

  self.Layout = self.Scroll:Add("DListLayout")
  self.Layout:Dock(TOP)
  self.Layout:DockMargin(0, 0, 8, 0)

  self.Loading = true
  hook.Add("XeninUI.Players.GotNotifications", self, function(self, notifications)
    if self.Loading then
      self:ClearNotifications()
      for i, v in ipairs(notifications) do
        self:AddNotification(v)
      end
      self.Loading = false
      self:InvalidateLayout()
    end
  end)

  self:GetNotifications()

  self:AddTimer("XeninUI.Players.Notifications.UpdateRead", 1, 0, function()
    if (!IsValid(self)) then return end

    local notificationPanels = self:GetNotificationsInView()
    local notifications = {}
    for i, v in ipairs(notificationPanels) do
      if (!v.Notification) then continue end
      if (v.Notification.readAt) then continue end

      v.Notification.readAt = os.time()
      v.BackgroundColor = XeninUI.Theme.Primary

      table.insert(notifications, v.Notification.id)
    end

    if (#notifications == 0) then return end
    XeninUI.Players.Network:sendReadNotifications(notifications)
  end)
end

function PANEL:GetNotifications()
  XeninUI.Players.Network:sendReceiveNotifications()
end

function PANEL:ClearNotifications()
  self.Layout:Clear()
end

function PANEL:AddNotification(notification)
  local row = self.Layout:Add("XeninUI.Players.Notifications.Row")
  row:Dock(TOP)
  row:DockMargin(0, 0, 0, 4)
  row:SetNotification(notification)
end

function PANEL:PerformLayout(w, h)
  self.Top.Title:SizeToContents()

  for i, v in ipairs(self.Layout:GetChildren()) do
    v:SetTall(v:CalculateHeight())
    print(v:IsVisible())
  end
end

function PANEL:Paint(w, h)
  if self.Loading then
    draw.SimpleText("Loading", "XeninJC.Admin.Queue.Loading", w / 2, h / 2 - h / 8, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
    XeninUI:DrawLoadingCircle(w / 2, h / 2 + 16, h / 4, XeninUI.Theme.Accent)
  end
end

function PANEL:GetNotificationsInView()
  local sH = self.Scroll:GetTall()
  local sY = self.Scroll.VBar.Scroll
  local sB = sH + sY

  local notifications = {}
  for i, v in ipairs(self.Layout:GetChildren()) do
    assert(v ~= nil, "cannot destructure nil value")
    local y = v.y
    if (y > sB) then continue end
    if (sY > y) then continue end
    if (sB < y) then continue end
    if (!v.Notification) then continue end
    if (v.Notification.readAt) then continue end

    table.insert(notifications, v)
  end

  return notifications
end

vgui.Register("XeninUI.Players.Notifications", PANEL)

--PATH lua/xeninui/elements/breadcrumbs.lua:
return gluapack()()
--PATH lua/xeninui/elements/checkbox.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Checkbox", 16)
XeninUI:CreateFont("XeninUI.Checkbox.Small", 15)

function PANEL:Init()
  self:SetText("")
  self.state = nil

  self.barPos = 0

  self.offText = "OFF"
  self.onText = "ON"
  self.font = "XeninUI.Checkbox"
end

function PANEL:Paint(w, h)
  surface.SetDrawColor(Color(0, 0, 0, 150))
  surface.DrawRect(0, 0, w, h)

  self.barPos = self.barPos + ((self.state and 1 or 0) - self.barPos) * 8 * FrameTime()

  local offColor = Color(self.barPos * 200, self.barPos * 200, self.barPos * 200)
  local onColor = Color(200 - (self.barPos * 200), 200 - (self.barPos * 200), 200 - (self.barPos * 200))

  surface.SetDrawColor(Color(200, 200, 200))
  surface.DrawRect(math.Clamp(self.barPos * ((w + 4) / 2), 2, w / 2), 2, (w - 4) / 2, h - 4)

  draw.SimpleText(self.offText, self.font, w / 4, h / 2, offColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  draw.SimpleText(self.onText, self.font, w / 2 + w / 4, h / 2, onColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

function PANEL:DoClick()
  self:SetState(!self:GetState())
end

function PANEL:OnStateChanged() end

function PANEL:GetState()
  return self.state
end

function PANEL:SetState(state, instant)
  self.state = state

  self:OnStateChanged(state, instant)

  if instant then
    self.barPos = state and 1 or 0
  end
end

function PANEL:SetStateText(off, on)
  self.offText = off
  self.onText = on
end

vgui.Register("XeninUI.Checkbox", PANEL, "DButton")

--PATH lua/xeninui/elements/colormixer.lua:
local PANEL = {}

function PANEL:Init()
    self.sliders = vgui.Create("Panel", self)
    self.sliders:Dock(LEFT)
    self.sliders:DockMargin(0, 0, 10, 0)

    self.red = vgui.Create("Panel", self.sliders)
    self.red:Dock(TOP)

    self.rInput = vgui.Create("XeninUI.TextEntry", self.red)
    self.rInput:Dock(LEFT)
    self.rInput:DockMargin(0, 0, 0, 5)
    self.rInput:SetText(0)
    self.rInput.textentry:SetUpdateOnType(true)

    self.Input.textentry.OnValueChange = function(pnl, value)
        local numValue = tonumber(value)
        if not numValue then return pnl:SetText("255")end

        if numValue < 0 or numValue > 255 then return pnl:SetText("255")end

        self.rSlider.fraction = (numValue / 255)
        self.rSlider:InvalidateLayout()
    end

    self.rSlider = vgui.Create("XeninUI.Slider", self.red)
    self.rSlider:Dock(RIGHT)
    self.rSlider:SetMin(0)
    self.rSlider:SetMax(255)
    self.rSlider:SetColor(Color(231, 76, 60))

    self.rSlider.OnValueChanged = function(pnl, frac)
        self.rInput:SetText(math.floor(frac * 255))
    end

    self.green = vgui.Create("Panel", self.sliders)
    self.green:Dock(TOP)

    self.gInput = vgui.Create("XeninUI.TextEntry", self.green)
    self.gInput:Dock(LEFT)
    self.gInput:DockMargin(0, 0, 0, 5)
    self.gInput:SetText(0)
    self.gInput.textentry:SetUpdateOnType(true)

    self.gInput.textentry.OnValueChange = function(pnl, value)
        local numValue = tonumber(value)
        if not numValue then return pnl:SetText("0")end

        if numValue < 0 or numValue > 255 then return pnl:SetText("255")end

        self.gSlider.fraction = (numValue / 255)
        self.gSlider:InvalidateLayout()
    end

    self.gSlider = vgui.Create("XeninUI.Slider", self.green)
    self.gSlider:Dock(RIGHT)
    self.gSlider:SetMin(0)
    self.gSlider:SetMax(255)
    self.gSlider:SetColor(Color(46, 204, 113))

    self.gSlider.OnValueChanged = function(pnl, frac)
        self.gInput:SetText(math.floor(frac * 255))
    end

    self.blue = vgui.Create("Panel", self.sliders)
    self.blue:Dock(TOP)

    self.bInput = vgui.Create("XeninUI.TextEntry", self.blue)
    self.bInput:Dock(LEFT)
    self.bInput:DockMargin(0, 5, 0, 0)
    self.bInput:SetText(0)
    self.bInput.textentry:SetUpdateOnType(true)

    self.bInput.textentry.OnValueChange = function(pnl, value)
        local numValue = tonumber(value)
        if not numValue then return pnl:SetText("0")end

        if numValue < 0 or numValue > 255 then return pnl:SetText("255")end

        self.bSlider.fraction = (numValue / 255)
        self.bSlider:InvalidateLayout()
    end

    self.bSlider = vgui.Create("XeninUI.Slider", self.blue)
    self.bSlider:Dock(RIGHT)
    self.bSlider:SetMin(0)
    self.bSlider:SetMax(255)
    self.bSlider:SetColor(Color(52, 152, 219))

    self.bSlider.OnValueChanged = function(pnl, frac)
        self.bInput:SetText(math.floor(frac * 255))
    end

    self.preview = vgui.Create("Panel", self)
    self.preview:Dock(FILL)
    self.preview:DockMargin(5, 5, 5, 5)

    self.preview.Paint = function(pnl, w, h)
        draw.RoundedBox(6, 0, 0, w, h, self:GetValue())
    end
end

function PANEL:SetValue(color)
    self.rSlider.fraction = color.r / 255
    self.rInput:SetText(color.r)
    self.gSlider.fraction = color.g / 255
    self.gInput:SetText(color.g)
    self.bSlider.fraction = color.b / 255
    self.bInput:SetText(color.b)
end

function PANEL:GetValue()
    return Color(math.floor(self.rSlider.fraction * 255), math.floor(self.gSlider.fraction * 255), math.floor(self.bSlider.fraction * 255))
end

function PANEL:PerformLayout(w, h)
    self.sliders:SetWide(w * .8)

    self.red:SetTall(h / 3)
    self.rInput:SetWide(self.red:GetWide() * .11)
    self.rSlider:SetWide(self.red:GetWide() * .88)

    self.green:SetTall(h / 3)
    self.gInput:SetWide(self.green:GetWide() * .11)
    self.gSlider:SetWide(self.green:GetWide() * .88)

    self.blue:SetTall(h / 3)
    self.bInput:SetWide(self.blue:GetWide() * .11)
    self.bSlider:SetWide(self.blue:GetWide() * .88)
end

vgui.Register("XeninUI.ColorMixer", PANEL)

--PATH lua/xeninui/elements/colorpicker.lua:
return gluapack()()
--PATH lua/xeninui/elements/frame.lua:
return gluapack()()
--PATH lua/xeninui/elements/purchase_confirmation.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.PurchaseConfirmation.Name", 24)
XeninUI:CreateFont("XeninUI.PurchaseConfirmation.Sid64", 18)
XeninUI:CreateFont("XeninUI.PurchaseConfirmation.String", 24)

AccessorFunc(PANEL, "m_player", "Player")
AccessorFunc(PANEL, "m_icon", "Icon")
AccessorFunc(PANEL, "m_purchaseStr", "PurchaseString")
AccessorFunc(PANEL, "m_accept", "Accept")
AccessorFunc(PANEL, "m_decline", "Decline")
AccessorFunc(PANEL, "m_tbl", "Table")

function PANEL:Start()
  self:SetAccept(function() end)
  self:SetDecline(function() end)

  self.background.avatar = self.background:Add("XeninUI.Avatar")
  self.background.avatar:SetPlayer(self:GetPlayer(), 64)
  self.background.avatar:SetVertices(90)
  self.background.avatar:SetMouseInputEnabled(false)

  self.background.name = self.background:Add("DLabel")
  self.background.name:SetText(self:GetPlayer():Nick())
  self.background.name:SetTextColor(color_white)
  self.background.name:SetFont("XeninUI.PurchaseConfirmation.Name")

  self.background.sid64 = self.background:Add("DTextEntry")
  self.background.sid64:SetText(self:GetPlayer():SteamID())
  self.background.sid64:SetTextColor(Color(190, 190, 190))
  self.background.sid64:SetFont("XeninUI.PurchaseConfirmation.Sid64")
  self.background.sid64:SetEnabled(false)
  self.background.sid64:SetDrawLanguageID(false)
  self.background.sid64.Paint = function(pnl, w, h)
    pnl:DrawTextEntryText(pnl:GetTextColor(), pnl:GetTextColor(), pnl:GetTextColor())
  end

  self.background.string = self.background:Add("DLabel")
  self.background.string:SetText(self:GetPurchaseString())
  self.background.string:SetTextColor(Color(220, 220, 220))
  self.background.string:SetWrap(true)
  self.background.string:SetFont("XeninUI.PurchaseConfirmation.String")
  self.background.string:SetContentAlignment(5)

  if (type(self:GetIcon()) == "string") then
    self.background.display = self.background:Add("XeninUI.AnimatedTexture")
    self.background.display:SetDirectory(self:GetIcon())
    local tbl = self:GetTable()
    self.background.display:SetTimes(tbl.normal, tbl.idle)
    self.background.display:PostInit()
  else
    self.background.display = self.background:Add("DPanel")
    self.background.display.Paint = function(pnl, w, h)
      if (!self:GetIcon()) then return end

      surface.SetMaterial(self:GetIcon())
      surface.SetDrawColor(color_white)
      surface.DrawTexturedRect(0, 0, w, h)
    end
  end

  self.background.accept = self.background:Add("DButton")
  self.background.accept:SetText("Confirm purchase")
  self.background.accept:SetFont("XeninUI.Query.Button")
  self.background.accept:SetTextColor(Color(21, 21, 21))
  self.background.accept.alpha = 0
  self.background.accept.background = XeninUI.Theme.Green
  self.background.accept.Paint = function(pnl, w, h)
    local x, y = pnl:LocalToScreen()

    BSHADOWS.BeginShadow()
    draw.RoundedBox(h / 2, x, y, w, h, pnl.background)
    BSHADOWS.EndShadow(1, 1, 2, pnl.alpha, 0, 0)
  end
  self.background.accept.OnCursorEntered = function(pnl)
    local col = XeninUI.Theme.Green
    col = Color(col.r + 5, col.g + 50, col.b + 7)

    pnl:LerpColor("background", col)
    pnl:Lerp("alpha", 255)
  end
  self.background.accept.OnCursorExited = function(pnl)
    pnl:LerpColor("background", XeninUI.Theme.Green)
    pnl:Lerp("alpha", 0)
  end
  self.background.accept.DoClick = function(pnl)
    self:GetAccept()(pnl)
    self:Remove()
  end

  self.background.decline = self.background:Add("DButton")
  self.background.decline:SetText("Cancel")
  self.background.decline:SetFont("XeninUI.Query.Button")
  self.background.decline:SetTextColor(Color(145, 145, 145))
  self.background.decline.alpha = 0
  self.background.decline.background = XeninUI.Theme.Background
  self.background.decline.Paint = function(pnl, w, h)
    local x, y = pnl:LocalToScreen()

    BSHADOWS.BeginShadow()
    draw.RoundedBox(h / 2, x, y, w, h, XeninUI.Theme.Navbar)
    BSHADOWS.EndShadow(1, 1, 2, pnl.alpha, 0, 0)

    draw.RoundedBox(h / 2, 2, 2, w - 4, h - 4, pnl.background)
  end
  self.background.decline.OnCursorEntered = function(pnl)
    pnl:LerpColor("background", XeninUI.Theme.Navbar)
    pnl:Lerp("alpha", 200)
  end
  self.background.decline.OnCursorExited = function(pnl)
    pnl:LerpColor("background", XeninUI.Theme.Background)
    pnl:Lerp("alpha", 0)
  end
  self.background.decline.DoClick = function(pnl)
    self:GetDecline()(pnl)
    self:Remove()
  end
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)

  local y = 40
  self.background.avatar:SetPos(16, y + 16)
  self.background.avatar:SetSize(48, 48)

  self.background.name:SetPos(16 + self.background.avatar:GetWide() + 8, y + 16 + 2)
  self.background.name:SizeToContents()

  self.background.sid64:SetPos(14 + self.background.avatar:GetWide() + 8, y + 16 + 24 + 2)
  self.background.sid64:SizeToContentsY()
  self.background.sid64:SetWide(155)

  y = y + self.background.avatar:GetTall() + 40

  self.background.display:SetSize(64, 64)
  self.background.display:SetPos(16, y)

  self.background.string:SetPos(8 + 64 + 16, y)
  self.background.string:SetWide(self.background:GetWide() - 16 - 64)
  self.background.string:SizeToContentsY()

  self.background.accept:SizeToContentsY(16)
  self.background.decline:SizeToContentsY(16)
  self.background.accept:SetWide(self.background:GetWide() / 2 - 16 - 8)
  self.background.decline:SetWide(self.background:GetWide() / 2 - 16 - 8)

  local y = self.background:GetTall() - self.background.accept:GetTall() - 16

  self.background.accept:SetPos(16, y)
  self.background.decline:SetPos(self.background:GetWide() / 2 + 8, y)
end

vgui.Register("XeninUI.PurchaseConfirmation", PANEL, "XeninUI.Popup")

--PATH lua/xeninui/elements/scrollpanel.lua:
local PANEL = {}

function PANEL:Init()
  self.VBar:SetWide(12)
  self.VBar:SetHideButtons(true)

  self.VBar.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Navbar, 150))
  end
  self.VBar.btnGrip.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, XeninUI.Theme.Primary)
  end
end

function PANEL:HideScrollBar(hide)
  self.VBar:SetWide((hide and 0) or 12)
end

vgui.Register("XeninUI.ScrollPanel", PANEL, "DScrollPanel")

--PATH lua/xeninui/elements/wyvern_scrollbar.lua:
local PANEL = {}

AccessorFunc(PANEL, "m_bVisibleFullHeight", "VisibleFullHeight", FORCE_BOOL)

function PANEL:Init()
    self.Offset = 0
    self.Scroll = 0
    self.CanvasSize = 1
    self.BarSize = 1

    self.scrollbar = vgui.Create("DScrollBarGrip", self)
    self.scrollbar.Paint = function(pnl, w, h)
        surface.SetDrawColor(255, 255, 255, 20)
        surface.DrawRect(0, 0, w, h)
    end

    self:SetSize(4, 4)

    self.scrollDelta = delta

    self:SetVisibleFullHeight(false)
end

function PANEL:SetEnabled(b)
    if not b then
        self.Offset = 0
        self:SetScroll(0)
        self.HasChanged = true
    end

    self:SetMouseInputEnabled(b)

    if not self:GetVisibleFullHeight() then
        self:SetVisible(b)
    end

    if self.Enabled ~= b then
        self:GetParent():InvalidateLayout()

        if self:GetParent().OnScrollbarAppear then
            self:GetParent():OnScrollbarAppear()
        end
    end

    self.Enabled = b
end

function PANEL:GetEnabled()
    return self.Enabled
end

function PANEL:Value()
    return self.Pos
end

function PANEL:BarScale()
    if self.BarSize == 0 then return 1 end

    return self.BarSize / (self.CanvasSize + self.BarSize)
end

function PANEL:SetUp(_barSize_, _canvasSize_)
    self.BarSize = _barSize_
    self.CanvasSize = math.max(_canvasSize_ - _barSize_, 1)

    self:SetEnabled(_canvasSize_ > _barSize_)

    self:InvalidateLayout()
end

function PANEL:OnMouseWheeled(dlta)
    if not self:IsVisible() then return false end

    return self:AddScroll(dlta * -2)
end

function PANEL:AddScroll(dlta)
    local oldScroll = self:GetScroll()

    dlta = dlta * 25
    self:SetScroll(oldScroll + dlta)

    return oldScroll ~= self:GetScroll()
end

function PANEL:SetScroll(scrll)
    if not self.Enabled then self.Scroll = 0 return end

    self.Scroll = math.Clamp(scrll, 0, self.CanvasSize + 75)
    self:InvalidateLayout()

    local func = self:GetParent().OnVScroll
    if func then
        func(self:GetParent(), self:GetOffset())
    else
        self:GetParent():InvalidateLayout()
    end
end

function PANEL:LimitScroll()
    if self.Scroll < 0 or self.Scroll > self.CanvasSize then
        self.Scroll = math.Clamp(self.Scroll, -75, self.CanvasSize + 75)
    end
end

function PANEL:AnimateTo(scrll, length, delay, ease)
    local anim = self:NewAnimation(length, delay, ease)
    anim.StartPos = self.Scroll
    anim.TargetPos = scrll
    anim.Think = function(anim, pnl, fraction)
        pnl:SetScroll(Lerp(fraction, anim.StartPos, anim.TargetPos))
    end
end

function PANEL:GetScroll()
    if not self.Enabled then self.Scroll = 0 end
    return self.Scroll
end

function PANEL:GetOffset()
    if not self.Enabled then return 0 end
    return self.Scroll * -1
end

function PANEL:Think() end

function PANEL:OnMousePressed()
    local x, y = self:CursorPos()

    local pageSize = self.BarSize

    if y > self.scrollbar.y then
        self:SetScroll(self:GetScroll() + pageSize)
    else
        self:SetScroll(self:GetScroll() - pageSize)
    end
end

function PANEL:OnMouseReleased()
    self.Dragging = false
    self.DraggingCanvas = nil
    self:MouseCapture(false)

    self.scrollbar.Depressed = false
end

function PANEL:OnCursorMoved(x, y)
    if not self.Enabled or not self.Dragging then return end

    local x = 0
    local y = gui.MouseY()
    local x, y = self:ScreenToLocal(x, y)

    y = y - self.HoldPos

    local trackSize = self:GetTall() - self.scrollbar:GetTall()
    y = y / trackSize

    self:SetScroll(math.Clamp(y * self.CanvasSize, 0, self.CanvasSize))
end

function PANEL:Grip()
    if not self.Enabled or self.BarSize == 0 then return end

    self:MouseCapture(true)
    self.Dragging = true

    local x, y = 0, gui.MouseY()
    local x, y = self.scrollbar:ScreenToLocal(x, y)
    self.HoldPos = y

    self.scrollbar.Depressed = true
end

function PANEL:PerformLayout(w, h)
    self:LimitScroll()

    local scroll = self:GetScroll() / self.CanvasSize
    local barSize = math.max(self:BarScale() * self:GetTall(), 10)
    local track = self:GetTall() - barSize
    track = track + 1

    scroll = scroll * track

    local barStart = math.max(scroll, 0)
    local barEnd = math.min(scroll + barSize, self:GetTall())

    self.scrollbar:SetPos(0, barStart)
    self.scrollbar:SetSize(w, barEnd - barStart)
end


function PANEL:Paint(w, h) end

vgui.Register("XeninUI.Scrollbar.Wyvern", PANEL, "Panel")

--PATH lua/xeninui/elements/wyvern_scrollpanel.lua:
local PANEL = {}

AccessorFunc(PANEL, "Padding", "Padding")
AccessorFunc(PANEL, "pnlCanvas", "Canvas")
AccessorFunc(PANEL, "m_scrollbarLeftSide", "ScrollbarLeftSide")
AccessorFunc(PANEL, "m_bBarDockOffset", "BarDockShouldOffset", FORCE_BOOL)

function PANEL:Init()
    self.pnlCanvas = vgui.Create("Panel", self)
    self.pnlCanvas.OnMousePressed = function(self, code)
        self:GetParent():OnMousePressed(code)end
    self.pnlCanvas:SetMouseInputEnabled(true)
    self.pnlCanvas.PerformLayout = function(pnl)
        self:PerformLayout()
        self:InvalidateParent()
    end

    self.VBar = vgui.Create("XeninUI.Scrollbar.Wyvern", self)
    self.VBar:Dock(RIGHT)

    self:SetPadding(0)
    self:SetMouseInputEnabled(true)


    self:SetPaintBackgroundEnabled(false)
    self:SetPaintBorderEnabled(false)

    self.scrollDelta = 0
    self.scrollReturnWait = 0

    self:SetBarDockShouldOffset(true)


    self:SetBarDockShouldOffset(false)
    self.VBar:SetWide(8)
    self.VBar.Paint = function(pnl, w, h)
        draw.RoundedBox(w / 2, 0, 0, w, h, XeninUI.Theme.Navbar)
    end
    self.VBar.scrollbar.barAlpha = 0
    self.VBar.scrollbar.Paint = function(pnl, w, h)
        if self.VBar:GetEnabled() then
            pnl.barAlpha = pnl.barAlpha + (1 - pnl.barAlpha) * 10 * FrameTime()
        else
            pnl.barAlpha = pnl.barAlpha + (0 - pnl.barAlpha) * 10 * FrameTime()
        end

        draw.RoundedBox(w / 2, 0, 0, w, h, Color(75, 75, 75, 255 * pnl.barAlpha))
    end
    self.VBar:SetVisibleFullHeight(true)
end

function PANEL:AddItem(pnl)
    pnl:SetParent(self:GetCanvas())
end

function PANEL:OnChildAdded(child)
    self:AddItem(child)
end

function PANEL:SizeToContents()
    self:SetSize(self.pnlCanvas:GetSize())
end

function PANEL:GetVBar()
    return self.VBar
end

function PANEL:GetCanvas()
    return self.pnlCanvas
end

function PANEL:InnerWidth()
    return self:GetCanvas():GetWide()
end

AccessorFunc(PANEL, "m_scrollbarLeftSide", "ScrollbarLeftSide")

function PANEL:Rebuild()
    self:GetCanvas():SizeToChildren(false, true)

    if self.m_bNoSizing and self:GetCanvas():GetTall() < self:GetTall() then
        self:GetCanvas():SetPos(0, (self:GetTall() - self:GetCanvas():GetTall()) * 0.5)
    end
end

function PANEL:Think()
    if not self.lastThink then self.lastThink = CurTime()end
    local elapsed = CurTime() - self.lastThink
    self.lastThink = CurTime()

    if self.scrollDelta > 0 then
        self.VBar:OnMouseWheeled(self.scrollDelta / 1)

        if self.VBar.Scroll >= 0 then
            self.scrollDelta = self.scrollDelta - 10 * elapsed
        end
        if self.scrollDelta < 0 then self.scrollDelta = 0 end
    elseif self.scrollDelta < 0 then
        self.VBar:OnMouseWheeled(self.scrollDelta / 1)

        if self.VBar.Scroll <= self.VBar.CanvasSize then
            self.scrollDelta = self.scrollDelta + 10 * elapsed
        end
        if self.scrollDelta > 0 then self.scrollDelta = 0 end
    end

    if self.scrollReturnWait >= 1 then
        if self.VBar.Scroll < 0 then
            if self.VBar.Scroll <= -75 and self.scrollDelta > 0 then self.scrollDelta = self.scrollDelta / 2 end

            self.scrollDelta = self.scrollDelta + (self.VBar.Scroll / 1500 - 0.01) * 100 * elapsed

        elseif self.VBar.Scroll > self.VBar.CanvasSize then
            if self.VBar.Scroll >= self.VBar.CanvasSize + 75 and self.scrollDelta < 0 then self.scrollDelta = self.scrollDelta / 2 end

            self.scrollDelta = self.scrollDelta + ((self.VBar.Scroll - self.VBar.CanvasSize) / 1500 + 0.01) * 100 * elapsed
        end
    else
        self.scrollReturnWait = self.scrollReturnWait + 10 * elapsed
    end
end

function PANEL:OnMouseWheeled(delta)
    if (delta > 0 and self.VBar.Scroll <= self.VBar.CanvasSize * 0.005) or (delta < 0 and self.VBar.Scroll >= self.VBar.CanvasSize * 0.995) then
        self.scrollDelta = self.scrollDelta + delta / 10
        return
    end

    self.scrollDelta = delta / 2
    self.scrollReturnWait = 0

end

function PANEL:OnVScroll(iOffset)
    self.pnlCanvas:SetPos(0, iOffset)
end

function PANEL:ScrollToChild(panel)
    self:PerformLayout()

    local x, y = self.pnlCanvas:GetChildPosition(panel)
    local w, h = panel:GetSize()




    self.VBar:AnimateTo(y, 0.5, 0, 0.5)
end


function PANEL:PerformLayout()
    if self:GetScrollbarLeftSide() then
        self.VBar:Dock(LEFT)
    else
        self.VBar:Dock(RIGHT)
    end

    local wide = self:GetWide()
    local xPos = 0
    local yPos = 0

    self:Rebuild()

    self.VBar:SetUp(self:GetTall(), self.pnlCanvas:GetTall())
    yPos = self.VBar:GetOffset()

    if self.VBar.Enabled or not self:GetBarDockShouldOffset() then
        wide = wide - self.VBar:GetWide()

        if self:GetScrollbarLeftSide() then
            xPos = self.VBar:GetWide()
        end
    end

    self.pnlCanvas:SetPos(xPos, yPos)
    self.pnlCanvas:SetWide(wide)

    self:Rebuild()
end

function PANEL:Clear()
    return self.pnlCanvas:Clear()
end

function PANEL:Paint(w, h) end

vgui.Register("XeninUI.Scrollpanel.Wyvern", PANEL, "DPanel")

--PATH lua/xeninui/core/ui/main.lua:
return gluapack()()
--PATH lua/xeninui/libs/units/main.lua:
XeninUI.Units = XeninUI.Units || {}

--PATH lua/xeninui/libs/units/classes/assert.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Units.Assert",
    isType = function(self, name, errMsg)
      local valType = type(self.val)
      assert(valType == name, errMsg or "Expected \"" .. tostring(self.val) .. "\"\" type to be \"" .. tostring(name) .. "\", but it is type \"" .. tostring(valType) .. "\"")

      return self
    end,
    isTrue = function(self, errMsg)
      self:isType("boolean")
      assert(self.val == true, errMsg or "Boolean is not true")

      return self
    end,
    isFalse = function(self, errMsg)
      self:isType("boolean")
      assert(!self.val, errMsg or "Boolean is not false")

      return self
    end,
    isNil = function(self, errMsg)
      assert(self.val == nil, errMsg or "Excepted nil, got \"" .. tostring(self.val) .. "\" of type \"" .. tostring(type(self.val)) .. "\"")

      return self
    end,
    isNotNil = function(self, errMsg)
      assert(self.val != nil, errMsg or "Expected not nil, but got nil")

      return self
    end,
    isNull = function(self, errMsg)
      assert(self.val == NULL, errMsg or "Expected NULL, but got \"" .. tostring(type(self.val)) .. "\"")

      return self
    end,
    isNotNull = function(self, errMsg)
      assert(self.val != NULL, errMsg or "Expected not NULL, but got NULL\"")

      return self
    end,
    isPlayer = function(self)
      assert(IsValid(self.val), "Player entity is not valid")
      assert(self.val:IsPlayer(), "This entity is not a player")

      return self
    end,
    shouldEqual = function(self, compare, errMsg)
      assert(self.val == compare, errMsg or "Expected \"" .. tostring(self.val) .. "\" of type \"" .. tostring(type(self.val)) .. "\" to equal \"" .. tostring(compare) .. "\" of type \"" .. tostring(type(compare)) .. "\", it does not")

      return self
    end,
    shouldNotEqual = function(self, compare, errMsg)
      assert(self.val != compare, errMsg or "Expected \"" .. tostring(self.val) .. "\" of type \"" .. tostring(type(self.val)) .. "\" to not equal \"" .. tostring(compare) .. "\" of type \"" .. tostring(type(compare)) .. "\", it does")

      return self
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, val, args)
      self.val = val
      self.args = args
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Units.Assert = _class_0
end

--PATH lua/autorun/zyg_captain_addon.lua:
return gluapack()()
--PATH lua/autorun/zyg_soldier_addon.lua:
return gluapack()()
--PATH lua/autorun/zyg_soldier_addon.lua:
player_manager.AddValidModel( "Zygerrian Empire Soldier", "models/player/zygerrian/zygerrian_soldier.mdl" );
list.Set( "PlayerOptionsModel",  "Zygerrian Empire Soldier", "models/player/zygerrian/zygerrian_soldier.mdl" );


--PATH addons/[tfres] frest_levels/lua/autorun/client/3d2dlib.lua:
--[[
	
3D2D VGUI Wrapper
Copyright (c) 2015-2017 Alexander Overvoorde, Matt Stevens

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

]]--

local origin = Vector(0, 0, 0)
local angle = Angle(0, 0, 0)
local normal = Vector(0, 0, 0)
local scale = 0
local maxrange = 0

-- Helper functions

local function getCursorPos()
	local p = util.IntersectRayWithPlane(LocalPlayer():EyePos(), LocalPlayer():GetAimVector(), origin, normal)

	-- if there wasn't an intersection, don't calculate anything.
	if not p then return end
	if WorldToLocal(LocalPlayer():GetShootPos(), Angle(0,0,0), origin, angle).z < 0 then return end

	if maxrange > 0 then
		if p:Distance(LocalPlayer():EyePos()) > maxrange then
			return
		end
	end

	local pos = WorldToLocal(p, Angle(0,0,0), origin, angle)

	return pos.x, -pos.y
end

local function getParents(pnl)
	local parents = {}
	local parent = pnl:GetParent()
	while parent do
		table.insert(parents, parent)
		parent = parent:GetParent()
	end
	return parents
end

local function absolutePanelPos(pnl)
	local x, y = pnl:GetPos()
	local parents = getParents(pnl)
	
	for _, parent in ipairs(parents) do
		local px, py = parent:GetPos()
		x = x + px
		y = y + py
	end
	
	return x, y
end

local function pointInsidePanel(pnl, x, y)
	local px, py = absolutePanelPos(pnl)
	local sx, sy = pnl:GetSize()

	if not x or not y then return end

	x = x / scale
	y = y / scale

	return pnl:IsVisible() and x >= px and y >= py and x <= px + sx and y <= py + sy
end

-- Input

local inputWindows = {}
local usedpanel = {}

local function isMouseOver(pnl)
	return pointInsidePanel(pnl, getCursorPos())
end

local function postPanelEvent(pnl, event, ...)
	if not IsValid(pnl) or not pnl:IsVisible() or not pointInsidePanel(pnl, getCursorPos()) then return false end

	local handled = false
	
	for i, child in pairs(table.Reverse(pnl:GetChildren())) do
		if not child:IsMouseInputEnabled() then continue end
		
		if postPanelEvent(child, event, ...) then
			handled = true
			break
		end
	end
	
	if not handled and pnl[event] then
		pnl[event](pnl, ...)
		usedpanel[pnl] = {...}
		return true
	else
		return false
	end
end

-- Always have issue, but less
local function checkHover(pnl, x, y, found)
	if not (x and y) then
		x, y = getCursorPos()
	end

	local validchild = false
	for c, child in pairs(table.Reverse(pnl:GetChildren())) do
		if not child:IsMouseInputEnabled() then continue end
		
		local check = checkHover(child, x, y, found or validchild)

		if check then
			validchild = true
		end
	end

	if found then
		if pnl.Hovered then
			pnl.Hovered = false
			if pnl.OnCursorExited then pnl:OnCursorExited() end
		end
	else
		if not validchild and pointInsidePanel(pnl, x, y) then
			pnl.Hovered = true
			if pnl.OnCursorEntered then pnl:OnCursorEntered() end

			return true
		else
			pnl.Hovered = false
			if pnl.OnCursorExited then pnl:OnCursorExited() end
		end
	end

	return false
end

-- Mouse input

hook.Add("KeyPress", "VGUI3D2DMousePress", function(_, key)
	if key == IN_USE then
		for pnl in pairs(inputWindows) do
			if IsValid(pnl) then
				origin = pnl.Origin
				scale = pnl.Scale
				angle = pnl.Angle
				normal = pnl.Normal

				local key = input.IsKeyDown(KEY_LSHIFT) and MOUSE_RIGHT or MOUSE_LEFT
				
				postPanelEvent(pnl, "OnMousePressed", key)
			end
		end
	end
end)

hook.Add("KeyRelease", "VGUI3D2DMouseRelease", function(_, key)
	if key == IN_USE then
		for pnl, key in pairs(usedpanel) do
			if IsValid(pnl) then
				origin = pnl.Origin
				scale = pnl.Scale
				angle = pnl.Angle
				normal = pnl.Normal

				if pnl["OnMouseReleased"] then
					pnl["OnMouseReleased"](pnl, key[1])
				end

				usedpanel[pnl] = nil
			end
		end
	end
end)

function vgui.Start3D2D(pos, ang, res)
	origin = pos
	scale = res
	angle = ang
	normal = ang:Up()
	maxrange = 0
	
	cam.Start3D2D(pos, ang, res)
end

function vgui.MaxRange3D2D(range)
	maxrange = isnumber(range) and range or 0
end

function vgui.IsPointingPanel(pnl)
	origin = pnl.Origin
	scale = pnl.Scale
	angle = pnl.Angle
	normal = pnl.Normal

	return pointInsidePanel(pnl, getCursorPos())
end

local Panel = FindMetaTable("Panel")
function Panel:Paint3D2D()
	if not self:IsValid() then return end
	
	-- Add it to the list of windows to receive input
	inputWindows[self] = true

	-- Override gui.MouseX and gui.MouseY for certain stuff
	local oldMouseX = gui.MouseX
	local oldMouseY = gui.MouseY
	local cx, cy = getCursorPos()

	function gui.MouseX()
		return (cx or 0) / scale
	end
	function gui.MouseY()
		return (cy or 0) / scale
	end
	
	-- Override think of DFrame's to correct the mouse pos by changing the active orientation
	if self.Think then
		if not self.OThink then
			self.OThink = self.Think
			
			self.Think = function()
				origin = self.Origin
				scale = self.Scale
				angle = self.Angle
				normal = self.Normal
				
				self:OThink()
			end
		end
	end
	
	-- Update the hover state of controls
	local _, tab = checkHover(self)
	
	-- Store the orientation of the window to calculate the position outside the render loop
	self.Origin = origin
	self.Scale = scale
	self.Angle = angle
	self.Normal = normal
	
	-- Draw it manually
	self:SetPaintedManually(false)
		self:PaintManual()
	self:SetPaintedManually(true)

	gui.MouseX = oldMouseX
	gui.MouseY = oldMouseY
end

function vgui.End3D2D()
	cam.End3D2D()
end
--PATH lua/autorun/client/cl_vmanip.lua:
--[[
More detail on stuff in lua/vmanip/vmanip_baseanims.lua

Please keep in mind that you do not fire events *through vmanip*. Think of it as a fully
clientside animation system. So instead, you request to play an anim, and if the request
went through (true return value), you do your thing

You probably don't need to snoop around this file, but feel free
]]

VManip={}
VMLegs={}
local curtime=0

local function LerpC(t,a,b,powa) --Non linear lerping

return a + (b - a) * math.pow(t,powa)

end

local properang = Angle(-79.750,0,-90)
local leftarmbones={"ValveBiped.Bip01_L_UpperArm",
"ValveBiped.Bip01_L_Forearm",
"ValveBiped.Bip01_L_Hand",
"ValveBiped.Bip01_L_Wrist",
"ValveBiped.Bip01_L_Ulna",
"ValveBiped.Bip01_L_Finger4",
"ValveBiped.Bip01_L_Finger41",
"ValveBiped.Bip01_L_Finger42",
"ValveBiped.Bip01_L_Finger3",
"ValveBiped.Bip01_L_Finger31",
"ValveBiped.Bip01_L_Finger32",
"ValveBiped.Bip01_L_Finger2",
"ValveBiped.Bip01_L_Finger21",
"ValveBiped.Bip01_L_Finger22",
"ValveBiped.Bip01_L_Finger1",
"ValveBiped.Bip01_L_Finger11",
"ValveBiped.Bip01_L_Finger12",
"ValveBiped.Bip01_L_Finger0",
"ValveBiped.Bip01_L_Finger01",
"ValveBiped.Bip01_L_Finger02"}

local playermodelbonesupper={"ValveBiped.Bip01_L_Forearm",
"ValveBiped.Bip01_L_UpperArm",
"ValveBiped.Bip01_L_Clavicle",
"ValveBiped.Bip01_L_Hand",
"ValveBiped.Bip01_Spine4",
"ValveBiped.Bip01_Neck1",
"ValveBiped.Bip01_Head1",
"ValveBiped.Bip01_L_Finger4",
"ValveBiped.Bip01_L_Finger41",
"ValveBiped.Bip01_L_Finger42",
"ValveBiped.Bip01_L_Finger3",
"ValveBiped.Bip01_L_Finger31",
"ValveBiped.Bip01_L_Finger32",
"ValveBiped.Bip01_L_Finger2",
"ValveBiped.Bip01_L_Finger21",
"ValveBiped.Bip01_L_Finger22",
"ValveBiped.Bip01_L_Finger1",
"ValveBiped.Bip01_L_Finger11",
"ValveBiped.Bip01_L_Finger12",
"ValveBiped.Bip01_L_Finger0",
"ValveBiped.Bip01_L_Finger01",
"ValveBiped.Bip01_L_Finger02",
"ValveBiped.Bip01_R_Forearm",
"ValveBiped.Bip01_R_UpperArm",
"ValveBiped.Bip01_R_Clavicle",
"ValveBiped.Bip01_R_Hand",
"ValveBiped.Bip01_R_Finger4",
"ValveBiped.Bip01_R_Finger41",
"ValveBiped.Bip01_R_Finger42",
"ValveBiped.Bip01_R_Finger3",
"ValveBiped.Bip01_R_Finger31",
"ValveBiped.Bip01_R_Finger32",
"ValveBiped.Bip01_R_Finger2",
"ValveBiped.Bip01_R_Finger21",
"ValveBiped.Bip01_R_Finger22",
"ValveBiped.Bip01_R_Finger1",
"ValveBiped.Bip01_R_Finger11",
"ValveBiped.Bip01_R_Finger12",
"ValveBiped.Bip01_R_Finger0",
"ValveBiped.Bip01_R_Finger01"}

local tableintensity={1,1,1}
VManip.Reset = function()
	VManip.Anims={}
	VManip.VMGesture=nil
	VManip.AssurePos=false
	VManip.LockToPly=false
	VManip.LockZ=0
	VManip.VMCam=nil
	VManip.Cam_Ang=properang
	VManip.Cam_AngInt=nil
	VManip.StartCycle=0
	VManip.Cycle=0
	VManip.CurGesture=nil
	VManip.CurGestureData=nil
	VManip.GestureMatrix=nil
	VManip.Lerp_Peak=nil
	VManip.Lerp_Speed_In=nil
	VManip.Lerp_Speed_Out=nil
	VManip.Lerp_Curve=nil
	VManip.Duration=0
	VManip.HoldTime=nil
	VManip.HoldQuit=false
	VManip.PreventQuit=false
	VManip.QueuedAnim=nil
	VManip.Segmented=false
	VManip.SegmentFinished=false
	VManip.CurSegment=nil
	VManip.LastSegment=false
	VManip.SegmentCount=0
	VManip.CurSegmentSequence=nil
	VManip.GesturePastHold=false
	VManip.GestureOnHold=false
	VManip.Attachment=nil
end
VManip.Remove = function()
	if VManip:IsActive() then hook.Run("VManipPreRemove",VManip:GetCurrentAnim()) end
	if IsValid(VManip.VMGesture) then VManip.VMGesture:Remove() end
	if IsValid(VManip.VMCam) then VManip.VMCam:Remove() end
	VManip.VMGesture=nil
	VManip.AssurePos=false
	VManip.LockToPly=false
	VManip.LockZ=0
	VManip.VMCam=nil
	VManip.Cam_Ang=properang
	VManip.Cam_AngInt=nil
	VManip.Cycle=0
	VManip.StartCycle=0
	VManip.Attachment=nil
	VManip.CurGesture=nil
	VManip.CurGestureData=nil
	VManip.GestureMatrix=nil
	VManip.Lerp_Peak=nil
	VManip.Lerp_Speed_In=nil
	VManip.Lerp_Speed_Out=nil
	VManip.Duration=0
	VManip.HoldTime=nil
	VManip.HoldQuit=false
	VManip.PreventQuit=false
	VManip.QueuedAnim=nil
	VManip.Segmented=false
	VManip.SegmentFinished=false
	VManip.CurSegment=nil
	VManip.LastSegment=false
	VManip.SegmentCount=0
	VManip.CurSegmentSequence=nil
	VManip.GesturePastHold=false
	VManip.GestureOnHold=false
	hook.Run("VManipRemove")
end
VManip:Reset()

VManip.RegisterAnim = function(self,name,tbl) self.Anims[name]=tbl end
VManip.GetAnim = function(self,name) return self.Anims[name] end
VManip.IsActive = function(self) return IsValid(self.VMGesture) end
VManip.GetVMGesture = function(self) return self.VMGesture end
VManip.GetCurrentAnim = function(self) return self.CurGesture end
VManip.GetCurrentSegment = function(self) return self.CurSegment end
VManip.GetCycle = function(self) return self.Cycle end
VManip.SetCycle = function(self,newcycle) self.Cycle=newcycle end
VManip.IsSegmented = function(self) return self.Segmented end
VManip.GetSegmentCount = function(self) return self.SegmentCount end
	local function PlayVMPSound(ent,sound,anim)
		if VManip:GetCurrentAnim()==anim and ent:Alive() then
			ent:EmitSound(sound)
		end
	end
	local function PlaySoundsInTable(tbl,animname)
	
		local ply=LocalPlayer()
		for k,v in pairs(tbl) do
			timer.Simple(v, function() PlayVMPSound(ply,k,animname) end)
		end
	
	end
VManip.PlaySegment = function(self,sequence,lastsegment,soundtable)
	if self:IsActive() and self:IsSegmented() and self.SegmentFinished and !self.LastSegment then
		if self:GetVMGesture():LookupSequence(sequence)!=-1 then
			if hook.Run("VManipPrePlaySegment",self:GetCurrentAnim(),sequence,lastsegment)==false then return end
			self:GetVMGesture():ResetSequence(sequence)
			VManip.CurSegment=sequence
			self:SetCycle(0)
			VManip.SegmentFinished=false
			self.SegmentCount=self.SegmentCount+1
			if lastsegment then self.LastSegment=true VManip.Lerp_Peak = curtime + VManip.CurGestureData["lerp_peak"] end
			if soundtable then PlaySoundsInTable(soundtable,self:GetCurrentAnim()) end
			hook.Run("VManipPlaySegment",self:GetCurrentAnim(),sequence,lastsegment)
			return true
		end
	end
	return false
end
VManip.IsPreventQuit = function(self) return self.PreventQuit end
VManip.QuitHolding = function(self,animtostop)
	if self:IsActive() then
		if hook.Run("VManipPreHoldQuit",self:GetCurrentAnim(),animtostop)==false then return end
		if (!animtostop and !VManip:IsPreventQuit()) or self:GetCurrentAnim()==animtostop then
			self.HoldQuit=true
			if self:IsSegmented() then self.LastSegment=true end
			hook.Run("VManipHoldQuit",self:GetCurrentAnim(),animtostop)
		end
		if self.QueuedAnim==animtostop then
			self.QueuedAnim=nil
		end
	end
end
VManip.QueueAnim = function(self,animtoqueue) if self:GetAnim(animtoqueue) then self.QueuedAnim=animtoqueue end end --For event related animations that you want to make sure will play no matter what


VMLegs.Reset = function()

	VMLegs.Anims={}
	VMLegs.LegParent=nil
	VMLegs.LegModel=nil
	VMLegs.Cycle=0
	VMLegs.StartCycle=0
	VMLegs.SeqID=nil
	VMLegs.CurLegs=nil

end
VMLegs.Remove = function()

	if IsValid(VMLegs.LegParent) then VMLegs.LegParent:Remove() end
	if IsValid(VMLegs.LegModel) then VMLegs.LegModel:Remove() end
	
	VMLegs.LegParent=nil
	VMLegs.LegModel=nil
	VMLegs.Cycle=0
	VMLegs.StartCycle=0
	VMLegs.SeqID=nil
	VMLegs.CurLegs=nil

end
VMLegs:Reset()

VMLegs.RegisterAnim = function(self,name,tbl) self.Anims[name]=tbl end
VMLegs.GetAnim = function(self,name) return self.Anims[name] end
VMLegs.IsActive = function(self) return IsValid(self.LegParent) end
VMLegs.GetCurrentAnim = function(self) return self.CurLegs end

VManip.PlayAnim = function(self,name)

local ply=LocalPlayer()
if ply:GetViewEntity() != ply and !self:IsActive() then return end
if IsValid(ply:GetActiveWeapon()) then if ply:GetActiveWeapon():GetHoldType()=="duel" then return false end --doesnt always work
else return false end
if ply:InVehicle() or !ply:Alive() then return false end
if self:IsActive() then return false end

local vm=ply:GetViewModel()

local bypass=hook.Run("VManipPreActCheck",name,vm)
if !bypass then
	if type(ply:GetActiveWeapon().GetStatus) == "function" then if ply:GetActiveWeapon():GetStatus() == 5 then return false end end
	if vm:GetSequenceActivity(vm:GetSequence())==ACT_VM_RELOAD then return false end
end

local animtoplay=self:GetAnim(name)
if !animtoplay then print("Invalid anim",name) return false end

if hook.Run("VManipPrePlayAnim",name)==false then return false end

curtime=CurTime()

self.Remove()
self.GesturePastHold = false
self.GestureOnHold = false
self.CurGestureData = animtoplay
self.CurGesture = name
self.Lerp_Peak = curtime + animtoplay["lerp_peak"]
vmatrixpeakinfo = animtoplay["lerp_peak"]
self.Lerp_Speed_In = animtoplay["lerp_speed_in"] or 1
self.Lerp_Speed_Out = animtoplay["lerp_speed_out"] or 1
self.Loop = animtoplay["loop"]
VManip_modelname = animtoplay["model"]
vmanipholdtime = animtoplay["holdtime"]

self.VMGesture = ClientsideModel( "models/"..VManip_modelname, RENDERGROUP_BOTH )
self.VMCam = ClientsideModel( "models/"..VManip_modelname, RENDERGROUP_BOTH ) --Saves me the headache of attachment shit

self.Cam_AngInt=animtoplay["cam_angint"] or tableintensity

self.SeqID = self.VMGesture:LookupSequence(name)
if animtoplay["assurepos"] then
	self.VMGesture:SetPos( ply:EyePos() )
	VManip.AssurePos=true
elseif !animtoplay["locktoply"] then
	self.VMGesture:SetPos( vm:GetPos() )
end

if animtoplay["locktoply"] then
	self.LockToPly=true
	local eyepos=ply:EyePos()
	self.VMGesture:SetAngles( ply:EyeAngles() )
	self.VMGesture:SetPos( eyepos )
	self.LockZ=eyepos.z
else
	self.VMGesture:SetAngles( vm:GetAngles() )
	self.VMGesture:SetParent(vm)
end

self.Cam_Ang=animtoplay["cam_ang"] or properang
self.VMCam:SetPos(vector_origin)
self.VMCam:SetAngles( angle_zero )

self.VMGesture:ResetSequenceInfo()
self.VMGesture:SetPlaybackRate( 1 )
self.VMGesture:ResetSequence(self.SeqID)

self.VMCam:ResetSequenceInfo()
self.VMCam:SetPlaybackRate( 1 )
self.VMCam:ResetSequence(self.SeqID)

self.VMatrixlerp=1
self.Speed=animtoplay["speed"] or 1

self.Lerp_Curve=animtoplay["lerp_curve"] or 1
self.StartCycle=animtoplay["startcycle"] or 0
self.Segmented=animtoplay["segmented"] or false
self.HoldTime=animtoplay["holdtime"] or nil
self.HoldTimeData=self.HoldTime
self.PreventQuit=animtoplay["preventquit"] or false
if self.HoldTime then self.HoldTime=curtime+self.HoldTime end
self.Cycle=self.StartCycle
self.VMGesture:SetNoDraw(true)
self.VMCam:SetNoDraw(true)
self.Duration=self.VMGesture:SequenceDuration(self.SeqID)
if animtoplay["sounds"] and animtoplay["sounds"]!={} then
	PlaySoundsInTable(animtoplay["sounds"],self.CurGesture)
end

hook.Run("VManipPostPlayAnim",name)
return true

end



VMLegs.PlayAnim = function(self,name)

if self:IsActive() then return false end
local animtoplay=self:GetAnim(name)
if !animtoplay then print("Invalid anim",name) return false end

local ply=LocalPlayer()
if LocalPlayer():ShouldDrawLocalPlayer() then return end
self.Cycle=0
self.CurLegs=name
self.Speed=animtoplay["speed"]
self.FBoost=animtoplay["forwardboost"]
self.UBoost=animtoplay["upwardboost"]
self.UBoostCache=Vector(0,0,self.UBoost)
local model=animtoplay["model"]
local vm=ply:GetViewModel()
local vmang=vm:GetAngles()
local vmpos=vm:GetPos()

self.LegParent = ClientsideModel( "models/"..model, RENDERGROUP_BOTH )
self.LegParent:SetPos( vmpos )
self.LegParent:SetParent( vm )
local legang=vm:GetAngles()
legang=Angle(0,legang.y,0)
VMLegs.LegParent:SetAngles(legang)

self.LegModel = ClientsideModel( string.Replace(ply:GetModel(),"models/models/","models/"), RENDERGROUP_TRANSLUCENT )
self.LegModel:SetPos( vmpos )
self.LegModel:SetAngles( vmang )

local plyhands=ply:GetHands()
if IsValid(plyhands) then
	self.LegModel.GetPlayerColor=plyhands.GetPlayerColor --yes, this is how you do player color. Fucking lol
end

self.LegModel:SetParent( self.LegParent )
self.LegModel:AddEffects(EF_BONEMERGE)
for i = 0, self.LegModel:GetNumBodyGroups() do
  local bodyg = ply:GetBodygroup(i)
  self.LegModel:SetBodygroup(i,bodyg)
end

for k,v in pairs(playermodelbonesupper) do
local plybone = self.LegModel:LookupBone(v)
if plybone!=nil then
self.LegModel:ManipulateBoneScale( plybone, Vector(0,0,0) )
end
end

self.SeqID = self.LegParent:LookupSequence(name)
self.LegParent:ResetSequenceInfo()
self.LegParent:SetPlaybackRate( 1 )
self.LegParent:ResetSequence(self.SeqID)

end

--#########################--


local posparentcache
local curtimecheck=0 --prevents the hook from ever running twice in the same frame
local scalevec = Vector(1,1,1)
hook.Add("PostDrawViewModel", "VManip", function(vm,ply,weapon)

if VManip:IsActive() then
curtime=CurTime()
if (curtime==curtimecheck and !gui.IsGameUIVisible()) then return end
curtimecheck=CurTime()

local vment = hook.Run("VManipVMEntity",ply,weapon)
if IsValid(vment) then
	vm = vment
end

if VManip.AssurePos then --Some SWEPs have RIDICULOUS offsets
	if posparentcache!=weapon then
		posparentcache=weapon
		VManip.VMGesture:SetParent(nil)
		VManip.VMGesture:SetPos( EyePos() )
		VManip.VMGesture:SetAngles( vm:GetAngles() )
		VManip.VMGesture:SetParent(vm)
	end
end


if VManip.LockToPly then --A more cruel version of AssurePos
	local eyeang=ply:EyeAngles()
	local eyepos=EyePos()
	local vmang=vm:GetAngles()
	local finang=(eyeang-vmang)
	finang.y=0 --fucks up on 180
	local newang=eyeang+(finang*0.25)
	VManip.VMGesture:SetAngles( newang )
	VManip.VMGesture:SetPos(eyepos)
end

if !ply:Alive() then VManip:Remove() return end --fun fact, this only runs on respawn for an obvious reason
--VManip.VMGesture:FrameAdvance(FrameTime()*VManip.Speed) --shit the bed, don't use this


if VManip.Loop then
	if VManip.Cycle>=1 then VManip.Lerp_Peak = curtime + VManip.CurGestureData["lerp_peak"] VManip.Cycle=0 end
	if VManip.HoldQuit then VManip.Loop=false end
end

if !VManip.GestureOnHold then VManip.Cycle=VManip.Cycle+FrameTime()*VManip.Speed end
VManip.VMGesture:SetCycle(VManip.Cycle)
VManip.VMCam:SetCycle(VManip.Cycle)

if VManip.HoldTime then
if curtime>=VManip.HoldTime and !VManip.GestureOnHold and !VManip.GesturePastHold and !VManip.HoldQuit then
	-- local seqdur=VManip.VMGesture:SequenceDuration()
	-- VManip.Cycle=(VManip.HoldTimeData)/(seqdur) ply:ChatPrint(seqdur)
	-- VManip.VMGesture:SetCycle(VManip.Cycle)
	VManip.GestureOnHold=true
elseif VManip.HoldQuit and VManip.GestureOnHold then
	VManip.GestureOnHold=false
	VManip.GesturePastHold=true
	VManip.Lerp_Peak = curtime + VManip.CurGestureData["lerp_peak"]-VManip.CurGestureData["holdtime"]
end
end


if (curtime < VManip.Lerp_Peak or (VManip:IsSegmented() and !VManip.LastSegment)) and (!VManip.GestureOnHold or VManip.GesturePastHold) then
  VManip.VMatrixlerp = math.Clamp(VManip.VMatrixlerp-(FrameTime()*7)*VManip.Lerp_Speed_In,0,1)
elseif !VManip.Loop and (!VManip.GestureOnHold or VManip.GesturePastHold) then
  if !VManip:IsSegmented() or VManip.LastSegment then
	VManip.VMatrixlerp = math.Clamp(VManip.VMatrixlerp+(FrameTime()*7)*VManip.Lerp_Speed_Out,0,1)
  end
end

local rigpick2 = leftarmbones
local rigpick = leftarmbones

VManip.VMGesture:SetupBones()
VManip.VMGesture:DrawModel()

--[[The actual manipulation part below]]

for k,v in pairs(rigpick) do

if v == "ValveBiped.Bip01_L_Ulna" then
  local lb=VManip.VMGesture:LookupBone("ValveBiped.Bip01_L_Forearm")
  if lb then 
  VManip.GestureMatrix = VManip.VMGesture:GetBoneMatrix(lb)
  end
else
  local lb=VManip.VMGesture:LookupBone(rigpick2[k])
  if lb then
	VManip.GestureMatrix = VManip.VMGesture:GetBoneMatrix(lb)
  end
end

local VMBone = vm:LookupBone(v)
if VMBone !=nil and VManip.GestureMatrix != nil then
  local VMBoneMatrix = vm:GetBoneMatrix(VMBone)
  if VMBoneMatrix then
	local VMBoneMatrixCache = VMBoneMatrix:ToTable()
	local VMGestureMatrixCache = VManip.GestureMatrix:ToTable()
	for k,v in pairs(VMGestureMatrixCache) do
		for l,b in pairs(v) do
		VMGestureMatrixCache[k][l] = LerpC(VManip.VMatrixlerp, b, VMBoneMatrixCache[k][l],VManip.Lerp_Curve)
		end
	end
	local m = Matrix(VMGestureMatrixCache)
	m:SetScale(scalevec)
	if type(ply:GetActiveWeapon().GetStatus) == "function" then if ply:GetActiveWeapon():GetStatus() != 5 then
		vm:SetBoneMatrix(VMBone,m)
	end
	else vm:SetBoneMatrix(VMBone,m) end
  end

end
end

if VManip.Cycle>=1 and !VManip.Loop then
	if VManip:IsSegmented() and !VManip.SegmentFinished then
		VManip.SegmentFinished=true
		hook.Run("VManipSegmentFinish",VManip:GetCurrentAnim(),VManip:GetCurrentSegment(),VManip.LastSegment,VManip:GetSegmentCount())
	elseif VManip:IsSegmented() and VManip.LastSegment then
		if VManip.VMatrixlerp>=1 then VManip:Remove() end
	elseif !VManip:IsSegmented() then
	if VManip.CurGestureData["loop"] then
		if VManip.VMatrixlerp>=1 then VManip:Remove() end
	else VManip.Remove() return
	end
	end
end

elseif VManip.QueuedAnim then

if VManip:PlayAnim(VManip.QueuedAnim) then VManip.QueuedAnim=nil end

end

end)

local anglef=Angle(0,1,0)
local curtimelegscheck = 0
hook.Add("PostDrawViewModel", "VMLegs", function(vm,ply,weapon) --Very basic stuff, you see

if VMLegs:IsActive() then
	curtime=CurTime()
	if (curtime==curtimelegscheck and !gui.IsGameUIVisible()) then return end
	curtimelegscheck=CurTime()

	local vment = hook.Run("VManipLegsVMEntity",ply,weapon)
	if IsValid(vment) then
		vm = vment
	end

	local legang=vm:GetAngles()
	legang=Angle(0,legang.y,0)
	VMLegs.LegParent:SetAngles(legang)
	VMLegs.LegParent:SetPos(vm:GetPos()+(legang:Forward()*VMLegs.FBoost)+VMLegs.UBoostCache)
	VMLegs.Cycle=VMLegs.Cycle+FrameTime()*VMLegs.Speed
	VMLegs.LegParent:SetCycle(VMLegs.Cycle)
	if VMLegs.Cycle>=1 then VMLegs.Remove() return end

end

end)

concommand.Add("VManip_List",function(ply) PrintTable(VManip.Anims) end)
concommand.Add("VManip_ListSimple",function(ply) for k,v in pairs(VManip.Anims) do print(k," | ",v["model"]) end end)


net.Receive("VManip_SimplePlay",function(len)

local anim=net.ReadString()
VManip:PlayAnim(anim)

end)
--[[Maybe merge these two in one message, using enums]]
net.Receive("VManip_StopHold",function(len)

local anim=net.ReadString()
if anim=="" then VManip:QuitHolding() else VManip:QuitHolding(anim) end

end)

hook.Add("NeedsDepthPass","VManip_RubatPLZ",function() --CalcView attachments need to be retrieved outside of CalcView

--Just gonna slide this in there, yea.
if VManip.QueuedAnim then
local ply=LocalPlayer()
if ply:GetViewEntity()!=ply or ply:ShouldDrawLocalPlayer() then VManip.QueuedAnim=nil end
end
--Good.

if !VManip:IsActive() then return end

if !LocalPlayer():Alive() then VManip:Remove() return end

local allatt=VManip.VMCam:GetAttachments()
if #allatt==0 then return end
local lookup=allatt[1]["id"]
local att=VManip.VMCam:GetAttachment(lookup)
VManip.Attachment=att

end)

local calcang = Angle()
hook.Add("CalcView","VManip_Cam",function(ply,origin,angles,fov,self)

if self == true then return end
if !VManip:IsActive() or !VManip.Attachment then return end
if ply:GetViewEntity()!=ply or ply:ShouldDrawLocalPlayer() then return end
local view={}
local camang=VManip.Attachment.Ang-VManip.Cam_Ang
camang.x = camang.x*VManip.Cam_AngInt[1]
camang.y = camang.y*VManip.Cam_AngInt[2]
camang.z = camang.z*VManip.Cam_AngInt[3]

view.angles = angles

local hookv = hook.Run("CalcView", ply, origin, angles, fov, true)
if hookv.angles then
	hookv.angles:Add(camang)
	view.angles:Set(hookv.angles)
end

view.fov = fov or hookv.fov
view.origin = hookv.origin
return view

end)


hook.Add( "StartCommand", "VManip_PreventReload", function(ply,ucmd) --prevent reload hook
if VManip:IsActive() and !ply:ShouldDrawLocalPlayer() then ucmd:RemoveKey(8192) end
end)
hook.Add("TFA_PreReload", "VManip_PreventTFAReload", function(wepom,keyreleased) --prevent reload on tfa hook
if VManip:IsActive() then return "no" end
end)



--Time to load everythin'
local function VManip_FindAndImport()

local path="vmanip/anims/"
local anims=file.Find(path.."*.lua","lcl")

for k,v in pairs(anims) do
		include(path..v)
end
print("VManip loaded with "..table.Count(VManip.Anims).." animations")

end


hook.Add("InitPostEntity","VManip_ImportAnims",function()

VManip_FindAndImport()
hook.Remove("InitPostEntity","VManip_ImportAnims")
end)

hook.Add("VManipPreActCheck","VManipArcCWFix",function(name,vm) 

local ply=LocalPlayer()
local activewep=ply:GetActiveWeapon()
if activewep.ArcCW then
	if activewep:ShouldDrawCrosshair() or vm:GetCycle()>0.99 then return true end --crossh check is pretty rudimentary
end --vm getcycle is fucked for some reason except on some anims, makes me wonder

end)
hook.Add("VManipPrePlayAnim","VManipArcCWReload",function()

local ply=LocalPlayer()
local activewep=ply:GetActiveWeapon()
if activewep.ArcCW then
	if activewep:GetNWBool("reloading") then return false end
end

end)
hook.Add("VManipPrePlayAnim","VManipMWBaseReload",function()

local ply=LocalPlayer()
local activewep=ply:GetActiveWeapon()
if activewep.GetIsReloading then
	if activewep:GetIsReloading() then return false end
end

end)

hook.Add("VManipVMEntity", "VManipMWBase", function(ply, weapon)
	local vm = weapon.m_ViewModel
	if IsValid(vm) then
		VManip:GetVMGesture():SetPos(vm:GetPos())
		VManip:GetVMGesture():SetAngles(vm:GetAngles())
		return vm
	end
end)

hook.Add("VManipLegsVMEntity", "VManipMWBase", function(ply, weapon)
	local vm = weapon.m_ViewModel
	if IsValid(vm) then
		return vm
	end
end)

concommand.Add("VManip_FindAndImport",VManip_FindAndImport)
RunConsoleCommand("VManip_FindAndImport") --Runs it again if this file is refreshed
--PATH addons/[tfres] datapad/lua/autorun/client/datapad.lua:
list.Set( "DesktopWindows", "datapad", {
	title = "[tfres] Datapad",
	icon = "tfres/datapads/icon.png",
	init = function( icon, window )
        
	end
} )

--PATH lua/autorun/client/jetted.lua:
return gluapack()()
--PATH lua/autorun/client/lvs_vehicle_tab.lua:

hook.Add( "PopulateVehicles", "!!!add_lvs_to_vehicles", function( pnlContent, tree, node )
	local CategoryNameTranslate = {}
	local Categorised = {}
	local SubCategorised = {}

	local SpawnableEntities = table.Copy( list.Get( "SpawnableEntities" ) )
	local Variants = {
		[1] = "[LVS] - ",
		[2] = "[LVS] -",
		[3] = "[LVS]- ",
		[4] = "[LVS]-",
		[5] = "[LVS] ",
	}

	for _, v in pairs( scripted_ents.GetList() ) do
		if not v.t or not v.t.ClassName or not v.t.VehicleCategory then continue end

		if not isstring( v.t.ClassName ) or v.t.ClassName == "" or not SpawnableEntities[ v.t.ClassName ] then continue end

		SpawnableEntities[ v.t.ClassName ].Category = "[LVS] - "..v.t.VehicleCategory

		if not v.t.VehicleSubCategory then continue end

		SpawnableEntities[ v.t.ClassName ].SubCategory = v.t.VehicleSubCategory
	end

	if SpawnableEntities then
		for k, v in pairs( SpawnableEntities ) do

			local Category = v.Category

			if not isstring( Category ) then continue end

			if not Category:StartWith( "[LVS]" ) and not v.LVS then continue end

			v.SpawnName = k

			for _, start in pairs( Variants ) do
				if Category:StartWith( start ) then
					local NewName = string.Replace(Category, start, "")
					CategoryNameTranslate[ NewName ] = Category
					Category = NewName

					break
				end
			end

			if v.SubCategory then
				SubCategorised[ Category ] = SubCategorised[ Category ] or {}
				SubCategorised[ Category ][ v.SubCategory ] = SubCategorised[ Category ][ v.SubCategory ] or {}

				table.insert( SubCategorised[ Category ][ v.SubCategory ], v )
			end

			Categorised[ Category ] = Categorised[ Category ] or {}

			table.insert( Categorised[ Category ], v )
		end
	end

	local lvsNode = tree:AddNode( "[LVS]", "icon16/lvs.png" )

	if Categorised["[LVS]"] then
		local v = Categorised["[LVS]"]

		lvsNode.DoPopulate = function( self )
			if self.PropPanel then return end

			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
					admin		= ent.AdminOnly
				} )
			end
		end

		lvsNode.DoClick = function( self )
			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )
		end
	end

	local IconList = list.Get( "ContentCategoryIcons" )

	for CategoryName, v in SortedPairs( Categorised ) do
		if CategoryName:StartWith( "[LVS]" ) then continue end

		local Icon = "icon16/lvs_noicon.png"

		if IconList and IconList[ CategoryNameTranslate[ CategoryName ] ] then
			Icon = IconList[ CategoryNameTranslate[ CategoryName ] ]
		end

		local node = lvsNode:AddNode( CategoryName, Icon )

		node.DoPopulate = function( self )
			if self.PropPanel then return end

			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				if ent.SubCategory then
					continue
				end

				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
					admin		= ent.AdminOnly
				} )
			end
		end
		node.DoClick = function( self )
			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )
		end

		local SubCat = SubCategorised[ CategoryName ]

		if not SubCat then continue end

		for SubName, data in SortedPairs( SubCat ) do

			local SubIcon = "icon16/lvs_noicon.png"

			if IconList then
				if IconList[ "[LVS] - "..CategoryName.." - "..SubName ] then
					SubIcon = IconList[ "[LVS] - "..CategoryName.." - "..SubName ]
				else
					if IconList[ "[LVS] - "..SubName ] then
						SubIcon = IconList[ "[LVS] - "..SubName ]
					end
				end
			end

			local subnode = node:AddNode( SubName, SubIcon )

			subnode.DoPopulate = function( self )
				if self.PropPanel then return end

				self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
				self.PropPanel:SetVisible( false )
				self.PropPanel:SetTriggerSpawnlistChange( false )

				for k, ent in SortedPairsByMemberValue( data, "PrintName" ) do
					spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
						nicename	= ent.PrintName or ent.ClassName,
						spawnname	= ent.SpawnName,
						material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
						admin		= ent.AdminOnly
					} )
				end
			end
			subnode.DoClick = function( self )
				self:DoPopulate()
				pnlContent:SwitchPanel( self.PropPanel )
			end
		end
	end

	-- User Stuff
	hook.Run( "LVS.PopulateVehicles", lvsNode, pnlContent, tree )

	-- CONTROLS
	local node = lvsNode:AddNode( "Controls", "icon16/keyboard.png" )
	node.DoClick = function( self )
		LVS:OpenMenu()
		LVS:OpenClientControls()
	end

	-- CLIENT SETTINGS
	local node = lvsNode:AddNode( "Client Settings", "icon16/wrench.png" )
	node.DoClick = function( self )
		LVS:OpenMenu()
		LVS:OpenClientSettings()
	end

	-- SERVER SETTINGS
	local node = lvsNode:AddNode( "Server Settings", "icon16/wrench_orange.png" )
	node.DoClick = function( self )
		if LocalPlayer():IsSuperAdmin() then
			LVS:OpenMenu()
			LVS:OpenServerMenu()
		else
			surface.PlaySound( "buttons/button11.wav" )
		end
	end
end )

list.Set( "ContentCategoryIcons", "[LVS]", "icon16/lvs.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Artillery", "icon16/lvs_artillery.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Cars", "icon16/lvs_cars.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Armored", "icon16/lvs_armor.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Civilian", "icon16/lvs_civilian.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Military", "icon16/lvs_military.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Pack", "icon16/lvs_cars_pack.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Helicopters", "icon16/lvs_helicopters.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Helicopters - Combine", "icon16/lvs_combine.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Helicopters - Resistance", "icon16/lvs_resistance.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Planes", "icon16/lvs_planes.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Bombers", "icon16/lvs_bomb.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Fighters", "icon16/lvs_fighter.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Civilian", "icon16/lvs_civilian.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Tanks", "icon16/lvs_tanks.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Light", "icon16/lvs_light.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Medium", "icon16/lvs_medium.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Heavy", "icon16/lvs_heavy.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - RP", "icon16/lvs_rp.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Star Wars", "icon16/lvs_starwars.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Gunships", "icon16/lvs_sw_gunship.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Hover Tanks", "icon16/lvs_sw_hover.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Walkers", "icon16/lvs_sw_walker.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Starfighters", "icon16/lvs_sw_starfighter.png" )

--PATH lua/autorun/client/morematerials.lua:
// adding materials to the material toolguns list

list.Add( "OverrideMaterials", "models/XQM//Deg360" )
list.Add( "OverrideMaterials", "models/XQM//LightLinesGB" )
list.Add( "OverrideMaterials", "models/XQM//LightLinesRed" )
list.Add( "OverrideMaterials", "models/XQM//SquaredMat" )
list.Add( "OverrideMaterials", "models/XQM//WoodTexture_1" )
list.Add( "OverrideMaterials", "models/airboat/airboat_blur02" )
list.Add( "OverrideMaterials", "models/alyx/emptool_glow" )
list.Add( "OverrideMaterials", "models/antlion/antlion_innards" )
list.Add( "OverrideMaterials", "models/barnacle/roots" )
list.Add( "OverrideMaterials", "models/combine_advisor/body9" )
list.Add( "OverrideMaterials", "models/combine_advisor/mask" )
list.Add( "OverrideMaterials", "models/combine_scanner/scanner_eye" )
list.Add( "OverrideMaterials", "models/debug/debugwhite" )
list.Add( "OverrideMaterials", "models/dog/eyeglass" )
list.Add( "OverrideMaterials", "models/effects/portalrift_sheet" )
list.Add( "OverrideMaterials", "models/effects/slimebubble_sheet" )
list.Add( "OverrideMaterials", "models/effects/splode1_sheet" )
list.Add( "OverrideMaterials", "models/effects/splode_sheet" )
list.Add( "OverrideMaterials", "models/gibs/metalgibs/metal_gibs" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs01" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs02" )
list.Add( "OverrideMaterials", "models/gibs/woodgibs/woodgibs03" )
list.Add( "OverrideMaterials", "models/player/player_chrome1" )
list.Add( "OverrideMaterials", "models/props_animated_breakable/smokestack/brickwall002a" )
list.Add( "OverrideMaterials", "models/props_building_details/courtyard_template001c_bars" )
list.Add( "OverrideMaterials", "models/props_building_details/courtyard_template001c_bars" )
list.Add( "OverrideMaterials", "models/props_buildings/destroyedbuilldingwall01a" )
list.Add( "OverrideMaterials", "models/props_buildings/plasterwall021a" )
list.Add( "OverrideMaterials", "models/props_c17/frostedglass_01a" )
list.Add( "OverrideMaterials", "models/props_c17/furniturefabric001a" )
list.Add( "OverrideMaterials", "models/props_c17/furniturefabric002a" )
list.Add( "OverrideMaterials", "models/props_c17/furnituremetal001a" )
list.Add( "OverrideMaterials", "models/props_c17/gate_door02a" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder001" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder002" )
list.Add( "OverrideMaterials", "models/props_c17/metalladder003" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01a" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01b" )
list.Add( "OverrideMaterials", "models/props_canal/canal_bridge_railing_01c" )
list.Add( "OverrideMaterials", "models/props_canal/canalmap_sheet" )
list.Add( "OverrideMaterials", "models/props_canal/coastmap_sheet" )
list.Add( "OverrideMaterials", "models/props_canal/metalcrate001d" )
list.Add( "OverrideMaterials", "models/props_canal/metalwall005b" )
list.Add( "OverrideMaterials", "models/props_canal/rock_riverbed01a" )
list.Add( "OverrideMaterials", "models/props_combine/citadel_cable" )
list.Add( "OverrideMaterials", "models/props_combine/citadel_cable_b" )
list.Add( "OverrideMaterials", "models/props_combine/com_shield001a" )
list.Add( "OverrideMaterials", "models/props_combine/combine_interface_disp" )
list.Add( "OverrideMaterials", "models/props_combine/combine_monitorbay_disp" )
list.Add( "OverrideMaterials", "models/props_combine/metal_combinebridge001" )
list.Add( "OverrideMaterials", "models/props_combine/pipes01" )
list.Add( "OverrideMaterials", "models/props_combine/pipes03" )
list.Add( "OverrideMaterials", "models/props_combine/prtl_sky_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/stasisfield_beam" )
list.Add( "OverrideMaterials", "models/props_debris/building_template010a" )
list.Add( "OverrideMaterials", "models/props_debris/building_template022j" )
list.Add( "OverrideMaterials", "models/props_debris/composite_debris" )
list.Add( "OverrideMaterials", "models/props_debris/concretefloor013a" )
list.Add( "OverrideMaterials", "models/props_debris/concretefloor020a" )
list.Add( "OverrideMaterials", "models/props_debris/concretewall019a" )
list.Add( "OverrideMaterials", "models/props_debris/metalwall001a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterceiling008a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall009d" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall021a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall034a" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall034d" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall039c" )
list.Add( "OverrideMaterials", "models/props_debris/plasterwall040c" )
list.Add( "OverrideMaterials", "models/props_debris/tilefloor001c" )
list.Add( "OverrideMaterials", "models/props_foliage/driftwood_01a" )
list.Add( "OverrideMaterials", "models/props_foliage/oak_tree01" )
list.Add( "OverrideMaterials", "models/props_foliage/tree_deciduous_01a_trunk" )
list.Add( "OverrideMaterials", "models/props_interiors/metalfence007a" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01a" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01b" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01c" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01d" )
list.Add( "OverrideMaterials", "models/props_junk/plasticcrate01e" )
list.Add( "OverrideMaterials", "models/props_lab/Tank_Glass001" )
list.Add( "OverrideMaterials", "models/props_lab/cornerunit_cloud" )
list.Add( "OverrideMaterials", "models/props_lab/door_klab01" )
list.Add( "OverrideMaterials", "models/props_lab/security_screens" )
list.Add( "OverrideMaterials", "models/props_lab/security_screens2" )
list.Add( "OverrideMaterials", "models/props_lab/warp_sheet" )
list.Add( "OverrideMaterials", "models/props_lab/xencrystal_sheet" )
list.Add( "OverrideMaterials", "models/props_pipes/GutterMetal01a")
list.Add( "OverrideMaterials", "models/props_pipes/destroyedpipes01a" )
list.Add( "OverrideMaterials", "models/props_pipes/pipemetal001a" )
list.Add( "OverrideMaterials", "models/props_pipes/pipeset_metal02" )
list.Add( "OverrideMaterials", "models/props_pipes/pipesystem01a_skin1" )
list.Add( "OverrideMaterials", "models/props_pipes/pipesystem01a_skin2" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001b" )
list.Add( "OverrideMaterials", "models/props_vents/borealis_vent001c" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretefloor010a" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretewall064b" )
list.Add( "OverrideMaterials", "models/props_wasteland/concretewall066a" )
list.Add( "OverrideMaterials", "models/props_wasteland/dirtwall001a" )
list.Add( "OverrideMaterials", "models/props_wasteland/metal_tram001a" )
list.Add( "OverrideMaterials", "models/props_wasteland/quarryobjects01" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02a" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02b" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff02c" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockcliff04a" )
list.Add( "OverrideMaterials", "models/props_wasteland/rockgranite02a" )
list.Add( "OverrideMaterials", "models/props_wasteland/tugboat01" )
list.Add( "OverrideMaterials", "models/props_wasteland/tugboat02" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a_skin2" )
list.Add( "OverrideMaterials", "models/shadertest/predator" )
list.Add( "OverrideMaterials", "models/weapons/v_crossbow/rebar_glow" )
list.Add( "OverrideMaterials", "models/weapons/v_crowbar/crowbar_cyl" )
list.Add( "OverrideMaterials", "models/weapons/v_grenade/grenade body" )
list.Add( "OverrideMaterials", "models/weapons/v_slam/new light1" )
list.Add( "OverrideMaterials", "models/weapons/v_slam/new light2" )
list.Add( "OverrideMaterials", "models/weapons/v_smg1/texture5" )
list.Add( "OverrideMaterials", "models/XQM/BoxFull_diffuse" )
list.Add( "OverrideMaterials", "models/XQM/CellShadedCamo_diffuse" )
list.Add( "OverrideMaterials", "models/XQM/CinderBlock_Tex" )
list.Add( "OverrideMaterials", "models/XQM/JetBody2TailPiece_diffuse" )
list.Add( "OverrideMaterials", "models/XQM/PoleX1_diffuse" )
list.Add( "OverrideMaterials", "models/XQM/Rails/gumball_1" )
list.Add( "OverrideMaterials", "models/XQM/SquaredMatInverted" )
list.Add( "OverrideMaterials", "models/XQM/WoodPlankTexture" )
list.Add( "OverrideMaterials", "models/XQM/boxfull_diffuse" )
list.Add( "OverrideMaterials", "models/dav0r/hoverball" )
list.Add( "OverrideMaterials", "models/spawn_effect" )
list.Add( "OverrideMaterials", "phoenix_storms/Fender_chrome" )
list.Add( "OverrideMaterials", "phoenix_storms/Fender_white" )
list.Add( "OverrideMaterials", "phoenix_storms/Fender_wood" )
list.Add( "OverrideMaterials", "phoenix_storms/Future_vents" )
list.Add( "OverrideMaterials", "phoenix_storms/FuturisticTrackRamp_1-2" )
list.Add( "OverrideMaterials", "phoenix_storms/OfficeWindow_1-1" )
list.Add( "OverrideMaterials", "phoenix_storms/Pro_gear_side" )
list.Add( "OverrideMaterials", "phoenix_storms/black_brushes" )
list.Add( "OverrideMaterials", "phoenix_storms/black_chrome" )
list.Add( "OverrideMaterials", "phoenix_storms/blue_steel" )
list.Add( "OverrideMaterials", "phoenix_storms/camera" )
list.Add( "OverrideMaterials", "phoenix_storms/car_tire" )
list.Add( "OverrideMaterials", "phoenix_storms/checkers_map" )
list.Add( "OverrideMaterials", "phoenix_storms/cigar" )
list.Add( "OverrideMaterials", "phoenix_storms/concrete0" )
list.Add( "OverrideMaterials", "phoenix_storms/concrete1" )
list.Add( "OverrideMaterials", "phoenix_storms/concrete2" )
list.Add( "OverrideMaterials", "phoenix_storms/concrete3" )
list.Add( "OverrideMaterials", "phoenix_storms/construct/concrete_barrier00" )
list.Add( "OverrideMaterials", "phoenix_storms/construct/concrete_barrier2_00" )
list.Add( "OverrideMaterials", "phoenix_storms/construct/concrete_pipe_00" )
list.Add( "OverrideMaterials", "phoenix_storms/egg" )
list.Add( "OverrideMaterials", "phoenix_storms/gear" )
list.Add( "OverrideMaterials", "phoenix_storms/gear_top" )
list.Add( "OverrideMaterials", "phoenix_storms/grey_chrome" )
list.Add( "OverrideMaterials", "phoenix_storms/grey_steel" )
list.Add( "OverrideMaterials", "phoenix_storms/heli" )
list.Add( "OverrideMaterials", "phoenix_storms/indentTiles2" )
list.Add( "OverrideMaterials", "phoenix_storms/iron_rails" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_carbonfiber" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_carbonfiber2" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_metallic" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_metallic2" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_plastic" )
list.Add( "OverrideMaterials", "phoenix_storms/mat/mat_phx_plastic2" )
list.Add( "OverrideMaterials", "phoenix_storms/metal_plate" )
list.Add( "OverrideMaterials", "phoenix_storms/metal_wheel" )
list.Add( "OverrideMaterials", "phoenix_storms/metalbox" )
list.Add( "OverrideMaterials", "phoenix_storms/metalbox2" )
list.Add( "OverrideMaterials", "phoenix_storms/metalfence004a" )
list.Add( "OverrideMaterials", "phoenix_storms/middle" )
list.Add( "OverrideMaterials", "phoenix_storms/mrref2" )
list.Add( "OverrideMaterials", "phoenix_storms/output_jack" )
list.Add( "OverrideMaterials", "phoenix_storms/pack2/chrome" )
list.Add( "OverrideMaterials", "phoenix_storms/pack2/interior_sides" )
list.Add( "OverrideMaterials", "phoenix_storms/pack2/train_floor" )
list.Add( "OverrideMaterials", "phoenix_storms/potato" )
list.Add( "OverrideMaterials", "phoenix_storms/pro_gear_top2" )
list.Add( "OverrideMaterials", "phoenix_storms/ps_grass" )
list.Add( "OverrideMaterials", "phoenix_storms/road" )
list.Add( "OverrideMaterials", "phoenix_storms/roadside" )
list.Add( "OverrideMaterials", "phoenix_storms/scrnspace" )
list.Add( "OverrideMaterials", "phoenix_storms/side" )
list.Add( "OverrideMaterials", "phoenix_storms/simplyMetallic1" )
list.Add( "OverrideMaterials", "phoenix_storms/simplyMetallic2" )
list.Add( "OverrideMaterials", "phoenix_storms/smallwheel" )
list.Add( "OverrideMaterials", "phoenix_storms/spheremappy" )
list.Add( "OverrideMaterials", "phoenix_storms/t_light" )
list.Add( "OverrideMaterials", "phoenix_storms/thruster" )
list.Add( "OverrideMaterials", "phoenix_storms/tiles2" )
list.Add( "OverrideMaterials", "phoenix_storms/top" )
list.Add( "OverrideMaterials", "phoenix_storms/torpedo" )
list.Add( "OverrideMaterials", "phoenix_storms/trains/track_beamside" )
list.Add( "OverrideMaterials", "phoenix_storms/trains/track_beamtop" )
list.Add( "OverrideMaterials", "phoenix_storms/trains/track_plate" )
list.Add( "OverrideMaterials", "phoenix_storms/trains/track_plateside" )
list.Add( "OverrideMaterials", "phoenix_storms/white_brushes" )
list.Add( "OverrideMaterials", "phoenix_storms/white_fps" )
list.Add( "OverrideMaterials", "phoenix_storms/window" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_blue" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_green" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_red" )
list.Add( "OverrideMaterials", "phoenix_storms/wood_dome" )
list.Add( "OverrideMaterials", "phoenix_storms/wood_side" )

// Checking if CSS is mounted and adding CSS textures if it is

function engine.IsMounted(g)
    for k,v in pairs(engine.GetGames()) do
        if (' cstrike' ) then
            return true;
        end
    end
end

if IsMounted( 'cstrike' ) and (engine.IsMounted('cstrike')) then 

list.Add( "OverrideMaterials", "models/cs_havana/wndb" )
list.Add( "OverrideMaterials", "models/cs_havana/wndd" )
list.Add( "OverrideMaterials", "models/cs_italy/light_orange" )
list.Add( "OverrideMaterials", "models/cs_italy/plaster" )
list.Add( "OverrideMaterials", "models/cs_italy/pwtrim2" )
list.Add( "OverrideMaterials", "models/de_cbble/wndarch" )
list.Add( "OverrideMaterials", "models/de_chateau/ch_arch_b1" )
list.Add( "OverrideMaterials", "models/pi_window/plaster" )
list.Add( "OverrideMaterials", "models/pi_window/trim128" )
list.Add( "OverrideMaterials", "models/props/cs_assault/dollar" )
list.Add( "OverrideMaterials", "models/props/cs_assault/fireescapefloor" )
list.Add( "OverrideMaterials", "models/props/cs_assault/metal_stairs1" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneywrap" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneywrap02" )
list.Add( "OverrideMaterials", "models/props/cs_assault/moneytop" )
list.Add( "OverrideMaterials", "models/props/cs_assault/pylon" )
list.Add( "OverrideMaterials", "models/props/CS_militia/boulder01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/milceil001" )
list.Add( "OverrideMaterials", "models/props/CS_militia/militiarock" )
list.Add( "OverrideMaterials", "models/props/CS_militia/militiarockb" )
list.Add( "OverrideMaterials", "models/props/CS_militia/milwall006" )
list.Add( "OverrideMaterials", "models/props/CS_militia/rocks01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams01" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams02" )
list.Add( "OverrideMaterials", "models/props/CS_militia/roofbeams03" )
list.Add( "OverrideMaterials", "models/props/CS_militia/RoofEdges" )
list.Add( "OverrideMaterials", "models/props/cs_office/clouds" )
list.Add( "OverrideMaterials", "models/props/cs_office/file_cabinet2" )
list.Add( "OverrideMaterials", "models/props/cs_office/file_cabinet3" )
list.Add( "OverrideMaterials", "models/props/cs_office/screen" )
list.Add( "OverrideMaterials", "models/props/cs_office/snowmana" )
list.Add( "OverrideMaterials", "models/props/de_inferno/de_inferno_boulder_03" )
list.Add( "OverrideMaterials", "models/props/de_inferno/infflra" )
list.Add( "OverrideMaterials", "models/props/de_inferno/infflrd" )
list.Add( "OverrideMaterials", "models/props/de_inferno/inftowertop" )
list.Add( "OverrideMaterials", "models/props/de_inferno/offwndwb_break" )
list.Add( "OverrideMaterials", "models/props/de_inferno/roofbits" )
list.Add( "OverrideMaterials", "models/props/de_inferno/tileroof01" )
list.Add( "OverrideMaterials", "models/props/de_inferno/woodfloor008a" )
list.Add( "OverrideMaterials", "models/props/de_nuke/nukconcretewalla" )
list.Add( "OverrideMaterials", "models/props/de_nuke/nukecardboard" )
list.Add( "OverrideMaterials", "models/props/de_nuke/pipeset_metal" )

end



// Making sure there's no double materials in the list in case of other addons, plus sorting them

timer.Simple(0, function()
	local mats = list.GetForEdit("OverrideMaterials");
	local cleaner = {};
	for i, mat in pairs(mats) do
		cleaner[mat] = true;
		mats[i] = nil;
	end
	local i = 1;
	for mat in pairs(cleaner) do
		mats[i] = mat;
		i = i + 1;
	end
	table.sort(mats);
end);

--PATH lua/vgui/bvgui/frame.lua:
bVGUI.Frames = {}

local voice_enum
local voice_key
local function GetVoiceKeyEnum()
	voice_key = input.LookupBinding("+voicerecord", true)
	if (voice_key) then
		for i,v in pairs(_G) do
			if (i:sub(1,4) == "KEY_") then
				if (input.GetKeyName(v) == voice_key) then
					voice_enum = v
					break
				end
			end
		end
	end
end
GetVoiceKeyEnum()
timer.Create("bVGUI.voicerecord_bind", 10, 0, function()
	if (voice_key ~= input.LookupBinding("+voicerecord", true)) then
		GetVoiceKeyEnum()
	end
end)

local PANEL = {}

function PANEL:OnKeyCodePressed(key_code)
	if (GAS and GAS.LocalConfig and GAS.LocalConfig.AllowVoiceChat == false) then return end
	if (voice_enum and key_code == voice_enum) then
		if (permissions and permissions.EnableVoiceChat) then
			permissions.EnableVoiceChat(true)
		else
			RunConsoleCommand("+voicerecord")
		end
	end
end
function PANEL:OnKeyCodeReleased(key_code)
	if (GAS and GAS.LocalConfig and GAS.LocalConfig.AllowVoiceChat == false) then return end
	if (voice_enum and key_code == voice_enum) then
		if (permissions and permissions.EnableVoiceChat) then
			permissions.EnableVoiceChat(false)
		else
			RunConsoleCommand("-voicerecord")
		end
	end
end

function PANEL:Init()
	table.insert(bVGUI.Frames, self)

	local this = self

	self:DockPadding(0, 24, 0, 0)
	self.lblTitle:SetVisible(false)
	self.btnClose:SetVisible(false)
	self.btnMaxim:SetVisible(false)
	self.btnMinim:SetVisible(false)

	self.ColorCycling = {}
	self.ColorCycling.IntendedColor = table.Copy(bVGUI.COLOR_GMOD_BLUE)
	self.ColorCycling.CurrentColor = table.Copy(bVGUI.COLOR_GMOD_BLUE)

	self.bVGUI_Toolbar = vgui.Create("DPanel", self)
	self.bVGUI_Toolbar:SetTall(24)
	self.bVGUI_Toolbar:SetCursor("sizeall")
	function self.bVGUI_Toolbar:OnMousePressed()
		if (this.Fullscreened ~= false or this:GetDraggable() == false) then return end
		this.Dragging = { gui.MouseX() - this.x, gui.MouseY() - this.y }
	end
	function self.bVGUI_Toolbar:OnMouseReleased()
		this.Dragging = nil
	end
	function self.bVGUI_Toolbar:Paint(w,h)
		surface.SetDrawColor(this.ColorCycling.CurrentColor)
		surface.DrawRect(0,0,w,h)

		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
		surface.DrawTexturedRect(0,0,w,h)
	end
	function self.bVGUI_Toolbar:PaintOver(w,h)
		if (this.DrawBorder ~= false) then
			surface.SetDrawColor(bVGUI.COLOR_BLACK)
			surface.DrawLine(0,h - 1,w,h - 1)
		end
	end

	self.MenuOpen = false
	self.bVGUI_MenuButton = vgui.Create("bVGUI.ToolbarButton_IMGText", self.bVGUI_Toolbar)
	self.bVGUI_MenuButton:Dock(LEFT)
	self.bVGUI_MenuButton:SetMaterial(bVGUI.ICON_MENU)
	self.bVGUI_MenuButton:SetHoverMaterial(bVGUI.ICON_MENU_INVERTED)
	self.bVGUI_MenuButton:SetText(self:GetTitle())
	self.bVGUI_MenuButton.bVGUI_Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 14))
	function self.bVGUI_MenuButton:DoClick()
		if (GAS and GAS.PlaySound) then GAS:PlaySound("btn_light") end
		if (this.MenuClicked) then
			this:MenuClicked()
		elseif (not IsValid(this.DermaMenu) and this.DermaMenuOptions) then
			this.DermaMenu = DermaMenu()
			this:DermaMenuOptions(this.DermaMenu)
			this.DermaMenu:Open(self:LocalToScreen(0,self:GetTall() - 1))
			function this.DermaMenu:OptionSelected()
				this.DermaMenu = nil
			end
		elseif (IsValid(this.DermaMenu)) then
			this.DermaMenu:Hide()
			this.DermaMenu:Remove()
			this.DermaMenu = nil
		elseif (this.DermaMenu ~= nil) then
			this.DermaMenu = nil
		end
	end

	self.bVGUI_CloseButton = vgui.Create("bVGUI.ToolbarButton_IMG", self.bVGUI_Toolbar)
	self.bVGUI_CloseButton:SetSize(20,24)
	self.bVGUI_CloseButton:Dock(RIGHT)
	self.bVGUI_CloseButton:SetMaterial(bVGUI.ICON_CLOSE)
	self.bVGUI_CloseButton:SetHoverMaterial(bVGUI.ICON_CLOSE_INVERTED)
	function self.bVGUI_CloseButton:DoClick()
		if (GAS and GAS.PlaySound) then GAS:PlaySound("btn_heavy") end
		this:Close()
	end

	self.Fullscreened = false
	self.bVGUI_FullscreenButton = vgui.Create("bVGUI.ToolbarButton_IMG", self.bVGUI_Toolbar)
	self.bVGUI_FullscreenButton:SetSize(24,24)
	self.bVGUI_FullscreenButton:Dock(RIGHT)
	self.bVGUI_FullscreenButton:SetMaterial(bVGUI.ICON_FULLSCREEN)
	self.bVGUI_FullscreenButton:SetHoverMaterial(bVGUI.ICON_FULLSCREEN_INVERTED)

	function self.bVGUI_FullscreenButton:DoClick()
		if (this.Fullscreened == false) then
			if (GAS and GAS.PlaySound) then GAS:PlaySound("jump") end

			this.Fullscreened = {this:GetWide(), this:GetTall()}
			this.bVGUI_Toolbar:SetCursor("arrow")

			this:Stop()
			this:SizeTo(ScrW() - (self.OffsetX or 0), ScrH(), 0.5, 0, 0.5)
			this:MoveTo(self.OffsetX or 0, 0, 0.5, 0, 0.5)
		else
			if (GAS and GAS.PlaySound) then GAS:PlaySound("delete") end

			this:Stop()
			this:MoveTo((ScrW() / 2) - (this.Fullscreened[1] / 2), (ScrH() / 2) - (this.Fullscreened[2] / 2), 0.5, 0, 0.5)
			this:SizeTo(this.Fullscreened[1], this.Fullscreened[2], 0.5, 0, 0.5)

			this.Fullscreened = false
			this.bVGUI_Toolbar:SetCursor("sizeall")
		end
		timer.Simple(0.5, function()
			if (IsValid(this)) then
				this:InvalidateLayout(true)
				local function recursive(children)
					for _,child in ipairs(children) do
						if (child.RerenderMarkups) then
							child:RerenderMarkups()
						end
						recursive(child:GetChildren())
					end
				end
				recursive(this:GetChildren())
			end
		end)
	end

	self.Pinned = false
	self.bVGUI_PinButton = vgui.Create("bVGUI.ToolbarButton_IMG", self.bVGUI_Toolbar)
	self.bVGUI_PinButton:SetSize(24,24)
	self.bVGUI_PinButton:Dock(RIGHT)
	self.bVGUI_PinButton:SetMaterial(bVGUI.ICON_PIN)
	self.bVGUI_PinButton:SetHoverMaterial(bVGUI.ICON_PIN_INVERTED)

	function self.bVGUI_PinButton:DoClick()
		self:TogglePin()
		if (GAS and GAS.PlaySound) then
			if (this.Pinned) then
				GAS:PlaySound("drip_up")
			else
				GAS:PlaySound("drip_down")
			end
		end
	end
	function self.bVGUI_PinButton:TogglePin()
		this.Pinned = not this.Pinned
		if (this.Pinned) then
			this:KillFocus()
			this:SetMouseInputEnabled(false)
			this:SetKeyboardInputEnabled(false)
			this:SetAlpha(200)

			gui.HideGameUI()
			timer.Simple(0, function()

				this.pin_overlay = vgui.Create("DPanel")
				this.pin_overlay:SetCursor("hand")
				this.pin_overlay:SetMouseInputEnabled(true)
				function this.pin_overlay:Paint(w,h)
					if (not IsValid(this)) then
						self:Remove()
						return
					end
					self:SetSize(this:GetSize())
					self:SetPos(this:GetPos())
					if (gui.IsGameUIVisible()) then
						bVGUI_GlobalPinned = nil
						for _,v in ipairs(bVGUI.Frames) do
							if (v.Pinned and IsValid(v.bVGUI_PinButton) and v.bVGUI_PinButton:IsVisible()) then
								v.bVGUI_PinButton:TogglePin()
							end
						end
					end
				end
				function this.pin_overlay:OnMouseReleased(m)
					self:Remove()
					this.bVGUI_PinButton:DoClick()

					for _,v in ipairs(bVGUI.Frames) do
						if (v ~= this and v.Pinned and IsValid(v.bVGUI_PinButton) and v.bVGUI_PinButton:IsVisible()) then
							v.bVGUI_PinButton:TogglePin()
						end
					end
				end

			end)

			for _,v in ipairs(bVGUI.Frames) do
				if (v ~= this and not v.Pinned and IsValid(v.bVGUI_PinButton) and v.bVGUI_PinButton:IsVisible()) then
					v.bVGUI_PinButton:TogglePin()
				end
			end
		else
			if (IsValid(this.pin_overlay)) then
				this.pin_overlay:Remove()
			end
			this:MakePopup()
			this:SetAlpha(255)
		end

		gui.EnableScreenClicker(false)

		if (this.Pinned) then
			if (not bVGUI_GlobalPinned) then
				bVGUI_GlobalPinned = true
				notification.AddLegacy(bVGUI.L("pin_tip"), NOTIFY_UNDO, 3)
			end
		else
			bVGUI_GlobalPinned = nil
		end

		if (this.Pinned and this.OnPinned) then
			this:OnPinned()
		elseif (not this.Pinned and this.OnUnpinned) then
			this:OnUnpinned()
		end
	end

	function self:OnChildAdded(child)
		child.IsDefaultChild = false
	end
end

function PANEL:OnClose()
	if (self.CloseFrames) then
		for v in pairs(self.CloseFrames) do
			if (IsValid(v)) then v:Close() end
		end
	end
	if (self.ClosePanels) then
		for v in pairs(self.ClosePanels) do
			if (IsValid(v)) then v:Remove() end
		end
	end
end

function PANEL:OnResize(w, h)

end

local drag_icon = Material("vgui/bvgui/drag.png", "smooth")
function PANEL:EnableUserResize()
	local this = self
	self.UserResize = vgui.Create("bVGUI.BlankPanel", self)
	self.UserResize:SetMouseInputEnabled(true)
	self.UserResize:SetCursor("sizenwse")
	self.UserResize:SetSize(18,18)
	self.UserResize:MoveToFront()
	function self.UserResize:OnMousePressed(m)
		self.Dragging = true
	end
	function self.UserResize:Think()
		if (self.Dragging == true) then
			if (input.IsMouseDown(MOUSE_LEFT)) then
				local x,y = gui.MousePos()
				if (not self.StartingCoords) then
					self.StartingCoords = {x,y}
				end
				if (not self.StartingSize) then
					self.StartingSize = {this:GetSize()}
				end

				local new_x, new_y = self.StartingSize[1] + (x - self.StartingCoords[1]), self.StartingSize[2] + (y - self.StartingCoords[2])
				this:OnResize(new_x, new_y)
				this:SetSize(math.max(new_x, this:GetMinWidth()), math.max(new_y, this:GetMinHeight()))
				this:InvalidateChildren(true)
			else
				self.StartingCoords = nil
				self.StartingSize = nil
				self.Dragging = false

				local function recursive(children)
					for _,child in ipairs(children) do
						if (child.RerenderMarkups) then
							child:RerenderMarkups()
						end
						recursive(child:GetChildren())
					end
				end
				recursive(this:GetChildren())
			end
		end
	end
	function self.UserResize:Paint(w,h)
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(drag_icon)
		local width,height = 12,12
		surface.DrawTexturedRect(w / 2 - width / 2, h / 2 - height / 2, width, height)
	end
end

function PANEL:ShowCloseButton(showclosebutton)
	self.bVGUI_CloseButton:SetVisible(showclosebutton)
end

function PANEL:ShowFullscreenButton(showfullscreenbutton)
	self.bVGUI_FullscreenButton:SetVisible(showfullscreenbutton)
end

function PANEL:ShowPinButton(showpinbutton)
	self.bVGUI_PinButton:SetVisible(showpinbutton)
end

function PANEL:SetDraggable(draggable)
	self.m_bDraggable = draggable
	if (draggable) then
		self.bVGUI_Toolbar:SetCursor("sizeall")
	else
		self.bVGUI_Toolbar:SetCursor("default")
	end
end

function PANEL:PaintOver(w,h)
	if (self.DrawBorder ~= false) then
		surface.SetDrawColor(bVGUI.COLOR_BLACK)
		surface.DrawOutlinedRect(0,0,w,h)
	end
end

function PANEL:PerformLayout(w, h)
	self.bVGUI_Toolbar:SetWide(self:GetWide())
	for _,v in pairs(self:GetChildren()) do
		v:InvalidateLayout(true)
	end
	if (IsValid(self.UserResize)) then
		self.UserResize:AlignRight(0)
		self.UserResize:AlignBottom(0)
	end
	if (self.PostPerformLayout) then
		self:PostPerformLayout(w, h)
	end
end

function PANEL:SetTitle(title)
	self.lblTitle:SetText(title)
	self.bVGUI_MenuButton:SetText(title)
end

local frame_bg = Color(30,34,42,250)
local blur = Material("pp/blurscreen")
function PANEL:Paint(w,h)
	if (self.DrawBlur == true) then
		local x,y = self:LocalToScreen(0,0)
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(blur)
		for i = -0.2, 2, 0.2 do
			blur:SetFloat("$blur", i * 1.0)
			blur:Recompute()
			render.UpdateScreenEffectTexture()
			surface.DrawTexturedRect(-x,-y,ScrW(),ScrH())
		end

		surface.SetDrawColor(frame_bg)
		surface.DrawRect(0,0,w,h)
	else
		surface.SetDrawColor(30,34,42,253)
		surface.DrawRect(0,0,w,h)

		surface.SetDrawColor(255,255,255,210)
		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LARGE)
		surface.DrawTexturedRect(0,0,w,h)
	end

	local r = Lerp(0.01, self.ColorCycling.CurrentColor.r, self.ColorCycling.IntendedColor.r)
	local g = Lerp(0.01, self.ColorCycling.CurrentColor.g, self.ColorCycling.IntendedColor.g)
	local b = Lerp(0.01, self.ColorCycling.CurrentColor.b, self.ColorCycling.IntendedColor.b)
	if (self.ColorCycling.r_ceil) then r = bVGUI.CEIL(r) else r = bVGUI.FLOOR(r) end
	if (self.ColorCycling.g_ceil) then g = bVGUI.CEIL(g) else g = bVGUI.FLOOR(g) end
	if (self.ColorCycling.b_ceil) then b = bVGUI.CEIL(b) else b = bVGUI.FLOOR(b) end
	self.ColorCycling.CurrentColor.r = r
	self.ColorCycling.CurrentColor.g = g
	self.ColorCycling.CurrentColor.b = b
end
function PANEL:CycleColors(col)
	self.ColorCycling.r_ceil = col.r > self.ColorCycling.IntendedColor.r
	self.ColorCycling.g_ceil = col.g > self.ColorCycling.IntendedColor.g
	self.ColorCycling.b_ceil = col.b > self.ColorCycling.IntendedColor.b
	self.ColorCycling.IntendedColor = table.Copy(col)
end

derma.DefineControl("bVGUI.Frame", nil, PANEL, "DFrame")
--PATH lua/vgui/bvgui/gauge.lua:
local PANEL = {}

function PANEL:Init()
	self.Color = Color(192,57,43)
	self.Progress = 0
	self.ProgressAngle = 0

	self.ProgressCircle = GAS_NewCircle(CIRCLE_OUTLINED)
	self.ProgressCircle:SetAngles(180,360)
	self.ProgressCircle:SetThickness(20)
	self.ProgressCircle:SetVertices(64)

	self.ProgressBackgroundCircle = GAS_NewCircle(CIRCLE_OUTLINED)
	self.ProgressBackgroundCircle:SetAngles(180,360)
	self.ProgressBackgroundCircle:SetThickness(20)
	self.ProgressBackgroundCircle:SetVertices(64)

	self.BackgroundCircle = GAS_NewCircle(CIRCLE_FILLED)
	self.BackgroundCircle:SetAngles(180,360)
	self.BackgroundCircle:SetVertices(64)

	self.Text = vgui.Create("DLabel", self)
	self.Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 18))
	self.Text:SetTextColor(COLOR_WHITE)
	self.Text:SetText("")

	self.SubText = vgui.Create("DLabel", self)
	self.SubText:SetVisible(false)
	self.SubText:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	self.SubText:SetTextColor(COLOR_WHITE)
	self.SubText:SetText("")
end

function PANEL:SetColor(col_from, col_to)
	if (IsColor(col_from) and col_to == nil) then
		self.Color = col_from
		self.ColorFrom = nil
		self.ColorTo = nil
	elseif (IsColor(col_from) and IsColor(col_to)) then
		self.Color = table.Copy(col_from)
		self.ColorFrom = col_from
		self.ColorTo = col_to
	end
end

function PANEL:SetProgress(progress)
	self.Progress = math.Clamp(progress, 0, 100)
end

function PANEL:SetText(txt)
	self.Text:SetText(txt)
end

function PANEL:SetSubText(txt)
	if (txt == nil or #txt == 0) then
		self.SubText:SetVisible(false)
	else
		self.SubText:SetVisible(true)
		self.SubText:SetText(txt)
	end
end

function PANEL:PerformLayout(w, h)
	self.Text:SizeToContents()

	if (self.SubText:IsVisible()) then
		self.SubText:SizeToContents()

		self.Text:SetPos((w - self.Text:GetWide()) / 2, ((w - self.Text:GetTall()) / 2) - 20 - (self.SubText:GetTall() / 2))
		self.SubText:SetPos((w - self.SubText:GetWide()) / 2, ((w - self.Text:GetTall()) / 2) - 20 + (self.Text:GetTall() / 2))
	else
		self.Text:SetPos((w - self.Text:GetWide()) / 2, ((w - self.Text:GetTall()) / 2) - 20)
	end
end

function PANEL:Paint(w,h)
	draw.NoTexture()

	local r = w / 2

	surface.SetDrawColor(45,45,45,255)
	self.ProgressBackgroundCircle:SetPos(w / 2, w / 2)
	self.ProgressBackgroundCircle:SetRadius(r)
	self.ProgressBackgroundCircle()

	local progress_frac = (self.Progress / 100)
	if (self.ColorFrom and self.ColorTo) then
		self.Color.r = Lerp(0.05, self.Color.r, self.ColorFrom.r + ((self.ColorTo.r - self.ColorFrom.r) * progress_frac))
		self.Color.g = Lerp(0.05, self.Color.g, self.ColorFrom.g + ((self.ColorTo.g - self.ColorFrom.g) * progress_frac))
		self.Color.b = Lerp(0.05, self.Color.b, self.ColorFrom.b + ((self.ColorTo.b - self.ColorFrom.b) * progress_frac))
	end
	self.ProgressAngle = Lerp(0.05, self.ProgressAngle, progress_frac * 180)

	surface.SetDrawColor(self.Color)
	self.ProgressCircle:SetAngles(180, 180 + self.ProgressAngle)
	self.ProgressCircle:SetPos(w / 2, w / 2)
	self.ProgressCircle:SetRadius(r)
	self.ProgressCircle()

	surface.SetDrawColor(60,60,60,255)
	self.BackgroundCircle:SetPos(w / 2, w / 2)
	self.BackgroundCircle:SetRadius(r - 20)
	self.BackgroundCircle()
end

derma.DefineControl("bVGUI.Gauge", nil, PANEL, "DPanel")
--PATH lua/vgui/bvgui/header.lua:
return gluapack()()
--PATH lua/vgui/bvgui/horizontaldivider.lua:
return gluapack()()
--PATH lua/vgui/bvgui/horizontaldivider.lua:
local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("sizewe")

	self.LeftWidth = 0
	self.MiddleWidth = 0
	self.RightWidth = 0
end

function PANEL:SetLeft(pnl)
	self.LeftPnl = pnl
	pnl:SetParent(self)
end

function PANEL:SetMiddle(pnl)
	self.MiddlePnl = pnl
	pnl:SetParent(self)
end

function PANEL:SetRight(pnl)
	self.RightPnl = pnl
	pnl:SetParent(self)
end

function PANEL:SetDividerWidth(w)
	self.DividerWidth = w
end

function PANEL:BalanceWidths()
	self.BalanceWidth = true
end

function PANEL:PerformLayout(w,h)
	if (self.BalanceWidth) then
		self.BalanceWidth = nil

		if (IsValid(self.MiddlePnl)) then
			self.LeftWidth   = (w - (self.DividerWidth * 2)) / 3
			self.MiddleWidth = (w - (self.DividerWidth * 2)) / 3
			self.RightWidth  = (w - (self.DividerWidth * 2)) / 3
		else
			self.LeftWidth   = (w - self.DividerWidth) / 2
			self.MiddleWidth = 0
			self.RightWidth  = (w - self.DividerWidth) / 2
		end
	end

	if (IsValid(self.LeftPnl)) then
		self.LeftPnl:SetSize(self.LeftWidth, h)
		self.LeftPnl:AlignLeft(0)
	end
	if (IsValid(self.MiddlePnl)) then
		self.MiddlePnl:SetSize(self.MiddleWidth, h)
		self.MiddlePnl:AlignLeft(self.LeftWidth + self.DividerWidth)
	end
	if (IsValid(self.RightPnl)) then
		self.RightPnl:SetSize(self.RightWidth, h)
		self.RightPnl:AlignRight(0)
	end
end

function PANEL:Paint(w,h)
	if (not IsValid(self.LeftPnl) or not IsValid(self.RightPnl)) then return end

	surface.SetDrawColor(51,80,114)
	surface.DrawRect(self.LeftWidth,0,self.DividerWidth,h)

	surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LARGE)
	surface.DrawTexturedRect(self.LeftWidth,0,self.DividerWidth,h)

	if (IsValid(self.MiddlePnl)) then
		surface.SetDrawColor(51,80,114)
		surface.DrawRect(w - self.RightWidth - self.DividerWidth,0,self.DividerWidth,h)

		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LARGE)
		surface.DrawTexturedRect(w - self.RightWidth - self.DividerWidth,0,self.DividerWidth,h)
	end
end

function PANEL:OnMousePressed(m)
	if (m == MOUSE_LEFT) then
		self.Dragging = true
	end
end
function PANEL:OnCursorMoved(x,y)
	local w,h = self:GetSize()
	if (self.Dragging) then
		
	end
end
function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		self.Dragging = nil
	end
end

derma.DefineControl("bVGUI.HorizontalDivider", nil, PANEL, "DHorizontalDivider")
--PATH lua/vgui/bvgui/infobar.lua:
bVGUI.INFOBAR_COLOR_GREY = Color(62, 62, 62)
bVGUI.INFOBAR_COLOR_PURPLE = Color(104, 0, 160)

local PANEL = {}

function PANEL:Init()
	self:SetTall(30)
	self:SetMouseInputEnabled(true)
	self:DockPadding(5,0,5,4)

	self.OriginalBarColor = bVGUI.INFOBAR_COLOR_GREY
	self.TargetBarColor = self.OriginalBarColor
	self.BorderColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.2)

	self.Label = vgui.Create("DLabel", self)
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
end

function PANEL:SetText(text)
	self.Text = text
	self.Label:SetText(text)
end
function PANEL:GetText()
	return self.Text
end

function PANEL:SetColor(col_enum)
	self.OriginalBarColor = col_enum
	self.TargetBarColor = self.OriginalBarColor
	self.BorderColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.2)
	self.Label:SetTextColor(bVGUI.TextColorContrast(col_enum))
end

function PANEL:OnCursorEntered()
	if (self.AllowCopy) then
		self.TargetBarColor = bVGUI.LightenColor(self.OriginalBarColor, 0.2)
		self.ColorInterpolation = bVGUI.LerpColor(self.OriginalBarColor, self.TargetBarColor, 0.5)
	end
end
function PANEL:OnCursorExited()
	if (self.AllowCopy) then
		self.ColorInterpolation = bVGUI.LerpColor(self.TargetBarColor, self.OriginalBarColor, 0.5)
		self.TargetBarColor = self.OriginalBarColor
	end
end
function PANEL:OnMousePressed()
	if (self.AllowCopy) then
		self.ColorInterpolation = nil
		self.TargetBarColor = self.BorderColor
		self:DockPadding(5,0,5,0)
		self:InvalidateLayout(true)
	end
end
function PANEL:OnMouseReleased()
	if (self.AllowCopy) then
		if (GAS) then
			GAS:SetClipboardText(self:GetText())
		else
			SetClipboardText(self:GetText())
			bVGUI.MouseInfoTooltip.Create(bVGUI.L("copied"))
		end

		if (self:IsHovered()) then
			self.TargetBarColor = bVGUI.LightenColor(self.OriginalBarColor, 0.2)
		else
			self.TargetBarColor = self.OriginalBarColor
		end
		self:DockPadding(5,0,5,4)
		self:InvalidateLayout(true)
	end
end

function PANEL:Paint(w,h)
	if (self.ColorInterpolation) then
		self.ColorInterpolation:DoLerp()
		surface.SetDrawColor(self.ColorInterpolation:GetColor())
	else
		surface.SetDrawColor(self.TargetBarColor)
	end
	if (self.DrawBorder ~= false) then
		local col
		if (self.ColorInterpolation) then
			col = self.ColorInterpolation:GetColor()
		else
			col = self.TargetBarColor
		end
		draw.RoundedBox(4, 0, 0, w, h, self.BorderColor)
		draw.RoundedBoxEx(4, 0, 0, w, h - 4, col, true, true)
	else
		surface.DrawRect(0,0,w,h)
	end
end

function PANEL:SetDrawBorder(draw_border)
	self.DrawBorder = draw_border
	if (draw_border == false) then
		self:DockPadding(0,0,0,0)
	else
		self:DockPadding(0,0,0,4)
	end
end
function PANEL:GetDrawBorder()
	return self.DrawBorder
end

function PANEL:AllowCopy()
	self.AllowCopy = true
	self:SetCursor("hand")
end

derma.DefineControl("bVGUI.InfoBar", nil, PANEL, "DPanel")
--PATH lua/vgui/bvgui/loadingpanel.lua:
local PANEL = {}

function PANEL:Init()
	self.LoadingPaint = self.Paint
end

function PANEL:Paint(w,h)
	if (not self.EndTime or SysTime() >= self.EndTime) then
		self.EndTime = SysTime() + 2
	end
	self.Rotation = ((self.EndTime - SysTime()) / 2) * 360

	if (self.Loading == true) then
		local size = 24
		surface.SetDrawColor(bVGUI.COLOR_WHITE)
		surface.SetMaterial(bVGUI.MATERIAL_LOADING_ICON)
		surface.DrawTexturedRectRotated(w / 2, h / 2, size, size, math.Round(self.Rotation))
	end
end

function PANEL:SetLoading(is_loading)
	self.Loading = is_loading
end
function PANEL:GetLoading()
	return self.Loading
end

derma.DefineControl("bVGUI.LoadingPanel", nil, PANEL, "DPanel")
derma.DefineControl("bVGUI.LoadingScrollPanel", nil, table.Copy(PANEL), "bVGUI.ScrollPanel")
--PATH lua/vgui/bvgui/player_tooltip.lua:
if (bVGUI.PlayerTooltip) then
	if (IsValid(bVGUI.PlayerTooltip.Panel)) then
		bVGUI.PlayerTooltip.Panel:Remove()
	end
end

bVGUI.PlayerTooltip = {}
bVGUI.PlayerTooltip.Close = function()
	if (IsValid(bVGUI.PlayerTooltip.Panel)) then
		if (bVGUI.PlayerTooltip.Panel.Focused ~= true) then
			bVGUI.PlayerTooltip.Panel:Remove()
		end
	end
end
bVGUI.PlayerTooltip.Create = function(options)
	if (IsValid(bVGUI.PlayerTooltip.Panel)) then
		if (bVGUI.PlayerTooltip.Panel.Focused ~= true) then
			bVGUI.PlayerTooltip.Panel:Remove()
		end
	end

	if (not IsValid(options.player) and options.account_id) then
		local ply = player.GetByAccountID(options.account_id)
		if (IsValid(ply)) then
			options.player = ply
		end
	elseif (not IsValid(options.player) and options.steamid64) then
		local ply = player.GetBySteamID64(options.steamid64)
		if (IsValid(ply)) then
			options.player = ply
		end
	end

	local data = {}
	data.nick = "Loading..."
	data.usergroup = "Loading..."
	data.team_name = "(offline)"
	data.team_color = bVGUI.BUTTON_COLOR_RED
	if (IsValid(options.player)) then
		data.account_id = options.player:AccountID()
		data.steamid = options.player:SteamID()
		data.steamid64 = options.player:SteamID64()
		data.team_name = team.GetName(options.player:Team())
		data.team_color = team.GetColor(options.player:Team())
		data.nick = options.player:Nick()
		data.usergroup = options.player:GetUserGroup()
	elseif (options.steamid64) then
		data.account_id = GAS:SteamID64ToAccountID(options.steamid64)
		data.steamid = util.SteamIDFrom64(options.steamid64)
		data.steamid64 = options.steamid64
	elseif (options.account_id) then
		data.account_id = options.account_id
		data.steamid = GAS:AccountIDToSteamID(options.account_id)
		data.steamid64 = util.SteamIDTo64(data.steamid)
	end

	bVGUI.PlayerTooltip.Panel = vgui.Create("bVGUI.Frame")
	local pnl = bVGUI.PlayerTooltip.Panel
	pnl.Options = options
	pnl.CreatorPanel = options.creator
	pnl:ShowFullscreenButton(false)
	pnl:SetSize(316, 234)
	pnl:SetPos(gui.MouseX() + 15, gui.MouseY() + 15)
	pnl:DockPadding(10,24 + 10,10,10)
	pnl:MakePopup()
	pnl:SetMouseInputEnabled(false)
	pnl:SetKeyBoardInputEnabled(false)
	pnl:SetDrawOnTop(true)
	pnl.OriginalTitle = data.nick

	function pnl:OnRemove()
		timer.Simple(1, function()
			if (not IsValid(bVGUI.PlayerTooltip.Panel)) then
				bVGUI.PlayerTooltip.MouseX = false 
				bVGUI.PlayerTooltip.MouseY = false
			end
		end)
	end

	function pnl:PostPerformLayout(w, h)
		if (options.focustip) then
			pnl:SetTitle(bVGUI.EllipsesText(data.nick, bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 14), w / 3) .. " · " .. options.focustip)
		else
			pnl:SetTitle(data.nick)
		end
	end

	function pnl:OnFocusChanged(got)
		if got then return end 
		if self.Pinned then return end 
		if not GAS.LocalConfig.ClosePlayerPopups then return end		
		self:Close()
	end

	pnl.OldPaint = pnl.Paint
	function pnl:Paint(w,h)
		if (not self.Focused) then
			surface.SetAlphaMultiplier(0.5)
		end
		self:OldPaint(w,h)

		if (self.Focused ~= true) then
			local x,y = gui.MouseX(), gui.MouseY()
			bVGUI.PlayerTooltip.MouseX = Lerp(FrameTime() * 10, bVGUI.PlayerTooltip.MouseX or x, x)
			bVGUI.PlayerTooltip.MouseY = Lerp(FrameTime() * 10, bVGUI.PlayerTooltip.MouseY or y, y)

			self:SetPos(bVGUI.PlayerTooltip.MouseX + 15, bVGUI.PlayerTooltip.MouseY + 15)
		end

		if (not self.Focused) then
			if (not system.HasFocus()) then
				self:Remove()
			elseif (self.CreatorPanel) then
				if (not IsValid(self.CreatorPanel)) then
					self:Remove()
				elseif (vgui.GetHoveredPanel() ~= self.CreatorPanel) then
					if (self.HoverFrameNumber) then
						if (FrameNumber() > self.HoverFrameNumber) then
							self:Remove()
						end
					else
						self.HoverFrameNumber = FrameNumber() + 1
					end
				end
			end
		end
	end

	local avatar_container = vgui.Create("bVGUI.BlankPanel", pnl)
	avatar_container:SetMouseInputEnabled(true)
	avatar_container:Dock(LEFT)
	avatar_container:DockMargin(0,0,10,0)
	avatar_container:SetWide(110)

	local avatar = vgui.Create("AvatarImage", avatar_container)
	avatar:Dock(TOP)
	avatar:SetSize(avatar_container:GetWide(), avatar_container:GetWide())
	if (IsValid(options.player)) then
		avatar:SetPlayer(options.player, 128)
	else
		avatar:SetSteamID(data.steamid64, 128)
	end

	local usergroup = vgui.Create("bVGUI.InfoBar", avatar_container)
	usergroup:Dock(TOP)
	usergroup:DockMargin(0,10,0,10)
	usergroup:SetText(data.usergroup)
	usergroup:AllowCopy(options.copiedphrase)
	usergroup:SetColor(bVGUI.INFOBAR_COLOR_PURPLE)
	bVGUI.AttachTooltip(usergroup, {Text = "Usergroup"})

	local job = vgui.Create("bVGUI.InfoBar", avatar_container)
	job:Dock(TOP)
	job:DockMargin(0,0,0,10)
	job:SetText(data.team_name)
	job:AllowCopy(options.copiedphrase)
	job:SetColor(data.team_color)
	if (DarkRP) then
		bVGUI.AttachTooltip(job, {Text = "Job"})
	else
		bVGUI.AttachTooltip(job, {Text = "Team"})
	end

	local info_container = vgui.Create("bVGUI.BlankPanel", pnl)
	info_container:Dock(FILL)
	info_container:SetMouseInputEnabled(true)
	info_container.SIG = true

	local nick = vgui.Create("bVGUI.InfoBar", info_container)
	nick:Dock(TOP)
	nick:DockMargin(0,0,0,10)
	nick:SetText(data.nick)
	nick:AllowCopy(options.copiedphrase)
	nick:SetColor(bVGUI.INFOBAR_COLOR_PURPLE)

	local steamid = vgui.Create("bVGUI.InfoBar", info_container)
	steamid:Dock(TOP)
	steamid:DockMargin(0,0,0,10)
	steamid:SetText(data.steamid)
	steamid:AllowCopy(options.copiedphrase)

	local steamid64 = vgui.Create("bVGUI.InfoBar", info_container)
	steamid64:Dock(TOP)
	steamid64:DockMargin(0,0,0,10)
	steamid64:SetText(data.steamid64)
	steamid64:AllowCopy(options.copiedphrase)

	local steam_profile = vgui.Create("bVGUI.Button", info_container)
	steam_profile:Dock(TOP)
	steam_profile:DockMargin(0,0,0,10)
	steam_profile:SetText(bVGUI.L("open_steam_profile"))
	steam_profile:SetColor(bVGUI.BUTTON_COLOR_BLUE)
	function steam_profile:DoClick()
		if (GAS) then
			GAS:OpenURL("https://steamcommunity.com/profiles/" .. steamid64:GetText())
		else
			gui.OpenURL("https://steamcommunity.com/profiles/" .. steamid64:GetText())
		end
	end

	local context_menu = vgui.Create("bVGUI.Button", info_container)
	context_menu:Dock(TOP)
	context_menu:DockMargin(0,0,0,10)
	context_menu:SetText(bVGUI.L("open_context_menu"))
	context_menu:SetColor(bVGUI.BUTTON_COLOR_RED)
	context_menu:SetDisabled(not IsValid(options.player))
	function context_menu:DoClick()
		if (IsValid(options.player)) then
			if (GAS) then GAS:PlaySound("popup") end
			properties.OpenEntityMenu(options.player, LocalPlayer():GetEyeTrace())
		else
			if (GAS) then GAS:PlaySound("error") end
			self:SetDisabled(true)
		end
	end
	
	if (not IsValid(options.player)) then
		pnl.GetPlayerData = function()
			GAS:untimer("PlayerTooltip:Load:" .. data.account_id)
			GAS.OfflinePlayerData:AccountID(tonumber(data.account_id), function(success, offline_data)
				if (not IsValid(pnl)) then return end
				if (success) then
					data.nick = offline_data.nick
					data.usergroup = offline_data.usergroup

					pnl.OriginalTitle = offline_data.nick
					nick:SetText(offline_data.nick)
					usergroup:SetText(offline_data.usergroup)
					if (options.focustip) then
						pnl:SetTitle(offline_data.nick .. " · " .. options.focustip)
					else
						pnl:SetTitle(offline_data.nick)
					end
				else
					data.nick = "(unknown)"
					data.usergroup = "(unknown)"

					pnl.OriginalTitle = bVGUI.L("unknown")
					nick:SetText(bVGUI.L("unknown"))
					usergroup:SetText(bVGUI.L("unknown"))
					if (options.focustip) then
						pnl:SetTitle(bVGUI.L("unknown") .. " · " .. options.focustip)
					else
						pnl:SetTitle(bVGUI.L("unknown"))
					end
				end
			end)
			pnl.GetPlayerData = nil
		end
		if (GAS.OfflinePlayerData.data[data.account_id] ~= nil) then
			pnl.GetPlayerData()
		else
			GAS:timer("PlayerTooltip:Load:" .. data.account_id, .5, 1, function()
				if (not IsValid(pnl)) then return end
				pnl.GetPlayerData()
			end)
		end
	end

	return pnl
end
bVGUI.PlayerTooltip.Focus = function()
	if (IsValid(bVGUI.PlayerTooltip.Panel)) then
		if (GAS) then GAS:PlaySound("flash") end
		bVGUI.PlayerTooltip.Panel.Focused = true
		bVGUI.PlayerTooltip.Panel:MakePopup()
		bVGUI.PlayerTooltip.Panel:MoveToFront()
		bVGUI.PlayerTooltip.Panel:SetTitle(bVGUI.PlayerTooltip.Panel.OriginalTitle)
		bVGUI.PlayerTooltip.Panel:SetDrawOnTop(false)
		if (bVGUI.PlayerTooltip.Panel.GetPlayerData) then
			bVGUI.PlayerTooltip.Panel.GetPlayerData()
		end
	end
end

bVGUI.PlayerTooltip.Attach = function(pnl, options)
	options.creator = pnl
	if (pnl.bVGUI_PlayerTooltipOptions) then
		pnl.bVGUI_PlayerTooltipOptions = options
		return
	else
		pnl.bVGUI_PlayerTooltipOptions = options
	end

	pnl.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_ENTER = pnl.OnCursorEntered
	pnl.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_EXIT = pnl.OnCursorExited
	function pnl:OnCursorEntered(...)
		bVGUI.PlayerTooltip.Create(self.bVGUI_PlayerTooltipOptions)
		if (self.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_ENTER) then self.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_ENTER(self, ...) end
	end
	function pnl:OnCursorExited(...)
		bVGUI.PlayerTooltip.Close()
		if (self.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_EXIT) then self.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_EXIT(self, ...) end
	end
end

bVGUI.PlayerTooltip.Unattach = function(pnl)
	pnl.bVGUI_PlayerTooltipOptions = nil
	pnl.OnCursorEntered = pnl.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_ENTER
	pnl.OnCursorExited = pnl.bVGUI_PLAYER_TOOLTIP_OLD_CURSOR_EXIT
end
--PATH lua/vgui/bvgui/scrollpanel.lua:
return gluapack()()
--PATH lua/vgui/bvgui/scrollpanel.lua:
local PANEL = {}

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar:SetHideButtons(true)
	self.VBar:SetWide(5)
	self.VBar:DockMargin(0,0,0,0)

	function self.VBar:Paint() end
	function self.VBar.btnGrip:Paint(w,h)
		surface.SetDrawColor(150,150,150,100)
		surface.DrawRect(0,0,w,h)
	end

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	function self.VBar:PerformLayout()

		local Wide = self:GetWide()
		local BtnHeight = Wide
		if ( self:GetHideButtons() ) then BtnHeight = 0 end
		local Scroll = self:GetScroll() / self.CanvasSize
		local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
		local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
		Track = Track + 1

		Scroll = Scroll * Track

		self.TargetY = BtnHeight + Scroll
		self.btnGrip:SetSize( Wide, BarSize )

		if ( BtnHeight > 0 ) then
			self.btnUp:SetPos( 0, 0, Wide, Wide )
			self.btnUp:SetSize( Wide, BtnHeight )

			self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
			self.btnDown:SetSize( Wide, BtnHeight )
			
			self.btnUp:SetVisible( true )
			self.btnDown:SetVisible( true )
		else
			self.btnUp:SetVisible( false )
			self.btnDown:SetVisible( false )
			self.btnDown:SetSize( Wide, BtnHeight )
			self.btnUp:SetSize( Wide, BtnHeight )
		end

	end

	function self.VBar:Think()
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
		self.btnGrip:SetPos(0, math.Round(self.CurrentY))
	end

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	function self.pnlCanvas:Think()
		self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
		self:SetPos(0, math.Round(self.CurrentOffset))
	end
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayoutInternal()

	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide )

	self:Rebuild()

	if ( Tall != self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
	end

end

derma.DefineControl("bVGUI.ScrollPanel", nil, PANEL, "DScrollPanel")
--PATH lua/vgui/bvgui/table.lua:
bVGUI.TABLE_COLUMN_GROW   = 0
bVGUI.TABLE_COLUMN_SHRINK = 1

--/// bVGUI.Table ///--

local PANEL = {}

function PANEL:Init()
	self.Columns = {}
	self.Rows = {}
	self.ColumnWidths = {}

	self.ColumnContainer = vgui.Create("DPanel", self)
	self.ColumnContainer:Dock(TOP)
	self.ColumnContainer.Paint = nil

	self.RowContainer = vgui.Create("bVGUI.ScrollPanel", self)
	self.RowContainer:Dock(FILL)
	self.RowContainer.Paint = nil

	self.TextSize = 14
	self.RowContainer.OnMouseWheeled_Old = self.RowContainer.OnMouseWheeled
	function self.RowContainer:OnMouseWheeled(delta)
		if (input.IsKeyDown(KEY_LCONTROL)) then
			local tbl = self:GetParent()
			if (delta > 0) then
				tbl.TextSize = math.min(tbl.TextSize + 1, 18)
			else
				tbl.TextSize = math.max(tbl.TextSize - 1, 10)
			end
			for _,row in ipairs(tbl.Rows) do
				row.Font = bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", tbl.TextSize)
			end
			tbl:InvalidateLayout(true)
			tbl:InvalidateChildren(true)
		else
			self:OnMouseWheeled_Old(delta)
		end
	end

	self.NoData = vgui.Create("DLabel", self)
	self.NoData:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.NoData:SetTextColor(bVGUI.COLOR_WHITE)
	self.NoData:SetText(bVGUI.L("no_data"))
	self.NoData:SizeToContents()

	self.NoResultsFound = vgui.Create("DLabel", self)
	self.NoResultsFound:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.NoResultsFound:SetTextColor(bVGUI.COLOR_WHITE)
	self.NoResultsFound:SetText(bVGUI.L("no_results_found"))
	self.NoResultsFound:SizeToContents()
	self.NoResultsFound:SetVisible(false)
end

function PANEL:SetRowCursor(cursor)
	self.RowCursor = cursor
end
function PANEL:GetRowCursor()
	return self.RowCursor
end

function PANEL:Clear()
	for _,v in ipairs(self.Rows) do
		v:Remove()
	end
	self.Rows = {}
	self:InvalidateLayout(true)
end

function PANEL:AddColumn(name, sizing, alignment, color)
	local column = vgui.Create("bVGUI.Table_Column", self.ColumnContainer)
	column:SetText(name)
	column:SetColor(color or Color(51, 80, 114))
	column:SetSizing(sizing or bVGUI.TABLE_COLUMN_GROW)
	column:SetAlignment(alignment or TEXT_ALIGN_LEFT)
	column:SetDrawBorder(false)

	table.insert(self.Columns, column)

	return column
end

function PANEL:AddRow(...)
	local row = vgui.Create("bVGUI.Table_Row", self.RowContainer)
	row.RowIndex = table.insert(self.Rows, row)
	row.LabelsData = {...}
	row:InvalidateLayout(true)
	if (self.RowCursor) then
		row:SetCursor(self.RowCursor)
	end
	self:InvalidateLayout(true)

	return row
end

function PANEL:RemoveRow(index_or_row)
	local row
	if (type(index_or_row) == "number") then
		row = self.Rows[index_or_row]
	elseif (IsValid(index_or_row)) then
		row = index_or_row
	else
		return
	end
	self.Rows[row.RowIndex] = nil
	row:Remove()
	local new_rows = {}
	local i = 0
	for _,v in pairs(self.Rows) do
		i = i + 1
		table.insert(new_rows, v)
		v.RowIndex = i
	end
	self.Rows = new_rows
	self:InvalidateLayout(true)
end

function PANEL:RerenderMarkups()
	for _,row in pairs(self.Rows) do
		row.LabelsMarkup = nil
	end
end

function PANEL:PerformLayout()
	self.ColumnWidths = {}

	local cur_space = self:GetWide()
	if (self.IconLayout) then cur_space = cur_space - 16 - 10 end
	local grow_count = 0
	for i,v in pairs(self.Columns) do
		if (v.Sizing == bVGUI.TABLE_COLUMN_SHRINK) then
			v:SizeToContents()
			v.Label:SizeToContents()
			local width = v.Label:GetWide() + 26
			for _,row in ipairs(self.Rows) do
				if (row.LabelsMarkup) then
					width = math.max(width, row.LabelsMarkup[i]:GetWidth() + 14)
				end
			end
			v:SetWide(width)
			v:InvalidateLayout(true)
			cur_space = cur_space - width
			self.ColumnWidths[i] = width
		else
			grow_count = grow_count + 1
		end
	end

	local grow_width = cur_space / grow_count
	for i,v in pairs(self.Columns) do
		if (v.Sizing == bVGUI.TABLE_COLUMN_GROW) then
			v:SetWide(grow_width)
			self.ColumnWidths[i] = grow_width
			for _,row in ipairs(self.Rows) do
				if (row.LabelsMarkup) then
					row.LabelsMarkup[i] = markup.Parse("<colour=225,225,225><font=" .. row.Font .. ">" .. row.LabelsData[i] .. "</font></colour>", grow_width - 14)
				end
			end
		end
	end

	self.NoData:Center()
	self.NoResultsFound:Center()
end

function PANEL:SortRows()
	local size_y = 0
	local no_rows = true
	for i,v in pairs(self.Rows) do
		if (not v:IsVisible()) then continue end
		v:AlignTop(size_y)
		size_y = size_y + v:GetTall()
		no_rows = false
	end
	self.NoResultsFound.Visible = no_rows
end

function PANEL:Paint(w,h)
	self:LoadingPaint(w,h)
	if (not self.LoadingState or self.LoadingState ~= self:GetLoading()) then
		self.LoadingState = self:GetLoading()
		self.NoData:SetVisible(self:GetLoading() == false and #self.Rows == 0)
	end
	self.NoResultsFound:SetVisible(not self.NoData:IsVisible() and self:GetLoading() ~= true and self.NoResultsFound.Visible)

	surface.SetDrawColor(51, 80, 114)
	surface.DrawRect(0,0,w,23)

	surface.SetDrawColor(31, 48, 68)
	surface.DrawLine(0,23,w,23)
end

derma.DefineControl("bVGUI.Table", nil, PANEL, "bVGUI.LoadingPanel")

--/// bVGUI.Table_Column ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("arrow")
	self:Dock(LEFT)
	self:SetDrawBorder(false)
	self.ColumnBorderColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.4)
	self.ColumnSideColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.4)
end

function PANEL:GetSizing()
	return self.Sizing
end
function PANEL:SetSizing(size_enum)
	self.Sizing = size_enum
end

function PANEL:SetAlignment(alignment)
	self.Alignment = alignment
end
function PANEL:GetAlignment(alignment)
	return self.Alignment
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(self.ColumnBorderColor)
	surface.DrawLine(-1,h - 1,w + 1,h - 1)

	surface.SetDrawColor(self.ColumnSideColor)
	surface.DrawLine(w - 1, 0, w - 1, h - 1)

end

derma.DefineControl("bVGUI.Table_Column", nil, PANEL, "bVGUI.Button")

--/// bVGUI.Table_Row ///--

local PANEL = {}

function PANEL:Init()
	self.Table = self:GetParent():GetParent():GetParent()
	self:Dock(TOP)

	self.Font = bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", self.Table.TextSize)
	self.CurrentFont = self.Font
end

local row_1 = Color(39,44,53)
local row_2 = Color(35,40,48)
function PANEL:Paint(w,h)
	if (self.RowIndex % 2 == 0) then
		surface.SetDrawColor(31, 35, 43)
	else
		surface.SetDrawColor(33, 37, 45)
	end
	surface.DrawRect(0,0,w,h)
	if (self.Highlight) then
		surface.SetDrawColor(255,255,0,4)
		surface.DrawRect(0,0,w,h)
	elseif (self:IsHovered()) then
		surface.SetDrawColor(255,255,255,4)
		surface.DrawRect(0,0,w,h)
	end
	if (not self.LabelsMarkup or self.CurrentFont ~= self.Font) then
		self.CurrentFont = self.Font
		self.LabelsMarkup = {}
		for i,v in pairs(self.LabelsData) do
			if (self.Table.Columns[i]:GetSizing() ~= bVGUI.TABLE_COLUMN_SHRINK) then
				self.LabelsMarkup[i] = markup.Parse("<colour=225,225,225><font=" .. self.Font .. ">" .. v .. "</font></colour>", self.Table.ColumnWidths[i] - 14)
			else
				self.LabelsMarkup[i] = markup.Parse("<colour=225,225,225><font=" .. self.Font .. ">" .. v .. "</font></colour>")
			end
		end
	end
	local cumulative = 0
	local tall = self:GetTall()
	local max_height = 0
	for i,v in pairs(self.LabelsMarkup) do
		local l_padding = 0
		if (self.Table.IconLayout) then
			l_padding = 16 + 10
			if (i == 1) then
				l_padding = l_padding - 5
			end
		end
		if (v:GetWidth() > self.Table.ColumnWidths[i]) then
			self.Table:InvalidateLayout(true)
		end
		local alignment = self.Table.Columns[i]:GetAlignment()
		if (alignment == TEXT_ALIGN_CENTER) then
			v:Draw(l_padding + cumulative + (self.Table.ColumnWidths[i] / 2), tall / 2 - v:GetHeight() / 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		elseif (alignment == TEXT_ALIGN_RIGHT) then
			v:Draw(l_padding + cumulative + self.Table.ColumnWidths[i] - 7, tall / 2 - v:GetHeight() / 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		else
			v:Draw(l_padding + 7 + cumulative, tall / 2 - v:GetHeight() / 2, self.Table.Columns[i]:GetAlignment(), TEXT_ALIGN_TOP)
		end
		if (v:GetHeight() + 10 > max_height) then
			max_height = v:GetHeight() + 10
		end
		cumulative = cumulative + self.Table.ColumnWidths[i]
	end
	if (h ~= max_height) then
		self:SetTall(max_height)
	end
end

function PANEL:OnMouseReleased(key_code)
	if (key_code == MOUSE_LEFT) then
		self.Table.SelectedRow = self.RowIndex
		if (self.Table.OnRowClicked) then
			self.Table:OnRowClicked(self, self.CurrentHoveredColumn)
		end
	elseif (key_code == MOUSE_RIGHT) then
		if (self.Table.OnRowRightClicked) then
			self.Table:OnRowRightClicked(self, self.CurrentHoveredColumn)
		end
	end
end

function PANEL:OnCursorMoved(x)
	if (not self.Table.OnColumnHovered) then return end
	local cumulative_width = 0
	local hovered_column = nil
	for i,v in pairs(self.Table.ColumnWidths) do
		if (x >= cumulative_width) then
			hovered_column = i
		else
			break
		end
		cumulative_width = cumulative_width + v
	end
	if (self.CurrentHoveredColumn ~= hovered_column) then
		self.CurrentHoveredColumn = hovered_column
		self.Table:OnColumnHovered(self, hovered_column)
	end
end
function PANEL:OnCursorExited()
	if (not self.Table.OnColumnHovered) then return end
	self.CurrentHoveredColumn = nil
	self.Table:OnColumnHovered(self, nil)
end

function PANEL:SetIcon(path)
	self:SetMaterial(Material(path))
end
function PANEL:SetMaterial(mat)
	self.Table.IconLayout = true
	self.Table.ColumnContainer:DockPadding(16 + 10,0,0,0)
	self.Table.RowContainer:DockPadding(16 + 10,0,0,0)
	if (not IsValid(self.Icon)) then
		self.Icon = vgui.Create("DImage", self)
		self.Icon:SetSize(16,16)
		self.Icon:AlignLeft(5)
		self.Icon:CenterVertical()
	end
	self.Icon:SetMaterial(mat)
end

derma.DefineControl("bVGUI.Table_Row", nil, PANEL, "DPanel")
--PATH lua/vgui/cl_fjoy.lua:
return gluapack()()
--PATH lua/vgui/cl_fjoy.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_bBorder", "DrawBorder", FORCE_BOOL )

function PANEL:OnReleased()
	self.pos = nil
	self.p = nil
	self:SetPos(self.posx,self.posy)
end

function PANEL:OnDepressed()
	if self.posx == nil then
	self.posx,self.posy = self:GetPos()
	end
	if self.pos == nil then
	self.pos = {x = gui.MouseX(), y = gui.MouseY()}
	end
	self.p = true
end

function PANEL:Contr(size)
	self.size = size
end

function PANEL:Paint2( w, h )
		surface.SetMaterial(Material("materials/fstands/circle.png"))
    if self:GetStyle() ~= 1 then
        surface.SetDrawColor(self:lessback())
        
        if self:IsHovered() then
            surface.SetDrawColor(self:pulse())
        else
            self.np = CurTime()
        end
        surface.DrawTexturedRect(0,0,w,h)
    else
        
        surface.SetDrawColor(self:GetBackground())
        surface.SetDrawColor(self:Fade(true))
        if self:IsHovered() then
            self.np = math.Clamp(self.np + FrameTime(),0,self:GetTime())
        else

            self.np = math.Clamp(self.np - FrameTime(),0,self:GetTime())
        end
        surface.DrawTexturedRect	(0,0,w,h)
    end
	--
	-- Draw the button text
	--
	return false

end

function PANEL:GetValue()
	return self.ma
end

function PANEL:Make()

end

function PANEL:Paint(w,h)
	self.size = self.size or self:GetWide()*0.5
	self.last = self.last or CurTime() - 1
	if self.p == true then
		local x = math.Clamp((gui.MouseX() - self.pos.x),-self.size,self.size)
		local y = math.Clamp((gui.MouseY() - self.pos.y),-self.size,self.size)
		self.ma = {x = 0, y=0}
		if math.abs(x) > self.size*0.2 then
			self.ma.x = x/self.size
		end
		if math.abs(y) > self.size*0.2 then
			self.ma.y = y/self.size
		end
		if (math.abs(x) > self.size*0.2 or math.abs(y) > self.size*0.2) and self.last < CurTime() - 0.05 then
			self.last = CurTime()
			self:Make(self:GetValue())
		end 
	self:SetPos(x +self.posx, y + self.posy)
	
	end
	self:Paint2(w,h)
end

local PANEL = derma.DefineControl( "FJoy", "Custom made joystick", PANEL, "FButton" )
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/vgui/gas_logging_damagelog.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "logging")
	else
		return GAS:PhraseFormat(phrase, "logging", ...)
	end
end

surface.CreateFont("gas_logging_damagelog_pct", {
	size = 24,
	font = "Circular Std Medium",
	bold = true,
})

surface.CreateFont("gas_logging_damagelog_delay", {
	size = 12,
	font = "Circular Std Medium"
})

local module_icon_cache = {}
local module_noicon = Material("icon16/page_white_text.png")
local function GetModuleIcon(module_id)
	if (module_icon_cache[module_id]) then
		return module_icon_cache[module_id]
	else
		local module_data = GAS.Logging.IndexedModules[module_id]
		if (module_data.Icon ~= nil) then
			local mat = Material(module_data.Icon)
			module_icon_cache[module_id] = mat
			return mat
		else
			return module_noicon
		end
	end
end

GAS_Logging_PvPEventReports = {}

local PANEL = {}

function PANEL:DoClick()
	local this = self

	GAS:PlaySound("popup")
	if (IsValid(GAS_Logging_PvPEventReports[self.data[GAS.Logging.PvP_EVENT_ID]])) then
		GAS_Logging_PvPEventReports[self.data[GAS.Logging.PvP_EVENT_ID]]:MakePopup()
		GAS_Logging_PvPEventReports[self.data[GAS.Logging.PvP_EVENT_ID]]:Center()
	else
		local total_time = this.data[GAS.Logging.PvP_LAST_UPDATED] - this.data[GAS.Logging.PvP_PRECISE_CREATION_TIME]

		local pvp_event_report = vgui.Create("bVGUI.Frame")
		pvp_event_report.data = self.data

		GAS_Logging_PvPEventReports[self.data[GAS.Logging.PvP_EVENT_ID]] = pvp_event_report

		pvp_event_report:SetSize(800,500)
		pvp_event_report:SetMinimumSize(pvp_event_report:GetSize())
		pvp_event_report:SetTitle(L"pvp_event_report")
		pvp_event_report:MakePopup()
		pvp_event_report:Center()
		function pvp_event_report:OnClose()
			GAS.Logging.Scenes:ClearScene(pvp_event_report.data[GAS.Logging.PvP_COMBAT_SCENE])
			if (IsValid(this) and this.DeleteMeOnClose) then
				this:Remove()
			end
		end

		local info_container = vgui.Create("bVGUI.BlankPanel", pvp_event_report)
		info_container:Dock(FILL)

		local scene_container = vgui.Create("bVGUI.BlankPanel", pvp_event_report)
		scene_container:Dock(LEFT)
		scene_container:SetWide(200)

			local scene_beginning = vgui.Create("bVGUI.RenderScene", scene_container)
			scene_beginning:SetLabel(L"event_start")
			function scene_beginning:OnStartRender()
				GAS.Logging.Scenes:ViewScene(pvp_event_report.data[GAS.Logging.PvP_COMBAT_SCENE], true, function(pos, ang)
					if (not IsValid(self)) then return end
					if (self.SetDefaultPositioning) then return end
					self.SetDefaultPositioning = true
					self:SetOrigin(pos)
					self:SetAngle(ang)
				end)
			end
			function scene_beginning:OnEndRender()
				GAS.Logging.Scenes:ClearScene(pvp_event_report.data[GAS.Logging.PvP_COMBAT_SCENE], true)
			end

			local scene_end = vgui.Create("bVGUI.RenderScene", scene_container)
			scene_end:SetCanRender(not self.data[GAS.Logging.PvP_ONGOING])
			scene_end:SetLabel(L"event_end")
			function scene_end:OnStartRender()
				GAS.Logging.Scenes:ViewScene(pvp_event_report.data[GAS.Logging.PvP_COMBAT_SCENE], false, function(pos, ang)
					if (not IsValid(self)) then return end
					if (self.SetDefaultPositioning) then return end
					self.SetDefaultPositioning = true
					self:SetOrigin(pos)
					self:SetAngle(ang)
				end)
			end
			function scene_end:OnEndRender()
				GAS.Logging.Scenes:ClearScene(pvp_event_report.data[GAS.Logging.PvP_COMBAT_SCENE], false)
			end

			function scene_container:PerformLayout(w,_h)
				local h = _h + 5
				scene_beginning:SetSize(w,h/2)
				scene_end:SetSize(w,h/2)
				scene_end:AlignTop((h/2)-5)
			end

		local timeline = vgui.Create("bVGUI.BlankPanel", info_container)
		timeline:SetMouseInputEnabled(true)
		timeline:Dock(TOP)
		timeline:SetTall(70)
		timeline.Scale = math.max(1, total_time * 1.25)
		timeline.BlipOffset = 0
		timeline.DmgEventBlips = {}
		function timeline:OnMouseWheeled(delta)
			local scale_change = timeline.Scale
			if (delta == 1) then
				timeline.Scale = timeline.Scale * 2
			elseif (delta == -1) then
				timeline.Scale = timeline.Scale / 2
			end
			local max_scale = math.max(4, total_time * 1.25)

			timeline.Scale = math.Clamp(timeline.Scale, 0.25, max_scale)

			local x,y = timeline:ScreenToLocal(gui.MousePos())
			if (timeline.Scale >= max_scale) then
				timeline.BlipOffset = 0
			end

			timeline:RefreshBlips()
			timeline:RefreshDelayMarkup()
		end

		local blip_size = 7.5
		function timeline:RefreshBlips()
			local w,h = self:GetSize()

			local y_offset = 14 + 10

			timeline.DmgEventBlips = {}
			for i,log in ipairs(pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS]) do
				if (type(log[1]) == "table") then continue end

				local place = (log[1] / total_time) * (w * (total_time / timeline.Scale)) - timeline.BlipOffset

				local blip = {
					{x = place, y = y_offset},
					{x = place + blip_size, y = blip_size + y_offset},
					{x = place, y = (blip_size * 2) + y_offset},
					{x = place - blip_size, y = blip_size + y_offset},
				}
				if (log[3] == pvp_event_report.data[GAS.Logging.PvP_VICTIM] and log[4] == pvp_event_report.data[GAS.Logging.PvP_INSTIGATOR]) then
					timeline.DmgEventBlips[i] = {true, blip}
				elseif (log[3] == pvp_event_report.data[GAS.Logging.PvP_INSTIGATOR] and log[4] == pvp_event_report.data[GAS.Logging.PvP_VICTIM]) then
					timeline.DmgEventBlips[i] = {false, blip}
				else
					timeline.DmgEventBlips[i] = {nil, blip}
				end
			end
		end
		timeline:RefreshBlips()

		function timeline:RefreshDelayMarkup()
			local x,y = self:ScreenToLocal(gui.MousePos())
			local w,h = self:GetSize()
			if (x >= 0) then
				self.DelayMarkup = markup.Parse("<font=gas_logging_damagelog_delay>+" .. math.Round((x / (w * (total_time / self.Scale))) * total_time, 2) .. "s</font>")
			else
				self.DelayMarkup = markup.Parse("<font=gas_logging_damagelog_delay>+0s</font>")
			end
		end

		function timeline:PerformLayout()
			timeline:RefreshBlips()
		end

		local pvp_event = vgui.Create("GAS.Logging.DamageLog", info_container)
		pvp_event:Dock(TOP)
		pvp_event:Setup(self.data, false)

		local tabs = vgui.Create("bVGUI.Tabs", info_container)
		tabs:Dock(TOP)
		tabs:SetTall(40)

		local logs_tab_content, logs_tab = tabs:AddTab(L"logs", Color(216,76,76))
			
			local log_tbl = vgui.Create("bVGUI.Table", logs_tab_content)
			log_tbl:Dock(FILL)
			log_tbl:AddColumn(L"log", bVGUI.TABLE_COLUMN_GROW)
			log_tbl:AddColumn(L"instigator_abbr", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
			log_tbl:AddColumn(L"victim_abbr", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
			log_tbl:AddColumn(L"time", bVGUI.TABLE_COLUMN_SHRINK, TEXT_ALIGN_CENTER)
			for i,log in ipairs(this.data[GAS.Logging.PvP_EVENT_LOGS]) do
				if (type(log[1]) == "table") then
					local row = log_tbl:AddRow(GAS.Logging:FormatMarkupLog(log, nil, nil, this.data[GAS.Logging.PvP_VICTIM], this.data[GAS.Logging.PvP_INSTIGATOR]), "-", "-", "+" .. math.Round(this.data[GAS.Logging.PvP_EVENT_LOGS_CHRONOLOGY][i], 2) .. "s")
					local icon = GetModuleIcon(log[2])
					row:SetMaterial(icon)
				else
					local instigator_dmg = "-"
					local victim_dmg = "-"
					if (log[3] == this.data[GAS.Logging.PvP_VICTIM]) then
						victim_dmg = "<color=0,255,0>" .. math.Round(log[6], 2) .. "</color>"
					elseif (log[3] == this.data[GAS.Logging.PvP_INSTIGATOR]) then
						instigator_dmg = "<color=255,0,0>" .. math.Round(log[6], 2) .. "</color>"
					end
					log_tbl:AddRow(GAS.Logging:FormatMarkupLogCustom(GAS:Phrase(log[2], "logging", "Logs"), log[5], nil, nil, this.data[GAS.Logging.PvP_VICTIM], this.data[GAS.Logging.PvP_INSTIGATOR]), instigator_dmg, victim_dmg, "+" .. math.Round(log[1], 2) .. "s")
				end
			end

		local weapons_tab_content, weapons_tab = tabs:AddTab(L"weapons", Color(76,76,216))

			local weapons_grid = vgui.Create("bVGUI.Grid", weapons_tab_content)
			weapons_grid:Dock(FILL)
			weapons_grid:SetPadding(10,10)

			local merged_weps = {}
			for weapon_class, dmg in pairs(pvp_event_report.data[GAS.Logging.PvP_INSTIGATOR_WEPS]) do
				merged_weps[weapon_class] = merged_weps[weapon_class] or {0,0}
				merged_weps[weapon_class][1] = merged_weps[weapon_class][1] + dmg
			end
			for weapon_class, dmg in pairs(pvp_event_report.data[GAS.Logging.PvP_VICTIM_WEPS]) do
				merged_weps[weapon_class] = merged_weps[weapon_class] or {0,0}
				merged_weps[weapon_class][2] = merged_weps[weapon_class][2] + dmg
			end

			for weapon_class, dmgs in pairs(merged_weps) do
				local ent_display = vgui.Create("GAS.Logging.EntityDisplay", weapons_grid)
				ent_display:SetWeapon(weapon_class)
				ent_display:SetDrawOnTop(false)
				ent_display.Think = nil
				weapons_grid:AddToGrid(ent_display)
			end

		local linked_events_tab_content, linked_events_tab = tabs:AddTab(L"linked_events", Color(216,76,76))



		local log_tbl_highlights = {}
		local timeline_hover_last_prev_frame
		local timeline_hover_exact_prev_frame
		function timeline:Paint(w,h)
			local x,y = self:ScreenToLocal(gui.MousePos())
			local target_time_point = (x / (w * (total_time / self.Scale))) * total_time
			local target_time_point_rnd = math.Round(target_time_point, 2)

			if (x ~= self.StoreX) then
				self.StoreX = x
				timeline:RefreshDelayMarkup()
			end

			surface.SetDrawColor(26,26,26)
			surface.DrawRect(0,0,w,h)

			surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT_LARGE)
			surface.DrawTexturedRect(0,0,w,h)

			surface.SetDrawColor(50, 50, 50)
			local spacing = w / self.Scale
			for i=1,self.Scale do
				surface.DrawLine((i - 1) * spacing,0,(i - 1) * spacing,h)
			end
			if (self.Scale < 5) then
				local spacing = w / math.floor(self.Scale / .25)
				for i=1,math.floor(self.Scale / .25) do
					if ((i - 1) % 4 == 0) then continue end
					if ((i - 1) % 2 == 0) then
						surface.SetDrawColor(37, 37, 37)
					else
						surface.SetDrawColor(30, 30, 30)
					end
					surface.DrawLine((i - 1) * spacing,0,(i - 1) * spacing,h)
				end
			end

			surface.SetDrawColor(181,39,39)
			surface.DrawRect(0,0,w,14)

			surface.SetDrawColor(181,39,39)
			surface.DrawRect(0,0,w * (total_time / self.Scale),14)

			if (self.DelayMarkupW ~= nil and x >= 0 and x <= w) then
				surface.SetDrawColor(0,0,0,200)
				surface.DrawRect(x - ((self.DelayMarkupW + 15) / 2),0,self.DelayMarkupW + 15,14)
			end

			local timeline_hover_exact
			local timeline_hover_last = target_time_point > total_time
			if (timeline_hover_last) then
				for k,v in pairs(log_tbl_highlights) do
					if (k ~= #pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS]) then
						log_tbl_highlights = {}
						break
					end
				end
				log_tbl_highlights[#pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS]] = true
			elseif (timeline_hover_last_prev_frame ~= timeline_hover_last) then
				log_tbl_highlights[#pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS]] = nil
			end
			timeline_hover_last_prev_frame = timeline_hover_last

			for i,log in ipairs(pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS]) do
				local time_point
				if (type(log[1]) == "table") then
					-- event log
					time_point = pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS_CHRONOLOGY][i]

					local icon = GetModuleIcon(log[2])
					surface.SetDrawColor(255,255,255)
					surface.SetMaterial(icon)
					surface.DrawTexturedRect((time_point / total_time) * (w * (total_time / self.Scale)) - (16 / 2) - timeline.BlipOffset, h - 16 - 10, 16, 16)
				else
					-- damage log
					local poly = timeline.DmgEventBlips[i]
					draw.NoTexture()
					if (poly[1] == true) then
						surface.SetDrawColor(215,50,50,200)
					elseif (poly[1] == false) then
						surface.SetDrawColor(50,215,50,200)
					else
						surface.SetDrawColor(50,50,215,200)
					end
					surface.DrawPoly(poly[2])

					time_point = log[1]
				end

				if (not timeline_hover_last) then
					local time_point_rnd = math.Round(time_point, 2)
					if (timeline_hover_exact ~= nil) then
						log_tbl_highlights[i] = (time_point_rnd == timeline_hover_exact) or nil
					elseif (time_point_rnd == target_time_point_rnd) then
						timeline_hover_exact = target_time_point_rnd
						log_tbl_highlights[i] = true
					else
						if (i ~= 1 and target_time_point < time_point) then
							local prev = pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS][i - 1]
							local prev_time_point = prev[1]
							if (type(prev[1]) == "table") then
								prev_time_point = pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS_CHRONOLOGY][i - 1]
							end
							if (target_time_point > prev_time_point) then
								local median = (prev_time_point + time_point) / 2
								if (target_time_point > median) then
									log_tbl_highlights[i] = true
									log_tbl_highlights[i - 1] = nil
								else
									log_tbl_highlights[i] = nil
									log_tbl_highlights[i - 1] = true
								end
							else
								log_tbl_highlights[i] = nil
							end
						elseif (i ~= #pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS] and target_time_point > time_point) then
							local next = pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS][i + 1]
							local next_time_point = next[1]
							if (type(next[1]) == "table") then
								next_time_point = pvp_event_report.data[GAS.Logging.PvP_EVENT_LOGS_CHRONOLOGY][i + 1]
							end
							if (target_time_point < next_time_point) then
								local median = (next_time_point + time_point) / 2
								if (target_time_point > median) then
									log_tbl_highlights[i] = nil
									log_tbl_highlights[i + 1] = true
								else
									log_tbl_highlights[i] = true
									log_tbl_highlights[i + 1] = nil
								end
							else
								log_tbl_highlights[i] = nil
							end
						end
					end
				end
			end

			if (x >= 0 and x <= w) then
				surface.SetDrawColor(100,100,100)
				surface.DrawLine(x,14,x,h)

				if (self.DelayMarkup) then
					self.DelayMarkup:Draw(x, 7, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					self.DelayMarkupW = self.DelayMarkup:GetWidth()
				end
			elseif (next(log_tbl_highlights) ~= nil) then
				log_tbl_highlights = {}
			end

			for i,row in ipairs(log_tbl.Rows) do
				row.Highlight = log_tbl_highlights[i] == true
				if (row.Highlight and pvp_event_report:HasFocus() and (not IsValid(vgui.GetHoveredPanel()) or not log_tbl:IsOurChild(vgui.GetHoveredPanel()))) then
					if (self.ScrollToChild_Prev ~= row) then
						self.ScrollToChild_Prev = row
						log_tbl.RowContainer:ScrollToChild(row)
					end
				end
			end
		end

		pvp_event_report:EnableUserResize()
	end
end
function PANEL:OnMousePressed(m)
	self._pressed = m
end
function PANEL:OnMouseReleased(m)
	if (self._pressed == m) then
		if (m == MOUSE_LEFT and self.DoClick) then
			self:DoClick()
		end
		self._pressed = nil
	end
end

function PANEL:Init()
	self:SetMouseInputEnabled(true)

	self:SetTall(95)

	self.InstigatorAvatar = vgui.Create("AvatarImage", self)
	self.InstigatorAvatar:SetSize(48,48)
	self.InstigatorAvatar:SetCursor("hand")
	self.InstigatorAvatar:SetMouseInputEnabled(true)
	function self.InstigatorAvatar:OnMouseReleased(m) if m ~= MOUSE_LEFT then return else bVGUI.PlayerTooltip.Focus() end end

	self.InstigatorDead = vgui.Create("DLabel", self)
	self.InstigatorDead:SetTextColor(Color(255,0,0))
	self.InstigatorDead:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.InstigatorDead:SetContentAlignment(4)
	self.InstigatorDead:SetText("")
	self.InstigatorDead:SetWide(0)

	self.InstigatorTag = vgui.Create("DLabel", self)
	self.InstigatorTag:SetTextColor(Color(255,0,0))
	self.InstigatorTag:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.InstigatorTag:SetText("[" .. string.upper(L"instigator") .. "]")
	self.InstigatorTag:SetContentAlignment(4)
	self.InstigatorTag:SizeToContents()
	bVGUI.AttachTooltip(self.InstigatorTag, {
		Text = L"instigator_tag_tip",
	})

	self.InstigatorName = vgui.Create("DLabel", self)
	self.InstigatorName:SetTextColor(bVGUI.COLOR_WHITE)
	self.InstigatorName:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.InstigatorName:SetText("")
	self.InstigatorName:SetContentAlignment(4)
	self.InstigatorName:SetCursor("hand")
	self.InstigatorName:SetMouseInputEnabled(true)
	function self.InstigatorName:DoClick() bVGUI.PlayerTooltip.Focus() end

	self.InstigatorPrimaryWep = vgui.Create("DLabel", self)
	self.InstigatorPrimaryWep:SetTextColor(GAS.Logging.LogFormattingSettings.Colors.Weapon)
	self.InstigatorPrimaryWep:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.InstigatorPrimaryWep:SetText("")
	self.InstigatorPrimaryWep:SetContentAlignment(4)
	self.InstigatorPrimaryWep:SetMouseInputEnabled(true)

	self.VictimAvatar = vgui.Create("AvatarImage", self)
	self.VictimAvatar:SetSize(48,48)
	self.VictimAvatar:SetCursor("hand")
	self.VictimAvatar:SetMouseInputEnabled(true)
	function self.VictimAvatar:OnMouseReleased(m) if m ~= MOUSE_LEFT then return else bVGUI.PlayerTooltip.Focus() end end

	self.VictimDead = vgui.Create("DLabel", self)
	self.VictimDead:SetTextColor(Color(255,0,0))
	self.VictimDead:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.VictimDead:SetContentAlignment(4)
	self.VictimDead:SetText("")
	self.VictimDead:SetWide(0)

	self.VictimTag = vgui.Create("DLabel", self)
	self.VictimTag:SetTextColor(Color(0,255,0))
	self.VictimTag:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.VictimTag:SetText("[" .. string.upper(L"victim") .. "]")
	self.VictimTag:SetContentAlignment(6)
	self.VictimTag:SizeToContents()
	bVGUI.AttachTooltip(self.VictimTag, {
		Text = L"victim_tag_tip",
	})

	self.VictimName = vgui.Create("DLabel", self)
	self.VictimName:SetTextColor(bVGUI.COLOR_WHITE)
	self.VictimName:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.VictimName:SetText("")
	self.VictimName:SetContentAlignment(6)
	self.VictimName:SetCursor("hand")
	self.VictimName:SetMouseInputEnabled(true)
	function self.VictimName:DoClick() bVGUI.PlayerTooltip.Focus() end

	self.VictimPrimaryWep = vgui.Create("DLabel", self)
	self.VictimPrimaryWep:SetTextColor(GAS.Logging.LogFormattingSettings.Colors.Weapon)
	self.VictimPrimaryWep:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.VictimPrimaryWep:SetText("")
	self.VictimPrimaryWep:SetContentAlignment(6)
	self.VictimPrimaryWep:SetMouseInputEnabled(true)

	self.FlagMetadata = {
		{GAS.Logging.PvP_FLAG_ONGOING, L"flag_ongoing", "icon16/lightbulb.png"},
		{GAS.Logging.PvP_FLAG_FINISHED, L"flag_finished", "icon16/lightbulb_off.png"},
		{GAS.Logging.PvP_FLAG_SUPERADMIN, L"flag_superadmin", "icon16/shield_add.png"},
		{GAS.Logging.PvP_FLAG_ADMIN, L"flag_admin", "icon16/shield.png"},
		{GAS.Logging.PvP_FLAG_FRIENDLYFIRE, L"flag_friendly_fire", "icon16/emoticon_unhappy.png"},
		{GAS.Logging.PvP_FLAG_LAWENFORCEMENT, L"flag_law_enforcement", "icon16/bell.png"},
		{GAS.Logging.PvP_FLAG_INSTIGATOR_DEATH, L"flag_instigator_death", "icon16/status_busy.png"},
		{GAS.Logging.PvP_FLAG_VICTIM_DEATH, L"flag_victim_death", "icon16/status_offline.png"},
		{GAS.Logging.PvP_FLAG_VEHICLE, L"flag_vehicle", "icon16/car.png"},
		{GAS.Logging.PvP_FLAG_WORLD, L"flag_world", "icon16/world.png"},
		{GAS.Logging.PvP_FLAG_PROPS, L"flag_props", "icon16/bricks.png"},
		{GAS.Logging.PvP_FLAG_TEAM_SWITCHED, L"flag_team_switched", "icon16/arrow_refresh.png"},
		{GAS.Logging.PvP_FLAG_DISCONNECT, L"flag_disconnect", "icon16/disconnect.png"},
		{GAS.Logging.PvP_FLAG_LINKED, L"flag_linked", "icon16/link.png"},
	}

	self.LogTypeMetadata = {
		[GAS.Logging.PvP_LOG_TYPE_CHAT] = {L"log_type_chat", "icon16/user_comment.png"},
		[GAS.Logging.PvP_LOG_TYPE_CHAT_TEAM] = {L"log_type_team_chat", "icon16/group.png"},
		[GAS.Logging.PvP_LOG_TYPE_WEAPON_PICKUP] = {L"log_type_weapon_pickup", "icon16/bomb.png"},
		[GAS.Logging.PvP_LOG_TYPE_WEAPON_DROPPED] = {L"log_type_weapon_drop", "icon16/arrow_down.png"},
		[GAS.Logging.PvP_LOG_TYPE_ITEM_PICKUP] = {L"log_type_item_pickup", "icon16/coins.png"},
		[GAS.Logging.PvP_LOG_TYPE_SPAWNMENU] = {L"log_type_spawnmenu", "icon16/bricks.png"},
		[GAS.Logging.PvP_LOG_TYPE_DARKRP_PURCHASE] = {L"log_type_darkrp_purchase", "icon16/money_add.png"},
		[GAS.Logging.PvP_LOG_TYPE_DISCONNECT] = {L"log_type_disconnect", "icon16/disconnect.png"},
		[GAS.Logging.PvP_LOG_TYPE_WEAPON_SWITCHED] = {L"log_type_weapon_switched", "icon16/arrow_switch.png"},
		[GAS.Logging.PvP_LOG_TYPE_TEAM_SWITCH] = {L"log_type_team_switched", "icon16/arrow_refresh.png"},
		[GAS.Logging.PVP_LOG_TYPE_SILENT_DEATH] = {L"log_type_silent_death", "icon16/status_offline.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_WORLD] = {L"log_type_death_world", "icon16/world.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_PLAYER_WEP] = {L"log_type_death_player_wep", "icon16/wand.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_PLAYER] = {L"log_type_death_player", "icon16/status_offline.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_ENT] = {L"log_type_death_ent", "icon16/status_offline.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH] = {L"log_type_death", "icon16/status_offline.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_PROPKILL_SELF] = {L"log_type_propkill_self", "icon16/box.png"},
		[GAS.Logging.PvP_LOG_TYPE_DEATH_PROPKILL] = {L"log_type_propkill", "icon16/brick_go.png"},
	}

	self.FlagContainer = vgui.Create("bVGUI.BlankPanel", self)
	self.FlagContainer:Dock(RIGHT)
	self.FlagContainer:DockMargin(0,10,10 + 6,10 + 14)
	self.FlagContainer:SetWide(16)
	function self.FlagContainer:PerformLayout(w)
		self.Content:SetWide(w)
		self.Content:AlignRight(0)
		self.Content:CenterVertical()
	end

	self.FlagContainer.Content = vgui.Create("bVGUI.BlankPanel", self.FlagContainer)
	self.FlagContainer.Content:SetTall((3 * (16 + 5)) - 5)

	self.Timestamp = vgui.Create("DLabel", self)
	self.Timestamp:SetTextColor(bVGUI.COLOR_WHITE)
	self.Timestamp:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.Timestamp:SetText("")
	self.Timestamp:SetContentAlignment(4)
	self.Timestamp:SetMouseInputEnabled(true)
end

function PANEL:Setup(data, allow_click)
	if (allow_click == false) then
		self.DoClick = nil
	else
		self:SetCursor("hand")
	end

	self.data = data

	if (self.data[GAS.Logging.PvP_FLAGS][GAS.Logging.PvP_FLAG_INSTIGATOR_DEATH]) then
		self.InstigatorDead:SetText(L"dead_tag")
		self.InstigatorDead:SizeToContents()
	end
	if (self.data[GAS.Logging.PvP_FLAGS][GAS.Logging.PvP_FLAG_VICTIM_DEATH]) then
		self.VictimDead:SetText(L"dead_tag")
		self.VictimDead:SizeToContents()
	end

	self.Timestamp:SetText(GAS:SimplifyTimestamp(self.data[GAS.Logging.PvP_CREATION_TIMESTAMP]))
	self.Timestamp:SizeToContents()
	bVGUI.AttachTooltip(self.Timestamp, {
		Text = GAS:FormatFullTimestamp(self.data[GAS.Logging.PvP_CREATION_TIMESTAMP])
	})

	self.InstigatorAvatar:SetSteamID(GAS:AccountIDToSteamID64(data[GAS.Logging.PvP_INSTIGATOR]), 48)
	self.VictimAvatar:SetSteamID(GAS:AccountIDToSteamID64(data[GAS.Logging.PvP_VICTIM]), 48)

	local instigator = player.GetByAccountID(data[GAS.Logging.PvP_INSTIGATOR])
	if (IsValid(instigator)) then
		self.InstigatorName:SetText(instigator:Nick())
	else
		self.InstigatorName:SetText(data[GAS.Logging.PvP_INSTIGATOR_NICK])
	end
	self.InstigatorName:SizeToContents()

	bVGUI.PlayerTooltip.Attach(self.InstigatorAvatar, {
		account_id = data[GAS.Logging.PvP_INSTIGATOR],
		focustip = L"click_to_focus",
	})

	bVGUI.PlayerTooltip.Attach(self.InstigatorName, {
		account_id = data[GAS.Logging.PvP_INSTIGATOR],
		focustip = L"click_to_focus",
	})

	local instigator_primary_wep = table.GetWinningKey(data[GAS.Logging.PvP_INSTIGATOR_WEPS])
	if (instigator_primary_wep ~= nil) then
		self.InstigatorPrimaryWep:SetText(instigator_primary_wep)
		self.InstigatorPrimaryWep:SizeToContents()

		GAS_Logging_DisplayEntity(function(pnl)
			pnl:SetWeapon(instigator_primary_wep)
		end, self.InstigatorPrimaryWep, true)
	end

	local victim = player.GetByAccountID(data[GAS.Logging.PvP_VICTIM])
	if (IsValid(victim)) then
		self.VictimName:SetText(victim:Nick())
	else
		self.VictimName:SetText(data[GAS.Logging.PvP_VICTIM_NICK])
	end
	self.VictimName:SizeToContents()

	bVGUI.PlayerTooltip.Attach(self.VictimAvatar, {
		account_id = data[GAS.Logging.PvP_VICTIM],
		focustip = L"click_to_focus",
	})

	bVGUI.PlayerTooltip.Attach(self.VictimName, {
		account_id = data[GAS.Logging.PvP_VICTIM],
		focustip = L"click_to_focus",
	})

	local victim_primary_wep = table.GetWinningKey(data[GAS.Logging.PvP_VICTIM_WEPS])
	if (victim_primary_wep ~= nil) then
		self.VictimPrimaryWep:SetText(victim_primary_wep)
		self.VictimPrimaryWep:SizeToContents()

		GAS_Logging_DisplayEntity(function(pnl)
			pnl:SetWeapon(victim_primary_wep)
		end, self.VictimPrimaryWep, true)
	end

	local column = 1
	local count = 0
	for i,v in ipairs(self.FlagMetadata) do
		if (data[GAS.Logging.PvP_FLAGS][v[1]] == true) then
			count = count + 1
			if (count % 3 == 0) then
				column = column + 1
			end
		end
	end
	if (count % 3 == 0) then column = column - 1 end
	self.FlagContainer:SetWide((column * (16 + 5)) - 5)
	if (column == 1) then
		self.FlagContainer.Content:SetTall((count * (16 + 5)) - 5)
	else
		self.FlagContainer.Content:SetTall((3 * (16 + 5)) - 5)
	end
	self.FlagContainer.Content:SetWide((column * (16 + 5)) - 5)
	self.FlagContainer.Content:AlignRight(0)
	self.FlagContainer.Content:CenterVertical()

	local column = 1
	local count = 0
	for i,v in ipairs(self.FlagMetadata) do
		if (data[GAS.Logging.PvP_FLAGS][v[1]] == true) then
			local flag_icon = vgui.Create("DImage", self.FlagContainer.Content)
			flag_icon:SetSize(16,16)
			flag_icon:AlignTop((count % 3) * (16 + 5))
			flag_icon:AlignRight((column - 1) * (16 + 5))
			flag_icon:SetImage(v[3])
			bVGUI.AttachTooltip(flag_icon, {
				Text = v[2]
			})
			count = count + 1
			if (count % 3 == 0) then
				column = column + 1
			end
		end
	end

	self:InvalidateLayout(true)
end

function PANEL:PerformLayout(w,h)
	self.InstigatorAvatar:AlignLeft(10)
	self.InstigatorAvatar:AlignBottom(10 + 14)

	self.VictimAvatar:AlignRight(10 + self.FlagContainer:GetWide() + 10 + 6)
	self.VictimAvatar:AlignBottom(10 + 14)

	self.InstigatorDead:AlignTop(5)
	self.InstigatorDead:AlignLeft(10)

	local instigator_death_margin, victim_death_margin = 0,0
	if (self.InstigatorDead:GetWide() > 0) then
		instigator_death_margin = self.InstigatorDead:GetWide() + 5
	end
	if (self.VictimDead:GetWide() > 0) then
		victim_death_margin = self.VictimDead:GetWide() + 5
	end

	self.InstigatorTag:AlignTop(5)
	self.InstigatorTag:AlignLeft(10 + instigator_death_margin)

	self.InstigatorName:AlignTop(5)
	self.InstigatorName:AlignLeft(10 + instigator_death_margin + self.InstigatorTag:GetWide() + 5)

	self.InstigatorPrimaryWep:AlignTop(5)
	self.InstigatorPrimaryWep:AlignLeft(10 + instigator_death_margin + self.InstigatorTag:GetWide() + 5 + self.InstigatorName:GetWide() + 5)

	self.VictimDead:AlignTop(5)
	self.VictimDead:AlignRight(10 + self.FlagContainer:GetWide() + 10 + 6)

	self.VictimTag:AlignTop(5)
	self.VictimTag:AlignRight(10 + self.FlagContainer:GetWide() + 10 + victim_death_margin + 6)

	self.VictimName:AlignTop(5)
	self.VictimName:AlignRight(10 + self.FlagContainer:GetWide() + 10 + victim_death_margin + self.VictimTag:GetWide() + 5 + 6)

	self.VictimPrimaryWep:AlignTop(5)
	self.VictimPrimaryWep:AlignRight(10 + self.FlagContainer:GetWide() + 10 + self.VictimTag:GetWide() + 5 + self.VictimName:GetWide() + 5 + victim_death_margin + 6)

	self.Timestamp:AlignLeft(10)
	self.Timestamp:AlignBottom(5)

	self.vgui_InstigatorFrac = self.data[GAS.Logging.PvP_INSTIGATOR_DMG_GVN] / self.data[GAS.Logging.PvP_TOTAL_DMG]
	self.vgui_VictimFrac     = self.data[GAS.Logging.PvP_VICTIM_DMG_GVN] / self.data[GAS.Logging.PvP_TOTAL_DMG]
	self.vgui_OtherFrac      = (self.data[GAS.Logging.PvP_TOTAL_DMG] - self.data[GAS.Logging.PvP_INSTIGATOR_DMG_GVN] - self.data[GAS.Logging.PvP_VICTIM_DMG_GVN]) / self.data[GAS.Logging.PvP_TOTAL_DMG]
	if (self.data[GAS.Logging.PvP_TOTAL_DMG] == 0) then self.vgui_OtherFrac = 1 self.vgui_VictimFrac = 0 self.vgui_InstigatorFrac = 0 end

	self.vgui_InstigatorWidth = (w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - 10 - 48 - 10) * self.vgui_InstigatorFrac
	self.vgui_VictimWidth     = (w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - 10 - 48 - 10) * self.vgui_VictimFrac
	self.vgui_OtherWidth      = (w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - 10 - 48 - 10) * self.vgui_OtherFrac
end

function PANEL:OnCursorMoved(x,y)
	local w,h = self:GetSize()
	if (y >= (h - 10 - 48) and y <= h - 10 and x >= 10 + 48 + 10 and x <= w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10) then
		local relative_x = x - 10 - 48 - 10
		local DmgTooltip = self.DmgTooltip
		if (relative_x <= self.vgui_InstigatorWidth) then
			self.DmgTooltip = 1
		elseif (relative_x <= self.vgui_InstigatorWidth + self.vgui_OtherWidth) then
			self.DmgTooltip = 2
		else
			self.DmgTooltip = 3
		end
		if (DmgTooltip ~= self.DmgTooltip) then
			bVGUI.DestroyTooltip()
			local tt = {
				VGUI_Element = self,
			}
			if (self.DmgTooltip == 1) then
				tt.Text = math.Round(self.vgui_InstigatorFrac * 100, 2) .. L"DmgTooltip_Instigator"
				tt.TextColor = Color(216,76,76)
			elseif (self.DmgTooltip == 2) then
				tt.Text = math.Round(self.vgui_OtherFrac * 100, 2) .. L"DmgTooltip_Other"
				tt.TextColor = Color(74,126,214)
			else
				tt.Text = math.Round(self.vgui_VictimFrac * 100, 2) .. L"DmgTooltip_Victim"
				tt.TextColor = Color(76,216,76)
			end
			bVGUI.CreateTooltip(tt)
		end
	else
		self.DmgTooltip = nil
		bVGUI.DestroyTooltip()
	end
end

local stripes = Material("gmodadminsuite/stripes4.png")
function PANEL:Paint(w,h)
	if (self.RowIndex ~= nil and self.RowIndex % 2 ~= 0) then
		surface.SetDrawColor(255,255,255,75)
	else
		surface.SetDrawColor(255,255,255,200)
	end
	surface.SetMaterial(stripes)
	surface.DrawTexturedRect(0,0,w,h)

	surface.SetDrawColor(198,19,19)
	surface.DrawRect(48 + 10 + 10, h - 10 - 48 - 14, self.vgui_InstigatorWidth, 48)

	surface.SetDrawColor(19,198,19)
	surface.DrawRect(w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - self.vgui_VictimWidth, h - 10 - 48 - 14, self.vgui_VictimWidth, 48)

	surface.SetDrawColor(32,32,173)
	surface.DrawRect(48 + 10 + 10 + self.vgui_InstigatorWidth, h - 10 - 48 - 14, self.vgui_OtherWidth, 48)

	surface.SetDrawColor(255,255,255,255)
	surface.SetMaterial(bVGUI.MATERIAL_GRADIENT)
	surface.DrawTexturedRect(10 + 48 + 10,h - 10 - 48 - 14,w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - 48 - 10 - 10,48)

	if (self.vgui_InstigatorWidth >= 50) then
		draw.SimpleText(math.Round(self.vgui_InstigatorFrac * 100) .. "%", "gas_logging_damagelog_pct", 10 + 48 + 10 + (self.vgui_InstigatorWidth / 2), h - 10 - (48 / 2) - 14, bVGUI.COLOR_WHITE,TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
	end
	if (self.vgui_VictimWidth >= 50) then
		draw.SimpleText(math.Round(self.vgui_VictimFrac * 100) .. "%", "gas_logging_damagelog_pct", w - 6 - 10 - self.FlagContainer:GetWide() - 10 - 48 - 10 - (self.vgui_VictimWidth / 2), h - 10 - (48 / 2) - 14, bVGUI.COLOR_WHITE,TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
	end
	if (self.vgui_OtherWidth >= 50) then
		draw.SimpleText(math.Round(self.vgui_OtherFrac * 100) .. "%", "gas_logging_damagelog_pct", 10 + 48 + 10 + self.vgui_InstigatorWidth + (self.vgui_OtherWidth / 2), h - 10 - (48 / 2) - 14, bVGUI.COLOR_WHITE,TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
	end
end

derma.DefineControl("GAS.Logging.DamageLog", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/openpermissions_combobox.lua:

local PANEL = {}

Derma_Hook( PANEL, "Paint", "Paint", "ComboBox" )

Derma_Install_Convar_Functions( PANEL )

AccessorFunc( PANEL, "m_bDoSort", "SortItems", FORCE_BOOL )

function PANEL:Init()

	self.DropButton = vgui.Create( "DPanel", self )
	self.DropButton.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "ComboDownArrow", panel, w, h ) end
	self.DropButton:SetMouseInputEnabled( false )
	self.DropButton.ComboBox = self

	self:SetTall( 22 )
	self:Clear()

	self:SetContentAlignment( 4 )
	self:SetTextInset( 8, 0 )
	self:SetIsMenu( true )
	self:SetSortItems( true )

end

function PANEL:Clear()

	self:SetText( "" )
	self.Choices = {}
	self.Data = {}
	self.ChoiceIcons = {}
	self.Spacers = {}
	self.selected = nil

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

end

function PANEL:GetOptionText( id )

	return self.Choices[ id ]

end

function PANEL:GetOptionData( id )

	return self.Data[ id ]

end

function PANEL:GetOptionTextByData( data )

	for id, dat in pairs( self.Data ) do
		if ( dat == data ) then
			return self:GetOptionText( id )
		end
	end

	-- Try interpreting it as a number
	for id, dat in pairs( self.Data ) do
		if ( dat == tonumber( data ) ) then
			return self:GetOptionText( id )
		end
	end

	-- In case we fail
	return data

end

function PANEL:PerformLayout()

	self.DropButton:SetSize( 15, 15 )
	self.DropButton:AlignRight( 4 )
	self.DropButton:CenterVertical()

end

function PANEL:ChooseOption( value, index )

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self:SetText( value )

	-- This should really be the here, but it is too late now and convar changes are handled differently by different child elements
	--self:ConVarChanged( self.Data[ index ] )

	self.selected = index
	self:OnSelect( index, value, self.Data[ index ] )

end

function PANEL:ChooseOptionID( index )

	local value = self:GetOptionText( index )
	self:ChooseOption( value, index )

end

function PANEL:GetSelectedID()

	return self.selected

end

function PANEL:GetSelected()

	if ( !self.selected ) then return end

	return self:GetOptionText( self.selected ), self:GetOptionData( self.selected )

end

function PANEL:OnSelect( index, value, data )

	-- For override

end

function PANEL:AddSpacer()

	self.Spacers[ #self.Choices ] = true

end

function PANEL:AddChoice( value, data, select, icon )

	local i = table.insert( self.Choices, value )

	if ( data ) then
		self.Data[ i ] = data
	end
	
	if ( icon ) then
		self.ChoiceIcons[ i ] = icon
	end

	if ( select ) then

		self:ChooseOption( value, i )

	end

	return i

end

function PANEL:IsMenuOpen()

	return IsValid( self.Menu ) && self.Menu:IsVisible()

end

function PANEL:OpenMenu( pControlOpener )

	if ( pControlOpener && pControlOpener == self.TextEntry ) then
		return
	end

	-- Don't do anything if there aren't any options..
	if ( #self.Choices == 0 ) then return end

	-- If the menu still exists and hasn't been deleted
	-- then just close it and don't open a new one.
	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = DermaMenu( false, self )

	if ( self:GetSortItems() ) then
		local sorted = {}
		for k, v in pairs( self.Choices ) do
			local val = tostring( v ) --tonumber( v ) || v -- This would make nicer number sorting, but SortedPairsByMemberValue doesn't seem to like number-string mixing
			if ( string.len( val ) > 1 && !tonumber( val ) && val:StartWith( "#" ) ) then val = language.GetPhrase( val:sub( 2 ) ) end
			table.insert( sorted, { id = k, data = v, label = val, spacer = self.Spacers[ k ] } )
		end
		for k, v in SortedPairsByMemberValue( sorted, "label" ) do
			local option = self.Menu:AddOption( v.data, function() self:ChooseOption( v.data, v.id ) end )
			if ( self.ChoiceIcons[ v.id ] ) then
				option:SetIcon( self.ChoiceIcons[ v.id ] )
			end
			if ( v.spacer ) then
				self.Menu:AddSpacer()
			end
		end
	else
		for k, v in pairs( self.Choices ) do
			local option = self.Menu:AddOption( v, function() self:ChooseOption( v, k ) end )
			if ( self.ChoiceIcons[ k ] ) then
				option:SetIcon( self.ChoiceIcons[ k ] )
			end
			if ( self.Spacers[ k ] ) then
				self.Menu:AddSpacer()
			end
		end
	end

	local x, y = self:LocalToScreen( 0, self:GetTall() )

	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, false, self )

end

function PANEL:CloseMenu()

	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
	end

end

-- This really should use a convar change hook
function PANEL:CheckConVarChanges()

	if ( !self.m_strConVar ) then return end

	local strValue = GetConVarString( self.m_strConVar )
	if ( self.m_strConVarValue == strValue ) then return end

	self.m_strConVarValue = strValue

	self:SetValue( self:GetOptionTextByData( self.m_strConVarValue ) )

end

function PANEL:Think()

	self:CheckConVarChanges()

end

function PANEL:SetValue( strValue )

	self:SetText( strValue )

end

function PANEL:DoClick()

	if ( self:IsMenuOpen() ) then
		return self:CloseMenu()
	end

	self:OpenMenu()

end

function PANEL:GenerateExample( ClassName, PropertySheet, Width, Height )

	local ctrl = vgui.Create( ClassName )
	ctrl:AddChoice( "Some Choice" )
	ctrl:AddChoice( "Another Choice", "myData" )
	ctrl:AddChoice( "Default Choice", "myData2", true )
	ctrl:AddChoice( "Icon Choice", "myData3", false, "icon16/star.png" )
	ctrl:SetWide( 150 )

	PropertySheet:AddSheet( ClassName, ctrl, nil, true, true )

end

derma.DefineControl( "OpenPermissions.ComboBox", nil, PANEL, "DButton" )

--PATH gamemodes/starwarsrp/gamemode/libraries/sh_cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20211019

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from
--- @field CAMI_Source string @The source specified by the admin mod which registered this usergroup (if any, converted to a string)

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
--- ⚠ **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    admin = {
        Name = "admin",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin",
        CAMI_Source = "Garry's Mod",
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    if source then
        usergroup.CAMI_Source = tostring(source)
    end
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
--- ℹ **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
--- ⚠ **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
--- ⚠ **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--PATH gamemodes/starwarsrp/gamemode/modules/medic/sh_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/hitmenu/sh_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/config/licenseweapons.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/voting/sh_chatcommands.lua:
DarkRP.declareChatCommand{
    command = "forcecancelvote",
    description = "Forcefully cancel a vote.",
    delay = 0.5
}

--PATH gamemodes/starwarsrp/gamemode/modules/tipjar/cl_model.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/police/sh_init.lua:
local plyMeta = FindMetaTable("Player")

--[[---------------------------------------------------------------------------
Interface functions
---------------------------------------------------------------------------]]
function plyMeta:isArrested()
    return self:getDarkRPVar("Arrested")
end

function plyMeta:isWanted()
    return self:getDarkRPVar("wanted")
end

function plyMeta:getWantedReason()
    return self:getDarkRPVar("wantedReason")
end

function plyMeta:isCP()
    return GAMEMODE.CivilProtection and GAMEMODE.CivilProtection[self:Team()] or false
end

plyMeta.isMayor = fn.Compose{fn.Curry(fn.GetValue, 2)("mayor"), plyMeta.getJobTable}
plyMeta.isChief = fn.Compose{fn.Curry(fn.GetValue, 2)("chief"), plyMeta.getJobTable}


--[[---------------------------------------------------------------------------
Hooks
---------------------------------------------------------------------------]]

function DarkRP.hooks:canRequestWarrant(target, actor, reason)
    if not IsValid(target) then return false, DarkRP.getPhrase("suspect_doesnt_exist") end
    if not reason or string.len(reason) == 0 then return false, DarkRP.getPhrase("vote_specify_reason") end
    if string.len(reason) > 200 then return false, DarkRP.getPhrase("too_long") end
    if not IsValid(actor) then return false, DarkRP.getPhrase("actor_doesnt_exist") end
    if not actor:Alive() then return false, DarkRP.getPhrase("must_be_alive_to_do_x", DarkRP.getPhrase("get_a_warrant")) end
    if target.warranted then return false, DarkRP.getPhrase("already_a_warrant") end
    if not actor:isCP() then return false, DarkRP.getPhrase("incorrect_job", DarkRP.getPhrase("get_a_warrant")) end

    return true
end

function DarkRP.hooks:canRemoveWarrant(target, actor)
    if not IsValid(target) then return false, DarkRP.getPhrase("suspect_doesnt_exist") end
    if not IsValid(actor) then return false, DarkRP.getPhrase("actor_doesnt_exist") end
    if not actor:Alive() then return false, DarkRP.getPhrase("must_be_alive_to_do_x", DarkRP.getPhrase("remove_a_warrant")) end
    if not target.warranted then return false, DarkRP.getPhrase("not_warranted") end
    if not actor:isCP() then return false, DarkRP.getPhrase("incorrect_job", DarkRP.getPhrase("remove_a_warrant")) end
    if actor:isArrested() then return false, DarkRP.getPhrase("unable", DarkRP.getPhrase("remove_a_warrant"), "") end

    return true
end

function DarkRP.hooks:canWanted(target, actor, reason)
    if not IsValid(target) then return false, DarkRP.getPhrase("suspect_doesnt_exist") end
    if not reason or string.len(reason) == 0 then return false, DarkRP.getPhrase("vote_specify_reason") end
    if string.len(reason) > 200 then return false, DarkRP.getPhrase("too_long") end
    if not IsValid(actor) then return false, DarkRP.getPhrase("actor_doesnt_exist") end
    if not actor:Alive() then return false, DarkRP.getPhrase("must_be_alive_to_do_x", DarkRP.getPhrase("make_someone_wanted")) end
    if not actor:isCP() then return false, DarkRP.getPhrase("incorrect_job", DarkRP.getPhrase("make_someone_wanted")) end
    if target:isWanted() then return false, DarkRP.getPhrase("already_wanted") end
    if not target:Alive() then return false, DarkRP.getPhrase("suspect_must_be_alive_to_do_x", DarkRP.getPhrase("make_someone_wanted")) end
    if target:isArrested() then return false, DarkRP.getPhrase("suspect_already_arrested") end

    return true
end

function DarkRP.hooks:canUnwant(target, actor)
    if not IsValid(target) then return false, DarkRP.getPhrase("suspect_doesnt_exist") end
    if not IsValid(actor) then return false, DarkRP.getPhrase("actor_doesnt_exist") end
    if not actor:Alive() then return false, DarkRP.getPhrase("must_be_alive_to_do_x", DarkRP.getPhrase("remove_wanted_status")) end
    if not actor:isCP() then return false, DarkRP.getPhrase("incorrect_job", DarkRP.getPhrase("remove_wanted_status")) end
    if not target:isWanted() then return false, DarkRP.getPhrase("not_wanted") end
    if not target:Alive() then return false, DarkRP.getPhrase("suspect_must_be_alive_to_do_x", DarkRP.getPhrase("remove_wanted_status")) end

    return true
end

--[[---------------------------------------------------------------------------
Chat commands
---------------------------------------------------------------------------]]
for _, cmd in pairs{"cr", "911", "999", "112", "000"} do
    DarkRP.declareChatCommand{
        command = cmd,
        description = "Cry for help, the police will come (hopefully)!",
        delay = 1.5
    }
end

DarkRP.declareChatCommand{
    command = "warrant",
    description = "Get a search warrant for a certain player. With this warrant you can search their house.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.Alive, plyMeta.isCP, fn.Compose{fn.Not, plyMeta.isArrested}},
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "unwarrant",
    description = "Remove a search warrant for a certain player. With a warrant you can search their house.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.Alive, plyMeta.isCP, fn.Compose{fn.Not, plyMeta.isArrested}},
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "wanted",
    description = "Make a player wanted. This is needed to get them arrested.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.Alive, plyMeta.isCP, fn.Compose{fn.Not, plyMeta.isArrested}},
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "unwanted",
    description = "Remove a player's wanted status.",
    delay = 1.5,
    condition = fn.FAnd{plyMeta.Alive, plyMeta.isCP, fn.Compose{fn.Not, plyMeta.isArrested}}
}

DarkRP.declareChatCommand{
    command = "agenda",
    description = "Set the agenda.",
    delay = 1.5,
    condition = fn.Compose{fn.Not, fn.Curry(fn.Eq, 2)(nil), plyMeta.getAgenda}
}

DarkRP.declareChatCommand{
    command = "addagenda",
    description = "Add a line of text to the agenda.",
    delay = 1.5,
    condition = fn.Compose{fn.Not, fn.Curry(fn.Eq, 2)(nil), plyMeta.getAgenda}
}

DarkRP.declareChatCommand{
    command = "lottery",
    description = "Start a lottery.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "lockdown",
    description = "Start a lockdown. Everyone will have to stay inside.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "unlockdown",
    description = "Stop a lockdown.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "arrest",
    description = "Forcefully arrest a player.",
    delay = 0.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "unarrest",
    description = "Forcefully unarrest a player.",
    delay = 0.5,
    tableArgs = true
}

local noMayorExists = fn.Compose{fn.Null, fn.Curry(fn.Filter, 2)(plyMeta.isMayor), player.GetAll}
local noChiefExists = fn.Compose{fn.Null, fn.Curry(fn.Filter, 2)(plyMeta.isChief), player.GetAll}

DarkRP.declareChatCommand{
    command = "requestlicense",
    description = "Request a gun license.",
    delay = 1.5,
    condition = fn.FAnd {
        fn.FOr {
            fn.Curry(fn.Not, 2)(noMayorExists),
            fn.Curry(fn.Not, 2)(noChiefExists),
            fn.Compose{fn.Not, fn.Null, fn.Curry(fn.Filter, 2)(plyMeta.isCP), player.GetAll}
        },
        fn.Compose{fn.Not, fn.Curry(fn.Flip(plyMeta.getDarkRPVar), 2)("HasGunlicense")},
        fn.Compose{fn.Not, fn.Curry(fn.GetValue, 2)("LicenseRequested")}
    }
}

DarkRP.declareChatCommand{
    command = "givelicense",
    description = "Give someone a gun license",
    delay = 1.5,
    condition = fn.FOr{
        plyMeta.isMayor, -- Mayors can hand out licenses
        fn.FAnd{plyMeta.isChief, noMayorExists}, -- Chiefs can if there is no mayor
        fn.FAnd{plyMeta.isCP, noChiefExists, noMayorExists} -- CP's can if there are no chiefs nor mayors
    }
}

DarkRP.declareChatCommand{
    command = "demotelicense",
    description = "Start a vote to get someone's license revoked.",
    delay = 1.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "setlicense",
    description = "Forcefully give a player a license.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "unsetlicense",
    description = "Forcefully revoke a player's license.",
    delay = 1.5
}

--PATH gamemodes/starwarsrp/gamemode/modules/money/sh_commands.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/medic/sh_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/logging/cl_init.lua:
--[[---------------------------------------------------------------------------
Log a message to console
---------------------------------------------------------------------------]]
local function AdminLog(um)
    local colour = Color(um:ReadShort(), um:ReadShort(), um:ReadShort())
    local text = DarkRP.deLocalise(um:ReadString() .. "\n")

    MsgC(Color(255, 0, 0), "[" .. GAMEMODE.Name .. "] ", colour, text)

    hook.Call("DarkRPLogPrinted", nil, text, colour)
end
usermessage.Hook("DRPLogMsg", AdminLog)

--[[---------------------------------------------------------------------------
Interface
---------------------------------------------------------------------------]]
DarkRP.hookStub{
    name = "DarkRPLogPrinted",
    description = "Called when a log has printed in console.",
    realm = "Client",
    parameters = {
        {
            name = "text",
            description = "The actual log.",
            type = "string"
        },
        {
            name = "colour",
            description = "The colour of the printed log.",
            type = "Color"
        }
    },
    returns = {}
}

--PATH gamemodes/starwarsrp/gamemode/modules/jobs/sh_commands.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/chat/sh_chatcommands.lua:
local plyMeta = FindMetaTable("Player")
DarkRP.chatCommands = DarkRP.chatCommands or {}

local validChatCommand = {
    command = isstring,
    description = isstring,
    condition = fn.FOr{fn.Curry(fn.Eq, 2)(nil), isfunction},
    delay = isnumber,
    tableArgs = fn.FOr{fn.Curry(fn.Eq, 2)(nil), isbool},
}

local checkChatCommand = function(tbl)
    for k in pairs(validChatCommand) do
        if not validChatCommand[k](tbl[k]) then
            return false, k
        end
    end
    return true
end

function DarkRP.declareChatCommand(tbl)
    local valid, element = checkChatCommand(tbl)
    if not valid then
        DarkRP.error("Incorrect chat command! " .. element .. " is invalid!", 2)
    end

    tbl.command = string.lower(tbl.command)
    DarkRP.chatCommands[tbl.command] = DarkRP.chatCommands[tbl.command] or tbl
    for k, v in pairs(tbl) do
        DarkRP.chatCommands[tbl.command][k] = v
    end
end

function DarkRP.removeChatCommand(command)
    DarkRP.chatCommands[string.lower(command)] = nil
end

function DarkRP.chatCommandAlias(command, ...)
    local name
    for k, v in pairs{...} do
        name = string.lower(v)

        DarkRP.chatCommands[name] = {command = name}
        setmetatable(DarkRP.chatCommands[name], {
            __index = DarkRP.chatCommands[command]
        })
    end
end

function DarkRP.getChatCommand(command)
    return DarkRP.chatCommands[string.lower(command)]
end

function DarkRP.getChatCommands()
    return DarkRP.chatCommands
end

function DarkRP.getSortedChatCommands()
    local tbl = fn.Compose{table.ClearKeys, table.Copy, DarkRP.getChatCommands}()
    table.SortByMember(tbl, "command", true)

    return tbl
end

-- chat commands that have been defined, but not declared
DarkRP.getIncompleteChatCommands = fn.Curry(fn.Filter, 3)(fn.Compose{fn.Not, checkChatCommand})(DarkRP.chatCommands)

--[[---------------------------------------------------------------------------
Chat commands
---------------------------------------------------------------------------]]
DarkRP.declareChatCommand{
    command = "pm",
    description = "Send a private message to someone.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "w",
    description = "Say something in whisper voice.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "y",
    description = "Yell something out loud.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "me",
    description = "Chat roleplay to say you're doing things that you can't show otherwise.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "/",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "a",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "ooc",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "broadcast",
    description = "Broadcast something as a mayor.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "channel",
    description = "Tune into a radio channel.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "radio",
    description = "Say something through the radio.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "g",
    description = "Group chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "credits",
    description = "Send the DarkRP credits to someone.",
    delay = 1.5
}

--PATH gamemodes/starwarsrp/gamemode/modules/chat/cl_chatlisteners.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_gamemode_functions.lua:
function GM:SetupMove(ply, mv, cmd)
    if ply:isArrested() then
        mv:SetMaxClientSpeed(self.Config.arrestspeed)
    end
    return self.Sandbox.SetupMove(self, ply, mv, cmd)
end

function GM:StartCommand(ply, usrcmd)
    -- Used in arrest_stick and unarrest_stick but addons can use it too!
    local wep = ply:GetActiveWeapon()
    if wep:IsValid() and isfunction(wep.startDarkRPCommand) then
        wep:startDarkRPCommand(usrcmd)
    end
end

function GM:OnPlayerChangedTeam(ply, oldTeam, newTeam)
    if RPExtraTeams[oldTeam] and RPExtraTeams[oldTeam].OnPlayerLeftTeam then
        RPExtraTeams[oldTeam].OnPlayerLeftTeam(ply, newTeam)
    end

    if RPExtraTeams[newTeam] and RPExtraTeams[newTeam].OnPlayerChangedTeam then
        RPExtraTeams[newTeam].OnPlayerChangedTeam(ply, oldTeam, newTeam)
    end

    if CLIENT then return end

    local agenda = ply:getAgendaTable()

    -- Remove agenda text when last manager left
    if agenda and agenda.ManagersByKey[oldTeam] then
        local found = false
        for man, _ in pairs(agenda.ManagersByKey) do
            if team.NumPlayers(man) > 0 then found = true break end
        end
        if not found then agenda.text = nil end
    end

    ply:setSelfDarkRPVar("agenda", agenda and agenda.text or nil)
end

hook.Add("loadCustomDarkRPItems", "CAMI privs", function()
    CAMI.RegisterPrivilege{
        Name = "DarkRP_SeeEvents",
        MinAccess = "admin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_GetAdminWeapons",
        MinAccess = "admin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_SetDoorOwner",
        MinAccess = "admin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_ChangeDoorSettings",
        MinAccess = "superadmin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_AdminCommands",
        MinAccess = "admin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_SetMoney",
        MinAccess = "superadmin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_SetLicense",
        MinAccess = "superadmin"
    }

    for _, v in pairs(RPExtraTeams) do
        if not v.vote or v.admin and v.admin > 1 then continue end

        local toAdmin = {[0] = "admin", [1] = "superadmin"}
        CAMI.RegisterPrivilege{
            Name = "DarkRP_GetJob_" .. v.command,
            MinAccess = toAdmin[v.admin or 0]-- Add privileges for the teams that are voted for
        }
    end
end)

--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_util.lua:
local plyMeta = FindMetaTable("Player")

--[[---------------------------------------------------------------------------
Show a black screen
---------------------------------------------------------------------------]]
local function blackScreen(um)
    local toggle = um:ReadBool()
    if toggle then
        local black = color_black
        local w, h = ScrW(), ScrH()
        hook.Add("HUDPaintBackground", "BlackScreen", function()
            surface.SetDrawColor(black)
            surface.DrawRect(0, 0, w, h)
        end)
    else
        hook.Remove("HUDPaintBackground", "BlackScreen")
    end
end
usermessage.Hook("blackScreen", blackScreen)

--[[---------------------------------------------------------------------------
Wrap strings to not become wider than the given amount of pixels
---------------------------------------------------------------------------]]
local function charWrap(text, remainingWidth, maxWidth)
    local totalWidth = 0

    text = text:gsub(".", function(char)
        totalWidth = totalWidth + surface.GetTextSize(char)

        -- Wrap around when the max width is reached
        if totalWidth >= remainingWidth then
            -- totalWidth needs to include the character width because it's inserted in a new line
            totalWidth = surface.GetTextSize(char)
            remainingWidth = maxWidth
            return "\n" .. char
        end

        return char
    end)

    return text, totalWidth
end

function DarkRP.textWrap(text, font, maxWidth)
    local totalWidth = 0

    surface.SetFont(font)

    local spaceWidth = surface.GetTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
            local char = string.sub(word, 1, 1)
            if char == "\n" or char == "\t" then
                totalWidth = 0
            end

            local wordlen = surface.GetTextSize(word)
            totalWidth = totalWidth + wordlen

            -- Wrap around when the max width is reached
            if wordlen >= maxWidth then -- Split the word if the word is too big
                local splitWord, splitPoint = charWrap(word, maxWidth - (totalWidth - wordlen), maxWidth)
                totalWidth = splitPoint
                return splitWord
            elseif totalWidth < maxWidth then
                return word
            end

            -- Split before the word
            if char == ' ' then
                totalWidth = wordlen - spaceWidth
                return '\n' .. string.sub(word, 2)
            end

            totalWidth = wordlen
            return '\n' .. word
        end)

    return text
end

--[[---------------------------------------------------------------------------
Decides whether a given player is in the same room as the local player
note: uses a heuristic
---------------------------------------------------------------------------]]
function plyMeta:isInRoom()
    local tracedata = {}
    tracedata.start = LocalPlayer():GetShootPos()
    tracedata.endpos = self:GetShootPos()
    local trace = util.TraceLine(tracedata)

    return not trace.HitWorld
end

--[[---------------------------------------------------------------------------
Key name to key int mapping
---------------------------------------------------------------------------]]
local keyNames
function input.KeyNameToNumber(str)
    if not keyNames then
        keyNames = {}
        for i = 1, 107, 1 do
            keyNames[input.GetKeyName(i)] = i
        end
    end

    return keyNames[str]
end

--PATH gamemodes/starwarsrp/gamemode/config/addentities.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_language/english.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_modules/weaponsettings/sh_weaponsettings.lua:
-- Ignore these two lines:
local weapon = weapons.GetStored
local function edit()
--[[
---------------------------------------------------------------------------
Weapon setting changer module
---------------------------------------------------------------------------

This module allows you to change the settings of weapons. Here's how it works.
Per weapon and setting a line is added in this format:
weapon "WEAPON CLASS NAME HERE".SETTING_HERE = VALUE_HERE



IMPORTANT:
    - Note the quotation marks around the weapon class name!
    - Note the '.' between the class name and the setting!
    - Casing MATTERS. PrintName IS NOT THE SAME AS printname!
    - CHANGING THE SETTINGS IS NOT RECODING THE WEAPON. PLEASE LEAVE THE AUTHORS FIELD INTACT. THANK YOU.
    - Technically you can set any field of the weapon. Advanced users can even override e.g. PrimaryAttack with this.
    - This system is not limited to weapons that come with the DarkRP gamemode.

Examples:

-- This essentially works by replacing "SWEP" at the start of each setting like "SWEP.Primary.Ammo = "pistol""
with your customization in this file being "weapon_deagle2".Primary.Ammo = "ar2"

-- Set the printname of the stunstick to "bash baton". Note: the quotation marks are important!
weapon "stunstick".PrintName = "Bash baton"

-- Set the instructions of the arrest baton. Note the quotation marks! Also, the '\n' is an enter.
weapon "arrest_stick".Instructions = "Left click to arrest\nRight click to switch batons"

-- Set the damage of the p228 to 20 per shot. Note: NO quotes around 20 because it's just a number.
weapon "weapon_p2282".Primary.Damage = 20


LIST OF DEFAULT DARKRP WEAPONS:
The class names of the default DarkRP weapons are listed on this page:
https://github.com/FPtje/DarkRP/tree/master/entities/weapons

You can find extra documentation for weapon functions here on this page:
https://github.com/FPtje/darkrpmodification/blob/master/lua/weapons/weapon_ak47custom/shared.lua

Note that it's the folder names that matter here(the folders that contain the shared.lua for the weapons), e.g. keys, med_kit, door_ram, weapon_m42 etc.

SOME EXAMPLE SETTINGS THAT CAN BE CHANGED USING THIS METHOD:
    - PrintName
    - Instructions
    - Contact
    - Purpose
    - Category
    - Recoil
    - Damage
    - NumShots
    - Cone
    - ClipSize
    - Delay
    - DefaultClip

This list is not complete.

-- ADD WEAPON SETTINGS BELOW THIS LINE
]] -----------------------------------------


--------------------------------------------
-- ADD WEAPON SETTINGS ABOVE THIS LINE
-- Also ignore the lines below. They are needed to make this work.
end
hook.Add("OnGamemodeLoaded", "weaponsettings", edit)
hook.Add("OnReloaded", "weaponsettings", edit)

--PATH addons/!jobs/lua/darkrp_customthings/entities.lua:
--[[---------------------------------------------------------------------------
DarkRP custom entities
---------------------------------------------------------------------------

This file contains your custom entities.
This file should also contain entities from DarkRP that you edited.

Note: If you want to edit a default DarkRP entity, first disable it in darkrp_config/disabled_defaults.lua
    Once you've done that, copy and paste the entity to this file and edit it.

The default entities can be found here:
https://github.com/FPtje/DarkRP/blob/master/gamemode/config/addentities.lua

For examples and explanation please visit this wiki page:
https://darkrp.miraheze.org/wiki/DarkRP:CustomEntityFields

Add entities under the following line:
---------------------------------------------------------------------------]]

--PATH addons/!jobs/lua/darkrp_customthings/categories.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_bench.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_slots.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_stats.lua:
local ARC9ScreenScale = ARC9.ScreenScale

local function GetTrueRPM(self, base)
    if base then
        if self:GetCapacity() == 1 then
            local reloadtime = self.ReloadTime * self:GetAnimationTime("reload")

            local a = 60 / reloadtime

            a = math.Round(a, 0)

            return a
        else
            local a = self.RPM
            local delay = 60 / a

            if self.TriggerDelayRepeat then
                delay = math.max(self.TriggerDelayTime, delay)
            end

            if self.ManualAction then
				-- What is self.cycle .
				local cyclelen = self:GetAnimationTime("cycle")
				local cycleent = self:GetAnimationEntry("cycle")
				cyclelen = cyclelen * (cycleent.Mult or 1)
				cyclelen = cyclelen * (cycleent.MinProgress or 1)
                delay = delay + (cyclelen * self.CycleTime)
            end

            if self:GetCurrentFiremode() > 1 then
                local pbd = self.PostBurstDelay
                local burstlength = self:GetCurrentFiremode()

                delay = delay + (pbd / burstlength)
            end

            a = 60 / delay

			a = math.Round(a)

            return a
        end
    else
        if self:GetCapacity() == 1 then
            local reloadtime = self:GetProcessedValue("ReloadTime") * self:GetAnimationTime("reload")

            local a = 60 / reloadtime

            a = math.Round(a, 0)

            return a
        else
            local a = self:GetProcessedValue("RPM")
            local delay = 60 / a

            if self:GetProcessedValue("TriggerDelayRepeat") then
                delay = math.max(self:GetProcessedValue("TriggerDelayTime"), delay)
            end

            if self:GetProcessedValue("ManualAction") then
				local cyclelen = self:GetAnimationTime("cycle")
				local cycleent = self:GetAnimationEntry("cycle")
				cyclelen = cyclelen * (cycleent.Mult or 1)
				cyclelen = cyclelen * (cycleent.MinProgress or 1)
                delay = delay + (cyclelen * self:GetProcessedValue("CycleTime"))
            end

            if self:GetCurrentFiremode() > 1 then
                local pbd = self:GetProcessedValue("PostBurstDelay")
                local burstlength = self:GetCurrentFiremode()

                delay = delay + (pbd / burstlength)
            end

            a = 60 / delay

			a = math.Round(a)

            return a
        end
    end
end

function SWEP:CreateHUD_Stats()
    local lowerpanel = self.CustomizeHUD.lowerpanel
	local imperial = GetConVar("arc9_imperial"):GetBool()

    -- if true then return end
    self:ClearTabPanel()

    -- {
    --     title = "Recoil",
    --     stat = "Recoil",
    --     unit = "%",
    --     fifty = 5, # value for "50%" point on stat bar, logistic from then on
    --     func = function() return 0 end,
    --     cond = function() return true end
    --     conv = function(a) return a * 100 end
    --     lowerisbetter = false
    --     eval = function() return 0 end # return negative value to indicate this stat is WORSE than base and positive to indicate it is better
    -- }

    local stats = {
        {
            title = "customize.stats.firepower",
            desc = "customize.stats.explain.firepower",
            unit = "unit.dmg",
            fifty = 50,
            conv = function(a)
                local dv = self:GetProcessedValue("DamageMax")
                local num = self:GetProcessedValue("Num")
                if num <= 0 then return 0 end

                if self:GetProcessedValue("DistributeDamage") then
                    dv = dv / num
                elseif self:GetProcessedValue("NormalizeNumDamage") then
                    dv = dv / (num / self.Num)
                end

                dv = math.Round(dv, 0)

                if num > 1 then
                    dv = dv .. " x " .. tostring(num)
                end

                return dv
            end,
            cond = function()
                return self:GetProcessedValue("ShootEnt")
            end,
        },
        {
            title = "customize.stats.rof",
            desc = "customize.stats.explain.rof",
            stat = "RPM",
            fifty = 600,
            unit = "unit.rpm",
            conv = function(a)
                local cyclic = self:GetProcessedValue("RPM")
                a = GetTrueRPM(self)

                local str = ""

                if cyclic != a then
                    str = "~"
                end

                return str .. tostring(a)
            end,
            eval = function()
                local a = GetTrueRPM(self)
                local b = GetTrueRPM(self, true)

                if a == b then return 0 end

                return a > b and 1 or -1
            end,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true)
            end,
        },
        {
            title = "customize.stats.cyclic",
            desc = "customize.stats.explain.cyclic",
            stat = "RPM",
            fifty = 600,
            unit = "unit.rpm",
            conv = function(a)
                a = math.Round(a)

                return a
            end,
            cond = function()
                return self:GetProcessedValue("RPM") == GetTrueRPM(self) or self:GetProcessedValue("ManualAction") or self:GetCapacity() == 1
            end,
        },
        {
            title = "customize.stats.capacity",
            desc = "customize.stats.explain.capacity",
            stat = "ClipSize",
            fifty = 20,
            eval = function()
                local a = self:GetProcessedValue("ClipSize") + self:GetProcessedValue("ChamberSize")
                if self:GetProcessedValue("BottomlessClip", true) then
                    a = a + math.huge
                end
                local b = self.ClipSize + self.ChamberSize
                if self.BottomlessClip then
                    b = b + math.huge
                end

                if a == b then return 0 end

                return a > b and 1 or -1
            end,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true)
            end,
            conv = function(a)
                a = tostring(a)

                if self:GetProcessedValue("ChamberSize") > 0 then
                    a = a .. "+" .. tostring(self:GetProcessedValue("ChamberSize"))
                end

                if self:GetProcessedValue("BottomlessClip", true) then
                    a = "∞"
                end

                return a
            end
        },
        {
            title = "customize.stats.range",
            desc = "customize.stats.explain.range",
            unit = imperial and "unit.yard" or "unit.meter",
            fifty = 500,
            stat = "RangeMax",
            conv = function(a)
				if imperial then return a * ARC9.HUToM * 1.0936 end
                return a * ARC9.HUToM
            end,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or self:GetProcessedValue("ShootEnt")
            end
        },
        {
            title = "customize.stats.precision",
            desc = "customize.stats.explain.precision",
            stat = "Spread",
            fifty = 5,
            lowerisbetter = true,
            unit = "unit.moa",
            conv = function(a) return math.Round(a * 360 * 60 / 10, 1) end,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or self:GetProcessedValue("Spread") == 0
            end
        },
        {
            title = "customize.stats.muzzlevelocity",
            desc = "customize.stats.explain.muzzlevelocity",
            stat = "PhysBulletMuzzleVelocity",
            fifty = 500,
            unit = imperial and "unit.footpersecond" or "unit.meterpersecond",
            conv = function(a) 
				if imperial then return math.Round(a * ARC9.HUToM * 3.2808399) end
				return math.Round(a * ARC9.HUToM) 
			end,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or self:GetProcessedValue("ShootEnt")
            end
        },
        {
            title = "customize.stats.ammo",
            desc = "customize.stats.explain.ammo",
            stat = "Ammo",
            conv = function(a)
                -- return language.GetPhrase(a .. "_ammo")
                return ARC9:GetPhrase("ammo." .. a)
            end,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or self:GetProcessedValue("InfiniteAmmo")
            end
        },
        {
            title = "customize.stats.penetration",
            desc = "customize.stats.explain.penetration",
            stat = "Penetration",
            fifty = 50,
            unit = imperial and "unit.inch" or "unit.millimeter",
            conv = function(a) 
				if imperial then return math.Round(a * ARC9.HUToM * 39.370, 2) end -- not using it directly because hutom
				return math.Round(a * ARC9.HUToM * 1000, 2)
			end,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or self:GetProcessedValue("ShootEnt")
            end
        },
        {
            title = "customize.stats.ricochet",
            desc = "customize.stats.explain.ricochet",
            stat = "RicochetChance",
            fifty = 50,
            unit = "%",
            conv = function(a) return math.Round(a * 100, 0) end,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or self:GetProcessedValue("ShootEnt")
            end
        },
        {
            title = "customize.stats.armorpiercing",
            desc = "customize.stats.explain.armorpiercing",
            stat = "ArmorPiercing",
            fifty = 25,
            unit = "%",
            conv = function(a) return math.Round(a * 100, 0) end,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or self:GetProcessedValue("ShootEnt")
            end
        },
        {
            title = "customize.stats.explosive",
            desc = "customize.stats.explain.explosive",
            stat = "ExplosionDamage",
            fifty = 50,
            unit = "unit.dmg",
            conv = function(a) return math.Round(a, 0) end,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or self:GetProcessedValue("ShootEnt") or self:GetProcessedValue("ExplosionDamage") <= 0
            end
        },
        {
            title = "customize.stats.speed",
            desc = "customize.stats.explain.speed",
            stat = "SpeedMult",
            fifty = 95,
            unit = "%",
            conv = function(a) return math.Round(a * 100, 0) end,
        },
        {
            title = "customize.stats.aimtime",
            desc = "customize.stats.explain.aimtime",
            stat = "AimDownSightsTime",
            lowerisbetter = true,
            fifty = 0.3,
            unit = "unit.second",
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true)
            end
        },
        {
            title = "customize.stats.sprinttofire",
            desc = "customize.stats.explain.sprinttofire",
            stat = "SprintToFireTime",
            lowerisbetter = true,
            fifty = 0.3,
            unit = "unit.second"
        },
        -- {
        --     title = "Projectile Count",
        --     fifty = 3,
        --     stat = "Num",
        --     unit = "",
        --     cond = function()
        --         return self:GetProcessedValue("Num") <= 1
        --     end
        -- },
        -- {
        --     title = "Recoil",
        --     unit = "%",
        --     fifty = 75,
        --     conv = function(a)
        --         local recoilup = self:GetProcessedValue("RecoilUp")
        --         local recoilside = self:GetProcessedValue("RecoilSide")
        --         local recoilrup = self:GetProcessedValue("RecoilRandomUp")
        --         local recoilrside = self:GetProcessedValue("RecoilRandomSide")

        --         local rv = recoilup + (recoilside * 1.5) + (recoilrup * 4) + (recoilrside * 4)
        --         rv = rv * self:GetProcessedValue("Recoil")

        --         rv = rv - (self:GetProcessedValue("RecoilAutoControl") * 0.25)

        --         rv = rv * 15

        --         rv = math.Round(rv, 0)

        --         return rv
        --     end,
        --     cond = function()
        --         return self:GetProcessedValue("PrimaryBash")
        --     end
        -- },
        {
            title = "customize.stats.firemodes",
            desc = "customize.stats.explain.firemodes",
            conv = function(a)
                str = ""

                for i, k in pairs(self:GetValue("Firemodes")) do
                    if k.PrintName then
                        str = str .. k.PrintName .. ", "
                    else
                        if k.Mode then
                            if k.Mode == 0 then
                                str = str .. ARC9:GetPhrase("hud.firemode.safe") .. ", "
                            elseif k.Mode < 0 then
                                str = str .. ARC9:GetPhrase("hud.firemode.auto") .. ", "
                            elseif k.Mode == 1 then
                                str = str .. ARC9:GetPhrase("hud.firemode.single") .. ", "
                            elseif k.Mode > 1 then
                                str = str .. tostring(k.Mode) .. "-" .. ARC9:GetPhrase("hud.firemode.burst") .. ", "
                            end
                        end
                    end
                end

                str = string.sub(str, 1, string.len(str) - 2)

                return str
            end
        },
        {
            title = "customize.stats.burstdelay",
            desc = "customize.stats.explain.burstdelay",
            stat = "PostBurstDelay",
            lowerisbetter = true,
            fifty = 0.1,
            unit = "unit.second",
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or self:GetProcessedValue("PostBurstDelay") <= 0 or self:GetCapacity() == 0
            end
        },
        {
            title = "customize.stats.triggerdelay",
            desc = "customize.stats.explain.triggerdelay",
            stat = "TriggerDelayTime",
            lowerisbetter = true,
            fifty = 0.1,
            unit = "unit.second",
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or self:GetProcessedValue("TriggerDelayTime") <= 0 or !self:GetProcessedValue("TriggerDelay")
            end
        },
        {
            title = "customize.stats.noise",
            desc = "customize.stats.explain.noise",
            stat = "ShootVolume",
            lowerisbetter = true,
            fifty = 100,
            unit = "unit.decibel",
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true)
            end
        },
        {
            title = "customize.stats.sway",
            desc = "customize.stats.explain.sway",
            stat = "Sway",
            lowerisbetter = true,
            fifty = 95,
            unit = "%",
            conv = function(a) return math.Round(a * 60, 0) end,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or !GetConVar("arc9_mod_sway"):GetBool()
            end
        },
        {
            title = "customize.stats.freeaim",
            desc = "customize.stats.explain.freeaim",
            stat = "FreeAimRadius",
            lowerisbetter = true,
            fifty = 20,
            unit = "°",
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or !GetConVar("arc9_mod_freeaim"):GetBool()
            end
        },
        {
            title = "customize.stats.supplylimit",
            desc = "customize.stats.explain.supplylimit",
            stat = "SupplyLimit",
            fifty = 3,
            cond = function()
                return self:GetProcessedValue("PrimaryBash", true) or self:GetValue("EFTErgo")
            end,
            conv = function(a) return math.Round(a, 0) end,
            unit = ""
        },
        {
            title = "Ergonomics",
            desc = "EFT: Ergonomics affects the speed that the player aims down their sights and stamina drain.",
            stat = "EFTErgo",
            fifty = 50,
            cond = function()
                return !self:GetValue("EFTErgo")
            end,
            unit = ""
        },
    }


    local statsspanel = vgui.Create("DPanel", lowerpanel)
    statsspanel:SetPos(ARC9ScreenScale(60), ARC9ScreenScale(20))
    statsspanel:SetSize(lowerpanel:GetWide()*0.8, ARC9ScreenScale(98))
    statsspanel.Paint = function(self2, w, h)
        -- surface.SetDrawColor(144, 0, 0, 100)
        -- surface.DrawRect(0, 0, w, h)
    end

    statsspanel:SetAlpha(0)
    statsspanel:AlphaTo(255, 0.2, 0, nil)

    self.BottomBar = statsspanel

    local realI = 0

    local many = false                -- probably not the best way
    for i, stat in pairs(stats) do
        if stat.cond and stat.cond() then continue end
        realI = realI + 1
        if realI > 6 then many = true end
    end

    realI = 0

    for i, stat in pairs(stats) do
        if stat.cond and stat.cond() then continue end
        realI = realI + 1

        local statpanel = vgui.Create("DPanel", statsspanel )
        statpanel:SetSize(ARC9ScreenScale(120), ARC9ScreenScale(16))

        if !many then
            statpanel:SetPos(statsspanel:GetWide() * 0.5-ARC9ScreenScale(60), ARC9ScreenScale(16.5) * realI - ARC9ScreenScale(16))
        else
            if realI > 12 then
                statpanel:SetPos(statsspanel:GetWide() - ARC9ScreenScale(120), ARC9ScreenScale(16.5) * (realI-12) - ARC9ScreenScale(16))
            elseif realI > 6 then
                statpanel:SetPos(statsspanel:GetWide() * 0.5-ARC9ScreenScale(60), ARC9ScreenScale(16.5) * (realI-6) - ARC9ScreenScale(16))
            else
                statpanel:SetPos(0, ARC9ScreenScale(16.5) * realI - ARC9ScreenScale(16))
            end
        end

        statpanel.stats = stat
        statpanel.ri = realI
        statpanel.Paint = function(self2, w, h)
            if !IsValid(self) then return end

            local major = ""
            local improvement = 0 -- 0 = same, 1 = better, -1 = worse
            if self2.stats.stat then major = self:GetValue(self2.stats.stat) end

            if self2.stats.eval then
                improvement = self2.stats.eval()
            else
                if isnumber(major) then
                    local base = self:GetTable()[self2.stats.stat]

                    if isnumber(base) then
                        if self2.stats.lowerisbetter then
                            if major < base then
                                improvement = 1
                            elseif major > base then
                                improvement = -1
                            end
                        else
                            if major > base then
                                improvement = 1
                            elseif major < base then
                                improvement = -1
                            end
                        end
                    end
                end
            end

            if self2.stats.conv then major = self2.stats.conv(major) end

            if isnumber(major) then major = math.Round(major, 2) end
            local oldmajor = major
            major = tostring(major)

            local textcol = ARC9.GetHUDColor("fg")

            if improvement == 1 then
                textcol = ARC9.GetHUDColor("pro")
            elseif improvement == -1 then
                textcol = ARC9.GetHUDColor("con")
            end

            if self2:IsHovered() then
                surface.SetDrawColor(ARC9.GetHUDColor("fg", 100))
                surface.DrawRect(0, 0, w, h)
            else
                if self2.ri % 2 == 1 then
                    surface.SetDrawColor(ARC9.GetHUDColor("shadow", 100))
                    surface.DrawRect(0, 0, w, h)
                end
            end

            surface.SetFont("ARC9_10_Slim")
            surface.SetTextPos(ARC9ScreenScale(2), ARC9ScreenScale(2))
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.DrawText(ARC9:GetPhrase(self2.stats.title) or self2.stats.title)

            local tw_u = 0
            if self2.stats.unit then
                surface.SetFont("ARC9_8")
                tw_u = surface.GetTextSize(ARC9:GetPhrase(self2.stats.unit) or self2.stats.unit)

                surface.SetTextPos(w - tw_u - ARC9ScreenScale(2), ARC9ScreenScale(3))
                surface.SetTextColor(textcol)
                surface.DrawText(ARC9:GetPhrase(self2.stats.unit) or self2.stats.unit)

                tw_u = tw_u + ARC9ScreenScale(4)
            else
                tw_u = ARC9ScreenScale(2)
            end

            surface.SetFont("ARC9_10")
            local tw = surface.GetTextSize(major)
            surface.SetTextPos(w-tw-tw_u, ARC9ScreenScale(2))
            surface.SetTextColor(textcol)
            surface.DrawText(major)

            if self2:IsHovered() then
                self2:MoveToFront()
                local todo = DisableClipping(true)
                local col_text = ARC9.GetHUDColor("fg")
                local rx, ry = self2:CursorPos()
                rx = rx + ARC9ScreenScale(8)
                ry = ry + ARC9ScreenScale(8)

                local desc = ARC9:GetPhrase(self2.stats.desc) or self2.stats.desc
				
				-- self.CustomizeHints["customize.hint.select"] = self2.stats.desc

                surface.SetFont("ARC9_10")
                local btw = surface.GetTextSize(desc)

                local bw, bh = btw + ARC9ScreenScale(8), ARC9ScreenScale(16)

                if self2:GetY() + ry >= ARC9ScreenScale(60) then
                    ry = ry - ARC9ScreenScale(25)
                end

                if self2:GetX() + rx + bw >= (ScrW() - 250) then
                    rx = rx - bw - 25
                end

                surface.SetDrawColor(ARC9.GetHUDColor("shadow", 253))
                surface.DrawRect(rx, ry, bw, bh)

                surface.SetTextColor(col_text)
                surface.SetFont("ARC9_10")
                surface.SetTextPos(rx + ARC9ScreenScale(3), ry + ARC9ScreenScale(3))
                surface.DrawText(desc)

                DisableClipping(todo)
            end
        end
    end

    --[[
    local tp = vgui.Create("DScrollPanel", bg)
    tp:SetSize(ARC9ScreenScale(150), ScrH() - ARC9ScreenScale(76 + 4))
    tp:SetPos(ScrW() - ARC9ScreenScale(150 + 12), ARC9ScreenScale(76))
    tp.Paint = function(self2, w, h)
    end

    local scroll_preset = tp:GetVBar()
    scroll_preset.Paint = function() end
    scroll_preset.btnUp.Paint = function(span, w, h)
    end
    scroll_preset.btnDown.Paint = function(span, w, h)
    end
    scroll_preset.btnGrip.Paint = PaintScrollBar

    self.TabPanel = tp

    for i, stat in pairs(stats) do
        if stat.cond and stat.cond() then continue end

        local newbtn = tp:Add("DPanel")
        newbtn:SetSize(ARC9ScreenScale(150), ARC9ScreenScale(27))
        newbtn:Dock(TOP)
        newbtn.stats = stat
        newbtn.Paint = function(self2, w, h)
            if !IsValid(self) then return end
            -- title
            surface.SetFont("ARC9_8")
            local tw = surface.GetTextSize(self2.stats.title)

            surface.SetFont("ARC9_8")
            surface.SetTextPos(w - tw - ARC9ScreenScale(1), ARC9ScreenScale(2 + 1))
            surface.SetTextColor(ARC9.GetHUDColor("shadow"))
            surface.DrawText(self2.stats.title)

            surface.SetFont("ARC9_8")
            surface.SetTextPos(w - tw - ARC9ScreenScale(2), ARC9ScreenScale(2))
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.DrawText(self2.stats.title)

            local tw_u = 0
            -- unit
            if self2.stats.unit then
                surface.SetFont("ARC9_8")
                tw_u = surface.GetTextSize(self2.stats.unit)

                surface.SetFont("ARC9_8")
                surface.SetTextPos(w - tw_u - ARC9ScreenScale(2) + ARC9ScreenScale(1), ARC9ScreenScale(16 + 1))
                surface.SetTextColor(ARC9.GetHUDColor("shadow"))
                surface.DrawText(self2.stats.unit)

                surface.SetFont("ARC9_8")
                surface.SetTextPos(w - tw_u - ARC9ScreenScale(2), ARC9ScreenScale(16))
                surface.SetTextColor(ARC9.GetHUDColor("fg"))
                surface.DrawText(self2.stats.unit)
            end

            local major = ""

            if self2.stats.stat then
                major = self:GetValue(self2.stats.stat)
            end

            if self2.stats.conv then
                major = self2.stats.conv(major)
            end

            if isnumber(major) then
                major = math.Round(major, 2)
            end

            local oldmajor = major

            major = tostring(major)

            surface.SetFont("ARC9_12")
            tw_p = surface.GetTextSize(major) + tw_u

            surface.SetFont("ARC9_12")
            surface.SetTextPos(w - tw_p - ARC9ScreenScale(2), ARC9ScreenScale(12 + 1))
            surface.SetTextColor(ARC9.GetHUDColor("shadow"))
            self:DrawTextRot(self2, major, 0, 0, math.max(w - tw_p - ARC9ScreenScale(2), 0), ARC9ScreenScale(12 + 1), w)

            surface.SetFont("ARC9_12")
            surface.SetTextPos(w - tw_p - ARC9ScreenScale(3), ARC9ScreenScale(12))
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            self:DrawTextRot(self2, major, 0, 0, math.max(w - tw_p - ARC9ScreenScale(3), 0), ARC9ScreenScale(12), w, true)

            if self2.stats.fifty and isnumber(oldmajor) then
                local mapped = -(1 / ((oldmajor / self2.stats.fifty) + 1)) + 1

                surface.SetDrawColor(ARC9.GetHUDColor("shadow"))
                surface.DrawRect(ARC9ScreenScale(1), ARC9ScreenScale(12 + 1), ARC9ScreenScale(1), ARC9ScreenScale(13))

                surface.SetDrawColor(ARC9.GetHUDColor("fg"))
                surface.DrawRect(0, ARC9ScreenScale(12), ARC9ScreenScale(1), ARC9ScreenScale(13))

                local shortw = w - ARC9ScreenScale(1)

                local barw = mapped * shortw

                surface.SetDrawColor(ARC9.GetHUDColor("shadow"))
                surface.DrawRect(shortw - barw + ARC9ScreenScale(1), ARC9ScreenScale(12 + 1), barw, ARC9ScreenScale(13))

                surface.SetDrawColor(ARC9.GetHUDColor("fg"))
                surface.DrawRect(shortw - barw, ARC9ScreenScale(12), barw, ARC9ScreenScale(13))

                local screenx, screeny = self2:LocalToScreen(shortw - barw, ARC9ScreenScale(12 + 1))

                render.SetScissorRect(screenx, screeny, screenx + barw, screeny + ARC9ScreenScale(12), true)

                surface.SetFont("ARC9_8")
                surface.SetTextPos(w - tw_u - ARC9ScreenScale(2), ARC9ScreenScale(16))
                surface.SetTextColor(ARC9.GetHUDColor("shadow"))
                surface.DrawText(self2.stats.unit)

                surface.SetFont("ARC9_12")
                surface.SetTextPos(w - tw_p - ARC9ScreenScale(2), ARC9ScreenScale(12))
                surface.SetTextColor(ARC9.GetHUDColor("shadow"))
                self:DrawTextRot(self2, major, 0, 0, math.max(w - tw_p - ARC9ScreenScale(2), 0), ARC9ScreenScale(12), w, true)

                render.SetScissorRect(0, 0, 0, 0, false)
            end
        end
    end

    ]]--
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_hud.lua:
local arc9_crosshair_force = GetConVar("arc9_crosshair_force")
local arc9_cross_enable = GetConVar("arc9_cross_enable")
local arc9_crosshair_static = GetConVar("arc9_crosshair_static")
local arc9_cross_size_mult = GetConVar("arc9_cross_size_mult")
local arc9_cross_size_dot = GetConVar("arc9_cross_size_dot")
local arc9_cross_size_prong = GetConVar("arc9_cross_size_prong")
local arc9_cross_r = GetConVar("arc9_cross_r")
local arc9_cross_g = GetConVar("arc9_cross_g")
local arc9_cross_b = GetConVar("arc9_cross_b")
local arc9_cross_a = GetConVar("arc9_cross_a")
local arc9_dev_crosshair = GetConVar("arc9_dev_crosshair")
local arc9_crosshair_peek = GetConVar("arc9_crosshair_peek")


function SWEP:ShouldDrawCrosshair()
    local crossh = self:GetProcessedValue("Crosshair", true) or arc9_crosshair_force:GetBool()
    if self:GetInSights() then

        if (self.Peeking and !self:GetProcessedValue("NoPeekCrosshair", true) and arc9_crosshair_peek:GetFloat() == 1) and crossh then
			return true
		end

		return self:GetSight().CrosshairInSights
    end
    if !crossh and !ARC9.ShouldThirdPerson() then return false end
    if self:GetCustomize() then return false end

    return true
end

local function drawshadowrect(x, y, w, h, col)
    surface.SetDrawColor(col)
    surface.DrawRect(x, y, w, h)
    surface.SetDrawColor(0, 0, 0, col.a * 100 / 150)
    surface.DrawOutlinedRect(x - 1, y - 1, w + 2, h + 2)
end

local lastgap = 0
local lasthelperalpha = 0

local lerp = Lerp
-- local arcticcolor = Color(255, 255, 255, 100)
local ARC9ScreenScale = ARC9.ScreenScale
local arc9_crosshair_target = GetConVar("arc9_crosshair_target")

function SWEP:DoDrawCrosshair(x, y)
    if !arc9_cross_enable:GetBool() then return end

    if string.find(self:GetIKAnimation() or "", "inspect") and self:StillWaiting() then lasthelperalpha = 0 return true end
    
    local scrw, scrh = ScrW(), ScrH()
    local owner = self:GetOwner()

    local staticcs = arc9_crosshair_static:GetBool()

    if staticcs then
        x = scrw / 2
        y = scrh / 2
    else
        local sp, sa = self:GetShootPos()

        local endpos = sp + (sa:Forward() * 9000)
        local toscreen = endpos:ToScreen()
    
        if ARC9.ShouldThirdPerson() then
            local tr = util.TraceLine({
                start = sp,
                endpos = endpos,
                mask = MASK_SHOT,
                filter = owner
            })
    
            toscreen = tr.HitPos:ToScreen()
        end
    
        x, y = toscreen.x, toscreen.y
    end

    local m = arc9_cross_size_mult:GetFloat()
    local sizeprong = arc9_cross_size_prong:GetFloat()

    local dotsize = ARC9ScreenScale(1) * m * arc9_cross_size_dot:GetFloat()
    local prong = ARC9ScreenScale(4) * m * sizeprong
    local minigap = ARC9ScreenScale(2) * m
    local miniprong_1 = ARC9ScreenScale(4) * m * sizeprong
    local miniprong_2 = ARC9ScreenScale(2) * m * sizeprong
    local gap = 0
    local staticgap = ARC9ScreenScale(4)
	local hidedot = self:GetProcessedValue("CrosshairHideDot", true)

    -- local col = Color(255, 255, 255, 255)
    -- col.r = arc9_cross_r:GetFloat()
    -- col.g = arc9_cross_g:GetFloat()
    -- col.b = arc9_cross_b:GetFloat()
    -- col.a =  arc9_cross_a:GetFloat()

	if owner.ARC9_AATarget != nil and arc9_crosshair_target:GetBool() then
		col = Color(255,0,0,255)
	else
		col = Color(255, 255, 255, 255)
		col.r = arc9_cross_r:GetFloat()
		col.g = arc9_cross_g:GetFloat()
		col.b = arc9_cross_b:GetFloat()
		col.a =  arc9_cross_a:GetFloat()
	end
		

    local d = self:GetSightDelta()

    prong = lerp(d, prong, ARC9ScreenScale(6))
    gap = lerp(d, gap, 0)
    minigap = lerp(d, minigap, ARC9ScreenScale(1))
    miniprong_1 = lerp(d, miniprong_1, ARC9ScreenScale(3))
    miniprong_2 = lerp(d, miniprong_2, ARC9ScreenScale(1))

    local helpertarget = 0

    col.a = lasthelperalpha * col.a

    if owner:IsAdmin() and arc9_dev_crosshair:GetBool() then
        self:DevStuffCrosshair()
        return true
    end

    if !self:ShouldDrawCrosshair() then
        --[[]
        if owner:KeyDown(IN_USE) then
            helpertarget = 1
        end
        ]]

        lasthelperalpha = math.Approach(lasthelperalpha, helpertarget, FrameTime() / 0.1)

		if !hidedot then drawshadowrect(x - (dotsize / 2), y - (dotsize / 2), dotsize, dotsize, col) end

        return true
    else
        helpertarget = 1

        lasthelperalpha = math.Approach(lasthelperalpha, helpertarget, FrameTime() / 0.1)
    end

    local mode = self:GetCurrentFiremode()

    local shoottimegap = math.Clamp((self:GetNextPrimaryFire() - CurTime()) / (60 / (self:GetProcessedValue("RPM", true) * 0.1)), 0, 1)

    shoottimegap = math.ease.OutCirc(shoottimegap)

    if staticcs then shoottimegap = 0 end

    cam.Start3D()
        local lool = ( EyePos() + ( EyeAngles():Forward() ) + ( (self:GetProcessedValue("Spread")) * EyeAngles():Up() ) ):ToScreen()
    cam.End3D()

    local gau = 0
    gau = ( (scrh / 2) - lool.y )

    gap = gap + gau

    gap = math.max(ARC9ScreenScale(4), gap)
    gap = gap + (shoottimegap * ARC9ScreenScale(8))

    lastgap = lerp(0.5, gap, lastgap)

    gap = lastgap

    if !hidedot then drawshadowrect(x - (dotsize / 2), y - (dotsize / 2), dotsize, dotsize, col) end

    if self:GetSprintAmount() > 0 then return true end
    if self:GetReloading() then return true end

    local forcestd = self:GetProcessedValue("ForceStandardCrosshair", true)

    if self:GetProcessedValue("CustomCrosshair", true) then
		surface.SetDrawColor(col)
		
		surface.SetMaterial( self:GetProcessedValue("CustomCrosshairMaterial", true) or Material("arc9/ui/share.png", "mips smooth") )
		
		local size = self:GetProcessedValue("CustomCrosshairSize", true) or 40
		
		if self:GetProcessedValue("CustomCrosshairSingle", true) then
			surface.DrawTexturedRectRotated(x, y, size + gap, size + gap, 0) -- Central
		else
			surface.DrawTexturedRectRotated(x - (dotsize / 2) - gap - ARC9.ScreenScale(11), y - (dotsize / 2), size, size, 0) -- Left
			surface.DrawTexturedRectRotated(x - (dotsize / 2) + gap + ARC9.ScreenScale(11), y - (dotsize / 2), size, size, 180) -- Right
			
			surface.DrawTexturedRectRotated(x - (dotsize / 2), y - (dotsize / 2) - gap - prong - ARC9.ScreenScale(7), size, size, -90) -- Top
			surface.DrawTexturedRectRotated(x - (dotsize / 2), y + (dotsize / 2) + gap + ARC9.ScreenScale(10), size, size, 90) -- Bottom
		end
	elseif self:GetProcessedValue("MissileCrosshair", true) then
        -- local dotcount = 4

        -- for i = 1, dotcount do
        --     local rad = i * math.pi * 2 / dotcount
        --     rad = rad - (math.pi / 4)
        --     local cx = math.cos(rad)
        --     local cy = math.sin(rad)

        --     cx = cx * gap * 3
        --     cy = cy * gap * 3

        --     drawshadowrect(x + cx - (dotsize / 2), y + cy - (dotsize / 2), dotsize, dotsize, col)
        -- end

        drawshadowrect(x - gap * 2.75 - (dotsize / 2), y - gap * 2.75 - (dotsize / 2), dotsize, dotsize, col)
        drawshadowrect(x + gap * 2.75 - (dotsize / 2), y - gap * 2.75 - (dotsize / 2), dotsize, dotsize, col)
        drawshadowrect(x - gap * 2.75 - (dotsize / 2), y + gap * 2.75 - (dotsize / 2), dotsize, dotsize, col)
        drawshadowrect(x + gap * 2.75 - (dotsize / 2), y + gap * 2.75 - (dotsize / 2), dotsize, dotsize, col)

        drawshadowrect(x - gap * 2.75 - (dotsize / 2), y - gap * 2 - (dotsize / 2), dotsize, gap * 1, col)
        drawshadowrect(x + gap * 2.75 - (dotsize / 2), y - gap * 2 - (dotsize / 2), dotsize, gap * 1, col)

        drawshadowrect(x - gap * 2.75 - (dotsize / 2), y - gap * -1 - (dotsize / 2), dotsize, gap * 1, col)
        drawshadowrect(x + gap * 2.75 - (dotsize / 2), y - gap * -1 - (dotsize / 2), dotsize, gap * 1, col)

        drawshadowrect(x - gap * 2 - (dotsize / 2), y - gap * 2.75 - (dotsize / 2), gap * 1, dotsize, col)
        drawshadowrect(x - gap * 2 - (dotsize / 2), y + gap * 2.75 - (dotsize / 2), gap * 1, dotsize, col)

        drawshadowrect(x - gap * -1 - (dotsize / 2), y - gap * 2.75 - (dotsize / 2), gap * 1, dotsize, col)
        drawshadowrect(x - gap * -1 - (dotsize / 2), y + gap * 2.75 - (dotsize / 2), gap * 1, dotsize, col)
    elseif (self:GetProcessedValue("ShootEnt", true) or self:GetProcessedValue("LauncherCrosshair", true)) and !forcestd then
        if mode > 1 then
            drawshadowrect(x - (dotsize / 2) - gap - miniprong_2, y - (dotsize / 2), miniprong_2, dotsize, col)
            drawshadowrect(x - (dotsize / 2) - gap - miniprong_2 - minigap - miniprong_1, y - (dotsize / 2), miniprong_1, dotsize, col)

            drawshadowrect(x - (dotsize / 2) + gap, y - (dotsize / 2), miniprong_2, dotsize, col)
            drawshadowrect(x - (dotsize / 2) + gap + miniprong_2 + minigap, y - (dotsize / 2), miniprong_1, dotsize, col)

            if mode > 2 then
                drawshadowrect(x - (dotsize / 2), y - (dotsize / 2) - gap - miniprong_2, dotsize, miniprong_2, col)
                drawshadowrect(x - (dotsize / 2), y - (dotsize / 2) - gap - miniprong_2 - minigap - miniprong_1, dotsize, miniprong_1, col)
            end
        elseif mode < 0 then
            -- Auto crosshair
            drawshadowrect(x - (dotsize / 2), y - (dotsize / 2) - gap - prong, dotsize, prong, col)
        else
            drawshadowrect(x - (dotsize / 2) - gap - prong, y - (dotsize / 2), prong, dotsize, col)
            drawshadowrect(x - (dotsize / 2) + gap, y - (dotsize / 2), prong, dotsize, col)
        end


        -- drawshadowrect(x - (dotsize / 2), y - (dotsize / 2) + gap * 1.25, dotsize, staticgap * 5, col)

        drawshadowrect(x - (dotsize / 2) - (minigap * 5), y - (dotsize / 2) + gap + (staticgap * 1), dotsize, dotsize, col)
        drawshadowrect(x - (dotsize / 2) + (minigap * 5), y - (dotsize / 2) + gap + (staticgap * 1), dotsize, dotsize, col)

        drawshadowrect(x - (dotsize / 2) - (minigap * 4), y - (dotsize / 2) + gap + (staticgap * 2.5), dotsize, dotsize, col)
        drawshadowrect(x - (dotsize / 2) + (minigap * 4), y - (dotsize / 2) + gap + (staticgap * 2.5), dotsize, dotsize, col)

        drawshadowrect(x - (dotsize / 2) - (minigap * 3), y - (dotsize / 2) + gap + (staticgap * 4), dotsize, dotsize, col)
        drawshadowrect(x - (dotsize / 2) + (minigap * 3), y - (dotsize / 2) + gap + (staticgap * 4), dotsize, dotsize, col)

        drawshadowrect(x - (dotsize / 2) - (minigap * 2), y - (dotsize / 2) + gap + (staticgap * 5.5), dotsize, dotsize, col)
        drawshadowrect(x - (dotsize / 2) + (minigap * 2), y - (dotsize / 2) + gap + (staticgap * 5.5), dotsize, dotsize, col)
    elseif self:GetProcessedValue("Num", true) > 1 and !forcestd then
        local dotcount = 10

        for i = 1, dotcount do
            local rad = i * math.pi * 2 / dotcount
            rad = rad - (math.pi / 2)
            local cx = math.cos(rad)
            local cy = math.sin(rad)

            cx = cx * gap
            cy = cy * gap

            drawshadowrect(x + cx - (dotsize / 2), y + cy - (dotsize / 2), dotsize, dotsize, col)
        end
    else
        if mode > 1 then
            -- Burst crosshair
            drawshadowrect(x - (dotsize / 2) - gap - miniprong_2, y - (dotsize / 2), miniprong_2, dotsize, col)
            drawshadowrect(x - (dotsize / 2) - gap - miniprong_2 - minigap - miniprong_1, y - (dotsize / 2), miniprong_1, dotsize, col)

            drawshadowrect(x + (dotsize / 2) + gap, y - (dotsize / 2), miniprong_2, dotsize, col)
            drawshadowrect(x + (dotsize / 2) + gap + miniprong_2 + minigap, y - (dotsize / 2), miniprong_1, dotsize, col)

            drawshadowrect(x - (dotsize / 2), y + (dotsize / 2) + gap, dotsize, miniprong_2, col)
            drawshadowrect(x - (dotsize / 2), y + (dotsize / 2) + gap + miniprong_2 + minigap, dotsize, miniprong_1, col)

            if mode > 2 then
                drawshadowrect(x - (dotsize / 2), y - (dotsize / 2) - gap - miniprong_2, dotsize, miniprong_2, col)
                drawshadowrect(x - (dotsize / 2), y - (dotsize / 2) - gap - miniprong_2 - minigap - miniprong_1, dotsize, miniprong_1, col)
            end
        elseif mode != 0 then
            drawshadowrect(x - (dotsize / 2) - gap - prong, y - (dotsize / 2), prong, dotsize, col)
            drawshadowrect(x + (dotsize / 2) + gap, y - (dotsize / 2), prong, dotsize, col)
            drawshadowrect(x - (dotsize / 2), y + (dotsize / 2) + gap, dotsize, prong, col)

            if mode < 0 then
                -- Auto crosshair
                drawshadowrect(x - (dotsize / 2), y - (dotsize / 2) - gap - prong, dotsize, prong, col)
            end
        end
    end

    return true
end

function SWEP:GetBinding(bind)
    local t_bind = input.LookupBinding(bind)

    if !t_bind then
        t_bind = "BIND " .. bind .. "!"
    end

    return string.upper(t_bind)
end

local bipodhint = 0 -- alpha
local bipodreloadmove = 0 -- ??
local bipodhintstate = false -- enter or exit
local fmhint = 0 -- alpha

local cv1, cv2, cv3, cv4

function SWEP:DrawHUD()
    self:RunHook("Hook_HUDPaintBackground")
    local scrw, scrh = ScrW(), ScrH()
    local getsight = self:GetSight()

	cv4 = cv4 or GetConVar("arc9_center_reload_enable")
	cv1 = cv1 or GetConVar("arc9_center_reload")
	jamcom = GetConVar("arc9_center_jam")

    local ubgl = self:GetUBGL()
	local rel = self:GetReloading()
	local throw = self.Throwable
	local primbash = self.PrimaryBash

    -- Bipod hint

    local ft1000 = RealFrameTime() * 1000
    bipodhint = math.max(0, bipodhint - ft1000)

    if self:GetBipod() then
        bipodhint = math.min(255, bipodhint + ft1000 * 2)
        bipodhintstate = true
    elseif self:CanBipod() and self:GetSightAmount() <= 0 then
        bipodhint = math.min(255, bipodhint + ft1000 * 2)
        bipodhintstate = false
    end

	cv3 = cv3 or GetConVar("arc9_center_bipod")
    if cv3:GetBool() and bipodhint > 0 then
        local glyph = ARC9.GetBindKey(bipodhintstate and "+back" or "+attack2")
        -- local text = bipodhintstate and "Exit bipod" or "Enter bipod"
		-- local text = bipodhintstate and ARC9:GetPhrase("hud.hint.bipod.exit") or ARC9:GetPhrase("hud.hint.bipod.enter")
		local text = ARC9:GetPhrase("hud.hint.bipod")
        local twbp = surface.GetTextSize(text)

        if ARC9.CTRL_Lookup[glyph] then glyph = ARC9.CTRL_Lookup[glyph] end
        if ARC9.CTRL_ConvertTo[glyph] then glyph = ARC9.CTRL_ConvertTo[glyph] end
        if ARC9.CTRL_Exists[glyph] then glyph = Material( "arc9/" .. ARC9.GlyphFamilyHUD() .. glyph .. ".png", "smooth" ) end

        surface.SetTextColor(255, 255, 255, bipodhint)
        surface.SetDrawColor(255, 255, 255, bipodhint)
        surface.SetFont("ARC9_16")
		
        local symbol = CreateControllerKeyLine({x = scrw / 2-ScreenScale(10) - (twbp * 0.5) + ScreenScale(5), y = scrh / 2 + ScreenScale(97), size = ScreenScale(8), font = "ARC9_12", font_keyb = "ARC9_12" }, { glyph, ScreenScale(7) })

        surface.SetFont("ARC9_10")
		
        surface.SetTextColor(0, 0, 0, bipodhint) -- Black
        surface.SetTextPos(scrw / 2 + 2 - twbp / 2 + ScreenScale(5), scrh / 2 + 2 + ScreenScale(97))
        surface.DrawText(text)
		
        surface.SetTextColor(255, 255, 255, bipodhint) -- White
        surface.SetTextPos(scrw / 2 - twbp / 2 + ScreenScale(5), scrh / 2 + ScreenScale(97))
        surface.DrawText(text)
    end

	if !ubgl then
		magazine = self:Clip1()
		mag = magazine <= self:GetMaxClip1()*cv1:GetFloat()
		maxmag = self.Owner:GetAmmoCount(self.Primary.Ammo)
	else
		magazine = self:Clip2()
		mag = magazine <= self:GetMaxClip2()*cv1:GetFloat()
		maxmag = self.Owner:GetAmmoCount(self.Secondary.Ammo)
	end

	local blink = 255 * math.abs(math.sin(CurTime() * 5))

	local glyph = ARC9.GetBindKey("+reload")
	
	if ARC9.CTRL_Lookup[glyph] then glyph = ARC9.CTRL_Lookup[glyph] end
	if ARC9.CTRL_ConvertTo[glyph] then glyph = ARC9.CTRL_ConvertTo[glyph] end
	if ARC9.CTRL_Exists[glyph] then glyph = Material( "arc9/" .. ARC9.GlyphFamilyHUD() .. glyph .. ".png", "smooth" ) end

    if (cv4:GetBool() and (cv1:GetFloat() > 0.02)) and !(string.find(self:GetIKAnimation() or "", "inspect") and self:StillWaiting()) and !self:GetJammed() then
		if !rel and !throw and !primbash and mag then
			local text = ARC9:GetPhrase("hud.hint.reload")
			local textlow = ARC9:GetPhrase("hud.hint.lowammo")
			local textempty = ARC9:GetPhrase("hud.hint.noammo")

			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetFont("ARC9_12")
			
			local tw = surface.GetTextSize(text)
			local twlow = surface.GetTextSize(textlow)
			local twempty = surface.GetTextSize(textempty)
			local ia = GetConVar("arc9_infinite_ammo"):GetBool()

			if !ia and (magazine == 0 and maxmag == 0) then -- If no ammo and no reserve
				surface.SetTextPos(scrw / 2 + 2 - twlow / 2, scrh / 2 + 2 + ScreenScale(97) + (bipodhint / 7.5)) -- Black
				surface.SetTextColor(0, 0, 0, blink)
				surface.DrawText(textempty)
				
				surface.SetTextPos(scrw / 2 - twlow / 2, scrh / 2 + ScreenScale(97) + (bipodhint / 7.5)) -- White
				surface.SetTextColor(255, 100, 100, blink)
				surface.DrawText(textempty)
			elseif !ia and mag and maxmag == 0 then -- If low on ammo with no reserve ammo
				surface.SetTextPos(scrw / 2 + 2 - twlow / 2, scrh / 2 + 2 + ScreenScale(97) + (bipodhint / 7.5)) -- Black
				surface.SetTextColor(0, 0, 0, blink)
				surface.DrawText(textlow)
				
				surface.SetTextPos(scrw / 2 - twlow / 2, scrh / 2 + ScreenScale(97) + (bipodhint / 7.5)) -- White
				surface.SetTextColor(255, 255, 100, blink)
				surface.DrawText(textlow)
			elseif (ia and mag) or (!ia and mag and maxmag > 0) then -- If low on ammo and have reserve ammo
				surface.SetTextColor(255, 255, 255, 255)
				local symbol = CreateControllerKeyLine({x = scrw / 2-ScreenScale(10) - (tw * 0.5) + ScreenScale(5), y = scrh / 2 + 7.5 + ScreenScale(96) + (bipodhint / 7.5), size = ScreenScale(8), font = "ARC9_12", font_keyb = "ARC9_12" }, { glyph, ScreenScale(7) })
				
				surface.SetTextPos(scrw / 2 - tw / 2 + 2 + ScreenScale(5), scrh / 2 + 2 + ScreenScale(97) + (bipodhint / 7.5)) -- Black
				surface.SetTextColor(0, 0, 0, blink)
				surface.DrawText(text)
				
				surface.SetTextPos(scrw / 2 - tw / 2 + ScreenScale(5), scrh / 2 + ScreenScale(97) + (bipodhint / 7.5)) -- White
				surface.SetTextColor(255, 255, 255, blink)
				surface.DrawText(text)
			end
		end
    end
			
	if jamcom:GetBool() and self:GetJammed() and not self:StillWaiting() then -- If weapon is Jammed
        if !self:GetProcessedValue("Overheat", true) then -- overheat makes guns auto unjam so hint is useless
            local textunjam = ARC9:GetPhrase("hud.hint.unjam")
            local twunjam = surface.GetTextSize(textunjam)
            
            surface.SetDrawColor(255, 255, 255, 255)
            surface.SetFont("ARC9_10")
            
            surface.SetTextColor(255, 255, 255, 255)
			local symbol = CreateControllerKeyLine({x = scrw / 2-ScreenScale(10) - (twunjam * 0.5) + ScreenScale(5), y = scrh / 2 + 7.5 + ScreenScale(96) + (bipodhint / 7.5), size = ScreenScale(8), font = "ARC9_12", font_keyb = "ARC9_12" }, { glyph, ScreenScale(7) })
			
			surface.SetTextPos(scrw / 2 - twunjam / 2 + 2 + ScreenScale(5), scrh / 2 + 2 + ScreenScale(97) + (bipodhint / 7.5)) -- Black
			surface.SetTextColor(0, 0, 0, blink)
			surface.DrawText(textunjam)
			
			surface.SetTextPos(scrw / 2 - twunjam / 2 + ScreenScale(5), scrh / 2 + ScreenScale(97) + (bipodhint / 7.5)) -- White
			surface.SetTextColor(255, 255, 255, blink)
			surface.DrawText(textunjam)
        end
	end

local cvo = GetConVar("arc9_center_overheat"):GetBool()
local ah = GetConVar("arc9_hud_arc9"):GetBool()

	if cvo and !ah and self:GetProcessedValue("Overheat", true) then
		local heat = self:GetHeatAmount()
		local heatcap = self:GetProcessedValue("HeatCapacity", true)
		local heatlocked = self:GetHeatLockout()
		local hud_t_full = Material("arc9/thermometer_full.png", "mips")
		local hud_t_empty = Material("arc9/thermometer_empty.png", "mips")
		local fill = math.Clamp(0.035 + (0.9 * heat) / heatcap, 0, 1)
		local wp = 25
		local xp = 70
		local col = {
			white = Color(255,255,255, heat * 1.5),
			black = Color(0,0,0, heat * 1.5),
			red = Color(255,255,255, heat * 1.5),
			redblink = Color(255, 255 * math.abs(math.sin(CurTime() * 5)), 255 * math.abs(math.sin(CurTime() * 5)), heat * 1.5),
		}

		local flashheatbar = false
		if heatlocked then flashheatbar = true end

		local heat_col = col["white"]

		if GetConVar("arc9_center_overheat_dark"):GetBool() then heat_col = col["black"] end

		if heat > (heatcap * 0.75) then
			heat_col = col["redblink"]
		end

		surface.SetDrawColor(col.black)
		surface.SetMaterial(hud_t_full)
		surface.DrawTexturedRectUV(scrw / 2 - ScreenScale(wp), scrh / 2 + ScreenScale(xp), math.ceil(150 * fill), 60, 0, 0, fill, 1)

		surface.SetDrawColor(heat_col)
		surface.SetMaterial(hud_t_full)
		surface.DrawTexturedRectUV(scrw / 2 - ScreenScale(wp), scrh / 2 + ScreenScale(xp), math.ceil(150 * fill), 60, 0, 0, fill, 1)

		surface.SetDrawColor(col.black)
		surface.SetMaterial(hud_t_empty)
		surface.DrawTexturedRectUV(scrw / 2 - ScreenScale(wp) + math.ceil(150 * fill), scrh / 2 + ScreenScale(xp), 150 * (1 - fill), 60, fill, 0, 1, 1)

		surface.SetDrawColor(heat_col)
		surface.SetMaterial(hud_t_empty)
		surface.DrawTexturedRectUV(scrw / 2 - ScreenScale(wp) + math.ceil(150 * fill), scrh / 2 + ScreenScale(xp), 150 * (1 - fill), 60, fill, 0, 1, 1)
	end

    if self:GetSightAmount() > 0.75 and getsight.FlatScope and getsight.FlatScopeOverlay then
        if getsight.FlatScopeBlackBox then
            surface.SetMaterial(getsight.FlatScopeOverlay)
            surface.SetDrawColor(255, 255, 255)
            surface.DrawTexturedRect((scrw - scrh) / 2, 0, scrh, scrh)

            surface.SetDrawColor(0, 0, 0)
            surface.DrawRect(0, 0, (scrw - scrh) / 2, scrh)
            surface.DrawRect(scrw - (scrw - scrh) / 2, 0, (scrw - scrh) / 2, scrh)
        else
            surface.SetMaterial(getsight.FlatScopeOverlay)
            surface.SetDrawColor(255, 255, 255)
            surface.DrawTexturedRect(0, (scrh - scrw) / 2, scrw, scrw)
        end
    end

	local function fmhintignore()
		local fmodes = self:GetValue("Firemodes")

		-- if !self:GetOwner():KeyDown(IN_USE) and #fmodes < 2 then return end
		if self:StillWaiting() then return end
		if self:GetProcessedValue("NoFiremodeWhenEmpty", true) and self:Clip1() <= 0 then return end
		if self:GetUBGL() then return end
	
		self.FMHintTime = CurTime()
	end

	-- local fmhintdrawtime = math.Clamp(1 - (self:GetReloadFinishTime() - CurTime()) / (self.ReloadTime * self:GetAnimationTime("reload")), 0, 1)
	-- local fmhintdrawanim = self:GetAnimationEntry(self:TranslateAnimation("reload"))
	
	local bzoom = self:GetOwner():KeyPressed(IN_ZOOM)
	local batt = self:GetOwner():KeyDown(IN_ATTACK)

	local fmc = GetConVar("arc9_center_firemode_time")

	-- if self:GetOwner():KeyPressed(IN_ZOOM) or (fmhintdrawtime > 0.5 and fmhintdrawtime < 0.51) then fmhintignore() end
	
	if bzoom or (self:GetSafe() and batt) then fmhintignore() end

    local ft1000 = RealFrameTime() * 2000
    fmhint = math.max(0, fmhint - ft1000 * 1.25)
	
    if self.FMHintTime and CurTime() > self.FMHintTime + 0.15 and CurTime() < self.FMHintTime + (fmc:GetFloat() or 1) + 0.15 then
        fmhint = math.min(255, fmhint + ft1000 * 2)
    end

    if GetConVar("arc9_center_firemode"):GetBool() and fmhint > 0 then
		local text = self:GetFiremodeName()

        surface.SetTextColor(0, 0, 0, fmhint)
        surface.SetDrawColor(255, 255, 255, fmhint)
        surface.SetFont("ARC9_10")
        local tw = surface.GetTextSize(text)
        surface.SetTextPos(scrw / 2 - tw / 2, scrh / 2 + ScreenScale(60))
        surface.DrawText(text)
		
        surface.SetTextColor(255, 255, 255, fmhint)
        surface.SetTextPos(scrw / 2 - tw / 2 - 2, scrh / 2 + ScreenScale(60) - 2)
        surface.DrawText(text)
    end

	cv2 = cv2 or GetConVar("arc9_cruelty_reload")
    if cv2:GetBool() and input.IsKeyDown(input.GetKeyCode(self:GetBinding("+reload"))) then
        -- Draw vertical line

        local col = Color(255, 255, 255, 255)

        local reloadline_x = scrw * 3 / 4

        surface.SetDrawColor(col)
        surface.DrawLine(reloadline_x, 0, reloadline_x, scrh)

        local reloadline_target_w = scrw / 20
        local reloadline_target_y = scrh * 2 / 3

        surface.DrawLine(reloadline_x - (reloadline_target_w / 2), reloadline_target_y, reloadline_x + (reloadline_target_w / 2), reloadline_target_y)

        surface.SetFont("ARC9_16")
        local text = "Reload"
        local text_w, text_h = surface.GetTextSize(text)

        surface.SetTextPos(reloadline_x + ARC9ScreenScale(2), reloadline_target_y - text_h)
        surface.SetTextColor(col)
        surface.DrawText(text)

        surface.SetFont("ARC9_16")
        local text2 = "Drag down to reload!!!"
        local text2_w, text2_h = surface.GetTextSize(text2)

        surface.SetTextPos(reloadline_x + ARC9ScreenScale(2), reloadline_target_y + ARC9ScreenScale(2))
        surface.SetTextColor(Color(255, 255, 255, 255 * math.abs(math.sin(CurTime() * 5))))
        surface.DrawText(text2)

        local reloadline_mover_y = reloadline_target_y * ARC9.ReloadAmount

        surface.DrawLine(reloadline_x - (reloadline_target_w / 2), reloadline_mover_y, reloadline_x + (reloadline_target_w / 2), reloadline_mover_y)
    end

    self:HoldBreathHUD()
    self:DrawCustomizeHUD()

    self:DrawLockOnHUD(false)

    self:RunHook("Hook_HUDPaint")
end

SWEP.InvalidateSelectIcon = false

function SWEP:DrawWeaponSelection(x, y, w, h, a)
    if self.EntitySelectIcon then
        if !self.Mat_Select then
            self.Mat_Select = Material("entities/" .. self:GetClass() .. ".png")
        end

        surface.SetDrawColor(255, 255, 255, a)
        surface.SetMaterial(self.Mat_Select)

        if w > h then
            y = y - ((w - h) / 2)
        end

        surface.DrawTexturedRect(x, y, w, w)
        return
    elseif self.CustomSelectIcon then
        surface.SetDrawColor(255, 255, 255, a)
        surface.SetMaterial(self.CustomSelectIcon)

        h = w / 2

         y = y + (h / 8)

        surface.DrawTexturedRect(x, y, w, h)
        return
    end

    local selecticon = self.AutoSelectIcon

    if !selecticon or self.InvalidateSelectIcon then
        self:DoIconCapture()

        local filename = ARC9.PresetPath .. self:GetPresetBase() .. "_icon." .. ARC9.PresetIconFormat
        selecticon = Material("data/" .. filename, "smooth")
    end

    if !selecticon then return end

    self.WepSelectIcon = selecticon:GetTexture("$basetexture")
    if self:GetJammed() then  
        surface.SetDrawColor(200, 50, 50, a)
    else
        surface.SetDrawColor(255, 255, 255, a)
    end

    surface.SetMaterial(selecticon)
    if w > h then
        y = y - ((w - h) / 2)
    end
    surface.DrawTexturedRect(x, y, w, w)
    // surface.DrawTexturedRectUV(x, y, w, w, 0, 0, 1, 1)
end

SWEP.AutoSelectIcon = nil

function SWEP:DoIconCapture()
    self:DoPresetCapture(ARC9.PresetPath .. self:GetPresetBase() .. "_icon")
end

function SWEP:RangeUnitize(range)
	if GetConVar("arc9_imperial"):GetBool() then return tostring(math.Round(range * ARC9.HUToM * 1.0936)) .. ARC9:GetPhrase("unit.yard") end
    return tostring(math.Round(range * ARC9.HUToM)) .. ARC9:GetPhrase("unit.meter")
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_light.lua:
SWEP.Flashlights = {} -- tracks projectedlights
-- {{att = int, light = ProjectedTexture}}

function SWEP:GetHasFlashlights()
    for i, k in ipairs(self:GetAttachmentList()) do
        local atttbl = self:GetFinalAttTable(k)

        if atttbl.Flashlight then return true end
    end

    return false
end

function SWEP:CreateFlashlights()
    self:KillFlashlights()
    self.Flashlights = {}

    local total_lights = 0

    for _, k in ipairs(self:GetSubSlotList()) do
        if !k.Installed then continue end
        local atttbl = self:GetFinalAttTable(k)

        if atttbl.Flashlight then
            local newlight = {
                slottbl = k,
                light = ProjectedTexture(),
                col = atttbl.FlashlightColor or color_white,
                br = atttbl.FlashlightBrightness or 3,
                qca = atttbl.FlashlightAttachment,
                nodotter = atttbl.Flashlight360
            }

            total_lights = total_lights + 1

            local l = newlight.light
            if !IsValid(l) then continue end

            table.insert(self.Flashlights, newlight)

            l:SetFOV(atttbl.FlashlightFOV or 50)


            l:SetFarZ(atttbl.FlashlightDistance or 1024)
            l:SetNearZ(4)

            l:SetQuadraticAttenuation(100)

            l:SetColor(atttbl.FlashlightColor or color_white)
            l:SetTexture(atttbl.FlashlightMaterial or "effects/flashlight001")
            l:SetBrightness(atttbl.FlashlightBrightness or 3)
            l:SetEnableShadows(true)
            l:Update()

            local g_light = {
                Weapon = self,
                ProjectedTexture = l
            }

            table.insert(ARC9.FlashlightPile, g_light)
        end
    end

    if total_lights > 1 then -- you are a madman
        for i, k in ipairs(self.Flashlights) do
            if k.light:IsValid() then k.light:SetEnableShadows(false) end
        end
    end
end

function SWEP:KillFlashlights()
    if !self.Flashlights then return end

    for i, k in ipairs(self.Flashlights) do
        if k.light and k.light:IsValid() then
            k.light:Remove()
        end
    end

    self.Flashlights = nil
end

local arc9_allflash = GetConVar("arc9_allflash")
local fuckingbullshit = Vector(0, 0, 0.001)

function SWEP:DrawFlashlightsWM()
    local owner = self:GetOwner()
    local lp = LocalPlayer()

    if (!arc9_allflash:GetBool()) and owner != lp then return end

    if !self.Flashlights then
        self:CreateFlashlights()
    end
    
    for i, k in ipairs(self.Flashlights) do
        local model = (k.slottbl or {}).WModel

        if !IsValid(model) then continue end

        local pos, ang


        if !model then
            pos = owner:EyePos()
            ang = owner:EyeAngles()
        else
            pos = model:GetPos()
            ang = model:GetAngles()
        end


        if k.qca then
            local a = model:GetAttachment(k.qca)
            if a then pos, ang = a.Pos, a.Ang end
        end
        
        self:DrawLightFlare(pos + fuckingbullshit, ang, k.col, k.br * 20, i, nil, k.nodotter)

        if k.qca then ang:RotateAroundAxis(ang:Up(), 90) end

        -- ang:RotateAroundAxis(ang:Up(), 90)

        local tr = util.TraceLine({
            start = pos,
            endpos = pos + ang:Forward() * 16,
            mask = MASK_OPAQUE,
            filter = lp,
        })
        if tr.Fraction < 1 then -- We need to push the flashlight back
            local tr2 = util.TraceLine({
                start = pos,
                endpos = pos - ang:Forward() * 16,
                mask = MASK_OPAQUE,
                filter = lp,
            })
            -- push it as back as the area behind us allows
            pos = pos + -ang:Forward() * 16 * math.min(1 - tr.Fraction, tr2.Fraction)
        else
            pos = tr.HitPos
        end

        k.light:SetPos(pos)
        k.light:SetAngles(ang)
        k.light:Update()
    end
end

function SWEP:DrawFlashlightsVM()
    if !self.Flashlights then
        self:CreateFlashlights()
    end

    local owner = self:GetOwner()
    local lp = LocalPlayer()
    local eyepos = owner:EyePos()

    for i, k in ipairs(self.Flashlights) do
        local model = (k.slottbl or {}).VModel

        if !IsValid(model) then continue end

        local pos, ang

        if !model then
            pos = eyepos
            ang = owner:EyeAngles()
        else
            pos = model:GetPos()
            ang = model:GetAngles()
        end

        if k.qca then
            a = model:GetAttachment(k.qca)

            if a then
                pos, ang = a.Pos, a.Ang
            else
                ang:RotateAroundAxis(ang:Up(), -90)
            end
        end

        self:DrawLightFlare(pos, ang, k.col, k.br * 25, i, true, k.nodotter)

        if k.qca then ang:RotateAroundAxis(ang:Up(), 90) end

        local tr = util.TraceLine({
            start = eyepos,
            endpos = eyepos - -ang:Forward() * 128,
            mask = MASK_OPAQUE,
            filter = lp,
        })
        if tr.Fraction < 1 then -- We need to push the flashlight back
            local tr2 = util.TraceLine({
                start = eyepos,
                endpos = eyepos + -ang:Forward() * 128,
                mask = MASK_OPAQUE,
                filter = lp,
            })
            -- push it as back as the area behind us allows
            pos = pos + -ang:Forward() * 128 * math.min(1 - tr.Fraction, tr2.Fraction)
        end

        k.light:SetPos(pos)
        k.light:SetAngles(ang)
        k.light:Update()
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_rhik.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_rhik.lua:
local function qerp(delta, a, b)
    local qdelta = -(delta ^ 2) + (delta * 2)
    qdelta = math.Clamp(qdelta, 0, 1)

    return Lerp(qdelta, a, b)
end

function SWEP:DoRHIK(wm)
    -- local vm = self:GetOwner():GetHands()
    local vm = self:GetVM()
    if wm then vm = self:GetWM() end
    if !IsValid(vm) then return end
    if !self.UseHands then return end
    vm:SetupBones()
    local lh_delta = 1
    local rh_delta = 1
    -- local lhik_bf_d = self:GetBlindFireAmount() - (math.abs(self:GetBlindFireCornerAmount()))
    local hide_lh_d = 0
    local hide_rh_d = 0
    hide_lh_d = self.CustomizeDelta
    hide_rh_d = self.CustomizeDelta
    hide_lh_d = math.ease.InCubic(hide_lh_d)
    hide_rh_d = math.ease.InCubic(hide_rh_d)
    if ARC9.PresetCam then
        hide_lh_d = 1
        hide_rh_d = 1
    end
    local iktl = (self.Animations[self:GetIKAnimation() or ""] or {}).IKTimeLine
    local iket = self:GetIKTime()
    local iklt = math.Clamp((CurTime() - self:GetIKTimeLineStart()) / iket, 0, 1)

    if iktl then
        if self:GetProcessedValue("LHIK", true) then
            local next_stage_index

            for i, k in ipairs(iktl) do
                if !k or !k.t then continue end

                if k.t > iklt then
                    next_stage_index = i
                    break
                end
            end

            if next_stage_index then
                if next_stage_index == 1 then
                    -- we are on the first stage.
                    stage = {
                        t = 0,
                        lhik = 0
                    }

                    next_stage = iktl[next_stage_index]
                else
                    stage = iktl[next_stage_index - 1]
                    next_stage = iktl[next_stage_index]
                end
            else
                stage = iktl[#iktl]

                next_stage = {
                    t = iket,
                    lhik = iktl[#iktl].lhik
                }
            end

            local local_time = iklt
            local delta_time = next_stage.t - stage.t
            delta_time = (local_time - stage.t) / delta_time
            delta_time = math.ease.InOutQuart(delta_time)
            lh_delta = qerp(delta_time, stage.lhik or 0, next_stage.lhik or 0)
        end

        if self:GetProcessedValue("RHIK", true) then
            local next_stage_index

            for i, k in ipairs(iktl) do
                if !k or !k.t then continue end

                if k.t > iklt then
                    next_stage_index = i
                    break
                end
            end

            if next_stage_index then
                if next_stage_index == 1 then
                    -- we are on the first stage.
                    stage = {
                        t = 0,
                        rhik = 0
                    }

                    next_stage = iktl[next_stage_index]
                else
                    stage = iktl[next_stage_index - 1]
                    next_stage = iktl[next_stage_index]
                end
            else
                stage = iktl[#iktl]

                next_stage = {
                    t = iket,
                    rhik = iktl[#iktl].rhik
                }
            end

            local local_time = iklt
            local delta_time = next_stage.t - stage.t
            delta_time = (local_time - stage.t) / delta_time
            delta_time = math.ease.InOutQuart(delta_time)
            rh_delta = qerp(delta_time, stage.rhik or 0, next_stage.rhik or 0)
        end
    end

    local rhik_model = self.RHIKModel

    if wm then
        rhik_model = self.RHIKModelWM
    end

    if IsValid(rhik_model) then
        rhik_model:SetupBones()

        for _, bone in ipairs(ARC9.RHIKBones) do
            local vm_bone = vm:LookupBone(bone)
            local target_bone = rhik_model:LookupBone(bone)
            if !vm_bone or !target_bone then continue end
            local vm_bone_matrix = vm:GetBoneMatrix(vm_bone)
            local target_bone_matrix = rhik_model:GetBoneMatrix(target_bone)
            local lerped_pos = LerpVector(rh_delta, vm_bone_matrix:GetTranslation(), target_bone_matrix:GetTranslation())
            local lerped_ang = LerpAngle(rh_delta, vm_bone_matrix:GetAngles(), target_bone_matrix:GetAngles())
            local newtransform = Matrix()
            newtransform:SetTranslation(lerped_pos)
            newtransform:SetAngles(lerped_ang)
            local matrix = Matrix(newtransform)
            vm:SetBoneMatrix(vm_bone, matrix)
        end
    end

    local lhik_model = self.LHIKModel

    if wm then
        lhik_model = self.LHIKModelWM
    end

    if IsValid(lhik_model) then
        lhik_model:SetupBones()

        for _, bone in ipairs(ARC9.LHIKBones) do
            local vm_bone = vm:LookupBone(bone)
            local target_bone = lhik_model:LookupBone(bone)
            if !vm_bone or !target_bone then continue end
            local vm_bone_matrix = vm:GetBoneMatrix(vm_bone)
            local target_bone_matrix = lhik_model:GetBoneMatrix(target_bone)
            local lerped_pos = LerpVector(lh_delta, vm_bone_matrix:GetTranslation(), target_bone_matrix:GetTranslation())
            local lerped_ang = LerpAngle(lh_delta, vm_bone_matrix:GetAngles(), target_bone_matrix:GetAngles())
            local newtransform = Matrix()
            newtransform:SetTranslation(lerped_pos)
            newtransform:SetAngles(lerped_ang)
            vm:SetBoneMatrix(vm_bone, newtransform)
        end
    end

    if wm then return end

    self:LHIKThirdArm()
    local enable_ik = false
    -- obsolete lol
    if enable_ik then
        local rupperarm, rforearm, rulna, rwrist, rhand = vm:LookupBone("ValveBiped.Bip01_R_UpperArm"), vm:LookupBone("ValveBiped.Bip01_R_Forearm"), vm:LookupBone("ValveBiped.Bip01_R_Ulna"), vm:LookupBone("ValveBiped.Bip01_R_Wrist"), vm:LookupBone("ValveBiped.Bip01_R_Hand")
        local lupperarm, lforearm, lulna, lwrist, lhand = vm:LookupBone("ValveBiped.Bip01_L_UpperArm"), vm:LookupBone("ValveBiped.Bip01_L_Forearm"), vm:LookupBone("ValveBiped.Bip01_L_Ulna"), vm:LookupBone("ValveBiped.Bip01_L_Wrist"), vm:LookupBone("ValveBiped.Bip01_L_Hand")
        local rupperarm_matrix, rhand_matrix = vm:GetBoneMatrix(rupperarm), vm:GetBoneMatrix(rhand)
        local lupperarm_matrix, lhand_matrix = vm:GetBoneMatrix(lupperarm), vm:GetBoneMatrix(lhand)
        local rforearm_matrix = vm:GetBoneMatrix(rforearm)
        local lforearm_matrix = vm:GetBoneMatrix(lforearm)
        local rarm_start, rhand_end = rupperarm_matrix:GetTranslation(), rhand_matrix:GetTranslation()
        local larm_start, lhand_end = lupperarm_matrix:GetTranslation(), lhand_matrix:GetTranslation()
        local rupperarm_length, rarm_length = 10, 10
        local lupperarm_length, larm_length = 10, 10
        -- local rupperarm_length, rarm_length = vm:BoneLength(rupperarm), vm:BoneLength(rforearm)
        -- if rupperarm_length > 15 or rarm_length > 15 or rupperarm_length < 5 or rarm_length < 5 then
        --     rupperarm_length = 8
        --     rarm_length = 8
        -- end
        -- local lupperarm_length, larm_length = vm:BoneLength(lupperarm), vm:BoneLength(lforearm)
        -- if lupperarm_length < 5 or larm_length < 5 then
        --     lupperarm_length = 8
        --     larm_length = 8
        -- end
        -- lupperarm_length = lupperarm_length + 2
        -- larm_length = larm_length + 2
        rupperarm_matrix, rhand_matrix = vm:GetBoneMatrix(rupperarm), vm:GetBoneMatrix(rhand)
        lupperarm_matrix, lhand_matrix = vm:GetBoneMatrix(lupperarm), vm:GetBoneMatrix(lhand)
        rarm_start = rupperarm_matrix:GetTranslation()
        -- rarm_start = EyePos() + (EyeAngles():Right() * 4) + (EyeAngles():Up() * -8) + (EyeAngles():Forward() * -1)
        larm_start = lupperarm_matrix:GetTranslation()
        -- larm_start = EyePos() + (EyeAngles():Right() * -6) + (EyeAngles():Up() * -8) + (EyeAngles():Forward() * -1)
        local rupperarm_position, rforearm_position = self:Solve2PartIK(rarm_start, rhand_end, rupperarm_length, rarm_length, 0)
        local lupperarm_position, lforearm_position = self:Solve2PartIK(larm_start, lhand_end, lupperarm_length, larm_length, 0)
        
        debugoverlay.Line(rarm_start, rupperarm_position, 0.1, color_white, true)
        debugoverlay.Line(rforearm_position, rupperarm_position, 0.1, color_white, true)
        debugoverlay.Line(rforearm_position, rhand_end, 0.1, color_white, true)
        debugoverlay.Line(larm_start, lupperarm_position, 0.1, color_white, true)
        debugoverlay.Line(lforearm_position, lupperarm_position, 0.1, color_white, true)
        debugoverlay.Line(lforearm_position, lhand_end, 0.1, color_white, true)

        -- rupperarm_matrix:SetTranslation(rupperarm_position)
        -- brought to you by: https://rubberduckdebugging.com/
        -- get one today!
        -- right
        if self:GetValue("RHIK") and enable_ik then
            local rupperarm_dir = (rupperarm_position - rupperarm_matrix:GetTranslation())
            local rupperarm_ang = rupperarm_dir:Angle()
            rupperarm_ang.r = 90 -- rupperarm_dir:Angle()
            rupperarm_matrix:SetAngles(rupperarm_ang)
            local rupperarm_norm = (rupperarm_position - rarm_start)
            rupperarm_norm:Normalize()
            rupperarm_matrix:SetTranslation(rarm_start - rupperarm_norm * 0)
            local rforearm_norm = (rforearm_position - rforearm_matrix:GetTranslation())
            rforearm_norm:Normalize()
            rforearm_matrix:SetTranslation(rupperarm_position + rforearm_norm * 0)
            local rforearm_dir = rhand_end - rupperarm_position
            local rforearm_ang = 90 -- rforearm_dir:Angle()
            rforearm_ang.r = rforearm_dir:Angle()
            rforearm_matrix:SetAngles(rforearm_ang)

            vm:SetBoneMatrix(rupperarm, rupperarm_matrix)
            vm:SetBoneMatrix(rforearm, rforearm_matrix)

            if rulna and rwrist then
                local rwrist_matrix = vm:GetBoneMatrix(rwrist)
                local rulna_matrix = vm:GetBoneMatrix(rulna)
                local rwrist_angle = (rwrist_matrix:GetTranslation() - rupperarm_position):Angle()
                rwrist_matrix:SetAngles(rwrist_angle)
                vm:SetBoneMatrix(rwrist, rwrist_matrix)
                -- rwrist_angle.r = rwrist_matrix:GetAngles().r + 90
                rulna_matrix:SetTranslation(rwrist_matrix:GetTranslation() - (rwrist_angle:Forward() * 0))
                rulna_matrix:SetAngles(rwrist_angle)
                vm:SetBoneMatrix(rulna, rulna_matrix)
            end
        end

        -- brought to you by: https://rubberduckdebugging.com/
        -- get one today!
        -- left
        if self:GetValue("LHIK") and enable_ik then
            local lupperarm_dir = (lupperarm_position - lupperarm_matrix:GetTranslation())
            local lupperarm_ang = lupperarm_dir:Angle()
            lupperarm_ang.r = -125 -- lupperarm_matrix:GetAngles().r
            lupperarm_matrix:SetAngles(lupperarm_ang)
            local lupperarm_norm = (lupperarm_position - larm_start)
            lupperarm_norm:Normalize()
            lupperarm_matrix:SetTranslation(larm_start - (lupperarm_norm * 0))
            local lforearm_norm = (lforearm_position - lforearm_matrix:GetTranslation())
            lforearm_norm:Normalize()
            lforearm_matrix:SetTranslation(lupperarm_position + (lforearm_norm * 0))
            local lforearm_dir = lhand_end - lupperarm_position
            local lforearm_ang = lforearm_dir:Angle()
            lforearm_ang.r = -90 -- lforearm_matrix:GetAngles().r
            lforearm_matrix:SetAngles(lforearm_ang)
            vm:SetBoneMatrix(lupperarm, lupperarm_matrix)
            vm:SetBoneMatrix(lforearm, lforearm_matrix)

            if lulna and lwrist then
                local lwrist_matrix = vm:GetBoneMatrix(lwrist)
                local lulna_matrix = vm:GetBoneMatrix(lulna)
                local lwrist_angle = (lwrist_matrix:GetTranslation() - lupperarm_position):Angle()
                lwrist_matrix:SetTranslation(lwrist_matrix:GetTranslation())
                lwrist_matrix:SetAngles(lwrist_angle)
                vm:SetBoneMatrix(lwrist, lwrist_matrix)
                -- lwrist_angle.r = lwrist_matrix:GetAngles().r + 90
                lulna_matrix:SetTranslation(lwrist_matrix:GetTranslation() - (lwrist_angle:Forward() * 0))
                lulna_matrix:SetAngles(lwrist_angle)
                vm:SetBoneMatrix(lulna, lulna_matrix)
            end
        end
    end

    if hide_lh_d > 0 then
        for _, bone in ipairs(ARC9.LHIKBones) do
            local vmbone = vm:LookupBone(bone)
            if !vmbone then continue end -- Happens when spectating someone prolly
            local vmtransform = vm:GetBoneMatrix(vmbone)
            if !vmtransform then continue end -- something very bad has happened
            local vm_pos = vmtransform:GetTranslation()
            local vm_ang = vmtransform:GetAngles()
            local newtransform = Matrix()
            newtransform:SetTranslation(LerpVector(hide_lh_d, vm_pos, vm_pos - (EyeAngles():Up() * 48) - (EyeAngles():Forward() * 16)))
            newtransform:SetAngles(vm_ang)
            vm:SetBoneMatrix(vmbone, newtransform)
        end
    end

    if hide_rh_d > 0 then
        for _, bone in ipairs(ARC9.RHIKBones) do
            local vmbone = vm:LookupBone(bone)
            if !vmbone then continue end -- Happens when spectating someone prolly
            local vmtransform = vm:GetBoneMatrix(vmbone)
            if !vmtransform then continue end -- something very bad has happened
            local vm_pos = vmtransform:GetTranslation()
            local vm_ang = vmtransform:GetAngles()
            local newtransform = Matrix()
            newtransform:SetTranslation(LerpVector(hide_rh_d, vm_pos, vm_pos - (EyeAngles():Up() * 48) - (EyeAngles():Forward() * 16)))
            newtransform:SetAngles(vm_ang)
            vm:SetBoneMatrix(vmbone, newtransform)
        end
    end
end

function SWEP:RecalculateIKGunMotionOffset()
    local seqproxy = self:GetSequenceProxy()

    if seqproxy != 0 then
        local slottbl = self:LocateSlotFromAddress(seqproxy)
        local atttbl = self:GetFinalAttTable(slottbl)
        local qca = atttbl.IKGunMotionQCA

        local anim_mdl = slottbl.GunDriverModel

        if !anim_mdl then return end

        local oldseq = anim_mdl:GetSequence()
        local oldcycle = anim_mdl:GetCycle()
        anim_mdl:ResetSequence(0)
        anim_mdl:SetCycle(0)

        if !anim_mdl:GetAttachment(qca) then return end

        local idleattpos = anim_mdl:GetAttachment(qca).Pos
        local idleattang = anim_mdl:GetAttachment(qca).Ang

        self.IKGunMotionOffset = idleattpos
        self.IKGunMotionOffsetAngle = idleattang

        anim_mdl:ResetSequence(oldseq)
        anim_mdl:SetCycle(oldcycle)
    end
end

function SWEP:GunControllerRHIK(pos, ang)
    local seqproxy = self:GetSequenceProxy()

    if seqproxy != 0 then
        local slottbl = self:LocateSlotFromAddress(seqproxy)
        local atttbl = self:GetFinalAttTable(slottbl)
        local qca = atttbl.IKGunMotionQCA

        if !qca then return pos, ang end

        local anim_mdl = slottbl.GunDriverModel

        if !anim_mdl then return pos, ang end

        local refl_mdl = slottbl.ReflectDriverModel

        if !refl_mdl then return pos, ang end

        anim_mdl:SetPos(Vector(0, 0, 0))
        anim_mdl:SetAngles(Angle(0, 0, 0))

        refl_mdl:SetPos(Vector(0, 0, 0))
        refl_mdl:SetAngles(Angle(0, 0, 0))

        if !self.IKGunMotionOffset then
            self:RecalculateIKGunMotionOffset()
        end

        local attpos, attang = anim_mdl:GetAttachment(qca).Pos, anim_mdl:GetAttachment(qca).Ang

        attang:Sub( self.IKGunMotionOffsetAngle )

        attpos = attpos - self.IKGunMotionOffset

        local r = attang.r
        attang.r = attang.p
        attang.p = -r
        attang.y = -attang.y

        local anchor = slottbl.Pos

        local bone = refl_mdl:LookupBone( slottbl.Bone )
        local bonp, bona = refl_mdl:GetBonePosition( bone )
        if bonp == refl_mdl:GetPos() then
            bonp = refl_mdl:GetBoneMatrix( bone ):GetTranslation()
            bona = refl_mdl:GetBoneMatrix( bone ):GetAngles()
        end

        if anchor and bonp then
            anchor = ( bonp + ( (bona:Forward() * anchor.x) + (bona:Right() * anchor.y) + (bona:Up() * anchor.z) ) )

            local rap_pos, rap_ang = self:RotateAroundPoint2(pos, ang, anchor, attpos, attang)
            rap_pos:Sub(pos)
            rap_ang:Sub(ang)

            pos:Add(rap_pos)
            ang:Add(rap_ang)
        end

        return pos, ang
    else
        return pos, ang
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_tpik.lua:
-- third person inverse kinematics

local arc9_tpik = GetConVar("arc9_tpik")
local arc9_tpik_others = GetConVar("arc9_tpik_others")
local arc9_tpik_framerate = GetConVar("arc9_tpik_framerate")

local forcednotpik = ARC9.NoTPIK

function SWEP:ShouldTPIK()
    if self.NoTPIK or forcednotpik then return end
    local owner = self:GetOwner()
    local lp = LocalPlayer()

    if render.GetDXLevel() < 90 then return end
    if !owner:IsPlayer() then return end
    if owner:IsPlayingTaunt() then return end
    if owner:InVehicle() and !owner:GetAllowWeaponsInVehicle() then return end
    if owner.ARC9_HoldingProp then return end
    if !self.MirrorVMWM then return end
    if self:ShouldLOD() == 2 then return end
    -- if self:GetSafe() then return end
    -- if self:GetBlindFireAmount() > 0 then return false end
    if lp == owner and !owner:ShouldDrawLocalPlayer() then return end
    if self:RunHook("Hook_BlockTPIK") then return end
    -- if !arc9_tpik:GetBool() then return false end
    if lp != owner then
        return arc9_tpik:GetBool() and arc9_tpik_others:GetBool()
    else
        return arc9_tpik:GetBool()
    end
    -- return false
end

SWEP.TPIKCache = {}
SWEP.LastTPIKTime = 0

local cachelastcycle = 0 -- probably bad

function SWEP:DoTPIK()
    local wm = self:GetWM()

    if !IsValid(wm) then return end

    if wm:GetPos():IsZero() and self.wmnormalpos then -- VERY STUPID BUT SetupModel() on wm makes wm go to 0 0 0 BUT ONLY ON CERTAIN PLAYERMODELS???????
        wm:SetPos(self.wmnormalpos) 
        wm:SetAngles(self.wmnormalang) 
    else 
        self.wmnormalpos = wm:GetPos()
        self.wmnormalang = wm:GetAngles()
    end
    
    if !self:ShouldTPIK() then
        if cachelastcycle > 0 then wm:SetCycle(0) cachelastcycle = 0 end
        return
     end

    local ply = self:GetOwner()

    local tpikdelay = 0

    local lod

    if ply != LocalPlayer() then
        local dist = EyePos():DistToSqr(ply:GetPos())

        local convartpiktime = arc9_tpik_framerate:GetFloat()
        convartpiktime = (convartpiktime == 0) and 250 or math.Clamp(convartpiktime, 5, 250)
        tpikdelay = 1 / convartpiktime

        lod = self:ShouldLOD()

        if lod == 1 then
            tpikdelay = math.max(0.05, tpikdelay)  -- max 20 fps if lodding
        elseif lod == 1.5 then
            tpikdelay = math.max(0.1, tpikdelay)
        end
    end

    local shouldfulltpik = true

    if self.LastTPIKTime + tpikdelay > CurTime() then
        shouldfulltpik = false
    end

    local nolefthand = false

    local htype = self:GetHoldType()

    if !self.TPIKforcelefthand and !self.NotAWeapon and !(self:GetReloading() and !self.TPIKforcenoreload) and (htype == "slam" or htype == "magic" or htype == "pistol"  or htype == "normal" or self.TPIKnolefthand) then
        nolefthand = true
    end

    if shouldfulltpik then
        wm:SetupBones()

        local time = self:GetSequenceCycle()
        local seq = self:GetSequenceIndex()

        if self:GetSequenceProxy() != 0 then seq = wm:LookupSequence("idle") end -- lhik ubgls fix
        
        if self.TPIKNoSprintAnim and self:GetIsSprinting() then seq = wm:LookupSequence("idle") end -- no sprint anim in tpik (less ugly)

        wm:SetSequence(seq)

        wm:SetCycle(time)
        cachelastcycle = time

        wm:InvalidateBoneCache()
    end

    self:DoRHIK(true)

    self:SetFiremodePose(true)

    ply:SetupBones()
    local bones = ARC9.TPIKBones

    if nolefthand then
        bones = ARC9.RHIKHandBones
    end

    if lod == 1.5 then -- hackkkkk
        bones = ARC9.LHIKHandBones
    end

    local ply_spine_index = ply:LookupBone("ValveBiped.Bip01_Spine4")
    if !ply_spine_index then return end
    local ply_spine_matrix = ply:GetBoneMatrix(ply_spine_index)
    local wmpos = ply_spine_matrix:GetTranslation()

    for _, bone in ipairs(bones) do
        local wm_boneindex = wm:LookupBone(bone)
        if !wm_boneindex then continue end
        local wm_bonematrix = wm:GetBoneMatrix(wm_boneindex)
        if !wm_bonematrix then continue end

        local ply_boneindex = ply:LookupBone(bone)
        if !ply_boneindex then continue end
        local ply_bonematrix = ply:GetBoneMatrix(ply_boneindex)
        if !ply_bonematrix then continue end

        local bonepos = wm_bonematrix:GetTranslation()
        local boneang = wm_bonematrix:GetAngles()

        bonepos.x = math.Clamp(bonepos.x, wmpos.x - 38, wmpos.x + 38) -- clamping if something gone wrong so no stretching (or animator is fleshy)
        bonepos.y = math.Clamp(bonepos.y, wmpos.y - 38, wmpos.y + 38)
        bonepos.z = math.Clamp(bonepos.z, wmpos.z - 38, wmpos.z + 38)

        ply_bonematrix:SetTranslation(bonepos)
        ply_bonematrix:SetAngles(boneang)

        ply:SetBoneMatrix(ply_boneindex, ply_bonematrix)
        ply:SetBonePosition(ply_boneindex, bonepos, boneang)
    end

    local ply_l_shoulder_index = ply:LookupBone("ValveBiped.Bip01_L_UpperArm")
    local ply_r_shoulder_index = ply:LookupBone("ValveBiped.Bip01_R_UpperArm")
    local ply_l_elbow_index = ply:LookupBone("ValveBiped.Bip01_L_Forearm")
    local ply_r_elbow_index = ply:LookupBone("ValveBiped.Bip01_R_Forearm")
    local ply_l_hand_index = ply:LookupBone("ValveBiped.Bip01_L_Hand")
    local ply_r_hand_index = ply:LookupBone("ValveBiped.Bip01_R_Hand")

    local ply_l_HELPERelbow_index = ply:LookupBone("ValveBiped.Bip01_L_Elbow")
    if ply_l_HELPERelbow_index and !ply:BoneHasFlag(ply_l_HELPERelbow_index, 524032) then ply_l_HELPERelbow_index = nil end -- ply:GetBoneName(ply_l_HELPERelbow_index) == "__INVALIDBONE__" can work too, same performance hit

    local ply_l_bicep_index = ply:LookupBone("ValveBiped.Bip01_L_Bicep")
    local ply_l_ulna_index = ply:LookupBone("ValveBiped.Bip01_L_Ulna") or ply:LookupBone("HumanLForearm2") -- THANK YOU MAl0 FOR NOT RENAMING YOUR BONES
    local ply_l_wrist_index = ply:LookupBone("ValveBiped.Bip01_L_Wrist") or ply:LookupBone("HumanLForearm3")

    local ply_r_HELPERelbow_index = ply:LookupBone("ValveBiped.Bip01_R_Elbow")
    if ply_r_HELPERelbow_index and !ply:BoneHasFlag(ply_r_HELPERelbow_index, 524032) then ply_r_HELPERelbow_index = nil end

    local ply_r_bicep_index = ply:LookupBone("ValveBiped.Bip01_R_Bicep")
    local ply_r_ulna_index = ply:LookupBone("ValveBiped.Bip01_R_Ulna") or ply:LookupBone("HumanRForearm2")
    local ply_r_wrist_index = ply:LookupBone("ValveBiped.Bip01_R_Wrist") or ply:LookupBone("HumanRForearm3")

    if ply_l_bicep_index and !ply:BoneHasFlag(ply_l_bicep_index, 524032) then ply_l_bicep_index = nil end
    if ply_l_ulna_index and !ply:BoneHasFlag(ply_l_ulna_index, 524032) then ply_l_ulna_index = nil end
    if ply_r_bicep_index and !ply:BoneHasFlag(ply_r_bicep_index, 524032) then ply_r_bicep_index = nil end
    if ply_r_ulna_index and !ply:BoneHasFlag(ply_r_ulna_index, 524032) then ply_r_ulna_index = nil end
    if ply_l_wrist_index and !ply:BoneHasFlag(ply_l_wrist_index, 524032) then ply_l_wrist_index = nil end
    if ply_r_wrist_index and !ply:BoneHasFlag(ply_r_wrist_index, 524032) then ply_r_wrist_index = nil end

    if !ply_l_shoulder_index then return end
    if !ply_r_shoulder_index then return end
    if !ply_l_elbow_index then return end
    if !ply_r_elbow_index then return end
    if !ply_l_hand_index then return end
    if !ply_r_hand_index then return end

    local ply_r_shoulder_matrix = ply:GetBoneMatrix(ply_r_shoulder_index)
    local ply_r_elbow_matrix = ply:GetBoneMatrix(ply_r_elbow_index)
    local ply_r_hand_matrix = ply:GetBoneMatrix(ply_r_hand_index)

    local limblength = ply:BoneLength(ply_l_elbow_index)
    if !limblength or limblength == 0 then limblength = 12 end

    local r_upperarm_length = limblength
    local r_forearm_length = limblength
    local l_upperarm_length = limblength
    local l_forearm_length = limblength

    local ply_r_upperarm_pos, ply_r_forearm_pos

    if shouldfulltpik then
        ply_r_upperarm_pos, ply_r_forearm_pos = self:Solve2PartIK(ply_r_shoulder_matrix:GetTranslation(), ply_r_hand_matrix:GetTranslation(), r_upperarm_length, r_forearm_length, -35)
        self.LastTPIKTime = CurTime()

        self.TPIKCache.r_upperarm_pos = WorldToLocal(ply_r_upperarm_pos, angle_zero, ply_r_shoulder_matrix:GetTranslation(), ply_r_shoulder_matrix:GetAngles())
        self.TPIKCache.r_forearm_pos = WorldToLocal(ply_r_forearm_pos, angle_zero, ply_r_shoulder_matrix:GetTranslation(), ply_r_shoulder_matrix:GetAngles())
    else
        ply_r_upperarm_pos = LocalToWorld(self.TPIKCache.r_upperarm_pos, angle_zero, ply_r_shoulder_matrix:GetTranslation(), ply_r_shoulder_matrix:GetAngles())
        ply_r_forearm_pos = LocalToWorld(self.TPIKCache.r_forearm_pos, angle_zero, ply_r_shoulder_matrix:GetTranslation(), ply_r_shoulder_matrix:GetAngles())
    end

    if ARC9.Dev(2) then
        debugoverlay.Line(ply_r_shoulder_matrix:GetTranslation(), ply_r_upperarm_pos, 0.1)
        debugoverlay.Line(ply_r_upperarm_pos, ply_r_forearm_pos, 0.1)
        -- debugoverlay.Line(ply_r_forearm_pos, ply_r_hand_matrix:GetTranslation(), 0.1)
    end
    -- ply_r_shoulder_matrix:SetTranslation(ply_r_upperarm_pos)
    ply_r_elbow_matrix:SetTranslation(ply_r_upperarm_pos)

    local ply_r_shoulder_angle = (ply_r_upperarm_pos - ply_r_shoulder_matrix:GetTranslation()):GetNormalized():Angle()
    ply_r_shoulder_angle.r = 180
    ply_r_shoulder_matrix:SetAngles(ply_r_shoulder_angle)

    local ply_r_elbow_angle = (ply_r_forearm_pos - ply_r_upperarm_pos):GetNormalized():Angle()
    ply_r_elbow_angle.r = -90
    ply_r_elbow_matrix:SetAngles(ply_r_elbow_angle)

    ply:SetBoneMatrix(ply_r_elbow_index, ply_r_elbow_matrix)
    ply:SetBoneMatrix(ply_r_shoulder_index, ply_r_shoulder_matrix)

    if nolefthand then return end

    local ply_l_shoulder_matrix = ply:GetBoneMatrix(ply_l_shoulder_index)
    local ply_l_elbow_matrix = ply:GetBoneMatrix(ply_l_elbow_index)
    local ply_l_hand_matrix = ply:GetBoneMatrix(ply_l_hand_index)

    local ply_l_HELPERelbow_matrix = ply_l_HELPERelbow_index and ply:GetBoneMatrix(ply_l_HELPERelbow_index)
    local ply_l_bicep_matrix = ply_l_bicep_index and ply:GetBoneMatrix(ply_l_bicep_index)
    local ply_l_ulna_matrix = ply_l_ulna_index and ply:GetBoneMatrix(ply_l_ulna_index)
    local ply_l_wrist_matrix = ply_l_wrist_index and ply:GetBoneMatrix(ply_l_wrist_index)

    local ply_r_HELPERelbow_matrix = ply_r_HELPERelbow_index and ply:GetBoneMatrix(ply_r_HELPERelbow_index)
    local ply_r_bicep_matrix = ply_r_bicep_index and ply:GetBoneMatrix(ply_r_bicep_index)
    local ply_r_ulna_matrix = ply_r_ulna_index and ply:GetBoneMatrix(ply_r_ulna_index)
    local ply_r_wrist_matrix = ply_r_wrist_index and ply:GetBoneMatrix(ply_r_wrist_index)

    -- local ply_r_upperarm_pos = ply:LocalToWorld(self.TPIKCache.r_upperarm_pos)
    -- local ply_r_forearm_pos = ply:LocalToWorld(self.TPIKCache.r_forearm_pos)

    -- if shouldfulltpik then
    --     ply_r_upperarm_pos, ply_r_forearm_pos = self:Solve2PartIK(ply_r_shoulder_matrix:GetTranslation(), ply_r_hand_matrix:GetTranslation(), r_upperarm_length, r_forearm_length, -35)
    --     self.LastTPIKTime = CurTime()

    --     self.TPIKCache.r_upperarm_pos = ply:WorldToLocal(ply_r_upperarm_pos)
    --     self.TPIKCache.r_forearm_pos = ply:WorldToLocal(ply_r_forearm_pos)
    -- end

    local ply_l_upperarm_pos, ply_l_forearm_pos

    if shouldfulltpik or !(self.TPIKCache.l_upperarm_pos and self.TPIKCache.l_forearm_pos) then
        ply_l_upperarm_pos, ply_l_forearm_pos = self:Solve2PartIK(ply_l_shoulder_matrix:GetTranslation(), ply_l_hand_matrix:GetTranslation(), l_upperarm_length, l_forearm_length, 35)

        self.LastTPIKTime = CurTime()
        self.TPIKCache.l_upperarm_pos = WorldToLocal(ply_l_upperarm_pos, angle_zero, ply_l_shoulder_matrix:GetTranslation(), ply_l_shoulder_matrix:GetAngles())
        self.TPIKCache.l_forearm_pos = WorldToLocal(ply_l_forearm_pos, angle_zero, ply_l_shoulder_matrix:GetTranslation(), ply_l_shoulder_matrix:GetAngles())
    else
        ply_l_upperarm_pos = LocalToWorld(self.TPIKCache.l_upperarm_pos, angle_zero, ply_l_shoulder_matrix:GetTranslation(), ply_l_shoulder_matrix:GetAngles())
        ply_l_forearm_pos = LocalToWorld(self.TPIKCache.l_forearm_pos, angle_zero, ply_l_shoulder_matrix:GetTranslation(), ply_l_shoulder_matrix:GetAngles())
    end

    if ARC9.Dev(2) then
        debugoverlay.Line(ply_l_shoulder_matrix:GetTranslation(), ply_l_upperarm_pos, 0.1, Color(255, 255, 255), true)
        debugoverlay.Line(ply_l_upperarm_pos, ply_l_forearm_pos, 0.1, Color(255, 255, 255), true)
        -- debugoverlay.Line(ply_l_forearm_pos, ply_l_hand_matrix:GetTranslation(), 0.1, Color(255, 255, 255), true)
    end

    -- ply_l_shoulder_matrix:SetTranslation(ply_l_upperarm_pos)
    ply_l_hand_matrix:SetTranslation(ply_l_forearm_pos)
    ply_l_elbow_matrix:SetTranslation(ply_l_upperarm_pos)

    if ply_l_HELPERelbow_matrix then ply_l_HELPERelbow_matrix:SetTranslation(ply_l_forearm_pos) end
    if ply_l_bicep_matrix then ply_l_bicep_matrix:SetTranslation(ply_l_forearm_pos) end
    if ply_l_ulna_matrix then ply_l_ulna_matrix:SetTranslation(ply_l_forearm_pos) end
    if ply_l_wrist_matrix then ply_l_wrist_matrix:SetTranslation(ply_l_forearm_pos) end

    if ply_r_HELPERelbow_matrix then ply_r_HELPERelbow_matrix:SetTranslation(ply_r_forearm_pos) end
    if ply_r_bicep_matrix then ply_r_bicep_matrix:SetTranslation(ply_r_forearm_pos) end
    if ply_r_ulna_matrix then ply_r_ulna_matrix:SetTranslation(ply_r_forearm_pos) end
    if ply_r_wrist_matrix then ply_r_wrist_matrix:SetTranslation(ply_r_forearm_pos) end

    -- print(ply:GetBoneName(ply_l_ulna_index), ply:GetBoneName(ply_l_wrist_index))

    local ply_l_shoulder_angle = (ply_l_upperarm_pos - ply_l_shoulder_matrix:GetTranslation()):GetNormalized():Angle()
    ply_l_shoulder_angle.r = -45
    ply_l_shoulder_matrix:SetAngles(ply_l_shoulder_angle)

    local ply_l_elbow_angle = (ply_l_forearm_pos - ply_l_upperarm_pos):GetNormalized():Angle()
    ply_l_elbow_angle.r = -90
    ply_l_elbow_matrix:SetAngles(ply_l_elbow_angle)

    if ply_l_HELPERelbow_index then ply:SetBoneMatrix(ply_l_HELPERelbow_index, ply_l_elbow_matrix) end
    if ply_l_bicep_index then ply:SetBoneMatrix(ply_l_bicep_index, ply_l_shoulder_matrix) end
    if ply_l_ulna_index then ply:SetBoneMatrix(ply_l_ulna_index, ply_l_hand_matrix) end
    if ply_l_wrist_index then ply:SetBoneMatrix(ply_l_wrist_index, ply_l_hand_matrix) end

    if ply_r_HELPERelbow_index then ply:SetBoneMatrix(ply_r_HELPERelbow_index, ply_r_elbow_matrix) end
    if ply_r_bicep_index then ply:SetBoneMatrix(ply_r_bicep_index, ply_r_shoulder_matrix) end
    if ply_r_ulna_index then ply:SetBoneMatrix(ply_r_ulna_index, ply_r_hand_matrix) end
    if ply_r_wrist_index then ply:SetBoneMatrix(ply_r_wrist_index, ply_r_hand_matrix) end

    ply:SetBoneMatrix(ply_l_hand_index, ply_l_hand_matrix)
    ply:SetBoneMatrix(ply_l_elbow_index, ply_l_elbow_matrix)
    ply:SetBoneMatrix(ply_l_shoulder_index, ply_l_shoulder_matrix)
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_attach.lua:
SWEP.CustomizeDelta = 0

function SWEP:Attach(addr, att, silent)
    local slottbl = self:LocateSlotFromAddress(addr)
    if !slottbl then -- to not error and reset menu
        self.BottomBarAddress = nil
        self.BottomBarMode = 0
        self:CreateHUD_Bottom()
        return false 
    end
    if (slottbl.Installed == att) then return false end
    if !self:CanAttach(addr, att) then return false end
    local atttbl = ARC9.GetAttTable(att) or {}

    self:DetachAllFromSubSlot(addr, true)

    slottbl.Installed = att
    slottbl.ToggleNum = 1

    if !silent then
        self:PlayTranslatedSound({
            name = "install",
            sound = atttbl.InstallSound or slottbl.InstallSound or "arc9/newui/ui_part_install.ogg"
        })
    end

    self:PruneAttachments()
    self:PostModify()

    return true
end

function SWEP:Detach(addr, silent)
    local slottbl = self:LocateSlotFromAddress(addr)
    if !slottbl.Installed then return false end
    if !self:CanDetach(addr) then return false end
    local atttbl = ARC9.GetAttTable(slottbl.Installed) or {}

    slottbl.Installed = nil

    if !silent then
        self:PlayTranslatedSound({
            name = "uninstall",
            sound = atttbl.UninstallSound or slottbl.UninstallSound or "arc9/newui/ui_part_uninstall.ogg"
        })
    end

    self:PruneAttachments()

    self:PostModify()

    return true
end

function SWEP:DetachAllFromSubSlot(addr, silent)
    local slottbl = self:LocateSlotFromAddress(addr)

    self:Detach(addr, silent)

    if slottbl.MergeSlotAddresses then
        for _, addr2 in ipairs(slottbl.MergeSlotAddresses) do
            self:Detach(addr2, silent)
        end
    end
end

function SWEP:GetFilledMergeSlot(addr)
    local slottbl = self:LocateSlotFromAddress(addr)

    if !slottbl then return {} end

    if slottbl.Installed then
        return slottbl
    end

    if slottbl.MergeSlots then
        for _, merge_addr in ipairs(slottbl.MergeSlotAddresses) do
            local mergeslot = self:LocateSlotFromAddress(merge_addr)

            if mergeslot.Installed then
                return mergeslot
            end
        end
    end

    return slottbl
end

SWEP.LastClipSize = 0
SWEP.LastAmmo = ""

function SWEP:PostModify(toggleonly)
    self:InvalidateCache()

    if !toggleonly then
        self:CancelReload()
        -- self:PruneAttachments()
        self:SetNthReload(0)
    end

    local client = self:GetOwner()
    local validplayerowner = IsValid(client) and client:IsPlayer()

    local base = baseclass.Get(self:GetClass())

    if ARC9:UseTrueNames() then
        self.PrintName = base.TrueName
        self.PrintName = self:GetValue("TrueName")
    else
        self.PrintName = base.PrintName
        self.PrintName = self:GetValue("PrintName")
    end

    if !self.PrintName then
        self.PrintName = base.PrintName
        self.PrintName = self:GetValue("PrintName")
    end
    
    self.Description = base.Description

    self.PrintName = self:RunHook("HookP_NameChange", self.PrintName)
    self.Description = self:RunHook("HookP_DescriptionChange", self.Description)

    if CLIENT then
        -- self:PruneAttachments()
        self:SendWeapon()
        self:KillModel()
        self:SetupModel(true)
        self:SetupModel(false)
        if !toggleonly then
            self:SavePreset()
        end
        self:BuildMultiSight()
        self.InvalidateSelectIcon = true
    else
        if validplayerowner then
            if self:GetValue("ToggleOnF") and client:FlashlightIsOn() then
                client:Flashlight(false)
            end

            if self.LastAmmo != self:GetValue("Ammo") or self.LastClipSize != self:GetValue("ClipSize") then
                if self.AlreadyGaveAmmo then
                    self:Unload()
                    self:SetRequestReload(true)
                else
                    self:SetClip1(self:GetProcessedValue("ClipSize"))
                    self.AlreadyGaveAmmo = true
                end
            end

            self.LastAmmo = self:GetValue("Ammo")
            self.LastClipSize = self:GetValue("ClipSize")

            if self:GetValue("UBGL") then
                if !self.AlreadyGaveUBGLAmmo then
                    self:SetClip2(self:GetMaxClip2())
                    self.AlreadyGaveUBGLAmmo = true
                end

                if (self.LastUBGLAmmo) then
                    if (self.LastUBGLAmmo != self:GetValue("UBGLAmmo") or self.LastUBGLClipSize != self:GetValue("UBGLClipSize")) then
                        client:GiveAmmo(self:Clip2(), self.LastUBGLAmmo)
                        self:SetClip2(0)
                        self:SetRequestReload(true)
                    end
                end

                self.LastUBGLAmmo = self:GetValue("UBGLAmmo")
                self.LastUBGLClipSize = self:GetValue("UBGLClipSize")

                local capacity = self:GetCapacity(true)
                if capacity > 0 and self:Clip2() > capacity then
                    client:GiveAmmo(self:Clip2() - capacity, self.LastUBGLAmmo)
                    self:SetClip2(capacity)
                end
            end

            local capacity = self:GetCapacity(false)
            if capacity > 0 and self:Clip1() > capacity then
                client:GiveAmmo(self:Clip1() - capacity, self.LastAmmo)
                self:SetClip1(capacity)
            end

            if self:GetProcessedValue("BottomlessClip", true) then
                self:RestoreClip()
            end
        end
    end

    if self:GetUBGL() and !self:GetProcessedValue("UBGL") then
        self:ToggleUBGL(false)
    end

    if game.SinglePlayer() and validplayerowner then
        self:CallOnClient("RecalculateIKGunMotionOffset")
    end

    self:SetupAnimProxy()

    self:SetBaseSettings()

    if self:GetAnimLockTime() <= CurTime() then
        self:Idle()
    end
end

function SWEP:ThinkCustomize()
    local owner = self:GetOwner()

    if owner:KeyPressed(ARC9.IN_CUSTOMIZE) and !owner:KeyDown(IN_USE) and !self:GetGrenadePrimed() then
        self:ToggleCustomize(!self:GetCustomize())
    end

    if game.SinglePlayer() or (CLIENT and IsFirstTimePredicted()) then
        if self:GetCustomize() then
            if self.CustomizeDelta < 1 then
                self.CustomizeDelta = math.Approach(self.CustomizeDelta, 1, FrameTime() * 6.666666666666667)
            end
        else
            if self.CustomizeDelta > 0 then
                self.CustomizeDelta = math.Approach(self.CustomizeDelta, 0, FrameTime() * 6.666666666666667)
            end
        end
    end
end

function SWEP:ToggleCustomize(on)
    if on == self:GetCustomize() then return end
    if self.NotAWeapon then return end

    self:SetCustomize(on)

    self:SetShouldHoldType()

    self:SetInSights(false)

    if !on then
        if self:HasAnimation("postcustomize") then
            self:CancelReload()
            self:PlayAnimation("postcustomize", 1, true)
        end
    end
end

function SWEP:GetAttBlocked(atttbl)
    local eles = self:GetElements()

    if atttbl.ExcludeElements then
        for _, group in ipairs(atttbl.ExcludeElements) do
            if !istable(group) then
                group = {group}
            end

            local ok = false
            for _, ele in ipairs(group) do
                if !eles[ele] then ok = true break end
            end

            if !ok then return true end
        end
    end

    if atttbl.RequireElements then
        for _, group in ipairs(atttbl.RequireElements) do
            if !istable(group) then
                group = {group}
            end

            local ok = false
            for _, ele in ipairs(group) do
                if !eles[ele] then ok = true break end
            end

            if !ok then return false end
        end

        return true
    end

    return false
end

local arc9_atts_anarchy = GetConVar("arc9_atts_anarchy")

function SWEP:SlotInvalid(slottbl)
    if arc9_atts_anarchy:GetBool() then return false end

    local eles = self:GetElements()

    if slottbl.ExcludeElements then
        for _, group in ipairs(slottbl.ExcludeElements) do
            if !istable(group) then
                group = {group}
            end

            local ok = false
            for _, ele in ipairs(group) do
                if !eles[ele] then ok = true break end
            end

            if !ok then return true end
        end
    end

    local totalcount = self:CountAttachments()

    if totalcount > ARC9.GetMaxAtts() then return true end

    if slottbl.RequireElements then
        for _, group in ipairs(slottbl.RequireElements) do
            if !istable(group) then
                group = {group}
            end

            local ok = true
            for _, ele in ipairs(group) do
                if !eles[ele] then ok = false break end
            end

            if !ok then return true end
        end
    end

    local att = slottbl.Installed

    if !att then return false end

    if self:RunHook("Hook_BlockAttachment", {att = att, slottbl = slottbl}) == false then return true end

    if (slottbl.RejectAttachments or {})[att] then return true end

    local cat = slottbl.Category

    if !istable(cat) then
        cat = {cat}
    end

    local atttbl = self:GetFinalAttTable(slottbl)

    if atttbl.Max then
        local count = self:CountAttachments(att)

        if slottbl.Installed then
            local installed_atttbl = self:GetFinalAttTable(slottbl)

            if slottbl.Installed == installed_atttbl.InvAtt then
                count = count - 1
            end
        end

        if count > atttbl.Max then return true end
    end

    if self:GetAttBlocked(atttbl) then return true end
    if atttbl.AdminOnly and IsValid(self:GetOwner()) and (self:GetOwner():IsNPC() or !self:GetOwner():IsAdmin()) then return true end

    local attcat = atttbl.Category

    if attcat == "*" then return false end

    if !istable(attcat) then
        attcat = {attcat}
    end

    local cat_true = false

    for _, c in ipairs(attcat) do
        if (slottbl.RejectAttachments or {})[c] then return false end
        if table.HasValue(cat, c) then
            cat_true = true
        end
    end

    return !cat_true
end

function SWEP:GetSlotBlocked(slottbl)
    local eles = self:GetElements()

    if slottbl.ExcludeElements then
        for _, group in ipairs(slottbl.ExcludeElements) do
            if !istable(group) then
                group = {group}
            end

            local ok = false
            for _, ele in ipairs(group) do
                if !eles[ele] then ok = true break end
            end

            if !ok then return true end
        end
    end

    local totalcount = self:CountAttachments()

    if totalcount >= ARC9.GetMaxAtts() then return true end

    if slottbl.RequireElements then
        for _, group in ipairs(slottbl.RequireElements) do
            if !istable(group) then
                group = {group}
            end

            local ok = true
            for _, ele in ipairs(group) do
                if !eles[ele] then ok = false break end
            end

            if !ok then return true end
        end
    end

    return false
end

-- Find any available attachment for the slot the player owns, in no specific order.
function SWEP:FirstAttForSlot(slottbl)
    local atts = ARC9.GetAttsForCats(slottbl.Category)
    for _, v in ipairs(atts) do
        if ARC9:PlayerGetAtts(self:GetOwner(), v) > 0 then return v end
    end
    return false
end

-- When attaching or detaching, changes in elements may cause a slot to be enabled when it previously wasn't.
-- We want to find all slots of this type that are Integral so we can fill in an attachment for it.
-- "att" is the attachment to add, set to false for detach
-- Note that the returned slots may not all have an address; subslots that are about to be added don't have one yet
function SWEP:GetDependentIntegralSlots(addr, att, slottbl)
    slottbl = slottbl or self:LocateSlotFromAddress(addr)
    local atttbl = att and ARC9.GetAttTable(att) or ARC9.GetAttTable(slottbl.Installed)

    local eles = {}

    if att then
        -- About to attach; InstalledElements will be involved
        for _, e in pairs(slottbl.InstalledElements or {}) do
            eles[e] = true
        end
        eles[att] = true
    else
        -- About to detach, UnInstalledElements will be involved
        for _, e in pairs(slottbl.UnInstalledElements or {}) do
            eles[e] = true
        end
    end

    -- The attachment's elements will be involved regardless of attaching or detaching
    if atttbl then
        for _, e in pairs(atttbl.ActivateElements or {}) do
            eles[e] = true
        end
    end

    -- If another slot is providing the element too, our changes will have no effect
    local othereles = self:GetElements({[addr] = true})
    for _, e in pairs(othereles) do
        eles[e] = nil
    end

    local slots = {}

    for _, tbl in ipairs(self:GetSubSlotList()) do
        if !tbl.Integral then continue end

        local affected = false
        if att then
            -- If the elements we are trying to add will enable this slot, it is affected
            local required = tbl.RequireElements
            if !istable(required) then required = {required} end
            for _, e in ipairs(required) do
                if eles[e] then
                    affected = true
                    break
                end
            end
        else
            -- If the element we are about to remove is keeping the slot disabled, it is affected
            local excluded = tbl.ExcludeElements
            if !istable(excluded) then excluded = {excluded} end
            for _, e in ipairs(excluded) do
                if eles[e] then
                    affected = true
                    break
                end
            end
        end

        -- TODO: Consider domino effect caused by the slot about to be added?
        if affected then
            slots[#slots + 1] = tbl
        end
    end

    -- Any subslots added by the attachment may need Integral attachments
    if att then
        for _, slot in ipairs(atttbl.Attachments or {}) do
            if slot.Integral then
                slots[#slots + 1] = slot
            end
        end
    end

    return slots
end

function SWEP:GetSlotMissingDependents(addr, att, slottbl)
    self.DependentCache = self.DependentCache or {}
    if !self.DependentCache[addr] or (self.DependentCache[addr][att] or {0, false})[1] != CurTime() then
        self.DependentCache[addr] = self.DependentCache[addr] or {}
        self.DependentCache[addr][att] = {CurTime(), false}
        for _, v in ipairs(self:GetDependentIntegralSlots(addr, att, slottbl)) do
            if !self:FirstAttForSlot(v) then
                self.DependentCache[addr][att][2] = true
                break
            end
        end
    end
    return self.DependentCache[addr][att][2]
end

local arc9_atts_nocustomize = GetConVar("arc9_atts_nocustomize")

function SWEP:CanAttach(addr, att, slottbl, ignorecount)
    if ARC9.Blacklist[att] then return false end

    if arc9_atts_anarchy:GetBool() then return true end
    if arc9_atts_nocustomize:GetBool() then return false end

    local atttbl = ARC9.GetAttTable(att)
    local invatt = atttbl.InvAtt or att

    slottbl = slottbl or self:LocateSlotFromAddress(addr)

    local curtbl = ARC9.GetAttTable(slottbl.Installed) or {}

    if !ignorecount and ARC9:PlayerGetAtts(self:GetOwner(), att) == 0 and (curtbl.InvAtt or slottbl.Installed) != invatt then return false end

    if self:RunHook("Hook_BlockAttachment", {att = att, slottbl = slottbl}) == false then return false end

    if self:GetSlotBlocked(slottbl) then return false end

    if (slottbl.RejectAttachments or {})[att] then return false end

    local cat = slottbl.Category

    if !istable(cat) then
        cat = {cat}
    end

    if atttbl.Max then
        local count = self:CountAttachments(att)

        if slottbl.Installed then
            local installed_atttbl = self:GetFinalAttTable(slottbl)

            if slottbl.Installed == installed_atttbl.InvAtt then
                count = count - 1
            end
        end

        if count >= atttbl.Max then return false end
    end

    if self:GetAttBlocked(atttbl) then return false end
    if atttbl.AdminOnly and !self:GetOwner():IsAdmin() then return false end

    -- If attaching will enable any Integral slots, we must own something to put in there
    if self:GetSlotMissingDependents(addr, att, slottbl) then return false end

    local attcat = atttbl.Category

    if attcat == "*" then return true end

    if !istable(attcat) then
        attcat = {attcat}
    end

    local cat_true = false

    for _, c in ipairs(attcat) do
        if (slottbl.RejectAttachments or {})[c] then return false end
        if table.HasValue(cat, c) then
            cat_true = true
        end
    end

    if !cat_true then return false end

    return true
end

function SWEP:CanDetach(addr)
    if arc9_atts_nocustomize:GetBool() then return false end

    local slottbl = self:LocateSlotFromAddress(addr)

    if slottbl and slottbl.Integral then return false end

    return true
end

function SWEP:CountAttachments(countatt)
    local qty = 0

    for _, att in ipairs(self:GetAttachmentList()) do
        if !countatt then
            qty = qty + 1
        else
            if countatt == att then
                qty = qty + 1
            end
        end
    end

    return qty
end

function SWEP:ToggleAllStatsOnF()
    if self:GetReloading() then return true end

    local toggled = false

    for _, slottbl in ipairs(self:GetSubSlotList()) do
        if !slottbl.Installed then continue end

        local atttbl = self:GetFinalAttTable(slottbl)

        if !atttbl.ToggleStats then continue end
        if !atttbl.ToggleOnF then continue end

        toggled = true

        self:ToggleStat(slottbl.Address)
    end

    if toggled then
        self:RunHook("Hook_ToggleAtts")
        self:PostModify()
        return true
    end
end

function SWEP:CanToggleAllStatsOnF()
    local toggled = false

    for _, slottbl in ipairs(self:GetSubSlotList()) do
        if !slottbl.Installed then continue end

        local atttbl = self:GetFinalAttTable(slottbl)

        if !atttbl.ToggleStats then continue end
        if !atttbl.ToggleOnF then continue end

        toggled = true
    end

    return toggled
end

function SWEP:ToggleStat(addr, val)
    val = val or 1
    local slottbl = self:LocateSlotFromAddress(addr)

    if !slottbl.Installed then return end

    local atttbl = self:GetFinalAttTableFromAddress(addr)

    if !atttbl.ToggleStats then return end

    slottbl.ToggleNum = (slottbl.ToggleNum or 1) + val

    if slottbl.ToggleNum > #atttbl.ToggleStats then
        slottbl.ToggleNum = 1
    elseif slottbl.ToggleNum < 1 then
        slottbl.ToggleNum = #atttbl.ToggleStats
    end
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_blindfire.lua:

/*

ValveBiped.Bip01_Spine
ValveBiped.Bip01_Spine1
ValveBiped.Bip01_Spine2
ValveBiped.Bip01_Spine4
ValveBiped.Bip01_Neck1
ValveBiped.Bip01_Head1
ValveBiped.forward
ValveBiped.Bip01_R_Clavicle
ValveBiped.Bip01_R_UpperArm
ValveBiped.Bip01_R_Forearm
ValveBiped.Bip01_R_Hand
ValveBiped.Anim_Attachment_RH
ValveBiped.Bip01_L_Clavicle
ValveBiped.Bip01_L_UpperArm
ValveBiped.Bip01_L_Forearm
ValveBiped.Bip01_L_Hand
ValveBiped.Anim_Attachment_LH
ValveBiped.Bip01_R_Thigh
ValveBiped.Bip01_R_Calf
ValveBiped.Bip01_R_Foot
ValveBiped.Bip01_R_Toe0
ValveBiped.Bip01_L_Thigh
ValveBiped.Bip01_L_Calf
ValveBiped.Bip01_L_Foot
ValveBiped.Bip01_L_Toe0
ValveBiped.Bip01_L_Finger4
ValveBiped.Bip01_L_Finger41
ValveBiped.Bip01_L_Finger42
ValveBiped.Bip01_L_Finger3
ValveBiped.Bip01_L_Finger31
ValveBiped.Bip01_L_Finger32
ValveBiped.Bip01_L_Finger2
ValveBiped.Bip01_L_Finger21
ValveBiped.Bip01_L_Finger22
ValveBiped.Bip01_L_Finger1
ValveBiped.Bip01_L_Finger11
ValveBiped.Bip01_L_Finger12
ValveBiped.Bip01_L_Finger0
ValveBiped.Bip01_L_Finger01
ValveBiped.Bip01_L_Finger02
ValveBiped.Bip01_R_Finger4
ValveBiped.Bip01_R_Finger41
ValveBiped.Bip01_R_Finger42
ValveBiped.Bip01_R_Finger3
ValveBiped.Bip01_R_Finger31
ValveBiped.Bip01_R_Finger32
ValveBiped.Bip01_R_Finger2
ValveBiped.Bip01_R_Finger21
ValveBiped.Bip01_R_Finger22
ValveBiped.Bip01_R_Finger1
ValveBiped.Bip01_R_Finger11
ValveBiped.Bip01_R_Finger12
ValveBiped.Bip01_R_Finger0
ValveBiped.Bip01_R_Finger01
ValveBiped.Bip01_R_Finger02

*/

function SWEP:ToggleBoneMods(on, dir)
    -- if on then
    --     if dir < 0 then
    --         for i, k in pairs(self:GetValue("BlindFireLeftBoneMods")) do
    --             local boneindex = self:GetOwner():LookupBone(i)

    --             if !boneindex then continue end

    --             self:GetOwner():ManipulateBonePosition(boneindex, k.pos or vector_origin)
    --             self:GetOwner():ManipulateBoneAngles(boneindex, k.ang or angle_zero)
    --         end
    --     elseif dir > 0 then
    --         for i, k in pairs(self:GetValue("BlindFireRightBoneMods")) do
    --             local boneindex = self:GetOwner():LookupBone(i)

    --             if !boneindex then continue end

    --             self:GetOwner():ManipulateBonePosition(boneindex, k.pos or vector_origin)
    --             self:GetOwner():ManipulateBoneAngles(boneindex, k.ang or angle_zero)
    --         end
    --     else
    --         for i, k in pairs(self:GetValue("BlindFireBoneMods")) do
    --             local boneindex = self:GetOwner():LookupBone(i)

    --             if !boneindex then continue end

    --             self:GetOwner():ManipulateBonePosition(boneindex, k.pos or vector_origin)
    --             self:GetOwner():ManipulateBoneAngles(boneindex, k.ang or angle_zero)
    --         end
    --     end
    -- else
    --     for i, k in pairs(self:GetValue("BlindFireBoneMods")) do
    --         local boneindex = self:GetOwner():LookupBone(i)

    --         if !boneindex then continue end

    --         self:GetOwner():ManipulateBonePosition(boneindex, vector_origin)
    --         self:GetOwner():ManipulateBoneAngles(boneindex, angle_zero)
    --     end

    --     for i, k in pairs(self:GetValue("BlindFireRightBoneMods")) do
    --         local boneindex = self:GetOwner():LookupBone(i)

    --         if !boneindex then continue end

    --         self:GetOwner():ManipulateBonePosition(boneindex, vector_origin)
    --         self:GetOwner():ManipulateBoneAngles(boneindex, angle_zero)
    --     end

    --     for i, k in pairs(self:GetValue("BlindFireLeftBoneMods")) do
    --         local boneindex = self:GetOwner():LookupBone(i)

    --         if !boneindex then continue end

    --         self:GetOwner():ManipulateBonePosition(boneindex, vector_origin)
    --         self:GetOwner():ManipulateBoneAngles(boneindex, angle_zero)
    --     end
    -- end
end

function SWEP:ToggleBlindFire(bf, dir)
    -- dir = dir or 0
    -- if !self:GetValue("CanBlindFire") then return end

    -- if bf == self:GetBlindFire() and dir == self:GetBlindFireDirection() then return end
    -- if bf and self:GetIsSprinting() then return end
    -- if bf and self:GetAnimLockTime() > CurTime() then return end
    -- if bf and self:GetSafe() then return end

    -- if dir < 0 and !self:GetValue("BlindFireLeft") then dir = 0 bf = false end
    -- if dir > 0 and !self:GetValue("BlindFireRight") then dir = 0 bf = false end

    -- if bf and self:GetSightAmount() > 0 then return end

    -- self:SetBlindFire(bf)
    -- self:ToggleCustomize(false)

    -- self:ToggleBoneMods(false, false)
    -- self:ToggleBoneMods(bf, dir)

    -- if !bf then
    --     self:SetBlindFireDirection(0)
    -- else
    --     self:SetBlindFireDirection(dir)
    -- end

    -- if self:StillWaiting() then self:IdleAtEndOfAnimation() return end

    -- self:Idle()
end

function SWEP:ThinkBlindFire()


    -- local amt = self:GetBlindFireAmount()
    -- local oldamt = amt

    -- if self:GetBlindFire() then
    --     amt = math.Approach(amt, 1, FrameTime() / 0.25)
    -- else
    --     amt = math.Approach(amt, 0, FrameTime() / 0.25)
    -- end

    -- if oldamt != amt then
    --     self:SetBlindFireAmount(amt)
    -- end

    -- local amt2 = self:GetBlindFireCornerAmount()
    -- local oldamt2 = amt2

    -- if self:GetBlindFireDirection() > 0 then
    --     amt2 = math.Approach(amt2, 1, FrameTime() / 0.25)
    -- elseif self:GetBlindFireDirection() < 0 then
    --     amt2 = math.Approach(amt2, -1, FrameTime() / 0.25)
    -- else
    --     amt2 = math.Approach(amt2, 0, FrameTime() / 0.25)
    -- end

    -- if oldamt2 != amt2 then
    --     self:SetBlindFireCornerAmount(amt2)
    -- end

    -- if self:GetOwner():KeyDown(IN_ALT1) then
    --     if self:GetOwner():KeyDown(IN_BACK) then
    --         self:ToggleBlindFire(false)
    --     elseif self:GetOwner():KeyDown(IN_FORWARD) then
    --         self:ToggleBlindFire(true, 0)
    --     elseif self:GetOwner():KeyDown(IN_MOVELEFT) then
    --         self:ToggleBlindFire(true, -1)
    --     elseif self:GetOwner():KeyDown(IN_MOVERIGHT) then
    --         self:ToggleBlindFire(true, 1)
    --     end
    -- end

    -- if self:GetBlindFire() then
    --     if self:GetOwner():KeyDown(IN_USE) and self:GetOwner():KeyPressed(IN_MOVELEFT) then
    --         self:SetBlindFireCorner(!self:GetBlindFireCorner())
    --     end
    -- else
    --     if self:GetBlindFireCorner() then
    --         self:SetBlindFireCorner(false)
    --     end
    -- end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_firemodes.lua:
SWEP.FinishFiremodeAnimTime = 0

function SWEP:SwitchFiremode()
    if self:StillWaiting() then return end

    if self:GetProcessedValue("NoFiremodeWhenEmpty", true) and self:Clip1() <= 0 then return end

    if self:GetSafe() then
        self:ToggleSafety(false)
        return
    end

    if self:GetUBGL() then return end

    local fmodes = self:GetValue("Firemodes")

    if #fmodes < 2 then return end

    local fm = self:GetFiremode()

    local anim = "firemode_" .. tostring(fm)

    fm = fm + 1

    if fm > #fmodes then
        fm = 1
    end

    if IsFirstTimePredicted() then
        local soundtab1 = {
            name = "firemode",
            sound = self:RandomChoice(self:GetProcessedValue("FiremodeSound", true)),
            channel = ARC9.CHAN_FIDDLE
        }
        self:PlayTranslatedSound(soundtab1)
    end

    self:SetFiremode(fm)

    local lock = self:GetValue("FiremodeAnimLock")

    if self:HasAnimation(anim) then
        local t = self:PlayAnimation(anim, 1, lock)

        self:SetFinishFiremodeAnimTime(CurTime() + t)
        -- self:SetFiremodePose()
    elseif self:HasAnimation("firemode") then
        local t = self:PlayAnimation("firemode", 1, lock)

        self:SetFinishFiremodeAnimTime(CurTime() + t)
    end

    self:InvalidateCache()

    if game.SinglePlayer() then
        self:CallOnClient("InvalidateCache")
    end
	
end

function SWEP:SetFiremodePose(wm)
    if SERVER then return end
    local vm = self:GetVM()

    if wm then vm = self:GetWM() end

    if !vm then return end

    if self.CustomPoseParamsHandler then self:CustomPoseParamsHandler(vm, wm) end

    local pp = self:GetFiremode()

    if pp > #self:GetValue("Firemodes") then
        pp = 1
        self:SetFiremode(pp)
    end

    local fmt = self:GetCurrentFiremodeTable()

    if fmt.PoseParam then
        pp = fmt.PoseParam
    end

    pp = self:RunHook("HookP_ModifyFiremodePoseParam", pp) or pp

    if self.HasFiremodePoseparam then
        if self:GetFinishFiremodeAnimTime() < CurTime() then
            vm:SetPoseParameter("firemode", pp)
        else
            vm:SetPoseParameter("firemode", 1)
        end
    end
end

function SWEP:GetCurrentFiremode()
    if self:GetUBGL() then
        return self:GetProcessedValue("UBGLFiremode", true)
    end

    mode = self:GetCurrentFiremodeTable().Mode

    mode = self:RunHook("Hook_TranslateMode") or mode

    return mode
end

function SWEP:GetCurrentFiremodeTable()
    local fm = self:GetFiremode()

    if fm > #self:GetValue("Firemodes") then
        fm = 1
        self:SetFiremode(fm)
    end

    return self:GetValue("Firemodes")[fm]
end

function SWEP:ToggleSafety(onoff)
    if self.CantSafety then return end

    if onoff == nil then
        onoff = !self:GetSafe()
    end

    local last = self:GetSafe()

    self:SetSafe(onoff)

    if onoff != last then
        if IsFirstTimePredicted() then
            local soundtab1 = {
                name = "safety",
                sound = self:RandomChoice(self:GetProcessedValue("FiremodeSound", true)),
                channel = ARC9.CHAN_FIDDLE
            }
            self:PlayTranslatedSound(soundtab1)
        end

        if onoff == false then
            self:ExitSights()
        end
    end

end

function SWEP:ThinkFiremodes()

	-- if CurTime() < self.FMHintTime +1 then return end

    if self:GetOwner():KeyPressed(IN_ZOOM) and self:GetOwner():KeyDown(IN_USE) then
        self:ToggleSafety()
		self.FMHintTime = CurTime()
        return
    end

    if self:GetOwner():KeyPressed(IN_ZOOM) then
        self:SwitchFiremode()
		self.FMHintTime = CurTime()
    end
end

function SWEP:GetFiremodeName()
    if self:GetUBGL() then
        return self:GetProcessedValue("UBGLFiremodeName", true)
    end

    local arc9_mode = self:GetCurrentFiremodeTable()

    local firemode_text = "UNKNOWN"

    if arc9_mode.PrintName then
        firemode_text = arc9_mode.PrintName
    else
        if arc9_mode.Mode == 1 then
            firemode_text = ARC9:GetPhrase("hud.firemode.single")
        elseif arc9_mode.Mode == 0 then
            firemode_text = ARC9:GetPhrase("hud.firemode.safe")
        elseif arc9_mode.Mode < 0 then
            firemode_text = ARC9:GetPhrase("hud.firemode.auto")
        elseif arc9_mode.Mode > 1 then
            firemode_text = tostring(arc9_mode.Mode) .. "-" .. ARC9:GetPhrase("hud.firemode.burst")
        end
    end

    if self:GetSafe() then
        firemode_text = ARC9:GetPhrase("hud.firemode.safe")
    end

    return firemode_text
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_nearwall.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_nearwall.lua:
SWEP.NearWallTick = 0
SWEP.NearWallCached = false

do
    local traceResults = {}

    local traceData = {
        start = true,
        endpos = true,
        filter = true,
        mask = MASK_SHOT_HULL,
        output = traceResults
    }

    local VECTOR = FindMetaTable("Vector")
    local vectorAdd = VECTOR.Add
    local vectorMul = VECTOR.Mul

    local angleForward = FindMetaTable("Angle").Forward
    local entityGetOwner = FindMetaTable("Entity").GetOwner

    local engineTickCount = engine.TickCount

    function SWEP:GetIsNearWall()
        local now = engineTickCount()

        if self.NearWallTick == now then return self.NearWallCached end

        if (self.NearWallLastCheck or 0) > now then return self.NearWallCached end
        self.NearWallLastCheck = now + 8 -- 8 ticks before next check

        local length = self:GetProcessedValue("BarrelLength", true)

        if length == 0 then return false end

        local startPos = self:GetShootPos()

        local endPos = angleForward(self:GetShootDir())
        vectorMul(endPos, length)
        vectorAdd(endPos, startPos)

        traceData.start = startPos
        traceData.endpos = endPos
        traceData.filter = entityGetOwner(self)

        util.TraceLine(traceData)
        local hit = traceResults.Hit

        self.NearWallCached = hit
        self.NearWallTick = now

        return hit
    end
end

local swepGetIsNearWall = SWEP.GetIsNearWall
local math_Approach = math.Approach
local FrameTime = FrameTime

function SWEP:ThinkNearWall()
    self:SetNearWallAmount(math_Approach(
        self.dt.NearWallAmount,
        swepGetIsNearWall(self) and 1 or 0,
        FrameTime() / self:GetProcessedValue("SprintToFireTime", true)))
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_recoil.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_customize2.lua:
local translate = ArcCW.GetTranslation
local try_translate = ArcCW.TryTranslation
local defaultatticon = Material("arccw/hud/atts/default.png", "mips smooth")
local blockedatticon = Material("arccw/hud/atts/blocked.png", "mips smooth")

local bullseye = Material("arccw/hud/bullseye.png", "mips smooth")
local mat_hit = Material("arccw/hud/hit.png", "mips smooth")
local mat_hit_dot = Material("arccw/hud/hit_dot.png", "mips smooth")

local pickx_empty = Material("arccw/hud/pickx_empty.png", "mips smooth")
local pickx_full = Material("arccw/hud/pickx_filled.png", "mips smooth")

local bird = Material("arccw/hud/arccw_bird.png", "mips smooth")

local iconlock = Material("arccw/hud/locked_32.png", "mips smooth")
local iconunlock = Material("arccw/hud/unlocked_32.png", "mips smooth")

local col_fg = Color(255, 255, 255, 255)
local col_fg_tr = Color(255, 255, 255, 100)
local col_shadow = Color(0, 0, 0, 255)
local col_button = Color(0, 0, 0, 175)
local col_button_hv = Color(75, 75, 75, 175)
local col_mayomustard = Color(255, 255, 127)
local mayoicons = false

local col_block = Color(50, 0, 0, 175)
local col_block_txt = Color(175, 10, 10, 255)

local col_bad = Color(255, 50, 50, 255)
local col_good = Color(100, 255, 100, 255)
local col_info = Color(150, 150, 255, 255)

local col_unowned = col_block
local col_unowned_txt = col_block_txt

local ss, rss, thicc

local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

local function LerpColor(d, col1, col2)
    local r = Lerp(d, col1.r, col2.r)
    local g = Lerp(d, col1.g, col2.g)
    local b = Lerp(d, col1.b, col2.b)
    local a = Lerp(d, col1.a, col2.a)
    return Color(r, g, b, a)
end

local function DrawTextRot(span, txt, x, y, tx, ty, maxw, only)
    local tw, th = surface.GetTextSize(txt)

    span.TextRot = span.TextRot or {}

    if tw > maxw then
        local realx, realy = span:LocalToScreen(x, y)
        render.SetScissorRect(realx, realy, realx + maxw, realy + (th * 2), true)

        span.TextRot[txt] = span.TextRot[txt] or 0

        if !only then
            span.StartTextRot = span.StartTextRot or CurTime()
            span.TextRotState = span.TextRotState or 0 -- 0: start, 1: moving, 2: end
            if span.TextRotState == 0 then
                span.TextRot[txt] = 0
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 1
                end
            elseif span.TextRotState == 1 then
                span.TextRot[txt] = span.TextRot[txt] + (FrameTime() * ScreenScaleMulti(16))
                if span.TextRot[txt] >= (tw - maxw) + ScreenScaleMulti(8) then
                    span.StartTextRot = CurTime()
                    span.TextRotState = 2
                end
            elseif span.TextRotState == 2 then
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 3
                    span.StartTextRot = CurTime()
                end
            elseif span.TextRotState == 3 then
                span.TextRot[txt] = span.TextRot[txt] - (FrameTime() * ScreenScaleMulti(16))
                if span.TextRot[txt] <= 0 then
                    span.StartTextRot = CurTime()
                    span.TextRotState = 0
                end
            end
        end
        surface.SetTextPos(tx - span.TextRot[txt], ty)
        surface.DrawText(txt)
        render.SetScissorRect(0, 0, 0, 0, false)
    else
        surface.DrawText(txt)
    end
end

local function multlinetext(text, maxw, font)
    local content = {}
    local tline = ""
    local x = 0
    surface.SetFont(font)

    local newlined = string.Split(text, "\n")

    for _, line in pairs(newlined) do
        local words = string.Split(line, " ")

        for _, word in pairs(words) do
            local tx = surface.GetTextSize(word)

            if x + tx >= maxw then
                table.insert(content, tline)
                tline = ""
                x = surface.GetTextSize(word)
            end

            tline = tline .. word .. " "

            x = x + surface.GetTextSize(word .. " ")
        end

        table.insert(content, tline)
        tline = ""
        x = 0
    end

    return content
end

-- given fov and distance solve apparent size
local function solvetriangle(angle, dist)
    local a = angle / 2
    local b = dist
    return b * math.tan(a) * 2
end

local hits_1 = {}
local hits_3 = {}

local function rollhit(radius)
    local anglerand = math.Rand(0, 360)
    local dist = math.Rand(0, radius)

    local hit_x = math.sin(anglerand) * dist
    local hit_y = math.cos(anglerand) * dist

    return {x = hit_x, y = hit_y}
end

local function rollallhits(self, range_3, range_1)

    hits_1 = {}
    hits_3 = {}

    local ang = self:GetBuff("AccuracyMOA") / 60

    local radius_1 = solvetriangle(ang, range_1 * ArcCW.HUToM)
    local radius_3 = solvetriangle(ang, range_3 * ArcCW.HUToM)

    local hitcount = math.Clamp(math.max(math.Round(self:GetCapacity() / 4), math.Round(self:GetBuff("Num") * 2)), 10, 20)

    for i = 1, hitcount do
        table.insert(hits_1, rollhit(radius_1))
    end

    for i = 1, hitcount do
        table.insert(hits_3, rollhit(radius_3))
    end
end

local function RangeText(range)
    local metres = tostring(math.Round(range)) .. "m"
    local hu = tostring(math.Round(range / ArcCW.HUToM / 100) * 100) .. "HU"

    return metres, hu
end

local shot_limit = 12
local max_shots = 8

local function shotstokill(mult, dmgmin, dmgmax, mran, sran)

    -- for i, return range where i * damage == 100
    -- return -1 if can't kill with i shots, math.huge if can kill at any range
    local result = {}

    for i = 1, shot_limit do
        local req_damage = math.ceil(100 / mult / i) -- target damage to kill in i shots
        if req_damage > dmgmin and req_damage > dmgmax then
            -- cannot reach target damage ever
            result[i] = -1
        elseif req_damage <= dmgmin and req_damage <= dmgmax then
            -- will always exceed target damage
            result[i] = math.huge
        elseif dmgmin < dmgmax then
            -- damage decays over range
            local frac = 1 - math.Clamp((req_damage - dmgmin) / (dmgmax - dmgmin), 0, 1)
            result[i] = mran + frac * (sran - mran)
        else
            -- damage increases over range
            local frac = math.Clamp((req_damage - dmgmax) / (dmgmin - dmgmax), 0, 1)
            result[i] = mran + frac * (sran - mran)
        end
    end
    return result
end

local function linepaintfunc(self2, w, h)
    surface.SetDrawColor(Color(self2.Color.r, self2.Color.g, self2.Color.b, self2.Color.a * ArcCW.Inv_Fade))
    surface.SetMaterial(pickx_full)

    local imsize = h * 0.45

    surface.DrawTexturedRect((h - imsize) / 2, ((h - imsize) / 2) + (ss * 2), imsize, imsize)

    local tp = h + (ss * 2)

    surface.SetFont("ArcCWC2_10_Glow")
    surface.SetTextColor(col_shadow)
    surface.SetTextPos(tp, 0)
    DrawTextRot(self2, self2.Text, tp, 0, tp, 0, self2:GetWide() - tp)

    surface.SetFont("ArcCWC2_10")
    surface.SetTextColor(Color(self2.Color.r, self2.Color.g, self2.Color.b, self2.Color.a * ArcCW.Inv_Fade))
    surface.SetTextPos(tp, 0)
    DrawTextRot(self2, self2.Text, tp, 0, tp, 0, self2:GetWide() - tp, true)
end

local function headpaintfunc(self2, w, h)
    local tp = 0

    surface.SetFont("ArcCWC2_8_Glow")
    surface.SetTextColor(col_shadow)
    surface.SetTextPos(tp, 0)
    DrawTextRot(self2, self2.Text, tp, 0, tp, 0, self2:GetWide() - tp)

    surface.SetFont("ArcCWC2_8")
    surface.SetTextColor(Color(self2.Color.r, self2.Color.g, self2.Color.b, self2.Color.a * ArcCW.Inv_Fade))
    surface.SetTextPos(tp, 0)
    DrawTextRot(self2, self2.Text, tp, 0, tp, 0, self2:GetWide() - tp, true)
end

function SWEP:ShowInventoryButton()
    if ArcCW.ConVars["attinv_free"]:GetBool() then return false end
    --if ArcCW.ConVars["attinv_lockmode"]:GetBool() then return false end
    if !ArcCW.ConVars["enable_dropping"]:GetBool() then return false end

    return true
end

function SWEP:GetSlotInstalled(i)
    local slot = self.Attachments[i]
    local installed = slot.Installed

    if !installed then
        for _, slot2 in pairs(slot.MergeSlots or {}) do
            if !isnumber(slot2) then continue end
            if self.Attachments[slot2] and self.Attachments[slot2].Installed then
                installed = self.Attachments[slot2].Installed
                break
            elseif !self.Attachments[slot2] then
                print("ERROR! No attachment " .. tostring(slot2))
            end
        end
    end

    return installed
end

-- 1: Customize
-- 2: Presets
-- 3: Inventory
ArcCW.Inv_SelectedMenu = 1

-- Selected inventory slot
SWEP.Inv_SelectedSlot = 0

SWEP.Inv_Scroll = {}

-- 1: Stats
-- 2: Trivia
-- 3: Ballistics
ArcCW.Inv_SelectedInfo = 1

ArcCW.Inv_Fade = 0.01

ArcCW.Inv_ShownAtt = nil
ArcCW.Inv_Hidden = false

function SWEP:CreateCustomize2HUD()
    local cvar_reloadincust = ArcCW.ConVars["reloadincust"]
    local cvar_cust_sounds = ArcCW.ConVars["cust_sounds"]
    local cvar_darkunowned = ArcCW.ConVars["attinv_darkunowned"]
    local cvar_lockmode = ArcCW.ConVars["attinv_lockmode"]
    local cvar_truenames = ArcCW.ConVars["truenames"]

    if cvar_darkunowned:GetBool() then
        col_unowned = Color(0, 0, 0, 150)
        col_unowned_txt = Color(150, 150, 150, 255)
    else
        col_unowned = col_block
        col_unowned_txt = col_block_txt
    end

    ArcCW.Inv_ShownAtt = nil

    local scrw, scrh = ScrW(), ScrH()
    if vrmod and vrmod.IsPlayerInVR(self:GetOwner()) then
        -- Other resolutions seem to cause stretching issues
        scrw = 1366
        scrh = 768
    end

    ArcCW.InvHUD = vgui.Create("DFrame")

    local scrwmult = ArcCW.ConVars["hud_deadzone_x"]:GetFloat() * scrw
    local scrhmult = ArcCW.ConVars["hud_deadzone_y"]:GetFloat() * scrh

    ss = ArcCW.AugmentedScreenScale(1)
    rss = ss -- REAL SCREEN SCALE
    thicc = math.ceil(ss * 2)

    scrw, scrh = scrw - scrwmult, scrh - scrhmult

    local bar1_w = scrw / 4
    local bar2_w = scrw / 5
    local bar3_w = scrw / 2
    local airgap_x = ss * 24
    local airgap_y = ss * 24
    local smallgap = ss * 4

    local top_zone = ss * 24
    local bottom_zone = ss * 40

    local cornerrad = ss * 4

    local bigbuttonheight = ss * 36
    local smallbuttonheight = rss * 16

    local function PaintScrollBar(panel, w, h)
        local s = ss * 2
        draw.RoundedBox(ss * 1, (w - s) / 2, 0, s, h, col_fg)
    end

    local function clearrightpanel()
        if ArcCW.Inv_SelectedInfo == 1 then
            ArcCW.InvHUD_FormWeaponStats()
        elseif ArcCW.Inv_SelectedInfo == 2  then
            ArcCW.InvHUD_FormWeaponTrivia()
        elseif ArcCW.Inv_SelectedInfo == 3 then
            ArcCW.InvHUD_FormWeaponBallistics()
        end
    end

    ArcCW.Inv_Fade = 0.01

    ArcCW.InvHUD:SetPos(0, 0)
    ArcCW.InvHUD:SetSize(scrw, scrh)
    ArcCW.InvHUD:Center()
    ArcCW.InvHUD:SetDraggable(false)
    ArcCW.InvHUD:SetText("")
    ArcCW.InvHUD:SetTitle("")
    ArcCW.InvHUD:ShowCloseButton(false)
    ArcCW.InvHUD.Paint = function(self2)
        if !IsValid(self) then
            gui.EnableScreenClicker(false)
            ArcCW.InvHUD:Remove()
            return
        end

        if self:GetReloading() and !cvar_reloadincust:GetBool() then
            ArcCW.InvHUD:Remove()
            return
        end

        local st = 1 / 5
        if self:GetState() == ArcCW.STATE_CUSTOMIZE and !ArcCW.Inv_Hidden then
            ArcCW.Inv_Fade = math.Approach(ArcCW.Inv_Fade, 1, FrameTime() * 1 / st)
            --print("nooo")
        else
            ArcCW.Inv_Fade = math.Approach(ArcCW.Inv_Fade, 0, FrameTime() * 1 / st)
            --if (!game.SinglePlayer() and IsFirstTimePredicted() or true) and (self:GetState() != ArcCW.STATE_CUSTOMIZE or !ArcCW.Inv_Hidden) and ArcCW.Inv_Fade == 0 then ArcCW.InvHUD:Remove() end
            --print(CurTime())
                -- This'll completely screw up on multiplayer games and sometimes even singleplayer
        end
        col_fg = Color(255, 255, 255, Lerp(ArcCW.Inv_Fade, 0, 255))
        col_mayomustard = Color(255, 255, 127, Lerp(ArcCW.Inv_Fade, 0, 255))
        col_fg_tr = Color(255, 255, 255, Lerp(ArcCW.Inv_Fade, 0, 125))
        col_shadow = Color(0, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 255))
        col_button = Color(0, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 175))

        col_block = Color(50, 0, 0, 175 * ArcCW.Inv_Fade)
        col_block_txt = Color(175, 10, 10, Lerp(ArcCW.Inv_Fade, 0, 255))

        if cvar_darkunowned:GetBool() then
            col_unowned = Color(0, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 150))
            col_unowned_txt = Color(150, 150, 150, Lerp(ArcCW.Inv_Fade, 0, 255))
        else
            col_unowned = col_block
            col_unowned_txt = col_block_txt
        end

        --col_bad = Color(255, 50, 50, 255 * ArcCW.Inv_Fade)
        --col_good = Color(100, 255, 100, 255 * ArcCW.Inv_Fade)
        --col_info = Color(75, 75, 255, 255 * ArcCW.Inv_Fade)
    end
    ArcCW.InvHUD.ActiveWeapon = self
    ArcCW.InvHUD.OnRemove = function()
        local close = false
        if self:IsValid() and self:GetState() == ArcCW.STATE_CUSTOMIZE then
            close = true
        end

        if LocalPlayer():GetActiveWeapon() != ArcCW.InvHUD.ActiveWeapon then
            close = true
        end

        if close then
            net.Start("arccw_togglecustomize")
            net.WriteBool(false)
            net.SendToServer()

            if IsValid(self) and self.ToggleCustomizeHUD then
                self:ToggleCustomizeHUD(false)
            end
        end

        --print("INVHUD REMOVED", CurTime())
        ArcCW.Inv_Fade = 0.01
        gui.EnableScreenClicker(false)
    end

    if ArcCW.ConVars["attinv_onlyinspect"]:GetBool() then
        return
    end

    local menu1_w = bar1_w - airgap_x
    local menu1_h = scrh - (2 * airgap_y) - bottom_zone - top_zone + smallgap

    local closebutton = vgui.Create("DButton", ArcCW.InvHUD)
    closebutton:SetText("")
    closebutton:SetPos(scrw - smallbuttonheight - airgap_x, smallgap)
    closebutton:SetSize(rss * 24, bigbuttonheight)
    closebutton.Paint = function(self2, w, h)
        local col = col_fg

        if self2:IsHovered() then
            col = col_shadow
        end
        --draw.RoundedBox(ss * 1, 0, 0, w, h, Color(127, 127, 127, 127))
            -- Comment me! But it'll show when the HUD is alive.

        surface.SetTextColor(col_shadow)
        surface.SetTextPos(ss * 8, 0)
        surface.SetFont("ArcCWC2_24_Glow")
        surface.DrawText("x")

        surface.SetTextColor(col)
        surface.SetTextPos(ss * 8, 0)
        surface.SetFont("ArcCWC2_24")
        surface.DrawText("x")
    end
    closebutton.DoClick = function(self2, clr, btn)
        net.Start("arccw_togglecustomize")
        net.WriteBool(false)
        net.SendToServer()

        if IsValid(self) and self.ToggleCustomizeHUD then
            self:ToggleCustomizeHUD(false)
        end
    end
    closebutton.DoRightClick = function(self2, clr, btn)
        ArcCW.InvHUD:Remove()
    end

    local hidebutton = vgui.Create("DButton", ArcCW.InvHUD)
    hidebutton:SetText("")
    hidebutton:SetPos(scrw - smallbuttonheight * 2 - airgap_x, smallgap)
    hidebutton:SetSize(smallbuttonheight, bigbuttonheight)
    hidebutton.Paint = function(self2, w, h)
        local col = col_fg

        if self2:IsHovered() then
            col = Color(col_shadow.r, col_shadow.g, col_shadow.b, col_shadow.a * ArcCW.Inv_Fade)
        end
        --draw.RoundedBox(ss * 1, 0, 0, w, h, Color(127, 127, 127, 127))
            -- Comment me! But it'll show when the HUD is alive.

        surface.SetTextColor(col_shadow)
        surface.SetTextPos(ss * 8, ss * -4)
        surface.SetFont("ArcCWC2_24_Glow")
        surface.DrawText("_")

        surface.SetTextColor(col)
        surface.SetTextPos(ss * 8, ss * -4)
        surface.SetFont("ArcCWC2_24")
        surface.DrawText("_")
    end
    hidebutton.DoClick = function(self2, clr, btn)
        if IsValid(self) and self.ToggleCustomizeHUD then
            ArcCW.Inv_Hidden = !ArcCW.Inv_Hidden
            gui.EnableScreenClicker(false)
        end
    end

    -- Menu for attachment slots/presets
    ArcCW.InvHUD_Menu1 = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    ArcCW.InvHUD_Menu1:SetPos(airgap_x, airgap_y + top_zone + smallgap)
    ArcCW.InvHUD_Menu1:SetSize(menu1_w, menu1_h)

    local scroll_1 = ArcCW.InvHUD_Menu1:GetVBar()
    scroll_1.Paint = function() end

    scroll_1.btnUp.Paint = function(span, w, h)
    end
    scroll_1.btnDown.Paint = function(span, w, h)
    end
    scroll_1.btnGrip.Paint = PaintScrollBar

    local topframe = vgui.Create("DPanel", ArcCW.InvHUD)
    topframe:SetSize(menu1_w, ss * 16)
    topframe:SetPos(airgap_x, airgap_y + ss * 8)
    topframe.Paint = function() end

    local customizebutton = vgui.Create("DButton", topframe)
    customizebutton:SetSize(ss * 90, ss * 16)
    customizebutton:SetPos(0, 0)
    customizebutton:SetText("")
    customizebutton.Text = translate("ui.customize")
    customizebutton.Val = 1
    customizebutton.DoClick = function(self2, clr, btn)
        ArcCW.Inv_SelectedMenu = 1
        ArcCW.InvHUD_FormAttachments()

        surface.PlaySound("weapons/arccw/hover.wav")
    end
    customizebutton.Paint = function(self2, w, h)
        local col = col_button
        local col2 = col_fg

        if self2:IsHovered() or (ArcCW.Inv_SelectedMenu == self2.Val) then
            col = col_fg_tr
            col2 = col_shadow
        end

        draw.RoundedBox(cornerrad, 0, 0, w, h, col)

        surface.SetFont("ArcCWC2_8")
        local tw, th = surface.GetTextSize(self2.Text)

        surface.SetFont("ArcCWC2_8_Glow")
        surface.SetTextColor(col_shadow)
        surface.SetTextPos((w - tw) / 2, (h - th) / 2)
        surface.DrawText(self2.Text)

        surface.SetFont("ArcCWC2_8")
        surface.SetTextColor(col2)
        surface.SetTextPos((w - tw) / 2, (h - th) / 2)
        surface.DrawText(self2.Text)
    end

    local presetsbutton = vgui.Create("DButton", topframe)
    presetsbutton:SetSize(ss * 80, ss * 16)
    presetsbutton:SetPos(ss * 94, 0)
    presetsbutton:SetText("")
    presetsbutton.Text = translate("ui.presets")
    presetsbutton.Val = 2
    presetsbutton.DoClick = function(self2, clr, btn)
        ArcCW.Inv_SelectedMenu = 2
        ArcCW.InvHUD_FormPresets()

        surface.PlaySound("weapons/arccw/hover.wav")
    end
    presetsbutton.Paint = customizebutton.Paint

    if self:ShowInventoryButton() then
        customizebutton:SetSize(ss * 60, ss * 16)
        presetsbutton:SetSize(ss * 55, ss * 16)
        presetsbutton:SetPos(ss * 65, 0)

        local inventorybutton = vgui.Create("DButton", topframe)
        inventorybutton:SetSize(ss * 50, ss * 16)
        inventorybutton:SetPos(ss * 125, 0)
        inventorybutton:SetText("")
        inventorybutton.Text = translate("ui.inventory")
        inventorybutton.Val = 3
        inventorybutton.DoClick = function(self2, clr, btn)
            ArcCW.Inv_SelectedMenu = 3
            ArcCW.InvHUD_FormInventory()

            surface.PlaySound("weapons/arccw/hover.wav")
        end
        inventorybutton.Paint = customizebutton.Paint
    end

    local menu2_x, menu2_y = ArcCW.InvHUD_Menu1:GetPos()
    menu2_x = menu2_x + ArcCW.InvHUD_Menu1:GetWide() + smallgap
    local menu2_w = bar2_w
    local menu2_h = scrh - top_zone - airgap_y - airgap_y - (ss * 16)

    -- Menu for attachments
    ArcCW.InvHUD_Menu2 = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    ArcCW.InvHUD_Menu2:SetPos(menu2_x, menu2_y)
    ArcCW.InvHUD_Menu2:SetSize(menu2_w, menu2_h)

    -- ArcCW.InvHUD_Menu2.Paint = function(self2, w, h)
    --     draw.RoundedBox(2, 0, 0, w, h, col_fg)
    -- end

    local scroll_2 = ArcCW.InvHUD_Menu2:GetVBar()
    scroll_2.AlreadySet = false
    scroll_2.Paint = function(self2, w, h)
        if !self2.AlreadySet then
            self2:SetScroll(self.Inv_Scroll[self.Inv_SelectedSlot or 0] or 0)
            self2.AlreadySet = true
        end

        local scroll = self2:GetScroll()

        self.Inv_Scroll[self.Inv_SelectedSlot or 0] = scroll
    end

    scroll_2.btnUp.Paint = function(span, w, h)
    end
    scroll_2.btnDown.Paint = function(span, w, h)
    end
    scroll_2.btnGrip.Paint = PaintScrollBar

    function ArcCW.InvHUD_FormInventory()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu1:Clear()
        ArcCW.InvHUD_Menu2:Clear()
        self.Inv_SelectedSlot = nil
        clearrightpanel()

        local attinv = LocalPlayer().ArcCW_AttInv or {}

        local atts = table.GetKeys(attinv)

        table.sort(atts)

        local str = nil
        if #atts == 0 then
            str = translate("ui.noatts")
        elseif cvar_lockmode:GetBool() then
            str = translate("ui.lockinv")
        end

        if str then
            local msg = vgui.Create("DPanel", ArcCW.InvHUD_Menu1)
            msg:SetText("")
            msg:SetSize(menu2_w - (2 * ss), rss * 12)
            msg:Dock(TOP)
            msg.Paint = function(self2, w, h)
                local old = DisableClipping(true)
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_12_Glow")
                surface.DrawText(str)
                --DrawTextRot(self2, str, ss * 4, 0, ss * 4, ss * 2, w - (ss * 4))

                surface.SetTextColor(col_fg)
                surface.SetTextPos(ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_12")
                surface.DrawText(str)
                --DrawTextRot(self2, str, ss * 4, 0, ss * 4, ss * 2, w - (ss * 4))
                DisableClipping(old)
            end
        end

        for i, k in ipairs(atts) do
            if (ArcCW:PlayerGetAtts(self:GetOwner(), k) or 0) <= 0 then continue end
            local atttbl = ArcCW.AttachmentTable[k or ""]

            if atttbl.Free then continue end

            local button = vgui.Create("DButton", ArcCW.InvHUD_Menu1)
            button.att = k
            button:SetText("")
            button:SetSize(menu2_w - (2 * ss), smallbuttonheight)
            button:DockMargin(0, smallgap, 0, 0)
            button:Dock(TOP)
            button.DoClick = function(self2, clr, btn)
                if cvar_lockmode:GetBool() then return end

                surface.PlaySound("weapons/arccw/uninstall.wav")

                net.Start("arccw_asktodrop")
                    net.WriteUInt(ArcCW.AttachmentTable[self2.att].ID, 24)
                net.SendToServer()

                ArcCW:PlayerTakeAtt(self:GetOwner(), self2.att)
                if (self:GetOwner().ArcCW_AttInv[self2.att] or 0) == 0 then
                    self2:Remove()
                end
                clearrightpanel()
            end
            button.DoRightClick = function(self2, clr, btn)
                ArcCW.InvHUD_FormAttachmentStats(self2.att, self2.attslot)
            end
            button.Paint = function(self2, w, h)
                local col = col_button
                local col2 = col_fg

                if self2:IsHovered() then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                --[[]
                if self2:IsHovered() then
                    ArcCW.InvHUD_FormAttachmentStats(self2.att, self2.attslot)
                end
                ]]

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local icon_h = h
                local buffer = 0

                if !cvar_lockmode:GetBool() then
                    local amt = ArcCW:PlayerGetAtts(self:GetOwner(), self2.att) or 0
                    amt = math.min(amt, 99)
                    local amttxt = tostring(amt)
                    surface.SetFont("ArcCWC2_8")
                    local amt_w = surface.GetTextSize(amttxt)

                    -- surface.SetTextColor(col_shadow)
                    -- surface.SetFont("ArcCWC2_8_Glow")
                    -- surface.SetTextPos(w - amt_w - (ss * 1), h - (rss * 8) - (ss * 1))
                    -- surface.DrawText(amttxt)

                    surface.SetTextColor(col2)
                    surface.SetFont("ArcCWC2_8")
                    surface.SetTextPos(w - amt_w - (ss * 4), h - (rss * 8) - (ss * 1))
                    surface.DrawText(amttxt)

                    buffer = amt_w + (ss * 6)
                end

                local txt = translate("name." .. self2.att .. ".short") or atttbl.AbbrevName
                if !txt then
                    txt = translate("name." .. self2.att) or atttbl.PrintName
                end

                surface.SetTextColor(atttbl.Ignore and col_mayomustard or col2)
                surface.SetTextPos(icon_h + ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_12")

                DrawTextRot(self2, txt, icon_h + (ss * 4), 0, icon_h + ss * 4, ss * 2, w - icon_h - (ss * 4) - buffer)

                local icon = atttbl.Icon
                if !icon or icon:IsError() then icon = bird end

                surface.SetDrawColor(atttbl.Ignore and mayoicons and col_mayomustard or col2)
                surface.SetMaterial(icon)
                surface.DrawTexturedRect(ss * 2, 0, icon_h, icon_h)
            end
        end
    end

    function ArcCW.InvHUD_FormPresets()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu1:Clear()
        ArcCW.InvHUD_Menu2:Clear()
        self.Inv_SelectedSlot = nil
        self.Preset_DeleteMode = false
        clearrightpanel()

        local framer = vgui.Create("DPanel", ArcCW.InvHUD_Menu1)
        framer:SetSize(menu1_w, smallbuttonheight * 1.2)
        framer:DockMargin(0, 0, 0, smallgap)
        framer:Dock(TOP)
        framer.Paint = function() end

        local button = vgui.Create("DButton", framer)
        button:SetText("")
        button:Dock(LEFT)
        button:SetWide(menu1_w * 0.5)
        button:DockMargin(0, 0, smallgap, 0)
        button.DoClick = function(self2, clr, btn)
            self:CreatePresetSave()
            surface.PlaySound("weapons/arccw/open.wav")
        end
        button.Paint = function(self2, w, h)
            local col = col_button
            local col2 = col_fg

            if self2:IsHovered() then
                col = col_fg_tr
                col2 = col_shadow
            end

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            local preset_txt = translate("ui.createpreset") --"Create New Preset"

            surface.SetFont("ArcCWC2_14")
            surface.SetTextPos(ss * 4, ss * 0)
            surface.SetTextColor(col2)
            DrawTextRot(self2, preset_txt, 0, 0, ss * 4, ss * 0, w - ss * 4)
        end

        local remov = vgui.Create("DButton", framer)
        remov:SetText("")
        remov:Dock(FILL)
        remov.DoClick = function(self2, clr, btn)
            self.Preset_DeleteMode = !self.Preset_DeleteMode
            surface.PlaySound(self.Preset_DeleteMode and "weapons/arccw/open.wav" or "weapons/arccw/close.wav")
        end
        remov.Paint = function(self2, w, h)
            local col = col_button
            local col2 = col_fg

            if self.Preset_DeleteMode then
                if self2:IsHovered() then
                    col = Color(200, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 125))
                    col2 = col_shadow
                else
                    col = Color(100, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 175))
                end
            elseif self2:IsHovered() then
                col = col_fg_tr
                col2 = col_shadow
            end

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            local preset_txt = translate("ui.deletepreset")

            surface.SetFont("ArcCWC2_14")
            surface.SetTextPos(ss * 4, ss * 0)
            surface.SetTextColor(col2)
            DrawTextRot(self2, preset_txt, 0, 0, ss * 4, ss * 0, w - ss * 4)
        end

        local presetpanel = vgui.Create("DScrollPanel", ArcCW.InvHUD_Menu1)
        presetpanel:SetSize(menu1_w, menu1_h - smallbuttonheight * 1.2 - smallgap)
        presetpanel:SetPos(0, smallbuttonheight * 1.2 + smallgap)

        local scroll_preset = presetpanel:GetVBar()
        scroll_preset.Paint = function() end
        scroll_preset.btnUp.Paint = function(span, w, h)
        end
        scroll_preset.btnDown.Paint = function(span, w, h)
        end
        scroll_preset.btnGrip.Paint = PaintScrollBar

        local preset = {}

        preset = self:GetPresets()

        for i, k in pairs(preset) do
            if string.StripExtension(k) == "autosave" then continue end
            local load_btn = vgui.Create("DButton", presetpanel)
            load_btn:SetText("")
            load_btn.PresetName = string.StripExtension(k)
            load_btn.PresetFile = k
            load_btn:SetSize(menu1_w, smallbuttonheight)
            load_btn:DockMargin(0, smallgap, 0, 0)
            load_btn:Dock(TOP)
            load_btn.DoClick = function(self2, clr, btn)
                if !self.Preset_DeleteMode then
                    self.LastPresetName = self2.PresetName
                    self:LoadPreset(self2.PresetName)
                else
                    file.Delete(ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. self2.PresetFile)
                    self2:Remove()
                    surface.PlaySound("weapons/arccw/uninstall.wav")
                end
            end
            --[[]
            load_btn.DoRightClick = function(self2)
                local filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. self2.PresetName .. ".txt"
                file.Delete(filename)
                self2:Remove()
            end
            ]]
            load_btn.Paint = function(self2, w, h)
                local col = col_button
                local col2 = col_fg

                if self.Preset_DeleteMode then
                    if self2:IsHovered() then
                        col = Color(200, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 125))
                        col2 = col_shadow
                    --else
                    --    col = Color(100, 0, 0, Lerp(ArcCW.Inv_Fade, 0, 175))
                    end
                elseif self2:IsHovered() then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local preset_txt = self2.PresetName:upper()

                surface.SetFont("ArcCWC2_14")
                surface.SetTextPos(ss * 4, ss * 0)
                surface.SetTextColor(col2)
                DrawTextRot(self2, preset_txt, 0, 0, ss * 4, ss * 0, w - ss * 4)
            end
        end
    end

    function ArcCW.InvHUD_FormAttachmentSelect()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu2:Clear()

        local slot = self.Attachments[self.Inv_SelectedSlot or 0]

        if !slot then return end

        local atts = {}
        local slots = {self.Inv_SelectedSlot}
        local attCheck = {}

        table.Add(slots, slot.MergeSlots or {})

        for _, y in pairs(slots) do
            for _, bruh in pairs(ArcCW:GetAttsForSlot((self.Attachments[y] or {}).Slot, self)) do
                if attCheck[bruh] then continue end
                table.insert(atts, {
                    att = bruh,
                    slot = y
                })
                attCheck[bruh] = true
            end
        end

        atts[0] = {
            att = "",
            slot = self.Inv_SelectedSlot
        }

        table.sort(atts, function(a, b)
            a = a.att or ""
            b = b.att or ""
            local atttbl_a = ArcCW.AttachmentTable[a]
            local atttbl_b = ArcCW.AttachmentTable[b]

            local order_a = 0
            local order_b = 0

            order_a = atttbl_a.SortOrder or order_a
            order_b = atttbl_b.SortOrder or order_b

            if order_a == order_b then
                return (translate("name." .. a) or atttbl_a.PrintName or "") > (translate("name." .. b) or atttbl_b.PrintName or "")
            end

            return order_a > order_b
        end)

        local has = false
        for _, att in pairs(atts) do
            if !att then continue end
            if !istable(att) then continue end

            local show, _, _ = self:ValidateAttachment(att.att, nil, att.slot)
            -- if !ArcCW.AttachmentTable[att] then continue end

            if !show then continue end
            has = (att.att != "")

            local button = vgui.Create("DButton", ArcCW.InvHUD_Menu2)
            button.att = att.att
            button.attslot = att.slot
            button:SetText("")
            button:SetSize(menu2_w - (2 * ss), smallbuttonheight)
            button:DockMargin(0, smallgap, 0, 0)
            button:Dock(TOP)
            button.DoClick = function(self2, clr, btn)
                -- self.Inv_SelectedSlot = self2.attindex
                -- ArcCW.InvHUD_FormAttachmentSelect()
                -- self:DetachAllMergeSlots(self2.attslot, true)
                --if ArcCW.ConVars["enable_customization"]:GetInt() < 0 then return end
                if ArcCW:PlayerCanAttach(LocalPlayer(), self, self2.att, self2.attslot, false) then
                    if self2.att == "" then
                        self2:DoRightClick()
                    elseif self:Attach(self2.attslot, self2.att) then
                        ArcCW.Inv_ShownAtt = nil -- Force a regen on the panel so we can see toggle/slider options
                        ArcCW.InvHUD_FormAttachmentStats(self2.att, self2.attslot, true)
                    elseif self:CountAttachments() >= self:GetPickX() then
                        ArcCW.Inv_LastPickXBlock = CurTime()
                    end
                else
                    if CLIENT then surface.PlaySound("items/medshotno1.wav") end
                end
            end
            button.DoRightClick = function(self2)
                if ArcCW:PlayerCanAttach(LocalPlayer(), self, self2.att, self2.attslot, true) then
                    self:DetachAllMergeSlots(self2.attslot)
                    ArcCW.InvHUD_FormAttachmentSelect()
                else
                    if CLIENT then surface.PlaySound("items/medshotno1.wav") end
                end
            end
            button.Paint = function(self2, w, h)
                if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
                local col = col_button
                local col2 = col_fg

                local atttbl = ArcCW.AttachmentTable[self2.att or ""] or {}

                local _, _, blocked, showqty = self:ValidateAttachment(att.att, nil, att.slot)

                if blocked and atttbl.HideIfBlocked then self2:Remove() return end

                local installed = self:GetSlotInstalled(self2.attslot)

                if self2:IsHovered() or self2.att == installed or (self2.att == "" and !installed) then
                    col = col_fg_tr
                    col2 = col_shadow

                --     self2:SetSize(menu2_w - (2 * ss), smallbuttonheight * 2)
                -- else
                --     self2:SetSize(menu2_w - (2 * ss), smallbuttonheight)
                end

                if self2:IsHovered() then
                    ArcCW.InvHUD_FormAttachmentStats(self2.att, self2.attslot, installed == self2.att)
                end

                local owned = ArcCW:PlayerGetAtts(self:GetOwner(), att.att) > 0

                if blocked then
                    col = col_block
                    col2 = col_block_txt
                elseif !owned and installed != self2.att then
                    col = col_unowned
                    col2 = col_unowned_txt
                end

                if !owned and installed != self2.att then
                    showqty = false
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local icon_h = h

                if !self2.att or self2.att == "" then
                    local attslot = self.Attachments[self2.attslot]
                    local att_txt = self:GetBuff_Hook("Hook_GetDefaultAttName", self2.attslot, true) or attslot.DefaultAttName
                    att_txt = att_txt and try_translate(att_txt) or translate("attslot.noatt")
                    atttbl = {
                        PrintName = att_txt,
                        Icon = self:GetBuff_Hook("Hook_GetDefaultAttIcon", self2.attslot, true) or attslot.DefaultAttIcon or defaultatticon
                    }
                end

                local buffer = 0

                if showqty then
                    local amt = ArcCW:PlayerGetAtts(self:GetOwner(), self2.att) or 0

                    amt = math.min(amt, 99)

                    local amttxt = tostring(amt)

                    surface.SetFont("ArcCWC2_8")
                    local amt_w = surface.GetTextSize(amttxt)

                    -- surface.SetTextColor(col_shadow)
                    -- surface.SetFont("ArcCWC2_8_Glow")
                    -- surface.SetTextPos(w - amt_w - (ss * 1), h - (rss * 8) - (ss * 1))
                    -- surface.DrawText(amttxt)

                    surface.SetTextColor(col2)
                    surface.SetFont("ArcCWC2_8")
                    surface.SetTextPos(w - amt_w - (ss * 4), h - (rss * 8) - (ss * 1))
                    surface.DrawText(amttxt)

                    buffer = amt_w + (ss * 6)
                end

                local txt = translate("name." .. self2.att .. ".short") or atttbl.AbbrevName
                if !txt then
                    txt = translate("name." .. self2.att) or atttbl.PrintName
                end

                surface.SetTextColor(atttbl.Ignore and col_mayomustard or col2)
                surface.SetTextPos(icon_h + ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_12")

                DrawTextRot(self2, txt, icon_h + (ss * 4), 0, icon_h + ss * 4, ss * 2, w - icon_h - (ss * 4) - buffer)

                local icon = atttbl.Icon
                if !icon or icon:IsError() then icon = bird end

                surface.SetDrawColor(atttbl.Ignore and mayoicons and col_mayomustard or col2)
                surface.SetMaterial(icon)
                surface.DrawTexturedRect(ss * 2, 0, icon_h, icon_h)
            end
        end

        if table.Count(atts) > 1 and !has then
            local msg = vgui.Create("DPanel", ArcCW.InvHUD_Menu2)
            msg:SetText("")
            msg:SetSize(menu2_w - (2 * ss), smallbuttonheight)
            msg:Dock(TOP)
            msg.Paint = function(self2, w, h)
                local txt = translate("ui.noatts_slot")

                surface.SetTextColor(col_shadow)
                surface.SetTextPos(ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_10_Glow")
                DrawTextRot(self2, txt, ss * 4, 0, ss * 4, ss * 2, w - (ss * 4))

                surface.SetTextColor(col_fg)
                surface.SetTextPos(ss * 4, ss * 2)
                surface.SetFont("ArcCWC2_10")
                DrawTextRot(self2, txt, ss * 4, 0, ss * 4, ss * 2, w - (ss * 4))
            end
        end
    end

    -- add attachments

    function ArcCW.InvHUD_FormAttachments()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu1:Clear()
        for i, slot in pairs(self.Attachments) do
            if !istable(slot) then continue end
            if !slot.PrintName then continue end
            if i == "BaseClass" then continue end
            if slot.Hidden or slot.Blacklisted then continue end
            if slot.Integral then continue end

            local button = vgui.Create("DButton", ArcCW.InvHUD_Menu1)
            button.attindex = i
            button:SetText("")
            button:SetSize(menu1_w, bigbuttonheight)
            button:DockMargin(0, 0, 0, smallgap)
            button:Dock(TOP)
            button.DoClick = function(self2, clr, btn)
                if self.Inv_SelectedSlot == self2.attindex then
                    self.Inv_SelectedSlot = nil
                    ArcCW.InvHUD_Menu2:Clear()
                    clearrightpanel()
                    if cvar_cust_sounds:GetBool() then surface.PlaySound("weapons/arccw/close.wav") end
                else
                    local aslot = self.Attachments[i]

                    if self:CheckFlags(aslot.ExcludeFlags, aslot.RequireFlags) then
                        self.Inv_SelectedSlot = self2.attindex
                        ArcCW.InvHUD_FormAttachmentSelect()
                        ArcCW.InvHUD_FormAttachmentStats(self2.attindex, self2.attindex, true)
                        if cvar_cust_sounds:GetBool() then surface.PlaySound("weapons/arccw/open.wav") end
                    end
                end
            end
            button.DoRightClick = function(self2)
                if ArcCW:PlayerCanAttach(LocalPlayer(), self, nil, self2.attindex, true) then
                    self:DetachAllMergeSlots(self2.attindex)
                    ArcCW.InvHUD_FormAttachmentSelect()
                else
                    if CLIENT then surface.PlaySound("items/medshotno1.wav") end
                end
            end
            button.Paint = function(self2, w, h)
                if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
                local col = col_button
                local col2 = col_fg

                if self2:IsHovered() or self.Inv_SelectedSlot == self2.attindex then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                local aslot = self.Attachments[i]

                if !self:CheckFlags(aslot.ExcludeFlags, aslot.RequireFlags) then
                    col = col_block
                    col2 = col_block_txt
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local installed = self:GetSlotInstalled(i)

                local att_icon = self:GetBuff_Hook("Hook_GetDefaultAttIcon", i, true) or slot.DefaultAttIcon or defaultatticon
                local att_txt = self:GetBuff_Hook("Hook_GetDefaultAttName", i, true) or slot.DefaultAttName
                att_txt = att_txt and try_translate(att_txt) or translate("attslot.noatt")
                local atttbl = ArcCW.AttachmentTable[installed or ""]

                if atttbl then
                    att_txt = translate("name." .. installed .. ".short") or atttbl.AbbrevName
                    if !att_txt then
                        att_txt = translate("name." .. installed) or atttbl.PrintName
                    end
                    att_icon = atttbl and atttbl.Icon
                    if !att_icon or att_icon:IsError() then att_icon = bird end
                end

                local slot_txt = try_translate(slot.PrintName)

                surface.SetDrawColor((atttbl and atttbl.Ignore and mayoicons and col_mayomustard) or col2)
                local icon_h = h
                surface.SetMaterial(att_icon)
                surface.DrawTexturedRect(w - icon_h - ss * 2, 0, icon_h, icon_h)

                surface.SetTextColor((atttbl and atttbl.Ignore and col_mayomustard) or col2)
                surface.SetFont("ArcCWC2_10")
                surface.SetTextPos(ss * 6, ss * 4)
                DrawTextRot(self2, slot_txt, 0, 0, ss * 6, ss * 4, w - icon_h - ss * 4)
                -- surface.DrawText(slot.PrintName)

                surface.SetFont("ArcCWC2_14")
                surface.SetTextPos(ss * 6, ss * 14)
                DrawTextRot(self2, att_txt, 0, 0, ss * 6, ss * 14, w - icon_h - ss * 4)
            end
        end

        local pickxpanel = vgui.Create("DPanel", ArcCW.InvHUD)
        pickxpanel:SetSize(menu1_w - ArcCW.InvHUD_Menu1:GetVBar():GetWide(), bottom_zone - smallgap * 4)
        pickxpanel:SetPos(airgap_x, scrh - bottom_zone - smallgap * 4)
        pickxpanel.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
            local pickx_amount = self:GetPickX()
            local pickedatts = self:CountAttachments()

            local col_fg_pick = col_fg
            local d = 0.5
            local diff = CurTime() - (ArcCW.Inv_LastPickXBlock or 0 + d)
            if diff > 0 then
                col_fg_pick = Color(255, 255 * diff / d, 255 * diff / d, 255*ArcCW.Inv_Fade)
            end

            if pickx_amount == 0 then return end
            if pickx_amount > 8 then
                surface.SetFont("ArcCWC2_16")
                local txt = string.format(translate("ui.pickx"), pickedatts, pickx_amount)
                local s = surface.GetTextSize(txt)
                surface.SetTextColor(col_fg_pick)
                surface.SetTextPos(w / 2 - s / 2, ss * 4)
                surface.DrawText(txt)
                return
            end

            local x = 0
            local y = ss * 4

            local s = ss * 20

            x = (w - (s * pickx_amount)) / 2

            local icons = {}
            for k, v in pairs(self.Attachments) do
                if v.Installed and !v.FreeSlot and !ArcCW.AttachmentTable[v.Installed].IgnorePickX then
                    local icon = (ArcCW.AttachmentTable[v.Installed] or {}).Icon or defaultatticon
                    if !icon or icon:IsError() then icon = bird end
                    table.insert(icons, icon)
                end
            end

            for i = 1, pickx_amount do
                surface.SetDrawColor(col_fg_pick)
                if i > pickedatts then
                    surface.SetMaterial(pickx_empty)
                else
                    surface.SetMaterial(pickx_full)
                end
                surface.DrawTexturedRect(x, y, s, s)
                if i <= pickedatts and icons[i] then
                    surface.SetDrawColor(col_shadow)
                    surface.SetMaterial(icons[i])
                    surface.DrawTexturedRect(x + ss * 3, y + ss * 3, ss * 14, ss * 14)
                end

                x = x + s
            end
        end
    end

    local menu3_h = scrh - airgap_y - bottom_zone
    local menu3_w = bar3_w

    -- weapon details
    ArcCW.InvHUD_Menu3 = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    ArcCW.InvHUD_Menu3:SetPos(scrw - menu3_w, airgap_y + smallgap)
    ArcCW.InvHUD_Menu3:SetSize(menu3_w, menu3_h)

    function ArcCW.InvHUD_FormAttachmentStats(att, slot, equipped)
        if ArcCW.Inv_ShownAtt == att then
            return
        end
        if isnumber(att) then
            local installed = self:GetSlotInstalled(att)

            att = installed
        end
        if !att then
            clearrightpanel()
            return
        end
        local atttbl = ArcCW.AttachmentTable[att]

        if !atttbl then return end

        ArcCW.InvHUD_Menu3:Clear()

        ArcCW.Inv_ShownAtt = att

        local s = ss * 250

        local bgim = vgui.Create("DLabel", ArcCW.InvHUD_Menu3)
        bgim:SetText("")
        bgim:SetPos(menu3_w - s - (ss * 25), 0)
        bgim:SetSize(s, s)
        bgim.Paint = function(self2, w, h)
            local icon = atttbl.Icon
            if !icon or icon:IsError() then icon = bird end

            surface.SetDrawColor(255, 255, 255, 25 * ArcCW.Inv_Fade)
            surface.SetMaterial(icon)
            surface.DrawTexturedRect(0, 0, w, h)
        end

        local attname_panel = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        attname_panel:SetSize(menu3_w, rss * 24)
        attname_panel:SetPos(0, rss * 16)
        attname_panel.Paint = function(self2, w, h)
            local name = translate("name." .. atttbl.ShortName) or atttbl.PrintName

            surface.SetFont("ArcCWC2_24")
            local tw = surface.GetTextSize(name)

            surface.SetTextColor(col_shadow)
            surface.SetFont("ArcCWC2_24_Glow")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x)

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_24")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x, true)
        end

        local scroll = vgui.Create("DScrollPanel", ArcCW.InvHUD_Menu3)
        --scroll:SetSize(menu3_w - airgap_x, ss * 128)
        --scroll:SetPos(0, rss * 32 + ss * 16)

        local scroll_bar = scroll:GetVBar()
        scroll_bar.Paint = function() end

        scroll_bar.btnUp.Paint = function(span, w, h)
        end
        scroll_bar.btnDown.Paint = function(span, w, h)
        end
        scroll_bar.btnGrip.Paint = PaintScrollBar

        local bottombuffer = 0

        local m_w = menu3_w * 0.75
        local leftbuffer = 0

        if equipped and self.Attachments[slot].SlideAmount and !atttbl.MountPositionOverride then
            local slider = vgui.Create("DButton", ArcCW.InvHUD_Menu3)

            slider:SetSize(m_w * 2 / 3, rss * 10)
            slider:SetPos(0, rss * 16 + rss * 24 + ss * 128 - (rss * 10))
            slider:SetText("")
            slider.Dragging = false
            slider.NextDrag = 0
            slider.OnRemove = function(self2)
                self:SendDetail_SlidePos(slot)
                self:SavePreset("autosave")
            end
            slider.Paint = function(self2, w, h)
                local col = col_button
                local col2 = col_fg

                if self2:IsHovered() or self2.Dragging then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local linebuffer = ss * 8
                local line_w = w - (linebuffer * 2)

                if self2.Dragging or (self2:IsHovered() and input.IsMouseDown(MOUSE_LEFT)) then
                    local x, _ = self2:LocalCursorPos()

                    local mouse_line_x = x - linebuffer

                    local delta = mouse_line_x / line_w

                    delta = math.Clamp(delta, 0, 1)

                    if self.Attachments[slot].SlidePos != delta and self2.NextDrag <= CurTime() then
                        -- local amt = math.abs(self.Attachments[slot].SlidePos - delta)
                        EmitSound("weapons/arccw/dragatt.wav", EyePos(), -2, CHAN_ITEM, 1,75, 0, math.Clamp(90+(delta * 20), 90, 110))
                        self2.NextDrag = CurTime() + 0.05
                    end

                    self.Attachments[slot].SlidePos = delta

                    self2.Dragging = true

                    if !input.IsMouseDown(MOUSE_LEFT) then
                        self2.Dragging = false

                        self:SetupActiveSights()
                        self:SendDetail_SlidePos(slot)
                        self:SavePreset("autosave")
                    end
                end

                local slide = (self.Attachments[slot] or {}).SlidePos or 0.5

                surface.SetDrawColor(col2)
                surface.DrawLine(linebuffer, h / 2, w - linebuffer, h / 2)

                local rect_x = slide * line_w + linebuffer
                local rect_w = ss * 6
                surface.DrawRect(rect_x - (rect_w / 2), (h - rect_w) / 2, rect_w, rect_w)
            end

            leftbuffer = m_w * 2 / 3
            bottombuffer = bottombuffer + rss * 10
        end

        if equipped and atttbl.ToggleStats then
            local toggle = vgui.Create("DButton", ArcCW.InvHUD_Menu3)

            toggle:SetSize(m_w * 1 / 3 - rss * 2, rss * 10)
            toggle:SetPos(leftbuffer + (ss * 4), rss * 16 + rss * 24 + ss * 128 - (rss * 10))
            toggle:SetText("")
            toggle.OnMousePressed = function(self2, kc)
                if kc == MOUSE_LEFT then
                    self:ToggleSlot(slot)
                elseif kc == MOUSE_RIGHT then
                    self:ToggleSlot(slot, nil, nil, true)
                end
            end
            toggle.Paint = function(self2, w, h)
                local col = col_button
                local col2 = col_fg

                if self2:IsHovered() or ArcCW.Inv_SelectedInfo == self2.Val then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local txt = (translate("ui.toggle"))
                local catttbl = ArcCW.AttachmentTable[att]
                if catttbl and catttbl.ToggleStats[self.Attachments[slot].ToggleNum]
                        and catttbl.ToggleStats[self.Attachments[slot].ToggleNum].PrintName then
                    txt = try_translate(catttbl.ToggleStats[self.Attachments[slot].ToggleNum].PrintName)
                end

                surface.SetFont("ArcCWC2_8")
                local tw, th = surface.GetTextSize(txt)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(txt)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col2)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(txt)
            end

            local togglelock = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
            togglelock:SetSize(rss * 10, rss * 10)
            togglelock:SetPos(leftbuffer + (ss * 4) + m_w * 1 / 3, rss * 16 + rss * 24 + ss * 128 - (rss * 10))
            togglelock:SetText("")
            togglelock.OnMousePressed = function(self2, kc)
                self.Attachments[slot].ToggleLock = !self.Attachments[slot].ToggleLock
                if self.Attachments[slot].ToggleLock then
                    self:EmitSound("weapons/arccw/dragatt.wav", 0, 150)
                else
                    self:EmitSound("weapons/arccw/dragatt.wav", 0, 80)
                end
            end
            togglelock.Paint = function(self2, w, h)
                local col = col_button
                local col2 = col_fg

                if self2:IsHovered() or ArcCW.Inv_SelectedInfo == self2.Val then
                    col = col_fg_tr
                    col2 = col_shadow
                end

                draw.RoundedBox(cornerrad, 0, 0, w, h, col)
                surface.SetDrawColor(col2.r, col2.g, col2.b)
                surface.SetMaterial(self.Attachments[slot].ToggleLock and iconlock or iconunlock)
                surface.DrawTexturedRect(4, 4, w - 8, h - 8)
            end

            bottombuffer = bottombuffer + rss * 10
        end

        scroll:SetPos(0, rss * 32 + ss * 16 + bottombuffer)
        scroll:SetSize(menu3_w - airgap_x, ss * 128 - bottombuffer)

        local multiline = {}
        local desc = translate("desc." .. atttbl.ShortName) or translate(atttbl.Description) or atttbl.Description

        multiline = multlinetext(desc, scroll:GetWide() - (ss * 2), "ArcCW_10")

        local desc_title = vgui.Create("DPanel", scroll)
        desc_title:SetSize(scroll:GetWide(), rss * 8)
        desc_title:SetPos(0, 0)
        desc_title.Paint = function(self2, w, h)
            surface.SetFont("ArcCWC2_8")
            local txt = translate("trivia.description")
            local tw_1 = surface.GetTextSize(txt)

            surface.SetFont("ArcCWC2_8_Glow")
            surface.SetTextColor(col_shadow)
            surface.SetTextPos(w - tw_1, 0)
            surface.DrawText(txt)

            surface.SetFont("ArcCWC2_8")
            surface.SetTextColor(col_fg)
            surface.SetTextPos(w - tw_1, 0)
            surface.DrawText(txt)
        end

        for i, text in pairs(multiline) do
            local desc_line = vgui.Create("DPanel", scroll)
            desc_line:SetSize(scroll:GetWide(), rss * 10)
            desc_line:SetPos(0, (rss * 10 * i) - (rss * 2))
            desc_line.Paint = function(self2, w, h)
                surface.SetFont("ArcCWC2_10")
                local tw = surface.GetTextSize(text)

                surface.SetFont("ArcCWC2_10_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw, 0)
                surface.DrawText(text)

                surface.SetFont("ArcCWC2_10")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw, 0)
                surface.DrawText(text)
            end
        end

        local scroll_pros = vgui.Create("DScrollPanel", ArcCW.InvHUD_Menu3)
        scroll_pros:SetSize(menu3_w, ss * 172)
        scroll_pros:SetPos(0, menu3_h - (ss * 172))
        scroll_pros.Paint = function() end

        local scroll_bar_pros = scroll_pros:GetVBar()
        scroll_bar_pros.Paint = function() end

        scroll_bar_pros.btnUp.Paint = function(span, w, h)
        end
        scroll_bar_pros.btnDown.Paint = function(span, w, h)
        end
        scroll_bar_pros.btnGrip.Paint = PaintScrollBar

        -- Don't have stats disappear due to toggle state
        local pros, cons, infos = ArcCW:GetProsCons(self, atttbl) -- self.Attachments[slot].ToggleNum

        pros = pros or {}
        cons = cons or {}
        infos = infos or {}

        local p_w = menu3_w / 2

        local pan_pros = vgui.Create("DPanel", scroll_pros)
        pan_pros:SetPos(0, 0)
        pan_pros.Paint = function() end

        local pan_cons = vgui.Create("DPanel", scroll_pros)
        pan_cons:SetPos(#pros > 0 and (menu3_w * 1 / 2) or 0, 0)
        pan_cons.Paint = function() end

        local pan_infos

        if #infos > 0 then
            pan_infos = vgui.Create("DPanel", scroll_pros)
            pan_infos:SetWide(menu3_w)
            pan_infos.Paint = function() end
        end
        p_w = (pan_pros and pan_cons) and (menu3_w / 2) or p_w

        if #pros > 0 then
            local pan_head = vgui.Create("DPanel", pan_pros)
            pan_head:SetTall(rss * 8)
            pan_head:Dock(TOP)
            pan_head.Paint = headpaintfunc
            pan_head.Text = translate("ui.positives")
            pan_head.Color = col_good
        end

        if #cons > 0 then
            local pan_head = vgui.Create("DPanel", pan_cons)
            pan_head:SetTall(rss * 8)
            pan_head:Dock(TOP)
            pan_head.Paint = headpaintfunc
            pan_head.Text = translate("ui.negatives")
            pan_head.Color = col_bad
        end

        for i, line in pairs(pros) do
            if !line or line == "" then continue end
            local pan_line = vgui.Create("DPanel", pan_pros)
            pan_line:SetSize(p_w, rss * 10)
            pan_line:SetPos(0, rss * 10 * i)
            pan_line.Paint = linepaintfunc
            pan_line.Text = line
            pan_line.Color = col_good
        end

        pan_pros:SizeToChildren(true, true)

        for i, line in pairs(cons) do
            if !line or line == "" then continue end
            local pan_line = vgui.Create("DPanel", pan_cons)
            pan_line:SetSize(p_w, rss * 10)
            pan_line:SetPos(0, rss * 10 * i)
            pan_line.Paint = linepaintfunc
            pan_line.Text = line
            pan_line.Color = col_bad
        end

        pan_cons:SizeToChildren(true, true)

        if #infos > 0 then
            local pan_head = vgui.Create("DPanel", pan_infos)
            pan_head:SetTall(rss * 8)
            pan_head:Dock(TOP)
            pan_head.Paint = headpaintfunc
            pan_head.Text = translate("ui.information")
            pan_head.Color = col_info

            for i, line in pairs(infos) do
                if !line or line == "" then continue end
                local pan_line = vgui.Create("DPanel", pan_infos)
                pan_line:SetSize(menu3_w, rss * 10)
                pan_line:SetPos(0, rss * 10 * i)
                pan_line.Paint = linepaintfunc
                pan_line.Text = line
                pan_line.Color = col_info
            end

            -- We can't do this on initialize because SizeToChildren isn't called yet
            local h = math.max(pan_pros and pan_pros:GetTall() or 0, pan_cons and pan_cons:GetTall() or 0)
            h = (h > 0) and (h + rss * 10) or 0 -- if only info, don't add padding
            pan_infos:SetPos(0, h)
            pan_infos:SizeToChildren(true, true)
        end
    end

    function ArcCW.InvHUD_FormStatsTriviaBar()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        local statsbutton = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
        statsbutton:SetSize(ss * 48, ss * 16)
        statsbutton:SetPos(menu3_w - (ss * 48 * 2) - airgap_x - (ss * 4), rss * 48 + ss * 12)
        statsbutton:SetText("")
        statsbutton.Text = translate("ui.stats")
        statsbutton.Val = 1
        statsbutton.DoClick = function(self2, clr, btn)
            ArcCW.InvHUD_FormWeaponStats()
            ArcCW.Inv_SelectedInfo = 1
        end
        statsbutton.Paint = function(self2, w, h)
            local col = col_button
            local col2 = col_fg

            if self2:IsHovered() or ArcCW.Inv_SelectedInfo == self2.Val then
                col = col_fg_tr
                col2 = col_shadow
            end

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            surface.SetFont("ArcCWC2_8")
            local tw, th = surface.GetTextSize(self2.Text)

            surface.SetFont("ArcCWC2_8_Glow")
            surface.SetTextColor(col_shadow)
            surface.SetTextPos((w - tw) / 2, (h - th) / 2)
            surface.DrawText(self2.Text)

            surface.SetFont("ArcCWC2_8")
            surface.SetTextColor(col2)
            surface.SetTextPos((w - tw) / 2, (h - th) / 2)
            surface.DrawText(self2.Text)
        end

        local triviabutton = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
        triviabutton:SetSize(ss * 48, ss * 16)
        triviabutton:SetPos(menu3_w - ss * 48 - airgap_x, rss * 48 + ss * 12)
        triviabutton:SetText("")
        triviabutton.Text = translate("ui.trivia")
        triviabutton.Val = 2
        triviabutton.DoClick = function(self2, clr, btn)
            ArcCW.InvHUD_FormWeaponTrivia()
            ArcCW.Inv_SelectedInfo = 2
        end
        triviabutton.Paint = statsbutton.Paint

        local ballisticsbutton = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
        ballisticsbutton:SetSize(ss * 48, ss * 16)
        ballisticsbutton:SetPos(menu3_w - (ss * 48 * 3) - airgap_x - (ss * 4 * 2), rss * 48 + ss * 12)
        ballisticsbutton:SetText("")
        ballisticsbutton.Text = translate("ui.ballistics")
        ballisticsbutton.Val = 3
        ballisticsbutton.DoClick = function(self2, clr, btn)
            ArcCW.InvHUD_FormWeaponBallistics()
            ArcCW.Inv_SelectedInfo = 3
        end
        ballisticsbutton.Paint = statsbutton.Paint
    end

    function ArcCW.InvHUD_FormWeaponName()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_FormStatsTriviaBar()
        local weapon_title = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        weapon_title:SetSize(menu3_w, rss * 32)
        weapon_title:SetPos(0, 0)
        weapon_title.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
            local name = translate("name." .. self:GetClass() .. (cvar_truenames:GetBool() and ".true" or "")) or translate(self.PrintName) or self.PrintName

            surface.SetFont("ArcCWC2_32")
            local tw = surface.GetTextSize(name)

            surface.SetTextColor(col_shadow)
            surface.SetFont("ArcCWC2_32_Glow")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x)

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_32")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x, true)
        end

        local weapon_cat = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        weapon_cat:SetSize(menu3_w, rss * 16)
        weapon_cat:SetPos(0, rss * 32)
        weapon_cat.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
            local class = try_translate(self:GetBuff_Override("Override_Trivia_Class") or self.Trivia_Class) or "missing"
            local cal = try_translate(self:GetBuff_Override("Override_Trivia_Calibre") or self.Trivia_Calibre)
            local name = class

            if !self.PrimaryMelee and !self.Throwing and cal then
                name = name .. ", " .. cal
            end

            surface.SetFont("ArcCWC2_16")
            local tw = surface.GetTextSize(name)

            surface.SetTextColor(col_shadow)
            surface.SetFont("ArcCWC2_16_Glow")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x)

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_16")
            surface.SetTextPos(w - tw - airgap_x, 0)
            DrawTextRot(self2, name, 0, 0, 0, 0, w - airgap_x, true)
        end
    end

    function ArcCW.InvHUD_FormWeaponTrivia()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu3:Clear()
        ArcCW.InvHUD_FormWeaponName()

        local scroll = vgui.Create("DScrollPanel", ArcCW.InvHUD_Menu3)
        scroll:SetSize(menu3_w - airgap_x, ss * 110)
        scroll:SetPos(0, rss * 48 + ss * 32)

        local scroll_bar = scroll:GetVBar()
        scroll_bar.Paint = function() end

        scroll_bar.btnUp.Paint = function(span, w, h)
        end
        scroll_bar.btnDown.Paint = function(span, w, h)
        end
        scroll_bar.btnGrip.Paint = PaintScrollBar

        local multiline = {}
        local desc = translate(self:GetBuff_Override("Override_Trivia_Desc")) or translate("desc." .. self:GetClass()) or self.Trivia_Desc

        multiline = multlinetext(desc, scroll:GetWide() - (ss * 2), "ArcCW_10")

        local desc_title = vgui.Create("DPanel", scroll)
        desc_title:SetSize(scroll:GetWide(), rss * 8)
        desc_title:Dock(TOP)
        desc_title.Paint = function(self2, w, h)
            surface.SetFont("ArcCWC2_8")
            local txt = translate("trivia.description")
            local tw_1 = surface.GetTextSize(txt)

            surface.SetFont("ArcCWC2_8_Glow")
            surface.SetTextColor(col_shadow)
            surface.SetTextPos(w - tw_1, 0)
            surface.DrawText(txt)

            surface.SetFont("ArcCWC2_8")
            surface.SetTextColor(col_fg)
            surface.SetTextPos(w - tw_1, 0)
            surface.DrawText(txt)
        end

        for i, text in pairs(multiline) do
            local desc_line = vgui.Create("DPanel", scroll)
            desc_line:SetSize(scroll:GetWide(), rss * 10)
            desc_line:Dock(TOP)
            desc_line.Paint = function(self2, w, h)
                surface.SetFont("ArcCWC2_10")
                local tw = surface.GetTextSize(text)

                surface.SetFont("ArcCWC2_10_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw, 0)
                surface.DrawText(text)

                surface.SetFont("ArcCWC2_10")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw, 0)
                surface.DrawText(text)
            end
        end

        local info = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        info:SetSize(menu3_w - airgap_x, menu3_h - ss * 110 - rss * 48 - ss * 32)
        info:SetPos(0, rss * 48 + ss * 32 + ss * 110)
        info.Paint = function(self2, w, h)
            local infos = self.Infos_Trivia or {}

            local year = try_translate(self:GetBuff_Override("Override_Trivia_Year") or self.Trivia_Year)

            if year then
                if isnumber(year) and year < 0 then
                    table.insert(infos, {
                        title = translate("trivia.year"),
                        value = tostring(-year),
                        unit = translate("unit.bce"),
                    })
                else
                    table.insert(infos, {
                        title = translate("trivia.year"),
                        value = tostring(year),
                    })
                end
            end

            local mech = try_translate(self:GetBuff_Override("Override_Trivia_Mechanism") or self.Trivia_Mechanism)

            if mech then
                table.insert(infos, {
                    title = translate("trivia.mechanism"),
                    value = translate(mech) or mech,
                })
            end

            local country = try_translate(self:GetBuff_Override("Override_Trivia_Country") or self.Trivia_Country)

            if country then
                table.insert(infos, {
                    title = translate("trivia.country"),
                    value = translate(country) or country,
                })
            end

            local manufacturer = try_translate(self:GetBuff_Override("Override_Trivia_Manufacturer") or self.Trivia_Manufacturer)

            if manufacturer then
                table.insert(infos, {
                    title = translate("trivia.manufacturer"),
                    value = translate(manufacturer) or manufacturer,
                })
            end

            local calibre = try_translate(self:GetBuff_Override("Override_Trivia_Calibre") or self.Trivia_Calibre)

            if calibre then
                table.insert(infos, {
                    title = translate("trivia.calibre"),
                    value = translate(calibre) or calibre,
                })
            end

            for i, triv in pairs(infos) do
                triv.unit = triv.unit or ""
                local i_2 = i - 1
                surface.SetFont("ArcCWC2_8")
                local tw_1 = surface.GetTextSize(triv.title)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)

                surface.SetFont("ArcCWC2_8")
                local tw_2 = surface.GetTextSize(triv.unit)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 12))
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 12))
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_16")
                local tw_3 = surface.GetTextSize(tostring(triv.value))

                surface.SetFont("ArcCWC2_16_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_2 - tw_3, (i_2 * (rss * 24)) + (rss * 6))
                -- surface.DrawText(triv.value)
                DrawTextRot(self2, triv.value, 0, i_2 * (rss * 24), math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6), w)

                -- (span, txt, x, y, tx, ty, maxw, only)

                surface.SetFont("ArcCWC2_16")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_2 - tw_3, (i_2 * (rss * 24)) + (rss * 6))
                -- surface.DrawText(triv.value)
                DrawTextRot(self2, triv.value, 0, i_2 * (rss * 24), math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6), w, true)
            end
        end
    end

    function ArcCW.InvHUD_FormWeaponStats()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu3:Clear()
        ArcCW.InvHUD_FormWeaponName()

        self.Infos_Stats = nil
        self.Infos_Breakpoints = nil
        local stats_breakpoint = false

        local info = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        info:SetSize(menu3_w - airgap_x, menu3_h - ss * 110 - rss * 48 - ss * 32)
        info:SetPos(0, rss * 48 + ss * 32 + ss * 110)
        info.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
            --local infos = self.Infos_Stats or {}

            if !self.Infos_Stats then

                self.Infos_Stats = {}

                -- rpm
                local rpm = math.Round(60 / self:GetFiringDelay())

                if self:GetIsManualAction() then

                    local fireanim = self:GetBuff_Hook("Hook_SelectFireAnimation") or self:SelectAnimation("fire")
                    local firedelay = self.Animations[fireanim].MinProgress or 0
                    rpm = math.Round(60 / ((firedelay + self:GetAnimKeyTime("cycle", true)) * self:GetBuff_Mult("Mult_CycleTime")))

                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.firerate"),
                        value = "~" .. tostring(rpm),
                        unit = translate("unit.rpm"),
                    })
                elseif !self.PrimaryBash and !self.Throwing then
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.firerate"),
                        value = tostring(rpm),
                        unit = translate("unit.rpm"),
                    })
                    local mode = self:GetCurrentFiremode()
                    if mode.Mode < 0 then
                        table.insert(self.Infos_Stats, {
                            title = translate("trivia.firerate_burst"),
                            value = tostring( math.Round( 60 / (self:GetFiringDelay() + ((mode.PostBurstDelay or 0) / -mode.Mode)) ) ),
                            unit = translate("unit.rpm"),
                        })
                    end
                end

                -- precision
                local precision = math.Round(self:GetBuff("AccuracyMOA"), 1)

                if !self.PrimaryBash and !self.Throwing then
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.precision"),
                        value = precision,
                        unit = translate("unit.moa"),
                    })
                end

                -- ammo type
                local ammo = string.lower(self:GetBuff_Override("Override_Ammo", self.Primary.Ammo))
                if (ammo or "") != "" and ammo != "none" then
                    local ammotype = ArcCW.TranslateAmmo(ammo) --language.GetPhrase(self.Primary.Ammo .. "_ammo")
                    if ammotype then
                        table.insert(self.Infos_Stats, {
                            title = translate("trivia.ammo"),
                            value = ammotype,
                            --unit = " (" .. ammo .. ")",
                        })
                    end
                end

                -- penetration
                local shootent = self:GetBuff("ShootEntity", true)

                if !self.PrimaryBash and !shootent then
                    local pen = math.Round( self:GetBuff("Penetration") )
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.penetration"),
                        value = pen,
                        unit = translate("unit.mm"),
                    })
                end

                -- noise
                local noise = self:GetBuff("ShootVol")

                if !self.PrimaryBash and !self.Throwing then
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.noise"),
                        value = math.Round(noise),
                        unit = translate("unit.db"),
                    })
                end

                if self.Throwing then
                    local ft = self:GetBuff_Override("Override_FuseTime") or self.FuseTime
                    if ft and ft > 0 then
                        table.insert(self.Infos_Stats, {
                            title = translate("trivia.fusetime"),
                            value = tostring(math.Round(ft, 1)),
                            unit = "s"
                        })
                    end
                end

                if self.PrimaryBash then
                    local meleedelay = self.MeleeTime * self:GetBuff_Mult("Mult_MeleeTime")
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.attackspersecond"),
                        value = tostring(math.Round(1 / meleedelay, 1)),
                        unit = translate("unit.aps")
                    })

                    local meleerange = self:GetBuff("MeleeRange")
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.range"),
                        value = tostring(math.Round(meleerange * ArcCW.HUToM)),
                        unit = "m"
                    })

                    local dmg = self.MeleeDamage * self:GetBuff_Mult("Mult_MeleeDamage")
                    table.insert(self.Infos_Stats, {
                        title = translate("trivia.damage"),
                        value = dmg,
                    })

                    local dmgtype = self:GetBuff_Override("Override_MeleeDamageType") or self.MeleeDamageType

                    if ArcCW.MeleeDamageTypes[dmgtype or ""] then
                        table.insert(self.Infos_Stats, {
                            title = translate("trivia.meleedamagetype"),
                            value = translate(ArcCW.MeleeDamageTypes[dmgtype]),
                        })
                    end
                end

            end

            for i, triv in pairs(self.Infos_Stats) do
                triv.unit = triv.unit or ""
                local i_2 = i - 1
                surface.SetFont("ArcCWC2_8")
                local tw_1 = surface.GetTextSize(triv.title)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)


                surface.SetFont("ArcCWC2_16")
                local tw_3a = select(2, surface.GetTextSize(tostring(triv.value)))

                surface.SetFont("ArcCWC2_8")
                local tw_2 = surface.GetTextSize(triv.unit)
                local tw_2a = select(2, surface.GetTextSize(triv.unit))

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 4.4) + tw_2a)
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 4.4) + tw_2a)
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_16")
                local tw_3 = surface.GetTextSize(tostring(triv.value))

                surface.SetFont("ArcCWC2_16_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6))
                surface.DrawText(triv.value)

                surface.SetFont("ArcCWC2_16")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6))
                surface.DrawText(triv.value)
            end
        end

        local stk_min, stk_max, stk_count = 1, shot_limit, shot_limit
        local stk_num = self:GetBuff("Num")
        local dmgt = tostring("DMG")

        local rangegraph = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
        rangegraph:SetSize(ss * 200, ss * 110)
        rangegraph:SetPos(menu3_w - ss * 200 - airgap_x, rss * 48 + ss * 32)
        rangegraph:SetText("")
        rangegraph.DoClick = function(self2)
            stats_breakpoint = !stats_breakpoint
        end
        rangegraph.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end

            local col = col_button
            if self2:IsHovered() then
                col = col_button_hv
            end
            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            if self.PrimaryBash or
                self.ShootEntity or
                self:GetBuff_Override("Override_ShootEntity") or
                self.NoRangeGraph
            then

                local txt = translate("ui.nodata")

                surface.SetTextColor(col_fg)
                surface.SetFont("ArcCWC2_24")
                local tw, th = surface.GetTextSize(txt)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(txt)

                return
            elseif self:GetBuff("Num") <= 0 then

                local txt = translate("ui.nonum")

                surface.SetTextColor(col_fg)
                surface.SetFont("ArcCWC2_12")
                local tw, th = surface.GetTextSize(txt)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(txt)

                return
            end

            local dmgmax = self:GetDamage(0)
            local dmgmin = self:GetDamage(math.huge)

            local mran, sran = self:GetMinMaxRange()

            if stats_breakpoint then

                if !self.Infos_Breakpoints then
                    self.Infos_Breakpoints = {}

                    local our = self:GetBuff_Override("Override_BodyDamageMults", self.BodyDamageMults)
                    local gam = ArcCW.LimbCompensation[engine.ActiveGamemode()] or ArcCW.LimbCompensation[1]
                    if our and ArcCW.ConVars["bodydamagemult_cancel"]:GetBool() then
                        gam = {}
                    elseif !our then
                        our = {}
                    end

                    -- Head
                    table.insert(self.Infos_Breakpoints, {"ui.hitgroup.head", shotstokill((our[HITGROUP_HEAD] or 1) / (gam[HITGROUP_HEAD] or 1), dmgmin, dmgmax, mran, sran)})

                    -- Torso
                    -- separates into Chest and Stomach if they have different values
                    local m_chest = (our[HITGROUP_CHEST] or 1) / (gam[HITGROUP_CHEST] or 1)
                    local m_stomach = (our[HITGROUP_STOMACH] or 1) / (gam[HITGROUP_STOMACH] or 1)
                    if m_chest == m_stomach then
                        table.insert(self.Infos_Breakpoints, {"ui.hitgroup.torso", shotstokill(m_chest, dmgmin, dmgmax, mran, sran)})
                    else
                        table.insert(self.Infos_Breakpoints, {"ui.hitgroup.chest", shotstokill(m_chest, dmgmin, dmgmax, mran, sran)})
                        table.insert(self.Infos_Breakpoints, {"ui.hitgroup.stomach", shotstokill(m_stomach, dmgmin, dmgmax, mran, sran)})
                    end

                    -- Arms and Legs
                    -- if two limbs have different multipliers (why???), use the smaller one
                    local m_arms = math.min((our[HITGROUP_LEFTARM] or 1) / (gam[HITGROUP_LEFTARM] or 1), (our[HITGROUP_RIGHTARM] or 1) / (gam[HITGROUP_RIGHTARM] or 1))
                    table.insert(self.Infos_Breakpoints, {"ui.hitgroup.arms", shotstokill(m_arms, dmgmin, dmgmax, mran, sran)})
                    local m_legs = math.min((our[HITGROUP_LEFTLEG] or 1) / (gam[HITGROUP_LEFTLEG] or 1), (our[HITGROUP_RIGHTLEG] or 1) / (gam[HITGROUP_RIGHTLEG] or 1))
                    table.insert(self.Infos_Breakpoints, {"ui.hitgroup.legs", shotstokill(m_legs, dmgmin, dmgmax, mran, sran)})

                    stk_num = self:GetBuff("Num")
                    local max = max_shots * (stk_num > 1 and 0.5 or 1)

                    -- Trim table values that are all -1 or math.huge on either end
                    stk_min, stk_max = 1, 1 + max_shots
                    local stk_min_n, stk_min_y = true, true
                    for i = 1, shot_limit do
                        if stk_min_y or stk_min_n then
                            stk_min = i
                        else
                            break
                        end
                        for j = 1, #self.Infos_Breakpoints do
                            if stk_min_n and self.Infos_Breakpoints[j][2][i] != -1 then
                                stk_min_n = false
                            elseif stk_min_y and self.Infos_Breakpoints[j][2][i] != math.huge then
                                stk_min_y = false
                            end
                            if !stk_min_y and !stk_min_n then
                                stk_min = math.Clamp(shot_limit, 1, math.max(1, i - 1))
                                break
                            end
                        end
                    end

                    local stk_max_n, stk_max_y = true, true
                    for i = shot_limit, 1, -1 do
                        if stk_max_y or stk_max_n then
                            stk_max = i
                        else
                            break
                        end
                        for j = 1, #self.Infos_Breakpoints do
                            if stk_max_n and self.Infos_Breakpoints[j][2][i] != -1 then
                                stk_max_n = false
                            elseif stk_max_y and self.Infos_Breakpoints[j][2][i] != math.huge then
                                stk_max_y = false
                            end
                            if !stk_max_y and !stk_max_n then
                                stk_max = math.Clamp(i + 1, 1, shot_limit)
                                break
                            end
                        end
                    end

                    stk_count = stk_max - stk_min + 1
                    if stk_count > max then
                        stk_max = stk_min + max - 1
                        stk_count = max
                    end


                    if GetConVar("developer"):GetInt() > 0 then
                        print(dmgmax .. "-" .. dmgmin .. "DMG; range " .. mran .. "/" .. sran)
                        print("table range: " .. stk_min .. " - " .. stk_max .. " (" .. stk_count .. ")")
                        PrintTable(self.Infos_Breakpoints)
                    end
                end

                local header_w = ss * 48
                local column_w = (w - header_w) / stk_count
                local header_h = ss * 16
                local column_h = (h - header_h) / #self.Infos_Breakpoints

                -- header texts
                surface.SetTextColor(col_fg)
                surface.SetFont("ArcCWC2_8")

                local hg_t = translate("ui.hitgroup")
                local _, hg_h = surface.GetTextSize(hg_t)
                surface.SetTextPos(ss, header_h - (thicc / 2) - hg_h)
                surface.DrawText(hg_t)

                local stk_t = translate("ui.shotstokill")
                local stk_w, _ = surface.GetTextSize(stk_t)
                surface.SetTextPos(header_w - (thicc / 2) - stk_w, 0)
                surface.DrawText(stk_t)

                -- vertical dividers
                local cnt_t = stk_num > 1 and ("×" .. stk_num) or ""
                surface.SetFont("ArcCWC2_8")
                local cnt_w, cnt_h = surface.GetTextSize(cnt_t)

                surface.SetDrawColor(255, 255, 255, Lerp(ArcCW.Inv_Fade, 0, 255))
                for i = 1, stk_count do
                    surface.DrawLine(header_w + i * column_w, 0, header_w + i * column_w, header_h)
                    surface.SetFont("ArcCWC2_16")
                    local num_t = tostring(i + stk_min - 1)
                    local num_w, num_h = surface.GetTextSize(num_t)
                    surface.SetTextPos(header_w + (i - 0.5) * column_w - num_w / 2 - cnt_w / 2, header_h / 2 - num_h / 2)
                    surface.DrawText(num_t)

                    if stk_num > 1 then
                        surface.SetFont("ArcCWC2_8")
                        surface.SetTextPos(header_w + (i - 0.5) * column_w + num_w / 2 - cnt_w / 2, header_h / 2 - num_h / 2 + cnt_h / 2)
                        surface.DrawText(cnt_t)
                    end
                end

                -- table info
                surface.SetFont("ArcCWC2_8")
                for i, tbl in ipairs(self.Infos_Breakpoints) do
                    local row_t = translate(tbl[1])
                    local row_w, row_h = surface.GetTextSize(row_t)
                    surface.SetTextPos(header_w / 2 - row_w / 2, header_h + column_h * (i - 0.5) - row_h / 2)
                    surface.DrawText(row_t)

                    for j = 1, stk_count do
                        local val = tbl[2][j + stk_min - 1]
                        local mat, siz
                        if val == -1 then
                            --ran_t = "⨯"
                            siz = ss * 8
                            mat = mat_hit
                            surface.SetDrawColor(col_bad.r, col_bad.g, col_bad.b, Lerp(ArcCW.Inv_Fade, 0, 255))
                        elseif val == math.huge then
                            --ran_t = "⚫"
                            siz = ss * 16
                            mat = mat_hit_dot
                            surface.SetDrawColor(col_good.r, col_good.g, col_good.b, Lerp(ArcCW.Inv_Fade, 0, 255))
                        else
                            local ran_t = math.floor(val) .. "m"
                            local ran_w, ran_h = surface.GetTextSize(ran_t)
                            surface.SetTextPos(header_w + (j - 0.5) * column_w - ran_w / 2, header_h + column_h * (i - 0.5) - ran_h / 2)
                            surface.DrawText(ran_t)
                        end

                        if mat then
                            surface.SetMaterial(mat)
                            surface.DrawTexturedRect(header_w + (j - 0.5) * column_w - siz / 2, header_h + column_h * (i - 0.5) - siz / 2, siz, siz)
                        end
                    end
                end


                for i = 1, thicc do
                    local meth = ((thicc - i) / thicc)
                    surface.SetDrawColor(255, 255, 255, Lerp(ArcCW.Inv_Fade, 0, 127 * meth))

                    local of
                    if i == 1 then
                        surface.SetDrawColor(col_fg)
                        of = 0
                    elseif (i % 2 == 0) then
                        -- even
                        of = -1 * i / 2
                    else
                        -- odd
                        of = 1 * i / 2
                    end

                    -- first vertical
                    surface.DrawLine(header_w + of, 0, header_w + of, h)

                    -- first horizontal
                    surface.DrawLine(0, header_h + of, w, header_h + of)

                    -- diagonal header
                    --surface.DrawLine(0, of, header_w, header_h + of)

                    -- horizontal dividers
                    for j = 1, #self.Infos_Breakpoints - 1 do
                        surface.DrawLine(0, header_h + column_h * j + of, w, header_h + column_h * j + of)
                    end
                end

                return
            end

            local scale = math.ceil((math.max(dmgmax, dmgmin) + 10) / 25) * 25
            local hscale = math.ceil(math.max(mran, sran) / 150) * 150

            scale = math.max(scale, 75)
            hscale = math.max(hscale, 150)

            local wmin = mran / hscale * w
            local wmax = math.min(sran / hscale * w, w - ss * 32)
            if sran == hscale then wmax = w end

            -- segment 1: minimum range
            local x_1 = 0
            local y_1 = h - (dmgmax / scale * h)
            y_1 = math.Clamp(y_1, ss * 16, h - (ss * 16))
            -- segment 2: slope
            local x_2 = 0
            local y_2 = y_1
            -- segment 3: maximum range
            local x_3 = wmax
            local y_3 = h - (dmgmin / scale * h)
            y_3 = math.Clamp(y_3, ss * 16, h - (ss * 16))

            local x_4 = w
            local y_4 = y_3

            if sran == mran then
                x_2 = w / 2
                x_3 = w / 2
            elseif mran > 0 then
                x_2 = wmin -- w * 1 / 3
            end

            local col_vline = LerpColor(0.5, col_fg, Color(0, 0, 0, 0))

            surface.SetDrawColor(col_vline)

            -- line for min range
            if dmgmax != dmgmin and mran > 0 then
                surface.DrawLine(x_2, 0, x_2, h)
            end

            -- line for max range
            if dmgmax != dmgmin then
                surface.DrawLine(x_3, 0, x_3, h)
            end

            -- damage number text
            for i = 1, thicc do
                local meth = ((thicc - i) / thicc)
                surface.SetDrawColor(255, 255, 255, Lerp(ArcCW.Inv_Fade, 0, 127 * meth))

                local of
                if i == 1 then
                    surface.SetDrawColor(col_fg)
                    of = 0
                elseif (i % 2 == 0) then
                    -- even
                    of = -1 * i / 2
                else
                    -- odd
                    of = 1 * i / 2
                end

                if mran > 0 then
                    -- draw seg 1
                    surface.DrawLine(x_1, y_1 + of, x_2, y_2 + of)
                end
                -- draw seg 2
                surface.DrawLine(x_2, y_2 + of, x_3, y_3 + of)
                -- drag seg 3
                surface.DrawLine(x_3, y_3 + of, x_4, y_4 + of)
            end

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")

            local drawndmg = false
            if dmgmax != dmgmin then

                if mran == 0 or wmin > ss * 24 then
                    local m_1, hu_1 = RangeText(0)

                    surface.SetTextPos(ss * 2, h - rss * 16)
                    surface.DrawText(m_1)
                    surface.SetTextPos(ss * 2, h - rss * 10)
                    surface.DrawText(hu_1)
                end

                if sran != hscale and w - wmax > ss * 40 then
                    local m_1x, hu_1x = RangeText(hscale)
                    local w_m, _ = surface.GetTextSize(m_1x)
                    local w_hu, _ = surface.GetTextSize(hu_1x)

                    surface.SetTextPos(w - w_m - ss * 2, h - rss * 16)
                    surface.DrawText(m_1x)
                    surface.SetTextPos(w - w_hu - ss * 2, h - rss * 10)
                    surface.DrawText(hu_1x)
                end

                if mran > 0 then
                    -- min damage
                    local dmg = tostring(math.Round(dmgmax))
                    local tw = surface.GetTextSize(dmg)
                    if wmin < tw then
                        surface.SetTextPos(x_2 + ss * 1, ss * 1)
                    else
                        surface.SetTextPos(x_2 - (tw / 2), ss * 1)
                    end
                    surface.DrawText(dmg)

                    local m_2, hu_2 = RangeText(mran)

                    surface.SetTextPos(x_2, h - rss * 16)
                    surface.DrawText(m_2)
                    surface.SetTextPos(x_2, h - rss * 10)
                    surface.DrawText(hu_2)

                    local twt = surface.GetTextSize(dmgt)

                    if wmin < tw then
                        surface.SetTextPos(x_2 + ss * 1, ss * 8)
                    else
                        surface.SetTextPos(x_2 - (twt / 2), ss * 8)
                    end
                    surface.DrawText(dmgt)

                    drawndmg = true
                end

                if sran == hscale then
                    -- draw max damage at edge
                    local dmg = tostring(math.Round(dmgmin))
                    local tw = surface.GetTextSize(dmg)
                    surface.SetTextPos(w - ss * 2 - tw, ss * 1)
                    surface.DrawText(dmg)

                    local m_3, hu_3 = RangeText(sran)
                    local w_m, _ = surface.GetTextSize(m_3)
                    local w_hu, _ = surface.GetTextSize(hu_3)

                    surface.SetTextPos(w - ss * 2 - w_m, h - rss * 16)
                    surface.DrawText(m_3)
                    surface.SetTextPos(w - ss * 2 - w_hu, h - rss * 10)
                    surface.DrawText(hu_3)

                    local twt = surface.GetTextSize(dmgt)
                    surface.SetTextPos(w - ss * 2 - twt, ss * 8)
                    surface.DrawText(dmgt)

                elseif sran != mran then
                    -- draw max damage centered
                    local dmg = tostring(math.Round(dmgmin))
                    local tw = surface.GetTextSize(dmg)
                    surface.SetTextPos(x_3 - (tw / 2), ss * 1)
                    surface.DrawText(dmg)

                    local m_3, hu_3 = RangeText(sran)

                    surface.SetTextPos(x_3, h - rss * 16)
                    surface.DrawText(m_3)
                    surface.SetTextPos(x_3, h - rss * 10)
                    surface.DrawText(hu_3)

                    local twt = surface.GetTextSize(dmgt)
                    surface.SetTextPos(x_3 - (twt / 2), ss * 8)
                    surface.DrawText(dmgt)
                end


                if sran != mran and self2:IsHovered() then
                    local mouse_x, _ = self2:ScreenToLocal(input.GetCursorPos())
                    local mouse_frac = math.Clamp((mouse_x - x_2) / (x_3 - x_2), 0, 1)

                    if mouse_frac > 0 and mouse_frac < 1 then
                        local mouse_range = mran + mouse_frac * (sran - mran)
                        local mouse_dmg = math.Round(self:GetDamage(mouse_range))
                        local y_slope = Lerp(mouse_frac, y_2, y_3)

                        surface.SetDrawColor(col_vline)
                        surface.DrawLine(mouse_x, 0, mouse_x, h)

                        local mouse_text1 = tostring(mouse_dmg)
                        local mouse_text_w, _ = surface.GetTextSize(mouse_text1)
                        local nudge = -mouse_text_w * 0.5
                        local side_margin = ss * 12
                        local a = 255
                        if mouse_x - x_2 <= side_margin then
                            local f = (1 - (mouse_x - x_2) / side_margin)
                            a = Lerp(f, 255, 0)
                        elseif x_3 - mouse_x <= side_margin then
                            local f = (1 - (x_3 - mouse_x) / side_margin)
                            a = Lerp(f, 255, 25)
                        end
                        surface.SetTextColor(255, 255, 255, a)
                        surface.SetTextPos(mouse_x + nudge, y_slope - ss * 12)
                        surface.DrawText(mouse_text1)

                        local m_mouse, hu_mouse = RangeText(mouse_range)
                        local w_m, _ = surface.GetTextSize(m_mouse)
                        local w_hu, _ = surface.GetTextSize(hu_mouse)
                        surface.SetTextPos(mouse_x - w_m * 0.5, y_slope + rss * 5)
                        surface.DrawText(m_mouse)
                        surface.SetTextPos(mouse_x - w_hu * 0.5, y_slope + rss * 11)
                        surface.DrawText(hu_mouse)

                    end
                end
            end

            if !drawndmg then
                surface.SetTextColor(col_fg)

                local dmg = tostring(math.Round(dmgmax))
                surface.SetTextPos(ss * 2, ss * 1)
                surface.DrawText(dmg)

                surface.SetTextPos(ss * 2, ss * 8)
                surface.DrawText(dmgt)

            end
        end
    end

    function ArcCW.InvHUD_FormWeaponBallistics()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        ArcCW.InvHUD_Menu3:Clear()
        ArcCW.InvHUD_FormWeaponName()

        self.Infos_Ballistics = nil

        local info = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        info:SetSize(menu3_w - airgap_x, menu3_h - (ss * 110) - (ss * 70) - rss * 48 - ss * 32)
        info:SetPos(0, rss * 48 + ss * 32 + (ss * 110) + (ss * 70))
        info.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end

            if !self.Infos_Ballistics then

                self.Infos_Ballistics = {}

                table.insert(self.Infos_Ballistics, {
                    title = translate("trivia.muzzlevel"),
                    value = math.Round(self:GetMuzzleVelocity() * ArcCW.HUToM),
                    unit = translate("unit.mps"),
                })

                table.insert(self.Infos_Ballistics, {
                    title = translate("trivia.recoil"),
                    value = math.Round(self.Recoil * ArcCW.RecoilUnit * self:GetBuff_Mult("Mult_Recoil"), 1),
                    unit = translate("unit.lbfps"),
                })

                table.insert(self.Infos_Ballistics, {
                    title = translate("trivia.recoilside"),
                    value = math.Round(self.RecoilSide * ArcCW.RecoilUnit * self:GetBuff_Mult("Mult_RecoilSide"), 1),
                    unit = translate("unit.lbfps"),
                })

                -- arccw_approved_recoil_score
                local aars = 0
                local disclaimers = ""

                aars = aars + (self.Recoil + self:GetBuff_Add("Add_Recoil")) * self:GetBuff_Mult("Mult_Recoil")
                aars = aars + (self.RecoilSide + self:GetBuff_Add("Add_RecoilSide")) * self:GetBuff_Mult("Mult_RecoilSide") * 0.5

                local arpm = (60 / self:GetFiringDelay())

                if self:GetIsManualAction() then
                    local fireanim = self:GetBuff_Hook("Hook_SelectFireAnimation") or self:SelectAnimation("fire")
                    local firedelay = self.Animations[fireanim].MinProgress or 0

                    arpm = math.Round(60 / ((firedelay + self:GetAnimKeyTime("cycle", true)) * self:GetBuff_Mult("Mult_CycleTime")))
                elseif self:GetCurrentFiremode().Mode == 1 then
                    arpm = math.min(400, 60 / self:GetFiringDelay())
                end
                aars = aars * arpm

                --[[
                if self:GetCurrentFiremode().Mode == 1 or self:GetIsManualAction() then
                    disclaimers = disclaimers .. " " .. arpm .. translate("unit.rpm")
                end
                ]]

                table.insert(self.Infos_Ballistics, {
                    title = translate("trivia.recoilscore"),
                    value = math.Round(aars),
                    unit = " points" .. disclaimers,
                })

            end

            for i, triv in pairs(self.Infos_Ballistics) do
                triv.unit = triv.unit or ""
                local i_2 = i - 1
                surface.SetFont("ArcCWC2_8")
                local tw_1 = surface.GetTextSize(triv.title)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_1, i_2 * (rss * 24))
                surface.DrawText(triv.title)


                surface.SetFont("ArcCWC2_16")
                local tw_3a = select(2, surface.GetTextSize(tostring(triv.value)))

                surface.SetFont("ArcCWC2_8")
                local tw_2 = surface.GetTextSize(triv.unit)
                local tw_2a = select(2, surface.GetTextSize(triv.unit))

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 4.4) + tw_2a)
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(w - tw_2, (i_2 * (rss * 24)) + (rss * 4.4) + tw_2a)
                surface.DrawText(triv.unit)

                surface.SetFont("ArcCWC2_16")
                local tw_3 = surface.GetTextSize(tostring(triv.value))

                surface.SetFont("ArcCWC2_16_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos(math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6))
                surface.DrawText(triv.value)

                surface.SetFont("ArcCWC2_16")
                surface.SetTextColor(col_fg)
                surface.SetTextPos(math.max(w - tw_2 - tw_3, 0), (i_2 * (rss * 24)) + (rss * 6))
                surface.DrawText(triv.value)
            end
        end

        local range_3 = math.max(math.Round(self:GetBuff("Range") / 25) * 25, 50) --self.Range * self:GetBuff_Mult("Mult_Range")
        local range_1 = math.max(math.Round(range_3 / 3 / 25) * 25, 15) --(self.RangeMin or 0) * self:GetBuff_Mult("Mult_RangeMin")

        if range_1 == 0 then
            range_1 = range_3 * 0.5
        end

        rollallhits(self, range_3, range_1)

        local ballisticchart = vgui.Create("DButton", ArcCW.InvHUD_Menu3)
        ballisticchart:SetSize(ss * 200, ss * 110)
        ballisticchart:SetPos(menu3_w - ss * 200 - airgap_x, rss * 48 + ss * 32)
        ballisticchart:SetText("")
        ballisticchart.DoClick = function(self2)
            rollallhits(self, range_3, range_1)
        end
        ballisticchart.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end

            local col = col_button
            if self2:IsHovered() then
                col = col_button_hv
            end

            if self.PrimaryBash then
                draw.RoundedBox(cornerrad, 0, 0, w, h, col)

                local txt = translate("ui.nodata")

                surface.SetTextColor(col_fg)
                surface.SetFont("ArcCWC2_24")
                local tw, th = surface.GetTextSize(txt)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(txt)
                return
            end

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            local s = w / 2
            local s2 = ss * 10

            local range_1_txt = tostring(range_1) .. "m / " .. tostring(math.Round(range_1 / ArcCW.HUToM / 100) * 100) .. "HU"
            local range_3_txt = tostring(range_3) .. "m / " .. tostring(math.Round(range_3 / ArcCW.HUToM / 100) * 100) .. "HU"

            local col_bullseye = Color(200, 200, 200, Lerp(ArcCW.Inv_Fade, 0, 100))

            surface.SetMaterial(bullseye)
            surface.SetDrawColor(col_bullseye)
            surface.DrawTexturedRect(0, 0, s, s)

            local r_1_x, r_1_y = self2:LocalToScreen(0, 0)

            render.SetScissorRect(r_1_x, r_1_y, r_1_x + s, r_1_y + s, true)

            for _, hit in ipairs(hits_1) do
                if self:GetBuff("Num") > 1 then
                    surface.SetMaterial(mat_hit_dot)
                else
                    surface.SetMaterial(mat_hit)
                end
                surface.SetDrawColor(col_fg)
                surface.DrawTexturedRect((s / 2) + (hit.x * s) - (s2 / 2), (s / 2) + (hit.y * s) - (s2 / 2), s2, s2)
            end

            render.SetScissorRect(r_1_x, r_1_y, r_1_x + s, r_1_y + s, false)

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_12")
            local range_1_txtw = surface.GetTextSize(range_1_txt)
            surface.SetTextPos((s - range_1_txtw) / 2, h - (ss * 12) - (ss * 1))
            surface.DrawText(range_1_txt)

            surface.SetMaterial(bullseye)
            surface.SetDrawColor(col_bullseye)
            surface.DrawTexturedRect(s, 0, s, s)

            render.SetScissorRect(r_1_x + s, r_1_y, r_1_x + (s * 2), r_1_y + s, true)

            for _, hit in ipairs(hits_3) do
                if self:GetBuff("Num") > 1 then
                    surface.SetMaterial(mat_hit_dot)
                else
                    surface.SetMaterial(mat_hit)
                end
                surface.SetDrawColor(col_fg)
                surface.DrawTexturedRect(s + (s / 2) + (hit.x * s) - (s2 / 2), (s / 2) + (hit.y * s) - (s2 / 2), s2, s2)
            end

            render.SetScissorRect(r_1_x, r_1_y, r_1_x + s, r_1_y + s, false)

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_12")
            local range_3_txtw = surface.GetTextSize(range_3_txt)
            surface.SetTextPos(s + (s - range_3_txtw) / 2, h - (ss * 12) - (ss * 1))
            surface.DrawText(range_3_txt)
        end

        local penchart = vgui.Create("DPanel", ArcCW.InvHUD_Menu3)
        penchart:SetSize(ss * 200, ss * 60)
        penchart:SetPos(menu3_w - ss * 200 - airgap_x, rss * 48 + ss * 32 + (ss * 115))
        penchart:SetText("")
        penchart.Paint = function(self2, w, h)
            if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end

            local col = col_button

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            local pen = self:GetBuff("Penetration")

            local pm_wood = ArcCW.PenTable[MAT_WOOD]
            local pm_metal = ArcCW.PenTable[MAT_METAL]
            local pm_concrete = ArcCW.PenTable[MAT_CONCRETE]

            local line_s = ss * 1
            local line_h = h - (rss * 8 * 2) - (ss * 2)

            -- wood

            local pen_wood = math.Round(pen / pm_wood, 1)
            local wood_txt = "WOOD"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local wood_txtw = surface.GetTextSize(wood_txt)
            surface.SetTextPos((w * 1 / 6) - (wood_txtw / 2), h - (rss * 8))
            surface.DrawText(wood_txt)

            local wood_txt2 = tostring(pen_wood) .. "HU"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local wood_txt2w = surface.GetTextSize(wood_txt)
            surface.SetTextPos((w * 1 / 6) - (wood_txt2w / 2), h - (rss * 8 * 2))
            surface.DrawText(wood_txt2)

            local wood_width = (math.ceil(pen_wood / 5) * 5)
            wood_width = math.max(wood_width, 5)
            wood_width = math.min(wood_width, 20)

            local wood_s = wood_width * ss

            surface.SetDrawColor(col_fg_tr)
            surface.DrawRect((w * 1 / 6) - (wood_s / 2), ss * 4, wood_s, line_h / 2 - (line_s / 2) - (ss * 4))
            surface.DrawRect((w * 1 / 6) - (wood_s / 2), line_h / 2 + (line_s / 2), wood_s, line_h / 2 - (line_s / 2))
            -- bullet
            surface.DrawRect((w * 1 / 6) - (wood_s / 2) - (w / 6), line_h / 2 - (line_s / 2), w / 6, line_s)

            if pen_wood > wood_width then
                -- penetrated
                surface.DrawRect((w * 1 / 6) + (wood_s / 2), line_h / 2 - (line_s / 2), ss * 4, line_s)
            else
                -- did not penetrate
                local pen_percent = (pen_wood / wood_width)
                surface.DrawRect((w * 1 / 6) - (wood_s / 2) + math.ceil(wood_s * pen_percent), line_h / 2 - (line_s / 2) - 1, wood_s - math.ceil(wood_s * pen_percent), line_s + 1)
            end

            -- metal

            local pen_metal = math.Round(pen / pm_metal, 1)
            local metal_txt = "METAL"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local metal_txtw = surface.GetTextSize(metal_txt)
            surface.SetTextPos((w * 3 / 6) - (metal_txtw / 2), h - (rss * 8))
            surface.DrawText(metal_txt)

            local metal_txt2 = tostring(pen_metal) .. "HU"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local metal_txt2w = surface.GetTextSize(metal_txt)
            surface.SetTextPos((w * 3 / 6) - (metal_txt2w / 2), h - (rss * 8 * 2))
            surface.DrawText(metal_txt2)

            local metal_width = (math.ceil(pen_metal / 5) * 5)
            metal_width = math.max(metal_width, 5)
            metal_width = math.min(metal_width, 20)

            local metal_s = metal_width * ss

            surface.SetDrawColor(col_fg_tr)
            surface.DrawRect((w * 3 / 6) - (metal_s / 2), ss * 4, metal_s, line_h / 2 - (line_s / 2) - (ss * 4))
            surface.DrawRect((w * 3 / 6) - (metal_s / 2), line_h / 2 + (line_s / 2), metal_s, line_h / 2 - (line_s / 2))
            -- bullet
            surface.DrawRect((w * 3 / 6) - (metal_s / 2) - (w / 6), line_h / 2 - (line_s / 2), w / 6, line_s)

            if pen_metal > metal_width then
                -- penetrated
                surface.DrawRect((w * 3 / 6) + (metal_s / 2), line_h / 2 - (line_s / 2), ss * 4, line_s)
            else
                -- did not penetrate
                local pen_percent = (pen_metal / metal_width)
                surface.DrawRect((w * 3 / 6) - (metal_s / 2) + math.ceil(metal_s * pen_percent), line_h / 2 - (line_s / 2) - 1, metal_s - math.ceil(metal_s * pen_percent), line_s + 1)
            end

            -- concrete

            local pen_concrete = math.Round(pen / pm_concrete, 1)
            local concrete_txt = "CONCRETE"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local concrete_txtw = surface.GetTextSize(concrete_txt)
            surface.SetTextPos((w * 5 / 6) - (concrete_txtw / 2), h - (rss * 8))
            surface.DrawText(concrete_txt)

            local concrete_txt2 = tostring(pen_concrete) .. "HU"

            surface.SetTextColor(col_fg)
            surface.SetFont("ArcCWC2_8")
            local concrete_txt2w = surface.GetTextSize(concrete_txt)
            surface.SetTextPos((w * 5 / 6) - (concrete_txt2w / 2), h - (rss * 8 * 2))
            surface.DrawText(concrete_txt2)

            local concrete_width = (math.ceil(pen_concrete / 5) * 5)
            concrete_width = math.max(concrete_width, 5)
            concrete_width = math.min(concrete_width, 20)

            local concrete_s = concrete_width * ss

            surface.SetDrawColor(col_fg_tr)
            surface.DrawRect((w * 5 / 6) - (concrete_s / 2), ss * 4, concrete_s, line_h / 2 - (line_s / 2) - (ss * 4))
            surface.DrawRect((w * 5 / 6) - (concrete_s / 2), line_h / 2 + (line_s / 2), concrete_s, line_h / 2 - (line_s / 2))
            -- bullet
            surface.DrawRect((w * 5 / 6) - (concrete_s / 2) - (w / 6), line_h / 2 - (line_s / 2), w / 6, line_s)

            if pen_concrete > concrete_width then
                -- penetrated
                surface.DrawRect((w * 5 / 6) + (concrete_s / 2), line_h / 2 - (line_s / 2), ss * 4, line_s)
            else
                -- did not penetrate
                local pen_percent = (pen_concrete / concrete_width)
                surface.DrawRect((w * 5 / 6) - (concrete_s / 2) + math.ceil(concrete_s * pen_percent), line_h / 2 - (line_s / 2) - 1, concrete_s - math.ceil(concrete_s * pen_percent), line_s + 1)
            end
        end
    end

    function ArcCW.InvHUD_FormGamemodeFunctions()
        if !IsValid(ArcCW.InvHUD) or !IsValid(self) then return end
        if !ArcCW.ConVars["attinv_gamemodebuttons"]:GetBool() then return end

        local shoulddrawtitle = false
        local function paint_gmbutton(self2, w, h)
            local col = col_button
            local col2 = col_fg

            if self2:IsHovered() then
                col = col_fg_tr
                col2 = col_shadow
            end

            draw.RoundedBox(cornerrad, 0, 0, w, h, col)

            surface.SetFont("ArcCWC2_14")
            local tw, th = surface.GetTextSize(self2.Text)

            surface.SetFont("ArcCWC2_14_Glow")
            surface.SetTextColor(col_shadow)
            surface.SetTextPos((w - tw) / 2, (h - th) / 2)
            surface.DrawText(self2.Text)

            surface.SetFont("ArcCWC2_14")
            surface.SetTextColor(col2)
            surface.SetTextPos((w - tw) / 2, (h - th) / 2)
            surface.DrawText(self2.Text)
        end

        if engine.ActiveGamemode() == "terrortown" then
            shoulddrawtitle = true
            local shop = vgui.Create("DButton", ArcCW.InvHUD)
            shop:SetSize(ss * 64, ss * 24)
            shop:SetPos(ScrW() * 0.5 - ss * (64 + 4), ScrH() - ss * (24 + 10))
            shop:SetText("")
            shop.Text = translate("ui.tttequip")
            shop.DoClick = function(self2, clr, btn)
                RunConsoleCommand("ttt_cl_traitorpopup")
            end
            shop.Paint = paint_gmbutton

            local quickchat = vgui.Create("DButton", ArcCW.InvHUD)
            quickchat:SetSize(ss * 64, ss * 24)
            quickchat:SetPos(ScrW() * 0.5 + ss * 4, ScrH() - ss * (24 + 10))
            quickchat:SetText("")
            quickchat.Text = translate("ui.tttchat")
            quickchat.DoClick = function(self2, clr, btn)
                if RADIO then RADIO:ShowRadioCommands(!RADIO.Show) end
            end
            quickchat.Paint = paint_gmbutton
        elseif engine.ActiveGamemode() == "darkrp" or DarkRP then
            -- Check for the global table, as DarkRP has many derivatives
            shoulddrawtitle = true
            local drop = vgui.Create("DButton", ArcCW.InvHUD)
            drop:SetSize(ss * 96, ss * 24)
            drop:SetPos(ScrW() * 0.5 - ss * 48, ScrH() - ss * (24 + 10))
            drop:SetText("")
            drop.Text = translate("ui.darkrpdrop")
            drop.DoClick = function(self2, clr, btn)
                LocalPlayer():ConCommand("say /drop")
            end
            drop.Paint = paint_gmbutton
        end

        if shoulddrawtitle then
            local text = vgui.Create("DPanel", ArcCW.InvHUD)
            text:SetSize(ss * 256, ss * 12)
            text:SetPos(ScrW() * 0.5 - ss * 128, ScrH() - ss * (24 + 12 + 12))
            text.Paint = function(self2, w, h)
                local col2 = col_fg
                local str = translate("ui.gamemode_buttons")
                surface.SetFont("ArcCWC2_12")
                local tw, th = surface.GetTextSize(str)

                surface.SetFont("ArcCWC2_12_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(str)

                surface.SetFont("ArcCWC2_12")
                surface.SetTextColor(col2)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(str)
            end

            local text2 = vgui.Create("DPanel", ArcCW.InvHUD)
            text2:SetSize(ss * 256, ss * 8)
            text2:SetPos(ScrW() * 0.5 - ss * 128, ScrH() - ss * 9)
            text2.Paint = function(self2, w, h)
                local col2 = col_fg
                local str = translate("ui.gamemode_usehint")
                surface.SetFont("ArcCWC2_8")
                local tw, th = surface.GetTextSize(str)

                surface.SetFont("ArcCWC2_8_Glow")
                surface.SetTextColor(col_shadow)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(str)

                surface.SetFont("ArcCWC2_8")
                surface.SetTextColor(col2)
                surface.SetTextPos((w - tw) / 2, (h - th) / 2)
                surface.DrawText(str)
            end
        end
    end

    clearrightpanel()

    ArcCW.Inv_SelectedMenu = ArcCW.Inv_SelectedMenu or 1

    if ArcCW.Inv_SelectedMenu == 1 then
        ArcCW.InvHUD_FormAttachments()
        if self.Inv_SelectedSlot then
            ArcCW.InvHUD_FormAttachmentSelect()
        end
    elseif ArcCW.Inv_SelectedMenu == 2 then
        ArcCW.InvHUD_FormPresets()
    elseif ArcCW.Inv_SelectedMenu == 3 then
        ArcCW.InvHUD_FormInventory()
    end

    ArcCW.InvHUD_FormGamemodeFunctions()

end

--PATH lua/weapons/arccw_base/cl_laser.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_attach.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_customize.lua:
local translate = ArcCW.GetTranslation

local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

local temp = 0
local SolidBlack = Color(temp, temp, temp)
-- don't fucking mess with the shadow, makes the menu hurt your goddamn eyes

local function DrawTextRot(span, txt, x, y, tx, ty, maxw, only)
    local tw, th = surface.GetTextSize(txt)

    if tw > maxw then
        local realx, realy = span:LocalToScreen(x, y)
        render.SetScissorRect(realx, realy, realx + maxw, realy + (th * 2), true)

        if !only then
            span.TextRot = span.TextRot or 0
            span.StartTextRot = span.StartTextRot or CurTime()
            span.TextRotState = span.TextRotState or 0 -- 0: start, 1: moving, 2: end
            if span.TextRotState == 0 then
                span.TextRot = 0
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 1
                end
            elseif span.TextRotState == 1 then
                span.TextRot = span.TextRot + (FrameTime() * ScreenScaleMulti(16))
                if span.TextRot >= (tw - maxw) + ScreenScaleMulti(8) then
                    span.StartTextRot = CurTime()
                    span.TextRotState = 2
                end
            elseif span.TextRotState == 2 then
                if span.StartTextRot < CurTime() - 2 then
                    span.TextRotState = 0
                    span.StartTextRot = CurTime()
                end
            end
        end
        surface.SetTextPos(tx - span.TextRot, ty)
        surface.DrawText(txt)
        render.SetScissorRect(0, 0, 0, 0, false)
    else
        surface.DrawText(txt)
    end
end


function SWEP:ToggleCustomizeHUD(ic)
    if ic and self:GetState() == ArcCW.STATE_SPRINT then return end
    if self:GetReloading() then ic = false end
    if self:GetState() == ArcCW.STATE_DISABLE then return end

    local noinspect = (CLIENT and ArcCW.ConVars["noinspect"]:GetBool()) or (SERVER and self:GetOwner():GetInfoNum("arccw_noinspect", 0) > 0)

    if ic then
        if (self:GetNextPrimaryFire() + 0.1) >= CurTime() then return end

        self:SetState(ArcCW.STATE_CUSTOMIZE)
        self:ExitSights()
        self:SetShouldHoldType()
        self:ExitBipod()
        if !noinspect then
            self:PlayAnimation(self:SelectAnimation("enter_inspect"), nil, true, nil, nil, true, false)
        end

        if CLIENT then
            self:OpenCustomizeHUD()
        end
    else
        self:SetState(ArcCW.STATE_IDLE)
        self.Sighted = false
        self.Sprinted = false
        self:SetShouldHoldType()

        if !noinspect then
            self:PlayAnimation(self:SelectAnimation("exit_inspect"), nil, true, nil, nil, true, false)
        end

        if CLIENT then
            self:CloseCustomizeHUD()
            self:SendAllDetails()
        end
    end
end

if CLIENT then

local function multlinetext(text, maxw, font)
    local content = {}
    local tline = ""
    local x = 0
    surface.SetFont(font)

    local newlined = string.Split(text, "\n")

    for _, line in pairs(newlined) do
        local words = string.Split(line, " ")

        for _, word in pairs(words) do
            local tx = surface.GetTextSize(word)

            if x + tx >= maxw then
                table.insert(content, tline)
                tline = ""
                x = surface.GetTextSize(word)
            end

            tline = tline .. word .. " "

            x = x + surface.GetTextSize(word .. " ")
        end

        table.insert(content, tline)
        tline = ""
        x = 0
    end

    -- local space_len = surface.GetTextSize(" ")

    -- for _, word in pairs(string.Split(text, " ")) do
    --     if word == "\n" then
    --         table.insert(content, line)
    --         line = ""
    --         x = 0
    --     else
    --         x = x + surface.GetTextSize(word)

    --         if x >= limitx then
    --             table.insert(content, line)
    --             line = ""
    --             x = 0
    --             x = x + surface.GetTextSize(word)
    --         end

    --         line = line .. word .. " "

    --         x = x + space_len

    --         -- print(word .. " at " .. tostring(x))
    --     end
    -- end

    -- table.insert(content, line)

    return content
end

-- Same snippet of code in Paint() moved to its own function so the button won't be added if it's not valid to begin with
function SWEP:ValidateAttachment(attname, attslot, i)
    if !self:IsValid() or !self.Attachments then return false end
    local atttbl = ArcCW.AttachmentTable[attname]
    if !atttbl then return true, nil, nil, nil end

    attslot = attslot or self.Attachments[i]

    local show = true
    local showqty = true
    local installed = false
    local blocked = !self:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags)
    local owned = self:PlayerOwnsAtt(attname)

    if !ArcCW:SlotAcceptsAtt(attslot.Slot or "", self, attname) then
        blocked = true
    end

    if !atttbl or atttbl.Free then
        showqty = false
    end

    if ArcCW.ConVars["attinv_free"]:GetBool() then
        showqty = false
    end

    -- if !owned then
    --     showqty = false
    -- end

    if ArcCW.ConVars["attinv_lockmode"]:GetBool() then
        showqty = false
    end

    -- orighas checks if the original slot accepts this attachment.
    -- If the original slot is ok but the mergeslot that has the same attachment is not, we're still okay
    local orighas = ArcCW:SlotAcceptsAtt(self.Attachments[i], self, attname) and self:CheckFlags(self.Attachments[i].ExcludeFlags, self.Attachments[i].RequireFlags)

    if attslot.Installed == attname then
        installed = true
    end

    if attname == "" and !attslot.Installed then
        installed = true

        for _, slot in pairs(attslot.MergeSlots or {}) do
            if self.Attachments[slot].Installed then
                installed = false
                break
            end
        end
    end

    for _, slot in pairs(attslot.MergeSlots or {}) do
        if !slot then continue end
        if !self.Attachments[slot] then continue end
        if !blocked and ArcCW:SlotAcceptsAtt(self.Attachments[slot], self, attname) and
                !self:CheckFlags(self.Attachments[slot].ExcludeFlags, self.Attachments[slot].RequireFlags) and
                !orighas then
            blocked = true
            if self.Attachments[slot].HideIfBlocked then
                show = false
            end
            break
        end
        if self.Attachments[slot].Installed == attname then
            installed = true
            break
        end
    end

    if blocked and atttbl and atttbl.HideIfBlocked then
        show = false
    end

    if !owned and atttbl and atttbl.HideIfUnavailable then
        show = false
    end

    if !owned and ArcCW.ConVars["attinv_hideunowned"]:GetBool() then
        show = false
    end

    return show, installed, blocked, showqty
end

function SWEP:OpenCustomizeHUD()
    if self:GetPriorityAnim() then return end
    if IsValid(ArcCW.InvHUD) then
        ArcCW.InvHUD:Show()
        -- ArcCW.InvHUD:RequestFocus()
    else
        --if GetConVar("arccw_dev_cust2beta"):GetBool() then self:CreateCustomize2HUD() else self:CreateCustomizeHUD() end
        self:CreateCustomize2HUD()
        gui.SetMousePos(ScrW() / 2, ScrH() / 2)
    end

    ArcCW.Inv_Hidden = false
    gui.EnableScreenClicker(true)

    if ArcCW.ConVars["cust_sounds"]:GetBool() then surface.PlaySound("weapons/arccw/extra.wav") end

end

function SWEP:CloseCustomizeHUD( hide )
    if IsValid(ArcCW.InvHUD) then
        --if !GetConVar("arccw_dev_cust2beta"):GetBool() then
        if false then
            ArcCW.InvHUD:Hide()
            ArcCW.InvHUD:Clear()
            if vrmod and vrmod.MenuExists( "ArcCW_Customize" ) then
                vrmod.MenuClose( "ArcCW_Customize" )
            end
            if !hide then
                ArcCW.InvHUD:Remove()
            end
        else
            -- The new hud fades out instead of commiting sudoku, only do this if we're debugging
            if ArcCW.ConVars["dev_removeonclose"]:GetBool() then
                ArcCW.InvHUD:Remove()
            end
        end

        if !hide then
            gui.EnableScreenClicker(false)
        end
        ArcCW.Inv_Hidden = false

        if ArcCW.ConVars["cust_sounds"]:GetBool() then surface.PlaySound("weapons/arccw/extra2.wav") end
    end
end

local defaultatticon = Material("arccw/hud/atts/default.png", "smooth mips")
local blockedatticon = Material("arccw/hud/atts/blocked.png", "smooth mips")
local activeslot = nil
local bird = Material("arccw/hud/arccw_bird.png", "mips smooth")

SWEP.InAttMenu = false

function SWEP:CreateCustomizeHUD()
    local barsize = ScreenScaleMulti(160)
    local airgap = ScreenScaleMulti(16)
    local smallgap = ScreenScaleMulti(2)
    local linesize = ScreenScaleMulti(1)
    local buttonsize = ScreenScaleMulti(32)
    local fg_col = Color(255, 255, 255, 255)
    local bg_col = Color(0, 0, 0, 150)

    if !self:IsValid() then return end

    self.InAttMenu = false
    activeslot = nil

    local scrw, scrh = ScrW(), ScrH()
    if vrmod and vrmod.IsPlayerInVR(self:GetOwner()) then
        -- Other resolutions seem to cause stretching issues
        scrw = 1366
        scrh = 768
    end

    ArcCW.InvHUD = vgui.Create("DFrame")

            local scrwmult = ArcCW.ConVars["hud_deadzone_x"]:GetFloat() * ScrW()
            local scrhmult = ArcCW.ConVars["hud_deadzone_y"]:GetFloat() * ScrH()

    scrw, scrh = scrw - scrwmult, scrh - scrhmult

    ArcCW.InvHUD:SetPos(0, 0)
    ArcCW.InvHUD:SetSize(scrw, scrh)
    ArcCW.InvHUD:Center()
    ArcCW.InvHUD:SetText("")
    ArcCW.InvHUD:SetTitle("")
    ArcCW.InvHUD.Paint = function(span)
        if !IsValid(self) then
            gui.EnableScreenClicker(false)
            span:Remove()
        end

        if --[[self:GetState() != ArcCW.STATE_CUSTOMIZE or]] self:GetReloading() then
            span:Remove()
        end
    end
    ArcCW.InvHUD.ActiveWeapon = self
    ArcCW.InvHUD.OnRemove = function()
        local close = false
        if self:IsValid() and self:GetState() == ArcCW.STATE_CUSTOMIZE then
            close = true
        end

        if LocalPlayer():GetActiveWeapon() != ArcCW.InvHUD.ActiveWeapon then
            close = true
        end

        if close then
            net.Start("arccw_togglecustomize")
            net.WriteBool(false)
            net.SendToServer()

            if IsValid(self) and self.ToggleCustomizeHUD then
                self:ToggleCustomizeHUD(false)
            end
        end

        gui.EnableScreenClicker(false)
    end

    if ArcCW.ConVars["attinv_onlyinspect"]:GetBool() then
        return
    end

    local loadpresets = vgui.Create("DButton", ArcCW.InvHUD)
    loadpresets:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
    loadpresets:SetText("")
    loadpresets:SetPos(scrw - barsize - airgap, airgap)

    loadpresets.OnMousePressed = function(spaa, kc)
        self:CreatePresetMenu()
    end

    loadpresets.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (translate("ui.loadpreset"))

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local savepresets = vgui.Create("DButton", ArcCW.InvHUD)
    savepresets:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
    savepresets:SetText("")
    savepresets:SetPos(scrw - (barsize / 2) + ScreenScaleMulti(1) - airgap, airgap)

    savepresets.OnMousePressed = function(spaa, kc)
        self:CreatePresetSave()
    end

    savepresets.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (translate("ui.savepreset"))

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local attcatsy = scrh - ScreenScaleMulti(64) - airgap

    local attcats = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    attcats:SetText("")
    attcats:SetSize(barsize, attcatsy)
    attcats:SetPos(airgap, airgap)
    attcats.Paint = function(span, w, h)
        -- surface.SetDrawColor(bg_col)
        -- surface.DrawRect(0, 0, w, h)
    end

    local triviabox = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    triviabox:SetText("")
    triviabox:SetSize(barsize, scrh - ScreenScaleMulti(64) - (3 * airgap))
    triviabox:SetPos(scrw - barsize - airgap, 2 * airgap)
    triviabox.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local sbar = attcats:GetVBar()
    sbar.Paint = function() end

    sbar.btnUp.Paint = function(span, w, h)
    end

    sbar.btnDown.Paint = function(span, w, h)
    end

    sbar.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local wpninfo = attcats:Add("DLabel")
    wpninfo:SetSize(barsize, buttonsize)
    wpninfo:SetText("")
    wpninfo:Dock( TOP )
    wpninfo:DockMargin( 0, 0, 0, smallgap )

    wpninfo.Paint = function(span, w, h)
        if !IsValid(self) then return end
        local Bfg_col = fg_col
        local Bbg_col = bg_col

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)
        surface.DrawRect(0, 0, w, h / 2)

        surface.SetDrawColor(Bfg_col)
        surface.DrawRect(0, (h - linesize) / 2, w, linesize)

        surface.SetTextColor(SolidBlack)
        surface.SetTextPos(smallgap, 0)
        surface.SetFont("ArcCW_12_Glow")
        surface.DrawText(translate("name." .. self:GetClass() .. (ArcCW.ConVars["truenames"]:GetBool() and ".true" or "")) or self.PrintName)

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, 0)
        surface.SetFont("ArcCW_12")
        surface.DrawText(translate("name." .. self:GetClass() .. (ArcCW.ConVars["truenames"]:GetBool() and ".true" or "")) or self.PrintName)

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap * 2, (h - linesize) / 2 + smallgap)
        surface.SetFont("ArcCW_12")

        local pick = self:GetPickX()

        if pick <= 0 then
            surface.DrawText(ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Class") or self.Trivia_Class))
        else
            local txt = self:CountAttachments() .. "/" .. pick .. " Attachments"

            surface.DrawText(txt)
        end
    end

    local statbox = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    statbox:SetText("")
    statbox:SetSize(barsize, scrh - ScreenScaleMulti(64) - (3 * airgap))
    statbox:SetPos(scrw - barsize - airgap, 2 * airgap)
    statbox.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)
    end
    statbox:Hide()
    local regenStatList -- early definition so category unequiping can update

    local sbar3 = statbox:GetVBar()
    sbar3.Paint = function() end

    sbar3.btnUp.Paint = function(span, w, h)
    end

    sbar3.btnDown.Paint = function(span, w, h)
    end

    sbar3.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local attmenuh = scrh - (2 * airgap)

    local attmenu = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    attmenu:SetText("")
    attmenu:SetSize(barsize + ScreenScaleMulti(12), attmenuh)
    attmenu:SetPos(airgap + barsize + smallgap, airgap)
    attmenu.Paint = function(span, w, h)
        -- surface.SetDrawColor(bg_col)
        -- surface.DrawRect(0, 0, w, h)
    end
    attmenu:Hide()

    local sbar4 = attmenu:GetVBar()
    sbar4.Paint = function() end

    sbar4.btnUp.Paint = function(span, w, h)
    end

    sbar4.btnDown.Paint = function(span, w, h)
    end

    sbar4.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local attslidebox = vgui.Create("DPanel", ArcCW.InvHUD)
    attslidebox:SetSize(barsize, ScreenScaleMulti(20))
    attslidebox:SetPos(scrw - barsize - airgap, scrh - ScreenScaleMulti(64) - (1 * airgap))
    attslidebox.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)

        surface.SetTextColor(fg_col)
        surface.SetFont("ArcCW_6")
        surface.SetTextPos(smallgap, smallgap)
        surface.DrawText(translate("ui.position"))
    end

    local attslider = vgui.Create("DSlider", attslidebox)
    attslider:SetPos(ScreenScaleMulti(4), ScreenScaleMulti(12))
    attslider:SetSize(barsize - ScreenScaleMulti(4 * 2), ScreenScaleMulti(4))

    attslider.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, h / 2, w, ScreenScaleMulti(1))
    end

    local lastslidepos = 0
    local lastsoundtime = 0

    attslider.Knob.Paint = function(span, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end

        if span:IsHovered() or attslider:GetDragging() then
            surface.SetDrawColor(fg_col)
            surface.DrawRect((w - ScreenScaleMulti(2)) / 2, 0, ScreenScaleMulti(2), h)
        else
            surface.SetDrawColor(fg_col)
            surface.DrawRect((w - ScreenScaleMulti(1)) / 2, 0, ScreenScaleMulti(1), h)
        end

        if attslider:GetDragging() and activeslot then
            local delta = attslider:GetSlideX()
            if lastslidepos != delta and lastsoundtime <= CurTime() then

                EmitSound("weapons/arccw/dragatt.wav", EyePos(), -2, CHAN_ITEM, 1,75, 0, math.Clamp(delta * 200, 90, 110))

                lastsoundtime = CurTime() + 0.05
            end

            self.Attachments[activeslot].SlidePos = delta
            lastslidepos = delta
        end

        attslider:SetSlideX((self.Attachments[activeslot] or {}).SlidePos or 0.5)
    end

    local og_attsliderknobmr = attslider.Knob.OnMouseReleased

    attslider.Knob.OnMouseReleased = function(span, kc)
        og_attsliderknobmr(span, kc)
        self:SendDetail_SlidePos(activeslot)
        self:SavePreset("autosave")
    end

    attslidebox:Hide()

    local atttogglebtn = vgui.Create("DButton", ArcCW.InvHUD)
    atttogglebtn:SetSize(barsize * 0.25, ScreenScaleMulti(15))
    atttogglebtn:SetPos(scrw - barsize - airgap + barsize * 0.75, scrh - ScreenScaleMulti(64) - (1 * airgap))
    atttogglebtn:SetText("")
    atttogglebtn.OnMousePressed = function(spaa, kc)
        if !self.Attachments[activeslot] then return end
        local catttbl = ArcCW.AttachmentTable[self.Attachments[activeslot].Installed]
        if !catttbl or !catttbl.ToggleStats then return end

        self:ToggleSlot(activeslot)
        --[[]
        self.Attachments[activeslot].ToggleNum = (self.Attachments[activeslot].ToggleNum or 1) + 1
        if self.Attachments[activeslot].ToggleNum > #catttbl.ToggleStats then
            self.Attachments[activeslot].ToggleNum = 1
        end
        self:SendDetail_ToggleNum(activeslot)
        self:AdjustAtts()
        if self:GetHasFlashlights() then
            self:CreateFlashlightsVM()
        end

        EmitSound("weapons/arccw/firemode.wav", EyePos(), -2, CHAN_ITEM, 1,75, 0, 100)
        ]]
    end
    atttogglebtn.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        if !self.Attachments then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (translate("ui.toggle"))
        local catttbl = activeslot and ArcCW.AttachmentTable[self.Attachments[activeslot].Installed]
        if catttbl and catttbl.ToggleStats[self.Attachments[activeslot].ToggleNum]
                and catttbl.ToggleStats[self.Attachments[activeslot].ToggleNum].PrintName then
            txt = ArcCW.TryTranslation(catttbl.ToggleStats[self.Attachments[activeslot].ToggleNum].PrintName)
        end

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(smallgap, ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    atttogglebtn:Hide()

    local atttrivia = vgui.Create("DScrollPanel", ArcCW.InvHUD)
    atttrivia:SetSize(barsize, scrh - ScreenScaleMulti(116))
    atttrivia:SetPos(scrw - barsize - airgap, 2 * airgap)
    atttrivia.Paint = function(span, w, h)
        surface.SetDrawColor(bg_col)
        surface.DrawRect(0, 0, w, h)
    end
    atttrivia:Hide()

    local sbar5 = atttrivia:GetVBar()
    sbar5.Paint = function() end

    sbar5.btnUp.Paint = function(span, w, h)
    end

    sbar5.btnDown.Paint = function(span, w, h)
    end

    sbar5.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local last_atttrivia = nil

    local function atttrivia_do(att, slot)

        if !att then
            last_atttrivia = att
            atttrivia:Hide()
            atttrivia:Clear()
            return
        end

        if att == "" then
            last_atttrivia = att
            atttrivia:Hide()
            atttrivia:Clear()
            return
        end

        if att == last_atttrivia then
            last_atttrivia = att
            return
        end

        atttrivia:Clear()

        last_atttrivia = att

        local atttbl = ArcCW.AttachmentTable[att]

        atttrivia:Show()

        -- att name

        local triv_attname = vgui.Create("DLabel", atttrivia)
            triv_attname:SetSize(barsize, ScreenScaleMulti(16))
            triv_attname:Dock(TOP)
            triv_attname:DockMargin( 0, 0, 0, 0 )
            triv_attname:SetText("")
            triv_attname.Paint = function(span, w, h)
                local txt = multlinetext(translate("name." .. att) or atttbl.PrintName, w, "ArcCW_16")

                c = 0

                for _, i in pairs(txt) do
                    surface.SetFont("ArcCW_16")
                    local tw = surface.GetTextSize(i)

                    surface.SetFont("ArcCW_16_Glow")
                    surface.SetTextPos((smallgap + (w - tw)) / 2, c)
                    surface.SetTextColor(SolidBlack)
                    surface.DrawText(i)

                    surface.SetFont("ArcCW_16")
                    surface.SetTextPos((smallgap + (w - tw)) / 2, c)
                    surface.SetTextColor(fg_col)
                    surface.DrawText(i)

                    c = c + ScreenScaleMulti(16)
                end

                span:SetSize(barsize, c)
            end

        -- att pic

        local triv_pic = vgui.Create("DLabel", atttrivia)
            triv_pic:SetSize(barsize, barsize / 2)
            triv_pic:Dock(TOP)
            triv_pic:DockMargin( 0, 0, 0, smallgap )
            triv_pic:SetText("")
            triv_pic.Paint = function(span, w, h)
                local img = atttbl.Icon or defaultatticon
                if !img or img:IsError() then img = bird end

                surface.SetDrawColor(fg_col)
                surface.SetMaterial(img)
                surface.DrawTexturedRect(h / 2, 0, h, h)
            end

        -- att desc

        desctext = multlinetext(translate("desc." .. att) or atttbl.Description, barsize - smallgap * 2, "ArcCW_8")

        local triv_desc = vgui.Create("DLabel", atttrivia)
        triv_desc:SetSize(barsize, ScreenScaleMulti(8) * (table.Count(desctext) + 1))
        triv_desc:SetText("")
        triv_desc:DockMargin( 0, 0, 0, smallgap )
        triv_desc:Dock(TOP)
        triv_desc.Paint = function(span, w, h)
            local y = ScreenScaleMulti(8)
            for i, line in pairs(desctext) do
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap * 2, y)
                surface.SetTextColor(fg_col)
                surface.DrawText(line)
                y = y + ScreenScaleMulti(8)
            end
        end

        local neutrals = atttbl.Desc_Neutrals or {}

        local pros, cons = ArcCW:GetProsCons(self, atttbl, self.Attachments[slot].ToggleNum)

        if (pros and #pros or 0) > 0 then

            local triv_pros = vgui.Create("DLabel", atttrivia)
            triv_pros:SetSize(barsize, ScreenScaleMulti(10))
            triv_pros:SetText("")
            triv_pros:Dock(TOP)
            triv_pros.Paint = function(span, w, h)
                surface.SetDrawColor(Color(0, 50, 0, 100))
                surface.DrawRect(0, 0, w, h)

                surface.SetTextColor(Color(125, 200, 125))
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.DrawText(translate("ui.positives"))
            end

            for _, i in pairs(pros) do
                local triv_pro = vgui.Create("DLabel", atttrivia)
                triv_pro:SetSize(barsize, ScreenScaleMulti(10))
                triv_pro:SetText("")
                triv_pro:Dock(TOP)
                triv_pro.Paint = function(span, w, h)

                    surface.SetTextColor(Color(150, 225, 150))
                    surface.SetFont("ArcCW_8")
                    surface.SetTextPos(smallgap, 0)
                    surface.DrawText(i)
                end
            end
        end

        if (cons and #cons or 0) > 0 then
            local triv_cons = vgui.Create("DLabel", atttrivia)
            triv_cons:SetSize(barsize, ScreenScaleMulti(10))
            triv_cons:SetText("")
            triv_cons:Dock(TOP)
            triv_cons.Paint = function(span, w, h)
                surface.SetDrawColor(Color(50, 0, 0, 100))
                surface.DrawRect(0, 0, w, h)

                surface.SetTextColor(Color(200, 125, 125))
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.DrawText(translate("ui.negatives"))
            end

            for _, i in pairs(cons) do
                local triv_con = vgui.Create("DLabel", atttrivia)
                triv_con:SetSize(barsize, ScreenScaleMulti(10))
                triv_con:SetText("")
                triv_con:Dock(TOP)
                triv_con.Paint = function(span, w, h)

                    surface.SetTextColor(Color(225, 150, 150))
                    surface.SetFont("ArcCW_8")
                    surface.SetTextPos(smallgap, 0)
                    surface.DrawText(i)
                end
            end
        end

        if #neutrals > 0 then

            local triv_neutrals = vgui.Create("DLabel", atttrivia)
            triv_neutrals:SetSize(barsize, ScreenScaleMulti(10))
            triv_neutrals:SetText("")
            triv_neutrals:Dock(TOP)
            triv_neutrals.Paint = function(span, w, h)
                surface.SetDrawColor(Color(0, 0, 50, 100))
                surface.DrawRect(0, 0, w, h)

                surface.SetTextColor(Color(125, 125, 200))
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.DrawText(translate("ui.information"))
            end

            for _, i in pairs(neutrals) do
                local triv_neutral = vgui.Create("DLabel", atttrivia)
                triv_neutral:SetSize(barsize, ScreenScaleMulti(10))
                triv_neutral:SetText("")
                triv_neutral:Dock(TOP)
                triv_neutral.Paint = function(span, w, h)

                    surface.SetTextColor(Color(150, 150, 225))
                    surface.SetFont("ArcCW_8")
                    surface.SetTextPos(smallgap, 0)
                    surface.DrawText(ArcCW.TryTranslation(i))
                end
            end
        end
    end

    ArcCW.InvHUD.OnMousePressed = function(span, kc)
        if (kc == MOUSE_LEFT or kc == MOUSE_RIGHT) and
                !triviabox:IsVisible() and !statbox:IsVisible() then
            activeslot = nil
            triviabox:Show()
            statbox:Hide()
            attmenu:Hide()
            self.InAttMenu = false
            atttrivia:Hide()
            attslidebox:Hide()
            atttogglebtn:Hide()
            if ArcCW.ConVars["cust_sounds"]:GetBool() then surface.PlaySound("weapons/arccw/close.wav") end
        end
    end

    for i, k in pairs(self.Attachments) do
        if !k.PrintName then continue end
        if i == "BaseClass" then continue end
        if k.Hidden or k.Blacklisted then continue end
        if k.Integral then continue end

        local attcatb = attcats:Add("DButton")
        if ArcCW.ConVars["hud_embracetradition"]:GetBool() then
            attcatb:SetSize(barsize, buttonsize )
        else
            attcatb:SetSize(barsize, buttonsize / 2)
        end
        attcatb:SetText("")
        attcatb:Dock( TOP )
        attcatb:DockMargin( 0, 0, 0, smallgap )

        attcatb.AttIndex = i
        attcatb.AttSlot = k

        local function attcatb_regen(span)
            local catt = self.Attachments[span.AttIndex].Installed
            local catttbl
            if catt then
                catttbl = ArcCW.AttachmentTable[catt]
            end

            if self.Attachments[span.AttIndex].Installed and self.Attachments[span.AttIndex].SlideAmount and !catttbl.MountPositionOverride then
                attslidebox:Show()
            else
                attslidebox:Hide()
            end

            if self.Attachments[span.AttIndex].Installed and catttbl and catttbl.ToggleStats then
                if attslidebox:IsVisible() then
                    atttogglebtn:SetPos(scrw - barsize - airgap + barsize * 0.75, scrh - ScreenScaleMulti(40) - (1 * airgap))
                else
                    atttogglebtn:SetPos(scrw - barsize - airgap + barsize * 0.75, scrh - ScreenScaleMulti(64) - (1 * airgap))
                end
                atttogglebtn:Show()
            else
                atttogglebtn:Hide()
            end

            attmenu:Clear()

            local atts = {}
            local slots = {i}
            local attCheck = {}

            table.Add(slots, k.MergeSlots or {})

            for _, y in pairs(slots) do
                for _, bruh in pairs(ArcCW:GetAttsForSlot((self.Attachments[y] or {}).Slot, self)) do
                    if attCheck[bruh] then continue end
                    table.insert(atts, {
                        att = bruh,
                        slot = y
                    })
                    attCheck[bruh] = true
                end
            end

            atts[0] = ""

            table.sort(atts, function(a, b)
                a = a.att or ""
                b = b.att or ""
                local atttbl_a = ArcCW.AttachmentTable[a]
                local atttbl_b = ArcCW.AttachmentTable[b]

                local order_a = 0
                local order_b = 0

                order_a = atttbl_a.SortOrder or order_a
                order_b = atttbl_b.SortOrder or order_b

                if order_a == order_b then
                    return (translate("name." .. a) or atttbl_a.PrintName or "") > (translate("name." .. b) or atttbl_b.PrintName or "")
                end

                return order_a > order_b
            end)

            local ca = 0

            for _, att in pairs(atts) do
                local aslot = att
                if istable(att) then
                    aslot = aslot.slot
                    att = att.att
                end
                local owned = self:PlayerOwnsAtt(att)

                if !owned and ArcCW.ConVars["attinv_hideunowned"]:GetBool() then continue end

                local valid, installed, blocked, showqty = self:ValidateAttachment(att, k, i)

                if !valid then continue end

                local attbtn = attmenu:Add("DButton")
                attbtn:SetSize(barsize + ScreenScaleMulti(12), ScreenScaleMulti(14))
                attbtn:SetText("")
                attbtn:Dock( TOP )
                attbtn:DockMargin( 0, 0, 0, smallgap )

                ca = ca + 1

                attbtn.AttName = att

                attbtn.OnMousePressed = function(spaa, kc2)

                    owned = self:PlayerOwnsAtt(spaa.AttName)
                    local installed = false
                    local orighas = ArcCW:SlotAcceptsAtt(self.Attachments[i], self, spaa.AttName) and self:CheckFlags(self.Attachments[i].ExcludeFlags, self.Attachments[i].RequireFlags)

                    local atttbl = ArcCW.AttachmentTable[spaa.AttName]
                    if atttbl then
                        if !self:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags) then return end
                        for _, slot in pairs(k.MergeSlots or {}) do
                            if self.Attachments[slot].Installed then
                                installed = true
                            end

                            if slot and self.Attachments[slot] and
                                    ArcCW:SlotAcceptsAtt(self.Attachments[slot], self, spaa.AttName) and
                                    !self:CheckFlags(self.Attachments[slot].ExcludeFlags, self.Attachments[slot].RequireFlags) and
                                    !orighas then
                                return
                            end
                        end
                    end

                    if kc2 == MOUSE_LEFT and owned then

                        if spaa.AttName == "" then
                            self:DetachAllMergeSlots(span.AttIndex)
                        else
                            self:DetachAllMergeSlots(span.AttIndex, true)
                            self:Attach(aslot, spaa.AttName)
                        end
                    elseif kc2 == MOUSE_RIGHT and spaa.AttName != "" then
                        if span.AttSlot.Installed == spaa.AttName then
                            -- Unequip
                            self:DetachAllMergeSlots(span.AttIndex)
                        elseif installed then
                            self:DetachAllMergeSlots(span.AttIndex)
                        elseif owned then
                            -- Drop attachment
                            if ArcCW.ConVars["attinv_free"]:GetBool() then return end
                            if ArcCW.ConVars["attinv_lockmode"]:GetBool() then return end
                            if ArcCW.ConVars["enable_customization"]:GetInt() < 0 then return end
                            if !ArcCW.ConVars["enable_dropping"]:GetBool() then return end

                            net.Start("arccw_asktodrop")
                                net.WriteUInt(ArcCW.AttachmentTable[spaa.AttName].ID, 24)
                            net.SendToServer()

                            ArcCW:PlayerTakeAtt(self:GetOwner(), spaa.AttName)
                        end
                    end

                    attcatb_regen(span)
                end

                attbtn.Paint = function(spaa, w, h)
                    if !self:IsValid() then return end
                    if !self.Attachments then return end
                    local Bfg_col = Color(255, 255, 255, 255)
                    local Bbg_col = Color(0, 0, 0, 100)
                    local atttbl = ArcCW.AttachmentTable[spaa.AttName]
                    local qty = ArcCW:PlayerGetAtts(self:GetOwner(), spaa.AttName)

                    valid, installed, blocked, showqty = self:ValidateAttachment(att, k, i)
                    if !valid then
                        attbtn:Remove()
                        return
                    end

                    owned = self:PlayerOwnsAtt(spaa.AttName)

                    if !atttbl and ArcCW.AttachmentTable[k.EmptyFallback] then
                        atttbl = ArcCW.AttachmentTable[k.EmptyFallback]
                    elseif !atttbl then
                        atttbl = {
                            PrintName = k.DefaultAttName and ArcCW.TryTranslation(k.DefaultAttName) or translate("attslot.noatt"),
                            Icon = k.DefaultAttIcon or defaultatticon,
                            Free = true
                        }
                    end

                    if spaa:IsHovered() or installed then
                        Bbg_col = Color(255, 255, 255, 100)
                        Bfg_col = Color(0, 0, 0, 255)
                    end

                    if spaa:IsHovered() and installed then
                        Bbg_col = Color(255, 255, 255, 200)
                        Bfg_col = Color(0, 0, 0, 255)
                    end

                    if spaa:IsHovered() then
                        atttrivia_do(spaa.AttName, i)
                    end

                    if !owned and ArcCW.ConVars["attinv_darkunowned"]:GetBool() then
                        if spaa:IsHovered() then
                            Bbg_col = Color(50, 50, 50, 150)
                            Bfg_col = Color(150, 150, 150, 255)
                        else
                            Bbg_col = Color(20, 20, 20, 150)
                            Bfg_col = Color(150, 150, 150, 255)
                        end
                    elseif !owned or blocked then
                        if spaa:IsHovered() then
                            Bbg_col = Color(125, 25, 25, 150)
                            Bfg_col = Color(150, 50, 50, 255)
                        else
                            Bbg_col = Color(75, 0, 0, 150)
                            Bfg_col = Color(150, 50, 50, 255)
                        end
                    end

                    local max = atttbl.Max

                    if max then
                        local amt = 0

                        for i2, k2 in pairs(self.Attachments) do
                            if k2.Installed == spaa.AttName then
                                amt = amt + 1
                            end
                        end

                        if amt >= max and self.Attachments[i].Installed != spaa.AttName then
                            if spaa:IsHovered() then
                                Bbg_col = Color(125, 25, 25, 150)
                                Bfg_col = Color(150, 50, 50, 255)
                            else
                                Bbg_col = Color(75, 0, 0, 150)
                                Bfg_col = Color(150, 50, 50, 255)
                            end
                        end
                    end

                    surface.SetDrawColor(Bbg_col)
                    surface.DrawRect(0, 0, w, h)
                    surface.DrawRect(0, 0, h * 1.5, h)

                    surface.SetDrawColor(Bfg_col)
                    surface.DrawRect((h * 1.5) - (linesize / 2), 0, linesize, h)

                    local txt = translate("name." .. spaa.AttName) or atttbl.PrintName or "???"

                    if showqty then
                        txt = txt .. " (" .. tostring(qty) .. ")"
                    end

                    surface.SetTextColor(Bfg_col)
                    surface.SetTextPos((h * 1.5) + smallgap, ScreenScaleMulti(1))
                    surface.SetFont("ArcCW_12")

                    DrawTextRot(spaa, txt, h * 1.5, 0, (h * 1.5) + smallgap, ScreenScaleMulti(1), w - (h * 1.5))

                    -- surface.DrawText(txt)

                    local icon = k.DefaultAttIcon or defaultatticon
                    if atttbl then
                        icon = atttbl.Icon
                    end
                    if (!icon or icon:IsError()) then icon = bird end

                    surface.SetDrawColor(Bfg_col)
                    surface.SetMaterial(icon)
                    surface.DrawTexturedRect(h / 4, 0, h, h)

                    if blocked then
                        surface.SetDrawColor(color_white)
                        surface.SetMaterial(blockedatticon)
                        surface.DrawTexturedRect(h / 4 - h * 0.1, - h * 0.1, h * 1.2, h * 1.2)
                    end
                end
            end

            local specsize = ca * (ScreenScaleMulti(14) + smallgap)

            attmenu:SetSize(barsize + ScreenScaleMulti(12), math.min(specsize, attmenuh))
        end

        attcatb.OnMousePressed = function(span, kc)
            if !self:CheckFlags(span.AttSlot.ExcludeFlags, span.AttSlot.RequireFlags) then
                return
            end

            if kc == MOUSE_LEFT then
                if activeslot == span.AttIndex then
                    activeslot = nil
                    triviabox:Show()
                    statbox:Hide()
                    attmenu:Hide()
                    self.InAttMenu = false
                    atttrivia:Hide()
                    attslidebox:Hide()
                    atttogglebtn:Hide()
                    surface.PlaySound("weapons/arccw/close.wav")
                else
                    activeslot = span.AttIndex
                    triviabox:Hide()
                    statbox:Hide()
                    attmenu:Show()
                    attslider:SetSlideX(self.Attachments[span.AttIndex].SlidePos)
                    lastslidepos = self.Attachments[span.AttIndex].SlidePos
                    self.InAttMenu = true
                    surface.PlaySound("weapons/arccw/open.wav")

                    span.TextRot = 0
                    span.StartTextRot = CurTime()
                    span.TextRotState = 0

                    if self.Attachments[span.AttIndex].Installed then
                        atttrivia_do(self.Attachments[span.AttIndex].Installed, span.AttIndex)
                    end

                    attcatb_regen(span)
                end
            elseif kc == MOUSE_RIGHT then
                self:DetachAllMergeSlots(span.AttIndex)
                attcatb_regen(span)
                if statbox:IsVisible() then
                    regenStatList()
                end
            end
        end

        attcatb.Paint = function(span, w, h)

            -- Might error when player dies
            if !self or !self.Attachments then return end

            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if span:IsHovered() or activeslot == span.AttIndex then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            if span:IsHovered() and activeslot == span.AttIndex then
                Bbg_col = Color(255, 255, 255, 200)
                Bfg_col = Color(0, 0, 0, 255)
            end

            if self.CheckFlags and !self:CheckFlags(span.AttSlot.ExcludeFlags, span.AttSlot.RequireFlags) then
                Bbg_col = Color(75, 0, 0, 150)
                Bfg_col = Color(150, 50, 50, 255)
            end

            local txt =  ArcCW.TryTranslation(k.PrintName)

            local att_txt = k.DefaultAttName and ArcCW.TryTranslation(k.DefaultAttName) or translate("attslot.noatt")
            local att_icon = k.DefaultAttIcon or defaultatticon

            local installed = k.Installed

            if !installed then
                (k.MergeSlots or {})["BaseClass"] = nil
                for _, slot in pairs(k.MergeSlots or {}) do
                    if self.Attachments[slot] and self.Attachments[slot].Installed then
                        installed = self.Attachments[slot].Installed
                        break
                    elseif !self.Attachments[slot] then
                        print("ERROR! No attachment " .. tostring(slot))
                    end
                end
            end

            if installed then
                local atttbl = ArcCW.AttachmentTable[installed]

                if atttbl.Health then
                    local perc = (self:GetAttachmentHP(i) / self:GetAttachmentMaxHP(i)) * 100
                    perc = math.Round(perc)
                    txt = txt .. " (" .. tostring(perc) .. "%)"
                end
                if !ArcCW.ConVars["hud_embracetradition"]:GetBool() then
                    att_txt = translate("name." .. installed) or atttbl.PrintName

                    if atttbl.Icon then
                        att_icon = atttbl.Icon
                        if (!att_icon or att_icon:IsError()) then att_icon = bird end
                    end
                end
            end

            if ArcCW.ConVars["hud_embracetradition"]:GetBool() then
                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(0, 0, w, h / 2)
                surface.DrawRect(w - (1.5 * h), h / 2, 1.5 * h, h / 2)

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(0, 0, w, h / 2)
                surface.DrawRect(w - (1.5 * h), h / 2, 1.5 * h, h / 2)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(0, (h - linesize) / 2, w - (1.5 * h), linesize)

                surface.SetTextColor(SolidBlack)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12_Glow")
                surface.DrawText(txt)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12")
                surface.DrawText(txt)

                if installed then
                    local atttbl = ArcCW.AttachmentTable[installed]

                    att_txt = translate("name." .. installed) or atttbl.PrintName

                    if atttbl.Icon then
                        att_icon = atttbl.Icon
                        if (!att_icon or att_icon:IsError()) then att_icon = bird end
                    end
                end

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap * 2, (h - linesize) / 2 + smallgap)
                surface.SetFont("ArcCW_12")
                DrawTextRot(span, att_txt, 0, h / 2, smallgap * 2, (h - linesize) / 2 + smallgap, w - 1.5 * h)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(w - (1.5 * h), 0, linesize, h)

                surface.SetDrawColor(Bfg_col)
                surface.SetMaterial(att_icon)
                surface.DrawTexturedRect(w - (1.25 * h), 0, h, h)
            ----------------------------------------------------------------------
            elseif activeslot == span.AttIndex then
                span:SetSize(barsize, buttonsize)

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(0, 0, w, h / 2)
                surface.DrawRect(w - (1.5 * h), h / 2, 1.5 * h, h / 2)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(0, (h - linesize) / 2, w - (1.5 * h), linesize)

                surface.SetTextColor(SolidBlack)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12_Glow")
                surface.DrawText(txt)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12")
                surface.DrawText(txt)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap * 2, (h - linesize) / 2 + smallgap)
                surface.SetFont("ArcCW_12")

                DrawTextRot(span, att_txt, 0, h / 2, smallgap * 2, (h - linesize) / 2 + smallgap, w - 1.5 * h)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(w - (1.5 * h), 0, linesize, h)

                surface.SetDrawColor(Bfg_col)
                surface.SetMaterial(att_icon)
                surface.DrawTexturedRect(w - (1.25 * h), 0, h, h)
            else
                if installed then
                    local atttbl = ArcCW.AttachmentTable[installed]
                    txt = att_txt

                    if atttbl.Health then
                        local perc = (self:GetAttachmentHP(i) / self:GetAttachmentMaxHP(i)) * 100
                        perc = math.Round(perc)
                        txt = txt .. " (" .. tostring(perc) .. "%)"
                    end
                end

                span:SetSize(barsize, buttonsize / 2)

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
                surface.DrawRect(w - (1.5 * h), 0, 1.5 * h, h)

                surface.SetTextColor(SolidBlack)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12_Glow")
                -- surface.DrawText(txt)
                DrawTextRot(span, txt, 0, 0, smallgap, 0, w - 1.5 * h)

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, 0)
                surface.SetFont("ArcCW_12")
                DrawTextRot(span, txt, 0, 0, smallgap, 0, w - 1.5 * h, true)

                surface.SetDrawColor(Bfg_col)
                surface.DrawRect(w - (1.5 * h), 0, linesize, h)

                surface.SetDrawColor(Bfg_col)
                surface.SetMaterial(att_icon)
                surface.DrawTexturedRect(w - (1.25 * h), 0, h, h)
            end
        end
    end

    local sbar2 = triviabox:GetVBar()
    sbar2.Paint = function() end

    sbar2.btnUp.Paint = function(span, w, h)
    end

    sbar2.btnDown.Paint = function(span, w, h)
    end

    sbar2.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(fg_col)
        surface.DrawRect(0, 0, w, h)
    end

    local triv_wpnnamelabel = vgui.Create("DLabel", triviabox)
    triv_wpnnamelabel:SetSize(barsize, buttonsize)
    triv_wpnnamelabel:Dock(TOP)
    triv_wpnnamelabel:DockMargin( 0, 0, 0, smallgap )
    triv_wpnnamelabel:SetText("")
    triv_wpnnamelabel.Paint = function(span, w, h)
        if !IsValid(self) then return end
        local txt = translate("name." .. self:GetClass()) or self.PrintName

        surface.SetFont("ArcCW_20")
        local tw, th = surface.GetTextSize(txt)

        surface.SetFont("ArcCW_20_Glow")
        surface.SetTextPos((w - tw) / 2, th / 2)
        surface.SetTextColor(SolidBlack)
        surface.DrawText(txt)

        surface.SetFont("ArcCW_20")
        surface.SetTextPos((w - tw) / 2, th / 2)
        surface.SetTextColor(fg_col)
        surface.DrawText(txt)
    end

    local year = self:GetBuff_Override("Override_Trivia_Year") or self.Trivia_Year

    if isnumber(year) and year < 0 then
        year = tostring(math.abs(year)) .. "BC"
    end

    year = tostring(year)

    local trivia = {
        function() return translate("trivia.class") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Class") or self.Trivia_Class) or "Unknown" end,
        function() return translate("trivia.year") .. ": " .. year or "Unknown" end,
        function() return translate("trivia.mechanism") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Mechanism") or self.Trivia_Mechanism or "Unknown") end,
        function() return translate("trivia.calibre") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Calibre") or self.Trivia_Calibre or "Unknown") end,
        function() return translate("trivia.ammo") .. ": " .. language.GetPhrase(self.Primary.Ammo or self.PrintName) end,
        function() return translate("trivia.country") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Country") or self.Trivia_Country or "Unknown") end,
        function() return translate("trivia.manufacturer") .. ": " .. ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Manufacturer") or self.Trivia_Manufacturer or "Unknown") end,
        function() return translate("trivia.clipsize") .. ": " .. self:GetCapacity() end,
        function() return translate("trivia.precision") .. ": " .. self:GetBuff("AccuracyMOA") .. " MOA" end,
        function() return translate("trivia.noise") .. ": " .. (self:GetBuff("ShootVol")) .. "dB" end,
        function() return translate("trivia.recoil") .. ": " .. math.Truncate(self.Recoil * 41.4 * self:GetBuff_Mult("Mult_Recoil"), 1) .. " lb-fps" end,
        function() return translate("trivia.penetration") .. ": " .. math.Round(self:GetBuff("Penetration"), 1) .. "mm" end,
    }

    if !self.ManualAction and !self:GetBuff_Override("Override_ManualAction") then
        table.insert(trivia, function()
            local rpm = math.Round(60 / self:GetFiringDelay())
            return translate("trivia.firerate") .. ": " .. rpm .. "RPM"
        end)
    end

    if !(self:GetBuff_Override("Override_Trivia_Class") or self.Trivia_Class) then
        trivia[1] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Year") or self.Trivia_Year) then
        trivia[2] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Mechanism") or self.Trivia_Mechanism) then
        trivia[3] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Calibre") or self.Trivia_Calibre) then
        trivia[4] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Country") or self.Trivia_Country) then
        trivia[6] = nil
    end

    if !(self:GetBuff_Override("Override_Trivia_Manufacturer") or self.Trivia_Manufacturer) then
        trivia[7] = nil
    end

    if self.PrimaryBash then
        trivia[4] = nil
        trivia[5] = nil
        trivia[8] = nil
        trivia[9] = nil
        trivia[10] = nil
        trivia[11] = nil
        trivia[12] = nil
        trivia[13] = nil
    end

    if self.Throwing then
        trivia[4] = nil
        trivia[8] = nil
        trivia[9] = nil
        trivia[10] = nil
        trivia[11] = nil
        trivia[12] = nil
        trivia[13] = nil
    end

    local ft = self:GetBuff_Override("Override_FuseTime") or self.FuseTime

    if ft then
        table.insert(trivia, function() return translate("trivia.fusetime") .. ": " .. tostring(ft) end)
    end

    for _, i in pairs(trivia) do
        if !i then continue end
        local triv_misc = vgui.Create("DLabel", triviabox)
        triv_misc:SetSize(barsize, ScreenScaleMulti(8))
        triv_misc:Dock(TOP)
        triv_misc:SetText("")
        triv_misc:DockMargin( 0, 0, 0, 0 )
        triv_misc.Paint = function(span, w, h)
            if !IsValid(self) then return end
            local txt = i()

            surface.SetFont("ArcCW_8")
            surface.SetTextPos(smallgap, 0)
            surface.SetTextColor(fg_col)
            surface.DrawText(txt)
        end
    end

    -- multlinetext(text, maxw, font)

    local adesctext = multlinetext(ArcCW.TryTranslation(self:GetBuff_Override("Override_Trivia_Desc")) or translate("desc." .. self:GetClass()) or self.Trivia_Desc, barsize - smallgap, "ArcCW_8")

    table.insert(adesctext, "")

    local triv_desc = vgui.Create("DLabel", triviabox)
    triv_desc:SetSize(barsize, ScreenScaleMulti(8) * (table.Count(adesctext) + 1))
    triv_desc:SetText("")
    triv_desc:Dock(TOP)
    triv_desc.Paint = function(span, w, h)
        local y = ScreenScaleMulti(8)
        for _, line in pairs(adesctext) do
            surface.SetFont("ArcCW_8")
            surface.SetTextPos(smallgap, y)
            surface.SetTextColor(fg_col)
            surface.DrawText(line)
            y = y + ScreenScaleMulti(8)
        end
    end

    if !self.ShootEntity and !self.PrimaryBash and !self.Throwing and !self.NoRangeGraph then
        local rangegraph = vgui.Create("DLabel", triviabox)
        rangegraph:SetSize(barsize, ScreenScaleMulti(64))
        rangegraph:SetText("")
        rangegraph:Dock(TOP)
        rangegraph.Paint = function(span, w, h)
            if !IsValid(self) then return end
            local sidegap = 0
            local gx, gy = 0, smallgap
            local gw, gh = w - (2 * sidegap), h - smallgap - ScreenScaleMulti(6)

            local dmgmax = math.Round(self:GetDamage(0))
            local dmgmin = math.Round(self:GetDamage(math.huge))

            local grsh = math.max(dmgmax, dmgmin)

            grsh = math.ceil((grsh / 12) + 1) * 12

            local mingr = self.RangeMin * self:GetBuff_Mult("Mult_Range") * self:GetBuff_Mult("Mult_RangeMin")
            local maxgr = self.Range * self:GetBuff_Mult("Mult_Range")

            if dmgmax < dmgmin then
                maxgr = (self.Range / self:GetBuff_Mult("Mult_Range"))
            end

            maxgr = math.Round(maxgr)

            local grsw = math.ceil((maxgr / 12) + 1) * 12

            local convw = gw / grsw
            local convh = gh / grsh

            local starty = gh - (dmgmax * convh)
            local endy = gh - (dmgmin * convh)
            local startx = mingr * convw
            local endx = maxgr * convw

            surface.SetDrawColor(bg_col)
            surface.DrawRect(gx, gy, gw, gh)

            surface.SetDrawColor(fg_col)

            -- start
            surface.DrawLine(0, gy + starty, gx + startx, gy + starty)
            -- before mid
            surface.DrawLine(gx + startx, gy + starty, gx + endx, gy + endy)
            if mingr != 0 then
                surface.DrawLine(gx + startx, gy+ScreenScaleMulti(2) + starty, gx + startx, gy-ScreenScaleMulti(2) + starty)
            end
            -- long and into the void
            surface.DrawLine(gx + endx, gy + endy, gx + gw, gy + endy)
            surface.DrawLine(gx + endx, gy+ScreenScaleMulti(2) + endy, gx + endx, gy-ScreenScaleMulti(2) + endy)

            -- start dmg
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            surface.SetTextPos(0, gy + starty - ScreenScaleMulti(7) - 1)
            surface.DrawText(tostring(dmgmax) .. "DMG")

            -- end dmg
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")

            local dtw = surface.GetTextSize(tostring(dmgmin) .. "DMG")
            surface.SetTextPos(gx + gw - dtw, gy + endy - ScreenScaleMulti(7) - 1)
            surface.DrawText(tostring(dmgmin) .. "DMG")

            -- start range
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            surface.SetTextPos(sidegap, smallgap + gh)
            surface.DrawText("0m")

            -- before mid range
            if mingr != 0 then
                surface.SetTextColor(fg_col)
                surface.SetFont("ArcCW_6")
                local btw = surface.GetTextSize(tostring(mingr) .. "m")
                surface.SetTextPos(gx + startx - (btw / 2), smallgap + gh)
                surface.DrawText(tostring(mingr) .. "m")
            end

            -- mid range
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            local mtw = surface.GetTextSize(tostring(maxgr) .. "m")
            surface.SetTextPos(gx + endx - (mtw / 2), smallgap + gh)
            surface.DrawText(tostring(maxgr) .. "m")

            -- end range
            surface.SetTextColor(fg_col)
            surface.SetFont("ArcCW_6")
            local rtw = surface.GetTextSize(tostring(grsw) .. "m")
            surface.SetTextPos(w - sidegap - rtw, smallgap + gh)
            surface.DrawText(tostring(grsw) .. "m")

            local mousex, mousey = span:CursorPos()

            if mousex > gx and mousex < (gx + gw) and
                    (mousey > gy and mousey < (gy + gh)) then
                local mouser = (mousex - gx) / convw

                local shy
                local shdmg

                if mouser < mingr then
                    shy = starty
                    shdmg = dmgmax
                elseif mouser < maxgr then
                    local delta = mouser / maxgr
                    shy = Lerp(delta, starty, endy)
                    shdmg = Lerp(delta, dmgmax, dmgmin)
                else
                    shy = endy
                    shdmg = dmgmin
                end

                surface.SetDrawColor(Color(fg_col.r, fg_col.g, fg_col.b, 150))
                surface.DrawLine(gx, gy + shy, gw, gy + shy)
                surface.DrawLine(mousex, gy, mousex, gh + gy)

                shy = shy + ScreenScaleMulti(4)

                mouser = math.Round(mouser)
                shdmg = math.Round(shdmg)

                local alignleft = true

                surface.SetFont("ArcCW_6")
                local twmr = surface.GetTextSize(tostring(mouser) .. "m")
                local twmb = surface.GetTextSize(tostring(shdmg) .. "DMG")

                if mousex < math.max(twmr, twmb) + ScreenScaleMulti(2) then
                    alignleft = false
                end

                surface.SetTextColor(fg_col)
                surface.SetFont("ArcCW_6")
                if alignleft then
                    surface.SetTextPos(mousex - ScreenScaleMulti(2) - twmr, shy)
                else
                    surface.SetTextPos(mousex + ScreenScaleMulti(2), shy)
                end
                surface.DrawText(tostring(mouser) .. "m")

                surface.SetTextColor(fg_col)
                surface.SetFont("ArcCW_6")
                if alignleft then
                    surface.SetTextPos(mousex - ScreenScaleMulti(2) - twmb, ScreenScaleMulti(2) + gy)
                else
                    surface.SetTextPos(mousex + ScreenScaleMulti(2), ScreenScaleMulti(2) + gy)
                end
                surface.DrawText(tostring(shdmg) .. "DMG")
            end
        end
    end

    local function defaultStatFunc(name, unit, round)
        local orig = self[name]
        if ArcCW.ConVar_BuffMults["Mult_" .. name] then
            orig = orig * GetConVar(ArcCW.ConVar_BuffMults["Mult_" .. name]):GetFloat()
        end
        return math.Round((unit == "%" and 100 or unit == "ms" and 1000 or 1) * orig, round) .. (unit or ""),
               math.Round((unit == "%" and 100 or unit == "ms" and 1000 or 1) * self[name] * self:GetBuff_Mult("Mult_" .. name), round) .. (unit or "")
    end

    local function defaultBetterFunc(name, inverse)
        local mult = self:GetBuff_Mult("Mult_" .. name)
        if ArcCW.ConVar_BuffMults[name] then
            mult = mult / GetConVar(ArcCW.ConVar_BuffMults[name]):GetFloat()
        end
        if inverse then mult = 1 / mult end
        if mult > 1 then return true
        elseif mult < 1 then return false
        else return nil end
    end

    local statList
    regenStatList = function()
        statList = {
            {translate("stat.stat"), "",
                function() return translate("stat.original"), translate("stat.current") end,
                function() return nil end,
            },
            {translate("stat.damage"), translate("stat.damage.tooltip"),
                function()
                    local curNum = self:GetBuff("Num")
                    local orig = math.Round(self.Damage * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (self.Num != 1 and ("×" .. self.Num) or "")
                    local cur = math.Round(self:GetDamage(0) / curNum * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (curNum != 1 and ("×" .. curNum) or "")
                    return orig, cur
                end,
                function()
                    local orig = self.Damage * self.Num * ArcCW.ConVars["mult_damage"]:GetFloat()
                    local cur = self:GetDamage(0)
                    if orig == cur then return nil else return cur > orig end
                end,
            },
            {translate("stat.damagemin"), translate("stat.damagemin.tooltip"),
                function()
                    local curNum = self:GetBuff("Num")
                    local orig = math.Round(self.DamageMin * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (self.Num != 1 and ("×" .. self.Num) or "")
                    local cur = math.Round(self:GetDamage(self.Range) / curNum * ArcCW.ConVars["mult_damage"]:GetFloat()) .. (curNum != 1 and ("×" .. curNum) or "")
                    return orig, cur
                end,
                function()
                    local orig = self.DamageMin * self.Num * ArcCW.ConVars["mult_damage"]:GetFloat()
                    local maxgr = (self:GetBuff("Range"))
                    if math.Round(self:GetDamage(self.Range)) < math.Round(self:GetDamage(0)) then
                        maxgr = (self.Range / self:GetBuff_Mult("Mult_Range"))
                    end
                    local cur = self:GetDamage(maxgr)
                    if orig == cur then return nil else return cur > orig end
                end,
            },
            {translate("stat.range"), translate("stat.range.tooltip"),
                function() return defaultStatFunc("Range", "m") end,
                function() return defaultBetterFunc("Range") end,
            },
            {translate("stat.firerate"), translate("stat.firerate.tooltip"),
                function()

                local orig = math.Round(60 / self.Delay) .. "RPM"
                local cur = math.Round(60 / self:GetFiringDelay()) .. "RPM"

                if self.ManualAction then
                    orig = translate("stat.firerate.manual")
                end
                if self:GetBuff_Override("Override_ManualAction") or self.ManualAction then
                    cur = translate("stat.firerate.manual")
                end

                return orig, cur
                end,
                function()
                    if !self:GetBuff_Override("Override_ManualAction") and !self.ManualAction then
                        return defaultBetterFunc("RPM")
                    end
                    -- Funky calculations for when some manual gun goes automatic
                    if !self.ManualAction and self:GetBuff_Override("Override_ManualAction") == true then
                        return false
                    elseif self.ManualAction and self:GetBuff_Override("Override_ManualAction") == false then
                        return true
                    end
                    return nil
                end,
            },
            {translate("stat.capacity"), translate("stat.capacity.tooltip"),
                function()
                    local m = self.RegularClipSize
                    local m2 = self.Primary.ClipSize
                    local cs = self.ChamberSize
                    local cs2 = self:GetChamberSize()
                    return m .. (cs > 0 and " +" .. cs or ""), m2 .. (cs2 > 0 and " +" .. cs2 or "")
                end,
                function()
                    local m = self.RegularClipSize
                    local m2 = self.Primary.ClipSize
                    local cs = self.ChamberSize
                    local cs2 = self:GetChamberSize()
                    if m + cs == m2 + cs2 then return nil end
                    return m + cs < m2 + cs2
                end,
            },
            {translate("stat.precision"), translate("stat.precision.tooltip"),
                function() return defaultStatFunc("AccuracyMOA", " MOA", 3) end,
                function() return defaultBetterFunc("AccuracyMOA", true) end,
            },
            {translate("stat.hipdisp"), translate("stat.hipdisp.tooltip"),
                function() return defaultStatFunc("HipDispersion", " MOA") end,
                function() return defaultBetterFunc("HipDispersion", true) end,
            },
            {translate("stat.movedisp"), translate("stat.movedisp.tooltip"),
                function() return defaultStatFunc("MoveDispersion", " MOA") end,
                function() return defaultBetterFunc("MoveDispersion", true) end,
            },
            {translate("stat.recoil"), translate("stat.recoil.tooltip"),
                function() return defaultStatFunc("Recoil", nil, 2) end,
                function() return defaultBetterFunc("Recoil", true) end,
            },
            {translate("stat.recoilside"), translate("stat.recoilside.tooltip"),
                function() return defaultStatFunc("RecoilSide", nil, 2) end,
                function() return defaultBetterFunc("RecoilSide", true) end,
            },
            {translate("stat.sighttime"), translate("stat.sighttime.tooltip"),
                function() return defaultStatFunc("SightTime", "ms") end,
                function() return defaultBetterFunc("SightTime", true) end,
            },
            {translate("stat.speedmult"), translate("stat.speedmult.tooltip"),
                function()
                    return math.Round(self.SpeedMult * 100) .. "%", math.Round(math.Clamp(self:GetBuff("SpeedMult") * self:GetBuff_Mult("Mult_MoveSpeed"), 0, 1) * 100) .. "%"
                end,
                function()
                    local mult = self:GetBuff_Mult("Mult_SpeedMult") * self:GetBuff_Mult("Mult_MoveSpeed")
                    if mult == 1 then return nil
                    elseif mult > 1 then return true
                    else return false end
                end,
            },
            {translate("stat.sightspeed"), translate("stat.sightspeed.tooltip"),
                function()
                    return math.Round(self.SightedSpeedMult * 100) .. "%", math.Round(math.Clamp(self:GetBuff("SightedSpeedMult") * self:GetBuff_Mult("Mult_SightedMoveSpeed"), 0, 1) * 100) .. "%"
                end,
                function()
                    local mult = self:GetBuff_Mult("Mult_SightedSpeedMult") * self:GetBuff_Mult("Mult_SightedMoveSpeed")
                    if mult == 1 then return nil
                    elseif mult > 1 then return true
                    else return false end
                end,
            },
            {translate("stat.meleedamage"), translate("stat.meleedamage.tooltip"),
                function() return defaultStatFunc("MeleeDamage") end,
                function() return defaultBetterFunc("MeleeDamage") end,
            },
            {translate("stat.meleetime"), translate("stat.meleetime.tooltip"),
                function() return defaultStatFunc("MeleeTime", "ms", 2) end,
                function() return defaultBetterFunc("MeleeTime", true) end,
            },
            {translate("stat.shootvol"), translate("stat.shootvol.tooltip"),
                function() return defaultStatFunc("ShootVol","dB") end,
                function() return defaultBetterFunc("ShootVol", true) end,
            },
            {translate("stat.barrellen"), translate("stat.barrellen.tooltip"),
                function()
                    local orig = self.BarrelLength
                    local cur = orig + self:GetBuff_Add("Add_BarrelLength")
                    return orig .. "in", cur .. "in"
                end,
                function()
                    local add = self:GetBuff_Add("Add_BarrelLength")
                    if add == 0 then return nil else return add < 0 end
                end,
            },
            {translate("stat.pen"), translate("stat.pen.tooltip"),
                function() return defaultStatFunc("Penetration","mm") end,
                function() return defaultBetterFunc("Penetration") end,
            },
        }

        statbox:Clear()

        for _, i in pairs(statList) do
            if !i then continue end
            local stat_panel = vgui.Create("DPanel", statbox)
            stat_panel:SetSize(barsize, ScreenScaleMulti(10))
            stat_panel:Dock(TOP)
            stat_panel:SetText("")
            stat_panel:DockMargin( 0, ScreenScaleMulti(1), 0, ScreenScaleMulti(1) )
            stat_panel.Paint = function(spaa, w, h)
                local Bbg_col = Color(0, 0, 0, 50)

                if spaa:IsHovered() then
                    Bbg_col = Color(100, 100, 100, 50)
                end

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)
            end

            local stat_title = vgui.Create("DLabel", stat_panel)
            stat_title:SetSize(barsize * 0.5, ScreenScaleMulti(10))
            stat_title:SetText("")
            stat_title:Dock(LEFT)
            stat_title.Paint = function(span, w, h)
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.SetTextColor(fg_col)
                surface.DrawText(i[1])
            end

            local origStat, curStat = i[3]()
            local better = i[4]()
            local stat_orig = vgui.Create("DLabel", stat_panel)
            stat_orig:SetSize(barsize * 0.25, ScreenScaleMulti(10))
            stat_orig:SetText("")
            stat_orig:Dock(LEFT)
            stat_orig.Paint = function(span, w, h)
                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.SetTextColor(fg_col)
                surface.DrawText(origStat)
            end
            local stat_cur = vgui.Create("DLabel", stat_panel)
            stat_cur:SetSize(barsize * 0.25, ScreenScaleMulti(10))
            stat_cur:SetText("")
            stat_cur:Dock(LEFT)
            stat_cur.Paint = function(span, w, h)
                local color = better == true and Color(150, 255, 150) or better == false and Color(255, 150, 150) or fg_col

                surface.SetFont("ArcCW_8")
                surface.SetTextPos(smallgap, 0)
                surface.SetTextColor(color)
                surface.DrawText(curStat)
            end
        end
    end

    if !self.Throwing and !self.PrimaryBash and !self.ShootEntity then
        local togglestat = vgui.Create("DButton", ArcCW.InvHUD)
        togglestat:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
        togglestat:SetText("")
        togglestat:SetPos(scrw - barsize - airgap - ScreenScaleMulti(1) - (barsize / 2), airgap)

        togglestat.OnMousePressed = function(spaa, kc)
            if statbox:IsVisible() then
                statbox:Hide()
                triviabox:Show()
            else
                regenStatList()
                statbox:Show()
                triviabox:Hide()
                attmenu:Hide()
                self.InAttMenu = false
                atttrivia:Hide()
                attslidebox:Hide()
                atttogglebtn:Hide()
            end
        end

        togglestat.Paint = function(spaa, w, h)
            if !self:IsValid() then return end
            if !self.Attachments then return end
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            local txt = translate(statbox:IsVisible() and "ui.trivia" or "ui.stats")

            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(smallgap, ScreenScaleMulti(1))
            surface.SetFont("ArcCW_12")
            surface.DrawText(txt)
        end
    end

    if engine.ActiveGamemode() == "terrortown" then
        local gap = airgap

        if GetRoundState() == ROUND_ACTIVE and (LocalPlayer():GetTraitor() or LocalPlayer():GetDetective() or (TTT2 and LocalPlayer().IsShopper and LocalPlayer():IsShopper())) then
            local buymenu = vgui.Create("DButton", ArcCW.InvHUD)
            buymenu:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
            buymenu:SetText("")
            buymenu:SetPos(scrw - barsize - airgap - ScreenScaleMulti(1) - (barsize / 2), airgap + gap)
            gap = gap + airgap

            buymenu.OnMousePressed = function(spaa, kc)
                RunConsoleCommand("ttt_cl_traitorpopup")
            end

            buymenu.Paint = function(spaa, w, h)
                if !self:IsValid() then return end
                if !self.Attachments then return end
                local Bfg_col = Color(255, 255, 255, 255)
                local Bbg_col = Color(0, 0, 0, 100)

                if spaa:IsHovered() then
                    Bbg_col = Color(255, 255, 255, 100)
                    Bfg_col = Color(0, 0, 0, 255)
                end

                surface.SetDrawColor(Bbg_col)
                surface.DrawRect(0, 0, w, h)

                local txt = translate("ui.tttequip")

                surface.SetTextColor(Bfg_col)
                surface.SetTextPos(smallgap, ScreenScaleMulti(1))
                surface.SetFont("ArcCW_12")
                surface.DrawText(txt)
            end
        end

        local radiomenu = vgui.Create("DButton", ArcCW.InvHUD)
        radiomenu:SetSize((barsize - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
        radiomenu:SetText("")
        radiomenu:SetPos(scrw - barsize - airgap - ScreenScaleMulti(1) - (barsize / 2), airgap + gap)

        radiomenu.OnMousePressed = function(spaa, kc)
            RADIO:ShowRadioCommands(!RADIO.Show)
        end

        radiomenu.Paint = function(spaa, w, h)
            if !self:IsValid() then return end
            if !self.Attachments then return end
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            local txt = translate("ui.tttchat")

            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(smallgap, ScreenScaleMulti(1))
            surface.SetFont("ArcCW_12")
            surface.DrawText(txt)
        end
    end

    if CLIENT and vrmod and vrmod.IsPlayerInVR(self:GetOwner()) then
        local w, h = ArcCW.InvHUD:GetSize()
        local ang = Angle(0,g_VR.tracking.hmd.ang.yaw-90,45)
        local pos = g_VR.tracking.hmd.pos + Vector(0,0,-20) + Angle(0,g_VR.tracking.hmd.ang.yaw,0):Forward() * 30 + ang:Forward() * w * -0.02 + ang:Right() * h * -0.02
        pos, ang = WorldToLocal(pos, ang, g_VR.origin, g_VR.originAngle)
        vrmod.MenuCreate( "ArcCW_Customize", w, h, ArcCW.InvHUD, 4,
                pos, ang, 0.04, true, function()
            self:CloseCustomizeHUD()
        end)
    end

end

end
--PATH lua/weapons/arccw_base/sh_firemodes.lua:
function SWEP:ChangeFiremode(pred)
    pred = pred or true
    local fmt = self:GetBuff_Override("Override_Firemodes", self.Firemodes)
    fmt["BaseClass"] = nil

    local check = self:GetBuff_Hook("Hook_ChangeFiremode")
    if check then return end
    local count = table.Count(fmt)
    if count == 1 then return end
    if self:GetNextPrimaryFire() > CurTime() then return end
    if self:GetGrenadePrimed() then return end

    local fmi = self:GetFireMode()
    local lastfmi = fmi

    fmi = fmi + 1

    if fmi > count then
       fmi = 1
    end

    local altsafety = SERVER and (self:GetOwner():GetInfo("arccw_altsafety") == "1") or CLIENT and (ArcCW.ConVars["altsafety"]:GetBool())
    if altsafety and !self:GetOwner():KeyDown(IN_WALK) and fmt[fmi] and fmt[fmi].Mode == 0 then
        -- Skip safety when walk key is not down
        fmi = (fmi + 1 > count) and 1 or (fmi + 1)
    elseif altsafety and self:GetOwner():KeyDown(IN_WALK) then
        if fmt[lastfmi] and fmt[lastfmi].Mode == 0 then
            -- Find the first non-safety firemode
            local nonsafe_fmi = nil
            for i, fm in pairs(fmt) do
                if fm.Mode != 0 then nonsafe_fmi = i break end
            end
            fmi = nonsafe_fmi or fmi
        else
            -- Find the safety firemode
            local safety_fmi = nil
            for i, fm in pairs(fmt) do
                if fm.Mode == 0 then safety_fmi = i break end
            end
            fmi = safety_fmi or fmi
        end
    end

    if !fmt[fmi] then fmi = 1 end

    local a = tostring(lastfmi) .. "_to_" .. tostring(fmi)

    if !self.Animations[a] then a = "changefiremode" end

    if self.Animations[a] then
        self:PlayAnimationEZ(a, 1, true)
        local t = CurTime() + self:GetAnimKeyTime(a, true)
        self:SetPriorityAnim(t)
        self:SetNextPrimaryFire(t)
    end

    local old_inf = self:HasInfiniteAmmo()

    self:SetFireMode(fmi)
    --timer.Simple(0, function() self:RecalcAllBuffs() end)
    -- Absolutely, totally, completely ENSURE client has changed the value before attempting recalculation
    -- Waiting one tick will not work on dedicated servers
    local id = "ArcCW_RecalcWait_" .. self:EntIndex()
    timer.Create(id, 0.01, 0, function()
        if !IsValid(self) then timer.Remove(id) return end
        if self:GetFireMode() == fmi then
            self:RecalcAllBuffs()
            self:GetActiveElements(true)

            -- Timers solve everything!
            timer.Simple(0.01, function()
                if !IsValid(self) then return end
                self:AdjustAmmo(old_inf)
                if self:GetCurrentFiremode().RestoreAmmo then
                    -- No seriously, they really do
                    timer.Simple(0.01, function()
                        if !IsValid(self) then return end
                        self:RestoreAmmo()
                    end)
                end
            end)
            timer.Remove(id)
        end
    end)

    if lastfmi != fmi then
        local snd = self:GetBuff_Override("Override_FiremodeSound", self.FiremodeSound)
        if SERVER then
            if pred then
                SuppressHostEvents(self:GetOwner())
            end
            self:MyEmitSound(snd, 75, 100, 1, CHAN_ITEM + 2)
            if pred then
                SuppressHostEvents(NULL)
            end
        else
           self:MyEmitSound(snd, 75, 100, 1, CHAN_ITEM + 2)
        end
    end

    self:SetShouldHoldType()

    if self:GetCurrentFiremode().Mode == 0 or self:GetBuff_Hook("Hook_ShouldNotSight") then
        self:ExitSights()
    end
end

function SWEP:GetCurrentFiremode()
    local fmt = self:GetBuff_Override("Override_Firemodes", self.Firemodes)
    fmt.BaseClass = nil

    if self:GetFireMode() > table.Count(fmt) or self:GetFireMode() < 1 then
        self:SetFireMode(1)
    end

    fmt[self:GetFireMode()].BaseClass = nil
    return fmt[self:GetFireMode()]
end

function SWEP:GetFiremodeName()
    if self:GetBuff_Hook("Hook_FiremodeName") then return self:GetBuff_Hook("Hook_FiremodeName") end

    local abbrev = ArcCW.ConVars["hud_fcgabbrev"]:GetBool() and ".abbrev" or ""

    if self:GetInUBGL() then
        return self:GetBuff_Override("UBGL_PrintName") and self:GetBuff_Override("UBGL_PrintName") or ArcCW.GetTranslation("fcg.ubgl" .. abbrev)
    end

    local fm = self:GetCurrentFiremode()

    if fm.PrintName then
        local phrase = ArcCW.GetPhraseFromString(fm.PrintName)
        return phrase and ArcCW.GetTranslation(phrase .. abbrev) or ArcCW.TryTranslation(fm.PrintName)
    end

    local mode = fm.Mode
    if mode == 0 then return ArcCW.GetTranslation("fcg.safe" .. abbrev) end
    if mode == 1 then return ArcCW.GetTranslation("fcg.semi" .. abbrev) end
    if mode >= 2 then return ArcCW.GetTranslation("fcg.auto" .. abbrev) end
    if mode < 0 then return string.format(ArcCW.GetTranslation("fcg.burst" .. abbrev), tostring(-mode)) end
end

function SWEP:GetFiremodeBars()
    if self:GetBuff_Hook("Hook_FiremodeBars") then return self:GetBuff_Hook("Hook_FiremodeBars") end

    if self:GetInUBGL() then
        return "____-"
    end

    local fm = self:GetCurrentFiremode()

    if fm.CustomBars then return fm.CustomBars end

    local mode = fm.Mode

    if mode == 0 then return "_____" end
    if mode == 1 then return "-____" end
    if mode >= 2 then return "-----" end
    if mode == -2 then return "--___" end
    if mode == -3 then return "---__" end
    if mode == -4 then return "----_" end

    return "-----"
end
--PATH lua/weapons/arccw_base/sh_firing.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_freeaim.lua:
local ang0 = Angle(0, 0, 0)
SWEP.ClientFreeAimAng = Angle(ang0)

function SWEP:ShouldFreeAim()
    if self:GetOwner():IsNPC() then return false end
    if (ArcCW.ConVars["freeaim"]:GetInt() == 0 or self:GetBuff_Override("NeverFreeAim", self.NeverFreeAim))  and !self:GetBuff_Override("AlwaysFreeAim", self.AlwaysFreeAim) then return false end
    return true
end

function SWEP:FreeAimMaxAngle()
    local ang = self.FreeAimAngle and self:GetBuff("FreeAimAngle") or math.Clamp(self:GetBuff("HipDispersion") / 80, 3, 10)
    return ang
end

function SWEP:ThinkFreeAim()
    if self:ShouldFreeAim() then
        local diff = self:GetOwner():EyeAngles() - self:GetLastAimAngle()
        --diff = diff * 2

        local freeaimang = Angle(self:GetFreeAimAngle())

        local max = self:FreeAimMaxAngle()

        local delta = math.min(self:GetSightDelta(),
                self:CanShootWhileSprint() and 1 or (1 - self:GetSprintDelta()),
                self:GetState() == ArcCW.STATE_CUSTOMIZE and 0 or 1)

        max = max * delta

        diff.p = math.NormalizeAngle(diff.p)
        diff.y = math.NormalizeAngle(diff.y)

        diff = diff * Lerp(delta, 1, 0.25)

        freeaimang.p = math.Clamp(math.NormalizeAngle(freeaimang.p) + math.NormalizeAngle(diff.p), -max, max)
        freeaimang.y = math.Clamp(math.NormalizeAngle(freeaimang.y) + math.NormalizeAngle(diff.y), -max, max)

        local ang2d = math.atan2(freeaimang.p, freeaimang.y)
        local mag2d = math.sqrt(math.pow(freeaimang.p, 2) + math.pow(freeaimang.y, 2))

        mag2d = math.min(mag2d, max)

        freeaimang.p = mag2d * math.sin(ang2d)
        freeaimang.y = mag2d * math.cos(ang2d)

        self:SetFreeAimAngle(freeaimang)

        if CLIENT then
            self.ClientFreeAimAng = freeaimang
        end
    end

    self:SetLastAimAngle(self:GetOwner():EyeAngles())
end

function SWEP:GetFreeAimOffset()
    if !self:ShouldFreeAim() then return ang0 end
    if CLIENT then
        return self.ClientFreeAimAng
    else
        return self:GetFreeAimAngle()
    end
end
--PATH lua/weapons/arccw_base/sh_reload.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_rocket.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_util.lua:
function SWEP:TableRandom(table)
    return table[math.random(#table)]
end

function SWEP:MyEmitSound(fsound, level, pitch, vol, chan, useWorld)
    if !fsound then return end

    fsound = self:GetBuff_Hook("Hook_TranslateSound", fsound) or fsound

    if istable(fsound) then fsound = self:TableRandom(fsound) end

    if fsound and fsound != "" then
        if useWorld then
            sound.Play(fsound, self:GetOwner():GetShootPos(), level, pitch, vol)
        else
            self:EmitSound(fsound, level, pitch, vol, chan or CHAN_AUTO)
        end
    end
end
--PATH lua/weapons/arccw_e5.lua:
return gluapack()()
--PATH lua/weapons/arccw_e5bx.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "E-5 BX"
SWEP.Trivia_Class = "CIS Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact CIS E-5 Blaster Carbine."
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_e11.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_e5.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 44
SWEP.RangeMin = 175
SWEP.DamageMin = 24
SWEP.Range = 435
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 320
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.4 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 390 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/e5.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(255, 0, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-2.87, -8, .7),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 65,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2.9, -4, .5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, -10, 0)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(12.824, -8, -3.897)
SWEP.CustomizeAng = Angle(10.149, 34.547, 0)

SWEP.DefaultElements = {"e5bx", "muzzle"}

SWEP.AttachmentElements = {
    ["e5bx"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "v_e11_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-0.95, 0.899, -3.5),
                    ang = Angle(0, -90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "e11_sight",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.5, 4, 11),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
       },
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(450, 60, 200),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2000, 0, -900),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}

WMOverride = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl"
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.24, -1.5, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 55, -740),
            wang = Angle(-15, 0, 180)
        },
    },    
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 10),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 2.5, 10),
            vmax = Vector(-0, 2.5, 12),
            wmin = Vector(1000, 60, -450), 
            wmax = Vector(1000, 60, -450) -- how far this attachment can slide in both directions.
            },
    },
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 1.5, 11),
            vang = Angle(90, 0, 0),
            wpos = Vector(1200, 130, -750),
            wang = Angle(-15, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.1, 0.6, 17),
            vang = Angle(90, 0, -90),
            wpos = Vector(1640, 60, -860),
            wang = Angle(-15, 0, -90)
        },
    },
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 2.1, -0.5),
            vang = Angle(0, 0, 0),
        },
    },        
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.9, 1, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 220, -500),
            wang = Angle(-10 , 0, 180)
        },
    },          
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.2,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15s.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--PATH lua/weapons/arccw_e5c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "E-5C"
SWEP.Trivia_Class = "CIS Heavy Blaster Rifle"
SWEP.Trivia_Desc = "High tech CIS E-5C Heavy Blaster Rifle"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_t21.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_t21.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_e5c.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 35
SWEP.RangeMin = 145
SWEP.DamageMin = 24
SWEP.Range = 376
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1


SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 0.44
SWEP.RecoilSide = 0.25
SWEP.RecoilPunch = 0.8
SWEP.RecoilRise = 0.34

SWEP.Delay = 60 / 444
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 0.8 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 0.5 -- Bipod recoil for Integral bipods

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/e5c.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(250, 0, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-1.7, -9, 0.8),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 55,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(5, -3, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(3.4, -6, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)
SWEP.CustomizePos = Vector(20.824, -14, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"e5c", "muzzle"}

SWEP.AttachmentElements = {
    ["e5c"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5c_blaster.mdl",
                Bone = "v_t21_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0.699, 3.5, -2.8),
                    ang = Angle(0,-90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "t21_sight",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.5, 4, 17 ),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
       },
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5c_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(400, 50.5, 500),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(3000, 0, -1100),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}

WMOverride = "models/arccw/kuro/sw_battlefront/weapons/e5c_blaster.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.7, -2.3, 1.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(150, 50, -750),
            wang = Angle(-15, 0, 180)
        },
    },    
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.5, 2.3, 11),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
        vmin = Vector(0.5, 2.3, 7),
        vmax = Vector(0.5, 2.3, 11),
        wmin = Vector(1800, 50, -550), 
        wmax = Vector(1800, 50, -550) -- how far this attachment can slide in both directions.
        },         
    },
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.7, 2.3, 14),
            vang = Angle(90, 0, 0),
            wpos = Vector(1800, 150, -550),
            wang = Angle(-15, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 0.7, 23),
            vang = Angle(90, 0, -90),
            wpos = Vector(2800, 50, -1070),
            wang = Angle(-15, 0, -90)
        },
    },
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, 4),
            vang = Angle(0, 0, 0),
        },
    },        
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(2, 0.8, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(600, 100, -520),
            wang = Angle(-10 , 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--PATH lua/weapons/arccw_e5s.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_9228.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_9228.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "9228 Carbine"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "Blaster Carbine designed for military and civillian usage. It shoots 7 plasma bolts on a single shoot. Works like more than a Shotgun instead a Carbine."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Calibre = "Merr-Sonn. Munitions Inc."
SWEP.IconOverride = "entities/kraken/galactic/9228.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_9228_carbine.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 6
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}


SWEP.Damage = 26
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 340
SWEP.Penetration = 8
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 1.4
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.6
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 200
SWEP.Num = 7
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_9228"
SWEP.ShootSound = "ArcCW_Kraken.SW_9228"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3, 0, 1.5),
    Ang = Vector(0, 0, -2.4),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0, -1, 1.1),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.9, 15.3, 0.25),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 21.5, 0.30),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.6, -0.2, -1.2),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1, -3.6, 0.4),
            vang = Angle(20, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "shoot",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a280.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a280su.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "A-280su"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The A280 blaster rifle was a type of blaster rifle mostly used by Rebel Alliance troopers and New Republic soldiers. There existed two variants of the A280 blaster, the A280C and the A280-CFE, both of which were favored by commandos and special force of the Rebel Alliance."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/a280su.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000201000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_a280.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(0.9, 0.5, -2.9),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 46
SWEP.DamageMin = 25
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 1.10
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.54
SWEP.RecoilPunch = 1

SWEP.Delay = 60 / 750
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_A280"
SWEP.ShootSound = "ArcCW_Kraken.SW_A280"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.373, -3, 0),
    Ang = Vector(0, 0.1, -3),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -2, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, 0)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, -3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["optic_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
    ["foregrip_attach"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        InstalledEles = {"optic_attach"},
        Offset = {
            vpos = Vector(8.5, -0, 2),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(22.3, -0.1, 0.2),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        InstalledEles = {"laser_attach"},
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(13.5, 0.6, 0.5),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "A-280 Foregrip",
        Slot = {"foregrip"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        InstalledEles = {"foregrip_attach"},
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(13.4, 0.1, -0.3),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(5.55, -1.0, -1.34),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(2.5, -0.5, 0.09),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/a280/handling_2/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_reload_start.ogg", t = 0.033},
            {s = "ArcCW_Kraken.Overheat", t = 0.67},
            {s = path .. "wfoly_plr_ar_falima_reload_magout_01.ogg", t = 0.65},
            {s = path .. "wfoly_plr_ar_falima_reload_arm.ogg", t = 0.75},
            {s = path .. "wfoly_plr_ar_falima_reload_elbow.ogg", t = 1.45},
			{s = path .. "wfoly_plr_ar_falima_reload_magin_v2_01.ogg", t = 1.5},
			{s = path .. "wfoly_plr_ar_falima_reload_magin_v2_02.ogg", t = 1.75},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.6},
			{s = path .. "wfoly_plr_ar_falima_reload_end.ogg", t = 2.06},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_reload_empty_start.ogg", t = 0},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_rotate.ogg", t = 0.46},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_magout_01.ogg", t = 0.73},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_shake.ogg", t = 0.93},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_arm.ogg", t = 1.63},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_magin_v2_01.ogg", t = 1.83},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_magin_v2_02.ogg", t = 2.1},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_elbow.ogg", t = 2.2},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_boltopen_01.ogg", t = 2.66},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_boltclose_01.ogg", t = 2.96},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_end.ogg", t = 3},
        },
    },
    ["ready"] = {
        Source = "draw_short",
        LHIK = true,
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_raise_start.ogg", t = 0/30},
			{s = path .. "wfoly_plr_ar_falima_raise_settle.ogg", t = 0/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        LHIK = true,
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_raise_start.ogg", t = 0/30},
			{s = path .. "wfoly_plr_ar_falima_raise_settle.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_drop_down.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 1.25,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_ar_falima_inspect_01.ogg", t = 0},
			{s = path .. "wfoly_ar_falima_inspect_02.ogg", t = 1.3},
			{s = path .. "wfoly_ar_falima_inspect_03.ogg", t = 2.36},
			{s = path .. "wfoly_ar_falima_inspect_04.ogg", t = 3.6},
			{s = path .. "wfoly_ar_falima_inspect_05.ogg", t = 4.1},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "weap_ar_falima_selector_off.ogg", t = 0/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_b2hand.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Confederacy Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "B2 Handblaster"
SWEP.Trivia_Class = "Blaster, Handblaster"
SWEP.Trivia_Desc = "B2-series super battle droids, also known as B2 super battle droids, were an advanced battle droid used by the Confederacy of Independent Systems during the Clone Wars. Although one model of the B2-series was only equipped with wrist blasters on their right forearm, another was outfitted with wrist blasters on both forearms. Super battle droids were much stronger than their predecessors, and like the updated B1s used by the Confederacy, they did not require a command system to operate, which gave the droids limited independence. Another improvement was their thick armor casing, which contained their fragile sensors. However, B2s were designed with simple processors, limiting their ability to formulate strategies. As a result, they relied on organic commanders or tactical droids in order to effectively operate. The B2 was much stronger than the B1s, with enough strength to lift a clone trooper off the ground."
SWEP.Trivia_Manufacturer = "Baktoid Armor Workshop"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Confederacy of Independent Systems"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/b2blaster.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = false

SWEP.ViewModel = "models/arccw/kraken/cis/v_b2hand.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.MirrorWorldModel = nil
SWEP.ViewModelFOV = 65


SWEP.WorldModelOffset = {
    pos = Vector(-19, 7, -4.54),
    ang = Angle(-15, 0, 200),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 52
SWEP.DamageMin = 34
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_ITEM)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_B2HAND"
SWEP.ShootSound = "ArcCW_Kraken.SW_B2HAND"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.851, -1.285, 0.674),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "ar2"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, -5, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "dlt34",
                Scale = Vector(0, 0, 0),                
                Offset = {
                    pos = Vector(-2, 2, 20),
                    ang = Angle(90, 0, 0),
                },
                IsMuzzleDevice = false,
            }
         }, 
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },       
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Time = 0.6,
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Mult = 2.2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_bowcaster.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Bowcaster"
SWEP.Trivia_Class = "Blaster Crossbow"
SWEP.Trivia_Desc = "A bowcaster, also known as a laser crossbow, was a type of traditional, handcrafted projectile weapon commonly used by Wookiees."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/bowcaster.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_bowcaster.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 13
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 45
SWEP.DamageMin = 29
SWEP.RangeMin = 0
SWEP.Range = 350
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 400
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_BOWCASTER"
SWEP.ShootSound = "ArcCW_Kraken.SW_BOWCASTER"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.905, 0, 1.33),
    Ang = Vector(0, 0, -0.487),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.14, -3, 1.8),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.4, 10.15, 0.6),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.1, 12.4, 1.5),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.84, -3.1, -0.72),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, -3.2, 0.4),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_charriccarbine.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cr2c.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15a_train.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15s_grenadier.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17_training.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-17 Training"
SWEP.Trivia_Class = "Hand Blaster"
SWEP.Trivia_Desc = "The DC-17 repeater hand blaster, also known more simply as the DC-17 hand blaster or DC-17 blaster pistol, was a model of heavy blaster pistol and the Grand Army of the Republic's standard-issue sidearm. Produced by BlasTech Industries, the DC-17 was usually given to weapon teams, the crews of vehicles, and officers. The weapon was one of the most reliable and toughest models of blaster pistols created, as well as having remarkable stopping power in its small design. The weapon was also well balanced, possessed a respectable rate of fire, and lightweight."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17_training.png"


-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-16, 5, -3.4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 1
SWEP.DamageMin = 1
SWEP.RangeMin = 0
SWEP.Range = 180
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(250, 120, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.9
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.MuzzleFlashColor = Color(250, 120, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.79, -6.251, 0.55),
    Ang = Vector(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(0, -6, -9)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(0, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.AttachmentElements = {
    ["akimbo"] = {
        Override_ActivePos = Vector(2, -2, 0),
        Override_CrouchPos = Vector(0, -3, 0),	
        Override_CrouchAng = Angle(0, 0, 0),
        Override_HolsterPos = Vector(2,2,2),
        Override_HolsterAng = Angle(-20, 0, -5),		
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Hook_SelectReloadAnimation = function(wep, anim)
    if wep.Attachments[4].Installed then
        return anim .. "_akimbo"
    end

    return anim
end

SWEP.Attachments = {
    {
        PrintName = "Optic",
        Slot = "optic",
        Bone = "frame",
        InstalledEles = {"scope_attach"},
        DefaultAttName = "DC-17 Holosight",
        Offset = {
            vpos = Vector(-2, 4.2, 0.13),
            vang = Angle(180,0,90),
        },
        VMScale = Vector(1.25, 1.25, 1.25),
    },
    {
        PrintName = "Tactical",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "frame",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-6, 1, 0.15),
            vang = Angle(180,0,90),
        },
        ExtraSightDist = 9,
        CorrectivePos = Vector(1, 0, -1),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "frame",
        Offset = {
            vpos = Vector(-7.88, 2.35, 0.11),
            vang = Angle(180,0,90),
        },
    },
    {
        PrintName = "Left Hand",
        Slot = {"gso_extra_pistol_akimbo", "mifl_fas2_akimbo", "akimbotest"},
        Bone = "Akimbo_Base",
        DefaultAttName = "None",
        Offset = {
            vpos = Vector(6, -2.8, 0.2),
            vang = Angle(0, 0, 0),
        },
        InstalledEles = {"akimbo"},
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_pistol"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "frame",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.3, -1, -0.45),
            vang = Angle(180,0,90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "frame",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-5.5, 1.7, -0.75),
            vang = Angle(180,0,90),
        },
    },     
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["ready"] = {
        Source = "draw",
    },
    ["fire"] = {
        Source = "fire1",
        ShellEjectAt = false,
    },
    ["fire_iron"] = {
        Source = "fire_scoped2",
        ShellEjectAt = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.8,
        LHIKEaseOut = 0.5,
        SoundTable = {
            {s = "arccw/kraken/republic/dc17/handling/magout.wav", t = 5 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin_partial.wav", t = 30 / 30},
            {s = "arccw/kraken/republic/dc17/handling/magin.wav", t = 40 / 30},
        },
    },
--------------------------------------------------------
    ["reload_akimbo"] = {
        Source = "reload_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_empty_akimbo"] = {
        Source = "reload_empty_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_akimbo"] = {
        Source = "reload_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },
    ["reload_nomen_empty_akimbo"] = {
        Source = "reload_empty_nomen_akimbo",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
    },

    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 75 / 30},
            {s = "ArcCW_Kraken.Grab", t = 78 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17m_shotgun_republic.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17m_sniper_republic.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc17m_sniper_republic.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number


SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-17m Sniper"
SWEP.Trivia_Class = "Modular Blaster Rifle"
SWEP.Trivia_Desc = "The DC-17m Interchangeable Weapon System, also known as the DC-17m Repeating Blaster Rifle, was a type of repeating blaster rifle used by Republic clone commandos during the Clone Wars. It could change between a repeating blaster rifle and grenade launcher by switching the weapon's barrel module."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc17m_sniper.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0201000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc17m.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-13, 7.2, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 5
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = false

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 98
SWEP.DamageMin = 76
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "astra_beam"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 1.8
SWEP.RecoilSide = 1.5
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}

SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC17M_SNIPER"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC17M_SNIPER"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-6.498, -10.992, 1.258),
    Ang = Vector(-1.846, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-2, 0, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -1)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "DC-17M",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(0, -32, 0),
                    ang = Angle(0, 90, 0)
                },
                IsMuzzleDevice = true
            },
        },
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 4, bg = 2}},
    },
}



SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "None", 
        Slot = "optic",
        Bone = "DC-17M",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.06, -2.75, -1.6),
            vang = Angle(0, 90, 180),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    }, 
    {
        PrintName = "Internal Compression",
        DefaultAttName = "DC-17m Sniper",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
    },      
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "DC-17M", 
        Offset = {
            vpos = Vector(-1.5, -13, -0.1),
            vang = Angle(0, 90, 90),
        },
    },   
        {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_sniper"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC-17M",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.94, 0.8, 2.6),
            vang = Angle(0, 90, 180),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC-17M",
        Offset = {
            vpos = Vector(1.48, 1.4, 1),
            vang = Angle(0, 90, 180),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = {"fire"},
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "weapon_hand/reload_heavy/mag_eject/023d-00000080.mp3", t = 10 / 60},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000648.mp3", t = 90 / 60},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000668.mp3", t = 110 / 60},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_de18.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_defender.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt19.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DLT-19"
SWEP.Trivia_Class = "Prototype Heavy Rifle"
SWEP.Trivia_Desc = "Before the DLT-19, the DLT-16 existed as a prototype of a Heavy Rifle for Infantry usage. This weapon, like many others, continued to use bullet casings, however, it had a special system that when they were hammered, the explosion of the tibanna gas was compressed and transformed into a blaster projectile. The DLT-19 heavy blaster rifle was a model of heavy blaster rifle manufactured by BlasTech Industries. They were used by regular stormtroopers and Heavy Weapons Stormtroopers of the Galactic Empire, but they also saw use by other parties, including the Alliance to Restore the Republic and certain bounty hunters."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.IconOverride = "entities/kraken/galactic/dlt19.png"

-- Base
SWEP.DefaultBodygroups = "010300000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dlt19.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-1, 1, -2.4),
    ang = Angle(-5, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 55
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 39
SWEP.DamageMin = 25
SWEP.RangeMin = 0
SWEP.Range = 370
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 100, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_orange"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 75

SWEP.Recoil = 0.74
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.98
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 700
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.86
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DLT16"
SWEP.ShootSound = "ArcCW_Kraken.SW_DLT16"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 100, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.65, -2, 1.3),
    Ang = Angle(1.8, 0.3 , 4.25),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 2, -0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(8, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "j_lever",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(2.5, -0.5, -0),
            vang = Angle(180, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "tag_attachments",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(36, -0.05, 0),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "tag_attachments",
        InstalledEles = {"laser_attach"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(27, 1, 0),
            vang = Angle(0, 0, -90),
        },
    },
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(15.8, 0, -0.8),
            vang = Angle(0, -0, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(0.2, 0.1, -2.3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(0.45, -0.65, -2.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/dlt19/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
    },
    ["reload_empty"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        LHIK = true,
		MinProgress = 0.95,
        SoundTable = {
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_start.ogg", t = 0.1/30},
            {s = "ArcCW_Kraken.Overheat", t = 28/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_boltopen_01.ogg", t = 28/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_boltclose_01.ogg", t = 41/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 41/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_open.ogg", t = 51/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_coveropen_01.ogg", t = 56/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_adjust.ogg", t = 69/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_drumoff_01.ogg", t = 99/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_rattle.ogg", t = 109/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_drumon_01.ogg", t = 148/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_hands.ogg", t = 172/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_belt_01.ogg", t = 189/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_coverclose_01.ogg", t = 231/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_end.ogg", t = 232/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_hands.ogg", t = 250/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_pull.ogg", t = 255/30},
        },
    },
    ["reload"] = {
        Source = "jam_fix",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_start.ogg", t = 0.1/30},
            {s = "ArcCW_Kraken.Overheat", t = 12/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_boltopen_01.ogg", t = 12/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_boltclose_01.ogg", t = 24/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 24/30},
            {s = path .. "wfoly_plr_lm_mgolf34_reload_fast_end.ogg", t = 24/30},
        },
    },
    ["ready"] = {
        Source = "draw",
        LHIK = true,
		MinProgress = 0.7,
        SoundTable = {
            {s = path .. "wfoly_plr_lm_mgolf34_raise_first_pull.ogg", t = 0.1/30},
            {s = path .. "wfoly_plr_lm_mgolf34_raise_first_start.ogg", t = 6/30},
			{s = path .. "wfoly_plr_lm_mgolf34_raise_first_boltopen_01.ogg", t = 31/30},
			{s = path .. "wfoly_plr_lm_mgolf34_raise_first_boltclose_01.ogg", t = 40/30},
			{s = path .. "wfoly_plr_lm_mgolf34_raise_first_end.ogg", t = 56/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        LHIK = true,
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_plr_lm_mgolf34_raise_up.ogg", t = 10/30},
            {s = path .. "wfoly_plr_lm_mgolf34_raise_settle.ogg", t = 34/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_lm_mgolf34_reload_raise.ogg", t = 0.1/30},
            {s = path .. "wfoly_plr_lm_mgolf34_reload_open.ogg", t = 10/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["exit_inspect"] = {
        Source = "lookat01",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_lm_mgolf34_inspect_01.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_mgolf34_inspect_02.ogg", t = 54/30},
			{s = path .. "wfoly_lm_mgolf34_inspect_03.ogg", t = 120/30},
        },
    },
    ["bash"] = {
        LHIK = true,
        Source = {"melee","melee2","melee3"},
    },
    ["fix"] = {
        Mult = 2,
        LHIK = true,
        Source = "jam",
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 0.1/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 10/30},
            {s = "ArcCW_Kraken.Grab", t = 11 / 30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}

--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dp9.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_e9x.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_ee3k.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "EE-3k"
SWEP.Trivia_Class = "Blaster Short-Range Carabine"
SWEP.Trivia_Desc = "Blaster Long-Range Carabine designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/ee3k.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_ee3r.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(1, 0.8, 0),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 47
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.65

SWEP.Delay = 60 / 180
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 4,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_EE3R"
SWEP.ShootSound = "ArcCW_Kraken.SW_EE3R"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.027, 0, 1.503),
    Ang = Vector(0, 0, -2.878),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "tag_sling",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(8.2, -0.05, 3.2),
            vang = Angle(0, 0, 0),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(20, 0.7, 1.5),
            vang = Angle(0, 0, -90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(26.6, -0.1, 1.65),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "tag_sling",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(14, -0.1, 0.9),
            vang = Angle(0, -0, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(8.5, -0.62, 0.1),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(14, -1.15, 1.8),
            vang = Angle(0, 0, 0),
        },
    },   
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/ee3r/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["dryfire"] = {
        Source = "dryfire",
		MinProgress = 0.01,
    },
    ["reload"] = {
        Source = "reload_xmag",
		MinProgress = 0.8,
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_sn_mike14_reload_mvmnt.ogg", t = 0/30},
            {s = path .. "wfoly_sn_mike14_reload_magout.ogg", t = 4/30},
			{s = path .. "wfoly_sn_mike14_reload_arm.ogg", t = 25/30},
			{s = path .. "wfoly_sn_mike14_reload_magin_v2_01.ogg", t = 32/30},
			{s = path .. "wfoly_sn_mike14_reload_magin_v2_02.ogg", t = 38/30},
			{s = path .. "wfoly_sn_mike14_reload_end.ogg", t = 38/30},
        },
    },
    ["ready"] = {
        Source = "draw_short",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_sn_mike14_raise.ogg", t = 0/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_sn_mike14_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_sn_mike14_drop.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_sn_mike14_inspect_01.ogg", t = 0.0},
            {s = path .. "wfoly_sn_mike14_inspect_02.ogg", t = 1.367},
            {s = path .. "wfoly_sn_mike14_inspect_03.ogg", t = 2.333},
			{s = path .. "wfoly_sn_mike14_inspect_04.ogg", t = 4.2},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
        LHIK = true,
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_ee3r.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "EE-3r"
SWEP.Trivia_Class = "Blaster Short-Range Carabine"
SWEP.Trivia_Desc = "Blaster Long-Range Carabine designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/ee3r.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "01000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_ee3.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 16
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 37
SWEP.DamageMin = 27
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 29

SWEP.Recoil = 0.8
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 400
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_EE3"
SWEP.ShootSound = "ArcCW_Kraken.SW_EE3"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.027, 0, 1.503),
    Ang = Vector(0, 0, -2.878),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 6, -1),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.06, 1, 1.65),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.8, 4, 0.5),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0, 7.2, 0.4),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-0., 3, -0.5),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.5, -1.1, -1),
            vang = Angle(-20, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.2, 4, 0.4),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_el16.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_f10.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "F-10"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The F-11D blaster rifle was a blaster rifle manufactured by Sonn-Blas Corporation. This ranged weapon was the successor of the older E-11 medium blaster rifle used by the Galactic Empire. It served as the standard issue weapon of First Order stormtroopers."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Calibre = "Sonn-Blas Corporation"
SWEP.IconOverride = "entities/kraken/galactic/f10.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00020000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_f11d.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 34
SWEP.DamageMin = 25
SWEP.RangeMin = 0
SWEP.Range = 390
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.54
SWEP.RecoilRise = 0.97
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 320
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_F10"
SWEP.ShootSound = "ArcCW_Kraken.SW_F10"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.9, 0, 1.3),
    Ang = Vector(2, -0.3, 1),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 2, 0)
SWEP.ActiveAng = Angle(0, -0.3, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 4, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 10, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.2, -3.2, 1.1),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.9, 4, 0.25),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.1, 1.1, 1.1),
        WMScale = Vector(1.1, 1.1, 1.1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.1, 9, 0.1),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.93, -1.5, -0.1),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, -3.6, -0.25),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "shoot",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_fwmb10k.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "FWMB-10K"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "The FWMB-10 repeating blaster, also known as the megablaster,[3] was a repeating blaster manufactured by the Sonn-Blas Corporation.[1] The FWMB-10s used by First Order megablaster heavy assault troopers—who earned their name from their use of the blaster[1]— featured integrated stands that could fold out from the blaster,[4] as well as barrel cooling shrouds.[1] Light Infantry Utility Vehicles also used pintle-mounted megablasters as their primary armament.[1] These forward-mounted[5] FWMB-10s had steadying grips and trigger levers, data and power feeds, calibration adjustment, elevation gear, a collimator ring, and collimator sleeves.[1] It was powered by an Eksoan Class-5B1 duplex power generator.[6] The FWMB-10K was a smaller variant of the FWMB-10.[7]"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/fwmb10k.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "001010000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_fwmb10k.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 30
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 45
SWEP.DamageMin = 29
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_orange"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 80

SWEP.Recoil = 0.70
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = 2.5
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 390
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_FWMB"
SWEP.ShootSound = "ArcCW_Kraken.SW_FWMB"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.138, 0, 0.982),
    Ang = Vector(0, 0, -4.242),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, -4)

SWEP.CrouchPos = Vector(0, 0, 1)
SWEP.CrouchAng = Angle(0, 0, -4)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-1.2, 10.15, 0.3),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.2, 22, 0.),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-0., 7, -0.8),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.4, -3.6, 0.5),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.1, 0, -0.35),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_iqa11.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_iqa11c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_c14.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_decoy.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_dioxis.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_sequencecharger.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_nn14.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_nt240.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_republicshield.lua:
SWEP.Base = "arccw_base_melee"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.AdminOnly = false


SWEP.Slot = 0

SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Galactic Republic Shield"
SWEP.Trivia_Class = "Ballistic Shield"
SWEP.Trivia_Desc = "Anti-blaster fire shield for the grand army of the Republic. Stops blaster fire, specially from those damm clankers."
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/atts/republic_shield.png"

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_republicshield.mdl"
SWEP.WorldModel = "models/arccw/kraken/republic/v_republicshield.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(0, 15, -12),
    ang = Angle(0, 0, 180 - 15)
}

SWEP.ShieldProps = {
    {
        Model = "models/arccw/kraken/republic/v_republicshield.mdl",
        Pos = Vector(0, -15, -12),
        Ang = Angle(0, 0, 180 - 15),
        Resistance = 100
    }
}

SWEP.PrimaryBash = true

SWEP.SpeedMult = 0.85

SWEP.MeleeDamage = 35
SWEP.MeleeRange = 32
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 1
SWEP.MeleeGesture = ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE
SWEP.MeleeAttackTime = 0

SWEP.MeleeSwingSound = {
    "kraken/cgi/shield/shield_push_01.wav",
}
SWEP.MeleeHitSound = {
    "kraken/cgi/shield/shield_push_01.wav",
}
SWEP.MeleeHitNPCSound = {
    "kraken/cgi/shield/shield_push_01.wav",
}

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "MELEE"
    },
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "melee2"

SWEP.Primary.ClipSize = -1

SWEP.Animations = {
    ["draw"] = {
        Source = "deploy",
    },
    -- ["idle"] = {
    --     Source = {"idle1", "idle2"}
    -- },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
        Time = 2,
    },
}

SWEP.IronSightStruct = false

SWEP.ActivePos = Vector(0, 0, 1)

SWEP.BashPreparePos = Vector(0, 0, 0)
SWEP.BashPrepareAng = Angle(0, 5, 0)

SWEP.CustomizePos = Vector(15, 5, 0)
SWEP.CustomizeAng = Angle(0, 60, 0)

SWEP.BashPos = Vector(0, 0, 0)
SWEP.BashAng = Angle(10, -10, 0)

SWEP.HolsterPos = Vector(0, -1, 2)
SWEP.HolsterAng = Angle(-15, 0, 0)

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipStart",
    channel = 16,
    volume = 1.0,
    sound = "kraken/cgi/shield/shield_equip_04.wav"
})

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipEnd",
    channel = 16,
    volume = 1.0,
    sound = "kraken/cgi/shield/shield_equip_05.wav"
})
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_rg4d.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_s5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "S-5"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The Security S-5 was a heavy blaster pistol produced by Theed Arms for the Royal Naboo Security Forces. This weapon was commonly used by members of the Security Officer Corps."
SWEP.Trivia_Manufacturer = "Theed Arms"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/s5.png"

-- Base
SWEP.DefaultBodygroups = "002000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_s5.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 25
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 8

SWEP.Recoil = 0.6
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.2

SWEP.Delay = 60 / 340
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_S5"
SWEP.ShootSound = "ArcCW_Kraken.SW_S5"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.045, -11.296, 1.5),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -1.95, -3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0, -1.3, 10.3),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.36, -1.35, 8),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.8, -1.45, -6.8),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.45, -1.4, -4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_s5c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "S-5c"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The Security S-5 was a heavy blaster pistol produced by Theed Arms for the Royal Naboo Security Forces. This weapon was commonly used by members of the Security Officer Corps."
SWEP.Trivia_Manufacturer = "Theed Arms"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/s5c.png"

-- Base
SWEP.DefaultBodygroups = "010000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_s5.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 7
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 45
SWEP.DamageMin = 29
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 1
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_S5"
SWEP.ShootSound = "ArcCW_Kraken.SW_S5"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.045, -11.296, 1.3),
    Ang = Angle(0.5,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -1.95, -3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0, -1.4, 10.3),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.36, -1.35, 8),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.8, -1.45, -6.8),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.45, -1.4, -4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_weapon_g125.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Explosives - Weapons"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "G-125"
SWEP.Trivia_Class = "Projectile Launcher"
SWEP.Trivia_Desc = "The G125 projectile launcher was a weapon used by First Order jet troopers in combat during the First Order-Resistance War"
SWEP.Trivia_Manufacturer = "Sonn-Blas Corporation"
SWEP.Trivia_Calibre = "Plasma"
SWEP.IconOverride = "entities/kraken/explosives/g125.png"

-- Base
SWEP.DefaultBodygroups = "0000000000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_g125.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-8.6, 5.5, -4),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 17
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 34
SWEP.DamageMin = 32
SWEP.RangeMin = 0
SWEP.Range = 320
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 29

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.Recoil = 1.2
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 430
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
		Mode = -3,
        PostBurstDelay = 0.1,
    },
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 500

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 120
SWEP.ShootPitch = 95
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/explosives/g125/g125.wav"
SWEP.ShootSound = "kraken/explosives/g125/g125.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass_GL"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.761, 0, 1.199),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_up.ogg",
     SwitchFromSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_down.ogg",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "dlt34",
                Scale = Vector(0, 0, 0),                
                Offset = {
                    pos = Vector(-2, 2, 17),
                    ang = Angle(90, 0, 0),
                },
                IsMuzzleDevice = true,
            }
         }, 
    },
}

SWEP.Attachments = {
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dlt34", 
        Offset = {
            vpos = Vector(-0.8, 0, 10),
            vang = Angle(90, 0, -180),
        },
    },   
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },  
    {
        PrintName = "Mode", 
        DefaultAttName = "Blaster",
        Slot = "g125_mode",
    }, 
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.85, -0.05, 4.3),
            vang = Angle(90, 0, -90),
        },
    },         
}


-- Animations!

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 0.6,
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "overheat", 
        Mult = 2.2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_x8.lua:
return gluapack()()
--PATH lua/weapons/arccw_sg6.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_dlt19d.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Empire"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DLT-19d"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The DLT-19D heavy blaster rifle was a long-range heavy blaster rifle, longblaster and a variant of the DLT-19 heavy blaster rifle, featuring a scope and two underbarrel devices, one of which was a glowrod."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/dlt19d.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_dlt19d.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 132
SWEP.DamageMin = 87
SWEP.RangeMin = 0
SWEP.Range = 750
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.45
SWEP.RecoilSide = 0.70
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 145
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/dlt19d.wav"
SWEP.ShootSound = "kraken/sops/dlt19d.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.843, -3.388, 2.108),
    Ang = Vector(2.805, 0.094, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, 0, 34),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(0.90, -2.75, 6),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        InstalledEles = {"muzzle_attach"},
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2,1.2,1.2),
        WMScale = Vector(1.2,1.2,1.2),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.2, -0.7, 33.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.9, -0.75, 20),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Underbarrel",
        DefaultAttName = "E-11X Bipod",
        InstalledEles = {"bipod_e11x_hidden"},
        Slot = {"foregrip", "bipod_e11x"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, -0.3, 15),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.7, -0.82, 2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.8, -0.82, -1),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.6,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_firepuncher.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Empire"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Empire '773 Firepuncher"
SWEP.Trivia_Class = "Blaster-Experimental Sniper Rifle"
SWEP.Trivia_Desc = "The 773 Firepuncher rifle, also known as the 773 Firepuncher, was a model of sniper rifle manufactured by Merr-Sonn Munitions, Inc. that featured ablative coating and a wide-beam 'burning' mode."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/firepuncher_imperio.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_firepuncher_empire.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-4, 7.4, -9.5),
    ang = Angle(-30, 50, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 97
SWEP.DamageMin = 67
SWEP.RangeMin = 0
SWEP.Range = 320
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.05
SWEP.RecoilSide = 0.55
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1.45
SWEP.RecoilVMShake = 1.5

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 120
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/firepuncher/firepuncher.wav"
SWEP.ShootSound = "kraken/sops/firepuncher/firepuncher.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-1.629, -0.181, -0.202),
    Ang = Vector(0, 0, 7.673),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.SprintPos = Vector(2.019, 0, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 3, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "Crossair_rifle",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.1, 22, 0),
                   ang = Angle(0, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "Crossair_rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.1, -4.3, 2.86),
            vang = Angle(0, -90, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 180, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "Crossair_rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(0.1, 12, 0.9),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "Crossair_rifle",
        Offset = {
            vpos = Vector(1, 3, 1.6),
            vang = Angle(90, -90, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "Crossair_rifle",
        Offset = {
            vpos = Vector(1, 0, 1.6),
            vang = Angle(90, -90, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = {"fire"},
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 25 / 30},
            {s = "kraken/sops/firepuncher/reload.wav", t = 0.1 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_shortfirepuncher.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Empire"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Empire '773 Short-Firepuncher"
SWEP.Trivia_Class = "Blaster-Experimental Sniper Rifle"
SWEP.Trivia_Desc = "The 773 Firepuncher rifle, also known as the 773 Firepuncher, was a model of sniper rifle manufactured by Merr-Sonn Munitions, Inc. that featured ablative coating and a wide-beam 'burning' mode."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/shortypuncher_imperio.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00111000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_firepuncher_empire.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-4, 7.4, -9.5),
    ang = Angle(-30, 50, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 97
SWEP.DamageMin = 67
SWEP.RangeMin = 0
SWEP.Range = 320
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 1.25
SWEP.RecoilSide = 0.55
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1.45
SWEP.RecoilVMShake = 1.5

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/firepuncher/firepuncher.wav"
SWEP.ShootSound = "kraken/sops/firepuncher/firepuncher.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-1.629, -0.181, -0.202),
    Ang = Vector(0, 0, 7.673),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.SprintPos = Vector(2.019, 0, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 3, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "Crossair_rifle",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.1, 9, 2),
                   ang = Angle(0, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "Crossair_rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.1, -4.3, 2.86),
            vang = Angle(0, -90, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 180, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "Crossair_rifle",
        VMScale = Vector(1.5,1.5,1.5),
        WMScale = Vector(1.5,1.5,1.5),
        Offset = {
            vpos = Vector(0.1, 8, 2),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "Crossair_rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.6, 2, 1.5),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "Crossair_rifle",
        Offset = {
            vpos = Vector(1, 3, 1.6),
            vang = Angle(90, -90, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "Crossair_rifle",
        Offset = {
            vpos = Vector(1, 0, 1.6),
            vang = Angle(90, -90, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = {"fire"},
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 25 / 30},
            {s = "kraken/sops/firepuncher/reload.wav", t = 0.1 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_de10.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_de10.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DE-10"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DE-10 blaster pistol was a stylish and reliable heavy blaster pistol that was manufactured by Antrech Arms, a subsidiary of BlasTech Industries. It was vaunted for its reliability and ease of maintenance, and heavily resembled a slugthrower revolver."
SWEP.Trivia_Manufacturer = "Antrech Arms"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/de10.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_de10.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 45
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 190
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 1
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/de10.wav"
SWEP.ShootSound = "kraken/sops/de10.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-6.237, -5.169, 3.355),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(-3, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.25, -1, 14),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.18, -1.8, 4.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "a180",
        Offset = {
            vpos = Vector(0.25, -1.4, 11),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.5, -0.9, 8),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.6, 0.4, 2.8),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.5, -0.83, 5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}

--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_deadmansrevenge.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "'Dead Man's Revenge'"
SWEP.Trivia_Class = "Lever-Action Blaster"
SWEP.Trivia_Desc = "Galactic Lever-Action rifle. Unkown origin. 'Long, short, they all end the same way.'"
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Capsule"
SWEP.IconOverride = "entities/kraken/sops/deadmansrevenge.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/c_dead_mans_revenge.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11.3, 6, -3),
    ang = Angle(-15, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.9,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.ShotgunReload = true
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 95
SWEP.ShellScale = 2

SWEP.Damage = 132
SWEP.DamageMin = 87
SWEP.RangeMin = 0
SWEP.Range = 750
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 14

SWEP.Recoil = 1.25
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/deadmanstale/deadmansfire1.wav"
SWEP.ShootSound = "kraken/sops/deadmanstale/deadmansfire2.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.25, -10.363, -0.104),
    Ang = Vector(0, -0.03, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, -5, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.Attachments = {     
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },  
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle_retracted",
    },
	["fire"] = {
        Source = "shoot",
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "shootiron",
        ShellEjectAt = 0,
    },
    ["sgreload_start"] = {
        Source = "start reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "kraken/sops/deadmanstale/deadmansreloadstart.wav", t = 0.1},
                    },
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0,
    },
    ["sgreload_insert"] = {
        Source = "insert",
        RestoreAmmo = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "kraken/sops/deadmanstale/deadmansreloadinsert.wav", t = 3/30},
                    },
        TPAnimStartTime = 0.3,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["sgreload_finish"] = {
        Source = "finish reload",
        SoundTable = {
                        {s = "kraken/sops/deadmanstale/deadmansreloadend.wav", t = 0.01},
                    },
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.4,
    },  
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "kraken/sops/deadmanstale/deadmansdraw.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "kraken/sops/deadmanstale/deadmansdraw.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_tl30.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "TL-30"
SWEP.Trivia_Class = "Blaster Repeater"
SWEP.Trivia_Desc = "A blaster repeater which is a compact, rapid-fire weapon with a sleek design, often featuring a barrel that extends forward. It is known for its high rate of fire and is commonly used by soldiers or bounty hunters in battle. This weapon is a powerful, efficient, and ideal for close to medium-range combat."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/tl30.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_tl30.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 40
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 18
SWEP.DamageMin = 13
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.6
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 800
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "kraken/sops/tl30.wav"
SWEP.ShootSound = "kraken/sops/tl30.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.855, -4.439, 2.759),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -1, 25),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.2, -2.5, 4),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        InstalledEles = {"muzzle_attach"},
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.4,1.4,1.4),
        WMScale = Vector(1.4,1.4,1.4),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.12, -1.8, 26.6),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.7, -1.85, 19.5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.1, 0.2, 15),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.6, -0.8, 10.5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.8, -1.35, 5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_773firepuncher.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_dlt23v.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Republic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DLT-23V"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "In need of a heavy weapon capable of destroying Rebel scum, Blastech Industries designed and created a portable destruction machine. The DLT-23v was born with a single objective: that nothing and no one who is the target remains alive."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/dlt23v.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_dlt23v_republica.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11.3, 1.5, -7),
    ang = Angle(-10, 5, 220),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 10
SWEP.HeatLockout = false
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.1

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 30
SWEP.DamageMin = 13
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.55
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 0.9
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 230
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/dlt24x.wav"
SWEP.ShootSound = "kraken/sops/dlt24x.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = false

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "shotgun"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.Attachments = {     
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },     
}


-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "kraken/sops/dlt23/dlt23v_reload6.wav", t = 0.1/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 150 / 30},
        },
    },
}

-- Special properties
SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_x11.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_z6chaingun.lua:
return gluapack()()
--PATH lua/weapons/awhg_bobs_gun_base/cl_init.lua:
return gluapack()()
--PATH lua/weapons/carkeys.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/weapons/cityworker_config.lua:
SWEP.PrintName              = "Configurator"
SWEP.Author                 = "Silhouhat"
SWEP.Purpose                = "City Worker"
SWEP.Instructions           = "LMB to add a new position\nRMB to delete an existing position\nReload to update existing positions."

SWEP.Category               = "City Worker"
SWEP.Spawnable              = true
SWEP.AdminOnly              = true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		    = "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		    = "none"

SWEP.Weight			        = 5
SWEP.AutoSwitchTo		    = false
SWEP.AutoSwitchFrom		    = false

SWEP.Slot			        = 2
SWEP.SlotPos			    = 1
SWEP.DrawAmmo			    = false
SWEP.DrawCrosshair		    = true

SWEP.ViewModel	    	    = "models/weapons/c_toolgun.mdl"
SWEP.WorldModel	        	= "models/weapons/w_toolgun.mdl"


function SWEP:Initialize()
    self:SetHoldType( "revolver" )
end

local cwEnts = {
    ["Fire Hydrant"] = "cityworker_hydrant",
    ["Leak"] = "cityworker_leak",
    ["Rubble"] = "cityworker_rubble",
    ["Electrical"] = "cityworker_electric"
}

function SWEP:PrimaryAttack()
    if not IsFirstTimePredicted() then return end
    self:SetNextPrimaryFire( CurTime() + 0.2 )

    if CLIENT and not self.spawnmenu then
        self.spawnmenu = vgui.Create( "DMenu" )
        self.spawnmenu:Center()

        for name, class in pairs( cwEnts ) do
            local entry = self.spawnmenu:AddOption( name )
            entry.cwClass = class
            entry:SetIcon( "icon16/add.png" )
        end

        self.spawnmenu.OptionSelected = function( pnl, option, optionText )
            local class = option.cwClass

            net.Start( "CITYWORKER.Add" )
                net.WriteString( class )
            net.SendToServer()
        end

        self.spawnmenu.OnRemove = function()
            gui.EnableScreenClicker( false )
            self.spawnmenu = false
        end

        gui.EnableScreenClicker( true )
    end
end

local reloadDelay = 0

function SWEP:Reload()
    if SERVER then
        if reloadDelay > CurTime() then return end

        reloadDelay = CurTime() + 1

        CITYWORKER.SendData( self.Owner )
    end
end

function SWEP:SecondaryAttack()
    if not IsFirstTimePredicted() then return end
    self:SetNextSecondaryFire( CurTime() + 0.2 )

    if CLIENT then
        Derma_StringRequest( "Remove city worker task position.", "What is the id of the city worker task you'd like to remove?", "1", function( str )
            if not str then return end
            local id = tonumber( str )
            if not id then return end

            if id > 255 then return end
        
            net.Start( "CITYWORKER.Remove" )
                net.WriteUInt( id, 8 )
            net.SendToServer()
        end )
    end
end

function SWEP:Think()
    -- Because SWEP:Initialize() doesn't seem to work with this.
    if SERVER and not self.hasSendCWData then
        self.hasSendCWData = true
        CITYWORKER.SendData( self.Owner )
    end
end

if CLIENT then

    local CW_DEFINITIONS = {
        ["cityworker_rubble"] = "Rubble",
        ["cityworker_hydrant"] = "Fire Hydrant",
        ["cityworker_leak"] = "Leak",
        ["cityworker_electric"] = "Electrical",
    }

    local jobPositions = {}

    function SWEP:DrawHUD()
        for k, v in pairs( jobPositions ) do
            local scrPos = v.pos:ToScreen()

            draw.SimpleTextOutlined( "ID: "..k, "Trebuchet18", scrPos.x, scrPos.y - 15, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color( 0, 0, 0 ) )
            draw.SimpleTextOutlined( CW_DEFINITIONS[v.class], "Trebuchet18", scrPos.x, scrPos.y, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color( 0, 0, 0 ) )
            --draw.SimpleTextOutlined( math.ceil( ( LocalPlayer():GetPos():Distance( v.pos ) / 16 ) / 3.28084 ).."m", "Trebuchet18", scrPos.x, scrPos.y + 15, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color( 0, 0, 0 ) )
        end
    end

    net.Receive( "CITYWORKER.SendData", function()
        jobPositions = net.ReadTable()
    end )

end
--PATH lua/weapons/climb_swep2/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/door_ram/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Slot = 5
    SWEP.SlotPos = 1
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

-- Variables that are used on both client and server
DEFINE_BASECLASS("weapon_cs_base2")

SWEP.PrintName = "Battering Ram"
SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left click to break open doors/unfreeze props or get people out of their vehicles\nRight click to raise"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPDoorRam = true

SWEP.IconLetter = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/weapons/c_rpg.mdl")
SWEP.WorldModel = Model("models/weapons/w_rocket_launcher.mdl")
SWEP.AnimPrefix = "rpg"

SWEP.UseHands = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"

SWEP.Sound = Sound("physics/wood/wood_box_impact_hard3.wav")

SWEP.Primary.ClipSize = -1      -- Size of a clip
SWEP.Primary.DefaultClip = 0        -- Default number of bullets in a clip
SWEP.Primary.Automatic = false      -- Automatic/Semi Auto
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1        -- Size of a clip
SWEP.Secondary.DefaultClip = 0     -- Default number of bullets in a clip
SWEP.Secondary.Automatic = false     -- Automatic/Semi Auto
SWEP.Secondary.Ammo = ""

--[[---------------------------------------------------------
Name: SWEP:Initialize()
Desc: Called when the weapon is first loaded
---------------------------------------------------------]]
function SWEP:Initialize()
    if CLIENT then self.LastIron = CurTime() end
    self:SetHoldType("normal")
end

function SWEP:Holster()
    self:SetIronsights(false)

    return true
end

-- Check whether an object of this player can be rammed
local function canRam(ply)
    return IsValid(ply) and (ply.warranted == true or ply:isWanted() or ply:isArrested())
end

-- Ram action when ramming a door
local function ramDoor(ply, trace, ent)
    if ply:EyePos():DistToSqr(trace.HitPos) > 2025 or (not GAMEMODE.Config.canforcedooropen and ent:getKeysNonOwnable()) then return false end

    local allowed = false

    -- if we need a warrant to get in
    if GAMEMODE.Config.doorwarrants and ent:isKeysOwned() and not ent:isKeysOwnedBy(ply) then
        -- if anyone who owns this door has a warrant for their arrest
        -- allow the police to smash the door in
        for _, v in ipairs(player.GetAll()) do
            if ent:isKeysOwnedBy(v) and canRam(v) then
                allowed = true
                break
            end
        end
    else
        -- door warrants not needed, allow warrantless entry
        allowed = true
    end

    -- Be able to open the door if any member of the door group is warranted
    local keysDoorGroup = ent:getKeysDoorGroup()
    if GAMEMODE.Config.doorwarrants and keysDoorGroup then
        local teamDoors = RPExtraTeamDoors[keysDoorGroup]
        if teamDoors then
            allowed = false
            for _, v in ipairs(player.GetAll()) do
                if table.HasValue(teamDoors, v:Team()) and canRam(v) then
                    allowed = true
                    break
                end
            end
        end
    end

    if CLIENT then return allowed end

    -- Do we have a warrant for this player?
    if not allowed then
        DarkRP.notify(ply, 1, 5, DarkRP.getPhrase("warrant_required"))

        return false
    end

    ent:keysUnLock()
    ent:Fire("open", "", .6)
    ent:Fire("setanimation", "open", .6)

    return true
end

-- Ram action when ramming a vehicle
local function ramVehicle(ply, trace, ent)
    if ply:EyePos():DistToSqr(trace.HitPos) > 10000 then return false end

    if CLIENT then return false end -- Ideally this would return true after ent:GetDriver() check

    local driver = ent:GetDriver()
    if not IsValid(driver) or not driver.ExitVehicle then return false end

    driver:ExitVehicle()
    ent:keysLock()

    return true
end

-- Ram action when ramming a fading door
local function ramFadingDoor(ply, trace, ent)
    if ply:EyePos():DistToSqr(trace.HitPos) > 10000 then return false end

    local Owner = ent:CPPIGetOwner()

    if CLIENT then return canRam(Owner) end

    if not canRam(Owner) then
        DarkRP.notify(ply, 1, 5, DarkRP.getPhrase("warrant_required"))
        return false
    end

    if not ent.fadeActive then
        ent:fadeActivate()
        timer.Simple(5, function() if IsValid(ent) and ent.fadeActive then ent:fadeDeactivate() end end)
    end

    return true
end

-- Ram action when ramming a frozen prop
local function ramProp(ply, trace, ent)
    if ply:EyePos():DistToSqr(trace.HitPos) > 10000 then return false end
    if ent:GetClass() ~= "prop_physics" then return false end

    local Owner = ent:CPPIGetOwner()

    if CLIENT then return canRam(Owner) end

    if not canRam(Owner) then
        DarkRP.notify(ply, 1, 5, DarkRP.getPhrase(GAMEMODE.Config.copscanunweld and "warrant_required_unweld" or "warrant_required_unfreeze"))
        return false
    end

    if GAMEMODE.Config.copscanunweld then
        constraint.RemoveConstraints(ent, "Weld")
    end

    if GAMEMODE.Config.copscanunfreeze then
        ent:GetPhysicsObject():EnableMotion(true)
    end

    return true
end

-- Decides the behaviour of the ram function for the given entity
local function getRamFunction(ply, trace)
    local ent = trace.Entity

    if not IsValid(ent) then return fp{fn.Id, false} end

    local override = hook.Call("canDoorRam", nil, ply, trace, ent)

    return
        override ~= nil     and fp{fn.Id, override}                                 or
        ent:isDoor()        and fp{ramDoor, ply, trace, ent}                        or
        ent:IsVehicle()     and fp{ramVehicle, ply, trace, ent}                     or
        ent.fadeActivate    and fp{ramFadingDoor, ply, trace, ent}                  or
        ent:GetPhysicsObject():IsValid() and not ent:GetPhysicsObject():IsMoveable()
                                         and fp{ramProp, ply, trace, ent}           or
        fp{fn.Id, false} -- no ramming was performed
end

--[[---------------------------------------------------------
Name: SWEP:PrimaryAttack()
Desc: +attack1 has been pressed
---------------------------------------------------------]]
function SWEP:PrimaryAttack()
    if not self:GetIronsights() then return end

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    self:SetNextPrimaryFire(CurTime() + 0.1)

    Owner:LagCompensation(true)
    local trace = Owner:GetEyeTrace()
    Owner:LagCompensation(false)

    local hasRammed = getRamFunction(Owner, trace)()

    if SERVER then
        hook.Call("onDoorRamUsed", GAMEMODE, hasRammed, Owner, trace)
    end

    if not hasRammed then return end

    self:SetNextPrimaryFire(CurTime() + 2.5)

    self:SetTotalUsedMagCount(self:GetTotalUsedMagCount() + 1)

    Owner:SetAnimation(PLAYER_ATTACK1)
    Owner:EmitSound(self.Sound)
    Owner:ViewPunch(Angle(-10, math.Round(util.SharedRandom("DarkRP_DoorRam" .. self:EntIndex() .. "_" .. self:GetTotalUsedMagCount(), -5, 5)), 0))
end

function SWEP:SecondaryAttack()
    if CLIENT then self.LastIron = CurTime() end
    self:SetNextSecondaryFire(CurTime() + 0.30)
    self:SetIronsights(not self:GetIronsights())
    if self:GetIronsights() then
        self:SetHoldType("rpg")
    else
        self:SetHoldType("normal")
    end
end

function SWEP:GetViewModelPosition(pos, ang)
    local Mul = 1

    if self.LastIron > CurTime() - 0.25 then
        Mul = math.Clamp((CurTime() - self.LastIron) / 0.25, 0, 1)
    end

    if self:GetIronsights() then
        Mul = 1-Mul
    end

    ang:RotateAroundAxis(ang:Right(), - 15 * Mul)
    return pos,ang
end

DarkRP.hookStub{
    name = "canDoorRam",
    description = "Called when a player attempts to ram something. Use this to override ram behaviour or to disallow ramming.",
    parameters = {
        {
            name = "ply",
            description = "The player using the door ram.",
            type = "Player"
        },
        {
            name = "trace",
            description = "The trace containing information about the hit position and ram entity.",
            type = "table"
        },
        {
            name = "ent",
            description = "Short for the entity that is about to be hit by the door ram.",
            type = "Entity"
        }
    },
    returns = {
        {
            name = "override",
            description = "Return true to override behaviour, false to disallow ramming and nil (or no value) to defer the decision.",
            type = "boolean"
        }
    },
    realm = "Shared"
}

if SERVER then
    DarkRP.hookStub{
        name = "onDoorRamUsed",
        description = "Called when the door ram has been used.",
        parameters = {
            {
                name = "success",
                description = "Whether the door ram has been successful in ramming.",
                type = "boolean"
            },
            {
                name = "ply",
                description = "The player that used the door ram.",
                type = "Player"
            },
            {
                name = "trace",
                description = "The trace containing information about the hit position and ram entity.",
                type = "table"
            }
        },
        returns = {

        }
    }
end

hook.Add("SetupMove", "DarkRP_DoorRamJump", function(ply, mv)
    local wep = ply:GetActiveWeapon()
    if not wep:IsValid() or wep:GetClass() ~= "door_ram" or not wep.GetIronsights or not wep:GetIronsights() then return end

    mv:SetButtons(bit.band(mv:GetButtons(), bit.bnot(IN_JUMP)))
end)

--PATH lua/weapons/gmod_tool/stools/advdupe2.lua:
return gluapack()()
--PATH gamemodes/sandbox/entities/weapons/gmod_tool/stools/lvsaienabler.lua:

TOOL.Category		= "LVS"
TOOL.Name			= "#AI Enabler"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "team" ] = "-1"

if CLIENT then
	language.Add( "tool.lvsaienabler.name", "AI Enabler" )
	language.Add( "tool.lvsaienabler.desc", "A tool used to enable/disable AI on LVS-Vehicles" )
	language.Add( "tool.lvsaienabler.0", "Left click on a LVS-Vehicle to enable AI, Right click to disable." )
	language.Add( "tool.lvsaienabler.1", "Left click on a LVS-Vehicle to enable AI, Right click to disable." )
end

function TOOL:LeftClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if isfunction( ent.SetAI ) then
		ent:SetAI( true )
	end

	if SERVER then
		local Team = self:GetClientNumber( "team" )

		if Team ~= -1 then
			ent:SetAITEAM( math.Clamp( Team, 0, 3 ) )
		end
	end

	return true
end

function TOOL:RightClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if isfunction( ent.SetAI ) then
		ent:SetAI( false )
	end

	return true
end

function TOOL:Reload( trace )
	return false
end

function TOOL.BuildCPanel( CPanel )
	CPanel:AddControl( "Header", { Text = "#tool.lvsaienabler.name", Description	= "#tool.lvsaienabler.desc" }  )

	CPanel:AddControl( "Slider", { Label = "TeamOverride", Type = "Int", Min = -1, Max = 3, Command = "lvsaienabler_team" } )
end

--PATH gamemodes/sandbox/entities/weapons/gmod_tool/stools/lvshealthshieldeditor.lua:
return gluapack()()
--PATH addons/[misc] smartspawnmanager/lua/weapons/gmod_tool/stools/smart_entity_spawn.lua:
//
/*
	Smart Prop Control - Ghost Zone Tool 
	Smart Like My Shoe 
	3/3/2018
*/


TOOL.Category       = "Smart' s Tools";
TOOL.Name           = "#Entity Spawns";
TOOL.Command        = nil;
TOOL.ConfigName     = "";
 
TOOL.ClientConVar["auto_uniqueid"]			 	= "0";
TOOL.ClientConVar["class"]			 			= "Default";
TOOL.ClientConVar["uniqueid"]			 		= "Default";
TOOL.ClientConVar["delay"]						= "60";
TOOL.ClientConVar["pitch"]						= "0";
TOOL.ClientConVar["yaw"]						= "0";
TOOL.ClientConVar["roll"]						= "0";
TOOL.ClientConVar["limit"]						= "1";


function TOOL:LeftClick(trace)
	
	local autoGenerateUniqueID = self:GetClientInfo("auto_uniqueid");
	local class = self:GetClientInfo("class");
	local uniqueID = self:GetClientInfo("uniqueid");
	local delay = tonumber(self:GetClientInfo("delay"));
	local ang = Angle(tonumber(self:GetClientInfo("pitch")), tonumber(self:GetClientInfo("yaw")), tonumber(self:GetClientInfo("roll")));
	local limit = tonumber(self:GetClientInfo("limit"));
	
	hook.Call("smartspawn_addentityspawn", nil, class, uniqueID, trace.HitPos + trace.HitNormal * 10, ang, delay, limit, autoGenerateUniqueID);
	return true;
end

function TOOL:RightClick(trace)

	if (SERVER) then 
	
		if (IsValid(trace.Entity)) then 
			
			local ang = trace.Entity:GetAngles();
			
			local class = trace.Entity:GetClass();
			if (trace.Entity.VehicleName != nil) then 
				class = trace.Entity.VehicleName;
			end
			
			local p = self:GetOwner();
			
			p:ConCommand("smart_entity_spawn_class " .. class);
			p:ConCommand("smart_entity_spawn_pitch " .. ang.p);
			p:ConCommand("smart_entity_spawn_yaw " .. ang.y);
			p:ConCommand("smart_entity_spawn_roll " .. ang.r);
			
			p:ConCommand("smart_entity_spawn_tool_updatecpanel");
			
		end 
	end
	
	return true;
end 

function TOOL:Reload(trace)
end

function TOOL:Deploy()
end 

function TOOL:Holster()
end 

function TOOL:Think()

end 

if (CLIENT) then 

	// Top left hud language strings
	language.Add("Tool.smart_entity_spawn.name", "Entity Spawn Manager");
    language.Add("Tool.smart_entity_spawn.desc", "Manage entity spawn locations.");
    language.Add("Tool.smart_entity_spawn.0", "Primary: Create spawn location | Right click: Copy entity class");
	
	// Undo language 
	//language.Add("Undone_smart_npc", "Undone Smart Npc!");
	
	// Derma utility methods 
	local function MakeLabel(text, font)
	
		font = font || "Trebuchet18";
	
		local l = vgui.Create("DLabel");
		l:SetText(text);
		l:SetFont(font);
		l:SetTextColor(Color(0,0,0,255));
		l:SizeToContents();
		
		return l;
	end
	
	// Control panel (derma)
	local function BuildCPanel(panel)
		panel:ClearControls();
		
		panel:AddItem(MakeLabel("Class"));
		
		local classSelect = vgui.Create("DTextEntry");
		classSelect:SetText(GetConVarString("smart_entity_spawn_class"));
		classSelect.OnValueChange = function(s, value)
			RunConsoleCommand("smart_entity_spawn_class", value);
		end 
		classSelect:SetUpdateOnType(true);
		panel:AddItem(classSelect);
		
		panel:AddItem(MakeLabel("Spawn Delay (seconds)"));
		
		local delay = vgui.Create("DNumSlider");
		delay:SetMin(1);
		delay:SetMax(1000);
		delay:SetConVar("smart_entity_spawn_delay");
		delay:SetText("Delay");
		delay.Label:SetTextColor(color_black);
		
		panel:AddItem(delay);
		
		local pitch = vgui.Create("DNumSlider");
		pitch:SetMin(1);
		pitch:SetMax(360);
		pitch:SetConVar("smart_entity_spawn_pitch");
		pitch:SetText("Pitch");
		pitch.Label:SetTextColor(color_black);
		
		panel:AddItem(pitch);
		
		local yaw = vgui.Create("DNumSlider");
		yaw:SetMin(1);
		yaw:SetMax(360);
		yaw:SetConVar("smart_entity_spawn_yaw");
		yaw:SetText("Yaw");
		yaw.Label:SetTextColor(color_black);
		
		panel:AddItem(yaw);
		
		local roll = vgui.Create("DNumSlider");
		roll:SetMin(1);
		roll:SetMax(360);
		roll:SetConVar("smart_entity_spawn_roll");
		roll:SetText("Roll");
		roll.Label:SetTextColor(color_black);
		
		panel:AddItem(roll);
		
		panel:AddItem(MakeLabel("Unique ID"));
		
		local uniqueID = vgui.Create("DTextEntry");
		uniqueID:SetText("Some Unique Name");
		uniqueID.OnValueChange = function(s, value)
			RunConsoleCommand("smart_entity_spawn_uniqueid", value);
		end
		uniqueID:SetUpdateOnType(true);
		
		panel:AddItem(uniqueID);
		
		local autoUniqueID = vgui.Create("DCheckBoxLabel");
		autoUniqueID:SetText("Automatically generate unique ID");
		autoUniqueID:SetTextColor(color_black);
		autoUniqueID:SetConVar("smart_entity_spawn_auto_uniqueid");
		panel:AddItem(autoUniqueID);
		
		local limit = vgui.Create("DNumSlider");
		limit:SetDecimals(0);
		limit:SetText("Entity Limit");
		limit.Label:SetTextColor(color_black);
		limit:SetConVar("smart_entity_spawn_limit");
		limit:SetMin(0);
		limit:SetMax(999);
		
		panel:AddItem(MakeLabel("0 Limit = Infinite entities"));
		
		panel:AddItem(limit);
	end
	
	// Called when player selects this tool for the first time
    function TOOL.BuildCPanel(panel)
		
        BuildCPanel(panel);
    end
	
	local function UpdateCPanel()
		local panel = controlpanel.Get("smart_entity_spawn");
        if (!panel) then 
			return;
		end
        BuildCPanel(panel);
    end
    concommand.Add("smart_entity_spawn_tool_updatecpanel", UpdateCPanel);
end
--PATH lua/weapons/gmod_tool/stools/vjstool_notarget.lua:
TOOL.Name = "#tool.vjstool_notarget.name"
TOOL.Tab = "DrVrej"
TOOL.Category = "Tools"
TOOL.Command = nil -- The console command to execute upon being selected in the Q menu.

TOOL.Information = {
	{name = "left"},
	{name = "right"},
}
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	local function DoBuildCPanel_NoTarget(Panel)
		Panel:AddControl("Label", {Text = "#tool.vjstool_notarget.label"})
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	function TOOL.BuildCPanel(Panel)
		DoBuildCPanel_NoTarget(Panel)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:LeftClick(tr)
	if CLIENT then return true end
	local Ply = self:GetOwner()
	if Ply:IsFlagSet(FL_NOTARGET) != true then
		Ply:ChatPrint("#tool.vjstool_notarget.print.yourselfon")
		Ply:AddFlags(FL_NOTARGET)
		return true
	else
		Ply:ChatPrint("#tool.vjstool_notarget.print.yourselfoff")
		Ply:RemoveFlags(FL_NOTARGET)
		return true
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:RightClick(tr)
	if CLIENT then return true end
	if !IsValid(tr.Entity) then return false end
	local Ply = self:GetOwner()
	local Ent = tr.Entity
	
	local name = Ent:IsPlayer() and Ent:Nick() or Ent:GetClass()
	if Ent:IsFlagSet(FL_NOTARGET) != true then
		Ply:ChatPrint("Set no target to "..name..": ON")
		Ent:AddFlags(FL_NOTARGET)
		return true
	else
		Ply:ChatPrint("Set no target to "..name..": OFF")
		Ent:RemoveFlags(FL_NOTARGET)
		return true
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function TOOL:Reload(tr)
	if CLIENT then return true end
	return false
end
--PATH lua/weapons/gmod_tool/stools/vjstool_npcspawner.lua:
return gluapack()()
--PATH lua/weapons/jet_mk6.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/keys/shared.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_cgshield.lua:
SWEP.Base = "arccw_base_melee"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.AdminOnly = false

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Coruscant Guard Shield"
SWEP.Trivia_Class = "Shield"
SWEP.Trivia_Desc = "Anti-blaster fire shield for the grand army of the Republic. Stops blaster fire, specially from those damm clankers."
SWEP.Trivia_Manufacturer = "Grand Army of the Republic"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/coruscantguard_shield.png"

SWEP.Slot = 0

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw_cg/v_shield.mdl"
SWEP.WorldModel = "models/weapons/arccw_cg/v_shield.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(0, 15, -12),
    ang = Angle(0, 0, 180 - 15)
}

SWEP.ShieldProps = {
    {
        Model = "models/weapons/arccw_cg/v_shield.mdl",
        Pos = Vector(0, -15, -12),
        Ang = Angle(0, 0, 180 - 15),
        Resistance = 100
    }
}

SWEP.PrimaryBash = true

SWEP.SpeedMult = 0.85

SWEP.MeleeDamage = 50
SWEP.MeleeRange = 32
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 1
SWEP.MeleeGesture = ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE
SWEP.MeleeAttackTime = 0

SWEP.MeleeSwingSound = {
    "arccw_go/shield/shield_push_01.wav",
}
SWEP.MeleeHitSound = {
    "physics/metal/metal_barrel_impact_hard7.wav",
}
SWEP.MeleeHitNPCSound = {
    "physics/body/body_medium_break3.wav",
}

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "MELEE"
    },
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "melee2"

SWEP.Primary.ClipSize = -1

SWEP.Animations = {
    ["draw"] = {
        Source = "deploy",
    },
    -- ["idle"] = {
    --     Source = {"idle1", "idle2"}
    -- },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
        Time = 2,
    },
}

SWEP.IronSightStruct = false

SWEP.ActivePos = Vector(0, 0, 3)

SWEP.BashPreparePos = Vector(0, 0, 0)
SWEP.BashPrepareAng = Angle(0, 5, 0)

SWEP.CustomizePos = Vector(15, 5, 0)
SWEP.CustomizeAng = Angle(0, 60, 0)

SWEP.BashPos = Vector(0, 0, 0)
SWEP.BashAng = Angle(10, -10, 0)

SWEP.HolsterPos = Vector(0, -1, 2)
SWEP.HolsterAng = Angle(-15, 0, 0)

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipStart",
    channel = 16,
    volume = 1.0,
    sound = "arccw_go/shield/shield_equip_04.wav"
})

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipEnd",
    channel = 16,
    volume = 1.0,
    sound = "arccw_go/shield/shield_equip_05.wav"
})
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_cr2.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15s_grenadier.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15s Grenadier"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s_grenadier.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/servius/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/servius/starwars/w_dc15s.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.6,
    [HITGROUP_CHEST] = 1.2,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 37
SWEP.RangeMin = 198
SWEP.DamageMin = 21
SWEP.Range = 399
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 255

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.837, 0.619, 1.656),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.6, -0.5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Grenade Launcher",
        DefaultAttName = "None",
        Slot = "rep_ubgl",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1, 1.663),
            vang = Angle(90, 0, -90),
        },          
    },
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Bone = "DC15",
        Slot = "stock",
        Offset = {
            vpos = Vector(0, 0.5, -9.1),
            vang = Angle(0, 0, -90),
        },
    }, 
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.1, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },    
    {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15s_train.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17 hand blaster, also known as DC-17 blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17.png"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/venator/weapons/viewmodels/c_dc17.mdl"
SWEP.WorldModel = "models/venator/weapons/worldmodels/w_dc-17.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-11.3, 4.3, -3),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 29
SWEP.RangeMin = 102
SWEP.DamageMin = 23
SWEP.Range = 299
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.98
SWEP.RecoilPunch = 0.8
SWEP.RecoilSide = 0.17
SWEP.RecoilRise = 0.24

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = -2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 
SWEP.HipDispersion = 530
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

---- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.922, -4.125, 0.237),
    Ang = Vector(0.158, -3.961, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.Primary.Ammo = "ar2"

-- Sound & Holdtype
SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/dc17_2.wav"
SWEP.ShootSound = "armas/disparos/dc17_1.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 6, 1)
SWEP.ActiveAng = Angle(-3.2, -3, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, -1.08)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["dc17_powerpack"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        },
    },
    ["dc17_cooling"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
        },
    },
}


SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -2.3, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(9, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        WMScale = Vector(0.7, 0.7, 0.7),
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -0.3, 2.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -1.2, 3.442),
            vang = Angle(90, 0, -90),
        },
    }, 
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },        
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Cooling System",
        DefaultAttName = "None",
        Slot = "dc17_cooling",
    },
    {
        PrintName = "Powerpack",
        DefaultAttName = "None",
        Slot = "dc17_powerpack",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7,0.7,0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, 0.184),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, -3),
            vang = Angle(90, 0, -90),
        },
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "dc17_1", t = 1 / 60}, --s sound file
        },
    },


sound.Add({
    name =          "dc17_1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armasclasicas/wpn_wristrocket_reload.wav"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17_train.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dual_dc17.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Dual DC-17"
SWEP.Trivia_Class = "Dual Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17s hand blaster, also known as DC-17s blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers. This one version is a powerful one."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2024
SWEP.IconOverride = "entities/masita/dual_dc17.png"

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_akimbo_dc17.mdl"
SWEP.WorldModel = "models/rising/base/c_akimbo.mdl"

SWEP.ViewModelFOV = 65

SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_STOMACH] = 1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.9,
    [HITGROUP_RIGHTLEG] = 0.9,
}

SWEP.Damage = 32
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 4000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 0

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.6
SWEP.Recoil = 0.7

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 1
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 125 
SWEP.SightsDispersion = 0 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 1.1
SWEP.SightedSpeedMult = 0.77
SWEP.ShootSpeedMult = 1

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 120
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "armas/disparos/dc17_1.wav"
SWEP.ShootSound = "armas/disparos/dc17_2.wav"
SWEP.ShootSoundSilenced = "weapons/silenced.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = false
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 90,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.MovingPos = Vector(0, -1.5, -0.8)
SWEP.MovingAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(0, -1.5, -1)
SWEP.CrouchAng = Angle(0, 0, -5)

SWEP.SprintPos = Vector(-1, 0, -1)
SWEP.SprintAng = Angle(0, 0, -5)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

--SWEP.Attachments 

--SWEP.Attachments 
SWEP.DefaultElements = {"dc17"}
SWEP.AttachmentElements = {
    ["dc17"] = {
        WMElements = {
            {
                Model = "models/venator/weapons/worldmodels/w_dc-17.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-45, 15, 10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/venator/weapons/worldmodels/w_dc-17.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-135, 230, -35),
                    ang = Angle(180, -180, 2)
                }
            },
        },   
    }
}
WMOverride = "models/venator/weapons/worldmodels/w_dc-17.mdl"

SWEP.Attachments = {   
    [1] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


local path = "kraken/republic/dc17/"

SWEP.Animations = {
    ["fire"] = {
        Source = {"fire_right", "fire_left"}
    },
    ["reload"] = {
        Source = "reload_short",
		MinProgress = 0.725,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
			{s = path .. "wfoly_pi_mike1911_reload_empty_lift.ogg", t = 0/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_empty_lift.ogg", t = 4/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magout_01.ogg", t = 6/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_empty_magout_01.ogg", t = 10/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magin_v2_01.ogg", t = 49/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magin_v2_01.ogg", t = 52/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magin_v2_02.ogg", t = 54/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_magin_01.ogg", t = 54/30},
			{s = path .. "wfoly_pi_mike1911_reload_end.ogg", t = 62/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_end.ogg", t = 62/30},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
		MinProgress = 0.8,
        SoundTable = {
			{s = path .. "wfoly_pi_mike1911_reload_empty_lift.ogg", t = 0/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_empty_lift.ogg", t = 5/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magout_01.ogg", t = 7/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_empty_magout_01.ogg", t = 12/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_magin_v2_01.ogg", t = 52/30},
			{s = path .. "wfoly_pi_mike1911_fast_reload_empty_magin_01.ogg", t = 54/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_end.ogg", t = 60/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_end.ogg", t = 61/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_chamber_01.ogg", t = 73/30},
			{s = path .. "wfoly_pi_mike1911_reload_empty_chamber_01.ogg", t = 76/30},
        },
    },
    ["ready"] = {
        Source = "draw_first",
        SoundTable = {
            {s = path .. "wfoly_pi_mike1911_first_raise_lift.ogg", t = 0/30},
            {s = path .. "wfoly_pi_mike1911_first_raise_slide_pull.ogg", t = 24/30},
			{s = path .. "wfoly_pi_mike1911_first_raise_slide_release.ogg", t = 25/30},
			{s = path .. "wfoly_pi_mike1911_first_raise_chamber_end.ogg", t = 28/30},
        },
    },
    ["draw"] = {
        Source = "draw",
		MinProgress = 0.3,
        FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_pi_mike1911_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_pi_mike1911_reload_empty_end.ogg", t = 0/30},
            {s = path .. "wfoly_pi_mike1911_fast_reload_end.ogg", t = 5/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Time = 0.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		Time = 0.25,
    },
    ["enter_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.1,
		FireASAP = true,
        SoundTable = {
            {s = path .. "wfoly_pi_mike1911_inspect_01.ogg", t = 0/30},
			{s = path .. "wfoly_pi_mike1911_inspect_02.ogg", t = 36/30},
			{s = path .. "wfoly_pi_mike1911_inspect_03.ogg", t = 61/30},
			{s = path .. "wfoly_pi_mike1911_inspect_04.ogg", t = 112/30},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
    },
}

--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dual_dc17s.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dual_dc17s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Dual DC-17s"
SWEP.Trivia_Class = "Heavy Dual Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17s hand blaster, also known as DC-17s blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers. This one version is a powerful one."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2024
SWEP.IconOverride = "entities/masita/dual_dc17s_red.png"

SWEP.Slot = 1

SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/republic/v_akimbo_dc17s.mdl"
SWEP.WorldModel = "models/rising/base/c_akimbo.mdl"
SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.DefaultBodygroups = "000000000000"
SWEP.NoHideLeftHandInCustomization = true

SWEP.Damage = 45
SWEP.RangeMin = 100
SWEP.DamageMin = 17
SWEP.Range = 370
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 0

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.78
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 348
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },        
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootSound = "armas/disparos/dc17s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -2)

SWEP.CustomizePos = Vector(0, 4, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"dc17"}

SWEP.AttachmentElements = {
    ["dc17"] = {
        WMElements = {
            {
                Model = "models/weapon/ven/ggn/dc17s_single_world.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/weapon/ven/ggn/dc17s_single_world.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/weapon/ven/ggn/dc17s_single_world.mdl"

--SWEP.Attachments 
SWEP.Attachments = {   
    [1] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


local path = "kraken/republic/dc17s/"

SWEP.Animations = {
    ["fire"] = {
        Source = {"shoot1_right", "shoot1_left"},
    },
    ["reload"] = {
        Source = "reload",
		MinProgress = 0.95,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
		    {s = "kraken/movement1.wav", t = 0/30},
            {s = path .. "usp_clipout.wav", t = 5/30},
            {s = path .. "usp_clipout.wav", t = 8/30},
			{s = "kraken/movement2.wav", t = 19/30},
			{s = path .. "usp_clipin.wav", t = 45/30},
			{s = path .. "usp_clipin.wav", t = 55/30},
			{s = "kraken/movement3.wav", t = 65/30},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
		MinProgress = 0.95,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
		    {s = "kraken/movement1.wav", t = 0/30},
            {s = path .. "usp_clipout.wav", t = 7/30},
            {s = path .. "usp_clipout.wav", t = 8/30},
			{s = "kraken/movement2.wav", t = 19/30},
            {s = path .. "usp_clipin.wav", t = 50/30},
            {s = path .. "usp_clipin.wav", t = 55/30},
			{s = "kraken/movement3.wav", t = 65/30},
            {s = path .. "usp_sliderelease.wav", t = 75/30},
            {s = path .. "usp_sliderelease.wav", t = 77/30},
        },
    },
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = path .. "usp_draw.wav", t = 0/30},
            {s = path .. "usp_sliderelease.wav", t = 11/30},
            {s = path .. "usp_sliderelease.wav", t = 14/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "CSGO.Item.Movement", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 1,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 1,
    },
    ["idle_inspect"] = {
        Source = "lookat01",
        SoundTable = {
            {p = 100, s = "weapon_hand/reload_gentle/other/023d-00000adb.mp3", t = 1 / 30 },
            {p = 100, s = "weapon_hand/reload_gentle/other/023d-00000adb.mp3", t = 96 / 30 },
            {p = 100, s = "weapon_hand/reload_gentle/other/023d-00000adb.mp3", t = 170 / 30},
    },
    },
    ["enter_inspect"] = {
        Source = "lookat01",
        SoundTable = {
            {p = 100, s = "weapon_hand/reload_gentle/other/023d-00000adb.mp3", t = 1 / 30 },
            {p = 100, s = "weapon_hand/reload_gentle/other/023d-00000adb.mp3", t = 96 / 30 },
            {p = 100, s = "weapon_hand/reload_gentle/other/023d-00000adb.mp3", t = 170 / 30},
    },
    },
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_westarm5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 

SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita/Meeks"
SWEP.PrintName = "Westar M-5"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "The WESTAR-M5 blaster rifle was a blaster rifle used during the Clone Wars by the Grand Army of the Republic. They were mainly used by the Alpha-class Advanced Recon Commandos during the later years of the conflict."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/westarm5.png"

SWEP.ViewModel = "models/ser/starwars/c_westarm5.mdl"
SWEP.WorldModel = "models/ser/starwars/w_westarm5.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 1
SWEP.DefaultWMSkin = 1

SWEP.NoHideLeftHandInCustomization = false

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1.3,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 36
SWEP.DamageMin = 22 -- damage done at maximum range
SWEP.RangeMin = 170 -- how far bullets will retain their maximum damage for
SWEP.Range = 290 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false

SWEP.MuzzleVelocity = 472

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3
SWEP.TracerNum = 1 
SWEP.TracerFinalMag = 0 
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 47, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 50 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0
SWEP.MaxRecoilBlowback = 1
SWEP.VisualRecoilMult = 1

SWEP.RecoilDirection = Angle(0.2, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 527 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 2 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
	{
		Mode = 2,
   	},
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 447 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 60 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 157 -- dispersion that remains even in sights
SWEP.JumpDispersion = 220 -- dispersion penalty when in the air

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 125 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/dlt20.wav"
SWEP.ShootSound = "everfall/weapons/dlt-20a/blasters_dlt20a_laser_close_var_01.mp3"
SWEP.ShootSoundSilenced = "everfall/weapons/deadeye/blasters_deadeye_laser_close_var_01.mp3"
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false 

SWEP.MuzzleEffectAttachment = 1 
SWEP.ProceduralViewBobAttachment = 1
SWEP.MuzzleFlashColor = Color(0, 102, 255)

SWEP.SpeedMult = 0.87
SWEP.SightedSpeedMult = 0.77
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -0, 2.1),
    Ang = Angle(0, 0, 0),
    Midpoint = {
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1.2,
    SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
    SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0


SWEP.Malfunction = false
SWEP.MalfunctionJam = true 
SWEP.MalfunctionTakeRound = true 
SWEP.MalfunctionWait = 0.5 
SWEP.MalfunctionMean = nil 
SWEP.MalfunctionVariance = 0.25
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 27
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2
SWEP.SprintPos = Vector(.5, -6, -12)
SWEP.SprintAng = Angle(40, 0, 0)
SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)
SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)
SWEP.ActivePos = Vector(0, 3, 1)
SWEP.ActiveAng = Angle(0, 0, 0)
SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.CustomizePos = Vector(6.824, -7, 4.897)
SWEP.CustomizeAng = Angle(12.149, 45.547, 45)
SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        WMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(15, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, 
    },
}

SWEP.Attachments = {
	{
		PrintName = "Sight",
		DefaultAttName = "Standard",
		Slot = "optic",
		Bone = "weapon",
		Offset = {
            vpos = Vector(0.02, -2.4, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1, -7),
            wang = Angle(-10, 2, 180)
        },
	},
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(0.8, -0.8, 4),
            vang = Angle(90, 0, -0),
            wpos = Vector(7, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
    },
    {
        PrintName = "Charms", 
        DefaultAttName = "None",
        Slot = {"charm"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(1, -1, -3.2),
            vang = Angle(90, 0, -90),
            wpos = Vector(1.2, 2.2, -4.5),
            wang = Angle(0, 0, 180)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "No Attachment", 
        Slot = "foregrip",
        Bone = "weapon",
        Offset = {
            vpos = Vector(0, 2.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, .5, -1.5),
            wang = Angle(0, 0, 180)            
        },
        NoWM = true,
        NoVM = true,    
    },
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk", 
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
		Bone = "weapon",
        Offset = {
            vpos = Vector(0, -0.9, 8.1),
            vang = Angle(90, 0, 0),
            wpos = Vector(16, .5, -7.2),
            wang = Angle(-10, 0, -90)
        },
    },                              
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "fire",
    },
	["idle_sights"] = {
        Source = "idle",
        Mult = 10000,
    },
	["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {s = "armas/misc/westar_reload.mp3", t = 0.1 }
        },
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_02.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "everfall/weapons/handling/023d-00000d8c.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--PATH gamemodes/starwarsrp/entities/weapons/pocket/cl_menu.lua:
local meta = FindMetaTable("Player")
local pocket = {}
local frame
local reload

--[[---------------------------------------------------------------------------
Stubs
---------------------------------------------------------------------------]]
DarkRP.stub{
    name = "openPocketMenu",
    description = "Open the DarkRP pocket menu.",
    realm = "Client",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP
}

--[[---------------------------------------------------------------------------
Interface functions
---------------------------------------------------------------------------]]
function meta:getPocketItems()
    if self ~= LocalPlayer() then return nil end

    return pocket
end

function DarkRP.openPocketMenu()
    if IsValid(frame) and frame:IsVisible() then return end
    local wep = LocalPlayer():GetActiveWeapon()
    if not wep:IsValid() or wep:GetClass() ~= "pocket" then return end

    if not pocket then
        pocket = {}

        return
    end

    if table.IsEmpty(pocket) then return end
    frame = vgui.Create("DFrame")

    local count = GAMEMODE.Config.pocketitems or GM.Config.pocketitems
    frame:SetSize(345, 32 + 64 * math.ceil(count / 5) + 3 * math.ceil(count / 5))
    frame:SetTitle(DarkRP.getPhrase("drop_item"))
    frame.btnMaxim:SetVisible(false)
    frame.btnMinim:SetVisible(false)
    frame:SetDraggable(false)
    frame:MakePopup()
    frame:Center()

    local Scroll = vgui.Create("DScrollPanel", frame)
    Scroll:Dock(FILL)

    local sbar = Scroll:GetVBar()
    sbar:SetWide(3)
    frame.List = vgui.Create("DIconLayout", Scroll)
    frame.List:Dock(FILL)
    frame.List:SetSpaceY(3)
    frame.List:SetSpaceX(3)
    reload()
    frame:SetSkin(GAMEMODE.Config.DarkRPSkin)
end
net.Receive("DarkRP_PocketMenu", DarkRP.openPocketMenu)

--[[---------------------------------------------------------------------------
UI
---------------------------------------------------------------------------]]
function reload()
    if not IsValid(frame) or not frame:IsVisible() then return end
    if not pocket or next(pocket) == nil then frame:Close() return end

    local itemCount = table.Count(pocket)

    frame.List:Clear()
    local items = {}

    for k, v in pairs(pocket) do
        local ListItem = frame.List:Add("DPanel")
        ListItem:SetSize(64, 64)

        local icon = vgui.Create("SpawnIcon", ListItem)
        icon:SetModel(v.model)
        icon:SetSize(64, 64)
        icon:SetTooltip()
        icon.DoClick = function(self)
            icon:SetTooltip()

            net.Start("DarkRP_spawnPocket")
                net.WriteFloat(k)
            net.SendToServer()
            pocket[k] = nil

            itemCount = itemCount - 1

            if itemCount == 0 then
                frame:Close()
                return
            end

            fn.Map(self.Remove, items)
            items = {}

            local wep = LocalPlayer():GetActiveWeapon()

            wep:SetHoldType("pistol")
            timer.Simple(0.2, function()
                if wep:IsValid() then
                    wep:SetHoldType("normal")
                end
            end)
        end

        table.insert(items, icon)
    end
    if itemCount < GAMEMODE.Config.pocketitems then
        for _ = 1, GAMEMODE.Config.pocketitems - itemCount do
            local ListItem = frame.List:Add("DPanel")
            ListItem:SetSize(64, 64)
        end
    end
end

local function retrievePocket()
    pocket = net.ReadTable()
    reload()
end
net.Receive("DarkRP_Pocket", retrievePocket)

--PATH lua/weapons/tfa_bash_base.lua:
return gluapack()()
--PATH lua/weapons/tfa_bow_base.lua:
if SERVER then
	AddCSLuaFile()
end

SWEP.IsBow = true

DEFINE_BASECLASS("tfa_gun_base")
--primary stats
SWEP.Primary.Spread = 0.001
SWEP.Primary.SpreadShake = 0.05 --when shaking
SWEP.Primary.Velocity = 64 --velocity in m/s
SWEP.Primary.Damage_Charge = {0.2, 1} --velocity/damage multiplier between min and max charge
SWEP.Primary.Shake = true --enable shaking
--options
SWEP.Secondary.Cancel = true --enable cancelling
--bow base shit
SWEP.ChargeRate = 30 / 75 --1 is fully charged
SWEP.ChargeThreshold = 0.75 --minimum charge percent to fire
SWEP.ShakeTime = 5 --minimum time to start shaking
SWEP.Secondary.IronSightsEnabled = false
--tfa ballistics integration
SWEP.UseBallistics = true
SWEP.BulletModel = "models/weapons/w_tfa_arrow.mdl"
SWEP.BulletTracer = ""

--animation
SWEP.BowAnimations = {
	["shake"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "tiredloop",
		["enabled"] = true --Manually force a sequence to be enabled
	},
	["shoot"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "fire_1",
		["enabled"] = true --Manually force a sequence to be enabled
	},
	["cancel"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "cancelarrow",
		["enabled"] = true --Manually force a sequence to be enabled
	},
	["draw"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "drawarrow",
		["enabled"] = true --Manually force a sequence to be enabled
	}
}

--["idle_charged"] = {["type"] = TFA.Enum.ANIMATION_SEQ, ["value"] = "idle_charged", ["enabled"] = true }
function SWEP:SetupDataTables(...)
	BaseClass.SetupDataTables(self, ...)

	self:NetworkVarTFA("Bool", "Shaking")
	self:NetworkVarTFA("Float", "Charge")
end

function SWEP:GetChargeTime()
	return self:GetCharge() / self.ChargeRate
end

function SWEP:ShouldShake()
	return self:GetChargeTime() >= self.ShakeTime
end

function SWEP:Deploy(...)
	self:SetCharge(0)
	self:SetShaking(false)

	return BaseClass.Deploy(self, ...)
end

function SWEP:Charge(t)
	self:SetCharge(self:GetCharge() + self.ChargeRate * t)
end

local sp = game.SinglePlayer()
local ft

function SWEP:Think2(...)
	ft = FrameTime()

	if self:GetStatus() == TFA.Enum.STATUS_BOW_CANCEL and self:GetStatusEnd() > CurTime() then
		self:SetCharge(0)
		self:SetShaking(false)
	end

	if TFA.Enum.ReadyStatus[self:GetStatus()] and self:CanPrimaryAttack() then
		if self:GetOwner():KeyDown(IN_ATTACK2) and self:GetCharge() > self.ChargeThreshold then
			self:PlayAnimation(self.BowAnimations.cancel)
			self:ScheduleStatus(TFA.Enum.STATUS_BOW_CANCEL, self:GetActivityLength())
		elseif self:GetOwner():KeyDown(IN_ATTACK) then
			if self:GetCharge() <= 0 then
				self:PlayAnimation(self.BowAnimations.draw)
				self:SetCharge(0.01)
				self:SetShaking(false)
			end

			self:Charge(ft)

			if self:ShouldShake() and not self:GetShaking() then
				self:SetShaking(true)
				self:PlayAnimation(self.BowAnimations.shake)
			end
		else
			local c = self:GetCharge()

			if c > self.ChargeThreshold then
				self:Shoot()
			elseif c > 0 then
				self:Charge(ft)
			end
		end
	elseif self:GetCharge() > 0 then
		if TFA.Enum.ReadyStatus[self:GetStatus()] then
			if self:GetCharge() > self.ChargeThreshold then
				self:PlayAnimation(self.BowAnimations.cancel)
				self:ScheduleStatus(TFA.Enum.STATUS_BOW_CANCEL, self:GetActivityLength())
			else
				self.Idle_ModeOld = self.Idle_Mode
				self:ClearStatCache("Idle_Mode")
				self.Idle_Mode = TFA.Enum.IDLE_BOTH
				self:ChooseIdleAnim()
				self.Idle_Mode = self.Idle_ModeOld
			end
		end

		self:SetCharge(0)
		self:SetShaking(false)
	end

	if IsFirstTimePredicted() or game.SinglePlayer() then
		self.Primary_TFA.SpreadBase = self.Primary_TFA.SpreadBase or self:GetStatL("Primary.Spread")
		local targ = self:GetShaking() and self.Primary_TFA.SpreadShake or self:GetStatL("Primary.SpreadBase")
		self.Primary_TFA.Spread = math.Approach(self.Primary_TFA.Spread, targ, (targ - self.Primary_TFA.Spread) * FrameTime() * 5)
		self:ClearStatCache("Primary.Spread")
	end

	BaseClass.Think2(self, ...)
end

function SWEP:Shoot()
	if self:GetStatL("Primary.Sound") and IsFirstTimePredicted()  and not ( sp and CLIENT ) then
		if self:GetStatL("Primary.SilencedSound") and self:GetSilenced() then
			self:EmitSound(self:GetStatL("Primary.SilencedSound")   )
		else
			self:EmitSound(self:GetStatL("Primary.Sound"))
		end
	end
	self:TakePrimaryAmmo(self:GetStatL("Primary.AmmoConsumption"))
	self:PlayAnimation(self.BowAnimations.shoot)
	self:ShootBulletInformation()
	self:SetCharge(0)
	self:SetShaking(false)
	self:ScheduleStatus(TFA.Enum.STATUS_BOW_SHOOT, 0.1)
end

function SWEP:ChooseIdleAnim(...)
	if self:GetShaking() then
		return self:PlayAnimation(self.BowAnimations.shake)
	elseif self:GetCharge() > 0 and self.BowAnimations["idle_charged"] then
		return self:PlayAnimation(self.BowAnimations.idle_charged)
	end

	return BaseClass.ChooseIdleAnim(self, ...)
end

function SWEP:PrimaryAttack()
end

function SWEP:SecondaryAttack()
end

SWEP.MainBullet = {}
SWEP.MainBullet.Spread = Vector()
local ballistics_distcv = GetConVar("sv_tfa_ballistics_mindist")

local function BallisticFirebullet(ply, bul, ovr)
	local wep = ply:GetActiveWeapon()

	if TFA.Ballistics and TFA.Ballistics:ShouldUse(wep) then
		if ballistics_distcv:GetInt() == -1 or ply:GetEyeTrace().HitPos:Distance(ply:GetShootPos()) > (ballistics_distcv:GetFloat() * TFA.Ballistics.UnitScale) then
			bul.SmokeParticle = bul.SmokeParticle or wep.BulletTracer or wep.TracerBallistic or wep.BallisticTracer or wep.BallisticsTracer

			if ovr then
				TFA.Ballistics:FireBullets(wep, bul, angle_zero, true)
			else
				TFA.Ballistics:FireBullets(wep, bul)
			end
		else
			ply:FireBullets(bul)
		end
	else
		ply:FireBullets(bul)
	end
end

--[[
Function Name:  ShootBulletInformation
Syntax: self:ShootBulletInformation().
Returns:   Nothing.
Notes:  Used to generate a self.MainBullet table which is then sent to self:ShootBullet, and also to call shooteffects.
Purpose:  Bullet
]]
--
local cv_dmg_mult = GetConVar("sv_tfa_damage_multiplier")
local cv_dmg_mult_min = GetConVar("sv_tfa_damage_mult_min")
local cv_dmg_mult_max = GetConVar("sv_tfa_damage_mult_max")
local dmg, con, rec

function SWEP:ShootBulletInformation()
	self:UpdateConDamage()
	self.lastbul = nil
	self.lastbulnoric = false
	self.ConDamageMultiplier = cv_dmg_mult:GetFloat()
	if not IsFirstTimePredicted() then return end
	con, rec = self:CalculateConeRecoil()
	local tmpranddamage = math.Rand(cv_dmg_mult_min:GetFloat(), cv_dmg_mult_max:GetFloat())
	local basedamage = self.ConDamageMultiplier * self:GetStatL("Primary.Damage")
	dmg = basedamage * tmpranddamage
	local ns = self:GetStatL("Primary.NumShots")
	local clip = (self:GetStatL("Primary.ClipSize") == -1) and self:Ammo1() or self:Clip1()
	ns = math.Round(ns, math.min(clip / self:GetStatL("Primary.NumShots"), 1))
	self:ShootBullet(dmg, rec, ns, con)
end

--[[
Function Name:  ShootBullet
Syntax: self:ShootBullet(damage, recoil, number of bullets, spray cone, disable ricochet, override the generated self.MainBullet table with this value if you send it).
Returns:   Nothing.
Notes:  Used to shoot a self.MainBullet.
Purpose:  Bullet
]]
--
local cv_forcemult = GetConVar("sv_tfa_force_multiplier")

local AttachArrowModel = function(a, b, c, wep)
	c:SetDamageType(bit.bor(DMG_NEVERGIB, DMG_CLUB))
	if CLIENT then return end
	if not IsValid(wep) then return end

	if b.HitWorld and not (IsValid(b.Entity) and not b.Entity:IsWorld()) then
		local arrowstuck = ents.Create("tfbow_arrow_stuck")
		arrowstuck:SetModel(wep:GetStatL("BulletModel"))
		arrowstuck.gun = wep:GetClass()
		arrowstuck:SetPos(b.HitPos)
		arrowstuck:SetAngles(b.Normal:Angle())
		arrowstuck:Spawn()
	else
		local arrowstuck = ents.Create("tfbow_arrow_stuck_clientside")
		arrowstuck:SetModel(wep:GetStatL("BulletModel"))
		arrowstuck:SetModel(wep:GetStatL("BulletModel"))
		arrowstuck.gun = wep:GetClass()
		arrowstuck:SetPos(b.HitPos)
		arrowstuck:SetAngles(b.Normal:Angle())
		arrowstuck.targent = b.Entity
		arrowstuck.targphysbone = b.PhysicsBone or -1
		arrowstuck:Spawn()
	end
end

function SWEP:AutoDetectForce()
	if self:GetStatRawL("Primary.Force") == -1 or not self:GetStatRawL("Primary.Force") then
		self:SetStatRawL("Primary.Force", self:GetStatRawL("Force") or self:GetStatRawL("Primary.Damage") / 6 * math.sqrt(self:GetStatRawL("Primary.KickUp") + self:GetStatRawL("Primary.KickDown") + self:GetStatRawL("Primary.KickHorizontal")))
	end
end

function SWEP:ShootBullet(damage, recoil, num_bullets, aimcone, disablericochet, bulletoverride)
	if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
	local chargeTable = self:GetStatL("Primary.Damage_Charge")
	local mult = Lerp(math.Clamp(self:GetCharge() - self.ChargeThreshold, 0, 1 - self.ChargeThreshold) / (1 - self.ChargeThreshold), chargeTable[1], chargeTable[2])
	local unitScale = TFA.Ballistics.UnitScale or TFA.UnitScale or 40
	num_bullets = num_bullets or 1
	aimcone = aimcone or 0
	self.MainBullet.Attacker = self:GetOwner()
	self.MainBullet.Inflictor = self
	self.MainBullet.Num = num_bullets
	self.MainBullet.Src = self:GetOwner():GetShootPos()
	self.MainBullet.Dir = self:GetOwner():EyeAngles():Forward()
	self.MainBullet.HullSize = 0
	self.MainBullet.Spread.x = aimcone
	self.MainBullet.Spread.y = aimcone

	if self.TracerPCF then
		self.MainBullet.Tracer = 0
	else
		self.MainBullet.Tracer = self:GetStatL("TracerCount") or 3
	end

	self.MainBullet.PenetrationCount = 0
	self.MainBullet.AmmoType = self:GetPrimaryAmmoType()
	self.MainBullet.Force = self:GetStatL("Primary.Force") * cv_forcemult:GetFloat() * self:GetAmmoForceMultiplier() * mult
	self.MainBullet.Damage = damage * mult
	self.MainBullet.HasAppliedRange = false
	self.MainBullet.Velocity = self:GetStatL("Primary.Velocity") * mult * unitScale

	self.MainBullet.Callback = function(a, b, c)
		if IsValid(self) then
			c:SetInflictor(self)
		end

		if self.MainBullet.Callback2 then
			self.MainBullet.Callback2(a, b, c)
		end

		self:CallAttFunc("CustomBulletCallback", a, b, c)

		if SERVER and IsValid(a) and a:IsPlayer() and IsValid(b.Entity) and (b.Entity:IsPlayer() or b.Entity:IsNPC() or type(b.Entity) == "NextBot") then
			self:SendHitMarker(a, b, c)
		end

		AttachArrowModel(a, b, c, self)
	end

	BallisticFirebullet(self:GetOwner(), self.MainBullet)
end

TFA.FillMissingMetaValues(SWEP)

--PATH lua/weapons/tfa_gun_base/common/attachments.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/events.lua:
local lshift = bit.lshift
local band = bit.band
local bor = bit.bor

local sp = game.SinglePlayer()
local l_CT = CurTime

local is, spr, wlk, cst

--[[
Function Name:  ResetEvents
Syntax: self:ResetEvents()
Returns:  Nothing.
Purpose:  Cleans up events table.
]]--
function SWEP:ResetEvents()
	self:SetEventStatus1(0x00000000)
	self:SetEventStatus2(0x00000000)
	self:SetEventStatus3(0x00000000)
	self:SetEventStatus4(0x00000000)
	self:SetEventStatus5(0x00000000)
	self:SetEventStatus6(0x00000000)
	self:SetEventStatus7(0x00000000)
	self:SetEventStatus8(0x00000000)

	self:SetEventTimer(l_CT())
	-- self:SetFirstDeployEvent(false)

	if self.EventTable then
		for _, eventtable in pairs(self.EventTable) do
			for i = 1, #eventtable do
				eventtable[i].called = false
			end
		end
	end

	if self.event_table_overflow then
		local editcts = self.EventTableEdict

		if editcts[0] then
			editcts[0].called = false

			for i = 1, #editcts do
				editcts[i].called = false
			end
		end
	end

	if sp then
		self:CallOnClient("ResetEvents", "")
	end
end

function SWEP:GetEventPlayed(event_slot)
	if self.event_table_overflow then
		return assert(self.EventTableEdict[event_slot], string.format("Unknown event %d", event_slot)).called
	end

	local inner_index = event_slot % 32
	local outer_index = (event_slot - inner_index) / 32 + 1
	local lindex = lshift(1, inner_index)
	return band(self.get_event_status_lut[outer_index](self), lindex) ~= 0, inner_index, outer_index, lindex
end

function SWEP:SetEventPlayed(event_slot)
	if self.event_table_overflow then
		assert(self.EventTableEdict[event_slot], string.format("Unknown event %d", event_slot)).called = true
		return
	end

	local inner_index = event_slot % 32
	local outer_index = (event_slot - inner_index) / 32 + 1
	local lindex = lshift(1, inner_index)

	self.set_event_status_lut[outer_index](self, bor(self.get_event_status_lut[outer_index](self), lindex))
	return inner_index, outer_index, lindex
end

--[[
Function Name:  ProcessEvents
Syntax: self:ProcessEvents().
Returns:  Nothing.
Notes: Critical for the event table to function.
Purpose:  Main SWEP function
]]--

SWEP._EventSlotCount = 0
SWEP.EventTableEdict = {}

function SWEP:DispatchLuaEvent(arg)
	if not self.event_table_built then
		self:RebuildEventEdictTable()
	end

	local fn = assert(assert(self.EventTableEdict[tonumber(arg)], "No such event with edict " .. arg).value, "Event is missing a function to call")
	assert(isfunction(fn), "Event " .. arg .. " is not a Lua event")
	fn(self, self:VMIV(), true)
end

function SWEP:DispatchBodygroupEvent(arg)
	if not self.event_table_built then
		self:RebuildEventEdictTable()
	end

	local event = assert(self.EventTableEdict[tonumber(arg)], "No such event with edict " .. arg)
	assert(isstring(event.name), "Event " .. arg .. " is missing bodygroup name to set")
	assert(isstring(event.value), "Event " .. arg .. " is missing bodygroup value to set")

	if event.view then
		self.ViewModelBodygroups[event.name] = event.value
	end

	if event.world then
		self.WorldModelBodygroups[event.name] = event.value
	end
end

local isstring = isstring

local function eventtablesorter(a, b)
	local sa, sb = isstring(a), isstring(b)

	if sa and not sb or not sa and sb then
		if sa then
			return false
		end

		return true
	end

	return a < b
end

function SWEP:RebuildEventEdictTable()
	local self2 = self:GetTable()
	local slot = 0

	for i = #self2.EventTableEdict, 0, -1 do
		self2.EventTableEdict[i] = nil
	end

	self:ResetEvents()

	local eventtable = self2.EventTable
	eventtable.BaseClass = nil

	local keys = table.GetKeys(eventtable)
	table.sort(keys, eventtablesorter)

	for _, key in ipairs(keys) do
		local value = eventtable[key]

		if istable(value) then
			for _, event in SortedPairs(value) do
				if istable(event) then
					event.slot = slot
					slot = slot + 1

					if not event.autodetect then
						if event.type == "lua" then
							if event.server == nil then
								event.server = true
							end
						elseif event.type == "snd" or event.type == "sound" then
							if event.server == nil then
								event.server = false
							end
						elseif event.type == "bg" or event.type == "bodygroup" then
							if event.server == nil then event.server = true end
							if event.view == nil then event.view = true end
							if event.world == nil then event.world = true end
						end

						if event.client == nil then
							event.client = true
						end

						event.autodetect = true
					end

					event.called = false

					if slot > 256 and not self.event_table_warning then
						ErrorNoHalt("[TFA Base] Weapon " .. self:GetClass() .. " got too many events! 256 is maximum! Event table would NOT be properly predicted this time!\n")
						self.event_table_warning = true
					end

					self2.EventTableEdict[event.slot] = event
				end
			end
		end
	end

	self.event_table_overflow = slot > 256
	self._built_event_debug_string_fn = nil

	self._EventSlotCount = math.ceil(slot / 32)
	self._EventSlotNum = slot - 1
	self.event_table_built = true
end

function SWEP:ProcessEvents(firstprediction)
	local viewmodel = self:VMIVNPC()
	if not viewmodel then return end

	if not self.event_table_built then
		self:RebuildEventEdictTable()
	end

	if sp and CLIENT then return end
	if sp and SERVER then return self:ProcessEventsSP() end

	local ply = self:GetOwner()
	local isplayer = ply:IsPlayer()

	local evtbl = self.EventTable[self:GetLastActivity() or -1] or self.EventTable[viewmodel:GetSequenceName(viewmodel:GetSequence())]
	if not evtbl then return end

	local curtime = l_CT()
	local eventtimer = self:GetEventTimer()
	local is_local = CLIENT and ply == LocalPlayer()
	local animrate = self:GetAnimationRate(self:GetLastActivity() or -1)

	self.current_event_iftp = firstprediction
	self.processing_events = true

	for i = 1, #evtbl do
		local event = evtbl[i]
		if self:GetEventPlayed(event.slot) or curtime < eventtimer + event.time / animrate then goto CONTINUE end
		self:SetEventPlayed(event.slot)
		event.called = true

		if not event.autodetect then
			if event.type == "lua" then
				if event.server == nil then
					event.server = true
				end
			elseif event.type == "snd" or event.type == "sound" then
				if event.server == nil then
					event.server = false
				end
			elseif event.type == "bg" or event.type == "bodygroup" then
				if event.server == nil then event.server = true end
				if event.view == nil then event.view = true end
				if event.world == nil then event.world = true end
			end

			if event.client == nil then
				event.client = true
			end

			event.autodetect = true
		end

		if event.type == "lua" then
			if ((event.client and CLIENT and (not event.client_predictedonly or is_local)) or (event.server and SERVER)) and event.value then
				event.value(self, viewmodel, firstprediction)
			end
		elseif event.type == "snd" or event.type == "sound" then
			if SERVER then
				if event.client then
					if not isplayer and player.GetCount() ~= 0 then
						net.Start("tfaSoundEvent", true)
						net.WriteEntity(self)
						net.WriteString(event.value or "")
						net.WriteBool(event.shouldpause or false)
						net.SendPVS(self:GetPos())
					elseif isplayer then
						net.Start("tfaSoundEvent", true)
						net.WriteEntity(self)
						net.WriteString(event.value or "")
						net.WriteBool(event.shouldpause or false)
						net.SendOmit(ply)
					end
				elseif event.server and event.value and event.value ~= "" then
					self:EmitSound(event.value)
				end
			elseif event.client and is_local and not sp and event.value and event.value ~= "" then
				if firstprediction or firstprediction == nil then
					if event.time <= 0.01 then
						self:EmitSoundSafe(event.value)
					else
						self:EmitSound(event.value)
					end
				end
			end
		elseif event.type == "bg" or event.type == "bodygroup" then
			if ((event.client and CLIENT and (not event.client_predictedonly or is_local)) or
				(event.server and SERVER)) and (event.name and event.value and event.value ~= "") then

				if event.view then
					self.ViewModelBodygroups[event.name] = event.value
				end

				if event.world then
					self.WorldModelBodygroups[event.name] = event.value
				end
			end
		end

		::CONTINUE::
	end

	self.processing_events = false
	self.current_event_iftp = nil
end

-- This function is exclusively targeting singleplayer
function SWEP:ProcessEventsSP(firstprediction)
	local viewmodel = self:VMIVNPC()
	if not viewmodel then return end

	local evtbl = self.EventTable[self:GetLastActivity() or -1] or self.EventTable[viewmodel:GetSequenceName(viewmodel:GetSequence())]
	if not evtbl then return end

	local curtime = l_CT()
	local eventtimer = self:GetEventTimer()
	local is_local = self:GetOwner() == Entity(1)
	local animrate = self:GetAnimationRate(self:GetLastActivity() or -1)

	self.processing_events = true

	for i = 1, #evtbl do
		local event = evtbl[i]
		if self:GetEventPlayed(event.slot) or curtime < eventtimer + event.time / animrate then goto CONTINUE end
		self:SetEventPlayed(event.slot)
		event.called = true

		if not event.autodetect then
			if event.type == "lua" then
				if event.server == nil then
					event.server = true
				end
			elseif event.type == "snd" or event.type == "sound" then
				if event.server == nil then
					event.server = false
				end
			elseif event.type == "bg" or event.type == "bodygroup" then
				if event.server == nil then event.server = true end
				if event.view == nil then event.view = true end
				if event.world == nil then event.world = true end
			end

			if event.client == nil then
				event.client = true
			end

			event.autodetect = true
		end

		if event.type == "lua" then
			if event.value then
				if event.server then
					event.value(self, viewmodel, true)
				end

				if event.client and (not event.client_predictedonly or is_local) then
					self:CallOnClient("DispatchLuaEvent", tostring(event.slot))
				end
			end
		elseif event.type == "snd" or event.type == "sound" then
			if event.client then
				net.Start("tfaSoundEvent", true)
				net.WriteEntity(self)
				net.WriteString(event.value or "")
				net.WriteBool(event.shouldpause or false)
				net.Broadcast()
			elseif event.server and event.value and event.value ~= "" then
				self:EmitSound(event.value)
			end
		elseif event.type == "bg" or event.type == "bodygroup" then
			if event.name and event.value and event.value ~= "" then
				if event.server then
					if event.view then
						self.ViewModelBodygroups[event.name] = event.value
					end

					if event.world then
						self.WorldModelBodygroups[event.name] = event.value
					end
				end

				if event.client and (not event.client_predictedonly or is_local) then
					self:CallOnClient("DispatchBodygroupEvent", tostring(event.slot))
				end
			end
		end

		::CONTINUE::
	end

	self.processing_events = false
end

function SWEP:EmitSoundSafe(snd)
	timer.Simple(0, function()
		if IsValid(self) and snd then self:EmitSound(snd) end
	end)
end

local ct, stat, statend, finalstat, waittime, lact

function SWEP:ProcessStatus()
	local self2 = self:GetTable()

	is = self2.GetIronSightsRaw(self)
	spr = self2.GetSprinting(self)
	wlk = self2.GetWalking(self)
	cst = self2.GetCustomizing(self)

	local ply = self:GetOwner()
	local isplayer = ply:IsPlayer()

	if stat == TFA.Enum.STATUS_FIDGET and is then
		self:SetStatusEnd(0)

		self2.Idle_Mode_Old = self2.Idle_Mode
		self2.Idle_Mode = TFA.Enum.IDLE_BOTH
		self2.ClearStatCache(self, "Idle_Mode")
		self2.ChooseIdleAnim(self)

		if sp then
			self:CallOnClient("ChooseIdleAnim", "")
		end

		self2.Idle_Mode = self2.Idle_Mode_Old
		self2.ClearStatCache(self, "Idle_Mode")
		self2.Idle_Mode_Old = nil
		statend = -1
	end

	is = self:GetIronSights()
	stat = self:GetStatus()
	statend = self:GetStatusEnd()

	ct = l_CT()

	if stat ~= TFA.Enum.STATUS_IDLE and ct > statend then
		self:SetFirstDeployEvent(false)
		finalstat = TFA.Enum.STATUS_IDLE

		--Holstering
		if stat == TFA.Enum.STATUS_HOLSTER then
			finalstat = TFA.Enum.STATUS_HOLSTER_READY
			self:SetStatusEnd(ct)
		elseif stat == TFA.Enum.STATUS_HOLSTER_READY then
			self2.FinishHolster(self)
			finalstat = TFA.Enum.STATUS_HOLSTER_FINAL
			self:SetStatusEnd(ct + 0.6)
		elseif stat == TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY then
			--Shotgun Reloading from empty
			if not self2.IsJammed(self) then
				self2.InsertPrimaryAmmo(self, self2.GetStatL(self, "LoopedReloadInsertAmount", 1))
			end

			if self2.Ammo1(self) <= 0 or self:Clip1() >= self2.GetPrimaryClipSize(self) or self:GetReloadLoopCancel() then
				finalstat = TFA.Enum.STATUS_RELOADING_LOOP_END
				local _, tanim, ttype = self2.ChooseShotgunPumpAnim(self)
				self:SetStatusEnd(ct + self2.GetActivityLength(self, tanim, false, ttype))
				self:SetReloadLoopCancel(false)

				if not self:GetReloadLoopCancel() then
					self:SetJammed(false)
				end
			else
				lact = self:GetLastActivity()
				waittime = self2.GetActivityLength(self, lact, false) - self2.GetActivityLength(self, lact, true)

				if waittime > 0.01 then
					finalstat = TFA.Enum.STATUS_RELOADING_WAIT
					self:SetStatusEnd(ct + waittime)
				else
					finalstat = self2.LoadShell(self)
				end

				self:SetJammed(false)
				--finalstat = self:LoadShell()
				--self:SetStatusEnd( self:GetNextPrimaryFire() )
			end
		elseif stat == TFA.Enum.STATUS_RELOADING_LOOP_START then
			--Shotgun Reloading
			finalstat = self2.LoadShell(self)
		elseif stat == TFA.Enum.STATUS_RELOADING_LOOP then
			self2.InsertPrimaryAmmo(self, self2.GetStatL(self, "LoopedReloadInsertAmount", 1))
			lact = self:GetLastActivity()

			if self2.GetActivityLength(self, lact, true) < self2.GetActivityLength(self, lact, false) - 0.01 then
				local sht = self2.GetStatL(self, "LoopedReloadInsertTime")

				if sht then
					sht = sht / self2.GetAnimationRate(self, ACT_VM_RELOAD)
				end

				waittime = (sht or self2.GetActivityLength(self, lact, false)) - self2.GetActivityLength(self, lact, true)
			else
				waittime = 0
			end

			if waittime > 0.01 then
				finalstat = TFA.Enum.STATUS_RELOADING_WAIT
				self:SetStatusEnd(ct + waittime)
			else
				if self2.Ammo1(self) <= 0 or self:Clip1() >= self:GetPrimaryClipSize() or self:GetReloadLoopCancel() then
					finalstat = TFA.Enum.STATUS_RELOADING_LOOP_END
					local _, tanim, ttype = self2.ChooseShotgunPumpAnim(self)
					self:SetStatusEnd(ct + self2.GetActivityLength(self, tanim, false, ttype))
					self:SetReloadLoopCancel(false)
				else
					finalstat = self2.LoadShell(self)
				end
			end
		elseif stat == TFA.Enum.STATUS_RELOADING then
			self2.CompleteReload(self)
			lact = self:GetLastActivity()
			waittime = self2.GetActivityLength(self, lact, false) - self2.GetActivityLength(self, lact, true)

			if waittime > 0.01 then
				finalstat = TFA.Enum.STATUS_RELOADING_WAIT
				self:SetStatusEnd(ct + waittime)
			end
		elseif stat == TFA.Enum.STATUS_SILENCER_TOGGLE then
			--self:SetStatusEnd( self:GetNextPrimaryFire() )
			self:SetSilenced(not self:GetSilenced())
			self2.Silenced = self:GetSilenced()
		elseif stat == TFA.Enum.STATUS_RELOADING_WAIT and self:GetStatL("LoopedReload") then
			if self2.Ammo1(self) <= 0 or self:Clip1() >= self:GetPrimaryClipSize() or self:GetReloadLoopCancel() then
				finalstat = TFA.Enum.STATUS_RELOADING_LOOP_END
				local _, tanim, ttype = self2.ChooseShotgunPumpAnim(self)
				self:SetStatusEnd(ct + self2.GetActivityLength(self, tanim, false, ttype))
				--self:SetReloadLoopCancel( false )
			else
				finalstat = self2.LoadShell(self)
			end
		elseif stat == TFA.Enum.STATUS_RELOADING_LOOP_END and self:GetStatL("LoopedReload") then
			self:SetReloadLoopCancel(false)
		elseif self2.GetStatL(self, "PumpAction") and stat == TFA.Enum.STATUS_PUMP then
			self:SetReloadLoopCancel(false)
		elseif stat == TFA.Enum.STATUS_SHOOTING and self2.GetStatL(self, "PumpAction") then
			if self:Clip1() == 0 and self2.GetStatL(self, "PumpAction").value_empty then
				--finalstat = TFA.Enum.STATUS_PUMP_READY
				self:SetReloadLoopCancel(true)
			elseif (self2.GetStatL(self, "Primary.ClipSize") < 0 or self:Clip1() > 0) and self2.GetStatL(self, "PumpAction").value then
				--finalstat = TFA.Enum.STATUS_PUMP_READY
				self:SetReloadLoopCancel(true)
			end
		end

		--self:SetStatusEnd( math.huge )
		self:SetStatus(finalstat)

		local sightsMode = self2.GetStatL(self, "Sights_Mode")
		local sprintMode = self2.GetStatL(self, "Sprint_Mode")
		local walkMode = self2.GetStatL(self, "Walk_Mode")
		local customizeMode = self2.GetStatL(self, "Customize_Mode")

		local smi = sightsMode ~= TFA.Enum.LOCOMOTION_LUA
		local spi = sprintMode ~= TFA.Enum.LOCOMOTION_LUA
		local wmi = walkMode ~= TFA.Enum.LOCOMOTION_LUA
		local cmi = customizeMode ~= TFA.Enum.LOCOMOTION_LUA

		if
			not TFA.Enum.ReadyStatus[stat] and
			stat ~= TFA.Enum.STATUS_SHOOTING and
			stat ~= TFA.Enum.STATUS_PUMP and
			finalstat == TFA.Enum.STATUS_IDLE and
			((smi or spi) or (cst and cmi))
		then
			is = self2.GetIronSights(self, true)

			if (is and smi) or (spr and spi) or (wlk and wmi) or (cst and cmi) then
				local success, _ = self2.Locomote(self, is and smi, is, spr and spi, spr, wlk and wmi, wlk, cst and cmi, cst)

				if success == false then
					self:SetNextIdleAnim(-1)
				else
					self:SetNextIdleAnim(math.max(self:GetNextIdleAnim(), ct + 0.1))
				end
			end
		end

		self2.LastBoltShoot = nil

		if self:GetBurstCount() > 0 then
			if finalstat ~= TFA.Enum.STATUS_SHOOTING and finalstat ~= TFA.Enum.STATUS_IDLE then
				self:SetBurstCount(0)
			elseif self:GetBurstCount() < self:GetMaxBurst() and self:Clip1() > 0 then
				self:PrimaryAttack()
			else
				self:SetBurstCount(0)
				self:SetNextPrimaryFire(self2.GetNextCorrectedPrimaryFire(self, self2.GetBurstDelay(self)))
			end
		end
	end

	--if stat == TFA.Enum.STATUS_IDLE and self:GetReloadLoopCancel() and (self2.GetStatL(self, "AllowSprintAttack") or self:GetSprintProgress() < 0.1) then
	if stat == TFA.Enum.STATUS_IDLE and self:GetReloadLoopCancel() then
		if self2.GetStatL(self, "PumpAction") then
			if ct > self:GetNextPrimaryFire() and not self:KeyDown(IN_ATTACK) then
				self2.DoPump(self)
			end
		else
			self:SetReloadLoopCancel(false)
		end
	end
end

--PATH lua/weapons/tfa_gun_base/common/nzombies.lua:
SWEP.OldPaP = false
SWEP.OldSpCola = false
SWEP.SpeedColaFactor = 2 --Amount to speed up by when u get dat speed cola
SWEP.SpeedColaActivities = {
	[ACT_VM_DRAW] = true,
	[ACT_VM_DRAW_EMPTY] = true,
	[ACT_VM_DRAW_SILENCED] = true,
	[ACT_VM_DRAW_DEPLOYED or 0] = true,
	[ACT_VM_RELOAD] = true,
	[ACT_VM_RELOAD_EMPTY] = true,
	[ACT_VM_RELOAD_SILENCED] = true,
	[ACT_VM_HOLSTER] = true,
	[ACT_VM_HOLSTER_EMPTY] = true,
	[ACT_VM_HOLSTER_SILENCED] = true,
	[ACT_SHOTGUN_RELOAD_START] = true,
	[ACT_SHOTGUN_RELOAD_FINISH] = true
}
SWEP.DTapActivities = {
	[ACT_VM_PRIMARYATTACK] = true,
	[ACT_VM_PRIMARYATTACK_EMPTY] = true,
	[ACT_VM_PRIMARYATTACK_SILENCED] = true,
	[ACT_VM_PRIMARYATTACK_1] = true,
	[ACT_VM_SECONDARYATTACK] = true,
	[ACT_VM_HITCENTER] = true,
	[ACT_SHOTGUN_PUMP] = true
}
SWEP.DTapSpeed = 1 / 0.8
SWEP.DTap2Speed = 1 / 0.8

local nzombies

local count, upperclamp

function SWEP:NZMaxAmmo()
	if nzombies == nil then
		nzombies = engine.ActiveGamemode() == "nzombies"
	end
	local at = self:GetPrimaryAmmoType()
	local at2 = self.GetSecondaryAmmoType and self:GetSecondaryAmmoType() or self.Secondary_TFA.Ammo

	if IsValid(self:GetOwner()) then
		if self:GetStatL("Primary.ClipSize") <= 0 then
			count = math.Clamp(10, 300 / (self:GetStatL("Primary.Damage") / 30), 10, 300)
			if self.Primary_TFA.NZMaxAmmo and self.Primary_TFA.NZMaxAmmo > 0 then
				count = self.Primary_TFA.NZMaxAmmo
				if self:GetPaP() then
					count = count * 5 / 3
				end
			end
			self:GetOwner():SetAmmo(count, at)
		else
			upperclamp = self:GetPaP() and 600 or 300
			count = math.Clamp(math.abs(self:GetStatL("Primary.ClipSize")) * 10, 10, upperclamp)
			count = count + self:GetStatL("Primary.ClipSize") - self:Clip1()
			if self.Primary_TFA.NZMaxAmmo and self.Primary_TFA.NZMaxAmmo > 0 then
				count = self.Primary_TFA.NZMaxAmmo
				if self:GetPaP() then
					count = count * 5 / 3
				end
			end
			self:GetOwner():SetAmmo(count, at)
		end
		if self:GetStatL("Secondary.ClipSize") > 0 or self:GetSecondaryAmmoType() >= 0 then
			if self:GetStatL("Secondary.ClipSize") <= 0 then
				count = math.ceil( math.Clamp(10, 300 / math.pow( ( self:GetStatL("Secondary.Damage") or 100 ) / 30, 2 ), 10, 300) / 5 ) * 5
				if self.Secondary_TFA.NZMaxAmmo and self.Secondary_TFA.NZMaxAmmo > 0 then
					count = self.Secondary_TFA.NZMaxAmmo
					if self:GetPaP() then
						count = count * 5 / 3
					end
				end
				self:GetOwner():SetAmmo(count, at2)
			else
				upperclamp = self:GetPaP() and 600 or 300
				count = math.Clamp(math.abs(self:GetStatL("Secondary.ClipSize")) * 10, 10, upperclamp)
				count = count + self:GetStatL("Secondary.ClipSize") - self:Clip2()
				if self.Secondary_TFA.NZMaxAmmo and self.Secondary_TFA.NZMaxAmmo > 0 then
					count = self.Secondary_TFA.NZMaxAmmo
					if self:GetPaP() then
						count = count * 5 / 3
					end
				end
				self:GetOwner():SetAmmo(count, at2)
			end
		end
	end
end

function SWEP:GetPaP()
	return ( self.HasNZModifier and self:HasNZModifier("pap") ) or self.pap or false
end

function SWEP:IsPaP()
	return self:GetPaP()
end
--PATH lua/weapons/tfa_gun_base/client/effects.lua:
local vector_up = Vector(0, 0, 1)
local math = math
local render = render
local LerpVector = LerpVector

--[[
Function Name:  ComputeSmokeLighting
Syntax: self:ComputeSmokeLighting(pos, nrm, pcf).
Returns:  Nothing.
Notes:	Used to light the muzzle smoke trail, by setting its PCF Control Point 1
Purpose:  FX
]]--
function SWEP:ComputeSmokeLighting( pos, nrm, pcf )
	if not IsValid(pcf) then return end
	local licht = render.ComputeLighting(pos, nrm)
	local lichtFloat = math.Clamp((licht.r + licht.g + licht.b) / 3, 0, TFA.Particles.SmokeLightingClamp) / TFA.Particles.SmokeLightingClamp
	local lichtFinal = LerpVector(lichtFloat, TFA.Particles.SmokeLightingMin, TFA.Particles.SmokeLightingMax)
	pcf:SetControlPoint(1, lichtFinal)
end

--[[
Function Name:  SmokePCFLighting
Syntax: self:SmokePCFLighting().
Returns:  Nothing.
Notes:	Used to loop through all of our SmokePCF tables and call ComputeSmokeLighting on them
Purpose:  FX
]]--
function SWEP:SmokePCFLighting()
	local mzPos = self:GetMuzzlePos()
	if not mzPos or not mzPos.Pos then return end
	local pos = mzPos.Pos
	if self.SmokePCF then
		for _, v in pairs(self.SmokePCF) do
			self:ComputeSmokeLighting(pos, vector_up, v)
		end
	end
	if not self:VMIV() then return end
	local vm = self.OwnerViewModel
	if vm.SmokePCF then
		for _, v in pairs(vm.SmokePCF) do
			self:ComputeSmokeLighting(pos, vector_up, v)
		end
	end
end

--[[
Function Name:  FireAnimationEvent
Syntax: self:FireAnimationEvent( position, angle, event id, options).
Returns:  Nothing.
Notes:	Used to capture and disable viewmodel animation events, unless you disable that feature.
Purpose:  FX
]]--
function SWEP:FireAnimationEvent(pos, ang, event, options)
	if self.CustomMuzzleFlash or not self.MuzzleFlashEnabled then
		-- Disables animation based muzzle event
		if (event == 21) then return true end
		-- Disable thirdperson muzzle flash
		if (event == 5003) then return true end

		-- Disable CS-style muzzle flashes, but chance our muzzle flash attachment if one is given.
		if (event == 5001 or event == 5011 or event == 5021 or event == 5031) then
			if self.AutoDetectMuzzleAttachment then
				self.MuzzleAttachmentRaw = math.Clamp(math.floor((event - 4991) / 10), 1, 4)
				self:ShootEffectsCustom(true)
			end

			return true
		end
	end

	if (self.LuaShellEject and event ~= 5004) then return true end
end

--[[
Function Name:  MakeMuzzleSmoke
Syntax: self:MakeMuzzleSmoke( entity, attachment).
Returns:  Nothing.
Notes:	Deprecated. Used to make the muzzle smoke effect, clientside.
Purpose:  FX
]]--

local limit_particle_cv  = GetConVar("cl_tfa_fx_muzzlesmoke_limited")

function SWEP:MakeMuzzleSmoke(entity, attachment)
	if ( not limit_particle_cv ) or limit_particle_cv:GetBool() then
		self:CleanParticles()
	end
	local ht = self.DefaultHoldType and self.DefaultHoldType or self.HoldType

	if (CLIENT and TFA.GetMZSmokeEnabled() and IsValid(entity) and attachment and attachment ~= 0) then
		ParticleEffectAttach(self.SmokeParticles[ht], PATTACH_POINT_FOLLOW, entity, attachment)
	end
end

--[[
Function Name:  ImpactEffect
Syntax: self:ImpactEffect( position, normal (ang:Up()), materialt ype).
Returns:  Nothing.
Notes:	Used to make the impact effect.  See utilities code for CanDustEffect.
Purpose:  FX
]]--

function SWEP:DoImpactEffect(tr, dmgtype)
	if tr.HitSky then return true end
	local ib = self.BashBase and IsValid(self) and self:GetBashing()
	local dmginfo = DamageInfo()
	dmginfo:SetDamageType(dmgtype)

	if dmginfo:IsDamageType(DMG_SLASH) or (ib and self.Secondary_TFA.BashDamageType == DMG_SLASH and tr.MatType ~= MAT_FLESH and tr.MatType ~= MAT_ALIENFLESH) or (self and self.DamageType and self.DamageType == DMG_SLASH) then
		util.Decal("ManhackCut", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		return true
	end

	if ib and self.Secondary_TFA.BashDamageType == DMG_GENERIC then return true end
	if ib then return end

	if IsValid(self) then
		self:ImpactEffectFunc(tr.HitPos, tr.HitNormal, tr.MatType)
	end

	if self.ImpactDecal and self.ImpactDecal ~= "" then
		util.Decal(self.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		return true
	end
end

local impact_cl_enabled = GetConVar("cl_tfa_fx_impact_enabled")
local impact_sv_enabled = GetConVar("sv_tfa_fx_impact_override")

function SWEP:ImpactEffectFunc(pos, normal, mattype)
	local enabled

	if impact_cl_enabled then
		enabled = impact_cl_enabled:GetBool()
	else
		enabled = true
	end

	if impact_sv_enabled and impact_sv_enabled:GetInt() >= 0 then
		enabled = impact_sv_enabled:GetBool()
	end

	if enabled then
		local fx = EffectData()
		fx:SetOrigin(pos)
		fx:SetNormal(normal)

		if self:CanDustEffect(mattype) then
			TFA.Effects.Create("tfa_dust_impact", fx)
		end

		if self:CanSparkEffect(mattype) then
			TFA.Effects.Create("tfa_metal_impact", fx)
		end

		local scal = math.sqrt(self:GetStatL("Primary.Damage") / 30)
		if mattype == MAT_FLESH then
			scal = scal * 0.25
		end
		fx:SetEntity(self:GetOwner())
		fx:SetMagnitude(mattype or 0)
		fx:SetScale( scal )
		TFA.Effects.Create("tfa_bullet_impact", fx)

		if self.ImpactEffect then
			TFA.Effects.Create(self.ImpactEffect, fx)
		end
	end
end
--PATH lua/weapons/tfa_gun_base/client/flashlight.lua:
return gluapack()()
--PATH lua/weapons/tfa_melee_base/cl_init.lua:
return gluapack()()
--PATH lua/weapons/tfa_melee_base/cl_init.lua:
include("shared.lua")

--PATH lua/weapons/tfa_sword_advanced_base.lua:
local vector_origin = Vector()

if SERVER then
	AddCSLuaFile()
end

-- This base is kept for backward compatiblity purposes
-- This should not, by any means, be utilized in newer SWEPS
-- Look at melee base/knife base

--[[
PLEASE DON TUSE THIS ANYMIRE
PLEASe
PLEASSSSSSSS
]]
DEFINE_BASECLASS("tfa_gun_base")
SWEP.Primary.Ammo = "" -- Required for GMod legacy purposes.  Don't remove unless you want to see your sword's ammo.  Wat?
SWEP.data = {} --Ignore this.
--[[SWEP Info]]
--
SWEP.Gun = "" -- must be the name of your swep but NO CAPITALS!
SWEP.Category = ""
SWEP.Base = "tfa_gun_base"
SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = "Left click to slash" .. "\n" .. "Hold right mouse to put up guard."
SWEP.PrintName = "Snowflake Katana" -- Weapon name (Shown on HUD)
SWEP.Slot = 0 -- Slot in the weapon selection menu
SWEP.SlotPos = 21 -- Position in the slot
SWEP.DrawAmmo = false -- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox = true -- Should draw the weapon info box
SWEP.BounceWeaponIcon = false -- Should the weapon icon bounce?
SWEP.DrawCrosshair = false -- set false if you want no crosshair
SWEP.Weight = 50 -- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo = true -- Auto switch to if we pick it up
SWEP.AutoSwitchFrom = true -- Auto switch from if you pick up a better weapon
SWEP.Secondary.OwnerFOV = 90 -- How much you "zoom" in. Less is more!  Don't have this be <= 0
SWEP.WeaponLength = 8 --16 = 1 foot
SWEP.MoveSpeed = 0.9 --Multiply the player's movespeed by this.
SWEP.IronSightsMoveSpeed = 0.8 --Multiply the player's movespeed by this when sighting.
SWEP.IsMelee = true
SWEP.AllowSprintAttack = true
--[[TTT CRAP]]
--
-- SWEP.Kind = WEAPON_EQUIP
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
-- SWEP.CanBuy = {ROLE_TRAITOR, ROLE_DETECTIVE, ROLE_INNOCENT} -- only traitors can buy
-- SWEP.LimitedStock = true -- only buyable once
-- SWEP.NoSights = false
-- SWEP.IsSilent = true
--[[Worldmodel Variables]]
--
SWEP.HoldType = "melee2" -- how others view you carrying the weapon
SWEP.BlockHoldType = "slam" -- how others view you carrying the weapon, while blocking
--[[
Options:
normal - Pistol Idle / Weaponless, hands at sides
melee - One Handed Melee
melee2 - Two Handed Melee
fist - Fists Raised
knife - Knife/Dagger style melee.  Kind of hunched.
smg - SMG or Rifle with grip
ar2 - Rifle
pistol - One handed pistol
rpg - Used for RPGs or sometimes snipers.  AFAIK has no reload anim.
physgun - Used for physgun.  Kind of like SLAM, but holding a grip.
grenade - Used for nades, kind of similar to melee but more of a throwing animation.
shotgun - Used for shotugns, and really that's it.
crossbow -Similar to shotgun, but aimed.  Used for crossbows.
slam - Holding an explosive or other rectangular object with two hands
passive -- SMG idle, like you can see with some HL2 citizens
magic - One hand to temple, the other reaching out.  Can be used to mimic blocking a melee, if you're OK with the temple-hand-thing.
duel- dual pistols
revolver - 2 handed pistol
--]]
SWEP.WorldModel = "" -- Weapon world model
SWEP.ShowWorldModel = true --Draw the world model?
SWEP.Spawnable = false --Can it be spawned by a user?
SWEP.AdminSpawnable = false --Can it be spawned by an admin?
--[[Viewmodel Variables]]
--
SWEP.UseHands = true --Uses c_hands?  If you port a model directly from HL2, CS:S, etc. then set to false
	SWEP.ViewModelFOV = 60 --This controls the viewmodel FOV.  The larger, the smaller it appears.  Decrease if you can see something you shouldn't.
	SWEP.ViewModelFlip = false --Flip the viewmodel?  Usually gonna be yes for CS:S ports.
	SWEP.ViewModel = "" -- Weapon view model
	--[[Shooting/Attacking Vars]]
	--
	SWEP.Primary.Damage = 200 -- Base damage per bullet
	SWEP.DamageType = DMG_SLASH
	SWEP.Primary.RPM = 180 -- This is in Rounds Per Minute
	SWEP.Primary.KickUp = 0.4 -- Maximum up recoil (rise)
	SWEP.Primary.KickDown = 0.3 -- Maximum down recoil (skeet)
	SWEP.Primary.KickHorizontal = 0.3 -- Maximum up recoil (stock)
	SWEP.Primary.Automatic = false -- Automatic = true; Semi Auto = false.  In the case of our sword, if you can hold and keep swinging.
	SWEP.Primary.FiresUnderwater = true --Can you swing your sword underwater?
	--[[ Block Procedural Animation Variables]]
	--
	SWEP.BlockPos = Vector(-18, -10, 3) --Blocking Position.
	SWEP.BlockAng = Vector(10, -25, -15) --Blocking Angle.
	--[[Begin Slashing Variables]]
	--
	SWEP.Slash = 1
	SWEP.Sequences = {} --Swinging Sequences
	--[[
	SWEP.Sequences[1]={
	name="swipe_u2d",--Sequence name, can be found in HLMV
	holdtype="melee2",--Holdtype (thirdperson type of weapon, usually gonna be melee for a one handed or melee2 for a two handed)
	startt=10/60,--swing start in seconds, from the sequence start
endt=20/60,--swing end in seconds, from the sequence start
pitch=5, --This is a component of the slash's arc.  Pitch is added last, and changes based on the time of the trace.
yaw=35, --This is a component of the slash's arc.  Yaw is added second, and changes based on the time of the trace.
roll=-90,--This is a component of the slash's arc.  Roll is added first, and remains static.
dir=1--Left to right = -1, right to left =1.  Base this off if the roll were 0.
}
SWEP.Sequences[2]={
name="swipe_l2r",
holdtype="melee2",
startt=10/60,
endt=20/60,
pitch=5,
yaw=45,
roll=10,
dir=-1
}
SWEP.Sequences[3]={
name="swipe_r2l",
holdtype="melee2",
startt=10/60,
endt=20/60,
pitch=5,
yaw=45,
roll=-5,
dir=1
}
]]
--
SWEP.SlashRandom = Angle(5, 0, 10) --This is a random angle for the overall slash, added onto the sequence angle
SWEP.SlashJitter = Angle(1, 1, 1) --This is jitter for each point of the slash
SWEP.randfac = 0 --Don't change this, it's autocalculated
SWEP.HitRange = 86 -- Blade Length.  Set slightly longer to compensate for animation.
SWEP.AmmoType = "TFMSwordHitGenericSlash" --Ammotype.  You can set a damage type in a custom ammo, which you can create in autorun.  Then set it to that custom ammotype here.
SWEP.SlashPrecision = 15 --The number of traces per slash
SWEP.SlashDecals = 8 --The number of decals per slash.  May slightly vary
SWEP.SlashSounds = 6 --The number of sounds per slash.  May slightly vary.
SWEP.LastTraceTime = 0 --Don't change this, it's autocalculated
SWEP.NextPrimaryFire = 0 --In case SetNextPrimaryFire doesn't work.  Don't change this here.  Please.
--[[Blocking Variables]]
--
SWEP.BlockSequences = {} --Sequences for blocking
--[[
SWEP.BlockSequences[1]={
name="swipe_u2d", --Sequence name, can be found in HLMV
recoverytime=0.3, --Recovery Time (Added onto sequence time, if enabled)
recoverysequence=false  --Automatically add recovery time based on sequence length
}
SWEP.BlockSequences[2]={
name="swipe_l2r",
recoverytime=0.3,
recoverysequence=false
}
SWEP.BlockSequences[3]={
name="swipe_r2l",
recoverytime=0.3,
recoverysequence=false
}
]]
--
SWEP.DisableIdleAnimations = false --Disables idle animations.  Set to false to enable them.
SWEP.IronBobMult = 1 -- More is more bobbing, proportionally.  This is multiplication, not addition.  You want to make this < 1 for sighting, 0 to outright disable.
SWEP.NinjaMode = false --Can block bullets/everything
SWEP.DrawTime = 0.2 --Time you can't swing after drawing
SWEP.BlockAngle = 135 --Think of the player's view direction as being the middle of a sector, with the sector's angle being this
SWEP.BlockMaximum = 0.1 --Multiply damage by this for a maximumly effective block
SWEP.BlockMinimum = 0.7 --Multiply damage by this for a minimumly effective block
SWEP.BlockWindow = 0.5 --Time to absorb maximum damage
SWEP.BlockFadeTime = 1 --Time for blocking to do minimum damage.  Does not include block window
SWEP.PrevBlocking = false --Don't change this, just related to the block procedural animation
SWEP.BlockProceduralAnimTime = 0.15 --Change how slow or quickly the player moves their sword to block
--[[Sounds]]
--
--These are just kinda constants you can use.  Don't change these, or do if you want to be lazy.
SWEP.SlashSound = Sound("weapons/blades/woosh.mp3") --Weapon woosh/slash sound
SWEP.KnifeShink = Sound("weapons/blades/hitwall.mp3") --When a knife hits a wall.  Grating noise.
SWEP.KnifeSlash = Sound("weapons/blades/slash.mp3") --Meaty slash
SWEP.KnifeStab = Sound("weapons/blades/nastystab.mp3") --Meaty stab and pull-out
SWEP.SwordChop = Sound("weapons/blades/swordchop.mp3") --Meaty impact, without the pull-out
SWEP.SwordClash = Sound("weapons/blades/clash.mp3") --Sound played when you block something
--[[ Edit These ]]
--
SWEP.Primary.Sound = SWEP.SlashSound --Change this to your swing sound
SWEP.Primary.Sound_Impact_Flesh = SWEP.SwordChop --Change this to your flesh hit sound
SWEP.Primary.Sound_Impact_Generic = SWEP.KnifeShink --Change this to your generic hit sound
SWEP.Primary.Sound_Impact_Metal = SWEP.SwordClash --Change this to your metal hit
SWEP.Primary.Sound_Pitch_Low = 97 --Percentage of pitch out of 100, lowe end.  Up to 255.
SWEP.Primary.Sound_Pitch_High = 100 --Percentage of pitch out of 100  Up to 255.
SWEP.Primary.Sound_World_Glass_Enabled = true --Override for glass?
SWEP.Primary.Sound_Glass_Enabled = true --Override for glass?
SWEP.Primary.Sound_Glass = Sound("impacts/glass_impact.wav")
SWEP.GlassSoundPlayed = false -- DO NOT CHANGE THIS.  It's automatically set.   This way, it doesn't spam the glass sound.
SWEP.ViewModelElements = {} --View elements
SWEP.WorldModelElements = {} --World elements
SWEP.sounds = 0
SWEP.Action = true --Use action IDs?
--[[Stop editing here for normal users of my base.  Code starts here.]]--
--[[
function SWEP:Precache()
util.PrecacheSound(self.Primary_TFA.Sound)
util.PrecacheModel(self.ViewModel)
util.PrecacheModel(self.WorldModel)
end
]]--

function SWEP:Deploy()
	self:SetNW2Float("SharedRandomVal", CurTime())
	self:SetBlockStart(-1)
	self.PrevBlockRat = 0
	BaseClass.Deploy(self)
end

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	self:NetworkVarTFA("Float", "BlockStart")
end

function SWEP:DoImpactEffect(tr, dmg)
	local impactpos, impactnormal
	impactpos = tr.HitPos
	impactnormal = tr.HitNormal
	self.sounds = self.sounds and self.sounds or 0

	if (tr.HitSky == false) then
		if (util.SharedRandom(CurTime(), 1, self.SlashPrecision, "TFMSwordDecal") < self.SlashDecals) then
			util.Decal("ManhackCut", impactpos + impactnormal, impactpos - impactnormal)
		end

		if (tr.MatType == MAT_GLASS) and (self.Primary_TFA.Sound_Glass and self.Primary_TFA.Sound_Glass_Enabled == true) and (self.GlassSoundPlayed == false) then
			self:EmitSound(self.Primary_TFA.Sound_Glass, 100, math.random(self.Primary_TFA.Sound_Pitch_Low, self.Primary_TFA.Sound_Pitch_High), 0.75, CHAN_WEAPON)
			self.GlassSoundPlayed = true
		end
	end

	return true
end

function SWEP:HitThing(ent, posv, normalv, damage, tr)
	local ply
	ply = self:GetOwner()

	if IsValid(ply) then
		--[[
		ply:LagCompensation(true)
		local tr,tres;
		tr={}
		tr.start=posv
		tr.endpos=posv+normalv*self.HitRange
		tr.filter=ply
		tr.mask=2147483647--MASK_SOLID && MASK_SHOT && MASK_VISIBLE_AND_NPCS--MASK_SHOT
		tres=util.TraceLine(tr)
		ply:LagCompensation(false)
		if tres.Hit and tres.Fraction<1 and !tres.HitSky then
		]]
		--
		local bullet = {}
		bullet.Num = 1
		bullet.Src = posv -- Source
		bullet.Dir = normalv -- Dir of bullet
		bullet.Spread = vector_origin -- Aim Cone
		bullet.Tracer = 0 -- Show a tracer on every x bullets
		bullet.Force = damage / 16 -- Amount of force to give to phys objects
		bullet.Damage = damage
		bullet.Distance = self.HitRange
		bullet.HullSize = self.WeaponLength / self.SlashPrecision
		bullet.AmmoType = self.AmmoType

		bullet.Callback = function(a, b, c)
			local wep = a:GetActiveWeapon()
			if not IsValid(self) then return end
			if not self.sounds then return end
			c:SetDamageType(self.DamageType)

			if (self.sounds < self.SlashSounds) then
				local hitmat = b.MatType

				if (hitmat == MAT_METAL or hitmat == MAT_GRATE or hitmat == MAT_VENT or hitmat == MAT_COMPUTER) then
					--Emit metal sound
					wep.Weapon:EmitSound(self.Primary_TFA.Sound_Impact_Metal, 100, math.random(self.Primary_TFA.Sound_Pitch_Low, self.Primary_TFA.Sound_Pitch_High), 0.75, CHAN_AUTO)
					wep.sounds = self.sounds + 1
					--Emit flesh sound
					--Emit generic sound.
				elseif (hitmat == MAT_FLESH or hitmat == MAT_BLOODYFLESH or hitmat == MAT_ALIENFLESH) then
					wep.Weapon:EmitSound(self.Primary_TFA.Sound_Impact_Flesh, 100, math.random(self.Primary_TFA.Sound_Pitch_Low, self.Primary_TFA.Sound_Pitch_High), 0.75, CHAN_AUTO)
					wep.sounds = self.sounds + 1
				else
					wep.Weapon:EmitSound(self.Primary_TFA.Sound_Impact_Generic, 100, math.random(self.Primary_TFA.Sound_Pitch_Low, self.Primary_TFA.Sound_Pitch_High), 0.75, CHAN_AUTO)
					wep.sounds = self.sounds + 1
				end
			end
		end

		if CLIENT and SERVER then
			if self:GetOwner() ~= LocalPlayer() then
				self:GetOwner():FireBullets(bullet)
			end
		else
			self:GetOwner():FireBullets(bullet)
		end
		--end
	end
end

function SWEP:PrimaryAttack()
	local sharedrandomval = self:GetNW2Float("SharedRandomVal", 0)
	math.randomseed(sharedrandomval)
	if CLIENT and not IsFirstTimePredicted() then return end
	if not self:OwnerIsValid() then return end
	if CurTime() < self:GetNextPrimaryFire() then return end
	if not TFA.Enum.ReadyStatus[self:GetStatus()] then return end

	if self:IsSafety() then return end
	self:SetStatus(TFA.Enum.STATUS_SHOOTING)
	self.sounds = 0
	self:ChooseShootAnim() -- View model animation

	if SERVER then
		timer.Simple(0, function()
			if IsValid(self) then
				self:SetNW2Float("SharedRandomVal", math.Rand(-1024, 1024))
			end
		end)
	end

	local vm = self.OwnerViewModel
	self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	self:GetOwner():SetNW2Float("TFM_SwingStart", CurTime())
	self:SetStatusEnd(CurTime() + vm:SequenceDuration(vm:LookupSequence(self.Sequences[self:GetNW2Int("Slash", 1)].name)))
	self.LastTraceTime = CurTime() + self.Sequences[self:GetNW2Int("Slash", 1)].startt

	self:SetNextPrimaryFire(CurTime() + 1 / (self.Primary_TFA.RPM / 60))

	if SERVER then
		timer.Simple(self.Sequences[self:GetNW2Int("Slash", 1)].startt, function()
			if IsValid(self) and self.Primary_TFA.Sound then
				self:EmitSound(self.Primary_TFA.Sound)
			end
		end)
	end
end

local seq, swe
local ft, len, strikepercent, swingprogress, sws
local aimoff, jitfac
local blockseqn, ply
local vm

function SWEP:IronSights()
	BaseClass.IronSights(self)
	ply = self:GetOwner()
	seq = self.Sequences[self:GetNW2Int("Slash", 1)]
	swe = ply:GetNW2Float("TFM_SwingStart", CurTime()) + seq.endt

	if CurTime() < swe then
		self:SetIronSightsRaw(false)
	end
end


function SWEP:Think2(...)
	BaseClass.Think2(self, ...)

	local isr = self:GetIronSightsProgress()

	ply = self:GetOwner()

	if self.PrevBlockRat and isr and self.PrevBlockRat <= 0.3 and isr > 0.3 then
		self:SetBlockStart(CurTime())
		--print(CurTime())
	end

	if isr and self.PrevBlockRat and isr < 0.1 and self.PrevBlockRat > 0.1 then
		self:SetBlockStart(-1)
		--print(-1)
	end

	self.PrevBlockRat = isr
	local stat = self:GetStatus()
	if stat == TFA.Enum.STATUS_SHOOTING then
		seq = self.Sequences[self:GetNW2Int("Slash", 1)]
		ft = CurTime() - self.LastTraceTime
		len = seq.endt - seq.startt
		strikepercent = ft / len
		sws = ply:GetNW2Float("TFM_SwingStart", CurTime()) + seq.startt
		swe = ply:GetNW2Float("TFM_SwingStart", CurTime()) + seq.endt
		swingprogress = (CurTime() - sws) / len

		if CurTime() < swe then
			self:SetIronSightsRaw(false)
		end

		if (CurTime() > sws) and CurTime() < swe and ft > len / self.SlashPrecision and (strikepercent > 0) then
			aimoff = ply:EyeAngles()
			--aimoff = Angle(0,0,0)
			local cutangle = Angle(seq.pitch * (swingprogress - 0.5) * seq.dir, seq.yaw * (swingprogress - 0.5) * seq.dir, seq.roll)
			jitfac = 0.5 - util.SharedRandom("TFMSwordJitter", 0, 1, CurTime())
			aimoff:RotateAroundAxis(aimoff:Forward(), cutangle.r + self.SlashRandom.r * self.randfac + self.SlashJitter.r * jitfac) --Roll is static
			aimoff:RotateAroundAxis(aimoff:Up(), cutangle.y + self.SlashRandom.y * self.randfac + self.SlashJitter.y * jitfac)
			aimoff:RotateAroundAxis(aimoff:Right(), cutangle.p + self.SlashRandom.p * self.randfac + self.SlashJitter.p * jitfac)
			self:HitThing(ply, ply:GetShootPos(), aimoff:Forward(), self.Primary_TFA.Damage * strikepercent)
			self.LastTraceTime = CurTime()
		end
	end
end

function SWEP:ChooseShootAnim(mynewvar)
	local sharedrandomval = self:GetNW2Float("SharedRandomVal", 0)
	if not self:OwnerIsValid() then return end
	if not IsValid(self) or not self:OwnerIsValid() then return end
	ply = self:GetOwner()
	vm = self.OwnerViewModel
	local selection = {}
	local relativedir = WorldToLocal(ply:GetVelocity(), Angle(0, 0, 0), vector_origin, ply:EyeAngles())
	local fwd = relativedir.x
	local hor = relativedir.y

	if hor < -ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if v.right then
				table.insert(selection, #selection + 1, k)
			end
		end
	elseif hor > ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if v.left then
				table.insert(selection, #selection + 1, k)
			end
		end
	elseif fwd > ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if (v.up) then
				table.insert(selection, #selection + 1, k)
			end
		end
	elseif fwd < ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if (v.down) then
				table.insert(selection, #selection + 1, k)
			end
		end
	end

	if #selection <= 0 and math.abs(fwd) < ply:GetWalkSpeed() / 2 and math.abs(hor) < ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if v.up or v.down then
				table.insert(selection, #selection + 1, k)
			end
		end
	end

	if #selection <= 0 and math.abs(hor) < ply:GetWalkSpeed() / 2 and math.abs(fwd) < ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if v.standing then
				table.insert(selection, #selection + 1, k)
			end
		end
	end

	if #selection <= 0 then
		--print("random test:")
		math.randomseed(sharedrandomval)

		if math.random(0, 1) == 0 then
			math.randomseed(sharedrandomval)
			self:SetNW2Int("Slash", math.random(1, #self.Sequences))
		else
			self:SetNW2Int("Slash", self:GetNW2Int("Slash", 1) + 1)

			if self:GetNW2Int("Slash", 1) > #self.Sequences then
				self:SetNW2Int("Slash", 1)
			end
		end
		--print("selection sequence")
		--print(math.Round( util.SharedRandom( "TFAMelee", 1, #selection, sharedrandomval ) ))
	else
		math.randomseed(sharedrandomval)
		self:SetNW2Int("Slash", selection[math.random(1, #selection)])
	end

	--print("Shared Random Value:")
	--print(sharedrandomval)
	--print("Slash Number")
	--print(self:GetNW2Int("Slash",0))
	local n = tonumber(mynewvar and mynewvar or "")
	local seqn = n and n or self:GetNW2Int("Slash", 1)
	--self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
	seq = self.Sequences[seqn]
	--vm:ResetSequence(vm:LookupSequence(seq.name))
	--print(seq.name)
	local seqid = vm:LookupSequence(seq.name)
	seqid = seqid and seqid or 0
	local actid = vm:GetSequenceActivity(seqid)

	if actid and actid >= 0 and self.Action then
		self:SendViewModelAnim(actid)
		--vm:SendViewModelMatchingSequence(seqid)
	else
		self:SendViewModelSeq(seqid)
	end

	if SERVER and game.SinglePlayer() then
		self:CallOnClient("ChooseShootAnim", tostring(seqn))
	end

	return true, ACT_VM_PRIMARYATTACK
end

function SWEP:BlockAnim()
	local sharedrandomval = self:GetNW2Float("SharedRandomVal", 0)

	if self.BlockSequences and #self.BlockSequences > 0 then
		math.randomseed(sharedrandomval)
		blockseqn = math.random(1, #self.BlockSequences)
		seq = self.BlockSequences[blockseqn]
		ply = self:GetOwner()

		if IsValid(ply) then
			vm = self.OwnerViewModel

			if IsValid(vm) then
				self:SetNextIdleAnim(-1)
				self:SendWeaponAnim(ACT_VM_IDLE)
				vm:SendViewModelMatchingSequence(vm:LookupSequence(seq.name))

				if seq.recoverysequence and seq.recoverysequence == true then
					if seq.recoverytime then
						self.NextPrimaryFire = CurTime() + vm:SequenceDuration() + seq.recoverytime
						self:SetNextPrimaryFire(CurTime() + vm:SequenceDuration() + seq.recoverytime)
						self:SetStatus(TFA.Enum.STATUS_FIDGET)
						self:SetStatusEnd(self.NextPrimaryFire)
					else
						self.NextPrimaryFire = CurTime() + vm:SequenceDuration()
						self:SetNextPrimaryFire(CurTime() + vm:SequenceDuration())
						self:SetStatus(TFA.Enum.STATUS_FIDGET)
						self:SetStatusEnd(self.NextPrimaryFire)
					end
				else
					self.NextPrimaryFire = CurTime() + seq.recoverytime

					if seq.recoverytime then
						self.NextPrimaryFire = CurTime() + seq.recoverytime
						self:SetNextPrimaryFire(CurTime() + seq.recoverytime)
					else
						self.NextPrimaryFire = CurTime()
						self:SetNextPrimaryFire(CurTime())
					end
				end
			end
		end
	end
end

--PATH lua/weapons/weapon_armorkit/animations.lua:
--[[*******************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************]]

function SWEP:Anim_Initialize()

	// other initialize code goes here

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				--[[if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]
			end
		end
		
	end

end

function SWEP:Anim_Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:Anim_OnRemove()
	self:Anim_Holster()
	self:RemoveModels()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:Anim_ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local draWCuston = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(draWCuston, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local draWCuston = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(draWCuston, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:Anim_DrawWorldModel()
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			if self.WCustom and IsValid(self:GetOwner()) then
				local lu = self:GetOwner():LookupBone(self.WBone)
				if isnumber(lu) then
					local pos,ang = self:GetOwner():GetBonePosition(lu)

					local x = ang:Right() * self.WPos.x 
					local y = ang:Forward() * self.WPos.y 
					local z = ang:Up() * self.WPos.z
					pos = pos + x + y + z

					ang:RotateAroundAxis(ang:Right(), self.WAng.pitch)
					ang:RotateAroundAxis(ang:Up(), self.WAng.yaw)
					ang:RotateAroundAxis(ang:Forward(), self.WAng.roll)

					self:SetRenderOrigin(pos)
					self:SetRenderAngles(ang)
				end
			end

			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) or (!ang) then
				pos = self:GetPos()
				ang = self:GetAngles()
			end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local draWCuston = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(draWCuston, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local draWCuston = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(draWCuston, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		-- New code
		vm:SetColor(color_white)
		vm:SetMaterial("")
		--------

		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

----------------
-- Extra code --
----------------

function SWEP:RemoveModels()
	if (self.VElements) then
		for k, v in pairs( self.VElements ) do
			if (IsValid( v.modelEnt )) then
				v.modelEnt:Remove()
				v.modelEnt = nil
			end
		end
	end
	if (self.WElements) then
		for k, v in pairs( self.WElements ) do
			if (IsValid( v.modelEnt )) then
				v.modelEnt:Remove()
				v.modelEnt = nil
			end
		end
	end
end

--PATH gamemodes/starwarsrp/entities/weapons/weapon_cs_base2/shared.lua:
AddCSLuaFile()

if SERVER then
    include("sv_commands.lua")
    include("sh_commands.lua")
    SWEP.Weight = 5
    SWEP.AutoSwitchTo = false
    SWEP.AutoSwitchFrom = false
end

if CLIENT then
    SWEP.DrawAmmo           = true
    SWEP.DrawCrosshair      = false
    SWEP.ViewModelFOV       = 82
    SWEP.ViewModelFlip      = false
    SWEP.CSMuzzleFlashes    = true

    -- This is the font that's used to draw the death icons
    surface.CreateFont("CSKillIcons", {
        size = ScreenScale(30),
        weight = 500,
        antialias = true,
        shadow = true,
        font = "csd"
    })
    surface.CreateFont("CSSelectIcons", {
        size = ScreenScale(60),
        weight = 500,
        antialias = true,
        shadow = true,
        font = "csd"
    })
end

SWEP.Base = "weapon_base"

SWEP.Author = "DarkRP Developers"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.UseHands = true

SWEP.HoldType = "normal"
SWEP.LoweredHoldType = "normal"

SWEP.Primary.Sound = Sound("Weapon_AK47.Single")
SWEP.Primary.Recoil = 1.5
SWEP.Primary.Damage = 40
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0.02
SWEP.Primary.Delay = 0.15

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.MultiMode = false

SWEP.DarkRPBased = true

function SWEP:SetIronsights(b)
    if (b ~= self:GetIronsights()) then
        self:SetIronsightsPredicted(b)
        self:SetIronsightsTime(CurTime())
        if GAMEMODE.Config.ironshoot then
            self:SetHoldType(b and self.HoldType or self.LoweredHoldType)
        end
        if CLIENT then
            self:CalcViewModel()
        end
    end
end

function SWEP:GetIronsights()
    return self:GetIronsightsPredicted()
end

--- Dummy functions that will be replaced when SetupDataTables runs. These are
--- here for when that does not happen (due to e.g. stacking base classes)
function SWEP:GetIronsightsTime() return -1 end
function SWEP:SetIronsightsTime() end
function SWEP:GetIronsightsPredicted() return false end
function SWEP:SetIronsightsPredicted() end

function SWEP:SetupDataTables()
    self:NetworkVar("Bool", 0, "IronsightsPredicted")
    self:NetworkVar("Float", 0, "IronsightsTime")
    self:NetworkVar("Bool", 1, "Reloading")
    self:NetworkVar("Float", 1, "LastPrimaryAttack")
    self:NetworkVar("Float", 2, "ReloadEndTime")
    self:NetworkVar("Float", 3, "BurstTime")
    self:NetworkVar("Int", 0, "BurstBulletNum")
    self:NetworkVar("Int", 1, "TotalUsedMagCount")
    self:NetworkVar("String", 0, "FireMode")
    self:NetworkVar("Entity", 0, "LastOwner")
end

function SWEP:Initialize()
    if CLIENT and IsValid(self:GetOwner()) then
        local vm = self:GetOwner():GetViewModel()
        self:ResetDarkRPBones(vm)
    end

    self:SetHoldType(GAMEMODE.Config.ironshoot and self.LoweredHoldType or self.HoldType)
    if SERVER then
        self:SetNPCMinBurst(30)
        self:SetNPCMaxBurst(30)
        self:SetNPCFireRate(0.01)
    end

    self:SetFireMode(self.Primary.Automatic and "auto" or "semi")
end

function SWEP:Deploy()
    self:SetHoldType(GAMEMODE.Config.ironshoot and self.LoweredHoldType or self.HoldType)
    self:SetIronsights(false)
    self:SetReloading(false)
    self:SetReloadEndTime(0)
    self:SetBurstTime(0)
    self:SetBurstBulletNum(0)

    return true
end

function SWEP:Holster()
    self:SetIronsights(false)
    self:SetReloading(false)
    self:SetReloadEndTime(0)
    self:SetBurstTime(0)
    self:SetBurstBulletNum(0)

    if CLIENT then self.hasShot = false end

    if not IsValid(self:GetOwner()) then return true end
    if CLIENT then
        local vm = self:GetOwner():GetViewModel()
        self:ResetDarkRPBones(vm)
    end

    return true
end

function SWEP:OnRemove()
    if CLIENT and IsValid(self:GetOwner()) then
        local vm = self:GetOwner():GetViewModel()
        self:ResetDarkRPBones(vm)
    end
end

function SWEP:OwnerChanged()
    if IsValid(self:GetOwner()) then self:SetLastOwner(self:GetOwner()) end
end

function SWEP:PrimaryAttack()
    self.Primary.Automatic = self:GetFireMode() == "auto"

    if self:GetBurstBulletNum() > 0 and CurTime() < self:GetBurstTime() then return end

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    if self.MultiMode and Owner:KeyDown(IN_USE) then
        if self:GetFireMode() == "semi" then
            self:SetFireMode("burst")
            self.Primary.Automatic = false
            Owner:PrintMessage(HUD_PRINTCENTER, DarkRP.getPhrase("switched_burst"))
        elseif self:GetFireMode() == "burst" then
            self:SetFireMode("auto")
            self.Primary.Automatic = true
            Owner:PrintMessage(HUD_PRINTCENTER, DarkRP.getPhrase("switched_fully_auto"))
        elseif self:GetFireMode() == "auto" then
            self:SetFireMode("semi")
            self.Primary.Automatic = false
            Owner:PrintMessage(HUD_PRINTCENTER, DarkRP.getPhrase("switched_semi_auto"))
        end
        self:SetNextPrimaryFire(CurTime() + 0.5)
        self:SetNextSecondaryFire(CurTime() + 0.5)
        return
    end

    if self:GetFireMode() ~= "burst" then
        self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
    end

    self:SetNextSecondaryFire(CurTime() + self.Primary.Delay)

    if self:Clip1() <= 0 then
        self:EmitSound("weapons/clipempty_rifle.wav")
        self:SetNextPrimaryFire(CurTime() + 2)
        return
    end

    if not self:CanPrimaryAttack() then self:SetIronsights(false) return end
    if not self:GetIronsights() and GAMEMODE.Config.ironshoot then return end
    -- Play shoot sound
    self:EmitSound(self.Primary.Sound)

    -- Shoot the bullet
    self:CSShootBullet(self.Primary.Damage, self.Primary.Recoil + 3, self.Primary.NumShots, self.Primary.Cone + .05)

    if self:GetFireMode() == "burst" then
        self:SetBurstBulletNum(self:GetBurstBulletNum() + 1)
        if self:GetBurstBulletNum() == 3 then
            self:SetBurstTime(0)
            self:SetBurstBulletNum(0)
        else
            self:SetBurstTime(CurTime() + 0.1)
        end
    end

    -- Remove 1 bullet from our clip
    self:TakePrimaryAmmo(1)

    self:SetLastPrimaryAttack(CurTime())

    if Owner:IsNPC() then return end

    -- Punch the player's view
    Owner:ViewPunch(Angle(util.SharedRandom("DarkRP_CSBase" .. self:EntIndex() .. "Mag" .. self:GetTotalUsedMagCount() .. "p" .. self:Clip1(), -1.2, -1.1) * self.Primary.Recoil, util.SharedRandom("DarkRP_CSBase" .. self:EntIndex() .. "Mag" .. self:GetTotalUsedMagCount() .. "y" .. self:Clip1(), -1.1, 1.1) * self.Primary.Recoil, 0))
end

function SWEP:CSShootBullet(dmg, recoil, numbul, cone)
     local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    numbul = numbul or 1
    cone = cone or 0.01

    local bullet = {}
    bullet.Num = numbul or 1
    bullet.Src = Owner:GetShootPos()   -- Source
    bullet.Dir = (Owner:GetAimVector():Angle() + Owner:GetViewPunchAngles()):Forward() -- Dir of bullet
    bullet.Spread = Vector(cone, cone, 0)        -- Aim Cone
    bullet.Tracer = 4                            -- Show a tracer on every x bullets
    bullet.Force = 5                             -- Amount of force to give to phys objects
    bullet.Damage = dmg

    Owner:FireBullets(bullet)
    self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)    -- View model animation
    Owner:MuzzleFlash()                -- Crappy muzzle light
    Owner:SetAnimation(PLAYER_ATTACK1) -- 3rd Person Animation

    if Owner:IsNPC() then return end

    -- Part of workaround, different viewmodel position if shots have been fired
    if CLIENT then self.hasShot = true end
end

local host_timescale = GetConVar("host_timescale")
local IRONSIGHT_TIME = 0.25
function SWEP:GetViewModelPosition(pos, ang)
    if (not self.IronSightsPos) then return pos, ang end

    pos = pos + ang:Forward() * -5

    if (self.bIron == nil) then return pos, ang end

    local bIron = self.bIron
    local time = self.fCurrentTime + (SysTime() - self.fCurrentSysTime) * game.GetTimeScale() * host_timescale:GetFloat()

    if bIron then
        self.SwayScale = 0.3
        self.BobScale = 0.1
    else
        self.SwayScale = 1.0
        self.BobScale = 1.0
    end

    if GAMEMODE.Config.ironshoot then
        ang:RotateAroundAxis(ang:Right(), -15)
    end

    local fIronTime = self.fIronTime
    if (not bIron) and fIronTime < time - IRONSIGHT_TIME then
        return pos, ang
    end

    local mul = 1.0

    if fIronTime > time - IRONSIGHT_TIME then
        mul = math.Clamp((time - fIronTime) / IRONSIGHT_TIME, 0, 1)

        if not bIron then mul = 1 - mul end
    end

    local offset = self.IronSightsPos

    if self.IronSightsAng then
        ang = ang * 1
        ang:RotateAroundAxis(ang:Right(), self.IronSightsAng.x * mul)
        ang:RotateAroundAxis(ang:Up(), self.IronSightsAng.y * mul)
        ang:RotateAroundAxis(ang:Forward(), self.IronSightsAng.z * mul)
    end

    if GAMEMODE.Config.ironshoot then
        ang:RotateAroundAxis(ang:Right(), mul * 15)
    else
        ang:RotateAroundAxis(ang:Right(), mul)
    end

    pos = pos + offset.x * ang:Right() * mul
    pos = pos + offset.y * ang:Forward() * mul
    pos = pos + offset.z * ang:Up() * mul

    if not self.hasShot then
        if self.IronSightsAngAfterShootingAdjustment then
            ang:RotateAroundAxis(ang:Right(), self.IronSightsAngAfterShootingAdjustment.x * mul)
            ang:RotateAroundAxis(ang:Up(), self.IronSightsAngAfterShootingAdjustment.y * mul)
            ang:RotateAroundAxis(ang:Forward(), self.IronSightsAngAfterShootingAdjustment.z * mul)
        end

        if self.IronSightsPosAfterShootingAdjustment then
            offset = self.IronSightsPosAfterShootingAdjustment
            local right = ang:Right()
            local up = ang:Up()
            local forward = ang:Forward()

            pos = pos + offset.x * right * mul
            pos = pos + offset.y * forward * mul
            pos = pos + offset.z * up * mul
        end
    end

    return pos, ang
end

function SWEP:SecondaryAttack()
    if not self.IronSightsPos then return end

    if self:GetReloading() then return end

    self:SetIronsights(not self:GetIronsights())

    self:SetNextSecondaryFire(CurTime() + 0.3)
end

--[[---------------------------------------------------------
Reload does nothing
---------------------------------------------------------]]
function SWEP:Reload()
    if not self:DefaultReload(ACT_VM_RELOAD) then return end
    self:SetReloading(true)
    self:SetIronsights(false)
    self:SetBurstTime(0)
    self:SetBurstBulletNum(0)
    self:GetOwner():SetAnimation(PLAYER_RELOAD)
    self:SetReloadEndTime(CurTime() + 2)
    self:SetTotalUsedMagCount(self:GetTotalUsedMagCount() + 1)
end

function SWEP:OnRestore()
    self:SetNextSecondaryFire(0)
    self:SetIronsights(false)
end

function SWEP:Equip(NewOwner)
    if self.PrimaryClipLeft and self.SecondaryClipLeft and self.PrimaryAmmoLeft and self.SecondaryAmmoLeft then
        NewOwner:SetAmmo(self.PrimaryAmmoLeft, self:GetPrimaryAmmoType())
        NewOwner:SetAmmo(self.SecondaryAmmoLeft, self:GetSecondaryAmmoType())

        self:SetClip1(self.PrimaryClipLeft)
        self:SetClip2(self.SecondaryClipLeft)
    end
end

function SWEP:OnDrop()
    self.PrimaryClipLeft = self:Clip1()
    self.SecondaryClipLeft = self:Clip2()

    if not IsValid(self:GetLastOwner()) then return end
    self.PrimaryAmmoLeft = self:GetLastOwner():GetAmmoCount(self:GetPrimaryAmmoType())
    self.SecondaryAmmoLeft = self:GetLastOwner():GetAmmoCount(self:GetSecondaryAmmoType())
    self:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE_DEBRIS)
end

function SWEP:CalcViewModel()
    if (not CLIENT) or (not IsFirstTimePredicted()) then return end
    self.bIron = self:GetIronsights()
    self.fIronTime = self:GetIronsightsTime()
    self.fCurrentTime = CurTime()
    self.fCurrentSysTime = SysTime()
end

-- Note that if you override Think in your SWEP, you should call
-- BaseClass.Think(self) so as not to break ironsights
function SWEP:Think()
    self:CalcViewModel()
    if self.Primary.ClipSize ~= -1 and not self:GetReloading() and not self:GetIronsights() and self:GetLastPrimaryAttack() + 1 < CurTime() and self:GetHoldType() == self.HoldType and GAMEMODE.Config.ironshoot then
        self:SetHoldType(self.LoweredHoldType)
    end
    if self:GetReloadEndTime() ~= 0 and CurTime() >= self:GetReloadEndTime() then
        self:SetReloadEndTime(0)
        self:SetReloading(false)
        if GAMEMODE.Config.ironshoot then
            self:SetHoldType(self.LoweredHoldType)
        end
        if CLIENT then self.hasShot = false end
    end
    if self:GetBurstTime() ~= 0 and CurTime() >= self:GetBurstTime() then
        self:PrimaryAttack()
    end
end

function SWEP:DrawWeaponSelection(x, y, wide, tall, alpha)
    if self.IconLetter and string.find(self.IconLetter, "^[0-9a-wA-Z]$") then
        draw.DrawNonParsedSimpleText(self.IconLetter, "CSSelectIcons", x + wide / 2, y + tall * 0.2, Color(255, 210, 0, 255), TEXT_ALIGN_CENTER)

        -- try to fool them into thinking they're playing a Tony Hawks game
        draw.DrawNonParsedSimpleText(self.IconLetter, "CSSelectIcons", x + wide / 2 + math.Rand(-4, 4), y + tall * 0.2 + math.Rand(-14, 14), Color(255, 210, 0, math.Rand(10, 120)), TEXT_ALIGN_CENTER)
        draw.DrawNonParsedSimpleText(self.IconLetter, "CSSelectIcons", x + wide / 2 + math.Rand(-4, 4), y + tall * 0.2 + math.Rand(-9, 9), Color(255, 210, 0, math.Rand(10, 120)), TEXT_ALIGN_CENTER)
    else
        -- Set us up the texture
        surface.SetDrawColor(255, 255, 255, alpha)
        surface.SetTexture(self.WepSelectIcon)

        -- Lets get a sin wave to make it bounce
        local fsin = 0

        if self.BounceWeaponIcon then
            fsin = math.sin(CurTime() * 10) * 5
        end

        -- Borders
        y = y + 10
        x = x + 10
        wide = wide - 20

        -- Draw that motherfucker
        surface.DrawTexturedRect(x + fsin, y - fsin, wide - fsin * 2, (wide / 2) + fsin)

        -- Draw weapon info box
        self:PrintWeaponInfo(x + wide + 20, y + tall * 0.95, alpha)
    end
end

if CLIENT then
    function SWEP:ViewModelDrawn(vm)
        if self.DarkRPViewModelBoneManipulations and not self:GetReloading() then
            self:UpdateDarkRPBones(vm, self.DarkRPViewModelBoneManipulations)
        else
            self:ResetDarkRPBones(vm)
        end
    end

    function SWEP:UpdateDarkRPBones(vm, manipulations)
        if not IsValid(vm) or not vm:GetBoneCount() then return end

        -- Fill in missing bone names. Things fuck up when we workaround the scale bug and bones are missing.
        local bones = {}
        for i = 0, vm:GetBoneCount() - 1 do
            local bonename = vm:GetBoneName(i)
            if manipulations[bonename] then
                bones[bonename] = manipulations[bonename]
            else
                bones[bonename] = {
                    scale = Vector(1,1,1),
                    pos = Vector(0,0,0),
                    angle = Angle(0,0,0)
                }
            end
        end

        for k, v in pairs(bones) do
            local bone = vm:LookupBone(k)
            if not bone then continue end

            -- Bone scaling seems to be buggy. Workaround.
            local scale = Vector(v.scale.x, v.scale.y, v.scale.z)
            local ms = Vector(1,1,1)
            local cur = vm:GetBoneParent(bone)
            while cur >= 0 do
                local pscale = bones[vm:GetBoneName(cur)].scale
                ms = ms * pscale
                cur = vm:GetBoneParent(cur)
            end
            scale = scale * ms

            if vm:GetManipulateBoneScale(bone) ~= scale then
                vm:ManipulateBoneScale(bone, scale)
            end
            if vm:GetManipulateBonePosition(bone) ~= v.pos then
                vm:ManipulateBonePosition(bone, v.pos)
            end
            if vm:GetManipulateBoneAngles(bone) ~= v.angle then
                vm:ManipulateBoneAngles(bone, v.angle)
            end
        end
    end

    function SWEP:ResetDarkRPBones(vm)
        if not IsValid(vm) or not vm:GetBoneCount() then return end
        for i = 0, vm:GetBoneCount() - 1 do
            vm:ManipulateBoneScale(i, Vector(1, 1, 1))
            vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
            vm:ManipulateBonePosition(i, Vector(0, 0, 0))
        end
    end
end

hook.Add("SetupMove", "DarkRP_WeaponSpeed", function(ply, mv)
    local wep = ply:GetActiveWeapon()
    if not wep:IsValid() or not wep.DarkRPBased or not wep.GetIronsights or not wep:GetIronsights() then return end

    mv:SetMaxClientSpeed(mv:GetMaxClientSpeed() / 3)
end)

--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_rope.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_standard.lua SHARED --
--                                 --
-- Rope handcuffs.                 --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "Handcuffs"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "A weak restraint."

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AdminSpawnable = true

SWEP.Slot = 3
SWEP.PrintName = "Rope Restraint"

//
// Handcuff Vars
SWEP.CuffTime = 0.8 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "models/props_foliage/tree_deciduous_01a_trunk"
SWEP.CuffRope = "cable/rope"
SWEP.CuffStrength = 0.85
SWEP.CuffRegen = 0.8
SWEP.RopeLength = 100
SWEP.CuffReusable = false

SWEP.CuffBlindfold = true
SWEP.CuffGag = true

SWEP.CuffStrengthVariance = 0.1 // Randomise strangth
SWEP.CuffRegenVariance = 0.2 // Randomise regen

--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_standard.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_standard.lua SHARED --
--                                 --
-- Base swep for handcuffs.        --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "Handcuffs"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Basic restraints."

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AdminSpawnable = true

SWEP.Slot = 3
SWEP.PrintName = "Basic Handcuffs"

//
// Handcuff Vars
SWEP.CuffTime = 1.0 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/metalfloor_2-3"
SWEP.CuffRope = "cable/cable2"
SWEP.CuffStrength = 1
SWEP.CuffRegen = 1
SWEP.RopeLength = 0
SWEP.CuffReusable = false

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.05 // Randomise strangth
SWEP.CuffRegenVariance = 0.05 // Randomise regen

--PATH lua/weapons/weapon_forceheal.lua:
AddCSLuaFile()

SWEP.VElements = {
	["Glowy"] = { type = "Sprite", sprite = "sprites/plasmaember", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.635, 2.596, 0.518), size = { x = 10, y = 10 }, color = Color(46, 255, 255, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}
SWEP.WElements = {
	["Glowy"] = { type = "Sprite", sprite = "sprites/physcannon_blueglow", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.517, 1.84, -0.622), size = { x = 10, y = 10 }, color = Color(46, 255, 255, 103), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}
SWEP.HoldType = "slam"

SWEP.ViewModelFlip = false 

SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/weapons/w_grenade.mdl"

--SWEP.WorldModel = ""
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_R_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 27.777, 0) },
	["ValveBiped.Bip01_R_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 27.777, 0) },
	["ValveBiped.Bip01_R_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 36.666, 0) },
	["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-0.673, -1.879, 0) },
	["ValveBiped.Bip01_R_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 34.444, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(-3.245, 2.427, 0), angle = Angle(14.444, -16.667, 50) },
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0.071, 0, 0) },
	["ValveBiped.Bip01_R_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0.555, 0, 0), angle = Angle(0, 5.556, -14.445) },
	["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1.003, 1.003, 1.003), pos = Vector(0, 0, 0), angle = Angle(-37.258, 52.847, 4.78) },
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(14.444, -5.557, -94.445) }
}


SWEP.PrintName				= "Force Heal"
SWEP.Author					= "robotboy655 & Riddick"
SWEP.Purpose			= "Heal people with your primary attack, or yourself with the secondary. Provide ammo with Reload"

SWEP.Slot					= 5
SWEP.SlotPos				= 4

SWEP.Spawnable				= true

--SWEP.ViewModel				= Model( "models/weapons/c_medkit.mdl" )
--SWEP.WorldModel				= Model( "models/weapons/w_medkit.mdl" )
SWEP.ViewModelFOV			= 65
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= 200
SWEP.Primary.DefaultClip	= 200
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"


SWEP.HealAmount				= 100	-- Maximum heal amount per use
SWEP.MaxAmmo				= 200	-- Maxumum ammo


local HealSound = Sound( "starwars/items/bacta.wav" )
local DenySound = Sound( "WallHealth.Deny" )

function SWEP:Initialize()
	
	self:SetHoldType( "slam" )
	--self.Owner:GetViewModel( ):SetMaterial( "materials/reskin/healthkit01.vtf" )
	if ( CLIENT ) then 
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		end 

	timer.Create( "medkit_ammo" .. self:EntIndex(), .2, 0, function()
		if ( self:Clip1() < self.MaxAmmo ) then self:SetClip1( math.min( self:Clip1() + 100, self.MaxAmmo ) ) end
	end )

end

function SWEP:PrimaryAttack()

	if ( CLIENT ) then return end

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 256,
		filter = self.Owner
	} )

	local ent = tr.Entity
	
	local need
	if ( IsValid( ent ) ) then need = math.min( ent.var - ent:Health(), ent.var * .25 ) end

	if ( IsValid( ent ) && self:Clip1() >= 50 && ( ent:IsPlayer() || ent:IsNPC() ) && ent:Health() < ent.var ) then

		self:TakePrimaryAmmo( need )

		ent:SetHealth( math.min( ent.var, ent:Health() + need ) )
		ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() + 0 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		-- Even though the viewmodel has looping IDLE anim at all times, we need this to make fire animation work in multiplayer
		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )

	else

		self.Owner:EmitSound( DenySound )
		self:SetNextPrimaryFire( CurTime() + .1 )

	end

end

function SWEP:Reload()

	if ( CLIENT ) then return end

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 128,
		filter = self.Owner
	} )

	local ent = tr.Entity
	local me = self.Owner
	
	local need = self.HealAmount
	

	if ( IsValid( ent ) && self:Clip1() >= 100 && ( ent:IsPlayer()))  then

		self:TakePrimaryAmmo( 100 )

		ent:GiveAmmo(1000, 1, false)
		me:GiveAmmo(1000, 1, false)
		//ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() + 0 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		-- Even though the viewmodel has looping IDLE anim at all times, we need this to make fire animation work in multiplayer
		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )
--[[
	elseif( ( IsValid( ent ) && self:Clip1() >= 100)) then 
	self.Owner:GiveAmmo(2000, 1, false)
		ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() + 0 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		-- Even though the viewmodel has looping IDLE anim at all times, we need this to make fire animation work in multiplayer
		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )
	]]--
	else

		
		self:SetNextPrimaryFire( CurTime() + 1 )

	end

end

function SWEP:SecondaryAttack()

	if ( CLIENT ) then return end

	local ent = self.Owner
	--print (ent.var)
	local need
	
	if ( IsValid( ent ) ) then need = math.min( ent.var - ent:Health(), ent.var * .25 ) end
	
	if ( IsValid( ent ) && self:Clip1() >= need && ent:Health() < ent.var ) then

		self:TakePrimaryAmmo( 50 )

		ent:SetHealth( math.min( ent.var, ent:Health() + need ) )
		ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		--self:SetNextSecondaryFire( CurTime() + self:SequenceDuration() + 1 )
		self:SetNextSecondaryFire( CurTime() + 1 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )

	else

		ent:EmitSound( DenySound )
		self:SetNextSecondaryFire( CurTime() + 1 )

	end

	end



function SWEP:OnRemove()

	timer.Stop( "medkit_ammo" .. self:EntIndex() )
	timer.Stop( "weapon_idle" .. self:EntIndex() )
	self:Holster()

end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	

	timer.Stop( "weapon_idle" .. self:EntIndex() )
	
	return true

end

function SWEP:CustomAmmoDisplay()

	self.AmmoDisplay = self.AmmoDisplay or {} 
	self.AmmoDisplay.Draw = true
	self.AmmoDisplay.PrimaryClip = self:Clip1()

	return self.AmmoDisplay

end

if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)
		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end
		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
			
		end
		
	end
	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )
		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then
			self.wRenderOrder = {}
			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
			
		end
		
	end
	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)
			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end
	function SWEP:CreateModels( tab )
		if (!tab) then return end
		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

--PATH gamemodes/starwarsrp/entities/weapons/weapon_glock2/shared.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/weapons/weapon_handcuffed.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/weapons/weapon_handcuffed.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_handcuffed.lua    SHARED --
--                                 --
-- Handcuffed. Limits what         --
-- equipping player can do.        --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_base"

SWEP.Category = "Handcuffs"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = ""

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

SWEP.Slot = 4
SWEP.PrintName = "Handcuffed"

SWEP.ViewModelFOV = 60
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.ViewModel = "models/weapons/c_arms_citizen.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 1

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = -1

SWEP.DeploySpeed = 1.5

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "duel"

SWEP.IsHandcuffs = true
SWEP.CuffType = ""

CreateConVar( "cuffs_allowbreakout", 0, {FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE,FCVAR_REPLICATED,FCVAR_NOTIFY} )

// For anything that might try to drop this
SWEP.CanDrop = false
SWEP.PreventDrop = true
-- Missing anything?

//
// DataTables
function SWEP:SetupDataTables()
	self:NetworkVar( "Entity", 0, "Kidnapper" )
	self:NetworkVar( "Entity", 1, "FriendBreaking" )
	
	self:NetworkVar( "Float", 0, "RopeLength" )
	self:NetworkVar( "Float", 1, "CuffBroken" )
	self:NetworkVar( "Float", 2, "CuffStrength" )
	self:NetworkVar( "Float", 3, "CuffRegen" )
	
	self:NetworkVar( "String", 0, "RopeMaterial" )
	self:NetworkVar( "String", 1, "CuffMaterial" )
	
	self:NetworkVar( "Bool", 0, "CanGag" )
	self:NetworkVar( "Bool", 1, "IsGagged" )
	
	self:NetworkVar( "Bool", 2, "CanBlind" )
	self:NetworkVar( "Bool", 3, "IsBlind" )
end

//
// Initialize
function SWEP:Initialize()
	hook.Add( "canDropWeapon", self, function(wep, ply) if wep==self then return false end end) // Thank you DarkRP, your code is terrible
	
	if self:GetCuffStrength()<=0 then self:SetCuffStrength(1) end
	if self:GetCuffRegen()<=0 then self:SetCuffRegen(1) end
	self:SetCuffBroken( 0 )
	
	self:SetHoldType( self.HoldType )
end

//
// Standard SWEP functions
function SWEP:PrimaryAttack()
	if SERVER then self:AttemptBreak() end
end
function SWEP:SecondaryAttack() end
function SWEP:Reload() end

//
// Equip and Holster
function SWEP:Equip( newOwner )
	newOwner:SelectWeapon( self:GetClass() )
	
	timer.Simple( 0.1, function() // Fucking FA:S
		if IsValid(self) and  IsValid(newOwner) and newOwner:GetActiveWeapon()~=self then
			local wep = newOwner:GetActiveWeapon()
			if not IsValid(wep) then return end
			
			local oHolster = wep.Holster
			wep.Holster = function() return true end
			newOwner:SelectWeapon( self:GetClass() )
			wep.Holster = oHolster
		end
	end)
	
	return true
end
function SWEP:Holster()
	return false
end

//
// Deploy
function SWEP:Deploy()
	local viewModel = self.Owner:GetViewModel()
	viewModel:SendViewModelMatchingSequence( viewModel:LookupSequence("fists_idle_01") )
	
	return true
end
function SWEP:PreDrawViewModel( viewModel ) // Fixes visible base hands
	viewModel:SetMaterial( "engine/occlusionproxy" )
end
function SWEP:OnRemove() // Fixes invisible other weapons
	if IsValid(self.Owner) then
		local viewModel = self.Owner:GetViewModel()
		if IsValid(viewModel) then viewModel:SetMaterial("") end
	end
	if IsValid( self.cmdl_LeftCuff ) then self.cmdl_LeftCuff:Remove() end
	if IsValid( self.cmdl_RightCuff ) then self.cmdl_RightCuff:Remove() end
	return true
end

//
// Release
function SWEP:Uncuff()
	local ply = IsValid(self.Owner) and self.Owner
	
	self:Remove()
	
	if ply then ply:ConCommand( "lastinv" ) end
end

//
// Breakout
if SERVER then
	local BreakSound = Sound( "physics/metal/metal_barrel_impact_soft4.wav" )
	function SWEP:Breakout()
		if IsValid(self.Owner) then
			sound.Play( BreakSound, self.Owner:GetShootPos(), 75, 100, 1 )
			if IsValid( self:GetFriendBreaking() ) then
				hook.Call( "OnHandcuffBreak", GAMEMODE, self.Owner, self, self:GetFriendBreaking() )
			else
				hook.Call( "OnHandcuffBreak", GAMEMODE, self.Owner, self )
			end
		end
		
		self:Uncuff()
	end
	function SWEP:AttemptBreak()
		if not cvars.Bool( "cuffs_allowbreakout" ) then return end
		
		self:SetCuffBroken( self:GetCuffBroken() + math.abs(4/self:GetCuffStrength()) )
		
		if self:GetCuffBroken()>=100 then
			self:Breakout()
		end
	end
	
	local function GetTrace( ply )
		local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
		if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
			local cuffed,wep = tr.Entity:IsHandcuffed()
			if cuffed then return tr,wep end
		end
	end
	function SWEP:Think()
		if (self.NextRegen or 0)<=CurTime() then
			local regen = self:GetCuffRegen()
			local friend = self:GetFriendBreaking()
			if IsValid(friend) and friend:IsPlayer() then
				local tr = GetTrace(friend)
				if tr and tr.Entity==self.Owner then
					regen = (regen*0.5) - (2/self:GetCuffStrength())
				else
					self:SetFriendBreaking( nil )
				end
			end
			
			self:SetCuffBroken( math.Approach( self:GetCuffBroken(), regen<0 and 100 or 0, math.abs(regen) ) )
			self.NextRegen = CurTime()+0.05
			
			if self:GetCuffBroken()>=100 then self:Breakout() end
		end
		if IsValid(self:GetKidnapper()) and (self:GetKidnapper():IsPlayer() and not self:GetKidnapper():Alive()) then
			self:SetKidnapper( nil )
		end
		if IsValid(self.Owner) then
			self.Owner.KnockoutTimer = CurTime()+10 // Fucking DarkRP
		end
	end
end

//
// UI
if CLIENT then
	surface.CreateFont( "HandcuffsText", {
		font = "Arial",
		size = 24,
		weight = 700,
		extended = true
	})
	surface.CreateFont( "takiChuj", {
		font = "Default",
		extended = true,
		size = ScreenScale(60),
		weight = 500,
		blursize = 0,
		scanlines = 0,
		antialias = true
	})
	local Col = {
		Text = Color(255,255,255), TextShadow = Color(0,0,0),
		
		BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),
		
		Blind = Color(0,0,0, 253), Blind2 = Color(0,0,0, 255),
	}
	local matGrad = Material( "gui/gradient" )
	function SWEP:DrawHUD()
		local w,h = (ScrW()/2), (ScrH()/2)
		
		local TextPos = h+30
		local str = string.format( "Your hands are bound%s",
			((self:GetCuffStrength()>1.2) and " tightly") or ((self:GetCuffStrength()<0.8) and " loosely") or ""
		)
		if self:GetCuffRegen()>1.2 or self:GetCuffRegen()<0.8 then
			str = str.. string.format( " with a %s material", ((self:GetCuffRegen()>1.2) and "sturdy") or "flimsy" )
		end
		
		
		draw.SimpleText( "Twoje ręce zostały unieszkodliwione", "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
		draw.SimpleText( "Twoje ręce zostały unieszkodliwione", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		
		if self:GetIsBlind() then
			TextPos = TextPos+20
			draw.SimpleText( "Coś zasłania ci oczy...", "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( "Coś zasłania ci oczy...", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		end
		if self:GetIsGagged() then
			TextPos = TextPos+20
			draw.SimpleText( "Coś uniemożliwia ci mówienie...", "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( "Coś uniemożliwia ci mówienie...", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		end
		
		if cvars.Bool( "cuffs_allowbreakout" ) then
			TextPos = TextPos+20
			str = string.format("%s to struggle", (input.LookupBinding("+attack") or "[Primary Fire]"):upper())
			draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		end
		
		/*TextPos = TextPos+25
		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w-101, TextPos-1, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, TextPos, 200, 20 )
		
		render.SetScissorRect( w-100, TextPos, (w-100)+((self:GetCuffBroken()/100)*200), TextPos+20, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w-100,TextPos, 200,20 )
			
			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w-100,TextPos, 200,20 )
		render.SetScissorRect( 0,0,0,0, false )*/
	end
	function SWEP:DrawHUDBackground()
		if self:GetIsBlind() then
			surface.SetDrawColor( Col.Blind )
			surface.DrawRect( 0,0, ScrW(), ScrH() )
			
			surface.SetDrawColor( Col.Blind2 )
			for i=1,ScrH(),5 do
				surface.DrawRect( 0,i, ScrW(), 4 )
			end
			for i=1,ScrW(),5 do
				surface.DrawRect( i,0, 4,ScrH() )
			end
		end
	end

	hook.Add("PostDrawHUD", "NoIchujNicNieWidacXD", function()
	
		local graczyk = LocalPlayer()

		local bronGraczka = graczyk:GetActiveWeapon()

		if !IsValid(bronGraczka) then return end

		if bronGraczka:GetClass() != "weapon_handcuffed" then return end

		if bronGraczka:GetIsBlind() and gui.IsGameUIVisible() then

			draw.RoundedBox(0, 0, 0, ScrW(), ScrH(), Color(0,0,0,255))
			draw.SimpleText("TAKI CHUJ", "takiChuj", ScrW()/2, ScrH()/3, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			draw.SimpleText("DEVELOPER POZDRAWIA", "takiChuj", ScrW()/2, ScrH() - ScrH()/3, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		end
	
	end)
end

//
// Rendering
local renderpos = {
	left = {bone = "ValveBiped.Bip01_L_Wrist", pos=Vector(0.4,-0.15,-0.45), ang=Angle(90,0,0), scale = Vector(0.035,0.035,0.015)},
	right = {bone = "ValveBiped.Bip01_R_Wrist", pos=Vector(0.2,-0.15,0.35), ang=Angle(100,0,0), scale = Vector(0.035,0.035,0.015)},
	rope = {l = Vector(-0.2,1.3,-0.25), r = Vector(0.4,1.4,-0.2)},
}
local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"
local DefaultRope = "cable/cable2"
local RopeCol = Color(255,255,255)
function SWEP:ViewModelDrawn( vm )
	if not IsValid(vm) then return end
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
		self.cmdl_LeftCuff:SetParent( vm )
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
		self.cmdl_RightCuff:SetParent( vm )
	end
	
	local lpos, lang = self:GetBonePos( renderpos.left.bone, vm )
	local rpos, rang = self:GetBonePos( renderpos.right.bone, vm )
	if not (lpos and rpos and lang and rang) then return end
	
	// Left
	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward()*renderpos.left.pos.x) + (lang:Right()*renderpos.left.pos.y) + (lang:Up()*renderpos.left.pos.z) )
	local u,r,f = lang:Up(), lang:Right(), lang:Forward() // Prevents moving axes
	lang:RotateAroundAxis( u, renderpos.left.ang.y )
	lang:RotateAroundAxis( r, renderpos.left.ang.p )
	lang:RotateAroundAxis( f, renderpos.left.ang.r )
	self.cmdl_LeftCuff:SetAngles( lang )
	
	local matrix = Matrix()
	matrix:Scale( renderpos.left.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()
	
	// Right
	self.cmdl_RightCuff:SetPos( rpos + (rang:Forward()*renderpos.right.pos.x) + (rang:Right()*renderpos.right.pos.y) + (rang:Up()*renderpos.right.pos.z) )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, renderpos.right.ang.y )
	rang:RotateAroundAxis( r, renderpos.right.ang.p )
	rang:RotateAroundAxis( f, renderpos.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( renderpos.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_RightCuff:DrawModel()
	
	// Rope
	if self:GetRopeMaterial()~=self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end
	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( lpos + (lang:Forward()*renderpos.rope.l.x) + (lang:Right()*renderpos.rope.l.y) + (lang:Up()*renderpos.rope.l.z),
		rpos + (rang:Forward()*renderpos.rope.r.x) + (rang:Right()*renderpos.rope.r.y) + (rang:Up()*renderpos.rope.r.z),
		0.7, 0, 5, RopeCol )
end

local wrender = {
	left = {bone = "ValveBiped.Bip01_L_Hand", pos=Vector(0,0,0), ang=Angle(90,0,0), scale = Vector(0.035,0.035,0.035)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos=Vector(0.2,0,0), ang=Angle(90,0,0), scale = Vector(0.035,0.035,0.035)},
	rope = {l = Vector(-0.2,1.3,-0.25), r = Vector(0.4,1.4,-0.2)},
}
function SWEP:DrawWorldModel()
	if not IsValid(self.Owner) then return end
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
		-- self.cmdl_LeftCuff:SetParent( vm )
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
		-- self.cmdl_RightCuff:SetParent( vm )
	end
	
	local lpos, lang = self:GetBonePos( wrender.left.bone, self.Owner )
	local rpos, rang = self:GetBonePos( wrender.right.bone, self.Owner )
	if not (lpos and rpos and lang and rang) then return end
	
	// Left
	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward()*wrender.left.pos.x) + (lang:Right()*wrender.left.pos.y) + (lang:Up()*wrender.left.pos.z) )
	local u,r,f = lang:Up(), lang:Right(), lang:Forward() // Prevents moving axes
	lang:RotateAroundAxis( u, wrender.left.ang.y )
	lang:RotateAroundAxis( r, wrender.left.ang.p )
	lang:RotateAroundAxis( f, wrender.left.ang.r )
	self.cmdl_LeftCuff:SetAngles( lang )
	
	local matrix = Matrix()
	matrix:Scale( wrender.left.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()
	
	// Right
	self.cmdl_RightCuff:SetPos( rpos + (rang:Forward()*wrender.right.pos.x) + (rang:Right()*wrender.right.pos.y) + (rang:Up()*wrender.right.pos.z) )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, wrender.right.ang.y )
	rang:RotateAroundAxis( r, wrender.right.ang.p )
	rang:RotateAroundAxis( f, wrender.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( wrender.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_RightCuff:DrawModel()
	
	// Rope
	if (lpos.x==0 and lpos.y==0 and lpos.z==0) or (rpos.x==0 and rpos.y==0 and rpos.z==0) then return end // Rope accross half the map...
	
	if self:GetRopeMaterial()~=self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end
	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( lpos + (lang:Forward()*wrender.rope.l.x) + (lang:Right()*wrender.rope.l.y) + (lang:Up()*wrender.rope.l.z),
		rpos + (rang:Forward()*wrender.rope.r.x) + (rang:Right()*wrender.rope.r.y) + (rang:Up()*wrender.rope.r.z),
		0.7, 0, 5, RopeCol )
end

//
// Bones
function SWEP:GetBonePos( bonename, vm )
	local bone = vm:LookupBone( bonename )
	if not bone then return end
	
	local pos,ang = Vector(0,0,0),Angle(0,0,0)
	local matrix = vm:GetBoneMatrix( bone )
	if matrix then
		pos = matrix:GetTranslation()
		ang = matrix:GetAngles()
	end
	
	if self.ViewModelFlip then ang.r = -ang.r end
	
	-- if pos.x==0 and pos.y==0 and pos.z==0 then print( bonename, vm ) end
	return pos, ang
end

--PATH lua/weapons/weapon_hl2brokenbottle/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Broken Bottle"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Stab"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_brokenbottle.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_brokenbottle.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 28
SWEP.HitInclination		= 0.2
SWEP.HitPushback		= 0
SWEP.HitRate			= 0.50
SWEP.MinDamage			= 5
SWEP.MaxDamage			= 15

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "knife" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()

	return true	
end

function SWEP:OnDrop()
	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + ( self.Owner:GetAimVector() * self.HitDistance * 1.5 ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = self.Owner:GetShootPos()
		bullet.Dir    = self.Owner:GetAimVector()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 5
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 5, 15 )
		self.Owner:FireBullets(bullet)

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
		else
			self:EmitSound( HitSoundWorld )
		end

	
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay")
	return true
end
--PATH lua/weapons/weapon_hl2pickaxe/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_hl2shovel/shared.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/shared.lua:

--SWEP.Base = "weapon_pvebase"
--DEFINE_BASECLASS( "weapon_pvebase" )
SWEP.Base = "weapon_base"

SWEP.Category			= "[LSCS]"

SWEP.PrintName		= "#lscsGlowstick"
SWEP.Author			= "Blu-x92 / Luna"

SWEP.ViewModel		= "models/weapons/c_arms.mdl"
SWEP.WorldModel		= "models/lscs/weapons/katarn.mdl"

SWEP.Spawnable		= true
SWEP.AdminOnly		= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip		= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo		= "none"

SWEP.RenderGroup = RENDERGROUP_BOTH 

SWEP.AutoSwitchFrom = false

SWEP.LSCS = true

SWEP._tblHilt = {}
SWEP._tblBlade = {}

SWEP.HAND_RIGHT = 1
SWEP.HAND_LEFT = 2
SWEP.HAND_STRING = {
	[SWEP.HAND_RIGHT] = "RH",
	[SWEP.HAND_LEFT] = "LH",
}

SWEP.CachedSounds = {
	[SWEP.HAND_RIGHT]	= {
		AttackSound = "",
		AttackSound1 = "",
		AttackSound2 = "",
		AttackSound3 = "",
		ActivateSound = "",
		DisableSound = "",
		IdleSound = "",
	},
	[SWEP.HAND_LEFT] = {
		AttackSound = "",
		AttackSound1 = "",
		AttackSound2 = "",
		AttackSound3 = "",
		ActivateSound = "",
		DisableSound = "",
		IdleSound = "",
	},
}

function SWEP:SetupDataTables()
	self:NetworkVar( "Bool",0, "Active" )
	self:NetworkVar( "Bool",1, "NWDMGActive" )
	self:NetworkVar( "Bool",2, "AnimHasCancelAnim" )

	self:NetworkVar( "Float",0, "NWNextAttack" )
	self:NetworkVar( "Float",1, "NWGestureTime" )
	self:NetworkVar( "Float",2, "Length" )
	self:NetworkVar( "Float",3, "ComboHits" )
	self:NetworkVar( "Float",4, "BlockPointNotifyTime" )

	self:NetworkVar( "Int",0, "NWStance" )
	self:NetworkVar( "Int",1, "BlockPoints" )

	self:NetworkVar( "Vector",0, "BlockPos" )

	self:NetworkVar( "String",0, "HiltR")
	self:NetworkVar( "String",1, "HiltL")
	self:NetworkVar( "String",2, "BladeR")
	self:NetworkVar( "String",3, "BladeL")

	self:NetworkVar( "Entity",0, "Projectile" )

	if SERVER then
		self:SetNWStance( 1 )
	end
end

function SWEP:IsThrown()
	return IsValid( self:GetProjectile() )
end

function SWEP:GetHiltData( hand )
	local HiltR = self:GetHiltR()
	local HiltL = self:GetHiltL()

	if self._oldHiltR ~= HiltR then
		self._oldHiltR = HiltR

		local _HiltR = LSCS:GetHilt( HiltR )

		self._tblHilt[self.HAND_RIGHT] = _HiltR

		if CLIENT then
			self:UpdateWorldModel(self.HAND_RIGHT, _HiltR)
		end
	end

	if self._oldHiltL ~= HiltL then
		self._oldHiltL = HiltL

		local _HiltL = LSCS:GetHilt( HiltL )

		self._tblHilt[self.HAND_LEFT] = _HiltL

		if CLIENT then
			self:UpdateWorldModel(self.HAND_LEFT, _HiltL)
		end
	end

	if hand then
		return self._tblHilt[ hand ]
	else
		return self._tblHilt
	end
end

function SWEP:GetBladeData( hand )
	local BladeR = self:GetBladeR()
	local BladeL = self:GetBladeL()

	if self._oldBladeR ~= BladeR then
		self._oldBladeR = BladeR
		self._tblBlade[1] = LSCS:GetBlade( BladeR )
	end

	if self._oldBladeL ~= BladeL then
		self._oldBladeL = BladeL
		self._tblBlade[2] = LSCS:GetBlade( BladeL )
	end

	if hand then
		return self._tblBlade[ hand ]
	else
		return self._tblBlade
	end
end

function SWEP:BuildSounds()
	if self:IsBrokenSaber() then return end

	for hand = 1, 2 do
		local data = self:GetBladeData()[ hand ]

		if data then
			local SND = data.sounds

			self.CachedSounds[ hand ] = {
				AttackSound = (SND.Attack or ""),
				AttackSound1 = (SND.Attack1 or ""),
				AttackSound2 = (SND.Attack2 or ""),
				AttackSound3 = (SND.Attack3 or ""),
				ActivateSound = (SND.Activate or ""),
				DisableSound = (SND.Disable or ""),
				IdleSound = (SND.Idle or ""),
			}
		else
			self.CachedSounds[ hand ] = {
				AttackSound = "",
				AttackSound1 = "",
				AttackSound2 = "",
				AttackSound3 = "",
				ActivateSound = "",
				DisableSound = "",
				IdleSound = "",
			}
		end
	end
end

function SWEP:SetDMGActive( active )
	if SERVER then
		self:SetNWDMGActive( active )
	else
		self.b_dmgActive = active
	end
end

function SWEP:GetDMGActive()
	if CLIENT and not self:IsThrown() then
		if self:GetOwner() ~= LocalPlayer() then
			return self:GetNWDMGActive()
		else
			return self.b_dmgActive
		end
	else
		return self:GetNWDMGActive()
	end
end

function SWEP:SetNextPrimaryAttack( time )
	self:SetNWNextAttack( time )
	self.f_NextAttack = time
end

function SWEP:GetNextPrimaryAttack()
	if game.SinglePlayer() then
		return (self.f_NextAttack or 0) -- singleplayer IS a prediction error
	else
		return math.max( (self.f_NextAttack or 0), self:GetNWNextAttack()) -- first variable is for prediction, second variable for correcting when the server responds.
	end
end

function SWEP:CanPrimaryAttack()
	return self:GetNextPrimaryAttack() < CurTime()
end

function SWEP:Initialize()
	self:SetHoldType( "normal" )
	self:DrawShadow( false )
	self:SetNextPrimaryAttack( CurTime() + 1 )
end

function SWEP:PrimaryAttack()
end

function SWEP:SecondaryAttack()
	if self:IsThrown() then return end

	local CurStance = self:GetNWStance()

	if CurStance == -1 then return end

	self:SetNWStance( CurStance + 1 )
end

function SWEP:DoAttackSound( N, hand )
	if not self:GetDMGActive() then return end

	if hand then
		if hand == self.HAND_LEFT and not self:GetCombo().LeftSaberActive then return end -- this is gay

		if N then
			if N == 1 then
				self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound1 )
			elseif N == 2 then
				self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound2 )
			elseif N == 3 then
				self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound3 )
			else
				self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound )
			end
		else
			self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound )
		end
	else
		for hand = self.HAND_RIGHT, self.HAND_LEFT do
			if hand == self.HAND_LEFT and not self:GetCombo().LeftSaberActive then continue end -- this is gay

			if N then
				if N == 1 then
					self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound1 )
				elseif N == 2 then
					self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound2 )
				elseif N == 3 then
					self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound3 )
				else
					self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound )
				end
			else
				self:EmitSoundUnpredicted( self.CachedSounds[ hand ].AttackSound )
			end
		end
	end
end

function SWEP:Holster( wep )
	self:SetActive( false )
	self:SetLength( 0 )

	self:FinishCombo()

	self:Think()

	if SERVER then
		local ply = self:GetOwner()
		if IsValid( ply ) and ply:IsPlayer() then
			ply:lscsSetShouldBleed( true )
		end
	end

	return true
end

function SWEP:BeginAttack()
	self:SetDMGActive( true )
end

function SWEP:FinishAttack()
	self:SetDMGActive( false )

	local ply = self:GetOwner()
	if IsValid( ply ) then
		ply:lscsClearTimedMove()
		ply:Freeze( false )
	end

	self:SetBlockPos( Vector(0,0,0) )
end

function SWEP:Deploy()
	return true
end

function SWEP:OwnerChanged()
end

function SWEP:IsBrokenSaber()
	if not self._IsBroken then
		local Hilt1 = self:GetHiltR() == "" and 0 or 1
		local Hilt2 = self:GetHiltL() == "" and 0 or 1
		local Blade1 = self:GetBladeR() == "" and 0 or 1
		local Blade2 = self:GetBladeL() == "" and 0 or 1

		self._IsBroken = ((Hilt1 + Blade1) ~= 2 and (Hilt2 + Blade2) ~= 2)
	end

	return self._IsBroken
end

function SWEP:Think()
	self:ComboThink()

	local Active = self:GetActive()
	local Stance = self:GetStance()

	local FT = FrameTime()
	local Length = self:GetLength()

	self:SetLength( Length + math.Clamp((Active and 1 or 0) - Length,-FT * 1.5,FT * 3) )

	if Active ~= self.OldActive then
		self.OldActive = Active

		if Active then
			self:BuildSounds()

			self:SetHoldType( self:GetCombo().HoldType )

			self:EmitSoundUnpredicted( self.CachedSounds[1].ActivateSound )

			if self:GetCombo().LeftSaberActive then
				self:EmitSoundUnpredicted( self.CachedSounds[2].ActivateSound )
			end
		else
			self:SetHoldType( "normal" )

			self:EmitSoundUnpredicted( self.CachedSounds[1].DisableSound )

			if self:GetCombo().LeftSaberActive then
				self:EmitSoundUnpredicted( self.CachedSounds[2].DisableSound )
			end
		end

		self:OnActiveChanged( self.OldActive, Active )
	end

	if Stance ~= self.OldStance then
		if self:GetActive() then
			self:SetHoldType( self:GetCombo().HoldType )
		end

		self.OldStance = Stance
	end
	
	self:OnTick( Active )
end

function SWEP:AimDistanceTo( _pos )
	local ply = self:GetOwner()

	if not IsValid( ply ) then return 0 end

	local Pos = ply:lscsGetViewOrigin()
	local EndPos = Pos + ply:EyeAngles():Forward() * 500

	return util.DistanceToLine( Pos, EndPos, _pos )
end

function SWEP:GetBlockDistanceTo( _pos )
	local ply = self:GetOwner()

	if not IsValid( ply ) then return 100 end

	local BlockDistance = self:AimDistanceTo( _pos )

	if ply:WorldToLocal( _pos ).x < 0 then
		BlockDistance = 100
	end

	return BlockDistance
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_electrobat.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Vibrobat"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("vibrobat") 
		self:SetBladeR("elstb") 
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_electrokatana.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_electrokatana.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Vibro Katana"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("vibrokatana") 
		self:SetBladeR("elstk") 
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_magnastaff.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Magnaguard Electrostaff"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType 	= "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )
	
	if SERVER then
		self:SetHiltR("magnastaff") 
		self:SetBladeR("purpstaff")
		//self:SetStance("yongli")
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_purgevibrosword.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_savagespear.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_shockstaff.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Shock Electrostaff"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType 	= "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("magnastaff") 
		self:SetBladeR("yellstaff") 
		//self:SetStance("yongli")
	end
end
--PATH gamemodes/starwarsrp/entities/weapons/weapon_pumpshotgun2/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_swsft_base/shared.lua:

if (SERVER) then

	AddCSLuaFile( "shared.lua" )
	SWEP.Weight				= 5
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false

end

if ( CLIENT ) then

	SWEP.DrawAmmo			= true
	SWEP.DrawCrosshair		= false
	SWEP.ViewModelFOV		= 82
	SWEP.ViewModelFlip		= false
	SWEP.CSMuzzleFlashes	= false
	SWEP.BounceWeaponIcon = false

end

SWEP.Author			= "Syntax_Error752"
SWEP.Contact		= ""
SWEP.Purpose		= "To eradicate the disease that is our enemy"
SWEP.Instructions	= ""

--SWEP.Category = "TFA Star Wars"

SWEP.Spawnable			= false
SWEP.AdminSpawnable		= false

SWEP.Primary.Recoil			= 0.5
SWEP.Primary.Damage			= 50
SWEP.Primary.NumShots		= 1
SWEP.Primary.Spread		= 0.0125
SWEP.Primary.Delay = 0.175

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"
SWEP.Primary.Tracer = "effect_sw_laser_red"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"






--[[---------------------------------------------------------
---------------------------------------------------------]]
function SWEP:Initialize()

	if ( SERVER ) then
		self:SetNPCMinBurst( 30 )
		self:SetNPCMaxBurst( 30 )
		self:SetNPCFireRate( 0.01 )
	end
	
	self:SetWeaponHoldType( self.HoldType )
	self.Weapon:SetNetworkedBool( "Ironsights", false ) 
end

--[[---------------------------------------------------------
   Think does nothing
---------------------------------------------------------]]
function SWEP:Think()	
end

--[[---------------------------------------------------------
	Checks the objects before any action is taken
	This is to make sure that the entities haven't been removed
-----------------------------------------------------------]]
--function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
	
	--draw.SimpleText( self.IconLetter, "DODSelectIcons", x + wide/2, y + tall*0.2, Color( 255, 210, 0, 255 ), TEXT_ALIGN_CENTER )
	
	-- try to fool them into thinking they're playing a Tony Hawks game
	--draw.SimpleText( self.IconLetter, "DODSelectIcons", x + wide/2 + math.Rand(-4, 4), y + tall*0.2+ math.Rand(-14, 14), Color( 255, 210, 0, math.Rand(10, 120) ), TEXT_ALIGN_CENTER )
	--draw.SimpleText( self.IconLetter, "DODSelectIcons", x + wide/2 + math.Rand(-4, 4), y + tall*0.2+ math.Rand(-9, 9), Color( 255, 210, 0, math.Rand(10, 120) ), TEXT_ALIGN_CENTER )
	
--end

local IRONSIGHT_TIME = 0.25

--[[---------------------------------------------------------
   Name: GetViewModelPosition
   Desc: Allows you to re-position the view model
---------------------------------------------------------]]
function SWEP:GetViewModelPosition( pos, ang )

	if ( !self.IronSightsPos ) then return pos, ang end

	local bIron = self.Weapon:GetNetworkedBool( "Ironsights" )
	
	if ( bIron != self.bLastIron ) then
	
		self.bLastIron = bIron 
		self.fIronTime = CurTime()
		
		if ( bIron ) then 
			self.SwayScale 	= 0.3
			self.BobScale 	= 0.1
		else 
			self.SwayScale 	= 1.0
			self.BobScale 	= 1.0
		end
	
	end
	
	local fIronTime = self.fIronTime or 0

	if ( !bIron && fIronTime < CurTime() - IRONSIGHT_TIME ) then 
		return pos, ang 
	end
	
	local Mul = 1.0
	
	if ( fIronTime > CurTime() - IRONSIGHT_TIME ) then
	
		Mul = math.Clamp( (CurTime() - fIronTime) / IRONSIGHT_TIME, 0, 1 )
		
		if (!bIron) then Mul = 1 - Mul end
	
	end

	local Offset	= self.IronSightsPos
	
	if ( self.IronSightsAng ) then
	
		ang = ang * 1
		ang:RotateAroundAxis( ang:Right(), 		self.IronSightsAng.x * Mul )
		ang:RotateAroundAxis( ang:Up(), 		self.IronSightsAng.y * Mul )
		ang:RotateAroundAxis( ang:Forward(), 	self.IronSightsAng.z * Mul )
	
	
	end
	
	local Right 	= ang:Right()
	local Up 		= ang:Up()
	local Forward 	= ang:Forward()
	
	

	pos = pos + Offset.x * Right * Mul
	pos = pos + Offset.y * Forward * Mul
	pos = pos + Offset.z * Up * Mul

	return pos, ang
	
end

--[[---------------------------------------------------------
	SetIronsights
---------------------------------------------------------]]
function SWEP:SetIronsights( b )

	self.Weapon:SetNetworkedBool( "Ironsights", b )

end


SWEP.NextSecondaryAttack = 0
--[[---------------------------------------------------------
	SecondaryAttack
---------------------------------------------------------]]
function SWEP:SecondaryAttack()

	if ( !self.IronSightsPos ) then return end
	if ( self.NextSecondaryAttack > CurTime() ) then return end
	
	bIronsights = !self.Weapon:GetNetworkedBool( "Ironsights", false )
	
	self:SetIronsights( bIronsights )
	
	self.NextSecondaryAttack = CurTime() + 0.3
	
end

/*---------------------------------------------------------
	DrawHUD
	
	Just a rough mock up showing how to draw your own crosshair.
	
---------------------------------------------------------*/

function SWEP:DrawHUD()

	-- No crosshair when ironsights is on
	if ( self.Weapon:GetNetworkedBool( "Ironsights" ) ) then return end

	local x, y

	-- If we're drawing the local player, draw the crosshair where they're aiming,
	-- instead of in the center of the screen.
	if ( self.Owner == LocalPlayer() && self.Owner:ShouldDrawLocalPlayer() ) then

		local tr = util.GetPlayerTrace( self.Owner )
--		tr.mask = ( CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE|CONTENTS_AUX )
		local trace = util.TraceLine( tr )
		
		local coords = trace.HitPos:ToScreen()
		x, y = coords.x, coords.y

	else
		x, y = ScrW() / 2.0, ScrH() / 2.0
	end
	
	local scale = 10 * self.Primary.Cone
	
	-- Scale the size of the crosshair according to how long ago we fired our weapon
	local LastShootTime = self.Weapon:GetNetworkedFloat( "LastShootTime", 0 )
	scale = scale * (2 - math.Clamp( (CurTime() - LastShootTime) * 5, 0.0, 1.0 ))
	
	surface.SetDrawColor( 255, 0, 0, 255 )
	
	-- Draw an awesome crosshair
	local gap = 40 * scale
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )

end


/*---------------------------------------------------------
	onRestore
	Loaded a saved game (or changelevel)
---------------------------------------------------------*/
function SWEP:OnRestore()

	self.NextSecondaryAttack = 0
	self:SetIronsights( false )
	
end

function SWEP:DoImpactEffect( tr, dmgtype )
	if( tr.HitSky ) then return true; end
	
	--util.Decal( "fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal );
	
	if( game.SinglePlayer() or SERVER or not self:IsCarriedByLocalPlayer() or IsFirstTimePredicted() ) then

		local effect = EffectData();
		effect:SetOrigin( tr.HitPos );
		effect:SetNormal( tr.HitNormal );

		util.Effect( "effect_sw_impact", effect );

		local effect = EffectData();
		effect:SetOrigin( tr.HitPos );
		effect:SetStart( tr.StartPos );
		effect:SetDamageType( dmgtype );

		util.Effect( "RagdollImpact", effect );
	end

    return true;
end

--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_training_saber.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName		= "Training Saber"
SWEP.Author			= "Colt"

SWEP.Slot				= 0
SWEP.SlotPos			= 1

SWEP.Spawnable		= true
SWEP.AdminOnly		= true

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("colttrainingsaber")
		self:SetBladeR("trainingsaberblade")
	end
end
--PATH lua/weapons/weapon_vj_357/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= ".357 Magnum"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made for Players and NPCs"
SWEP.Instructions				= "Controls are like a regular weapon."
SWEP.Category					= "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot						= 1 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
SWEP.SlotPos					= 1 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.SwayScale 					= 4 -- Default is 1, The scale of the viewmodel sway
SWEP.UseHands					= true
end
	-- NPC Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.NPC_NextPrimaryFire 		= 0.9 -- Next time it can use primary fire
SWEP.NPC_CustomSpread	 		= 0.5 -- This is added on top of the custom spread that's set inside the SNPC! | Starting from 1: Closer to 0 = better accuracy, Farther than 1 = worse accuracy
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel					= "models/weapons/c_357.mdl"
SWEP.WorldModel					= "models/weapons/w_357.mdl"
SWEP.HoldType 					= "revolver"
SWEP.Spawnable					= true
SWEP.AdminSpawnable				= false
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage				= 20 -- Damage
SWEP.Primary.PlayerDamage		= "Double" -- Only applies for players | "Same" = Same as self.Primary.Damage, "Double" = Double the self.Primary.Damage OR put a number to be different from self.Primary.Damage
SWEP.Primary.Force				= 1 -- Force applied on the object the bullet hits
SWEP.Primary.ClipSize			= 6 -- Max amount of bullets per clip
SWEP.Primary.Recoil				= 2 -- How much recoil does the player get?
SWEP.Primary.Cone				= 1 -- How accurate is the bullet? (Players)
SWEP.Primary.Delay				= 0.9 -- Time until it can shoot again
SWEP.Primary.Automatic			= false -- Is it automatic?
SWEP.Primary.Ammo				= "357" -- Ammo type
SWEP.Primary.Sound				= {"vj_weapons/hl2_357/357_single1.wav","vj_weapons/hl2_357/357_single2.wav","vj_weapons/hl2_357/357_single3.wav"}
SWEP.Primary.DistantSound		= {"weapons/357/357_fire2.wav"}
SWEP.Primary.DistantSoundVolume	= 0.7 -- Distant sound volume
SWEP.PrimaryEffects_MuzzleAttachment = 1
SWEP.PrimaryEffects_SpawnShells = false
	-- Reload Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.HasReloadSound				= false -- Does it have a reload sound? Remember even if this is set to false, the animation sound will still play!
SWEP.Reload_TimeUntilAmmoIsSet	= 2.7 -- Time until ammo is set to the weapon
--PATH lua/weapons/weapon_vj_crossbow/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base = "weapon_vj_base"
SWEP.PrintName = "Crossbow"
SWEP.Author = "DrVrej"
SWEP.Contact = "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose = "This weapon is made for Players and NPCs"
SWEP.Instructions = "Controls are like a regular weapon."
SWEP.Category = "VJ Base"
	-- NPC Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.MadeForNPCsOnly = true
SWEP.NPC_NextPrimaryFire = 1 -- Next time it can use primary fire
SWEP.NPC_TimeUntilFire = 0.15 -- How much time until the bullet/projectile is fired?
SWEP.NPC_ReloadSound = {"weapons/crossbow/reload1.wav"}
SWEP.NPC_FiringDistanceScale = 2.5 -- Changes how far the NPC can fire | 1 = No change, x < 1 = closer, x > 1 = farther
SWEP.NPC_StandingOnly = true -- If true, the weapon can only be fired if the NPC is standing still
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.WorldModel = "models/weapons/w_crossbow.mdl"
SWEP.HoldType = "crossbow"
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.ClipSize = 1 -- Max amount of bullets per clip
SWEP.Primary.Ammo = "XBowBolt" -- Ammo type
SWEP.Primary.Sound = {"weapons/crossbow/fire1.wav"}
SWEP.Primary.DisableBulletCode = true -- The bullet won't spawn, this can be used when creating a projectile-based weapon
SWEP.PrimaryEffects_MuzzleParticles = {"vj_rifle_smoke","vj_rifle_smoke_dark","vj_rifle_smoke_flash","vj_rifle_sparks2"}
SWEP.PrimaryEffects_MuzzleParticlesAsOne = true -- If set to true, the base will spawn all the given particles instead of picking one
SWEP.PrimaryEffects_MuzzleAttachment = "muzzle"
SWEP.PrimaryEffects_SpawnShells = false
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnPrimaryAttack_BeforeShoot()
	if CLIENT then return end
	local bolt = ents.Create("obj_vj_crossbowbolt")
	local spawnpos = self:GetNW2Vector("VJ_CurBulletPos")
	bolt:SetPos(spawnpos)
	bolt:SetAngles(self:GetOwner():GetAngles())
	bolt:SetOwner(self:GetOwner())
	bolt:Activate()
	bolt:Spawn()
	
	local phys = bolt:GetPhysicsObject()
	if IsValid(phys) then
		phys:ApplyForceCenter(bolt:CalculateProjectile("Line", spawnpos, self:GetOwner():GetEnemy():GetPos() + self:GetOwner():GetEnemy():OBBCenter(), 4000) + Vector(math.Rand(-30,30), math.Rand(-30,30), math.Rand(-30,30)))
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnReload()
	timer.Simple(SoundDuration("weapons/crossbow/reload1.wav"), function()
		if IsValid(self) && IsValid(self:GetOwner()) then
			VJ_EmitSound(self:GetOwner(), {"weapons/crossbow/bolt_load1.wav","weapons/crossbow/bolt_load2.wav"}, self.NPC_ReloadSoundLevel)
		end
	end)
end
--PATH lua/weapons/weapon_vj_mp40/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= "MP 40"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made for Players and NPCs"
SWEP.Instructions				= "Controls are like a regular weapon."
SWEP.Category					= "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot						= 2 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
SWEP.SlotPos					= 4 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.SwayScale 					= 1 -- Default is 1, The scale of the viewmodel sway
SWEP.UseHands					= true
end
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel					= "models/vj_weapons/c_mp40.mdl"
SWEP.WorldModel					= "models/vj_weapons/w_mp40.mdl"
SWEP.HoldType 					= "smg"
SWEP.ViewModelFOV				= 45 -- Player FOV for the view model
SWEP.Spawnable					= true
SWEP.AdminSpawnable				= false
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage = 5 -- Damage
SWEP.Primary.PlayerDamage = "Double" -- Only applies for players | "Same" = Same as self.Primary.Damage, "Double" = Double the self.Primary.Damage OR put a number to be different from self.Primary.Damage
SWEP.Primary.Force = 5 -- Force applied on the object the bullet hits
SWEP.Primary.ClipSize = 32 -- Max amount of bullets per clip
SWEP.Primary.Recoil = 0.3 -- How much recoil does the player get?
SWEP.Primary.Delay = 0.1 -- Time until it can shoot again
SWEP.Primary.Automatic = true -- Is it automatic?
SWEP.Primary.Ammo = "SMG1" -- Ammo type
SWEP.Primary.Sound = {"vj_weapons/mp_40/mp40_single.wav"}
SWEP.Primary.DistantSound = {"vj_weapons/mp_40/mp40_single_dist.wav"}
SWEP.PrimaryEffects_MuzzleAttachment = 1
SWEP.PrimaryEffects_ShellAttachment = 2
SWEP.PrimaryEffects_ShellType = "VJ_Weapon_RifleShell1"
	-- Deployment Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.HasDeploySound = false -- Does the weapon have a deploy sound?
	-- Reload Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Reload_TimeUntilAmmoIsSet	= 2.1 -- Time until ammo is set to the weapon
--PATH lua/weapons/weapon_vj_npccontroller/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= "VJ NPC Controller"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made to control NPCs. Mostly VJ SNPCs"
SWEP.Instructions				= "Press Fire to control the NPC you are looking at."
SWEP.Category					= "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot						= 5 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
SWEP.SlotPos					= 7 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.SwayScale 					= 1 -- Default is 1, The scale of the viewmodel sway
SWEP.CSMuzzleFlashes 			= false -- Use CS:S Muzzle flash?
SWEP.DrawAmmo					= true -- Draw regular Garry's Mod HUD?
SWEP.DrawCrosshair				= true -- Draw Crosshair?
SWEP.DrawWeaponInfoBox 			= true -- Should the information box show in the weapon selection menu?
SWEP.BounceWeaponIcon 			= true -- Should the icon bounce in the weapon selection menu?
SWEP.RenderGroup 				= RENDERGROUP_OPAQUE
end
	-- Server Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if SERVER then
SWEP.Weight						= 30 -- Decides whether we should switch from/to this
SWEP.AutoSwitchTo				= false -- Auto switch to this weapon when it's picked up
SWEP.AutoSwitchFrom				= false -- Auto switch weapon when the owner picks up a better weapon
end
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel					= "models/vj_weapons/c_controller.mdl"
SWEP.WorldModel					= "models/gibs/humans/brain_gib.mdl"
SWEP.HoldType 					= "pistol"
SWEP.Spawnable					= true
SWEP.AdminSpawnable				= false
SWEP.UseHands = true -- Should this weapon use Garry's Mod hands? (The model must support it!)
	-- Primary/Secondary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Sound = {"physics/flesh/flesh_squishy_impact_hard1.wav","physics/flesh/flesh_squishy_impact_hard2.wav","physics/flesh/flesh_squishy_impact_hard3.wav","physics/flesh/flesh_squishy_impact_hard4.wav"} -- Sound played when the weapon is deployed
SWEP.Primary.SoundPitch	= VJ_Set(140, 140)
SWEP.Primary.ClipSize 			= -1
SWEP.Primary.DefaultClip		= -1
SWEP.Primary.Automatic 			= false
SWEP.Primary.Ammo 				= "none"
SWEP.Secondary.ClipSize 		= -1
SWEP.Secondary.DefaultClip 		= -1
SWEP.Secondary.Automatic 		= false
SWEP.Secondary.Ammo 			= "none"

SWEP.WorldModel_UseCustomPosition = true -- Should the gun use custom position? This can be used to fix guns that are in the crotch
SWEP.WorldModel_CustomPositionAngle = Vector(0, 0, 0)
SWEP.WorldModel_CustomPositionOrigin = Vector(0, 4, -1.1)
SWEP.WorldModel_CustomPositionBone = "ValveBiped.Bip01_R_Hand" -- The bone it will use as the main point (Owner's bone)
SWEP.WorldModel_Invisible = false -- Should the world model be invisible?
SWEP.WorldModel_NoShadow = false -- Should the world model have a shadow?

SWEP.DeploySound = {"physics/flesh/flesh_squishy_impact_hard1.wav","physics/flesh/flesh_squishy_impact_hard2.wav","physics/flesh/flesh_squishy_impact_hard3.wav","physics/flesh/flesh_squishy_impact_hard4.wav"} -- Sound played when the weapon is deployed
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:Initialize()
	self:SetWeaponHoldType(self.HoldType)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:PrimaryAttack()
	local owner = self:GetOwner()
	if CLIENT or owner:IsNPC() then return end
	
	owner:SetAnimation(PLAYER_ATTACK1)
	local anim = ACT_VM_SECONDARYATTACK
	local animTime = VJ_GetSequenceDuration(owner:GetViewModel(), anim)
	self:SendWeaponAnim(anim)
	self.NextIdleT = CurTime() + animTime
	self.NextReloadT = CurTime() + animTime
	self:SetNextPrimaryFire(CurTime() + animTime)
	
	local fireSd = VJ_PICK(self.Primary.Sound)
	if fireSd != false then
		sound.Play(fireSd, owner:GetPos(), self.Primary.SoundLevel, math.random(self.Primary.SoundPitch.a, self.Primary.SoundPitch.b), self.Primary.SoundVolume)
	end
	
	local tr =  util.TraceLine(util.GetPlayerTrace(owner))
	if tr.Entity && IsValid(tr.Entity) then
		if tr.Entity:IsPlayer() then
			owner:ChatPrint("That's a player dumbass.")
			return
		elseif tr.Entity:GetClass() == "prop_ragdoll" then
			owner:ChatPrint("You are about to become that corpse.")
			return
		elseif tr.Entity:GetClass() == "prop_physics" then
			owner:ChatPrint("Uninstall your game. Now.")
			return
		elseif !tr.Entity:IsNPC() then
			owner:ChatPrint("This isn't an NPC, therefore you can't control it.")
			return
		elseif tr.Entity:IsNPC() && tr.Entity:Health() <= 0 then
			owner:ChatPrint("This NPC's health is 0 or below, therefore you can't control.")
			return
		//elseif tr.Entity.IsVJBaseSNPC_Tank == true then
			//tr.Entity = tr.Entity.Gunner
			//owner:ChatPrint("Tank are not controllable yet, sorry!")
			//return
		elseif tr.Entity.VJ_IsBeingControlled == true then
			owner:ChatPrint("You can't control this NPC, it's already being controlled by someone else.")
			return
		end
		if (!tr.Entity.IsVJBaseSNPC) then
			owner:ChatPrint("NOTE: VJ NPC controller is mainly made for VJ Base SNPCs!")
		end
		local SpawnControllerObject = ents.Create("obj_vj_npccontroller")
		SpawnControllerObject.VJCE_Player = owner
		SpawnControllerObject:SetControlledNPC(tr.Entity)
		SpawnControllerObject:Spawn()
		//SpawnControllerObject:Activate()
		SpawnControllerObject:StartControlling()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:SecondaryAttack() return false end
--PATH lua/weapons/weapon_vj_ssg08/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_waterballoon/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_waterballoon/shared.lua:
if (SERVER) then --the init.lua stuff goes in here
 
   AddCSLuaFile ("shared.lua");
 
   SWEP.Weight = 5;
   SWEP.AutoSwitchTo = false;
   SWEP.AutoSwitchFrom = false;
 
end
 
if (CLIENT) then --the cl_init.lua stuff goes in here
 
   SWEP.PrintName = "Water Balloons";
   SWEP.Slot = 4;
   SWEP.SlotPos = 4;
   SWEP.DrawAmmo = true;
   SWEP.DrawCrosshair = false;
 
end

SWEP.Instructions = "Left click throws water balloons, these extinguish fires. Right click to rapid fire balloons. Reload to pick a new balloon color.";
SWEP.Category = "Sgt. Ownage"
 
SWEP.Spawnable = true;
SWEP.AdminSpawnable = true;
 
SWEP.ViewModel = "models/weapons/c_bugbait.mdl";
SWEP.WorldModel = "models/weapons/w_bugbait.mdl";
SWEP.ViewModelFOV = 54
SWEP.HoldType = "grenade"
SWEP.UseHands = true
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
    ["ValveBiped.cube3"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-30, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.Primary.ClipSize = 100;
SWEP.Primary.DefaultClip = 100;
SWEP.Primary.Automatic = false;
SWEP.Primary.Ammo = "balloons";
SWEP.Primary.Delay = 0.75


SWEP.Secondary.ClipSize = -1;
SWEP.Secondary.DefaultClip = -1;
SWEP.Secondary.Automatic = true;
SWEP.Secondary.Ammo = "none";
SWEP.Secondary.Delay = 0

function SWEP:Deploy() 
	self.Weapon:SetNWVector("MyColor",Vector(255, 0, 0)) --Red Generation
	self.Weapon:SetNWBool("HideBalloon", false)
end

function SWEP:Reload()
	if self.Weapon:GetNWBool("HideBalloon", false) then return end
	local Received = self.Weapon:GetNWVector("MyColor", Vector( 255, 0, 0))
	local h, s, v = ColorToHSV( Color( Received.x, Received.y, Received.z, 255))
	local Generation = HSVToColor(h + 20, 1, 1)
	self.Weapon:SetNWVector("MyColor",Vector(Generation.r, Generation.g, Generation.b))
	self.Weapon:SetNWBool("HideBalloon", true)
	self.Weapon:SendWeaponAnim(ACT_VM_HAULBACK)
	self.Weapon:SetHoldType( "slam" )
	timer.Simple(0.3, function() if not IsValid(self) or not IsValid(self.Owner) then return end self.Weapon:SendWeaponAnim(ACT_VM_IDLE) self.Weapon:SetNWBool("HideBalloon", false) self.Weapon:SetHoldType( "grenade" ) end)
end

function SWEP:Think()
	if CLIENT then
		local Received = self.Weapon:GetNWVector("MyColor",Vector( 255, 255, 255))
		local Translation = Color(Received.x, Received.y, Received.z, 255)
		if self.Weapon:GetNWBool("HideBalloon", false) then
			self.Weapon.VElements["balloon_view"].color = Color( 0, 0, 0, 0)
			self.Weapon.WElements["balloon_world"].color = Color( 0, 0, 0, 0)
		else
			self.Weapon.VElements["balloon_view"].color = Translation
			self.Weapon.WElements["balloon_world"].color = Translation
		end
	end
	
	if self.Owner:KeyDown(1) then
		if self.Weapon:Clip1() > 0 and self.Weapon:GetNextPrimaryFire() <= CurTime() and not self.Weapon:GetNWBool("HideBalloon", false) then
			self.Weapon:SendWeaponAnim( ACT_VM_HAULBACK )
			local p = self.Weapon:GetNWInt("Force", 0)
			self.Weapon:SetNWInt("Force", math.Clamp(p + 1, 0, 200))
			if p > 50 then
				EmitSound( Sound( "buttons/blip1.wav" ), self.Owner:GetPos(), 1, CHAN_AUTO, 1, 25, 0, p - 25 )
			end
		end
	end
	if self.Owner:KeyReleased(1) then
		if self.Weapon:Clip1() > 0 and self.Weapon:GetNextPrimaryFire() <= CurTime() and not self.Weapon:GetNWBool("HideBalloon", false) then
		self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay * 1.25)
		self:SetClip1(self:Clip1() - 1)
			if SERVER then
				local Received = self.Weapon:GetNWVector("MyColor", Vector( 255, 0, 0))
				local h, s, v = ColorToHSV( Color( Received.x, Received.y, Received.z, 255))
				local Generation = HSVToColor(h + 20, 1, 1)
				self.Weapon:SetNWVector("MyColor",Vector(Generation.r, Generation.g, Generation.b))
				local balloon = ents.Create("ent_wballoon") 
				local vec = Vector(0, 0, 8)
				if self.Owner:Crouching() then vec = Vector(0, 0, 4) end
				balloon:SetPos((self.Owner:EyePos() - vec) + (self.Owner:GetForward() * 16)) 
				balloon:SetAngles(Angle(math.random(0, 360),math.random(0, 360),0))
				balloon:SetColor( Color(Received.x, Received.y, Received.z, 255) )
				balloon:Spawn()
				local balloonphys = balloon:GetPhysicsObject()
				balloonphys:Wake()
				--print(self.Weapon:GetNWInt("Force", 0))
				balloonphys:SetVelocity(self.Owner:GetAimVector():GetNormalized() * 50 * (10 + self.Weapon:GetNWInt("Force", 0)))
				self.Weapon:SetNWInt("Force", 0)
				balloonphys:SetBuoyancyRatio( 0.03 )
				self.Owner:SetAnimation( PLAYER_ATTACK1 )
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				self.Weapon:SetNWBool("HideBalloon", true)
				timer.Simple(0.1, function() if not IsValid(self) or not IsValid(self.Owner) then return end self.Weapon:SendWeaponAnim( ACT_VM_THROW ) end) 
				timer.Simple(0.5, function() if not IsValid(self) or not IsValid(self.Owner) then return end self.Weapon:SetNWBool("HideBalloon", false) self.Weapon:SendWeaponAnim(ACT_VM_DRAW) end)
				if self.Weapon:Clip1() <= 0 then
					self.Owner:StripWeapon("weapon_waterballoon")
				end
			end
		end
	end
	--return false
end

function SWEP:PrimaryAttack()
	return false
--	if self.Weapon:Clip1() > 0 and not self.Weapon:GetNWBool("HideBalloon", false) then
--		self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
--		self:SetClip1(self:Clip1() - 1)
--			if SERVER then
--				local Received = self.Weapon:GetNWVector("MyColor", Vector( 255, 0, 0))
--			local h, s, v = ColorToHSV( Color( Received.x, Received.y, Received.z, 255))
--				local Generation = HSVToColor(h + 20, 1, 1)
--				self.Weapon:SetNWVector("MyColor",Vector(Generation.r, Generation.g, Generation.b))
--				local balloon = ents.Create("ent_wballoon") 
--				local vec = Vector(0, 0, 8)
--				if self.Owner:Crouching() then vec = Vector(0, 0, 4) end
--				balloon:SetPos((self.Owner:EyePos() - vec) + (self.Owner:GetForward() * 16)) 
--				balloon:SetAngles(Angle(math.random(0, 360),math.random(0, 360),0))
--				balloon:SetColor( Color(Received.x, Received.y, Received.z, 255) )
--				balloon:Spawn()
--				local balloonphys = balloon:GetPhysicsObject()
--				balloonphys:Wake()
--				balloonphys:SetVelocity(self.Owner:GetAimVector():GetNormalized() * 1000)
--				balloonphys:SetBuoyancyRatio( 0.03 )
--				self.Owner:SetAnimation( PLAYER_ATTACK1 )
--				self.Weapon:SendWeaponAnim( ACT_VM_THROW )
--				self.Weapon:SetNWBool("HideBalloon", true)
--				timer.Simple(0.5, function() if not IsValid(self) or not IsValid(self.Owner) then return end self.Weapon:SetNWBool("HideBalloon", false) self.Weapon:SendWeaponAnim(ACT_VM_DRAW) end)
--				if self.Weapon:Clip1() <= 0 then
--					self.Owner:StripWeapon("weapon_waterballoon")
--				end
--			end
--		return true
--	end
	--if CLIENT then
	--	timer.Simple(0.5, function()
	--	local Received = self.Weapon:GetNWVector("Colorss",Vector( 255, 255, 255))
	--	local Translation = Color(Received.x, Received.y, Received.z, 255)
	--	self.Weapon.VElements["balloon_view"].color = Translation
	--	self.Weapon.WElements["balloon_world"].color = Translation end)
	--end
end

function SWEP:SecondaryAttack()
	if self.Weapon:Clip1() > 0 and self.Weapon:GetNextPrimaryFire() <= CurTime() and not self.Weapon:GetNWBool("HideBalloon", false) then
		self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay )
		self:SetClip1(self:Clip1() - 1)
			if SERVER then
				local Received = self.Weapon:GetNWVector("MyColor", Vector( 255, 0, 0))
				local h, s, v = ColorToHSV( Color( Received.x, Received.y, Received.z, 255))
				local Generation = HSVToColor(h + 20, 1, 1)
				self.Weapon:SetNWVector("MyColor",Vector(Generation.r, Generation.g, Generation.b))
				local balloon = ents.Create("ent_wballoon") 
				local vec = Vector(0, 0, 8)
				if self.Owner:Crouching() then vec = Vector(0, 0, 4) end
				balloon:SetPos((self.Owner:EyePos() - vec) + (self.Owner:GetForward() * 16)) 
				balloon:SetAngles(Angle(math.random(0, 360),math.random(0, 360),0))
				balloon:SetColor( Color(Received.x, Received.y, Received.z, 255) )
				balloon:Spawn()
				local balloonphys = balloon:GetPhysicsObject()
				balloonphys:Wake()
				balloonphys:SetVelocity(self.Owner:GetAimVector():GetNormalized() * 1000)
				balloonphys:SetBuoyancyRatio( 0.03 )
				self.Owner:SetAnimation( PLAYER_ATTACK1 )
				self.Weapon:SendWeaponAnim( ACT_VM_THROW )
				self.Weapon:SetNWBool("HideBalloon", true)
				timer.Simple(0.5, function() if not IsValid(self) or not IsValid(self.Owner) then return end self.Weapon:SetNWBool("HideBalloon", false) self.Weapon:SendWeaponAnim(ACT_VM_IDLE) end)
				if self.Weapon:Clip1() <= 0 then
					self.Owner:StripWeapon("weapon_waterballoon")
				end
			end
		return true
	end
end

/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

self:SetHoldType(self.HoldType)

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

SWEP.VElements = {
	["balloon_view"] = { type = "Model", model = "models/maxofs2d/balloon_classic.mdl", bone = "ValveBiped.cube", rel = "", pos = Vector(-9.87, -7.792, 28.57), angle = Angle(3.506, 8.182, 68.96), size = Vector(0.5, 0.5, 0.4), color = Color(255,0,0,255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
    ["balloon_world"] = { type = "Model", model = "models/maxofs2d/balloon_classic.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.596, 3.635, -5.715), angle = Angle(0, 0, 0), size = Vector(0.5, 0.5, 0.4), color = Color(255,0,0,255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
--PATH lua/entities/a-wing.lua:

ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Type = "vehicle"
ENT.Base = "fighter_base"

ENT.PrintName = "A-Wing"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Rebels"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/awingland/awingland.mdl"
ENT.FlyModel = "models/awing/awing1.mdl"
ENT.Vehicle = "AWing"
ENT.StartHealth = 1000;
ENT.Allegiance = "Rebels";
list.Set("SWVehicles", ENT.PrintName, ENT);
util.PrecacheModel("models/awing/awing1.mdl")

if SERVER then

ENT.FireSound = Sound("weapons/xwing_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),FireMode = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("a-wing");
	e:SetPos(tr.HitPos + Vector(0,0,5));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()
	
	self:SetNWInt("Health",self.StartHealth);
	self.CanRoll = true;
	self.WeaponLocations = {
		Right = self:GetPos()+self:GetForward()*120+self:GetUp()*45+self:GetRight()*87,
		Left = self:GetPos()+self:GetForward()*120+self:GetUp()*43+self:GetRight()*-80,
	}
	self.WeaponsTable = {};

	self.BoostSpeed = 2500;
	self.ForwardSpeed = 1500;
	self.UpSpeed = 550;
	self.AccelSpeed = 9;
	
	self.Cooldown = 2;
	self.Overheat = 0;
	self.Overheated = false;
	self.CanShoot = true;
	self.FireDelay = 0.1;
	self.AlternateFire = true;
	self.FireGroup = {"Left","Right"}
	self.LandOffset = Vector(0,0,20)
	
	self.Bullet = CreateBulletStructure(70,"red");

	self.BaseClass.Initialize(self)
end


function ENT:Enter(p)
	
	if(not self.Inflight) then		
		self:SetModel(self.FlyModel);
	end
	self.BaseClass.Enter(self,p)
end

function ENT:Exit(kill)	
	if(self.Inflight and self.TakeOff) then
		self:SetModel(self.EntModel);
	end
	self.BaseClass.Exit(self,kill);
end

end

if CLIENT then

	function ENT:Draw() self:DrawModel() end
	
	ENT.EnginePos = {}
	ENT.CanFPV = true;
	ENT.Sounds={
		Engine=Sound("vehicles/xwing/xwing_fly2.wav"),
	}
	function ENT:Initialize()	
		self.BaseClass.Initialize(self);
	end
	
	local Health = 0;
	local Overheat;
	local Overheated;
	function ENT:Think()
		self.BaseClass.Think(self);
		
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local IsFlying = p:GetNWBool("Flying"..self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		if(Flying) then
			self.EnginePos = {
				self:GetPos()+self:GetForward()*-70+self:GetUp()*47+self:GetRight()*43,
				self:GetPos()+self:GetForward()*-70+self:GetUp()*47+self:GetRight()*-43,
			}


			if(!TakeOff and !Land) then
				self:FlightEffects();
			end
			Health = self:GetNWInt("Health");
		end
		
	end
	
	ENT.ViewDistance = 700;
    ENT.ViewHeight = 200;
    ENT.FPVPos = Vector(15,-4,80);

	
	local HUD = surface.GetTextureID("vgui/awing_cockpit");
	local Glass = surface.GetTextureID("models/props_c17/frostedglass_01a_dx60")
	function AWingReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingAWing");
		local self = p:GetNWEntity("AWing");
		

		

		if(Flying and IsValid(self)) then
			local FPV = self:GetFPV();
			if(FPV) then
				SW_HUD_FPV(HUD);
			end
			
			SW_HUD_DrawHull(1000);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			
			local x = ScrW()/2;
			local y = ScrH()/4*2.8;
			SW_HUD_Compass(self,x,y);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "AWingReticle", AWingReticle)

	function ENT:FlightEffects()
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		local p = LocalPlayer()		
		local FWD = self:GetForward();
		local id = self:EntIndex();

		for k,v in pairs(self.EnginePos) do
	
			local heat = self.FXEmitter:Add("sprites/heatwave",v)
			heat:SetVelocity(normal)
			heat:SetDieTime(0.04)
			heat:SetStartAlpha(255)
			heat:SetEndAlpha(255)
			heat:SetStartSize(15)
			heat:SetEndSize(13.5)
			heat:SetRoll(roll)
			heat:SetColor(255,100,100)
			
			if(k == 2 and Health <= (self.StartHealth*0.5)) then
				self:Smoke(true,v);
			else
				local red = self.FXEmitter:Add("sprites/orangecore1",v)
				red:SetVelocity(normal)
				red:SetDieTime(0.04)
				red:SetStartAlpha(255)
				red:SetEndAlpha(255)
				red:SetStartSize(15)
				red:SetEndSize(13.5)
				red:SetRoll(roll)
				red:SetColor(255,255,255)
								
				local dynlight = DynamicLight(id + 4096 * k);
				dynlight.Pos = v+FWD*-25;
				dynlight.Brightness = 5;
				dynlight.Size = 100;
				dynlight.Decay = 1024;
				dynlight.R = 255;
				dynlight.G = 100;
				dynlight.B = 100;
				dynlight.DieTime = CurTime()+1;
			end
		end
	
	end
	
	local UP = Vector(0,0,50); -- Smoke always moves up
	function ENT:Smoke(b,pos)

		local p = LocalPlayer();
		local awing = p:GetNetworkedEntity("AWing",NULL);

		if(b) and (IsValid(awing) and awing==self) then
			local fwd = self:GetForward()
			local vel = self:GetVelocity()
			local roll = math.Rand(-90,90)

			local particle = self.FXEmitter:Add("effects/blood2",pos)
			particle:SetVelocity(vel - 500*fwd+UP)
			particle:SetDieTime(0.75)
			particle:SetStartAlpha(200)
			particle:SetEndAlpha(0)
			particle:SetStartSize(14)
			particle:SetEndSize(20)
			particle:SetColor(40,40,40)
			particle:SetRoll(roll)

			--self.Emitter:Finish()
		end
	end
	
end
--PATH lua/entities/arccw_ammo_pistol_large.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo_smg1.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Carbine Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/smg_ammo.mdl"

ENT.AmmoType = "smg1"
ENT.AmmoCount = 60
if engine.ActiveGamemode() == "terrortown" then
    ENT.AmmoCount = 30
end

ENT.DetonationDamage = 30
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/smg1/npc_smg1_fire1.wav"
--PATH lua/entities/arccw_ammo_sniper_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Sniper Ammo (Large)"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/sniper_ammo.mdl"
ENT.Scale = 1.5

ENT.AmmoType = "SniperPenetratedRound"
ENT.AmmoCount = 50
ENT.MaxHealth = 20

ENT.DetonationDamage = 80
ENT.DetonationRadius = 128
ENT.DetonationSound = "npc/sniper/echo1.wav"
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/entities/arccw_ubgl_he.lua:
AddCSLuaFile()

ENT.Base = "arccw_ubgl_nade"
ENT.PrintName = "40mm HE"

ENT.GrenadeDamage = false
ENT.GrenadeRadius = 300
ENT.DragCoefficient = 0.25

ENT.Model = "models/items/ar2_grenade.mdl"
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/entities/arccw_ubgl_incendiary.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_aa-9_liner/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_bulwark/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_core/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_core/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_cr25/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cr90_rep/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "REP | CR90"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/squadrons/cr90.mdl"
ENT.AITEAM 					= 2

ENT.Mass 					= 700

ENT.HealthVal 				= 60000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(-610,0,185),
	[2] = Vector(-610,0,-169),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,0,0),
	[2] = Angle(0,0,-180),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
	{forward = 700, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_diamond/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Diamond"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/npc/starwars/cis/diamond/diamond.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = 2000, right = 0, up = 2800}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/9799_fire.mp3")

ENT.PRIMARYDAMAGE			= 30
ENT.SHOOTDELAY1 			= 2
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{
	[1] = Vector(0,1270,00),
	[2] = Vector(0,-1270,00),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(360,180,90),
	[2] = Angle(360,180,-90),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 1800},
	{forward = 1000, right = 0, up = -1600},
	{forward = 2000, right = 0, up = 1400},
	{forward = 3000, right = 0, up = -1800},
	{forward = 1000, right = 0, up = -1600},
	{forward = 200, right = 0, up = 1400},
	{forward = 0, right = 0, up = -1800},
	{forward = -1000, right = 0, up = 1600},
	{forward = -2500, right = 0, up = -1800},
	{forward = -1000, right = 0, up = 1600},
	{forward = -2500, right = 0, up = -1800},
}
--PATH lua/entities/aura_lvs_hardcell/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_pelta/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_rep_2/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_venator_mk2/cl_init.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_electric/cl_init.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_rubble/shared.lua:
ENT.Type            = "anim"
ENT.Base            = "base_gmodentity"

ENT.PrintName       = "Rubble"
ENT.Category        = "City Worker"
ENT.Author          = "Silhouhat"
ENT.Contact 	    = "contact@silhouhat.com"

ENT.Spawnable   	= false
--PATH lua/entities/claimboard/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/darkrp_cheque/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Cheque"
ENT.Author = "Eusion"
ENT.Spawnable = false
ENT.IsDarkRPCheque = true

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Entity", 1, "recipient")
    self:NetworkVar("Int", 0, "amount")
end

--PATH addons/[opt] decals/lua/entities/decal/shared.lua:
return gluapack()()
--PATH lua/entities/delta.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "Azure Angel"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Republic"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/jedi2/jedi2.mdl"
ENT.Vehicle = "Delta"
ENT.StartHealth = 1500;
ENT.Allegiance = "Republic";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/xwing_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("delta");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetNWInt("Health",self.StartHealth);
	self.CanRoll = true;
	self.WeaponLocations = {
		Left = self:GetPos()+self:GetRight()*-72+self:GetUp()*30+self:GetForward()*100,
		Right = self:GetPos()+self:GetRight()*72+self:GetUp()*30+self:GetForward()*100,
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 2350;
	self.ForwardSpeed = 1500;
	self.UpSpeed = 750;
	self.AccelSpeed = 9;
	
	self.Bullet = CreateBulletStructure(80,"red");
	self.FireDelay = 0.2;
	self.CanShoot = true;
	self.AlternateFire = true;
	self.FireGroup = { "Left" , "Right" };
	
	self.BaseClass.Initialize(self)

end

end

if CLIENT then
	local matPlasma	= Material( "effects/strider_muzzle" )
	function ENT:Draw() 
		self:DrawModel()
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		local vel = self:GetVelocity():Length();
		if(vel > 150) then
			if(Flying and !TakeOff and !Land) then
				for i=1,2 do
					local vOffset = self.EnginePos[i] 
					local scroll = CurTime() * -20
						
					render.SetMaterial( matPlasma )
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 32, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 28, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 24, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
					
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 32, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 28, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 24, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
					
					scroll = scroll * 0.9
					
					render.StartBeam( 3 )
						render.AddBeam( vOffset, 32, scroll, Color( 0, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-5, 28, scroll + 0.01, Color( 255, 255, 255, 255) )
						render.AddBeam( vOffset + self:GetForward()*-40, 24, scroll + 0.02, Color( 0, 255, 255, 0) )
					render.EndBeam()
				end
			end
		end
	end
	
	ENT.EnginePos = {}
	ENT.Sounds={
		Engine=Sound("vehicles/eta/eta_fly.wav"),
	}


	function ENT:FlightEffects()
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		local p = LocalPlayer()		
		local FWD = self:GetForward();
		local id = self:EntIndex();

		for k,v in pairs(self.EnginePos) do
			
			local blue = self.FXEmitter:Add("sprites/bluecore",v+FWD*-5)
			blue:SetVelocity(normal)
			blue:SetDieTime(0.025)
			blue:SetStartAlpha(255)
			blue:SetEndAlpha(255)
			blue:SetStartSize(15)
			blue:SetEndSize(10)
			blue:SetRoll(roll)
			blue:SetColor(255,255,255)
			
			local dynlight = DynamicLight(id + 4096*k);
			dynlight.Pos = v+FWD*-25;
			dynlight.Brightness = 5;
			dynlight.Size = 100;
			dynlight.Decay = 1024;
			dynlight.R = 100;
			dynlight.G = 100;
			dynlight.B = 255;
			dynlight.DieTime = CurTime()+1;
			
		end
	
	end
	
	local Health = 0;
	local Overheat = 0;
	local Overheated = false;
	function ENT:Think()
	
		self.BaseClass.Think(self)
		
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		if(Flying) then
			self.EnginePos = {
				self:GetPos()+self:GetForward()*-110+self:GetRight()*29+self:GetUp()*24,
				self:GetPos()+self:GetForward()*-110+self:GetRight()*-31+self:GetUp()*24,
			}
			if(!TakeOff and !Land) then
				self:FlightEffects();
			end
			Health = self:GetNWInt("Health");
			Overheat = self:GetNWInt("Overheat");
			Overheated = self:GetNWBool("Overheated");
		end
		
	end
	
	ENT.CanFPV = false;
    ENT.ViewDistance = 700;
    ENT.ViewHeight = 200;


	function DeltaReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingDelta");
		local self = p:GetNWEntity("Delta");
		if(Flying and IsValid(self)) then
			SW_HUD_DrawHull(1500);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);

			SW_HUD_Compass(self);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "DeltaReticle", DeltaReticle)

end
--PATH gamemodes/starwarsrp/entities/entities/drug/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/drug/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

local color_red = Color(140, 0, 0, 100)
local color_white = color_white

function ENT:Draw()
    self:DrawModel()

    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    local owner = self:Getowning_ent()
    owner = (IsValid(owner) and owner:Nick()) or DarkRP.getPhrase("unknown")

    surface.SetFont("HUDNumber5")
    local text = DarkRP.getPhrase("drugs")
    local text2 = DarkRP.getPhrase("priceTag", DarkRP.formatMoney(self:Getprice()), "")
    local TextWidth = surface.GetTextSize(text)
    local TextWidth2 = surface.GetTextSize(text2)

    Ang:RotateAroundAxis(Ang:Forward(), 90)
    local TextAng = Ang

    TextAng:RotateAroundAxis(TextAng:Right(), CurTime() * -180)

    cam.Start3D2D(Pos + Ang:Right() * -15, TextAng, 0.1)
        draw.WordBox(2, -TextWidth * 0.5 + 5, -30, text, "HUDNumber5", color_red, color_white)
        draw.WordBox(2, -TextWidth2 * 0.5 + 5, 18, text2, "HUDNumber5", color_red, color_white)
    cam.End3D2D()
end

function ENT:Think()
end

local function drugEffects(um)
    local toggle = um:ReadBool()

    LocalPlayer().isDrugged = toggle

    if toggle then
        hook.Add("RenderScreenspaceEffects", "drugged", function()
            DrawSharpen(-1, 2)
            DrawMaterialOverlay("models/props_lab/Tank_Glass001", 0)
            DrawMotionBlur(0.13, 1, 0.00)
        end)
    else
        hook.Remove("RenderScreenspaceEffects", "drugged")
    end
end
usermessage.Hook("DrugEffects", drugEffects)

--PATH lua/entities/ent_baby_explosive2/cl_init.lua:
return gluapack()()
--PATH lua/entities/ent_baby_explosive2/shared.lua:
return gluapack()()
--PATH lua/entities/ent_fballoon/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Balloon"

ENT.DoNotDuplicate = true 
ENT.DisableDuplicator = true

ENT.DefaultTimer	= 3
--PATH addons/[miecze] moce i hilty/lua/entities/ent_holocron.lua:
AddCSLuaFile() 
DEFINE_BASECLASS( "base_anim" )

local LoadedSounds

if SERVER then 
	util.AddNetworkString( "CreateKDMenu" )
	util.AddNetworkString( "ModelChange" )
end

if CLIENT then 

	surface.CreateFont("HoloCronTitle", {
	    font = "Soloist",
	    extended = true,
	    size = 50
	})

	surface.CreateFont("HoloCronFont", {
	    font = "Seagram tfb",
	    extended = true,
	    size = 30
	})

	ENT.AutomaticFrameAdvance = true
	LoadedSounds = {}
end

ENT.PrintName = "Jedi Holocron"
ENT.Author = "Kier"
ENT.Information = "An editable holocron entity"
ENT.Category = "Holocrons"

ENT.Editable = true
ENT.Spawnable = true
ENT.AdminOnly = false 
ENT.RenderGroup = RENDERGROUP_OPAQUE

ENT.IconOverride = "materials/wos/targetindicators/plasma_ring_sd.png"

function ENT:SetupDataTables()

	self:NetworkVar( "Bool", 0, "HolocronAccess", { KeyName = "holocronaccess", Edit = { type = "Boolean", order = 1 } } )
	self:NetworkVar( "String", 1, "HolocronText", { KeyName = "holocrontext", Edit = { type = "Generic", order = 2, waitforenter = true } } )

	if SERVER then 
		self:SetHolocronText( "CHANGE ME" )
		self:SetHolocronAccess( false )
	end

end

function ENT:SpawnFunction( ply, tr, ClassName )

	if ( !tr.Hit ) then return end

	local SpawnPos = tr.HitPos + tr.HitNormal

	-- Make sure the spawn position is not out of bounds
	local oobTr = util.TraceLine( {
		start = tr.HitPos,
		endpos = SpawnPos,
		mask = MASK_SOLID_BRUSHONLY
	} )

	if ( oobTr.Hit ) then
		SpawnPos = oobTr.HitPos + oobTr.HitNormal * ( tr.HitPos:Distance( oobTr.HitPos ) / 2 )
	end

	local ent = ents.Create( ClassName )
	ent:SetPos( SpawnPos )
	ent:Spawn()
	ent:Activate()

	return ent

end

function ENT:Initialize()

	self:SetModel( "models/holocrons/jedi_holocron_closed.mdl" )

	self:SetColor( Color( 255, 255, 255, 255 ) )

	self:SetMoveType( MOVETYPE_VPHYSICS )
	self:SetSolid( SOLID_VPHYSICS )

	if SERVER then self:PhysicsInit( SOLID_VPHYSICS ) end -- DONT CHANGE - CAN BREAK PHYSGUNS

	self:PhysWake()
end

function ENT:Use( active )
	self:SetUseType( SIMPLE_USE )

	if active:IsPlayer() then 
		if self:GetHolocronAccess() == true then 
			net.Start("CreateKDMenu")
				net.WriteString(self:GetHolocronText())
			net.Send(active)
			self:SetModel("models/holocrons/jedi_holocron_opened.mdl")
		else
			active:Say("I am not yet strong enough in the force to open this holocron")
		end
	end
end

function ENT:Think()
	for k, v in pairs( ents.FindByClass("ent_holocron")) do
		local newang = Angle(0,(CurTime()*90)%360,0)
		v:SetAngles(newang)
	end

	self:NextThink( CurTime() + 10 )
	return true
end

net.Receive("CreateKDMenu", function()  
	local displaytext = net.ReadString()

	local holocron = vgui.Create("DFrame")
	holocron:SetSize( ScrW()/2, ScrH()/2 )
	holocron:Center()
	holocron:SetTitle("")
	holocron:MakePopup()
	holocron:SetSizable(false)
	holocron:SetDraggable(false)
	holocron:ShowCloseButton(false)
	holocron:SetDeleteOnClose(true)

	holocron.Paint = function(self, w, h)


		draw.RoundedBoxEx(50, w/2, h*0.05, w/2*0.96, h, Color(176, 11, 11,200), true, true, false, false)
		draw.RoundedBoxEx(50, w*0.02, h*0.05, w/2*0.96, h, Color(0, 12, 176,200), true, true, false, false)
		local LightningCrack = Material("materials/holocron/lightning_crack.png", "noclamp smooth")
		local LightningEffect = Material("materials/holocron/lightning_effect.png", "noclamp smooth")
		surface.SetMaterial( LightningCrack )
		surface.SetDrawColor( 128, 0, 255, 255 )
		surface.DrawTexturedRect(w*0.02, h*0.05, w*0.96, h*0.98)
		draw.RoundedBox(0, w*0.02, h*0.05, w*0.005, h, Color( 10, 10, 10))
		draw.RoundedBox(0, w*0.98, h*0.05, w*0.005, h, Color( 10, 10, 10))

		

		--[[surface.SetMaterial( LightningEffect )
		surface.SetDrawColor( 128, 0, 255, 255 )
		surface.DrawTexturedRect(w/2*0.8, h*0.08, w*0.2, h*0.98)]]--

		surface.SetFont("HoloCronTitle")
		local holocrontitle = "Holocron"
		local tw, th = surface.GetTextSize(holocrontitle)

		draw.RoundedBoxEx(100, w*0.02, h*0.05, w*0.96, h*0.01+th*1.02, Color(10, 10, 10), true, true, false, false)

		draw.RoundedBox(0, w*0.02, h*0.99, w*0.965, h*0.02, Color( 10, 10, 10))

		local JediLogo = Material("materials/holocron/jedi_logo.png", "noclamp smooth")
		local SithLogo = Material("materials/holocron/sith_logo.png", "noclamp smooth")
		local Jedi = Material("materials/holocron/jedi.png", "noclamp smooth")
		local Sith = Material("materials/holocron/sith.png", "noclamp smooth")

		surface.SetMaterial( JediLogo )
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect(0, 0, w*0.1, h*0.155)

		surface.SetMaterial( SithLogo )
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect(w*0.9, 0, w*0.1, h*0.15)

		--[[surface.SetMaterial( Jedi )
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect(0, h/2, w*0.2, h*0.5)

		surface.SetMaterial( Sith )
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect(w*0.75, h/2*1.015, w*0.3, h*0.5)]]--

		surface.SetTextColor(255, 255, 255, 255)
		surface.SetTextPos(w/2-tw/2, h*0.06)
		surface.DrawText(holocrontitle)

		--[[draw.RoundedBox(0, w/2, 0, 1, h, Color(255,255,255))
		draw.RoundedBox(0, 0, h/2, w, 1, Color(255,255,255))]]--
	end

	local holoclose = vgui.Create("DButton", holocron )
	holoclose:SetPos(holocron:GetWide()/2*0.925, holocron:GetTall()*0.925)
	holoclose:SetSize(holocron:GetWide()/2*0.15, holocron:GetTall()/2*0.15)
	holoclose:SetText("")
	holoclose.DoClick = function()
		holocron:Close()
	end
	holoclose.Paint = function(self, w, h)
		surface.SetDrawColor(5, 5, 5, 250)
		surface.DrawRect(0, 0, w, h)

		local closebg = Material("materials/wos/targetindicators/plasma_square_sd.png", "noclamp smooth")
		surface.SetMaterial( closebg )
		surface.SetDrawColor( 100, 100, 100, 255 )
		surface.DrawTexturedRect(0, 0, w, h)

		local closemat = Material("materials/wos/runes/n.png", "noclamp smooth")
		surface.SetMaterial( closemat )
		surface.SetDrawColor( 25, 25, 25, 255 )
		surface.DrawTexturedRect(w/2*0.3, h/2*0.35, w*0.7, h*0.7)

		--[[surface.SetTextColor(0, 0, 0, 255)
		surface.SetFont("HoloCronFont")
		local closetext = "Close"
		local ww, hh = surface.GetTextSize( closetext )
		surface.SetTextPos(w*0.5-ww, h*0.5-hh)
		surface.DrawText( closetext )]]--
	end

	local holotextbg = vgui.Create( "DPanel", holocron )
	holotextbg:SetPos(holocron:GetWide()/2*0.6, holocron:GetTall()/2*0.6)
	holotextbg:SetSize(holocron:GetWide()/2*0.8, holocron:GetTall()/2)
	holotextbg:SetBackgroundColor( Color(25, 25, 25, 255))

	local holotext = vgui.Create( "DLabel", holotextbg )
	holotext:SetPos(holotextbg:GetWide()*0.1, 0)
	holotext:SetSize(holocron:GetWide()/2*0.65, holocron:GetTall()/2)
	holotext:SetFont("HoloCronFont")
	holotext:SetText(displaytext)
	holotext:SetColor(Color(255, 255, 255))
	holotext:SetWrap(true)
end )

hook.Add( "OnEntityCreated", "HolocronLoopSound", function(ent)
	if ent:GetClass() == "ent_holocron" then 
		print( ent:EntIndex() )
		ent:StartLoopingSound("holocronloop/holocron_loop.wav")
	end
end)

hook.Add( "PreDrawHalos", "HolocronGlow", function()
	halo.Add( ents.FindByClass( "ent_holocron" ), Color(255,255,255), 10, 10, 8, true, false )
end)

hook.Add( "EntityRemoved", "StopHolocronLoop", function(ent)
	if ent:GetClass() == "ent_holocron" then
		RunConsoleCommand("stopsound")
	end
end)

hook.Add( "Think", "DynLightHolocron", function() 
	if CLIENT then 
		for k, v in pairs( ents.FindByClass("ent_holocron") ) do
			local k_dlight = DynamicLight( v:EntIndex() )
			if ( k_dlight ) then 
				k_dlight.pos = v:GetPos()
				k_dlight.r = 255
				k_dlight.g = 255
				k_dlight.b = 255
				k_dlight.brightness = 1
				k_dlight.Decay = 1000
				k_dlight.Size = 150
				k_dlight.DieTime = CurTime() + 1
				k_dlight.nomodel = false
			end
		end
	end
end)

function ENT:CanProperty( ply, prop )
	if ( ply:IsAdmin() or ply:IsSuperAdmin() ) then 
		return true
	elseif ( ply:GetUserGroup() == "User" ) then
		return false
	end
end
--PATH lua/entities/fighter_base.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/fire_spawned1/shared.lua:
-- Made by Matsilagi

AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Damage = 1

function ENT:Draw()
end

function ENT:Initialize()
	self.Damage = 1
	self:SetNWBool("extinguished",false)
	if SERVER then
		self:SetModel( "models/arccw/kraken/sw/explosives/world/w_thermalimploder.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_NONE )
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		self:DrawShadow( false )
		for i = 1, 20 do
			local fire = ents.Create("info_particle_system")
			if (i < 2) then
				fire:SetKeyValue("effect_name","molotov_fire_main_gm")
			else
				fire:SetKeyValue("effect_name","molotov_fire_child_gm")
			end
			local pos = self:GetPos()
			//fire:SetPos( Vector( pos.x + 100 * math.sin( math.rad( i * 20 ) ), pos.y + 100 * math.cos( math.rad( i * 20 ) ), pos.z ) )
			fire:SetPos( Vector( pos.x + math.Rand(0, 144) * math.sin( math.rad( i * math.Rand( 0, 180 ) ) ), pos.y + math.Rand(0, 144) * math.cos( math.rad( i * math.Rand( 0, 180 ) ) ), pos.z ) )
			fire:SetAngles( self:GetAngles() )
			fire:SetParent( self )
			fire:Spawn()
			fire:Activate()
			fire:Fire("Start","",0)
			fire:Fire("Kill","",8)
		end
	end
	self:NextThink( CurTime() )
end

function ENT:Think()
	if SERVER then
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 150 ) ) do
			if v:IsPlayer() or v:IsNPC() or v:IsNextBot() then
				if v:GetPos():Distance( self:GetPos() ) < 150 then
					damage = DamageInfo()
					damage:SetDamage( math.random( 3, 7 ) )
					damage:SetAttacker( self:GetOwner() )
					damage:SetInflictor( self )
					damage:SetDamageType( DMG_BURN )
					v:TakeDamageInfo( damage )
				end
			end
		end
	end
	if self:GetNWBool("extinguished",true) then
		if not self.PlayedSound then
			self:EmitSound("ArcCW_Kraken.Explosives.IncendiaryExtinguish")
			self.PlayedSound = true
		end
		if SERVER then
			SafeRemoveEntity( self )
		end
	end

	self:NextThink( CurTime() + math.Rand( 0.2, 0.7 ) )
end
--PATH gamemodes/starwarsrp/entities/entities/food/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Food"
ENT.Author = "Pcwizdan"
ENT.Spawnable = false
ENT.EatSound = "vo/sandwicheat09.mp3" -- Requires Team Fortress 2

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 1, "owning_ent")
end

--PATH lua/entities/force_shield.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/g125_projectile/shared.lua:
return gluapack()()
--PATH lua/entities/gb_rp_sign/cl_init.lua:
return gluapack()()
--PATH lua/entities/gb_rp_sign/cl_init.lua:
include("shared.lua")

surface.CreateFont( "InfoRUS2", { font = "Enhanced Dot Digital-7", extended = true, size = 90, weight = 800, antialias = true })
surface.CreateFont( "InfoRUS3", { font = "Enhanced Dot Digital-7", extended = true, size = 50, weight = 800, antialias = true })

local font = "InfoRUS2"

local sizetable = {
	[3] = {350, 0.5},
	[4] = {470, -11.5},
	[5] = {590, -11.5},
	[6] = {710, 0.5},
	[7] = {830, 0.5},
	[8] = {950, 0.5},
}

function ENT:Initialize()
	
	self.OldWide = self:GetWide()

	self.frame = vgui.Create( "DPanel" )
	self.frame:SetSize( sizetable[self:GetWide()][1], 120 )
	self.frame.Text = self:GetText()
	self.frame.Type = self:GetType()
	self.frame.col = self:GetTColor()
	self.frame.damage = 0
	self.frame.appr = nil
	self.frame.FX = self:GetFX()
	self.frame.On = self:GetOn()
	self.frame.alfa = 0
	self.frame.speed = self:GetSpeed()
	self.frame:SetPaintedManually( true )
	self.frame.Paint = function(self,w,h)
		
		if self.On <= 0 then 
			if self.alfa < 1 then return end
			self.alfa = Lerp(FrameTime() * 5,self.alfa,0)
		else
			if self.FX > 0 then
				self.alfa = math.random(100,220)
			else
				self.alfa = 255
			end
		end
		
		surface.DisableClipping( false )
		surface.SetFont(font)
		local ww,hh = surface.GetTextSize(self.Text)
		local multiplier = self.speed * 100
		
		self.static = false
		
		if self.damage < CurTime() and self.On then
			if self.Type == 1 then
				
				local xs = (math.fmod(SysTime() * multiplier,w+ww)) - ww
				
				draw.DrawText(self.Text,font,xs,10,Color(self.col.x * 100, self.col.y * 100, self.col.z * 100, self.alfa),0)
			elseif self.Type == 2 then
				
				if !self.appr or self.appr > ww  then
					self.appr = -w
				else
					self.appr = math.Approach(self.appr, ww+w, FrameTime() * multiplier) 
				end
				
			draw.DrawText(self.Text,font,self.appr * -1,10,Color(self.col.x * 100, self.col.y * 100, self.col.z * 100, self.alfa),0)
			else
				if !self.appr then
					self.appr = 0
				end
				
				if w > ww then
					if self.Type == 3 then
						if self.appr < w-ww and !self.refl then
							self.appr = math.Approach(self.appr, ww+w, FrameTime() * multiplier) 
						else
							if self.appr <= 0 then
								self.refl = nil
							else
								self.refl = true
								self.appr = math.Approach(self.appr, 0, FrameTime() * multiplier) 
							end
						end
					else
						self.static = true
					end
				else
					if self.appr > w-ww-50 and !self.refl then
						self.appr = math.Approach(self.appr, w-ww-50, FrameTime() * multiplier) 
					else
						if self.appr >= 50 then
							self.refl = nil
						else
							self.refl = true
							self.appr = math.Approach(self.appr, 50, FrameTime() * multiplier) 
						end
					end
				end
				
				if self.static then
					draw.DrawText(self.Text,font,w/2,10,Color(self.col.x * 100, self.col.y * 100, self.col.z * 100, self.alfa),1)
				else
					draw.DrawText(self.Text,font,self.appr,10,Color(self.col.x * 100, self.col.y * 100, self.col.z * 100, self.alfa),0)
				end
			end
		else	
			draw.DrawText(self.Text,font,math.random(0,w-ww),10,Color(self.col.x * 100, self.col.y * 100, self.col.z * 100, math.random(0,255)),0)
		end
		surface.DisableClipping( true )
	end
end

function ENT:Draw()
	
	self:DrawModel()
	
	if self.frame then
		self.frame.Text = self:GetText()
		self.frame.Type = self:GetType()
		self.frame.col = self:GetTColor()
		self.frame.FX = self:GetFX()
		self.frame.On = self:GetOn()
		self.frame.damage = self:GetNWInt("LastDamaged")
		self.frame.speed = self:GetSpeed()
	end
	
	local Pos = self:GetPos()
	local Ang = self:GetAngles()
	local hight = 12
	
	if self.OldWide != self:GetWide() then
		self.frame:SetSize( sizetable[self:GetWide()][1], 120 )
		self.OldWide = self:GetWide()
	end
	
	if self:GetWide() == 3 then
		hight = 6
	end
	
	cam.Start3D2D(Pos + Ang:Up() * 1.1 - Ang:Right() * hight + Ang:Forward() * sizetable[self:GetWide()][2], Ang, 0.1)
		self.frame:PaintManual()
	cam.End3D2D()

end
--PATH lua/entities/heart_turbolaser_spawner/cl_init.lua:
return gluapack()()
--PATH lua/entities/kingpommes_swv_patroltransport_imp.lua:
return gluapack()()
--PATH lua/entities/laat_detonator/shared.lua:
ENT.Base            = "base_gmodentity"
ENT.Type            = "anim"

ENT.PrintName       = "Detonator"
ENT.Author          = "!Ben"
ENT.Information     = ""
ENT.Category        = "[LFS] - Star Wars Pack"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

game.AddParticles("particles/gb5_100lb.pcf")
PrecacheParticleSystem("100lb_ground")
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_projectile.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.AutomaticFrameAdvance = true
ENT.RenderGroup = RENDERGROUP_BOTH 

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "SWEP" )
end

if SERVER then
	function ENT:Initialize()
		self:SetModel( "models/lscs/saber_throw.mdl" )

		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:SetCollisionGroup( COLLISION_GROUP_NONE )

		local SWEP = self:GetSWEP()

		SWEP:SetActive( true )
		SWEP:SetProjectile( self )
		SWEP:CancelCombo( 100 )
		SWEP:SetDMGActive( true )

		self:PlayAnimation( "spin", 2.5 )

		self.SpawnTime = CurTime()
		self.StartThink = true

		self:DrawShadow( false )
	end

	function ENT:ResetProgress()
		self.Time = CurTime() + 1
	end

	function ENT:GetProgress()
		if not self.Time then
			return (2 + math.max(self.SpawnTime - CurTime(),-1)) / 2
		end

		return math.Clamp( (self.Time - CurTime()) / 2,0,1)
	end

	function ENT:CalcMove( ply )
		local FT = FrameTime()

		local ShootPos = ply:GetShootPos() 

		local trace = util.TraceLine( {
			start = ShootPos,
			endpos = ShootPos + ply:EyeAngles():Forward() * 5000,
			mask = MASK_SOLID_BRUSHONLY,
		} )

		local start = ShootPos - Vector(0,0,20)
		local sub = (trace.HitPos + trace.HitNormal * 20) - start
		local dir = sub:GetNormalized()
		local dist = math.min( sub:Length(), 800 )

		local TargetPos = start + dir * (dist * self:GetProgress() * 1.7)

		local MoveSub = TargetPos - self:GetPos()

		local MoveDist = math.min( MoveSub:Length() * 10, self:GetProgress() > 0.5 and 750 or 350 ) -- quick after throw, but slow on return
		local MoveDir = MoveSub:GetNormalized()

		local MoveSpeed = MoveDist * FT

		local Move = MoveDir * MoveSpeed

		self:SetPos( self:GetPos() + Move )

		local A = math.cos( math.rad(self:GetProgress() * 180 ) )
		self:SetAngles( ply:LocalToWorldAngles( Angle( math.min(A * 40,0),0,-A * 20 ) ) )
	end

	function ENT:CalcFP( ply, SWEP )
		local Time = CurTime()

		if (self._nextFP or 0) > Time then return end

		self._nextFP = Time + 1

		ply:lscsTakeForce( 5 )
		SWEP:DrainBP( 12 )

		if ply:lscsGetForce() > 0 then return end

		if not self.Returning then
			self.Returning = true
			ply._lscsThrownSaber:ResetProgress()
		end
	end

	function ENT:Think()
		self:NextThink( CurTime() )

		if self.StartThink then

			local SWEP = self:GetSWEP()

			if IsValid( SWEP ) then
				local ply = SWEP:GetOwner()

				if IsValid( ply ) then
					if not SWEP:GetActive() then
						self:Remove()

						return
					end

					self:CalcMove( ply )
					self:CalcFP( ply, SWEP )
	
					if (CurTime() - self.SpawnTime) > 0.5 then
						local Dist = (ply:GetShootPos() - self:GetPos()):Length()
						if self:GetProgress() <= 0.2 then
							if Dist <= 50 then
								ply:EmitSound("lscs/equip.mp3")
								self:Remove()
							end
						else
							if Dist <= 80 then
								ply:EmitSound("lscs/equip.mp3")
								self:Remove()
							end
						end
					end
				else
					self:Remove()
				end
			else
				self:Remove()
			end

		end

		return true
	end

	function ENT:OnRemove()
		local SWEP = self:GetSWEP()

		if not IsValid( SWEP ) then return end

		SWEP:SetProjectile( NULL )
		SWEP:SetDMGActive( false )
		SWEP:SetNextPrimaryAttack( CurTime() )
		SWEP:ResetHoldType()
	end

	function ENT:PlayAnimation( animation, playbackrate )
		playbackrate = playbackrate or 1

		local sequence = self:LookupSequence( animation )

		self:ResetSequence( sequence )
		self:SetPlaybackRate( playbackrate )
		self:SetSequence( sequence )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end
else
	function ENT:Initialize()
		self.SND = CreateSound( self, "lscs/saber/saberspin_loop.wav" )
		self.SND:Play()
	end

	function ENT:OnRemove()
		if self.SND then
			self.SND:Stop()
		end
	end

	function ENT:Draw()
	end

	function ENT:DrawTranslucent()
		local SWEP = self:GetSWEP()

		if not IsValid( SWEP ) then return end

		self:SetupBones()

		SWEP:DrawWorldModelTranslucent( nil, self )
	end
end
--PATH lua/entities/lvs_base/cl_trailsystem.lua:
return gluapack()()
--PATH lua/entities/lvs_base_gunner/cl_init.lua:
include("shared.lua")

function ENT:Think()
end

function ENT:OnRemove()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetNWAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		if self._AimVectorUnlocked then
			local pod = self:GetDriverSeat()

			if IsValid( pod ) then
				return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
			end
		end

		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:LVSPaintHitMarker( scr )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:LVSPaintHitMarker( scr )
end

function ENT:LVSDrawCircle( X, Y, target_radius, value )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:LVSDrawCircle( X, Y, target_radius, value )
end

function ENT:PaintCrosshairCenter( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairCenter( Pos2D, Col )
end

function ENT:PaintCrosshairOuter( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairOuter( Pos2D, Col )
end

function ENT:PaintCrosshairSquare( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairSquare( Pos2D, Col )
end

--PATH lua/entities/lvs_base_repulsorlift/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_base_repulsorlift/cl_init.lua:
include("shared.lua")

--PATH lua/entities/lvs_base_repulsorlift/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_base_starfighter/cl_init.lua:
include("shared.lua")
include("cl_camera.lua")
include("sh_camera_eyetrace.lua")
include("cl_hud.lua")
include("cl_flyby.lua")
include("cl_deathsound.lua")

ENT.TrailAlpha = 25

DEFINE_BASECLASS( "lvs_base" )

function ENT:Think()
	BaseClass.Think( self )

	self.EFxScale = self.EFxScale and (self.EFxScale - self.EFxScale * RealFrameTime()) or 0

	self:CalcOnThrottle()
end

function ENT:CalcOnThrottle()
	if not self:GetEngineActive() then 
		self._oldOnTHR = nil

		return
	end

	local Throttle = self:GetThrottle()

	if self._oldOnTHR ~= Throttle then
		if self._oldOnTHR == 0 and Throttle > 0 then
			self._IsAccelerating = true
		end

		if Throttle > (self._oldOnTHR or 0) then
			self._IsAccelerating = true
		else
			self._IsAccelerating = false
		end

		if self._oldOnTHR == 1 then
			self:StopBoost()
		end

		self._oldOnTHR = Throttle
	end

	if self._oldAccelerating ~= self._IsAccelerating then
		self._oldAccelerating = self._IsAccelerating

		if not self._IsAccelerating then return end

		self:StartBoost()
	end
end

function ENT:StartBoost()
	local T = CurTime()

	if (self._NextSND or 0) > T then return end

	self._NextSND = T + 1

	self.EFxScale = 100

	self:OnStartBoost()
end

function ENT:StopBoost()
	local T = CurTime()

	if (self._NextSND or 0) > T then return end

	self._NextSND = T + 1

	self:OnStopBoost()
end

function ENT:GetBoost()
	return (self.EFxScale or 0)
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end
--PATH lua/entities/lvs_base_starfighter/sh_camera_eyetrace.lua:
return gluapack()()
--PATH lua/entities/lvs_base_turret/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_dwarfdroid/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_aat/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_aat/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_aat/shared.lua:

ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "AAT"
ENT.Author = "Luna"
ENT.Information = "Trade Federation Hover Tank. Later used in the Droid army of the Separatists"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Hover Tanks"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/aat.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 1

ENT.MaxHealth = 2000

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 180
ENT.MaxVelocityY = 180

ENT.MaxTurnRate = 0.5

ENT.BoostAddVelocityX = 120
ENT.BoostAddVelocityY = 120

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.TurretTurnRate = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-260,0,0)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:SetTurretPitch( num )
	self._turretPitch = num
end

function ENT:SetTurretYaw( num )
	self._turretYaw = num
end

function ENT:GetTurretPitch()
	return (self._turretPitch or 0)
end

function ENT:GetTurretYaw()
	return (self._turretYaw or 0)
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(10,-60,81) ) ):GetNormalized():Angle() )
	local AimAnglesL = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(10,60,81) ) ):GetNormalized():Angle() )

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not ((AimAnglesR.p >= 20 and AimAnglesL.p >= 20) or (AimAnglesR.p <= -30 and AimAnglesL.p <= -30) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 60)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local ID_L = ent:LookupAttachment( "muzzle_left" )
		local ID_R = ent:LookupAttachment( "muzzle_right" )
		local MuzzleL = ent:GetAttachment( ID_L )
		local MuzzleR = ent:GetAttachment( ID_R )

		if not MuzzleL or not MuzzleR then return end

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and MuzzleL.Pos or MuzzleR.Pos
		local Dir =  (ent.MirrorPrimary and MuzzleL.Ang or MuzzleR.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0 )
		bullet.TracerName = "lvs_laser_red_short"
		bullet.Force	= 11000
		bullet.HullSize 	= 1
		bullet.Damage	= 25
		bullet.Velocity = 12000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if ent.MirrorPrimary then
			if not IsValid( ent.SNDLeft ) then return end
	
			ent.SNDLeft:PlayOnce()

			return
		end

		if not IsValid( ent.SNDRight ) then return end

		ent.SNDRight:PlayOnce()
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		if ent:GetIsCarried() then
			self:SetPoseParameter("cannon_right_pitch", 0 )
			self:SetPoseParameter("cannon_right_yaw", 0 )

			self:SetPoseParameter("cannon_left_pitch", 0 )
			self:SetPoseParameter("cannon_left_yaw", 0 )

			return
		end

		local AimAnglesR, AimAnglesL = ent:GetAimAngles()

		ent:SetPoseParameter("cannon_right_pitch", AimAnglesR.p )
		ent:SetPoseParameter("cannon_right_yaw", AimAnglesR.y )

		ent:SetPoseParameter("cannon_left_pitch", AimAnglesL.p )
		ent:SetPoseParameter("cannon_left_yaw", AimAnglesL.y )
	end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 60
	weapon.Delay = 1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local Driver = ent:GetDriver()

		local MissileAttach = {
			[1] = {
				left = "missile_1l",
				right = "missile_1r"
			},
			[2] = {
				left = "missile_2l",
				right = "missile_2r"
			},
			[3] = {
				left = "missile_3l",
				right = "missile_3r"
			},
		}

		for i = 1, 3 do
			timer.Simple( (i / 5) * 0.75, function()
				if not IsValid( ent ) then return end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end

				local ID_L = ent:LookupAttachment( MissileAttach[i].left )
				local ID_R = ent:LookupAttachment( MissileAttach[i].right )
				local MuzzleL = ent:GetAttachment( ID_L )
				local MuzzleR = ent:GetAttachment( ID_R )

				if not MuzzleL or not MuzzleR then return end

				local swap = false

				for i = 1, 2 do
					local Pos = swap and MuzzleL.Pos or MuzzleR.Pos
					local Start = Pos + ent:GetForward() * 50
					local Dir = (ent:GetEyeTrace().HitPos - Start):GetNormalized()
					if not ent:WeaponsInRange() then
						Dir = swap and MuzzleL.Ang:Up() or MuzzleR.Ang:Up()
					end

					local projectile = ents.Create( "lvs_missile" )
					projectile:SetPos( Start )
					projectile:SetAngles( Dir:Angle() )
					projectile:SetParent( ent )
					projectile:Spawn()
					projectile:Activate()
					projectile.GetTarget = function( missile ) return missile end
					projectile.GetTargetPos = function( missile )
						return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-10,10) )
					end
					projectile:SetAttacker( IsValid( Driver ) and Driver or self )
					projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
					projectile:SetDamage( 300 )
					projectile:SetRadius( 150 )
					projectile:Enable()
					projectile:EmitSound( "LVS.AAT.FIRE_MISSILE" )

					ent:TakeAmmo( 1 )

					swap = true
				end
			end)
		end

		ent:SetHeat( 1 )
		ent:SetOverheated( true )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	self:InitTurret()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/aat/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/aat/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "^lvs/vehicles/aat/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

sound.Add( {
	name = "LVS.AAT.FIRE_MISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "lvs/vehicles/aat/fire_missile.mp3"
} )

sound.Add( {
	name = "LVS.AAT.LASER_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {160, 180},
	sound = {
		"lvs/vehicles/aat/turret/impact1.ogg",
		"lvs/vehicles/aat/turret/impact2.ogg",
		"lvs/vehicles/aat/turret/impact3.ogg",
		"lvs/vehicles/aat/turret/impact4.ogg"
	}
} )
--PATH lua/entities/lvs_fakehover_barc_medical/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_iftx/sh_turret.lua:

function ENT:FireTurret( weapon )
	local T = CurTime()

	if (weapon._NextFire or 0) > T then return end

	weapon._NextFire = T + 0.1

	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local bullet = {}
	bullet.Src 	= pos
	bullet.Dir 	= dir
	bullet.Spread 	= Vector( 0.035,  0.035, 0.035 )
	bullet.TracerName = "lvs_laser_blue_short"
	bullet.Force	= 100
	bullet.HullSize 	= 10
	bullet.Damage	= 10
	bullet.Velocity = 8000
	bullet.Attacker 	= weapon:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,50,255) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_impact", effectdata )
	end
	weapon:LVSFireBullet( bullet )

	weapon:EmitSound("lvs/vehicles/iftx/fire_turret.mp3", 85, 100 + math.cos( CurTime() * 0.5 + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1, CHAN_WEAPON )

	local effectdata = EffectData()
	effectdata:SetStart( Vector(50,50,255) )
	effectdata:SetOrigin( bullet.Src )
	effectdata:SetNormal( dir )
	effectdata:SetEntity( weapon )
	util.Effect( "lvs_muzzle_colorable", effectdata )
end

function ENT:CanUseBTL()
	return self:GetBodygroup(1) == 0
end

function ENT:CanUseTurret()
	return self:GetBodygroup(1) == 1
end

function ENT:TraceBTL()
	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:SetPoseParameterBTL( weapon )
	if self:GetIsCarried() then
		self:SetPoseParameter("turret_pitch", 0 )
		self:SetPoseParameter("turret_yaw",  0 )

		return
	end

	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	self:SetPoseParameter("turret_pitch", AimAng.p )
	self:SetPoseParameter("turret_yaw",  AimAng.y )
end

function ENT:InitTurret()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.3
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return true end

		if not base:CanUseBTL() then
			if not base:CanUseTurret() then return true end

			base:FireTurret( ent )

			return
		end

		local trace = base:TraceBTL()

		base:BallturretDamage( trace.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - ent:GetPos()):GetNormalized() )
	end
	weapon.StartAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		if not base:CanUseBTL() then return end

		base:SetBTLFire( true )

		if not IsValid( self.sndBTL ) then return end

		self.sndBTL:Play()
		self.sndBTL:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
	end
	weapon.FinishAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetBTLFire( false )

		if not IsValid( self.sndBTL ) then return end

		self.sndBTL:Stop()
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterBTL( ent )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		if not base:CanUseBTL() and not base:CanUseTurret() then return end

		local Pos2D = base:TraceBTL().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

--PATH lua/entities/lvs_fall_missel.lua:
AddCSLuaFile()

ENT.Base = "lvs_fall_missel_base"

ENT.Type            = "anim"

ENT.PrintName = "Proton Torpedo"
ENT.Author = "Luna"
ENT.Information = "geht ab wie'n z�pfchen"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_explosion"
ENT.GlowColor = Color( 0, 117, 245, 235 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 8500)
	end

	function ENT:GetRadius() 
		return (self._radius or 250)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()	
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "lvs_proton_trail", effectdata )
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--PATH lua/entities/lvs_hoverchair/cl_init.lua:
-- This is my first addon done Solo. Do not judge the code. It is a wreck. It is disgusting. - Wolf

include("shared.lua")

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(-30,0,43) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-85,65,14) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-85,-65,14) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

--PATH lua/entities/lvs_hoverchair/shared.lua:

ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Yoda's Chair"
ENT.Author = "Wolf"
ENT.Information = ""
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/unconid/yoda_hoverchair/yoda_hoverchair.mdl"

ENT.AITEAM = 2

ENT.MaxHealth = 2700

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 180
ENT.MaxVelocityY = 180

ENT.MaxTurnRate = 1

ENT.BoostAddVelocityX = 120
ENT.BoostAddVelocityY = 120

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/iftx/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "^lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
} 
--PATH lua/entities/lvs_laatle_patrolgunship_imp/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_protontorpedo.lua:
AddCSLuaFile()

ENT.Base = "lvs_missile"

ENT.Type            = "anim"

ENT.PrintName = "Proton Torpedo"
ENT.Author = "Luna"
ENT.Information = "geht ab wie'n zpfchen"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_proton_explosion"
ENT.GlowColor = Color( 0, 127, 255, 255 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 400)
	end

	function ENT:GetRadius() 
		return (self._radius or 150)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()	
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "lvs_proton_trail", effectdata )
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--PATH lua/entities/lvs_repulsorlift_gunship/sh_ballturret_right.lua:

function ENT:SetPosBTR()
	local BTR = self:GetBTPodR()

	if not IsValid( BTR ) then return end

	local ID = self:LookupAttachment( "muzzle_ballturret_right" )
	local Muzzle = self:GetAttachment( ID )

	if Muzzle then
		local PosL = self:WorldToLocal( Muzzle.Pos + Muzzle.Ang:Right() * 28 - Muzzle.Ang:Up() * 65 )
		BTR:SetLocalPos( PosL )
	end
end

function ENT:TraceBTR()
	local ID = self:LookupAttachment( "muzzle_ballturret_right" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:SetPoseParameterBTR( weapon )
	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	self:SetPoseParameter("ballturret_right_pitch", AimAng.p )
	self:SetPoseParameter("ballturret_right_yaw", -AimAng.y )
end

function ENT:InitWeaponBTR()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.3
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not base._CanUseBT then return end

		local trace = base:TraceBTR()

		base:BallturretDamage( trace.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - ent:GetPos()):GetNormalized() )
	end
	weapon.StartAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not base._CanUseBT then return end

		base:SetBTRFire( true )

		if not IsValid( self.sndBTR ) then return end

		self.sndBTR:Play()
		self.sndBTR:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
	end
	weapon.FinishAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetBTRFire( false )

		if not IsValid( self.sndBTR ) then return end

		self.sndBTR:Stop()
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterBTR( ent )
		base:SetPosBTR()

		if not ent:GetAI() then return end

		local ID = base:LookupAttachment( "muzzle_ballturret_right" )
		local Muzzle = base:GetAttachment( ID )
		if not Muzzle then return end

		if ent:AngleBetweenNormal(Muzzle.Ang:Up(),ent:GetAimVector()) > 5 then
			ent:SetHeat( 1 )
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local ID = base:LookupAttachment( "muzzle_ballturret_right" )
		local Muzzle = base:GetAttachment( ID )

		if Muzzle then
			local Pos,Ang = LocalToWorld( Vector(0,25,-45), Angle(270,0,-90), Muzzle.Pos, Muzzle.Ang )

			view.origin = Pos
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceBTR().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 4 )
end
--PATH lua/entities/lvs_repulsorlift_gunship/sh_wingturret.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_gunship/cl_lights.lua:

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:RemoveLight()
	if IsValid( self.projector_L ) then
		self.projector_L:Remove()
		self.projector_L = nil
	end

	if IsValid( self.projector_R ) then
		self.projector_R:Remove()
		self.projector_R = nil
	end
end

function ENT:PostDrawTranslucent()
	if self:GetBodygroup( 5 ) ~= 2 or not self:GetLightsActive() then 
		self:RemoveLight()

		return
	end

	if not IsValid( self.projector_L ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 5000 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 40 )
		self.projector_L = thelamp
	end

	if not IsValid( self.projector_R ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 5000 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 40 )
		self.projector_R = thelamp
	end

	if not self.SpotlightID_L then
		self.SpotlightID_L = self:LookupAttachment( "spotlight_left" )
	else
		local attachment = self:GetAttachment( self.SpotlightID_L )

		if attachment then
			local StartPos = attachment.Pos
			local Dir = attachment.Ang:Up()

			render.SetMaterial( self.GlowMaterial )
			render.DrawSprite( StartPos + Dir * 20, 400, 400, Color( 255, 255, 255, 255) )

			render.SetMaterial( self.LightMaterial )
			render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 1500, 350, 0, 0.99, Color( 255, 255, 255, 10) ) 
			
			if IsValid( self.projector_L ) then
				self.projector_L:SetPos( StartPos )
				self.projector_L:SetAngles( Dir:Angle() )
				self.projector_L:Update()
			end
		end
	end

	if not self.SpotlightID_R then
		self.SpotlightID_R = self:LookupAttachment( "spotlight_right" )
	else
		local attachment = self:GetAttachment( self.SpotlightID_R )

		if attachment then
			local StartPos = attachment.Pos
			local Dir = attachment.Ang:Up()

			render.SetMaterial( self.GlowMaterial )
			render.DrawSprite( StartPos + Dir * 20, 400, 400, Color( 255, 255, 255, 255) )

			render.SetMaterial( self.LightMaterial )
			render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 1500, 350, 0, 0.99, Color( 255, 255, 255, 10 ) ) 

			if IsValid( self.projector_R ) then
				self.projector_R:SetPos( StartPos )
				self.projector_R:SetAngles( Dir:Angle() )
				self.projector_R:Update()
			end
		end
	end
end

function ENT:AnimLights()
	if self:GetBodygroup( 5 ) ~= 2 then return end

	local TargetValue = self:HitGround() and 0 or 1
	local Rate = FrameTime() * 10

	self.smSpotLight = isnumber( self.smSpotLight ) and (self.smSpotLight + math.Clamp(TargetValue - self.smSpotLight,-Rate,Rate * 0.1)) or 0

	if not self.SpotLightID_L then
		self.SpotLightID_L = self:LookupBone( "spotlight_left" ) 
	else
		self:ManipulateBoneAngles( self.SpotLightID_L, Angle(10,-30,5) * self.smSpotLight )	
	end

	if not self.SpotLightID_R then
		self.SpotLightID_R = self:LookupBone( "spotlight_right" ) 
	else
		self:ManipulateBoneAngles( self.SpotLightID_R, Angle(-10,30,5) * self.smSpotLight )	
	end
end
--PATH lua/entities/lvs_space_laat_arc/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_arc170/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "ARC-170 fighter"
ENT.Author = "Luna"
ENT.Information = "Heavy-Duty Starfighter of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/arc170.mdl"
ENT.GibModels = {
	"models/salza/arc170_gib1.mdl",
	"models/salza/arc170_gib2.mdl",
	"models/salza/arc170_gib3.mdl",
	"models/salza/arc170_gib4.mdl",
	"models/salza/arc170_gib5.mdl",
	"models/salza/arc170_gib6.mdl"
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 800
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "TailGunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(207.65,-303.52,-48.35),
		Vector(207.65,303.52,-48.35),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1000
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetFoils() then
			ent:SetHeat( ent:GetHeat() + 0.5 )
		end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 30
		bullet.Damage	= 40
		bullet.SplashDamage = 60
		bullet.SplashDamageRadius = 250
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent ) end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 12
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 90, (ent._swapMissile and -304 or 304), -32 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 2 or -2,0) ) )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )




	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 60 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )

		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(-175.81,0,50.26) or Vector(-171.69,0,5.81) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 45
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 60) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/arc170/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
}
--PATH lua/entities/lvs_turbo_laser/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_turbo_laser/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:OnSpawn()
end


--PATH lua/entities/lvs_turret_aa_red/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_ai/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_ai_red/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end

--PATH lua/entities/lvs_turret_av/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_av/shared.lua:
ENT.Base = "lvs_base_turret"

ENT.PrintName = "Anti-Vehicle Turret"
ENT.Author = "Luna"
ENT.Information = "Hard-hitting, but very limited firing arc. Good for dealing with pesky tanks."
ENT.Category = "[LVS] - Turrets (Republic)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/antivehicleturret/Anti-VehicleTurret.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.MaxHealth = 7500


function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,30) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 8 or AimAngles.p <= -10)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.67
	weapon.HeatRateDown = 0.2
    weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID = self:LookupAttachment( "muzzle" )
		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return end	

		local Pos = Muzzle.Pos
		local Dir = Muzzle.Ang:Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01)
		bullet.TracerName = "lvs_laser_blue_long"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 450
		bullet.Velocity = 20000
		bullet.SplashDamage	= 150
		bullet.SplashDamageRadius	= 200
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.5
    weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID_L = self:LookupAttachment( "muzzle_left" )
		local ID_R = self:LookupAttachment( "muzzle_right" )
		local MuzzleLeft = self:GetAttachment( ID_L )
		local MuzzleRight = self:GetAttachment( ID_R )

		if not MuzzleLeft or not MuzzleRight then return end		

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and MuzzleLeft.Pos or MuzzleRight.Pos
		local Dir =  (ent.MirrorPrimary and MuzzleLeft.Ang or MuzzleRight.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.015,  0.015, 0.015 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 35
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.SecondarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"
--PATH lua/entities/lvs_vwing_advanced/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 220, 150, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineCenter = Material( "vgui/circle" )
ENT.EnginePos = {
	[1] = Vector(-135,0.16,9.62),
	[2] = Vector(-135,0.72,-30.29),
}

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vwing/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 200, 50 )
	end
end

function ENT:PostDraw()
	if not self:GetEngineActive() then return end

	cam.Start3D2D( self:LocalToWorld( Vector(-125,0.16,9.62) ), self:LocalToWorldAngles( Angle(-90,0,0) ), 1 )
		surface.SetDrawColor( self.EngineColor )
		surface.SetMaterial( self.EngineCenter )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
		surface.SetDrawColor( color_white )
		surface.SetMaterial( self.EngineGlow )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
	cam.End3D2D()
	
	cam.Start3D2D( self:LocalToWorld( Vector(-125,0.72,-30.29) ), self:LocalToWorldAngles( Angle(-90,0,0) ), 1 )
		surface.SetDrawColor( self.EngineColor )
		surface.SetMaterial( self.EngineCenter )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
		surface.SetDrawColor( color_white )
		surface.SetMaterial( self.EngineGlow )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
	cam.End3D2D()
end

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-160,0.16,9.62), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-160,0.72,-30.29), 0, 20, 2, 1000, 150 )
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 60 + self:GetThrottle() * 60 + self:GetBoost()

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end


--PATH addons/[tfres] lego vechicles/lua/entities/lvs_vwing_advanced_lego/cl_init.lua:
return gluapack()()
--PATH addons/[tfres] lego vechicles/lua/entities/lvs_vwing_advanced_lego/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_rotary/cl_ikfunctions.lua:

function ENT:OnRemoved()
	self:LegClearAll()
	self:RemoveLight()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then 
		for _, tab in pairs( self.IK_Joints ) do
			for _,prop in pairs( tab ) do
				if IsValid( prop ) then
					prop:Remove()
				end
			end
		end
		
		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts( index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS )
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[ index ] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[ index ] then
		self.IK_Joints[ index ] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2 * 0.22 ) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.7) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()
		
		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )
	
	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--PATH lua/entities/lvs_walker_atrt_rotary/cl_legs.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/shared.lua:

ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "ATTE"
ENT.Author = "Luna"
ENT.Information = "Assault Walker of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Walkers"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/blu/atte.mdl"
ENT.GibModels = {
	"models/blu/atte.mdl",
	"models/blu/atte_rear.mdl",
	"models/blu/atte_bigfoot.mdl",
	"models/blu/atte_bigleg.mdl",
	"models/blu/atte_smallleg_part1.mdl",
	"models/blu/atte_smallleg_part2.mdl",
	"models/blu/atte_smallleg_part3.mdl"
}

ENT.AITEAM = 2

ENT.MaxHealth = 10000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 140
ENT.HoverTraceLength = 225
ENT.HoverHullRadius = 20

ENT.TurretTurnRate = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-220,0,-115)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true,
}

ENT.lvsShowInSpawner = true

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "RearEntity" )
	self:AddDT( "Entity", "TurretSeat" )
	self:AddDT( "Entity", "GunnerSeat" )

	self:AddDT( "Float", "Move" )
	self:AddDT( "Bool", "IsMoving" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Bool", "IsRagdoll" )
	self:AddDT( "Vector", "AIAimVector" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:SetTurretPitch( num )
	self._turretPitch = num
end

function ENT:SetTurretYaw( num )
	self._turretYaw = num
end

function ENT:GetTurretPitch()
	return (self._turretPitch or 0)
end

function ENT:GetTurretYaw()
	return (self._turretYaw or 0)
end

function ENT:GetContraption()
	return {self, self:GetRearEntity()}
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(265,0,100)) ):GetNormalized():Angle() )

	local ID = self:LookupAttachment( "muzzle_right_up" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return AimAngles, trace.HitPos, false end

	local DirAng = self:WorldToLocalAngles( (trace.HitPos - self:GetDriverSeat():LocalToWorld( Vector(0,0,33) ) ):Angle() )

	return AimAngles, trace.HitPos, (math.abs( DirAng.p ) < 12 and math.abs( DirAng.y ) < 35)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1000
	weapon.Delay = 0.1
	weapon.HeatRateUp = 2.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		if ent:GetIsCarried() then ent:SetHeat( 0 ) return true end

		local ID1 = ent:LookupAttachment( "muzzle_right_up" )
		local ID2 = ent:LookupAttachment( "muzzle_left_up" )
		local ID3 = ent:LookupAttachment( "muzzle_right_dn" )
		local ID4 = ent:LookupAttachment( "muzzle_left_dn" )

		local Muzzle1 = ent:GetAttachment( ID3 )
		local Muzzle2 = ent:GetAttachment( ID2 )
		local Muzzle3 = ent:GetAttachment( ID1 )
		local Muzzle4 = ent:GetAttachment( ID4 )

		if not Muzzle1 or not Muzzle2 or not Muzzle3 or not Muzzle4 then return end

		local FirePos = {
			[1] = Muzzle1,
			[2] = Muzzle2,
			[3] = Muzzle3,
			[4] = Muzzle4,
		}

		ent.FireIndex = ent.FireIndex and ent.FireIndex + 1 or 2
	
		if ent.FireIndex > #FirePos then
			ent.FireIndex = 1
		end

		local AimAngles, AimPos, InRange = ent:GetAimAngles()

		local Pos = FirePos[ent.FireIndex].Pos
		local Dir = (AimPos - Pos):GetNormalized()

		if not InRange then return true end

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0 )
		bullet.TracerName = "lvs_laser_green_short"
		bullet.Force	= 15000
		bullet.HullSize 	= 30
		bullet.Damage	= 100
		bullet.SplashDamage = 200
		bullet.SplashDamageRadius = 200
		bullet.Velocity = 8000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if not IsValid( ent.SNDPrimary ) then return end

		ent.SNDPrimary:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if IsValid( base ) and base:GetIsCarried() then return end

		local AimAngles = ent:GetAimAngles()

		ent:SetPoseParameter("frontgun_pitch", math.Clamp(AimAngles.p,-5,5) )
		ent:SetPoseParameter("frontgun_yaw", AimAngles.y )
	end
	self:AddWeapon( weapon )

	self:InitTurret()
	self:InitGunner()
end
--PATH lua/entities/lvs_walker_atte_hoverscript/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/cl_ikfunctions.lua:

function ENT:OnRemoved()
	self:LegClearAll()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then 
		for _, tab in pairs( self.IK_Joints ) do
			for _,prop in pairs( tab ) do
				if IsValid( prop ) then
					prop:Remove()
				end
			end
		end
		
		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts( index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS )
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[ index ] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[ index ] then
		self.IK_Joints[ index ] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()
		
		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )

	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--PATH gamemodes/starwarsrp/entities/entities/money_printer/shared.lua:
return gluapack()()
--PATH lua/entities/mortar/cl_init.lua:
return gluapack()()
--PATH lua/entities/mortar_shell/cl_init.lua:
return gluapack()()
--PATH lua/entities/mortar_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--PATH lua/entities/mortar_smoke_shell/cl_init.lua:
return gluapack()()
--PATH lua/entities/mvp_simpledefcons_display.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "DEFCON Display"
ENT.Author = "Kot @ Multiverse Project"

ENT.Spawnable = true
ENT.AdminOnly = false
ENT.Category = "MVP - Simple Defcons"

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

ENT.CanDrag = false

function ENT:Initialize()
    if SERVER then
        self:SetModel(mvp.config.Get("simpledefcons.entityDisplayModel") or "models/reizer_props/srsp/sci_fi/console_02_2/console_02_2.mdl")
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)

        self:SetUseType(SIMPLE_USE)
    end
end

if (CLIENT) then
    function ENT:Draw()
        self:DrawModel()

        local pos = Vector(0, 0, 25)
        local ang = Angle(0, LocalPlayer():EyeAngles().y - 90, 90)

        local P = mvp.package.Get("simpledefcons")
        local defconData = mvp.config.Get("simpledefcons.defcons")[P.activeDefcon]
        local defconName = defconData.name
        local defconColor = defconData.color

        cam.Start3D2D(self:LocalToWorld(pos), ang, 0.1)
            draw.SimpleText(mvp.q.Lang("simpledefcons.displayEntity"), mvp.Font(48, 600), 0, -25, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            
            draw.SimpleText(defconName, mvp.Font(85, 800), 0, 25, defconColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        cam.End3D2D()
    end
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_antitankmine/shared.lua:
AddCSLuaFile()

ENT.Base = "arc9_gsr_plantable"
ENT.PrintName = "Anti-Tank Mine"

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_atmine.mdl"
ENT.WeaponClass = "arc9_go_nade_landmines"
ENT.Bury = 3
ENT.DetectionRange = 300
ENT.ArmDelay = 5


function ENT:OnPlant()
    self:EmitSound("kraken/shared/beeps1.wav", 75, 100, 1, CHAN_AUTO)
end

function ENT:Think()
    if SERVER and self:GetArmed() then
        for k, v in ipairs(ents.FindInSphere(self:GetPos(), self.DetectionRange)) do
            if IsValid(v) and (v.LFS or v.LVS) then
                if v.LFS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
                    self:Detonate()
				end
				if v.LVS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
                    self:Detonate()
				end
                self:Detonate()
                break
            end
        end

        self:NextThink(CurTime() + 0.15)
        return true
    end
end

function ENT:Detonate()
    if SERVER then
        if not self:IsValid() then return end
        local pos = self:GetPos() + self:GetUp() * 6
        local effectdata = EffectData()
        effectdata:SetOrigin(pos)

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            ParticleEffect("explosion_grenade", pos, self:GetAngles(), nil)
            local spos = pos

            local trs = util.TraceLine({
                start = spos + Vector(0, 0, 64),
                endpos = spos + Vector(0, 0, -32),
                filter = self
            })

            util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)
            self:EmitSound("ArcCW_Kraken.Explosives.Explosion", 120, 100, 1, CHAN_AUTO)
        end

        util.ScreenShake(self:GetPos(), 25, 4, 1, self.DetectionRange * 15)

        local oldowner = self.Attacker or self:GetOwner()
        if not IsValid(oldowner) then
            oldowner = self
        end

        local d = Lerp(self:GetUp():Dot(Vector(0, 0, 1)), 0.25, 1)

        self:SetOwner(NULL)
        util.BlastDamage(oldowner, oldowner, pos, 200, 1500 * d)
        util.BlastDamage(oldowner, oldowner, pos, 356, 700 * d)

        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
        local pos = self:GetPos() + self:GetUp() * 5

        if self:GetArmed() and math.sin(CurTime() * 1) >= 0.75 then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
            render.SetMaterial(Material("effects/blueflare1")) -- Tell render what material we want, in this case the flash from the gravgun
            render.DrawSprite(pos, 16, 16, Color(255, 213, 0)) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_c14.lua:
return gluapack()()
--PATH lua/entities/nmg_mark_ii_ewhn-10/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_creature_base/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
ENT.Base 			= "base_entity"
ENT.Type 			= "ai"
ENT.PrintName 		= "VJ Creature SNPC Base"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "To make SNPCs."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.AutomaticFrameAdvance = false

ENT.IsVJBaseSNPC = true -- Is it a VJ Base SNPC?
ENT.IsVJBaseSNPC_Creature = true -- Is it a VJ Base creature?
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:SetAutomaticFrameAdvance(val)
	self.AutomaticFrameAdvance = val
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:MatFootStepQCEvent(data)
	-- Return true to apply all changes done to the data table.
	-- Return false to prevent the sound from playing.
	-- Return nil or nothing to play the sound without altering it.
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	//ENT.RenderGroup = RENDERGROUP_BOTH
	function ENT:Initialize() end
	function ENT:Draw() self:DrawModel() self:CustomOnDraw() end
	function ENT:DrawTranslucent() self:Draw() end
	function ENT:BuildBonePositions(NumBones,NumPhysBones) end
	function ENT:SetRagdollBones(bIn) self.m_bRagdollSetup = bIn end
	function ENT:DoRagdollBone(PhysBoneNum,BoneNum) /*self:SetBonePosition(BoneNum,Pos,Angle)*/ end
	//function ENT:CalcAbsolutePosition(pos, ang) end
	-- Custom functions ---------------------------------------------------------------------------------------------------------------------------------------------
	function ENT:CustomOnDraw() end
end
--PATH lua/entities/npc_vj_sbdnew/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_tridroidgunfixnew/shared.lua:
ENT.Base 			= "npc_vj_creature_base"
ENT.Type 			= "ai"
ENT.PrintName 		= "Tri Droidgun"
ENT.Author 			= "Mayhem - zhinged"
ENT.Contact 		= "http://vrejgaming.webs.com/"
ENT.Purpose 		= ""
ENT.Instructions	= "Click on it to spawn it."
ENT.Category		= "MGR"

if (CLIENT) then
local Name = "Tri Droid"
local LangName = "npc_vj_tridroidgunfixnew"
language.Add(LangName, Name)
killicon.Add(LangName,"HUD/killicons/default",Color ( 255, 80, 0, 255 ) )
language.Add("#"..LangName, Name)
killicon.Add("#"..LangName,"HUD/killicons/default",Color ( 255, 80, 0, 255 ) )
end
--PATH lua/entities/obj_vj_bullseye.lua:
return gluapack()()
--PATH lua/entities/obj_vj_bullseye.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Base 			= "base_entity"
ENT.Type 			= "ai"
ENT.PrintName 		= "Bullseye"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "To make my a target for NPCs"
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable 		= false
ENT.AdminSpawnable 	= false
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

//ENT.VJBULLSEYE_TheAttacker = nil
//ENT.Alreadydoneit = false
ENT.SolidMovementType = "Dynamic"
ENT.UseActivationSystem = false -- Mostly used for the Bullseye tool, allows you to activate/deactivate the bullseye
ENT.Activated = true
ENT.UserStatusColors = true
ENT.VJ_AlwaysEnemyToEnt = false

local sdActivated = Sound("hl1/fvox/activated.wav")
local sdDeactivated = Sound("hl1/fvox/deactivated.wav")
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Initialize()
	//self:SetModel("models/hunter/plates/plate.mdl")
	//self:SetMoveType(MOVETYPE_NONE)
	//self:SetSolid(SOLID_NONE)
	if self.SolidMovementType == "Dynamic" then
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_NONE)
		self:SetSolid(SOLID_VPHYSICS)
	elseif self.SolidMovementType == "Static" then
		self:PhysicsInit(SOLID_NONE)
		self:SetMoveType(MOVETYPE_NONE)
		self:SetSolid(SOLID_NONE)
	elseif self.SolidMovementType == "Physics" then
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
	end
	self:SetUseType(SIMPLE_USE)
	self:SetMaxHealth(999999)
	self:SetHealth(999999) -- So SNPCs won't think it's dead
	//self:SetColor(Color(255,0,0))
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:AcceptInput(key, activator, caller, data)
	if !activator:IsPlayer() then return end
	if self.Activated == false then
		self.Activated = true
		activator:PrintMessage(HUD_PRINTTALK, "#vjbase.print.bullseye.activated")
		self:EmitSound(sdActivated, 70, 100)
	elseif self.Activated == true then
		self.Activated = false
		activator:PrintMessage(HUD_PRINTTALK, "#vjbase.print.bullseye.deactivated")
		self:EmitSound(sdDeactivated, 70, 100)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Think()
	if self.VJ_AlwaysEnemyToEnt != false then
		//self:AddFlags(FL_NOTARGET) -- If NPC state is set, Source engine will automatically set m_hEnemy to NULL, so avoid putting this here!
		if IsValid(self.VJ_AlwaysEnemyToEnt) && self.VJ_AlwaysEnemyToEnt:IsNPC() then
			self.VJ_AlwaysEnemyToEnt:AddEntityRelationship(self, D_HT, 99)
			self:AddEntityRelationship(self.VJ_AlwaysEnemyToEnt, D_HT, 99)
			if self.VJ_AlwaysEnemyToEnt.IsVJBaseSNPC then
				self.VJ_AlwaysEnemyToEnt:VJ_DoSetEnemy(self, false, false)
			end
			self.VJ_AlwaysEnemyToEnt:SetEnemy(self)
		end
	elseif self.UseActivationSystem == true then
		if self.Activated == false then
			self:AddFlags(FL_NOTARGET)
			if self.UserStatusColors == true then self:SetColor(Color(255,0,0)) end
		elseif self.Activated == true then
			self:RemoveFlags(FL_NOTARGET)
			if self.UserStatusColors == true then self:SetColor(Color(0,255,0)) end
		end
	end
	/*if IsValid(self.VJBULLSEYE_TheAttacker) && self.Alreadydoneit == false then
		table.insert(self.VJBULLSEYE_TheAttacker.CurrentPossibleEnemies,self)
		//print(self.VJBULLSEYE_TheAttacker)
		//self.Alreadydoneit = true
		self:AddEntityRelationship(self.VJBULLSEYE_TheAttacker,D_HT,99)
		self.VJBULLSEYE_TheAttacker:VJ_DoSetEnemy(self)
	end*/
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnTakeDamage(dmginfo)
	return 0 -- Take no damage
end
--PATH lua/entities/obj_vj_combineball.lua:
return gluapack()()
--PATH lua/entities/obj_vj_flareround.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Type 			= "anim"
ENT.Base 			= "base_gmodentity"
ENT.PrintName		= "Flare Round"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "VJ Base"

ENT.Spawnable = true
ENT.AdminOnly = false
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	language.Add("obj_vj_flareround", "Flare Round")
	killicon.Add("obj_vj_flareround","HUD/killicons/default",Color(255,80,0,255))

	language.Add("#obj_vj_flareround", "Flare Round")
	killicon.Add("#obj_vj_flareround","HUD/killicons/default",Color(255,80,0,255))
	
	function ENT:Draw() self:DrawModel() end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

ENT.IdleSound1 = Sound("weapons/flaregun/burn.wav")
ENT.TouchSound = Sound("weapons/hegrenade/he_bounce-1.wav")
ENT.TouchSoundv = 75
ENT.Decal = "Scorch"
ENT.AlreadyPaintedDeathDecal = false
ENT.Dead = false
ENT.FussTime = 10
ENT.NextTouchSound = 0
---------------------------------------------------------------------------------------------------------------------------------------------
local colorRed = Color(255, 0, 0)
local colorTrailRed = Color(155, 0, 0, 150)
--
function ENT:Initialize()
	if self:GetModel() == "models/error.mdl" then self:SetModel("models/items/ar2_grenade.mdl") end
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetColor(colorRed)
	self:SetUseType(SIMPLE_USE)

	-- Physics Functions
	local phys = self:GetPhysicsObject()
	if IsValid(phys) then
		phys:Wake()
		phys:EnableGravity(true)
		phys:SetBuoyancyRatio(0)
	end

	-- Misc Functions
	//util.SpriteTrail(self, 0, Color(90,90,90,255), false, 10, 1, 3, 1/(15+1)*0.5, "trails/smoke.vmt")
	//ParticleEffectAttach("vj_rpg1_smoke", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	//ParticleEffectAttach("vj_rpg2_smoke2", PATTACH_ABSORIGIN_FOLLOW, self, 0)
	util.SpriteTrail(self, 0, colorTrailRed, false, 1, 100, 5, 5 / ((2 + 10) * 0.5), "trails/smoke.vmt")

	-- No longer needed, light is created by env_flare
	/*self.StartLight1 = ents.Create("light_dynamic")
	self.StartLight1:SetKeyValue("brightness", "0.01")
	self.StartLight1:SetKeyValue("distance", "1500")
	self.StartLight1:SetLocalPos(self:GetPos())
	self.StartLight1:SetLocalAngles( self:GetAngles() )
	self.StartLight1:Fire("Color", "255 0 0")
	self.StartLight1:SetParent(self)
	self.StartLight1:Spawn()
	self.StartLight1:Activate()
	self.StartLight1:Fire("TurnOn", "", 0)
	self:DeleteOnRemove(self.StartLight1)*/

	local envFlare = ents.Create("env_flare")
	envFlare:SetPos(self:GetPos())
	envFlare:SetAngles(self:GetAngles())
	envFlare:SetParent(self)
	envFlare:SetKeyValue("Scale","5")
	envFlare:SetKeyValue("spawnflags","4")
	envFlare:Spawn()
	envFlare:SetColor(colorRed)

	self.CurrentIdleSound = CreateSound(self, self.IdleSound1)
	self.CurrentIdleSound:SetSoundLevel(60)
	self.CurrentIdleSound:PlayEx(1, 100)

	local owner = self:GetOwner()
	if IsValid(owner) && owner.FlareAttackFussTime then
		timer.Simple(owner.FlareAttackFussTime, function() if IsValid(self) then self:DoDeath() end end)
	else
		timer.Simple(60, function() if IsValid(self) then self:DoDeath() end end)
	end
	
	-- Make it drop after in the air for a while
	timer.Simple(2, function()
		if IsValid(self) then
			local phys = self:GetPhysicsObject()
			if IsValid(phys) && phys:GetVelocity():Length() > 500 then
				phys:SetMass(0.005)
				timer.Simple(10, function()
					if IsValid(self) then
						phys:SetMass(5)
					end
				end)
			end
		end
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Use(activator, caller)
	if IsValid(activator) && activator:IsPlayer() then
		activator:PickupObject(self)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:PhysicsCollide(data, physobj)
	local hitEnt = data.HitEntity
	if IsValid(hitEnt) && (hitEnt:IsNPC() or hitEnt:IsPlayer()) then
		//hitEnt:Ignite(1)
		local dmg = DamageInfo()
		dmg:SetDamage(math.random(4, 8))
		dmg:SetDamageType(DMG_BURN)
		dmg:SetAttacker(self)
		dmg:SetInflictor(self)
		dmg:SetDamagePosition(data.HitPos)
		hitEnt:TakeDamageInfo(dmg, self)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnTakeDamage(dmginfo)
	self:GetPhysicsObject():AddVelocity(dmginfo:GetDamageForce() * 0.1)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:DoDeath()
	self.Dead = true
	if self.CurrentIdleSound then self.CurrentIdleSound:Stop() end
	self:StopParticles()
	
	timer.Simple(2, function()
		if IsValid(self) then
			self:Remove()
		end
	end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnRemove()
	self.Dead = true
	if self.CurrentIdleSound then self.CurrentIdleSound:Stop() end
end
--PATH lua/entities/obj_vj_npccontroller/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_npccontroller/shared.lua:
ENT.Base 			= "base_entity"
ENT.Type 			= "anim"
ENT.PrintName 		= "NPC Controller Base"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "To make my (S)NPCs controllable."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable 		= false
ENT.AdminSpawnable 	= false
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	function ENT:Draw() end
	
	local vec0 = Vector(0, 0, 0)
	local vec1 = Vector(1, 1, 1)
	local viewLerpVec = Vector(0, 0, 0)
	local viewLerpAng = Angle(0, 0, 0)
	---------------------------------------------------------------------------------------------------------------------------------------------
	hook.Add("CalcView", "VJ_MyCalcView", function(ply, origin, angles, fov)
		if !ply.IsControlingNPC then return end
		local camera = ply.VJCE_Camera -- Camera entity
		local npc = ply.VJCE_NPC -- The NPC that's being controlled
		if !IsValid(ply.VJCE_Camera) or !IsValid(ply.VJCE_NPC) then return end
		if IsValid(ply:GetViewEntity()) && ply:GetViewEntity():GetClass() == "gmod_cameraprop" then return end
		local cameraMode = ply.VJC_Camera_Mode

		local pos = origin -- The position that will be set
		local ang = ply:EyeAngles()
		if cameraMode == 2 then -- First person
			local setPos = npc:EyePos() + npc:GetForward()*20
			local offset = ply.VJC_FP_Offset
			//camera:SetLocalPos(camera:GetLocalPos() + ply.VJC_TP_Offset) -- Help keep the camera stable
			if ply.VJC_FP_Bone != -1 then -- If the bone does exist, then use the bone position
				local bonePos, boneAng = npc:GetBonePosition(ply.VJC_FP_Bone)
				setPos = bonePos
				if ply.VJC_FP_CameraBoneAng > 0 then
					ang[3] = boneAng[ply.VJC_FP_CameraBoneAng] + ply.VJC_FP_CameraBoneAng_Offset
				end
				if ply.VJC_FP_ShrinkBone then
					npc:ManipulateBoneScale(ply.VJC_FP_Bone, vec0) -- Bone manipulate to make it easier to see
				end
			end
			pos = setPos + (npc:GetForward()*offset.x + npc:GetRight()*offset.y + npc:GetUp()*offset.z)
		else -- Third person
			if ply.VJC_FP_Bone != -1 then -- Reset the NPC's bone manipulation!
				ply.VJCE_NPC:ManipulateBoneScale(ply.VJC_FP_Bone, vec1)
			end
			local offset = ply.VJC_TP_Offset + Vector(0, 0, npc:OBBMaxs().z - npc:OBBMins().z) // + vectp
			//camera:SetLocalPos(camera:GetLocalPos() + ply.VJC_TP_Offset) -- Help keep the camera stable
			local tr = util.TraceHull({
				start = npc:GetPos() + npc:OBBCenter(),
				endpos = npc:GetPos() + npc:OBBCenter() + angles:Forward()*-camera.Zoom + (npc:GetForward()*offset.x + npc:GetRight()*offset.y + npc:GetUp()*offset.z),
				filter = {ply, camera, npc},
				mins = Vector(-5, -5, -5),
				maxs = Vector(5, 5, 5),
				mask = MASK_SHOT,
			})
			pos = tr.HitPos + tr.HitNormal*2
		end

		if npc.Controller_CalcView then -- Allows custom calcview overrides
			local data = npc:Controller_CalcView(ply, pos, ang, fov, origin, angles, cameraMode)
			if data then
				pos = data.origin or pos
				ang = data.angles or ang
				fov = data.fov or fov
			end
		end
		
		-- Lerp the position and the angle
		local lerpSpeed = ply:GetInfoNum("vj_npc_cont_cam_speed", 6)
		viewLerpVec = (cameraMode == 2 and pos) or LerpVector(FrameTime()*lerpSpeed, viewLerpVec, pos)
        viewLerpAng = LerpAngle(FrameTime()*lerpSpeed, viewLerpAng, ang)
		
		-- Send the player's hit position to the controller entity
		local tr = util.TraceLine({start = viewLerpVec, endpos = viewLerpVec + viewLerpAng:Forward()*32768, filter = {ply, camera, npc}})
		//ParticleEffect("vj_impact1_centaurspit", tr.HitPos, Angle(0,0,0), npc)
		net.Start("vj_controller_cldata")
			net.WriteVector(tr.HitPos)
		net.SendToServer()
		
		local view = {
			origin = viewLerpVec,
			angles = viewLerpAng,
			fov = fov,
			drawviewer = false, //(cameraMode == 2 and true) or false
		}
		return view
	end)
	---------------------------------------------------------------------------------------------------------------------------------------------
	hook.Add("PlayerBindPress", "vj_controller_PlayerBindPress", function(ply, bind, pressed)
		-- For scroll wheel zooming
		if (bind == "invprev" or bind == "invnext") && ply.IsControlingNPC && IsValid(ply.VJCE_Camera) && ply.VJC_Camera_Mode != 2 then
			ply.VJCE_Camera.Zoom = ply.VJCE_Camera.Zoom or 100
			if bind == "invprev" then
				ply.VJCE_Camera.Zoom = math.Clamp(ply.VJCE_Camera.Zoom - ply:GetInfoNum("vj_npc_cont_cam_zoomspeed", 10), 0, 500)
			else
				ply.VJCE_Camera.Zoom = math.Clamp(ply.VJCE_Camera.Zoom + ply:GetInfoNum("vj_npc_cont_cam_zoomspeed", 10), 0, 500)
			end
		end
	end)
	---------------------------------------------------------------------------------------------------------------------------------------------
	net.Receive("vj_controller_data", function(len)
		//print("Data Sent!")
		//print(len)
		local ply = LocalPlayer()
		ply.IsControlingNPC = net.ReadBool()
		ply.VJCE_Camera = ents.GetByIndex(net.ReadUInt(14))
		ply.VJCE_Camera.Zoom = ply.VJCE_Camera.Zoom or 100
		-- If the controller has stopped then reset the NPC's bone manipulation!
		if ply.IsControlingNPC == false && IsValid(ply.VJCE_NPC) && ply.VJC_FP_Bone != -1 then
			ply.VJCE_NPC:ManipulateBoneScale(ply.VJC_FP_Bone, vec1)
		end
		ply.VJCE_NPC = ents.GetByIndex(net.ReadUInt(14))
		ply.VJC_Camera_Mode = net.ReadUInt(2)
		ply.VJC_TP_Offset = net.ReadVector()
		ply.VJC_FP_Offset = net.ReadVector()
		ply.VJC_FP_Bone = net.ReadInt(10)
		ply.VJC_FP_ShrinkBone = net.ReadBool()
		ply.VJC_FP_CameraBoneAng = net.ReadUInt(2) or 0
		ply.VJC_FP_CameraBoneAng_Offset = net.ReadInt(10) or 0
	end)
	---------------------------------------------------------------------------------------------------------------------------------------------
	local lerp_hp = 0
	local atk_col_red = Color(255, 60, 60, 255)
	local atk_col_orange = Color(204, 123, 60, 255)
	local atk_col_green = Color(60, 220, 60, 255)
	local mat_icon_melee = Material("vj_base/hud_controller/melee.png")
	local mat_icon_range = Material("vj_base/hud_controller/range.png")
	local mat_icon_leap = Material("vj_base/hud_controller/leap.png")
	local mat_icon_grenade = Material("vj_base/hud_controller/grenade.png")
	local mat_icon_gun = Material("vj_base/hud_controller/gun.png")
	local mat_icon_camera = Material("vj_base/hud_controller/camera.png")
	local mat_icon_zoom = Material("vj_base/hud_controller/camera_zoom.png")
	net.Receive("vj_controller_hud", function(len)
		//print(len)
		local enabled = net.ReadBool()
		local maxhp = net.ReadFloat()
		local hp = net.ReadFloat()
		local name = net.ReadString()
		local AtkTbl = net.ReadTable()
		local ply = LocalPlayer()
		hook.Add("HUDPaint", "vj_controller_HUD", function()
			draw.RoundedBox(1, ScrW() / 2.25, ScrH()-120, 220, 100, Color(0, 0, 0, 150))
			draw.SimpleText(name, "VJFont_Trebuchet24_SmallMedium", ScrW() / 2.21, ScrH()-115, Color(255,255,255,255), 0, 0)
			
			local hp_r = 255
			local hp_g = 153
			local hp_b = 0
			lerp_hp = Lerp(5*FrameTime(),lerp_hp,hp)
			draw.RoundedBox(0, ScrW() / 2.21, ScrH()-95, 180, 20, Color(hp_r,hp_g,hp_b,40))
			draw.RoundedBox(0, ScrW() / 2.21, ScrH()-95, (190*math.Clamp(lerp_hp,0,maxhp))/maxhp,20, Color(hp_r,hp_g,hp_b,255))
			surface.SetDrawColor(hp_r,hp_g,hp_b,255)
			surface.DrawOutlinedRect( ScrW() / 2.21, ScrH()-95,180,20)
			
			local finalhp = tostring(string.format("%.0f", lerp_hp).."/"..maxhp)
			local distlen = string.len(finalhp)
			local move = 0
			if distlen > 1 then
				move = move - (0.009*(distlen-1))
			end
			draw.SimpleText(finalhp, "VJFont_Trebuchet24_SmallMedium", ScrW() / (2-move), ScrH()-94, Color(255,255,255,255), 0, 0)
			
			-- Attack Icons
			surface.SetMaterial(mat_icon_melee)
			surface.SetDrawColor((AtkTbl["MeleeAttack"] == false and atk_col_red) or ((AtkTbl["MeleeAttack"] == 2 and atk_col_orange) or atk_col_green))
			surface.DrawTexturedRect(ScrW() / 2.21, ScrH()-73, 28, 28)
			
			surface.SetMaterial(mat_icon_range)
			surface.SetDrawColor((AtkTbl["RangeAttack"] == false and atk_col_red) or ((AtkTbl["RangeAttack"] == 2 and atk_col_orange) or atk_col_green))
			surface.DrawTexturedRect(ScrW() / 2.14, ScrH()-73, 28, 28)
			
			surface.SetMaterial(mat_icon_leap)
			surface.SetDrawColor((AtkTbl["LeapAttack"] == false and atk_col_red) or ((AtkTbl["LeapAttack"] == 2 and atk_col_orange) or atk_col_green))
			surface.DrawTexturedRect(ScrW() / 2.065, ScrH()-73, 28, 28)
			
			surface.SetMaterial(mat_icon_grenade)
			surface.SetDrawColor((AtkTbl["GrenadeAttack"] == false and atk_col_red) or ((AtkTbl["GrenadeAttack"] == 2 and atk_col_orange) or atk_col_green))
			surface.DrawTexturedRect(ScrW() / 2.005, ScrH()-73, 28, 28)
			
			surface.SetMaterial(mat_icon_gun)
			surface.SetDrawColor((AtkTbl["WeaponAttack"] != true and atk_col_red) or ((AtkTbl["Ammo"] <= 0 and atk_col_orange) or atk_col_green))
			surface.DrawTexturedRect(ScrW() / 1.94, ScrH()-73, 28, 28) // 1.865
			draw.SimpleText(AtkTbl["Ammo"], "VJFont_Trebuchet24_Medium", ScrW() / 1.885, ScrH()-70, (AtkTbl["WeaponAttack"] != true and atk_col_red) or ((AtkTbl["Ammo"] <= 0 and atk_col_orange) or atk_col_green), 0, 0)
			
			-- Camera
			surface.SetMaterial(mat_icon_camera)
			surface.SetDrawColor(Color(255, 255, 255, 255))
			surface.DrawTexturedRect(ScrW() / 2.21, ScrH()-45, 22, 22)
			draw.SimpleText((ply.VJC_Camera_Mode == 1 and "Third") or "First", "VJFont_Trebuchet24_SmallMedium", ScrW() / 2.155, ScrH()-43, Color(255, 255, 255, 255), 0, 0) // VJFont_Trebuchet24_SmallMedium
			
			-- Zoom Camera
			surface.SetMaterial(mat_icon_zoom)
			surface.SetDrawColor(Color(255, 255, 255, 255))
			surface.DrawTexturedRect(ScrW() / 2.065, ScrH()-45, 22, 22)
			draw.SimpleText(ply.VJCE_Camera.Zoom, "VJFont_Trebuchet24_Medium", ScrW() / 2.005, ScrH()-45, Color(255, 255, 255, 255), 0, 0) // VJFont_Trebuchet24_SmallMedium
		end)
		if enabled != true then hook.Remove("HUDPaint", "vj_controller_HUD") end
	end)
end
--PATH lua/entities/obj_vj_projectile_base/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
ENT.Base 			= "base_gmodentity"
ENT.Type 			= "anim"
ENT.PrintName 		= "VJ Projectile Base"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "To make projectiles."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable 		= false
ENT.AdminSpawnable	= false

if CLIENT then
	function ENT:Draw() self:DrawModel() end
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_blackjack_table/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_mystery_wheel/cl_init.lua:
include("shared.lua")


function ENT:Initialize()
	self.active = false
	self.currentBets = {}

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
end

local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local draw_simpletext = draw.SimpleText
local surface_setdrawcolor = surface.SetDrawColor
local surface_setmaterial = surface.SetMaterial
local surface_gettextsize = surface.GetTextSize
local surface_setfont = surface.SetFont
local draw_notexture = draw.NoTexture
local math_cos = math.cos
local math_sin = math.sin
local math_rad = math.rad
local black = Color(0, 0, 0, 155)
local white = Color(255, 255, 255, 100)
function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end


	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	-- Basic setups
	local pos = self:GetPos()
	local ang = self:GetBoneMatrix(2):GetAngles()

	ang:RotateAroundAxis(ang:Up(), 89.8)
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Up(), -162)

	cam.Start3D2D(pos + (self:GetUp()*9.75) + (self:GetRight()*0.2) + (self:GetForward()*-17.4), ang, 0.08)
		-- Spinny wheel icons
		local itter = 0
		for i=1, 360, 360/20 do 
			itter = itter + 1
			local x = math_cos(math_rad(i - 91)) * 155
			local y = math_sin(math_rad(i - 91)) * 155

			draw_notexture()
			surface_setdrawcolor(255, 255, 255, 255)
			surface_setmaterial(PerfectCasino.Icons[self.data.wheel[21 - itter].p].mat)

			PerfectCasino.UI.DrawTexturedRectRotatedPoint(x, y, 60, 60, (-i+1), 0, -218)
			PerfectCasino.UI.TextRotated(self.data.wheel[21 - itter].n, x, y, color_white, "pCasino.Title.Static", i-90, 1)
		end
	cam.End3D2D()

	if tobool(self.data.buySpin.buy) or (tobool(self.data.general.useFreeSpins) and (PerfectCasino.Spins > 0)) then
		-- Basic setups
		local pos = self:GetPos()
		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), 50)
		ang:RotateAroundAxis(ang:Forward(), 90)
	
		surface_setfont("pCasino.Entity.Arrows")
		local spinSize, _ = surface_gettextsize(PerfectCasino.Translation.UI.PurchaseASpin)
		local moneySize, _ = surface_gettextsize(PerfectCasino.Config.FormatMoney(self.data.buySpin.cost))
		local biggestSize = (spinSize > moneySize) and spinSize or moneySize
		biggestSize = biggestSize + 100

		cam.Start3D2D(pos + (ang:Up()*-35) + (ang:Forward()*25) + (ang:Right()*-9) + ((ang:Right()*-2)*(math.sin(CurTime()*0.5))), ang, 0.05)
				-- Current bet
				surface_setdrawcolor(black)
				surface_drawrect(-10, -20, biggestSize, 120)
				-- Border
				surface_setdrawcolor(white)
				surface_drawrect(-15, -25, biggestSize+10, 5)
				surface_drawrect(-15, -20, 5, 120)
				surface_drawrect(biggestSize-10, -20, 5, 120)
				surface_drawrect(-15, 100, biggestSize+10, 5)
				-- Current Bid
				draw_simpletext((PerfectCasino.Spins > 0) and PerfectCasino.Translation.UI.FreeSpin or PerfectCasino.Translation.UI.PurchaseASpin, "pCasino.Entity.Arrows", biggestSize/2-10, 37, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
				draw_simpletext((PerfectCasino.Spins > 0) and string.format(PerfectCasino.Translation.UI.FreeSpinCount, PerfectCasino.Spins) or PerfectCasino.Config.FormatMoney(self.data.buySpin.cost), "pCasino.Entity.Arrows", biggestSize/2-10, 37, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		cam.End3D2D()
	end
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_stand/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Stand"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

PerfectCasino.Core.RegisterEntity("pcasino_sign_stand", {
	-- General data
	general = {
		text = {d = "Casino", t = "string"} -- The text to show
	}
},
"models/freeman/owain_casinosign_standing.mdl")
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_wheel_slot_machine/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.active = false
	self.spin = false

	self.wheels = {}
	for i=0, self:GetNumPoseParameters()-2 do
		self.wheels[i+1] = {name = self:GetPoseParameterName(i)}
	end

	self.isPreSpin = false
	self.hasInitialized = true
end
function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
end

local colorGold = Color(255, 200, 0)
local colorPurple = Color(255, 0, 255)
local colorDarkWhite = Color(240, 240, 240)
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	-- For ticking value
	self.curJackpot = math.Approach(self.curJackpot or self:GetCurrentJackpot(), self:GetCurrentJackpot(), math.Round((self.data.bet.default*5)*FrameTime()))

	-- Basic setups
	local pos = self:GetPos()
	local ang = self:GetAngles()
	
	ang:RotateAroundAxis(ang:Up(), 90)
	ang:RotateAroundAxis(ang:Forward(), 90)

	cam.Start3D2D(pos + (ang:Up()*-5.17) + (ang:Right()*-31.63) + (ang:Forward()*-0.1), ang, 0.02)
		-- Spinny wheel icons
		local itter = 0
		for i=1, 360, 360/12 do 
			itter = itter + 1
			local x = math.cos(math.rad(i - 90)) * 115
			local y = math.sin(math.rad(i - 90)) * 115

			draw.NoTexture()
			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetMaterial(PerfectCasino.Icons[self.data.wheel[itter].p].mat)

			PerfectCasino.UI.DrawTexturedRectRotatedPoint(x, y, 80, 80, (-i), 0, -145)
			PerfectCasino.UI.TextRotated(self.data.wheel[itter].n, x, y, colorDarkWhite, "pCasino.Title.Static", i-90)
		end

		-- Pre spin text
		if self.isPreSpin and (math.ceil((CurTime()*2)%2) == 1) then
			draw.SimpleText(PerfectCasino.Translation.UI.SpinThatWheel, "pCasino.Entity.Bid", 0, 590, colorPurple, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end

		draw.SimpleText(string.format(PerfectCasino.Translation.UI.JackPot, PerfectCasino.Config.FormatMoney(self.curJackpot)), "pCasino.Title.Static", 0, 650, colorGold, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		draw.SimpleText(string.format(PerfectCasino.Translation.UI.Play, PerfectCasino.Config.FormatMoney(self.data.bet.default)), "pCasino.Title.Static", -415, 650, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		
	cam.End3D2D()
end

function ENT:Think()
	if not self.active then return end
	if self.win then
		for i=1, 2 do
			local winLight = DynamicLight(self:EntIndex()+i)
			if winLight then
				winLight.pos = self:GetPos()+(self:GetUp()*13)+(self:GetForward()*-5)+((self:GetRight()*3)*(-3+(2*i)))
				winLight.r = (self.win == 2) and ((math.Round(CurTime()%1) == 1) and 100 or 0) or 100
				winLight.g = self.win == 2 and 0 or 100
				winLight.b = (self.win == 2) and 100 or 0 -- and ((math.Round(CurTime()%2) == 1) and
				winLight.brightness = 3
				winLight.Decay = 1000
				winLight.Size = 100
				winLight.DieTime = CurTime() + 1
			end
		end
	end

	for k, v in pairs(self.wheels) do
		if v.spinning then
			self:SetPoseParameter(v.name, (CurTime()*600)%360)
		end
	end
end

-- Game specific code
function ENT:StartSpinning(i)
	self.wheels[i].spinning = true
end

function ENT:StopSpinning(i, result)
	local wheel = self.wheels[i]
	if not wheel then return end
	
	wheel.spinning = false
end

function ENT:StartWin(winData)
	-- 2 is jackpot, 1 is normal win
	self.win = tobool(winData.j) and 2 or 1
end

function ENT:EndWin()
	self.active = false
	self.win = nil
	self.spin = false
	self.isPreSpin = false
end

net.Receive("pCasino:WheelSlot:Spin:Start", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 500000 then return end
	if not entity.data then return end

	entity.active = true

	for i=1, 3 do
		entity:StartSpinning(i)
	end
end)

net.Receive("pCasino:WheelSlot:Spin:Stop", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.active then return end
	if not entity.data then return end

	local key = net.ReadUInt(2)
	local result = net.ReadString()
	entity:StopSpinning(key, result)
end)

net.Receive("pCasino:WheelSlot:Spin:Win", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.active then return end
	if not entity.data then return end

	local winData = net.ReadTable()
	entity:StartWin(winData)
	
	if tobool(winData.j) then
		entity.isPreSpin = true
		return
	end

	timer.Simple(2, function()
		entity:EndWin()
	end)
end)

net.Receive("pCasino:WheelSlot:Spin:Spin", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.active then return end
	if not entity.data then return end

	entity.spin = true
	entity.isPreSpin = false
	timer.Simple(5, function()
		entity:EndWin()
	end)
end)
--PATH lua/entities/pfx1_08_.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Red]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_red"
--PATH lua/entities/pfx1_08_~_l.lua:
return gluapack()()
--PATH lua/entities/pfx2_03.lua:
return gluapack()()
--PATH lua/entities/pfx2_04.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Swirl 1"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]swirl_1"
--PATH lua/entities/pfx3_00.lua:
return gluapack()()
--PATH lua/entities/pfx4_00_s.lua:
return gluapack()()
--PATH lua/entities/pfx4_00_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Basic Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_f_s"
--PATH lua/entities/pfx4_04~.lua:
return gluapack()()
--PATH lua/entities/pfx4_06_2.lua:
return gluapack()()
--PATH lua/entities/pfx4_0b.lua:
return gluapack()()
--PATH lua/entities/pfx5_00_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Small Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole_micro"
--PATH lua/entities/pfx5_00_ss.lua:
return gluapack()()
--PATH lua/entities/pfx5_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Starfield 1"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]starfield1"
--PATH lua/entities/pfx5_02.lua:
return gluapack()()
--PATH lua/entities/pfx6_02.lua:
return gluapack()()
--PATH lua/entities/pfx8_06.lua:
return gluapack()()
--PATH lua/entities/pfxcom.lua:
return gluapack()()
--PATH lua/entities/portals_base.lua:
AddCSLuaFile()

ENT.Base = "base_anim"
ENT.Type = "anim"

ENT.RenderGroup = RENDERGROUP_STATIC
ENT.Model = Model("models/lordtrilobite/starwars/props/imp_prefabbase_door01.mdl")

ENT.Mins = Vector(-25, -25, 5)
ENT.Maxs = Vector(25, 25, 50)

function ENT:Initialize()
	self:SetModel(self.Model)

	self:DrawShadow(false)

	if SERVER then
		self:PhysicsInitBox(self.Mins, self.Maxs)
		self:SetMoveType(MOVETYPE_NONE)

		self:SetTrigger(true)
	end

	self:SetCollisionGroup(COLLISION_GROUP_WORLD)
end

function ENT:GetCustomColor()
	return color_white
end

if CLIENT then
	local lightsEnabled = GetConVar("portals_lights_enabled")
	local lightsRange = GetConVar("portals_lights_range")

	function ENT:ShouldDoLight() -- Convar
		if not lightsEnabled:GetBool() then
			return false
		end

		local range = lightsRange:GetFloat() * lightsRange:GetFloat()

		return not self:IsDormant() and EyePos():DistToSqr(self:GetPos()) < range
	end

	function ENT:Think()
		local color = self:GetCustomColor()

		if self:GetColor() != color then
			self:SetColor(color)
		end

		if self:ShouldDoLight() then
			local light = DynamicLight(self:EntIndex())

			if light then
				light.pos = self:GetPos()
				light.r = color.r
				light.g = color.g
				light.b = color.b
				light.brightness = 2
				light.Decay = 1000
				light.Size = 128
				light.DieTime = CurTime() + 1
			end
		end

		self:RemoveAllDecals()
	end

	local developer = GetConVar("developer")
	local sprite = Material("sprites/light_glow02_add")

	function ENT:DrawTranslucent()
		if developer:GetBool() then
			local mins = self.Mins - Vector(0.1, 0.1, 0.1)
			local maxs = self.Maxs + Vector(0.1, 0.1, 0.1)

			local color = ColorAlpha(self:GetCustomColor(), 50)

			render.SetColorMaterial()
			render.DrawBox(self:GetPos(), self:GetNetworkAngles(), mins, maxs, color, true)
			render.DrawWireframeBox(self:GetPos(), self:GetNetworkAngles(), mins, maxs, color, true)

			render.DrawLine(self:GetPos(), self:GetPos() + self:GetForward() * 50, self:GetCustomColor(), true)
		end

		render.OverrideBlend(true, BLEND_ZERO, BLEND_ONE_MINUS_SRC_COLOR, BLENDFUNC_ADD)
		render.SetMaterial(sprite)
		render.DrawSprite(self:GetPos(), 150, 150)
		render.OverrideBlend(false)

		local ang = (EyePos() - self:GetPos()):Angle()

		self:SetRenderAngles(ang)
		self:SetupBones()
		self:DrawModel()
		self:DrawModel()
	end
else
	local allowSound = GetConVar("portals_allow_custom_sounds")
	local defaultSound = GetConVar("porte_default_sound")
	local extendedWhitelist = GetConVar("portals_extended_whitelist")

	function ENT:TeleportEffect(ent)
		if not ent then
			ent = self
		end

		local snd = defaultSound:GetString()

		if allowSound:GetBool() and self.GetTeleportSound then
			snd = self:GetTeleportSound()
		end

		if snd == "" then
			return
		end

		ent:EmitSound(snd, 75, 100, 0.5)
	end

	function ENT:IsValidEntity(ent)
		if ent:IsPlayer() then
			return ent:GetMoveType() != MOVETYPE_NOCLIP
		end

		if not extendedWhitelist:GetBool() and not ent:IsNPC() then
			return false
		end

		local phys = ent:GetPhysicsObject()

		if IsValid(phys) and not phys:IsMotionEnabled() then
			return false
		end

		local class = ent:GetClass()

		if string.find(class, "prop_dynamic") then return false end
		if string.find(class, "prop_door") then return false end
		if class == "func_physbox" and ent:HasSpawnFlags(SF_PHYSBOX_MOTIONDISABLED) then return false end
		if string.find(class, "prop_") and (ent:HasSpawnFlags(SF_PHYSPROP_MOTIONDISABLED) or ent:HasSpawnFlags(SF_PHYSPROP_PREVENT_PICKUP)) then return false end
		if class != "func_physbox" and string.find(class, "func_") then return false end

		return false
	end
end

--PATH lua/entities/portals_out.lua:
AddCSLuaFile()

ENT.Base = "portals_base"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT



ENT.Spawnable = true
ENT.Editable = true

ENT.BaseColor = Color(100, 200, 0)

local defaultSound = GetConVar("porte_default_sound")

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "Group", {
		KeyName = "group",
		Edit = {
			order = 0,
			type = "Generic"
		}
	})

	self:NetworkVar("String", 1, "TeleportSound", {
		KeyName = "sound",
		Edit = {
			title = "Teleport Sound",
			order = 1,
			type = "Generic"
		}
	})

	self:NetworkVar("Vector", 0, "PortalColor", {
		KeyName = "portalcolor",
		Edit = {
			order = 1,
			type = "VectorColor"
		}
	})

	self:SetTeleportSound(defaultSound:GetString())
	self:SetPortalColor(self.BaseColor:ToVector())
end

local allow = GetConVar("portals_allow_custom_colors")

function ENT:GetCustomColor()
	return allow:GetBool() and self:GetPortalColor():ToColor() or self.BaseColor
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_hh12.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_plx1.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/rocket_plx1.lua:
AddCSLuaFile()

ENT.Base                     = "kraken_proj_base"
ENT.PrintName                = "PLX-1 Rocket"
ENT.Spawnable                = false
ENT.Model                    = "models/items/ar2_grenade.mdl"

ENT.IsRocket = true -- projectile has a booster and will not drop.
ENT.InstantFuse = false -- projectile is armed immediately after firing.
ENT.RemoteFuse = false -- allow this projectile to be triggered by remote detonator.
ENT.ImpactFuse = true -- projectile explodes on impact.
ENT.ExplodeOnDamage = true
ENT.ExplodeUnderwater = true

ENT.Delay = 0
ENT.SafetyFuse = 0.02
ENT.AudioLoop = "kraken/launchers/rps/move_rpapa7_proj_flame_cls.ogg"
ENT.SmokeTrail = false
ENT.RocketTrail = true -- leaves trail of a particle effect
ENT.FlareColor = Color(255, 155, 0)
ENT.FlareSizeMin = 50
ENT.FlareSizeMax = 100
ENT.Radius = 470

--- Stuff
ENT.SeekerAngle = math.cos(math.rad(55))
ENT.SteerSpeed = 5000
ENT.FuseTime = 0
ENT.Boost = 1700
ENT.Lift = 80
ENT.DragCoefficient = 0.1
ENT.LifeTime = 20
ENT.FireAndForget = true
ENT.TopAttack = true -- This missile flies up above its target before going down in a top-attack trajectory.
ENT.TopAttackHeight = 5000
ENT.SuperSeeker = false
ENT.SuperSteerTime = 0
ENT.SuperSteerBoostTime = 100
ENT.NoReacquire = true
ENT.ShootEntData = {}
ENT.IsProjectile = true
ENT.LockOnPoint = nil

DEFINE_BASECLASS(ENT.Base)

function ENT:OnInitialize()
    if not IsValid(self.ShootEntData.Target) then
        local tr = util.TraceLine({
            start = self:GetPos(),
            endpos = self:GetPos() + self:GetForward() * 100000,
            filter = {self, self:GetOwner()},
            mask = MASK_SHOT
        })

        self.LockOnPoint = tr.HitPos
    end
    self:EmitSound("kraken/explosives/heat_burn.wav",75, 100, 1, CHAN_AUTO)
	self.LastAimPos = self:GetOwner():GetEyeTrace().HitPos
end

function ENT:Impact(data, collider)
   util.Decal("Scorch", data.HitPos + data.HitNormal, data.HitPos - data.HitNormal)
end

function ENT:OnThink()
if SERVER then
    if self.FireAndForget or self.SemiActive then
        if self.SemiActive then
            if IsValid(self.Weapon) then
                self.ShootEntData = self.Weapon:RunHook("Hook_GetShootEntData", {})
            end
        end

        local tpos = self.LockOnPoint

        if self.ShootEntData.Target and IsValid(self.ShootEntData.Target) then
            local target = self.ShootEntData.Target

            if target.UnTrackable then
                self.ShootEntData.Target = nil
            end

            tpos = target:EyePos()
        end

        if self.TopAttack and not self.TopAttackReached then
            tpos = tpos + Vector(0, 0, self.TopAttackHeight)
            local dist = (tpos - self:GetPos()):Length()

            if dist <= 3000 then
                self.TopAttackReached = true
                self.SuperSteerTime = CurTime() + self.SuperSteerBoostTime
            end
        end

        local dir = (tpos - self:GetPos()):GetNormalized()
        local dot = dir:Dot(self:GetAngles():Forward())
        local ang = dir:Angle()

        if self.SuperSeeker or dot >= self.SeekerAngle or not self.TopAttackReached or (self.SuperSteerTime and self.SuperSteerTime >= CurTime()) then
            local p = self:GetAngles().p
            local y = self:GetAngles().y
            p = math.ApproachAngle(p, ang.p, FrameTime() * self.SteerSpeed)
            y = math.ApproachAngle(y, ang.y, FrameTime() * self.SteerSpeed)
            self:SetAngles(Angle(p, y, 0))
            -- self:SetVelocity(dir * 15000)
        elseif self.NoReacquire then
            self.ShootEntData.Target = nil
        end
        -- end
    elseif self.SACLOS then
        if self:GetOwner():IsValid() then
            local tpos = self:GetOwner():GetEyeTrace().HitPos
            local dir = (tpos - self:GetPos()):GetNormalized()
            local dot = dir:Dot(self:GetAngles():Forward())
            local ang = dir:Angle()

            if dot >= self.SeekerAngle then
                local p = self:GetAngles().p
                local y = self:GetAngles().y
                p = math.ApproachAngle(p, ang.p, FrameTime() * self.SteerSpeed)
                y = math.ApproachAngle(y, ang.y, FrameTime() * self.SteerSpeed)
                self:SetAngles(Angle(p, y, 0))
            end
        end
    end
    self:GetPhysicsObject():AddVelocity(Vector(0, 0, self.Lift) + self:GetForward() * self.Boost)
end
end

function ENT:Detonate()
    local attacker = self.Attacker or self:GetOwner()
    local dir = self:GetVelocity():GetNormalized()
    local src = self:GetPos() - dir * 64

    local dmg = DamageInfo()
    dmg:SetAttacker(attacker)
    dmg:SetDamageType(DMG_AIRBOAT + DMG_BLAST)
    dmg:SetInflictor(self)
    dmg:SetDamageForce(self:GetVelocity() * 100)
    dmg:SetDamagePosition(src)
    dmg:SetDamage(325)
    util.BlastDamageInfo(dmg, self:GetPos(), self.Radius)
    util.BlastDamage(self, IsValid(self:GetOwner()) and self:GetOwner() or self, self:GetPos(), 300, 64)
    self:FireBullets({
        Attacker = attacker,
        Damage = 600,
        Tracer = 0,
        Src = src,
        Dir = dir,
        HullSize = 16,
        Distance = 256,
        IgnoreEntity = self,
        Callback = function(atk, btr, dmginfo)
            if IsValid(btr.Entity) and btr.Entity.LVS then
                dmginfo:ScaleDamage(5)
                dmginfo:SetDamageType(DMG_AIRBOAT + DMG_SNIPER + DMG_BLAST)
                dmginfo:SetDamageForce(self:GetForward() * 100000)
            end
        end,
    })

    local fx = EffectData()
	fx:SetOrigin(self:GetPos())
	fx:SetStart(self:GetPos() + self:GetUp())
	fx:SetRadius(512)
    fx:SetEntity(self)
    if self:WaterLevel() > 0 then
        util.Effect("WaterSurfaceExplosion", fx)
    else
        util.Effect("cod2019_grenade_explosion", fx)
		self:EmitSound("ArcCW_Kraken.Explosives.RocketImpact")
    end

    for i, e in pairs(ents.FindInSphere(self:GetPos(), 32)) do
        if (e:GetClass() == "npc_strider") then
            e:Fire("Explode")
        end
    end

    timer.Simple(0, function() self:Remove() end)
end
--PATH lua/entities/rw_sw_dispencer_ammobox/cl_init.lua:
include('shared.lua')

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/rw_sw_dispencer_ammobox/shared.lua:
return gluapack()()
--PATH lua/entities/rw_sw_dispencer_grenade/shared.lua:
return gluapack()()
--PATH lua/entities/sammyservers_textscreen/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "SammyServers Textscreen"
ENT.Author = "SammyServers"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:SetupDataTables()
	self:NetworkVar("Bool", 0, "IsPersisted")
end

local function textScreenCanTool(ply, trace, tool)
	-- only allow textscreen, remover, and permaprops tool
	if IsValid(trace.Entity) and trace.Entity:GetClass() == "sammyservers_textscreen" and tool ~= "textscreen" and tool ~= "remover" and tool ~= "permaprops" then
		return false
	end
end
hook.Add("CanTool", "3D2DTextScreensPreventTools", textScreenCanTool)
--PATH lua/entities/sent_streamradio/cl_init.lua:
return gluapack()()
--PATH lua/entities/shield_deployer.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "force_shield_deployer"
ENT.Author = "Trench"
ENT.Purpose = "deploys forceshield from it(Shoots out of players hand)"
ENT.shieldDeployAngleYaw = nil
ENT.deployed = false

PrecacheParticleSystem( "vortigaunt_glow_beam_cp1b" )
PrecacheParticleSystem( "vortigaunt_charge_token_c" )

--Deploys shield when the shield_deployer hits something, removes itself(with some effects on top)
function ENT:PhysicsCollide( data, phys )
    --This basically makes sure that split second double collisions dont result in it spawning multiple shields
    if(self.deployed == false) then
        ParticleEffect("vortigaunt_glow_beam_cp1b", self:GetPos(), self:GetAngles())
        self:Remove()
        if SERVER then 
            local shield = ents.Create("force_shield")
            shield:SetPos(self:GetPos())
            shield:SetAngles(Angle(0,self.shieldDeployAngleYaw - 90,0))
            shield:Spawn()
        end
    end
    self.deployed = true
end

if SERVER then
    function ENT:Initialize()
        self:SetModel( "models/Items/AR2_Grenade.mdl" )
        self:PhysicsInit( SOLID_VPHYSICS )
        self.phys = self:GetPhysicsObject()
        if(self.phys:IsValid())then self.phys:Wake() end --self:PhysWake() also works
        self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        --Effects on spawn below
        self:SetMaterial("models/props_combine/portalball001_sheet")
        ParticleEffectAttach( "vortigaunt_charge_token_c", PATTACH_ABSORIGIN_FOLLOW, self, 1)
        util.SpriteTrail( self, 0, Color(170,255,127), true, 40, 10, .05, .01, "trails/laser" )
    end
end    
--PATH gamemodes/starwarsrp/entities/entities/spawned_money/cl_init.lua:
return gluapack()()
--PATH lua/entities/tie_bomber.lua:
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "TIE Bomber"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Empire"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/tiebo/tiebo1.mdl"
ENT.Vehicle = "TieBomber"
ENT.StartHealth = 2500;
ENT.Allegiance = "Empire";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/tie_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("tie_bomber");
	e:SetPos(tr.HitPos + Vector(0,0,20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()


	self:SetNWInt("Health",self.StartHealth);
	
	self.WeaponLocations = {
		Blaster = self:GetPos()+self:GetForward()*130+self:GetUp()*85+self:GetRight()*-60,
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 2000;
	self.ForwardSpeed = 1000;
	self.UpSpeed = 500;
	self.AccelSpeed = 8;
	self.CanBack = true;
	self.CanRoll = true;
	
	self.Cooldown = 2;
	self.Overheat = 0;
	self.Overheated = false;
	
	self.CanShoot = true;
	self.ExitModifier = {x=0,y=140,z=40};
	
	self.Bullet = CreateBulletStructure(85,"green");

	
	self.BaseClass.Initialize(self);
end


function ENT:Think()

	if(self.Inflight) then
		if(IsValid(self.Pilot)) then
			if(self.Pilot:KeyDown(IN_ATTACK2)) then
				self:FireBlast(self:GetPos()+self:GetForward()*50+self:GetRight()*-20,true,0.4);	
			end
		end
	end
	self.BaseClass.Think(self);
end

end

if CLIENT then

	function ENT:Draw() self:DrawModel() end
	
	ENT.EnginePos = {}
	ENT.Sounds={
		//Engine=Sound("ambient/atmosphere/ambience_base.wav"),
		Engine=Sound("vehicles/tie/tie_fly3.wav"),
	}
	ENT.CanFPV = true;
	
	local Health = 0;
	function ENT:Think()
		self.BaseClass.Think(self);
		local p = LocalPlayer();
		local IsFlying = p:GetNWBool("Flying"..self.Vehicle);
		
		local IsDriver = p:GetNWEntity(self.Vehicle) == self.Entity;
		if(IsFlying and IsDriver) then
			Health = self:GetNWInt("Health");
		end		
	end

    ENT.ViewDistance = 700;
    ENT.ViewHeight = 300;
    ENT.FPVPos = Vector(120,-60,85);

	local HUD = surface.GetTextureID("vgui/tie_cockpit");
	function TieBomberReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingTieBomber");
		local self = p:GetNWEntity("TieBomber");
		
		if(Flying and IsValid(self)) then

			local FPV = self:GetFPV();
			if(FPV) then
				SW_HUD_FPV(HUD);
			end
			
			SW_HUD_DrawHull(2500);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			SW_BlastIcon(self);
			
			local x = ScrW()/4*0.6;
			local y = ScrH()/4*0.825;
			SW_HUD_Compass(self,x,y);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "TieBomberReticle", TieBomberReticle)

end
--PATH lua/entities/tie_fighter.lua:
return gluapack()()
--PATH lua/entities/turbolaser/shared.lua:
ENT.Type 		= "anim"
ENT.Base 		= "base_anim"
ENT.PrintName		= "Vanilla_Turbolaser"
ENT.Author		= "VanillaNekoNYAN"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.Force		= 1000
ENT.Damage		= 150
ENT.Magnitude		= 100

ENT.Phys		= nil
ENT.Once		= false

function ENT:SetupDataTables()

self:NetworkVar( "String", "3", "Colour" );

end

--PATH lua/entities/turbolaserspawner/shared.lua:
ENT.Type 		= "anim"
ENT.Base 		= "base_anim"
ENT.PrintName		= "Vanilla_Turbolaser_Spawner"
ENT.Author		= "VanillaNekoNYAN"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

--PATH lua/entities/tx130.lua:

ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "speeder_base"
ENT.Type = "vehicle"

ENT.PrintName = "TX-130"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Republic"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.Vehicle = "TX130";
ENT.EntModel = "models/tx130t/tx130t_hull1.mdl";
ENT.StartHealth = 2500;
list.Set("SWVehicles", ENT.PrintName, ENT);

if SERVER then

ENT.NextUse = {Use = CurTime(),Fire = CurTime()};
ENT.FireSound = Sound("weapons/xwing_shoot.wav");


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("tx130");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw+180,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self.BaseClass.Initialize(self);
	local driverPos = self:GetPos()+self:GetUp()*40+self:GetForward()*42;
	local driverAng = self:GetAngles()+Angle(0,90,0);
	local passPos = self:GetPos()+self:GetUp()*20+self:GetForward()*25+self:GetRight()*15
	self:SpawnChairs(driverPos,driverAng,false);
	
	self.ForwardSpeed = -300;
	self.BoostSpeed = -450
	self.AccelSpeed = 6;
	self.HoverMod = 0.5;
	self.SpeederClass = 2;
	self.NoWobble = true;
	self.WeaponLocations = {
		Left = self:GetPos()+self:GetUp()*30+self:GetRight()*46+self:GetForward()*-85,
		Right = self:GetPos()+self:GetUp()*30+self:GetRight()*-46+self:GetForward()*-85,
	}
	self.WeaponDir = self:GetAngles():Forward()*-1;
	self:SpawnWeapons();
	self.CannonLocation = self:GetPos()+self:GetUp()*60+self:GetForward()*-10;
	
	self.CanBack = true;
	self.StartHover = 30;
	
	self:SpawnTurretGuard();
	self:SpawnTurret();
	self:SpawnCannons();
	
	self.Bullet = CreateBulletStructure(150,"blue");
	
end

function ENT:SpawnTurret()
	
	local e = ents.Create("prop_physics");
	e:SetPos(self:GetPos()+self:GetUp()*60+self:GetForward()*25);
	e:SetAngles(self:GetAngles());
	e:SetModel("models/tx130t/tx130t_gun1.mdl");
	e:SetParent(self.TurretGuard);
	e:Spawn();
	e:Activate();
	e:GetPhysicsObject():EnableCollisions(false);
	e:GetPhysicsObject():EnableMotion(false);
	self.Turret = e;
	self:SetNWEntity("Turret",e);
	
end

function ENT:SpawnTurretGuard()
	
	local e = ents.Create("prop_physics");
	e:SetPos(self:GetPos()+self:GetUp()*55+self:GetForward()*40);
	e:SetAngles(self:GetAngles());
	e:SetModel("models/tx130t/tx130t_turret1.mdl");
	e:SetParent(self);
	e:Spawn();
	e:Activate();
	e:GetPhysicsObject():EnableCollisions(false);
	e:GetPhysicsObject():EnableMotion(false);
	self.TurretGuard = e;

end

function ENT:SpawnCannons()
	
	local e = ents.Create("prop_physics");
	e:SetModel("models/tx130t/tx130t_arms1.mdl");
	e:SetPos(self:GetPos()+self:GetUp()*30+self:GetForward()*40);
	e:SetAngles(self:GetAngles());
	e:SetParent(self);
	e:Spawn();
	e:Activate();
	e:GetPhysicsObject():EnableCollisions(false);
	e:GetPhysicsObject():EnableMotion(false);
	self.Cannon = e;
	self:SetNWEntity("Cannon",e);
	
end

local lastY = 0;
function ENT:Think()
	self.BaseClass.Think(self)
	if(self.Inflight) then
		if(IsValid(self.Pilot)) then
		

			self.Turret.LastAng = self.Turret:GetAngles();
			self.TurretGuard.LastAng = self.TurretGuard:GetAngles();
			self.Cannon.LastAng = self.Cannon:GetAngles();
		
			local aim = self.Pilot:GetAimVector():Angle();
			local p = aim.p*-1;
			if(p <= -0 and p >= -40) then
				p = -0;
			elseif(p >= -300 and p <= 280) then
				p = -300;
			end
			self.Turret:SetAngles(Angle(p,aim.y+180,0));
			//self.DriverChair:SetAngles(self.TurretGuard:GetAngles())
			self.TurretGuard:SetAngles(Angle(self:GetAngles().p,self.Turret:GetAngles().y,self:GetAngles().r));
			self.Cannon:SetAngles(Angle(p,self:GetAngles().y,self:GetAngles().r));
			if(self.Pilot:KeyDown(IN_ATTACK2)) then
				self:FireBlast(self.Turret:GetPos()+self.Turret:GetForward()*-40,true,-3,self.Turret:GetAngles():Forward());
			elseif(self.Pilot:KeyDown(IN_ATTACK)) then
				self:FireWeapons();
			end
			lastY = aim.y;
			self:NextThink(CurTime());
			return true;
		end
	end
	
end

function ENT:Exit(driver,kill)
	
	self.BaseClass.Exit(self,driver,kill);
	if(IsValid(self.Turret)) then
		self.Turret:SetAngles(self.Turret.LastAng);
	end
	if(IsValid(self.TurretGuard)) then
		self.TurretGuard:SetAngles(self.TurretGuard.LastAng);
	end
	if(IsValid(self.Cannon)) then
		self.Cannon:SetAngles(self.Cannon.LastAng);
	end
	
end


function ENT:FireWeapons()

	if(self.NextUse.Fire < CurTime()) then
		local e = self.Cannon;
		local WeaponPos = {
			e:GetPos()+e:GetRight()*45+e:GetForward()*-110,
			e:GetPos()+e:GetRight()*-45+e:GetForward()*-110,
		}
		for k,v in pairs(WeaponPos) do
			local tr = util.TraceLine({
				start = self:GetPos(),
				endpos = self:GetPos() + self.Cannon:GetForward()*-10000,
				filter = {self,self.Cannon,self.Turret,self.TurretGuard},
			})
		
			self.Bullet.Src		= v;
			self.Bullet.Attacker = self.Pilot or self;	
			self.Bullet.Dir = (tr.HitPos - v);

			self:FireBullets(self.Bullet)
		end
		self:EmitSound(self.FireSound, 120, math.random(90,110));
		self.NextUse.Fire = CurTime() + 0.8;
	end
end

local ZAxis = Vector(0,0,1);

function ENT:PhysicsSimulate( phys, deltatime )
	self.BackPos = self:GetPos()+self:GetForward()*100;
	self.FrontPos = self:GetPos()+self:GetForward()*-145;
	self.MiddlePos = self:GetPos();
	if(self.Inflight) then
		local UP = ZAxis;
		self.RightDir = self.Entity:GetForward():Cross(UP):GetNormalized();
		self.FWDDir = self.Entity:GetForward();

		if(IsValid(self.Pilot)) then
			if(self.Pilot:KeyDown(IN_JUMP)) then
				self.Right = -500;
			elseif(self.Pilot:KeyDown(IN_WALK)) then
				self.Right = 500;
			else
				self.Right = 0;
			end
		end
		self.Accel.RIGHT = math.Approach(self.Accel.RIGHT,self.Right,5);
		

		
		self:RunTraces();

		self.ExtraRoll = Angle(0,0,self.YawAccel / 4);
		if(!self.WaterTrace.Hit) then
			if(self.FrontTrace.HitPos.z >= self.BackTrace.HitPos.z) then
				self.PitchMod = Angle(math.Clamp((self.BackTrace.HitPos.z - self.FrontTrace.HitPos.z),-45,45)/3*-1,0,0)
			else
				self.PitchMod = Angle(math.Clamp(-(self.FrontTrace.HitPos.z - self.BackTrace.HitPos.z),-45,45)/3*-1,0,0)
			end
		end
	end

	self.BaseClass.PhysicsSimulate(self,phys,deltatime);
	

end

end

if CLIENT then
	ENT.Sounds={
		Engine=Sound("ambient/atmosphere/ambience_base.wav"),
	}
	ENT.HasCustomCalcView = true;
	local Health = 0;
	local Target;
	local Turret;
	local Cannon;
	function ENT:Think()
		self.BaseClass.Think(self);
		local p = LocalPlayer();
		local Flying = p:GetNWBool("Flying"..self.Vehicle);
		if(Flying) then
			Health = self:GetNWInt("Health");
			Target = self:GetNWVector("Target");
			Turret = self:GetNWEntity("Turret");
			Cannon = self:GetNWEntity("Cannon");
		end
		
	end

	local View = {}
	function CalcView()
		
		local p = LocalPlayer();
		local self = p:GetNWEntity("TX130", NULL)
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		local PassengerSeat = p:GetNWEntity("PassengerSeat",NULL);

		if(IsValid(self) and IsValid(Turret)) then

			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					local pos = Turret:GetPos()+Turret:GetForward()*270+Turret:GetUp()*50;
					//local face = self:GetAngles() + Angle(0,180,0);
					local face = ((self:GetPos() + Vector(0,0,100))- pos):Angle();
						View.origin = pos;
						View.angles = face;
					return View;
				end
			end
			
		end
	end
	hook.Add("CalcView", "TX130View", CalcView)

	
	hook.Add( "ShouldDrawLocalPlayer", "TX130DrawPlayerModel", function( p )
		local self = p:GetNWEntity("TX130", NULL);
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		local PassengerSeat = p:GetNWEntity("PassengerSeat",NULL);
		if(IsValid(self)) then
			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					return true;
				end
			elseif(IsValid(PassengerSeat)) then
				if(PassengerSeat:GetThirdPersonMode()) then
					return true;
				end
			end
		end
	end);
	
	function TX130Reticle()
	
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingTX130");
		local self = p:GetNWEntity("TX130");
		if(Flying and IsValid(self)) then
surface.SetDrawColor( color_white )	
			local TurretPos = Turret:GetPos()+Turret:GetForward()*-40;
			local tr = util.TraceLine({
				start = TurretPos,
				endpos = TurretPos + Turret:GetForward()*-10000,
				filter = {self,Turret},
			});
			
			local vpos = tr.HitPos;
			local screen = vpos:ToScreen();
			local x,y;
			for k,v in pairs(screen) do
				if(k == "x") then
					x = v;
				elseif(k == "y") then
					y = v;
				end
			end
			
			local w = ScrW()/100*2;
			local h = w;
			x = x - w/2;
			y = y - h/2;
			surface.SetMaterial( Material( "hud/missile_reticle.png", "noclamp" ) )
			surface.DrawTexturedRectUV( x , y, w, h, 0, 0, 1, 1 )
			
			local WeaponPos = {
				Cannon:GetPos()+Cannon:GetForward()*-105+Cannon:GetRight()*105+Cannon:GetUp()*5,
				Cannon:GetPos()+Cannon:GetForward()*-105+Cannon:GetRight()*-105+Cannon:GetUp()*5,
			}
			
		
			tr = util.TraceLine({
				start = self:GetPos(),
				endpos = self:GetPos() + Cannon:GetForward()*-10000,
				filter = {self,Cannon,Turret},
			})
			
			vpos = tr.HitPos;
			screen = vpos:ToScreen();
			x = 0;
			y = 0;
			for k,v in pairs(screen) do
				if(k == "x") then
					x = v;
				elseif(k == "y") then
					y = v;
				end
			end
			
			
			x = x - w/2;
			y = y - h/2;
			
			surface.SetMaterial( Material( "hud/reticle.png", "noclamp" ) )
			surface.DrawTexturedRectUV( x , y, w, h, 0, 0, 1, 1 )
	
			SW_Speeder_DrawHull(2500)
			SW_Speeder_DrawSpeedometer()
	
	

		end
	end
	hook.Add("HUDPaint", "TX130Reticle", TX130Reticle)
	
	
end
--PATH lua/entities/vox_e60r_rocket/shared.lua:
return gluapack()()
--PATH lua/effects/arc9_magdropeffect.lua:
EFFECT.Type = 1

EFFECT.Model = "models/food/hotdog.mdl"

EFFECT.AlreadyPlayedSound = false
EFFECT.LifeTime = 3
EFFECT.SpawnTime = 0


function EFFECT:Init(data)
    local att = data:GetAttachment()
    local ent = data:GetEntity()

    if !IsValid(ent) then self:Remove() return end
    if !IsValid(ent:GetOwner()) then self:Remove() return end

    if ent:GetOwner() != LocalPlayer() or LocalPlayer():ShouldDrawLocalPlayer() then
        mdl = (ent.WModel or {})[1] or ent
        self.VMContext = false
    else
        mdl = LocalPlayer():GetViewModel()

        if ent:ShouldTPIK() then
            self.VMContext = false
        else
            table.insert(ent.ActiveEffects, self)
        end
    end

    if !IsValid(ent) then self:Remove() return end
    if !mdl or !IsValid(mdl) then self:Remove() return end
    if !mdl:GetAttachment(att) then self:Remove() return end

    local origin, ang = mdl:GetAttachment(att).Pos, mdl:GetAttachment(att).Ang

    local model = ent:GetProcessedValue("DropMagazineModel", true)
    local skinn = ent:GetProcessedValue("DropMagazineSkin", true)
    local sounds = ent:GetProcessedValue("DropMagazineSounds", true)

    local dir = ang:Forward()

    local correctpos = ent:GetProcessedValue("DropMagazinePos", true) or vector_origin
    local correctang = ent:GetProcessedValue("DropMagazineAng", true) or angle_zero
    ang:RotateAroundAxis(ang:Forward(), correctang.p)
    ang:RotateAroundAxis(ang:Right(), 90 + correctang.y)
    ang:RotateAroundAxis(ang:Up(), 90 + correctang.r)

    origin:Add(ang:Right() * correctpos.x)
    origin:Add(ang:Up() * correctpos.y)
    origin:Add(ang:Forward() * correctpos.z)

    self:SetPos(origin)
    self:SetModel(model or "")
    self:SetSkin(skinn)
    self:DrawShadow(true)
    self:SetAngles(ang)

    if self.VMContext then
        self:SetNoDraw(true)
    end

    self.Sounds = sounds or ARC9.ShellSoundsTable

    -- self:SetSolid( SOLID_BBOX )
    -- self:SetMoveType( MOVETYPE_VPHYSICS )
    self:PhysicsInit(SOLID_VPHYSICS)
    -- local physbox = ent:GetProcessedValue("ShellPhysBox")

    -- local pb_z = physbox.z
    -- local pb_y = physbox.y
    -- local pb_x = physbox.x

    -- -- local mag = 150

    -- self:PhysicsInitBox(Vector(-pb_z,-pb_y,-pb_x), Vector(pb_z,pb_x,pb_y))

    -- self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)

    local phys = self:GetPhysicsObject()
    if !IsValid(phys) then self:Remove() return end
    phys:Wake()

    local plyvel = vector_origin

    if IsValid(ent.Owner) then
        plyvel = ent.Owner:GetAbsVelocity()
    end

    -- phys:SetDamping(0, 0)
    -- phys:SetMass(1)
    phys:SetMaterial("gmod_silent")
    -- phys:SetMaterial("default_silent")

    local velocity = ent:GetProcessedValue("DropMagazineVelocity", true) or Vector(0, 0, 0)

    -- phys:SetVelocity((dir * mag * velocity) + plyvel)
    dir:Add(ang:Right() * velocity.x)
    dir:Add(ang:Up() * velocity.y)
    dir:Add(ang:Forward() * velocity.z)

    phys:SetVelocity(dir + plyvel)

    phys:AddAngleVelocity(VectorRand() * 10)
    -- phys:AddAngleVelocity(ang:Up() * 2500 * velocity/0.75)

    self.SpawnTime = CurTime()
end

function EFFECT:PhysicsCollide()
    if self.AlreadyPlayedSound then return end
    local phys = self:GetPhysicsObject()
    self:StopSound("Default.ImpactHard")

    self.VMContext = false
    self:SetNoDraw(false)

    local snd = self.Sounds[math.random(#self.Sounds)]
    if snd then sound.Play(snd, self:GetPos(), 75, 100, 1) end

    self.AlreadyPlayedSound = true
end

function EFFECT:Think()
    if self:GetVelocity():Length() > 20 then self.SpawnTime = CurTime() end
    self:StopSound("Default.ScrapeRough")
    
    if (self.SpawnTime + self.LifeTime) <= CurTime() then
        if !IsValid(self) then return end
        self:SetRenderFX( kRenderFxFadeFast )
        if (self.SpawnTime + self.LifeTime + 0.25) <= CurTime() then
            if !IsValid(self:GetPhysicsObject()) then return end
            self:GetPhysicsObject():EnableMotion(false)
            if (self.SpawnTime + self.LifeTime + 0.5) <= CurTime() then
                self:Remove()
                return
            end
        end
    end
    return true
end

function EFFECT:Render()
    if !IsValid(self) then return end
    self:DrawModel()
end

function EFFECT:DrawTranslucent()
    self:DrawModel()
end

--PATH lua/effects/arc9_muzzleeffect.lua:
EFFECT.Weapon = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

function EFFECT:Init(data)
    local wpn = data:GetEntity()

    self.Weapon = wpn

    if !IsValid(wpn) then self:Remove() return end

    if !otherconvar:GetBool() and LocalPlayer() != wpn:GetOwner() then
        self:Remove()
        return
    end

    local muzzle = wpn:GetProcessedValue("MuzzleParticle", true)

    local att = data:GetAttachment() or 1

    local vm = LocalPlayer():GetViewModel()

    local wm = false

    if (LocalPlayer():ShouldDrawLocalPlayer() or wpn.Owner != LocalPlayer()) then
        wm = true
        if !wpn:ShouldTPIK() then att = 1 end
    end

    local parent = wpn

    if !wm then
        parent = vm
    else
        parent = (wpn.WModel or {})[1] or wpn
    end

    local muz = wpn:GetMuzzleDevice(wm, data:GetSurfaceProp())

    if !IsValid(muz) then
        muz = wpn
    end

    if !IsValid(muz) then
        self:Remove()
        return
    end

    local pa = muz:GetAttachment(att)
    local pos = pa and pa.Pos or muz:GetPos()

    -- if !IsValid(parent) then return end

    -- if muzzle then
    --     ParticleEffectAttach(muzzle, PATTACH_POINT_FOLLOW, muz or parent, att)
    -- end

    if muzzle then
        if !istable(muzzle) then
            muzzle = {muzzle}
        end

        for _, muzzleeffect in ipairs(muzzle) do
            local pcf = CreateParticleSystem(muz or parent, muzzleeffect, PATTACH_POINT_FOLLOW, att)

            if IsValid(pcf) then
                pcf:StartEmission()

                if (muz or parent) != vm and !wm then
                    pcf:SetShouldDraw(false)
                    table.insert(wpn.MuzzPCFs, pcf)
                end
            end
        end
    end

    if !wpn:GetProcessedValue("Silencer", true) and !wpn:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
        local light = DynamicLight(self:EntIndex())
        local clr = Color(244, 209, 66)
        if (light) then
            light.Pos = pos
            light.r = clr.r
            light.g = clr.g
            light.b = clr.b
            light.Brightness = 2
            light.Decay = 2500
            light.Size = wpn:GetOwner() == LocalPlayer() and 256 or 128
            light.DieTime = CurTime() + 0.1
        end
    end

    if ARC9.Dev(2) then debugoverlay.Sphere(pos, 2, 1, Color(255, 255, 255, 1)) end
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    return false
end
--PATH lua/effects/arccw_ricochet.lua:
return gluapack()()
--PATH lua/effects/arccw_tracer.lua:
EFFECT.StartPos = Vector(0, 0, 0)
EFFECT.EndPos = Vector(0, 0, 0)
EFFECT.StartTime = 0
EFFECT.LifeTime = 0.2
EFFECT.LifeTime2 = 0.2
EFFECT.DieTime = 0
EFFECT.Color = Color(255, 255, 255)
EFFECT.Speed = 15000

local head = Material("effects/whiteflare")
local tracer = Material("arccw/tracer")
local smoke = Material("trails/smoke")

function EFFECT:Init(data)

    local hit = data:GetOrigin()
    local wep = data:GetEntity()

    if !IsValid(wep) then return end

    local speed = data:GetScale()
    local start = (wep.GetTracerOrigin and wep:GetTracerOrigin()) or data:GetStart()

    if ArcCW.ConVars["fasttracers"]:GetBool() then
            local fx = EffectData()
            fx:SetOrigin(hit)
            fx:SetEntity(wep)
            fx:SetStart(start)
            fx:SetScale(4000)
            util.Effect("tracer", fx)
            self:Remove()
        return -- was it ever really necessary? yes, to not use the dog-shit tracers that used to ship with this
    end

    local diff = hit - start

    if speed > 0 then
        self.Speed = speed
    end

    local profile = 0
    if wep.GetBuff_Override then
        profile = wep:GetBuff_Override("Override_PhysTracerProfile", wep.PhysTracerProfile) or 0
        if isnumber(profile) then profile = ArcCW.BulletProfileDict[ArcCW.BulletProfiles[profile]] end
    end

    self.LifeTime = (hit - start):Length() / self.Speed

    self.StartTime = UnPredictedCurTime()
    self.DieTime = UnPredictedCurTime() + math.max(self.LifeTime, self.LifeTime2)
    self.Dir = diff:GetNormalized()

    self.StartPos = start
    self.EndPos = hit
    self.Color = (ArcCW.BulletProfileDict[profile] or ArcCW.BulletProfileDict["default0"]).color
end

function EFFECT:Think()
    return self.DieTime > UnPredictedCurTime()
end

local function LerpColor(d, col1, col2)
    local r = Lerp(d, col1.r, col2.r)
    local g = Lerp(d, col1.g, col2.g)
    local b = Lerp(d, col1.b, col2.b)
    local a = Lerp(d, col1.a, col2.a)
    return Color(r, g, b, a)
end

function EFFECT:Render()
    local d = (UnPredictedCurTime() - self.StartTime) / self.LifeTime
    local d2 = (UnPredictedCurTime() - self.StartTime) / self.LifeTime2
    local startpos = self.StartPos + (d * 0.1 * (self.EndPos - self.StartPos))
    local endpos = self.StartPos + (d * (self.EndPos - self.StartPos))
    local size = math.Clamp(math.log(EyePos():DistToSqr(endpos) - math.pow(256, 2)), 0, math.huge)

    local col = self.Color --LerpColor(d, self.Color, Color(0, 0, 0, 0))
    local col2 = LerpColor(d2, Color(155, 155, 155, 155), Color(0, 0, 0, 0))

    local vel = self.Dir * self.Speed - LocalPlayer():GetVelocity()
    local dot = math.abs(EyeAngles():Forward():Dot(vel:GetNormalized()))
    --dot = math.Clamp(((dot * dot) - 0.25) * 5, 0, 1)
    local headsize = size * dot * 2
    render.SetMaterial(head)
    render.DrawSprite(endpos, headsize, headsize, col)

    local tail = (self.Dir * math.min(self.Speed / 25, 512, (endpos - startpos):Length() - 64))
    render.SetMaterial(tracer)
    render.DrawBeam(endpos, endpos - tail, size * 0.75, 0, 1, col)

    render.SetMaterial(smoke)
    render.DrawBeam( endpos - tail, startpos, size * d2, 0, 1, col2)
end

--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/astra_beam.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.ParticleCast = false
EFFECT.Time = nil

EFFECT.Speed = 12000
function EFFECT:Think()

	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"astra_beam", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = lightorigin
		mLight.r = 130
		mLight.g = 120
		mLight.b = 255
		mLight.brightness = 3 * Fraction
		mLight.Size = 180 + 200 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end
	
	return ( self.Time > CurTime() ) 
	
end

--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/astw2_muzzleflash_swrc_green/init.lua:
local AddVel = Vector()

function EFFECT:Init(data)
    local quality = GetConVar("astw2_quality"):GetInt()
    if GetConVar("astw2_force_effect_minlevel_1"):GetBool() and quality == 0 then
        quality = 1
    end

    if quality == 0 then return end

    self.WeaponEnt = data:GetEntity()
    if !IsValid(self.WeaponEnt) then return end
    self.Owner = self.WeaponEnt:GetOwner()
    if !IsValid(self.Owner) then return end
    local dir = data:GetNormal()
    local scale = self.WeaponEnt.Primary.Damage * self.WeaponEnt.Primary.Num
    scale = scale * 0.025

    self.vOffset = self.WeaponEnt:GetBorePos()

    AddVel = self.WeaponEnt.Owner:GetVelocity()

    local emitter = ParticleEmitter(self.vOffset)

    if !self.WeaponEnt.Suppressed then
        local particle = emitter:Add("effects/swrc/a_flashgreen", self.vOffset)

        if (particle) then
            particle:SetVelocity(AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(0.07 ,0.1))
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(155)
            particle:SetStartSize(math.Rand(5, 10))
            particle:SetEndSize(scale * math.Rand(40, 60))
            particle:SetLighting(false)
            particle:SetRoll(math.random(0, 0))
            particle:SetColor(255, 255, 255)
        end
    end

    local particlecount = quality * 2


    if quality >= 3 then
        local particle = emitter:Add("sprites/heatwave", self.vOffset)

        if (particle) then
            particle:SetVelocity((dir * 25) + 1.05 * AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(0.1)
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(80, 100))
            particle:SetEndSize(0)
            particle:SetRoll(math.Rand(0, 360))
            particle:SetRollDelta(math.Rand(-2, 2))
            particle:SetAirResistance(5)
            particle:SetGravity(Vector(0, 0, 40))
            particle:SetColor(255, 255, 255)
        end
    end

    emitter:Finish()
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/astw2_muzzleflash_swrc_tran_shotgun/init.lua:
local AddVel = Vector()

function EFFECT:Init(data)
    local quality = GetConVar("astw2_quality"):GetInt()
    if GetConVar("astw2_force_effect_minlevel_1"):GetBool() and quality == 0 then
        quality = 1
    end

    if quality == 0 then return end

    self.WeaponEnt = data:GetEntity()
    if !IsValid(self.WeaponEnt) then return end
    self.Owner = self.WeaponEnt:GetOwner()
    if !IsValid(self.Owner) then return end
    local dir = data:GetNormal()
    local scale = self.WeaponEnt.Primary.Damage
    scale = scale * 0.07

    self.vOffset = self.WeaponEnt:GetBorePos()

    AddVel = self.WeaponEnt.Owner:GetVelocity()

    local emitter = ParticleEmitter(self.vOffset)

    if !self.WeaponEnt.Suppressed then
        local particle = emitter:Add("effects/swrc/p_shockwave", self.vOffset)

        if (particle) then
            particle:SetVelocity(AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(0.07 ,0.1))
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(155)
            particle:SetStartSize(math.Rand(5, 10))
            particle:SetEndSize(scale * math.Rand(40, 60))
            particle:SetLighting(false)
            particle:SetRoll(math.random(0, 0))
            particle:SetColor(200, 255, 155)
        end
	        local particle2 = emitter:Add("effects/swrc/shotgun_frontal", self.vOffset)

        if (particle2) then
            particle2:SetVelocity(AddVel)
            particle2:SetLifeTime(0)
            particle2:SetDieTime(math.Rand(0.07 ,0.1))
            particle2:SetStartAlpha(255)
            particle2:SetEndAlpha(155)
            particle2:SetStartSize(math.Rand(5, 10))
            particle2:SetEndSize(scale * math.Rand(40, 60))
            particle2:SetLighting(false)
            particle2:SetRoll(math.random(0, 0))
            particle2:SetColor(255, 255, 255)
        end
	        local particle3 = emitter:Add("effects/swrc/radial_sparks", self.vOffset)

        if (particle3) then
            particle3:SetVelocity(AddVel)
            particle3:SetLifeTime(0)
            particle3:SetDieTime(math.Rand(0.07 ,0.1))
            particle3:SetStartAlpha(255)
            particle3:SetEndAlpha(155)
            particle3:SetStartSize(math.Rand(5, 10))
            particle3:SetEndSize(scale * math.Rand(40, 60))
            particle3:SetLighting(false)
            particle3:SetRoll(math.random(0, 0))
            particle3:SetColor(255, 255, 200)
        end
    end

    local particlecount = quality * 2


    if quality >= 3 then
        local particle = emitter:Add("sprites/heatwave", self.vOffset)

        if (particle) then
            particle:SetVelocity((dir * 25) + 1.05 * AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(0.1)
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(80, 100))
            particle:SetEndSize(0)
            particle:SetRoll(math.Rand(0, 360))
            particle:SetRollDelta(math.Rand(-2, 2))
            particle:SetAirResistance(5)
            particle:SetGravity(Vector(0, 0, 40))
            particle:SetColor(255, 255, 255)
        end
    end

    emitter:Finish()
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/astw2_swrc_dc17aa_explosion/init.lua:
return gluapack()()
--PATH lua/effects/astw2_swrc_explosion_flash_grenade/init.lua:
return gluapack()()
--PATH lua/effects/atrt_flamethrower_flame/init.lua:
return gluapack()()
--PATH lua/effects/blue_tracer.lua:
return gluapack()()
--PATH lua/effects/ca3_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()

	util.ParticleTracerEx( 
		"ngen_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH lua/effects/cod2019_muzzle_db/init.lua:
function EFFECT:Init(data, weapon, dmgInfo, tr)
    local pos = data:GetOrigin()
    local ang = data:GetAngles()
    ParticleEffect("muzzleflash_slug", pos, ang, nil)
    sound.Play("COD2019.DB_Hit", pos, SNDLVL_75dB, 100, 0.1)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/cod2019_tracer_custom.lua:
return gluapack()()
--PATH lua/effects/cod2019_tracer_custom.lua:
EFFECT.StartPos = Vector(0, 0, 0)
EFFECT.EndPos = Vector(0, 0, 0)
EFFECT.StartTime = 0
EFFECT.LifeTime = 0.2
EFFECT.LifeTime2 = 0.2
EFFECT.DieTime = 0
EFFECT.Color = Color(255, 255, 255)
EFFECT.Speed = 22000

EFFECT.Size = 1

--local head = Material("effects/ar2_altfire1b")
local head = Material("effects/whiteflare")
local tracer = Material("effects/spark")
local smoke = Material("trails/smoke")

function EFFECT:Init(data)

    local hit = data:GetOrigin()
    local wep = data:GetEntity()

    if !IsValid(wep) then return end
    if !wep.ARC9 then return end

    local speed = data:GetScale()
    local start = (wep.GetTracerOrigin and wep:GetTracerOrigin()) or data:GetStart()

    if speed > 0 then
        self.Speed = speed
    end

    self.LifeTime = (hit - start):Length() / self.Speed

    self.StartTime = UnPredictedCurTime()
    self.DieTime = UnPredictedCurTime() + math.max(self.LifeTime, self.LifeTime2)

    self.StartPos = start
    self.EndPos = hit

    -- Sometimes it freaks out and, I dunno, gets invalid
    if wep.GetProcessedValue then
        self.Color = wep:GetProcessedValue("TracerColor")
        self.Size = wep:GetProcessedValue("TracerSize")
        self.Speed = wep:GetProcessedValue("TracerSpeed")
    end
end

function EFFECT:Think()
    return self.DieTime > UnPredictedCurTime()
end

local function LerpColor(d, col1, col2)
    local r = Lerp(d, col1.r, col2.r)
    local g = Lerp(d, col1.g, col2.g)
    local b = Lerp(d, col1.b, col2.b)
    local a = Lerp(d, col1.a, col2.a)
    return Color(r, g, b, a)
end

function EFFECT:Render()
    local d = (UnPredictedCurTime() - self.StartTime) / self.LifeTime
    local d2 = (UnPredictedCurTime() - self.StartTime) / self.LifeTime2
    local startpos = self.StartPos + (d * 0.1 * (self.EndPos - self.StartPos))
    local endpos = self.StartPos + (d * (self.EndPos - self.StartPos))
    local size = self.Size

    local col = LerpColor(d, self.Color, Color(0, 0, 0, 0))
    local col2 = LerpColor(d2, self.Color, Color(0, 0, 0, 0))
	local col3 = LerpColor(d2, Color(255, 255, 255, 255), Color(0, 0, 0, 0))

    render.SetMaterial(head)
    render.DrawSprite(endpos, size * 3, size * 3, col)

    render.SetMaterial(tracer)
    render.DrawBeam(endpos, startpos, size, 1, 0, col)

    render.SetMaterial(smoke)
    render.DrawBeam(self.EndPos, endpos, size * d2, 1, 0, col)
end

--PATH lua/effects/cod2019_tracer_inc/init.lua:
return gluapack()()
--PATH lua/effects/cryon_frozen.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_autoshotgun/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_magnum/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_para_negev/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_para_FP"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_taser_tracer/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.InValid = false

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	-- Keep the start and end pos - we're going to interpolate between them
	self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	util.ParticleTracerEx("weapon_tracers_taser", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
	if self.InValid then return false end
end
--PATH lua/effects/dark_succumb.lua:
return gluapack()()
--PATH lua/effects/effect_astw2_swrc_laser_red/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_blue_akimbo_pu/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_green/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_green_main" )
local MaterialFront			= Material( "effects/sw_laser_green_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 204
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/effect_sw_laser_purple/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_purple_main" );
local MaterialFront			= Material( "effects/sw_laser_purple_front" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 102
			dlight.g = 0
			dlight.b = 204
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/effect_sw_laser_red/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_red_main" )
local MaterialFront			= Material( "effects/sw_laser_red_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/effect_sw_laser_red_old/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_red_sniper/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 8000
EFFECT.Length				= 600
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 250

local MaterialMain			= Material( "effects/sw_laser_red_main" )
local MaterialFront			= Material( "effects/sw_laser_red_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/eml_tracer_cryo.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_groundslam.lua:

local function GetRandomPositionInBox( mins, maxs, ang )
	return ang:Up() * math.random( mins.z, maxs.z ) + ang:Right() * math.random( mins.y, maxs.y ) + ang:Forward() * math.random( mins.x, maxs.x )
end

local function GenerateLighting( from, to, deviations, power )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local segments = {
		{ start, endpos }
	}
	for i = 0, power do
		local newsegs = {}
		for id, seg in pairs( segments ) do
			local mid = Vector( (seg[1].x + seg[2].x) / 2, (seg[1].y + seg[2].y) / 2, (seg[1].z + seg[2].z) / 2 )
			local offsetpos = mid + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
			table.insert( newsegs, {seg[1], offsetpos} )
			table.insert( newsegs, {offsetpos, seg[2]} )
		end
		segments = newsegs
	end
	return segments
end

local function GenerateLightingSegs( from, to, deviations, segs )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to--:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos-- + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local fwd = (start - endpos):Angle():Forward()
	local step = (1 / segs) * start:Distance( endpos )

	local lastpos = start
	local segments = {}
	for i = 1, segs do
		local a = lastpos - fwd * step
		table.insert( segments, { lastpos, a } )
		lastpos = a
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		segments[ k ][ 1 ] = segments[ k ][ 1 ] + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
		segments[ k - 1 ][ 2 ] = segments[ k ][ 1 ]
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		if ( math.random( 0, 100 ) > 75 ) then
			local dir = AngleRand():Forward()
			table.insert( segments, { segments[ k ][ 1 ], segments[ k ][ 1 ] + dir * ( step * math.Rand( 0.2, 0.6 ) ) } )
		end
	end

	return segments
end

local mats = {
	(Material( "cable/xbeam" )),
	/*(Material( "cable/hydra" )),
	(Material( "cable/redlaser" )),
	(Material( "cable/crystal_beam1" )),
	(Material( "cable/physbeam" )),
	(Material( "cable/smoke" )),
	(Material( "cable/xbeam" )),*/
}

local segments = {}
--local n = 0
local tiemc = 2.2
hook.Add( "PostDrawTranslucentRenderables", "GroundSlamRender", function()
	--if ( #segments < 1 || n < CurTime() ) then
		--
		/*for i = 0, 1 do
			table.insert( segments, {
				segs = GenerateLighting( table.Random( ents.FindByClass( "prop_physics" ) ), table.Random( ents.FindByClass( "prop_physics" ) ), math.random( 10, 20 ), 3 ),
				mat = table.Random( mats ),
				time = CurTime() + tiemc,
				w = math.random( 20, 50 )
			} )
		end*/
		--n = CurTime() + .01
	--end

	for id, t in pairs( segments ) do
		if ( t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], ( math.max( t.startpos:Distance( t.endpos ) - seg[1]:Distance( t.endpos ), 20) / ( t.startpos:Distance( t.endpos ) ) * t.w ) * ( (t.time - CurTime() ) / tiemc ), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
			--render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiemc), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end
end )


function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local pos2 = data:GetStart()


	table.insert( segments, {
		--segs = GenerateLighting( pos, ent, math.random( 10, 20 ), 3 ),
		segs = GenerateLightingSegs( pos, pos2, math.random( 10, 20 ), pos:Distance( pos2 ) / 48 ), --math.random( 5, 10 ) ),
		mat = table.Random( mats ),
		time = CurTime() + tiemc,
		w = math.random( 20, 50 ),
		startpos = pos,
		endpos = pos2 --ent:GetPos()
	} )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
	for id, t in pairs( segments ) do
		if (t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiemc), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_judgement.lua:

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid( self.Ent ) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625
		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

local BeamMat = Material( "trails/electric" )
local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	if IsValid( self.Ent ) then

		local boneID = self.Ent:LookupBone( "ValveBiped.Bip01_L_Hand" )

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos
	
				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 255
					dlight.g = 162
					dlight.b = 0
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end


			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(200,600)

			local trace = util.TraceLine( { start = StartPos, endpos = EndPos, filter = self.Ent} )

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
						effectdata:SetNormal( -trace.HitNormal )
					util.Effect( "force_judgement_hit", effectdata )

					if math.random(1,3) == 3 then

						local dlight = DynamicLight( self.Ent:EntIndex() + math.random(100,9999) )
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 255
							dlight.g = 162
							dlight.b = 0
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end

						self:EmitSound("lscs/force/lightninghit"..math.random(1,3)..".mp3")
					end
				end
			end

			render.SetMaterial( mat )
			render.DrawSprite( StartPos, 64, 64, Color( 255, 162, 0) ) --Elden Cikan Yes
			render.DrawSprite( StartPos, 16, 16, Color( 255, 162, 0, 255) ) --Bilmiyorum

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial( BeamMat )

			render.DrawBeam( BeamStart, BeamEnd, 18, 0, 1, Color( 255, 162, 0) ) --Az Elektrik

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 255, 162 + 150 * Width, 0, 255 ) ) --Etraftaki Cok Fazla Elektrik

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 255, 162, 0, 255 ) ) --Aradakilerin yarisi 
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 255, 162, 0) ) --Kalanlar

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_judgementii_hit.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_push.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/hmp_concussion_trail.lua:
return gluapack()()
--PATH lua/effects/hwave_dissolve.lua:
local mat_dark = Material( "models/elemental/burned" )
local mat_glow = Material( "models/elemental/burned_glow" )

local cmd_sunbeams = GetConVar( "sfw_fx_individualsunbeams" )

EFFECT.Origin = Vector( 0, 0, 0 )
EFFECT.Edge = Vector( 0, 0, 0 )
EFFECT.Direction = false
EFFECT.DirectionSet = false

function EFFECT:Init( data )

	self.Time = 1.46
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.ParentEntity = ent
	
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	self.Normal = data:GetNormal()
	self.Flags = data:GetFlags()

	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self
	
	self.Origin = data:GetOrigin() || self:GetPos()

end

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end
	
	local PPos = self.ParentEntity:GetPos()
	self:SetPos( PPos + (EyePos() - PPos):GetNormal() )
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil
			
	return false
	
end

function EFFECT:Render()

	if ( self.Flags == 8 ) then
		self:RenderOverlay( self.ParentEntity )
	end

end

function EFFECT:RenderOverlay( entity )
		
	local Fraction = ( self.LifeTime - CurTime() ) / self.Time
	local ColFrac = ( Fraction - 0.5 ) * 2
	
	Fraction = math.Clamp( Fraction, 0, 1 )
	ColFrac =  math.Clamp( ColFrac, 0, 1 )

	local EyeNormal = entity:GetPos() - EyePos()
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local Pos = EyePos() + EyeNormal * Distance * 0.01
	local bClipping = self:StartClip( entity, 1 )
	
	cam.Start3D( Pos, EyeAngles() )
		render.MaterialOverride( mat_dark )
		entity:DrawModel()
		render.MaterialOverride( 0 )
	cam.End3D()

	render.PopCustomClipPlane()
	render.EnableClipping( bClipping )
	
	local bSunBeams = cmd_sunbeams:GetBool()
	if ( !bSunBeams ) then return end 
	
	local screen = Pos
	local vNormal = screen - EyePos()
	
	local dot = ( vNormal:Dot( EyeVector() ) - 0.8 ) * 5
	if ( dot <= 0 ) then return end

	screen = screen + ( vNormal * 16384 )
	screen = screen:ToScreen()
	
	local w, h = ScrW(), ScrH()

	local glowX, glowY = screen.x, screen.y
	DrawSunbeams( 0.7, 0.1 * ( 1 - Fraction ), 0.1 * Fraction, glowX / w, glowY / h )


end


function EFFECT:RenderParent()

	local bClipping = self.SpawnEffect:StartClip( self, 0.86 )
	
	render.SetColorModulation( 12, 2, 1.6 )
	render.MaterialOverride( mat_glow )
	
	self:DrawModel()
	
	render.SetColorModulation( 0.6, 0.56, 0.52 )
	
	render.PopCustomClipPlane()
	render.EnableClipping( bClipping )
	
	self.SpawnEffect:RenderOverlay( self )

end

function EFFECT:StartClip( model, spd )

	local mn, mx = model:GetRenderBounds()
	local me = model:EyePos()
	local mc = model:OBBCenter()

	local Top, Bottom, Up
	
	if ( !self.DirectionSet ) then
		self.Direction = ( self.Origin:Dot( mc ) > 0 )
		self.DirectionSet = true
	end
	
	if ( self.Direction ) then
		Top = me + mn
		Bottom = me + mx
		Up = (mx-mn):GetNormal()
	else
		Top = me + mx
		Bottom = me + mn
		Up = (mn-mx):GetNormal()
	end

	local Fraction = ( self.LifeTime - CurTime() ) / self.Time
	Fraction = math.Clamp( Fraction / spd, 0, 1 )
	
	local Lerped = LerpVector( Fraction, Bottom, Top )
	
	local normal = ( Bottom - Top ):GetNormal()
	local distance = normal:Dot( Lerped )
	local bEnabled = render.EnableClipping( true )
	render.PushCustomClipPlane( normal, distance ) 
	
	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = Lerped
		mLight.r = 255
		mLight.g = 90
		mLight.b = 10
		mLight.brightness = ( 1 - Fraction ) + 2 * Fraction
		mLight.Size = 200 + 320 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end

	return bEnabled
	
end

--PATH lua/effects/lfs_fb_detonator_explosion.lua:
function EFFECT:Init(data)
	self.Pos = data:GetOrigin()
	local Emitter = ParticleEmitter(self.Pos)
	if Emitter == nil then return end
	
	-- Fire
	for _ = 1, 3 do
		local EffectCode = Emitter:Add("particles/flamelet1",self.Pos)
            EffectCode:SetVelocity(Vector(math.random(-30,30),math.random(-30,30),math.random(30,40)))
            EffectCode:SetDieTime(math.Rand(0.4,0.6)) -- How much time until it dies
            EffectCode:SetStartAlpha(math.Rand(90,100)) -- Transparency
            EffectCode:SetStartSize(math.Rand(60,80)) -- Size of the effect
            EffectCode:SetEndSize(math.Rand(100,100)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
            EffectCode:SetRoll(math.Rand(480,540))
            EffectCode:SetRollDelta(math.Rand(0,0)) -- How fast it rolls
            EffectCode:SetColor(255,255,255) -- The color of the effect
            EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
	end

	-- Smoke screen
	for _ = 1, 5 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
            EffectCode:SetVelocity(Vector(math.random(-40,40),math.random(-40,40),math.random(5,15)))
            EffectCode:SetDieTime(math.Rand(7,9)) -- How much time until it dies
            EffectCode:SetStartAlpha(math.Rand(200,230)) -- Transparency
            EffectCode:SetStartSize(math.Rand(80,100)) -- Size of the effect
            EffectCode:SetEndSize(math.Rand(130,150)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
            EffectCode:SetRoll(math.Rand(480,540))
            EffectCode:SetRollDelta(math.Rand(-0.2,0.2)) -- How fast it rolls
            EffectCode:SetColor(50,50,50) -- The color of the effect
            EffectCode:SetGravity(Vector(0, 0, 0)) -- The Gravity
            EffectCode:SetAirResistance(15)
	end

	-- Cloud of smoke that goes up
	for _ = 1, 5 do
		local EffectCode = Emitter:Add("particles/smokey",self.Pos)
            EffectCode:SetVelocity(Vector(math.random(-60,70),math.random(-60,70),math.random(70,100)))
            EffectCode:SetDieTime(math.Rand(3,4)) -- How much time until it dies
            EffectCode:SetStartAlpha(math.Rand(150,190)) -- Transparency
            EffectCode:SetStartSize(math.Rand(80,100)) -- Size of the effect
            EffectCode:SetEndSize(math.Rand(130,150)) -- Size of the effect at the end (The effect slowly trasnsforms to this size)
            EffectCode:SetRoll(math.Rand(480,540))
            EffectCode:SetRollDelta(math.Rand(-1,1)) -- How fast it rolls
            EffectCode:SetColor(50,50,50) -- The color of the effect
            EffectCode:SetGravity(Vector(0,0,math.random(-30,-10))) -- The Gravity
	end
    
	Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/lvs_engine_blacksmoke.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin() + VectorRand() * 25
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )
	
	if particle then
		particle:SetVelocity( VectorRand() * 100 )
		particle:SetDieTime( 2 )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 60 )
		particle:SetEndSize( 200 )
		particle:SetRoll( math.Rand(-1,1) * math.pi )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( 60, 60, 60 )
		particle:SetGravity( Vector( 0, 0, 600 ) )
		particle:SetCollide( false )
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_explosion_nodebris.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()

	self:Explosion( Pos, 2 )

	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		timer.Simple( delay, function()
			sound.Play( "LVS.EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.EXPLOSION", Pos )
	end

	for i = 1, 20 do
		timer.Simple(math.Rand(0,0.01) * i, function()
			if not IsValid( self ) then return end

			local p = Pos + VectorRand() * 10 * i
			
			self:Explosion( p, math.Rand(0.5,0.8) )
		end)
	end
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,10 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 1000 * scale )
		particle:SetDieTime( math.Rand(0.75,1.5) * scale )
		particle:SetAirResistance( math.Rand(200,600) ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( math.Rand(60,120) * scale )
		particle:SetEndSize( math.Rand(160,280) * scale )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 40,40,40 )
		particle:SetGravity( Vector( 0, 0, 100 ) )
		particle:SetCollide( false )
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 1000 * scale )
		particle:SetDieTime( 0.14 )
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 * scale )
		particle:SetEndSize( math.Rand(60,120) * scale )
		particle:SetEndAlpha( 100 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( 200,150,150 )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_explosion_small.lua:
return gluapack()()
--PATH lua/effects/lvs_hsd_dish_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment( "muzzle_primary" )

		if self.ID then
			local Muzzle = self.Entity:GetAttachment( self.ID )

			self:SetRenderBoundsWS( self.Entity:GetPos(), -Muzzle.Ang:Right() * 50000 )
		end
	end

	self.SpawnTime = CurTime()
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.ID or not self.Entity:GetProjectorBeam() then
		return false
	end

	return true
end

function EFFECT:Render()
	if not self.ID or not IsValid( self.Entity ) then return end

	local T = CurTime()

	local Mul = math.min( math.max( 1.5 - (T - self.SpawnTime), 0 ) ^ 2, 1 )

	local Muzzle = self.Entity:GetAttachment( self.ID )

	local Dir = -Muzzle.Ang:Right()
	local StartPos = Muzzle.Pos
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos

	self:SetRenderBoundsWS( StartPos, EndPos )

	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, (16 + math.random(0,3)) * Mul, 1, 0, Color(255,0,0,255) )
	render.DrawBeam( StartPos, EndPos, (4 + math.random(0,2)) * Mul, 1, 0, Color(255,255,255,255) )

	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A * Mul, A * Mul, Color(255,0,0,255) )
	render.DrawSprite( StartPos, B * Mul, B * Mul, Color(255,255,255,255) )

	render.DrawSprite( EndPos, A, A, Color(255,0,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

	if (self._Next or 0) > T then return end

	self._Next = T + 0.02

	local emitter = ParticleEmitter( EndPos, false )

	if not emitter or not IsValid( emitter ) then return end

	local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
	
	for i = 0, 3 do
		local particle = emitter:Add( "sprites/light_glow02_add", EndPos )

		local vel = VectorRand() * 250 + Trace.HitNormal

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(12,24) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 255, 0, 0 )
		particle:SetGravity( Vector(0,0,-600) )

		particle:SetAirResistance( 0 )

		particle:SetCollide( true )
		particle:SetBounce( 1 )
	end

	local Dist = (StartPos - EndPos):Length()

	local invMul = (1 - Mul)

	for i = 0, Dist, 25 do
		local Pos = StartPos + Dir * i

		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand()  * 150
		
		if not particle then continue end

		particle:SetVelocity( vel + vel * invMul )
		particle:SetDieTime( 0.1 + 0.15 * invMul )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand( 1, 5 ) + invMul * 2 )
		particle:SetEndSize( 0 )
		particle:SetColor( 50 + 205 * Mul, 0, 0 )
		particle:SetAirResistance( 0 )
		particle:SetRoll( math.Rand(-10,10) )
		particle:SetRollDelta( math.Rand(-10,10) )
		particle:SetGravity( Vector(0,0,-600 * invMul) )

		particle:SetAirResistance( 0 )
	end

	emitter:Finish()
end

--PATH lua/effects/lvs_laat_right_projector.lua:
return gluapack()()
--PATH lua/effects/lvs_laser_red_aat.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )
EFFECT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )

	local emitter = ParticleEmitter( pos, false )

	if not IsValid( emitter ) then return end

	local trace = util.TraceLine( {
		start = pos,
		endpos = pos - Vector(0,0,500),
		mask = MASK_SOLID_BRUSHONLY,
	} )

	if not trace.Hit then return end

	local VecCol = (render.GetLightColor( trace.HitPos + trace.HitNormal ) * 0.8 + Vector(0.17,0.15,0.1)) * 255
	for i = 1,24 do
		local particle = emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], trace.HitPos )
		
		if not particle then continue end

		local ang = i * 15
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )

		particle:SetVelocity( Vector(X,Y,0) * 3000 )
		particle:SetDieTime( math.Rand(0.5,1) )
		particle:SetAirResistance( 500 ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 50 )
		particle:SetEndSize( 240 )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,150) + dir * 2000 )
		particle:SetCollide( false )
	end

	emitter:Finish()

	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local ViewEnt = ply:GetViewEntity()

	if not IsValid( ViewEnt ) then return end

	local Intensity = ply:InVehicle() and 8 or 80
	local Ratio = math.min( 250 / (ViewEnt:GetPos() - trace.HitPos):Length(), 1 )

	if Ratio < 0 then return end

	util.ScreenShake( trace.HitPos, Intensity * Ratio, 0.1, 0.5, 250 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 100 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 8, endpos + dir * len * 8, 200, 1, 0, Color( 255, 0, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 60, 1, 0, Color( 255, 0, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 30, 1, 0, Color( 255, 255, 255, 255 ) )
end

--PATH lua/effects/lvs_laser_red_short.lua:
return gluapack()()
--PATH lua/effects/lvs_physics_water.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	self.LifeTime = math.Rand(1.5,3)
	self.DieTime = CurTime() + self.LifeTime

	self.Splash = {
		Pos = Pos,
		Mat = Material("effects/splashwake1"),
		RandomAng = math.random(0,360),
	}

	local emitter = Ent:GetParticleEmitter( Ent:GetPos() )

	if emitter and emitter.Add then
		local particle = emitter:Add( "effects/splash4", Pos + VectorRand(-10,10) - Vector(0,0,20) )
		if particle then
			particle:SetVelocity( Vector(0,0,250) )
			particle:SetDieTime( 0.8 )
			particle:SetAirResistance( 60 ) 
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 50 )
			particle:SetEndSize( 100 )
			particle:SetRoll( math.Rand(-1,1) * 100 )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( false )
		end
	end
end


function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	end
	return true
end

function EFFECT:Render()
	if self.Splash and self.LifeTime then
		local Scale = (self.DieTime - self.LifeTime - CurTime()) / self.LifeTime
		local S = 200 - Scale * 600
		local Alpha = 100 + 100 * Scale

		cam.Start3D2D( self.Splash.Pos + Vector(0,0,1), Angle(0,0,0), 1 )
			surface.SetMaterial( self.Splash.Mat )
			surface.SetDrawColor( 255, 255, 255 , Alpha )
			surface.DrawTexturedRectRotated( 0, 0, S , S, self.Splash.RandomAng )
		cam.End3D2D()
	end
end
--PATH lua/effects/meridian_tracer.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/nio_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.ParticleCast = false
EFFECT.Time = nil

EFFECT.Speed = 12000
function EFFECT:Think()

	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"nio_beam", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = lightorigin
		mLight.r = 85
		mLight.g = 255
		mLight.b = 0
		mLight.brightness = 3 * Fraction
		mLight.Size = 280 + 300 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end
	
	return ( self.Time > CurTime() ) 
	
end

--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/pulsar_tracer_noattach_red.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/rb655_force_lighting_explosion.lua:

local function GetRandomPositionInBox( mins, maxs, ang )
	return ang:Up() * math.random( mins.z, maxs.z ) + ang:Right() * math.random( mins.y, maxs.y ) + ang:Forward() * math.random( mins.x, maxs.x )
end

local function GenerateLighting( from, to, deviations, power )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local segments = {
		{ start, endpos }
	}
	for i = 0, power do
		local newsegs = {}
		for id, seg in pairs( segments ) do
			local mid = Vector( (seg[1].x + seg[2].x) / 2, (seg[1].y + seg[2].y) / 2, (seg[1].z + seg[2].z) / 2 )
			local offsetpos = mid + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
			table.insert( newsegs, {seg[1], offsetpos} )
			table.insert( newsegs, {offsetpos, seg[2]} )
		end
		segments = newsegs
	end
	return segments
end

local function GenerateLightingSegs( from, to, deviations, segs )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to--:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos-- + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local fwd = (start - endpos):Angle():Forward()
	local step = (1 / segs) * start:Distance( endpos )

	local lastpos = start
	local segments = {}
	for i = 1, segs do
		local a = lastpos - fwd * step
		table.insert( segments, { lastpos, a } )
		lastpos = a
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		segments[ k ][ 1 ] = segments[ k ][ 1 ] + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
		segments[ k - 1 ][ 2 ] = segments[ k ][ 1 ]
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		if ( math.random( 0, 100 ) > 75 ) then
			local dir = AngleRand():Forward()
			table.insert( segments, { segments[ k ][ 1 ], segments[ k ][ 1 ] + dir * ( step * math.Rand( 0.2, 0.6 ) ) } )
		end
	end

	return segments
end

local mats = {
	(Material( "cable/blue_elec" )),
	/*(Material( "cable/hydra" )),
	(Material( "cable/redlaser" )),
	(Material( "cable/crystal_beam1" )),
	(Material( "cable/physbeam" )),
	(Material( "cable/smoke" )),
	(Material( "cable/xbeam" )),*/
}

local segments = {}
--local n = 0
local tiem = .2
hook.Add( "PostDrawTranslucentRenderables", "LightningExplosionRender", function()
	--if ( #segments < 1 || n < CurTime() ) then
		--
		/*for i = 0, 1 do
			table.insert( segments, {
				segs = GenerateLighting( table.Random( ents.FindByClass( "prop_physics" ) ), table.Random( ents.FindByClass( "prop_physics" ) ), math.random( 10, 20 ), 3 ),
				mat = table.Random( mats ),
				time = CurTime() + tiem,
				w = math.random( 20, 50 )
			} )
		end*/
		--n = CurTime() + .01
	--end

	for id, t in pairs( segments ) do
		if ( t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], ( math.max( t.startpos:Distance( t.endpos ) - seg[1]:Distance( t.endpos ), 20) / ( t.startpos:Distance( t.endpos ) ) * t.w ) * ( (t.time - CurTime() ) / tiem ), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
			--render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiem), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end
end )


function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local pos2 = data:GetStart()


	table.insert( segments, {
		--segs = GenerateLighting( pos, ent, math.random( 10, 20 ), 3 ),
		segs = GenerateLightingSegs( pos, pos2, math.random( 10, 20 ), pos:Distance( pos2 ) / 48 ), --math.random( 5, 10 ) ),
		mat = table.Random( mats ),
		time = CurTime() + tiem,
		w = math.random( 20, 50 ),
		startpos = pos,
		endpos = pos2 --ent:GetPos()
	} )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
	for id, t in pairs( segments ) do
		if (t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiem), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/rb655_force_repulse_out.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local rad = data:GetRadius()
	local emitter = ParticleEmitter( pos )

	if ( !emitter ) then return end

	local particle = emitter:Add( "effects/rb655_conc_warp", pos )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.25 * 5 )

		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( 0 )
		particle:SetEndSize( rad * 2 ) --math.random( 1000, 2000 ) )

		particle:SetStartAlpha( math.random( 128, 200 ) )
		particle:SetEndAlpha( 0 )

		particle:SetColor( 255, 255, 255 )
	end

	local particle2 = emitter:Add( "effects/rb655_splash_warpring1", pos )
	if ( particle2 ) then
		particle2:SetLifeTime( 0 )
		particle2:SetDieTime( 0.25 * 5 )

		particle2:SetGravity( Vector( 0, 0, 0 ) )
		particle2:SetVelocity( Vector( 0, 0, 0 ) )

		particle2:SetStartSize( 0 )
		particle2:SetEndSize( rad * 2 ) --math.random( 1000, 2000 ) )

		particle2:SetStartAlpha( math.random( 128, 200 ) )
		particle2:SetEndAlpha( 0 )

		particle2:SetColor( 255, 255, 255 )
	end

	--[[local part3 = emitter:Add( "effects/select_ring", pos )
	if ( part3 ) then
		part3:SetLifeTime( 0 )
		part3:SetDieTime( .5 )

		part3:SetGravity( Vector( 0, 0, 0 ) )
		part3:SetVelocity( Vector( 0, 0, 0 ) )

		part3:SetStartSize( 0 )
		part3:SetEndSize( rad )--math.random( 1000, 2000 ) )

		part3:SetStartAlpha( 255 )
		part3:SetEndAlpha( 0 )

		part3:SetColor( 0, 255, 255 )
		--part3:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
	end]]

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/[miecze] moce i hilty/lua/effects/repulse_charge.lua:
EFFECT.mat = Material( "sprites/heatwave" )
EFFECT.mat3 = Material( "particle/smokesprites_0001" )

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then self.Ready = true return end

	self.Pos = self.Ent:GetShootPos()
	self.mat3 = Material( "particle/smokesprites_000"..math.random(1,9) )

	self.Ready = true
end

function EFFECT:Think()
	if not self.Ready then return true end

	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

function EFFECT:Render()
	if not self.Ready or not IsValid( self.Ent ) then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local InvScale =  (1 - Scale)
	
	render.SetMaterial( self.mat3 )
	render.DrawSprite( self.Pos, 33 * InvScale * ( self.Ent:GetNWInt( "_RepulseCharge", 1 ) ), 33 * InvScale * ( self.Ent:GetNWInt( "_RepulseCharge", 1 ) ), Color( 150,200,255,50 ) )
	
	for i = 1, 3 do
		local Scale = (self.DieTime - CurTime()) / self.LifeTime / 3 * i

		local Pos = self.Pos

		render.SetMaterial( self.mat )
		render.DrawSprite( Pos, 50 * Scale * ( self.Ent:GetNWInt( "_RepulseCharge", 1 ) ), 50 * Scale * ( self.Ent:GetNWInt( "_RepulseCharge", 1 ) ), Color( 255,255,255,255 ) )
	end
end
	

--PATH lua/effects/rw_sw_dual_laser_red.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_green.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_orange.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_redpink.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_servius.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_red" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_laser_aqua.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_black.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_blue.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_blue.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_blue_main")
local MaterialFront 		= Material("effects/sw_laser_blue_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 30
			dlight.b = 255
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_laser_yellow.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_blue.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(0,120,255)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/rw_sw_muzzleflash_lightblue.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_orange.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 1
EFFECT.Color = Color(255,150,0)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/rw_sw_muzzleflash_redpink.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(255,0,50)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/rw_sw_stunwave_green.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4500;
EFFECT.Length				= 64;

local MaterialFront			= Material( "cs574/stun_tracers/sw_stunwave_green" );

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

EFFECT.WaveSize = 0

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if (self.WaveSize < 45) then
		self.WaveSize = self.WaveSize + 1
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(startPos, 1 + self.WaveSize, 1 + self.WaveSize, color_white)
end
--PATH lua/effects/rw_sw_stunwave_red.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4500;
EFFECT.Length				= 64;

local MaterialFront			= Material( "cs574/stun_tracers/sw_stunwave_red" );

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

EFFECT.WaveSize = 0

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if (self.WaveSize < 45) then
		self.WaveSize = self.WaveSize + 1
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(startPos, 1 + self.WaveSize, 1 + self.WaveSize, color_white)
end
--PATH addons/[miecze] moce i hilty/lua/effects/saber_hitwall_cheap.lua:
return gluapack()()
--PATH lua/effects/scifi_aftershock.lua:
local mat_glow = Material( "models/effects/scifi_aftershock" )
local mat = "models/effects/scifi_aftershock"

EFFECT.Parent 		= NULL
EFFECT.Time 		= 0.4
EFFECT.Origin 		= Vector( 0, 0, 0 )
EFFECT.Angles 		= Angle( 0, 0, 0 )
EFFECT.Radius 		= 16
EFFECT.Color 		= Vector( 0, 0, 0 )
EFFECT.SphereModel 	= "models/effects/shocksphere.mdl"

function EFFECT:Init( data )

	self.Parent 	= data:GetEntity() || self.Parent
	self.Origin 	= data:GetOrigin() || self.Origin
	self.Angles 	= data:GetAngles() || self.Angles
	self.Radius 	= data:GetRadius() || 16
	self.Color 		= data:GetNormal() || self.Color

	self.Time 		= math.max( data:GetScale(), 0.01 ) || self.Time
	self.LifeTime 	= CurTime() + self.Time

	self:SetModel( self.SphereModel )
	
end

function EFFECT:Think( )
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
			
	return false
	
end

function EFFECT:Render()

	local frac = math.Truncate( ( self.LifeTime - CurTime() ) / self.Time, 3 )
	local mul = 1 - frac

	local radius = 1 * self.Radius

	mat_glow:SetFloat( "$SilhouetteThickness", 1 - 1 * frac )
	mat_glow:SetFloat( "$RefractAmount", 0.01 * frac )
	mat_glow:SetFloat( "$BlurAmount", 0.01 * frac )
	mat_glow:SetVector( "$SilhouetteColor", self.Color * 10 * frac )

	self:SetPos( self.Origin )
	self:SetAngles( self.Angles )
	self:SetMaterial( mat )
	self:DrawModel()
	self:SetModelScale( radius * mul )
	self:SetParent( self.Parent )

	render.SetBlend( frac )
	render.SetMaterial( mat_glow )

end
--PATH lua/effects/scifi_emptyshell.lua:
local mat = "models/black"

EFFECT.Parent 		= NULL
EFFECT.Time 		= 5
EFFECT.Origin 		= Vector( 0, 0, 0 )
EFFECT.Angles 		= Angle( 0, 0, 0 )
EFFECT.Radius 		= 16
EFFECT.Velocity 	= Vector( 0, 0, 0 )
EFFECT.Model 		= "models/weapons/rifleshell.mdl"

function EFFECT:Init( data )

	self.Parent 	= data:GetEntity() || self.Parent
	self.Origin 	= data:GetOrigin() || self.Origin
	self.Angles 	= data:GetAngles() || self.Angles
	self.Radius 	= data:GetRadius() || 16
	self.Velocity 	= data:GetNormal() || self.Velocity

	self.Time 		= math.max( data:GetScale(), 0.01 ) || self.Time
	self.LifeTime 	= CurTime() + self.Time

	self:SetModel( self.Model )
	
end

function EFFECT:Think()

--	local grav = physenv.GetGravity() * 1
	local velo = self.Velocity * Vector( 1, 1, -60 ) * 1
	
	print( velo )
	
	self:SetPos( self:GetPos() + velo )
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
			
	return false
	
end

function EFFECT:Render()

	--self:SetPos( self.Origin )
	self:SetAngles( self.Angles )
	self:SetMaterial( mat )
	self:DrawModel()
	
	self:SetModelScale( 0.2 )

	if ( self.LifeTime - CurTime() < 1 ) then 
	--	render.SetBlend( self.LifeTime - CurTime() )
	end

end
--PATH lua/effects/seraph_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()
	
	util.ParticleTracerEx( 
		"seraph_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end
--PATH lua/effects/shk_tracer.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH addons/[miecze] moce i hilty/lua/effects/sl_force_lightning.lua:

local function GetRandomPositionInBox( mins, maxs, ang )
	return ang:Up() * math.random( mins.z, maxs.z ) + ang:Right() * math.random( mins.y, maxs.y ) + ang:Forward() * math.random( mins.x, maxs.x )
end

local function GenerateLighting( from, to, deviations, power )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local segments = {
		{ start, endpos }
	}
	for i = 0, power do
		local newsegs = {}
		for id, seg in pairs( segments ) do
			local mid = Vector( (seg[1].x + seg[2].x) / 2, (seg[1].y + seg[2].y) / 2, (seg[1].z + seg[2].z) / 2 )
			local offsetpos = mid + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
			table.insert( newsegs, {seg[1], offsetpos} )
			table.insert( newsegs, {offsetpos, seg[2]} )
		end
		segments = newsegs
	end
	return segments
end

local function GenerateLightingSegs( from, to, deviations, segs )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local fwd = (start - endpos):Angle():Forward()
	local step = (1 / segs) * start:Distance( endpos )

	local lastpos = start
	local segments = {}
	for i = 1, segs do
		local a = lastpos - fwd * step
		table.insert( segments, { lastpos, a } )
		lastpos = a
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		segments[ k ][ 1 ] = segments[ k ][ 1 ] + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
		segments[ k - 1 ][ 2 ] = segments[ k ][ 1 ]
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		if ( math.random( 0, 100 ) > 75 ) then
			local dir = AngleRand():Forward()
			table.insert( segments, { segments[ k ][ 1 ], segments[ k ][ 1 ] + dir * ( step * math.Rand( 0.2, 0.6 ) ) } )
		end
	end

	return segments
end

local mats = {
	(Material( "star/effects/lightning.png" )),
}

local segments = {}
--local n = 0
local tiem = .2

local inner = Material("star/effects/lightning_inner.png")

hook.Add( "PostDrawTranslucentRenderables", "SL.Lighting", function()
	for id, t in pairs( segments ) do
		if ( t.time < CurTime() ) then table.remove( segments, id ) continue end
		
		for id, seg in pairs( t.segs ) do
			
			local size = ( math.max( t.startpos:Distance( t.endpos ) - seg[1]:Distance( t.endpos ), 20) / ( t.startpos:Distance( t.endpos ) ) * t.w ) * ( (t.time - CurTime() ) / tiem )
			render.SetMaterial( t.mat )	
			render.DrawBeam(seg[1], seg[2], size, 0, seg[1]:Distance( seg[2] ) / 25, t.color)
			render.DrawBeam(seg[1], seg[2], size*0.5, 0, seg[1]:Distance( seg[2] ) / 25, color_white)
		end
	end
end )

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local ent = data:GetEntity()
	local color = data:GetAngles()

	color = Color(color[1], color[2], color[3])

	if ( !IsValid( ent ) ) then return end

	table.insert( segments, {
		color = color,
		segs = GenerateLightingSegs( pos, ent, math.random( 10, 20 ), pos:Distance( ent:GetPos() ) / 48 ), --math.random( 5, 10 ) ),
		mat = table.Random( mats ),
		time = CurTime() + tiem,
		w = math.random( 20, 50 ),
		startpos = pos,
		endpos = ent:GetPos()
	} )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()

end

--PATH lua/effects/spectra_blast.lua:
return gluapack()()
--PATH lua/effects/tbolt_tracer_cheap.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()

	util.ParticleTracerEx( 
		"tbolt_tracer_cheap", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/tfa_bullet_impact/init.lua:
function EFFECT:Init(data)
	local posoffset = data:GetOrigin()
	local emitter = ParticleEmitter(posoffset)

	if TFA.GetGasEnabled() then
		local p = emitter:Add("sprites/heatwave", posoffset)
		p:SetVelocity(50 * data:GetNormal() + 0.5 * VectorRand())
		p:SetAirResistance(200)
		p:SetStartSize(math.random(12.5, 17.5))
		p:SetEndSize(2)
		p:SetDieTime(math.Rand(0.15, 0.225))
		p:SetRoll(math.Rand(-180, 180))
		p:SetRollDelta(math.Rand(-0.75, 0.75))
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
return false
end
--PATH lua/effects/tfa_csgo_smokenade/init.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_cryo/init.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_energy/init.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_fubar/init.lua:
local function rvec(vec)
	vec.x=math.Round(vec.x)
	vec.y=math.Round(vec.y)
	vec.z=math.Round(vec.z)
	return vec
end

local blankvec = Vector(0,0,0)

local function partfunc(self)
	if IsValid(self.FollowEnt) then
		if self.Att then
			local angpos = self.FollowEnt:GetAttachment(self.Att)
			if angpos and angpos.Pos then
				self:SetPos(angpos.Pos)
				self:SetNextThink(CurTime())
			end
		end
	end
end
				
function EFFECT:Init( data )
	
	self.StartPacket = data:GetStart()
	self.Attachment = data:GetAttachment()

	local AddVel = vector_origin
	
	if LocalPlayer then
		if IsValid(LocalPlayer()) then
			AddVel = LocalPlayer():GetVelocity()
		end
	end
	
	if AddVel == vector_origin then
		AddVel = Entity(1):GetVelocity()
	end
	
	self.Position = data:GetOrigin()
	self.Forward = data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	
	local wepent = Entity(math.Round(self.StartPacket.z))
	
	if IsValid(wepent) then
		if wepent.IsFirstPerson and !wepent:IsFirstPerson() then
			data:SetEntity(wepent)
			self.Position = blankvec
		end
	end
	
	local ownerent = player.GetByID(math.Round(self.StartPacket.x))
	local serverside = false
	if math.Round(self.StartPacket.y)==1 then
		serverside = true
	end
	
	local ent = data:GetEntity()
	
	if serverside then
		if IsValid(ownerent) then
			if LocalPlayer() == ownerent then
				return
			end
			ent = ownerent:GetActiveWeapon()
			AddVel = ownerent:GetVelocity()
		end
	end
	
	if (!self.Position) or ( rvec(self.Position) == blankvec ) then
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		if self.WeaponEnt and IsValid(self.WeaponEnt) then
			local rpos = self.WeaponEnt:GetAttachment(self.Attachment)
			if rpos and rpos.Pos then
				self.Position = rpos.Pos
				if data:GetNormal()==vector_origin then
					self.Forward = rpos.Ang:Up()
					self.Angle = self.Forward:Angle()
					self.Right = self.Angle:Right()
				end
			end
		end
	end
	
	self.vOffset = self.Position
	dir = self.Forward
	AddVel = AddVel * 0.05

	if IsValid(ent) then
		dlight = DynamicLight(ent:EntIndex())
	else
		dlight = DynamicLight(0)	
	end
	
    if (dlight) then
        dlight.Pos              = self.Position + dir * 1 - dir:Angle():Right()*5
        dlight.r                = 255
        dlight.g                = 109
        dlight.b                = 0
        dlight.Brightness = 6.0
        dlight.size     = 110
        dlight.DieTime  = CurTime() + 0.03
   end
	
	ParticleEffectAttach("tfa_muzzle_fubar",PATTACH_POINT_FOLLOW,ent,data:GetAttachment())
	
	--[[
	local emitter = ParticleEmitter( self.vOffset )
		for i=0, 6 do
			local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.vOffset + (dir * 1.7 * i))
			if (particle) then
				particle:SetVelocity((dir * 19 * i) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.max(7 - 0.65 * i,1) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-40, 40) )
				particle:SetColor( 255 , 218 , 97 )
				particle:SetLighting(false)
				particle.FollowEnt = data:GetEntity()
				particle.Att = self.Attachment
				particle:SetThinkFunction( partfunc )
				particle:SetNextThink(CurTime())
			end
		end
		
		for i=0, 5 do
		
			local particle = emitter:Add( "particles/smokey", self.vOffset + dir * math.Rand(6, 10 ))
			if (particle) then
				particle:SetVelocity(VectorRand() * 5 + dir * math.Rand(27,33) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( math.Rand( 0.5, 0.5 ) )
				particle:SetStartAlpha( math.Rand( 5, 15 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(8,10) )
				particle:SetEndSize( math.Rand(2,5) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-0.8, 0.8) )
				
				particle:SetAirResistance( 10 ) 
 				 
 				particle:SetGravity( Vector( 0, 0, 60 ) ) 
				
				particle:SetColor( 255 , 255 , 255 ) 
			end
			
		end
		
		if GetTFAGasEnabled() then
			for i=0, 2 do
				local particle = emitter:Add( "sprites/heatwave", self.vOffset + (dir * i) )
				if (particle) then
					particle:SetVelocity((dir * 25 * i) + 1.05 * AddVel )
					particle:SetLifeTime( 0 )
					particle:SetDieTime( math.Rand( 0.05, 0.15 ) )
					particle:SetStartAlpha( math.Rand( 200, 225 ) )
					particle:SetEndAlpha( 0 )
					particle:SetStartSize( math.Rand(3,5) )
					particle:SetEndSize( math.Rand(8,10) )
					particle:SetRoll( math.Rand(0, 360) )
					particle:SetRollDelta( math.Rand(-2, 2) )
					
					particle:SetAirResistance( 5 ) 
					
					particle.FollowEnt = data:GetEntity()
					particle.Att = self.Attachment
					particle:SetThinkFunction( partfunc )
					 
					particle:SetGravity( Vector( 0, 0, 40 ) ) 
					
					particle:SetColor( 255 , 255 , 255 ) 
				end
			end
		end
		
	emitter:Finish() 
	]]--
end 

function EFFECT:Think( )
	return false
end

function EFFECT:Render()
end

 
--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_muzzleflash_smg/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.075
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--PATH lua/effects/tfa_muzzleflash_sniper/init.lua:
return gluapack()()
--PATH lua/effects/tfa_ricochet/init.lua:
return gluapack()()
--PATH lua/effects/tfa_ricochet/init.lua:
local RicochetColor = Color(255, 255, 255, 255)
local RicochetIDOffset = 33
local RicochetMat = Material("effects/yellowflare")
local cv_gv = GetConVar("sv_gravity")
local cv_sl = GetConVar("cl_tfa_fx_impact_ricochet_sparklife")
local cv_sc = GetConVar("cl_tfa_fx_impact_ricochet_sparks")

function EFFECT:Init(data)
	self.StartPos = data:GetOrigin()
	self.Dir = data:GetNormal()
	self.Dir:Normalize()
	self.Len = 128
	self.EndPos = self.StartPos + self.Dir * self.Len
	self.LifeTime = 0.1
	self.DieTime = CurTime() + self.LifeTime
	self.Grav = Vector(0, 0, -cv_gv:GetFloat())
	self.PartMult = data:GetMagnitude()
	self.SparkLife = cv_sl:GetFloat()
	local emitter = ParticleEmitter(self.StartPos)

	--Sparks
	for _ = 1, cv_sc:GetInt() * self.PartMult do
		local part = emitter:Add("effects/yellowflare", self.StartPos)
		part:SetVelocity((self.Dir + VectorRand() * 0.5) * math.Rand(75, 185))
		part:SetDieTime(math.Rand(0.25, 1) * self.SparkLife)
		part:SetStartAlpha(255)
		part:SetStartSize(math.Rand(2, 4))
		part:SetEndSize(0)
		part:SetRoll(0)
		part:SetGravity(self.Grav)
		part:SetCollide(true)
		part:SetBounce(0.55)
		part:SetAirResistance(0.5)
		part:SetStartLength(0.2)
		part:SetEndLength(0)
		part:SetVelocityScale(true)
		part:SetCollide(true)
	end

	--Impact
	local part = emitter:Add("effects/yellowflare", self.StartPos)
	part:SetStartAlpha(225)
	part:SetStartSize(64)
	part:SetDieTime(self.LifeTime)
	part:SetEndSize(0)
	part:SetEndAlpha(0)
	part:SetRoll(math.Rand(0, 360))
	part = emitter:Add("effects/yellowflare", self.StartPos)
	part:SetStartAlpha(255)
	part:SetStartSize(30 * self.PartMult)
	part:SetDieTime(self.LifeTime * 1.5)
	part:SetEndSize(0)
	part:SetEndAlpha(0)
	part:SetRoll(math.Rand(0, 360))
	emitter:Finish()
	local dlight = DynamicLight(LocalPlayer():EntIndex() + RicochetIDOffset)

	if (dlight) then
		dlight.Pos = self.StartPos
		dlight.r = 255
		dlight.g = 225
		dlight.b = 185
		dlight.Brightness = 2.75 * self.PartMult
		dlight.size = 48
		--dlight.DieTime 	= CurTime() + self.DieTime*0.7
		dlight.Decay = 1000 / math.max(0.01, math.min(self.SparkLife * 0.66, 1))
	end
end

function EFFECT:Think()
	if self.DieTime and (CurTime() > self.DieTime) then return false end

	return true
end

function EFFECT:Render()
	if self.DieTime then
		local fDelta = (self.DieTime - CurTime()) / self.LifeTime
		fDelta = math.Clamp(fDelta, 0, 1)
		render.SetMaterial(RicochetMat)
		local color = ColorAlpha(RicochetColor, 255 * fDelta)
		local precision = 16
		local i = 1

		while i <= precision do
			render.DrawBeam(self.StartPos + self.Dir * self.Len * ((i - 1) / precision), self.StartPos + self.Dir * self.Len * (i / precision), 8 * fDelta * (1 - i / precision), 0.5, 0.5, color)
			i = i + 1
		end
	end
end
--PATH lua/effects/tfa_tracer_fubar/init.lua:
return gluapack()()
--PATH lua/effects/tfa_tracer_fubar_aq/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tfa_tracer_red/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(255, 0, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(255, 0, 0)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 255
        dlight.g = 0
        dlight.b = 0
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 300
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH lua/effects/tx_130_projector.lua:
return gluapack()()
--PATH lua/effects/unitys_engine.lua:
return gluapack()()
--PATH lua/effects/xplo_tracer.lua:
return gluapack()()
--PATH lua/effects/xplo_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()

	util.ParticleTracerEx( 
		"xplo_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH addons/[tfres] frest_levels/lua/fstands2/levels/config.lua:
fstands = fstands or {}
fstands.Config = fstands.Config or {}
fstands.Config.Levels = {}

fstands.Config.Levels.hard = 1

fstands.Config.Levels.contexp = true

fstands.Config.Levels.weekendexpboost = 2 -- Ile razy ma dawać expa w weekendy (piątek-niedziela), wszystko po niżej włącznie z 1 wyłączy tą funkcję!



fstands.Config.Levels.exp = 10

fstands.Config.Levels.lvlconfig = {
    ["76561198146699133"] = true, -- DODAJ TUTAJ SWOJE STEAMID BY MÓC KOŻYSTAĆ Z EDYTORA W GRZE (Musisz mieć superadmina i byc tutaj dodany by edytować)

}

fstands.Config.Levels.multexp = {
    ["Vip"] = 2,
    ["Vip2"] = 2.5,
}

fstands.Config.Levels.showcustom = false

-- If you want to make custom display then grab some functions
-- ply:GetLevel(type) -- type = ALL will give all levels combined
-- ply:GetExp(type)


fstands.Config.Levels.Type = {
    ["global"] = true,
}


for k,v in pairs(fstands.Config.Levels.Type) do
    DarkRP.registerDarkRPVar(k.."_lvl",net.WriteDouble, net.ReadDouble)
    DarkRP.registerDarkRPVar(k.."_xp", net.WriteDouble, net.ReadDouble)
end

print("CONFIG LOADED")
--PATH lua/prone/sh_prone.lua:
return gluapack()()
--PATH lua/prone/cl_prone.lua:
return gluapack()()
--PATH lua/rd_claim_boards/core/client/cl_main.lua:
return gluapack()()
--PATH lua/rd_claim_boards/core/languages/sh_en.lua:
RDV.LIBRARY.AddLang("en", {
    CLAIMB_GetForceUnclaimed = "Your claimboard has been unclaimed by %s.",
    CLAIMB_YouForceUnclaimed = "You've unclaimed a Claimboard owned previously by %s.",
    CLAIMB_YouUnclaimed = "You've unclaimed one of your Claim-Boards.",
    CLAIMB_RateLimited = "You're being rate limited, calm down!",
    CLAIMB_UpdateSuccessful = "The Claim-Board has been updated.",
    CLAIMB_UpdateNoPerms = "You don't have the permissions to update this.",
    CLAIMB_OpenLabel = "Open",
    CLAIMB_ClosedLabel = "Closed",
    CLAIMB_CBLabel = "Claim Board",
    CLAIMB_SaveLabel = "Save",
    CLAIMB_moreInformation = "Please fill out all the information.",
    CLAIMB_battalionLabel = "Battalion",
    CLAIMB_unclaimLabel = "Unclaim",
    CLAIMB_statusLabel = "Status",
    CLAIMB_claimedByLabel = "Claimed By",
    CLAIMB_openToAll = "Open To All",
    CLAIMB_AOSOnEntry = "AOS On Entry",
    CLAIMB_UnclaimedLabel = "Unclaimed",
    CLAIMB_headerLabel = "Header",
    CLAIMB_battalionLabel = "Battalion",
})
--PATH addons/[tfres] datapad/lua/tfres/datapad/cl_core.lua:
local SN = "Datapad"
tfres[SN] = tfres[SN] or {}
local DP = tfres[SN]

 DP.App = DP.App or {}

local path = "tfres/datapad/apps/"
local apps = file.Find( path.."*", "LUA" )

for k,v in ipairs(apps) do
    local ap = include(path..v)
    DP.App[ap.Name] = ap
    
    
end

function DP:Applications()
    return DP.App
end

function DP:Mask(funcMask, funcDraw, funcRemove)
	render.SetStencilWriteMask(255)
	render.SetStencilTestMask(255)
	render.SetStencilReferenceValue(0)
	render.SetStencilPassOperation(STENCIL_KEEP)
	render.SetStencilZFailOperation(STENCIL_KEEP)
	render.ClearStencil()

	render.SetStencilEnable(true)
	render.SetStencilReferenceValue(1)
	render.SetStencilCompareFunction(STENCIL_NEVER)
	render.SetStencilFailOperation(STENCIL_REPLACE)

	


	funcMask()

	if funcRemove then
		render.SetStencilReferenceValue(1)
		render.SetStencilCompareFunction(STENCIL_GREATER)
		render.SetStencilFailOperation(STENCIL_INCR)
	
		funcRemove()
	end


	
	render.SetStencilCompareFunction(STENCIL_EQUAL)
	render.SetStencilFailOperation(STENCIL_KEEP)

	funcDraw()

	render.SetStencilEnable(false)
    render.SetStencilReferenceValue(0)
    render.ClearStencil()
end

local outline = Color(243,136,65)
local ofic = {
	["oficer"] = true,
	["moderator"] = true,
	["admin"] = true,
	["superadmin"] = true,
}



local function mainopen()
    if IsValid(DP.Menu) then DP.Menu:Remove() return end 
    DP.Menu = vgui.Create("DFrame")
    local x,y = ScrW()/1920,ScrH()/1080
    local frame = DP.Menu
    frame:SetSize(x*650,y*800)
    frame:Center()
    frame:MakePopup()
    frame:SetTitle("")
	frame:SetSkin("Datapad")
	frame.Paint = function(self,w,h) draw.RoundedBox(0,0,0,w,h,Color(0,0,0)) end
    local sheet = vgui.Create( "DPropertySheet", frame )
	sheet:Dock( FILL )
	local job = LocalPlayer():getJobTable()
	local rank = LocalPlayer():GetUserGroup()
    for k,v in pairs(DP:Applications()) do
		if (v.Category and !v.Category[job.category]) or (v.Rank and !ofic[rank]) then continue end
		local panel1 = vgui.Create( "DPanel", sheet )
        local pnl = sheet:AddSheet( k, panel1 )
        local tab = pnl.Tab

        panel1.Paint = function( self, w, h ) 
			if !self.Inval then 
				self.Inval = true
				 self:SetSize(w,h)
				 timer.Simple(0.1,function()
					if IsValid(panel1) then
						v.Derma(panel1)
					end
				end)
			end 
			draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 0,0 ) ) 
		end 

    end
end
list.Set( "DesktopWindows", "datapad", {
	title = "[tfres] Datapad",
	icon = "tfres/datapads/icon.png",
	init = function( icon, window )
        mainopen()
	end
} )


--local group = MRS.GetNWdata(LocalPlayer(), "Group")
--local rank = MRS.GetNWdata(LocalPlayer(), "Rank")
--print(MRS.Ranks[group].ranks[rank].name)

concommand.Add( "datapad_open", function( ply, cmd, args )
    mainopen() 
end )

DP.ArrestTable = {}

tfres.Global:RegisterNetwork("Datapad_arrest_text",function(data)

	chat.AddText(Color(218,0,0), "[Areszty] ", Color(255,230,0), data.txt)
	local gracz = player.GetBySteamID64(data.gracz)
	local czas = data.czas * 60
	DP.OSTIME = data.OSTIME -- Czas serwerowy To jest by obliczyć różnicę czasów między serwerem a klientem by się wszystko zgadzało
	DP.ArrestTable[data.gracz] = {czas = czas, nick = gracz:Nick(), start = data.start}
end)

tfres.Global:RegisterNetwork("Datapad_arrest_cleanarrest",function(data)
	chat.AddText(Color(218,0,0), "[Areszty] ", Color(255,230,0), data.txt)
	DP.ArrestTable[data.gracz] = nil
end)

tfres.Global:RegisterNetwork("Datapad_arrest_rejoin",function(data)
	chat.AddText(Color(218,0,0), "[Areszty] ", Color(255,230,0), data.txt)
end)

tfres.Global:RegisterNetwork("Datapad_arrest_sync",function(data)
	DP.OSTIME = data.OSTIME -- Czas serwerowy To jest by obliczyć różnicę czasów między serwerem a klientem by się wszystko zgadzało
	DP.ArrestTable = data.ArrestTable
	for k,v in pairs(DP.ArrestTable) do
		v.czas = v.czas * 60
	end
end)
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/areszty.lua:
local APP = {}

APP.Name = "Areszty"                   -- Nazwa
APP.Restricted = true               -- Dosłownie nic nie zmienia
APP.Category = {["Gwardia Coruscant"] = true, ["RSB"] = true}     -- Kategoria joba która ma dostęp

APP.Derma = function(parent)
    local x, y = parent:GetWide(), parent:GetTall()
    local pan = vgui.Create("DPanel", parent)
    pan:SetSize(x, y)
    pan:Dock(FILL)
    pan:SetBackgroundColor(Color(0, 0, 0))

    local html = vgui.Create("DHTML", pan)
    html:Dock(FILL)

    local steamMap = {} -- steamID64 -> player

    -- Funkcja do odbierania danych z JS
    html:AddFunction("datapad", "receive", function(json)
        local data = util.JSONToTable(json)
        if not data or not data.aresztowany then return end

        local target = steamMap[data.aresztowany]
        if not IsValid(target) then
            print("[ArrestPanel] Nieprawidłowy cel:", data.aresztowany)
            return
        end

        tfres.Global:NetServer("Datapad_arrest",data)

    end)

    -- Ładujemy HTML po dodaniu funkcji
    html:SetHTML([[
<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Panel Aresztowania</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(to bottom, #c13535, #891d1d);
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
            color: white;
            text-align: center;
            position: relative;
            overflow-x: hidden;
            box-sizing: border-box;
        }

        *, *::before, *::after {
            box-sizing: inherit;
        }

        body::before {
            content: "";
            background-image: url("https://static.wikia.nocookie.net/starwars/images/4/4c/Senate_seal.svg/revision/latest?cb=20080220004246");
            background-size: 100%;
            background-position: center;
            background-repeat: no-repeat;
            position: absolute;
            opacity: 0.3;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 500px;
            margin: 40px auto;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 10px;
            margin-bottom: 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            box-sizing: border-box;
        }

        .input-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .half-input {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .label {
            text-align: left;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .note {
            font-size: 12px;
            margin-bottom: 10px;
        }

        #confirmBtn {
            background: linear-gradient(to bottom, #6cff4c, #40cc2e);
            border: none;
            color: black;
            font-size: 20px;
            padding: 10px 40px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #confirmBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px #4aff00;
        }

        #errorMessage {
            color: #ff9999;
            font-size: 14px;
            margin-top: -15px;
            margin-bottom: 15px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Aresztowany</h2>
        <select id="aresztowany">
            <option value="">-- Wybierz osobę --</option>
        </select>

        <h2>Zarzuty</h2>
        <input type="text" id="zarzuty">

        <div class="input-row">
            <div class="half-input">
                <div class="label">Czas</div>
                <input type="number" id="czas" placeholder="1 = minuta">
            </div>
            <div class="half-input">
                <div class="label">Grzywna</div>
                <input type="number" id="grzywna">
            </div>
        </div>

        <div id="errorMessage"></div>

        <p class="note">
            Ja, niżej podpisany, potwierdzam, że zarzuty postawione wobec osoby aresztowanej są prawdziwe, a czas aresztu oraz wysokość grzywny są zgodne z obowiązującym taryfikatorem.
        </p>

        <input type="text" id="nick" placeholder="Podpisz się">

        <br><br>
        <button id="confirmBtn" onclick="zatwierdz()">Zatwierdź</button>
    </div>

    <script>
        function zatwierdz() {
            const czas = parseInt(document.getElementById('czas').value);

            if (czas > 30) {
                const msg = document.getElementById('errorMessage');
                msg.textContent = "Nie można ustawić czasu więcej niż 30 minut. Jeśli uważasz że powinno być inaczej postój sam 30 minut w miejscu i nic nie rób lub napisz do Troy na discordzie.";
                msg.style.display = 'block';
                setTimeout(() => msg.style.display = 'none', 10000);
                return;
            }

            const dane = {
                aresztowany: document.getElementById('aresztowany').value,
                zarzuty: document.getElementById('zarzuty').value,
                czas: czas,
                grzywna: parseInt(document.getElementById('grzywna').value),
                nick: document.getElementById('nick').value
            };

            if (!dane.nick || !dane.aresztowany) {
                alert("Wypełnij wszystkie pola.");
                return;
            }

            if (window.gmod) {
                datapad.receive(JSON.stringify(dane));
            } else {
                alert("Brak gmod");
            }
        }

        function zaladujAresztowanych(tablica) {
            const select = document.getElementById('aresztowany');
            select.innerHTML = '<option value="">-- Wybierz osobę --</option>';
            for (let i = 0; i < tablica.length; i++) {
                const entry = tablica[i];
                const opt = document.createElement('option');
                opt.value = entry.id;
                opt.textContent = entry.nick;
                select.appendChild(opt);
            }
        }

        window.gmod = {
            provideList: zaladujAresztowanych
        };
    </script>
</body>
</html>
    ]])

    -- Czekamy chwilę i wstrzykujemy dane
    timer.Simple(0.2, function()
        if not IsValid(html) then return end

        html:Call("document.getElementById('nick').value = " .. string.format("%q", LocalPlayer():Nick()))

        local list = {}
        for _, ply in ipairs(ents.FindInSphere(LocalPlayer():GetPos(), 300)) do
            if ply:IsPlayer() and ply:HasWeapon("weapon_handcuffed") then
                local sid = ply:SteamID64()
                table.insert(list, { nick = ply:Nick(), id = sid })
                steamMap[sid] = ply
            end
        end

        local json = util.TableToJSON(list)
        json = string.Replace(json, "\\", "\\\\")
        json = string.Replace(json, "\"", "\\\"")

        html:Call("gmod.provideList(JSON.parse(\"" .. json .. "\"))")
    end)
end

return APP

--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/posw.lua:
local APP = {}

APP.Name = "Poświadczenia"                   -- Nazwa
APP.Restricted = true               -- Dosłownie nic nie zmienia
APP.Rank = true                   -- Czy jest od oficera

APP.Derma = function(parrent)
    local x,y = parrent:GetWide(),parrent:GetTall()
	local pan = vgui.Create("DPanel",parrent)
    pan:SetSize(x,y)
    pan:Center()
    pan:SetBackgroundColor(Color(0,0,0))
    
    local tyt = vgui.Create("DTextEntry",pan)
    tyt:SetSize(x*0.5,tyt:GetTall())
    tyt:Center()
    tyt:SetPlaceholderText("Za co dostają reputacje")
    tyt:SetPos(tyt:GetX(), y*0.05)

    local ile = vgui.Create("DTextEntry",pan)
    ile:SetSize(x*0.5,ile:GetTall())
    ile:Center()
    ile:SetPlaceholderText("Ile czasu? 1 = minuta")
    ile:SetPos(ile:GetX(), y*0.1)
    ile:SetNumeric(true)

    local gracze = vgui.Create("DListView",pan)
    gracze:SetSize(x*0.3,y*0.6)
    gracze:Center()
    gracze:SetPos(gracze:GetX(),y*0.2)
    gracze:AddColumn( "Nick" )
    gracze:AddColumn( "Reputacja" )
    gracze:AddColumn( "SteamID" )

    for k,v in ipairs(ents.FindInSphere(LocalPlayer():GetPos(),500)) do
        if !IsValid(v) then continue end
        if !v:IsPlayer() then continue end
        local lvl = v:getJobTable().lvl
        local clvl = lvl ~= nil and v:GetLevel(lvl) or 0
        gracze:AddLine( v:Nick(), 0, v:SteamID() )
    end

    local wystaw = vgui.Create("DButton",pan)
    wystaw:Dock(BOTTOM)
    wystaw:SetText("Wystaw")
    wystaw:SetSize(1,y*0.05)
    function wystaw:DoClick()
        local seld = gracze:GetSelected()
        local pl = {}
        for k,v in ipairs(seld) do
            local steamid = v:GetColumnText(3)
            pl[steamid] = true
        end
        

        tfres.Global:NetServer("Datapad_posw",{players = pl,czas = ile:GetInt(),tyt = tyt:GetValue()})
    end

end





return APP
--PATH addons/!whitelist/lua/tfres/ranks/ranksandhide.lua:
return gluapack()()
--PATH lua/vmanip/anims/vmanip_baseanims.lua:
AddCSLuaFile()

--[[ IN BOTH CASES: NAME SHOULD BE THE ACTUAL SEQUENCE NAME
You don't have to put every value, but some like model are obviously needed

Hands
"model" - path to model
"lerp_peak" - time when the hand should transition back to the weapon
"lerp_speed_in" - speed at which the hand transitions into the anim
"lerp_speed_out" - speed at which the hand transitions out of the anim
"lerp_curve" - power of the curve
"speed" - playback speed
"startcycle" - time to start the anim at
"cam_ang" - angle offset for the camera
"cam_angint" - intensity multiplier of the camera
"sounds" - table of sounds, keys represent the path and their value the time it plays at. do not use past holdtime lmao
"loop" - loop the anim instead of stopping
"segmented" - when anim is over, freezes it and waits for SegmentPlay(sequence,lastanim). Repeat if lastanim is false
^Note: lerp peak and related values are used for the "last segment" instead.

"holdtime" - the time when the anim should be paused
"preventquit" - ONLY accept QuitHolding request if the argument is our anim. Use very cautiously
"assurepos" - for important anims, makes sure the position isn't offset by sweps. Use locktoply it's better
"locktoply" - for when assurepos isn't enough.


Legs
"model" - path to model
"speed" - playback speed 
"forwardboost" - forward offset
"upboost" - vertical offset (in actual hammer units)

]]

VManip:RegisterAnim("use",
{
["model"]="c_vmanipinteract.mdl",
["lerp_peak"]=0.4,
["lerp_speed_in"]=1,
["lerp_speed_out"]=0.8,
["lerp_curve"]=2.5,
["speed"]=1,
["startcycle"]=0.1,
["sounds"]={},
["loop"]=false
}
)


VManip:RegisterAnim("vault",
{
["model"]="c_vmanipvault.mdl",
["lerp_peak"]=0.4,
["lerp_speed_in"]=1,
["lerp_speed_out"]=0.5,
["lerp_curve"]=1,
["speed"]=1
}
)

VManip:RegisterAnim("handslide",
{
["model"]="c_vmanipvault.mdl",
["lerp_peak"]=0.2,
["lerp_speed_in"]=1,
["lerp_speed_out"]=0.8,
["lerp_curve"]=2,
["speed"]=1.5,
["holdtime"]=0.25,
}
)

VManip:RegisterAnim("adrenalinestim",
{
["model"]="old/c_vmanip.mdl",
["lerp_peak"]=1.1,
["lerp_speed_in"]=1,
["speed"]=0.7,
["sounds"]={},
["loop"]=false
}
)

VManip:RegisterAnim("thrownade",
{
["model"]="c_vmanipgrenade.mdl",
["lerp_peak"]=0.85,
["lerp_speed_in"]=1.2,
["lerp_speed_out"]=1.2,
["lerp_curve"]=1,
["speed"]=1,
["holdtime"]=0.4,
}
)

--###################################

VMLegs:RegisterAnim("test", --lmao, im not recompiling to change THAT shit
{
["model"]="c_vmaniplegs.mdl",
["speed"]=1.5,
["forwardboost"]=4,
["upwardboost"]=0
})