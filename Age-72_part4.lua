--Stealed clientside server code by exechack.cc
--Hostname: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus - Part 4/12 - 06/04/2025


--PATH addons/billy_gas/lua/includes/modules/hook.lua:
local gmod = gmod
local math = math
local table = table
local file = file
local timer = timer
local pairs = pairs
local setmetatable = setmetatable
local isstring = isstring
local isnumber = isnumber
local isbool = isbool
local isfunction = isfunction
local type = type
local ErrorNoHaltWithStack = ErrorNoHaltWithStack
local ErrorNoHalt = ErrorNoHalt
local print = print
local GProtectedCall = ProtectedCall
local tostring = tostring
local error = error

local _GLOBAL = _G

local EMPTY_FUNC = function() end

do
	-- this is for addons that think every server only has ulx and supplies numbers for priorities instead of using the constants
	HOOK_MONITOR_HIGH = -2
	HOOK_HIGH = -1
	HOOK_NORMAL = 0
	HOOK_LOW = 1
	HOOK_MONITOR_LOW = 2

	PRE_HOOK = {-4}
	PRE_HOOK_RETURN = {-3}
	NORMAL_HOOK = {0}
	POST_HOOK_RETURN = {3}
	POST_HOOK = {4}
end

local PRE_HOOK = PRE_HOOK
local PRE_HOOK_RETURN = PRE_HOOK_RETURN
local NORMAL_HOOK = NORMAL_HOOK
local POST_HOOK_RETURN = POST_HOOK_RETURN
local POST_HOOK = POST_HOOK

local NORMAL_PRIORITIES_ORDER = {
	[PRE_HOOK] = 1, [HOOK_MONITOR_HIGH] = 2, [PRE_HOOK_RETURN] = 3, [HOOK_HIGH] = 4,
	[NORMAL_HOOK] = 5, [HOOK_NORMAL] = 5, [HOOK_LOW] = 6, [HOOK_MONITOR_LOW] = 7,
	-- Special hooks, they don't use an order
}

local EVENTS_LISTS = {
	-- Special hooks
	[POST_HOOK_RETURN] = 2,
	[POST_HOOK] = 3,
}
for k, v in pairs(NORMAL_PRIORITIES_ORDER) do
	EVENTS_LISTS[k] = 1
end

local MAIN_PRIORITIES = {[PRE_HOOK] = true, [PRE_HOOK_RETURN] = true, [NORMAL_HOOK] = true, [POST_HOOK_RETURN] = true, [POST_HOOK] = true}

local PRIORITIES_NAMES = {
	[PRE_HOOK] = "PRE_HOOK", [HOOK_MONITOR_HIGH] = "HOOK_MONITOR_HIGH", [PRE_HOOK_RETURN] = "PRE_HOOK_RETURN",
	[HOOK_HIGH] = "HOOK_HIGH", [NORMAL_HOOK] = "NORMAL_HOOK", [HOOK_NORMAL] = "HOOK_NORMAL",
	[HOOK_LOW] = "HOOK_LOW", [HOOK_MONITOR_LOW] = "HOOK_MONITOR_LOW", [POST_HOOK_RETURN] = "POST_HOOK_RETURN", [POST_HOOK] = "POST_HOOK",
}

module("hook")

Author = "Srlion"
Version = "3.0.0"

local events = {}

local node_meta = {
	-- will only be called to retrieve the function
	__index = function(node, key)
		if key ~= 0 then -- this should never happen
			error("attempt to index a node with a key that is not 0: " .. tostring(key))
		end
		-- we need to check if the hook is still valid, if priority changed OR if the hook was removed from the list, we check from events table
		local event = node.event
		local hook_table = event[node.name]
		if not hook_table then return EMPTY_FUNC end -- the hook was removed

		if hook_table.priority ~= node.priority then
			return EMPTY_FUNC
		end

		return hook_table.func -- return the new/up-to-date function
	end
}
local function CopyPriorityList(self, priority)
	local old_list = self[EVENTS_LISTS[priority]]
	local new_list = {}; do
		local j = 0
		for i = 1, old_list[0 --[[length]]] do
			local node = old_list[i]
			if not node.removed then -- don't copy removed hooks
				j = j + 1
				local new_node = {
					[0 --[[func]]] = node[0 --[[func]]],
					event = node.event,
					name = node.name,
					priority = node.priority,
					idx = j,
				}
				new_list[j] = new_node
				-- we need to update the node reference in the event table
				local hook_table = node.event[node.name]
				hook_table.node = new_node
			end
			-- we need to delete the function reference so __index can work properly
			-- we do it to all nodes because they can't be updated when hooks are added/removed, so they need to be able to check using __index
			node[0 --[[func]]] = nil
			setmetatable(node, node_meta)
		end
		new_list[0 --[[length]]] = j -- update the length
	end
	local list_index = EVENTS_LISTS[priority] -- 1 for normal hooks, 2 for post return hooks, 3 for post hooks
	self[list_index] = new_list
end

local function new_event(name)
	if not events[name] then
		local function GetPriorityList(self, priority)
			return self[EVENTS_LISTS[priority]]
		end

		-- [0] = list length
		local lists = {
			[1] = {[0] = 0}, -- normal hooks
			[2] = {[0] = 0}, -- post return hooks
			[3] = {[0] = 0}, -- post hooks

			CopyPriorityList = CopyPriorityList,
			GetPriorityList = GetPriorityList,
		}

		-- create the event table, we use [0] as hook names can't be numbers
		events[name] = {[0] = lists}
	end
	return events[name]
end

function GetTable()
	local new_table = {}
	for event_name, event in pairs(events) do
		local hooks = {}
		for i = 1, 3 do
			local list = event[0][i]
			for j = 1, list[0 --[[length]]] do
				local node = list[j]
				hooks[node.name] = event[node.name].real_func
			end
		end
		new_table[event_name] = hooks
	end
	return new_table
end

function Remove(event_name, name)
	if not isstring(event_name) then ErrorNoHaltWithStack("bad argument #1 to 'Remove' (string expected, got " .. type(event_name) .. ")") return end

	local notValid = isnumber(name) or isbool(name) or isfunction(name) or not name.IsValid
	if not isstring(name) and notValid then ErrorNoHaltWithStack("bad argument #2 to 'Remove' (string expected, got " .. type(name) .. ")") return end

	local event = events[event_name]
	if not event then return end -- no event with that name

	local hook_table = event[name]
	if not hook_table then return end -- no hook with that name

	hook_table.node.removed = true

	-- we need to overwrite the priority list with the new one, to make sure we don't mess up with ongoing iterations inside hook.Call/ProtectedCall
	-- we basically copy the list without the removed hook
	event[0 --[[lists]]]:CopyPriorityList(hook_table.priority)

	event[name] = nil -- remove the hook from the event table
end

function Add(event_name, name, func, priority)
	if not isstring(event_name) then ErrorNoHaltWithStack("bad argument #1 to 'Add' (string expected, got " .. type(event_name) .. ")") return end
	if not isfunction(func) then ErrorNoHaltWithStack("bad argument #3 to 'Add' (function expected, got " .. type(func) .. ")") return end

	local notValid = name == nil or isnumber(name) or isbool(name) or isfunction(name) or not name.IsValid
	if not isstring(name) and notValid then ErrorNoHaltWithStack("bad argument #2 to 'Add' (string expected, got " .. type(name) .. ")") return end

	local real_func = func
	if not isstring(name) then
		func = function(...)
			local isvalid = name.IsValid
			if isvalid and isvalid(name) then
				return real_func(name, ...)
			end
			Remove(event_name, name)
		end
	end

	if isnumber(priority) then
		priority = math.floor(priority)
		if priority < -2 then priority = -2 end
		if priority > 2 then priority = 2 end
		if priority == -2 or priority == 2 then -- ulx doesn't allow returning anything in monitor hooks
			local old_func = func
			func = function(...)
				old_func(...)
			end
		end
	elseif MAIN_PRIORITIES[priority] then
		if priority == PRE_HOOK then
			local old_func = func
			func = function(...) -- this is done to stop the function from returning anything
				old_func(...)
			end
		end
		priority = priority
	else
		if priority ~= nil then
			ErrorNoHaltWithStack("bad argument #4 to 'Add' (priority expected, got " .. type(priority) .. ")")
		end
		-- we probably don't want to stop the function here because it's not a critical error
		priority = NORMAL_HOOK
	end

	local event = new_event(event_name)

	-- check if the hook already exists
	do
		local hook_info = event[name]
		if hook_info then
			-- check if priority is different, if not then we just update the function
			if hook_info.priority == priority then
				hook_info.func = func
				hook_info.real_func = real_func
				hook_info.node[0 --[[func]]] = func -- update the function in the node
				return
			end
			-- if priority is different then we consider it a new hook
			Remove(event_name, name)
		else
			-- create a new hook list to use, we need to shadow the old one
			event[0]:CopyPriorityList(priority)
		end
	end

	local hook_list = event[0]:GetPriorityList(priority)

	local hk_n = hook_list[0 --[[length]]] + 1
	local node = {
		[0 --[[func]]] = func,
		event = event,
		name = name,
		priority = priority,
		idx = hk_n, -- this is used to keep order of the hooks based on when they were added, to have a consistent order
	}
	hook_list[hk_n] = node
	hook_list[0 --[[length]]] = hk_n

	event[name] = {
		name = name,
		priority = priority,
		func = func,
		real_func = real_func,
		node = node,
	}

	if NORMAL_PRIORITIES_ORDER[priority] then
		table.sort(hook_list, function(a, b)
			local a_order = NORMAL_PRIORITIES_ORDER[a.priority]
			local b_order = NORMAL_PRIORITIES_ORDER[b.priority]
			if a_order == b_order then
				return a.idx < b.idx
			end
			return a_order < b_order
		end)
	end
end

local gamemode_cache
function Run(name, ...)
	if not gamemode_cache then
		gamemode_cache = gmod and gmod.GetGamemode() or nil
	end
	return Call(name, gamemode_cache, ...)
end

function ProtectedRun(name, ...)
	if not gamemode_cache then
		gamemode_cache = gmod and gmod.GetGamemode() or nil
	end
	return ProtectedCall(name, gamemode_cache, ...)
end

function Call(event_name, gm, ...)
	local event = events[event_name]
	if not event then -- fast path
		if not gm then return end
		local gm_func = gm[event_name]
		if not gm_func then return end
		return gm_func(gm, ...)
	end

	local lists = event[0 --[[lists]]]

	local hook_name, a, b, c, d, e, f

	do -- normal hooks
		local normal_hooks = lists[1]
		for i = 1, normal_hooks[0 --[[length]]] do
			local node = normal_hooks[i]
			local n_a, n_b, n_c, n_d, n_e, n_f = node[0 --[[func]]](...)
			if n_a ~= nil then
				hook_name, a, b, c, d, e, f = node.name, n_a, n_b, n_c, n_d, n_e, n_f
				break
			end
		end
	end

	if not hook_name and gm then
		local gm_func = gm[event_name]
		if gm_func then
			hook_name, a, b, c, d, e, f = gm, gm_func(gm, ...)
		end
	end

	-- we need to check if there is any post(return) hooks, if not then we can return early
	if lists[2][0 --[[length]]] == 0 and lists[3][0 --[[length]]] == 0 then
		return a, b, c, d, e, f
	end

	local returned_values = {hook_name, a, b, c, d, e, f}

	do -- post return hooks
		local post_return_hooks = lists[2]
		for i = 1, post_return_hooks[0 --[[length]]] do
			local node = post_return_hooks[i]
			local n_a, n_b, n_c, n_d, n_e, n_f = node[0 --[[func]]](returned_values, ...)
			if n_a ~= nil then
				a, b, c, d, e, f = n_a, n_b, n_c, n_d, n_e, n_f
				returned_values = {node.name, a, b, c, d, e, f}
				break
			end
		end
	end

	do -- post hooks
		local post_hooks = lists[3]
		for i = 1, post_hooks[0 --[[length]]] do
			local node = post_hooks[i]
			node[0 --[[func]]](returned_values, ...)
		end
	end

	return a, b, c, d, e, f
end

function ProtectedCall(event_name, gm, ...)
	local event = events[event_name]
	if not event then -- fast path
		if not gm then return end
		local gm_func = gm[event_name]
		if not gm_func then return end
		GProtectedCall(gm_func, gm, ...)
		return
	end

	local lists = event[0 --[[lists]]]

	do
		local normal_hooks = lists[1]
		for i = 1, normal_hooks[0 --[[length]]] do
			local node = normal_hooks[i]
			GProtectedCall(node[0 --[[func]]], ...)
		end
	end

	if gm then
		local gm_func = gm[event_name]
		if gm_func then
			GProtectedCall(gm_func, gm, ...)
		end
	end

	local returned_values = {nil, nil, nil, nil, nil, nil, nil}

	do
		local post_return_hooks = lists[2]
		for i = 1, post_return_hooks[0 --[[length]]] do
			local node = post_return_hooks[i]
			GProtectedCall(node[0 --[[func]]], returned_values, ...)
		end
	end

	do
		local post_hooks = lists[3]
		for i = 1, post_hooks[0 --[[length]]] do
			local node = post_hooks[i]
			GProtectedCall(node[0 --[[func]]], returned_values, ...)
		end
	end
end

function Debug(event_name)
	local event = events[event_name]
	if not event then
		print("No event with that name")
		return
	end

	local lists = event[0]
	print("------START------")
	print("event:", event_name)
	for i = 1, 3 do
		local list = lists[i]
		for j = 1, list[0 --[[length]]] do
			local node = list[j]
			print("----------")
			print("   name:", node.name)
			print("   func:", node[0])
			print("   real_func:", event[node.name].real_func)
			print("   priority:", PRIORITIES_NAMES[node.priority])
			print("   idx:", node.idx)
		end
	end
	print("-------END-------")
end

do -- ulx and dlib
	-- ulx/ulib support
	if file.Exists("ulib/shared/hook.lua", "LUA") then
		local old_include = _GLOBAL.include
		function _GLOBAL.include(f, ...)
			if f == "ulib/shared/hook.lua" then
				timer.Simple(0, function()
					print("Srlion Hook Library: Stopped ULX/ULib from loading it's hook library!")
				end)
				_GLOBAL.include = old_include
				return
			end
			return old_include(f, ...)
		end

		-- this could make an issue with addons that retrieve all hooks and call them, as POST_HOOK(_RETURN)
		-- will be called randomly and their first argument won't be the "returned values" table
		function GetULibTable()
			local new_events = {}

			for event_name, event in pairs(events) do
				local hooks = {[-2] = {}, [-1] = {}, [0] = {}, [1] = {}, [2] = {}}
				for i = 1, 3 do
					local list = event[0][i]
					for j = 1, list[0 --[[length]]] do
						local node = list[j]
						local priority = node.priority
						priority = isnumber(priority) and priority or priority[1]
						priority = math.Clamp(priority, -2, 2) -- just to make sure it's in the range
						local hook_table = event[node.name]
						hooks[priority][node.name] = hook_table.real_func
					end
				end
				new_events[event_name] = hooks
			end

			return new_events
		end
	end

	-- bloated hooks warning
	if file.Exists("dlib/modules/hook.lua", "LUA") then
		timer.Simple(0, function()
			ErrorNoHalt("Srlion Hook Library: DLib is installed, you should remove the bloated addon!\n")
			ErrorNoHalt("Srlion Hook Library: DLIB is also slower than default hook library, check github.com/srlion/Hook-Library for more info! THIS MEANS IT MAKES YOUR SERVER SLOWER!\n")
		end)
	end
end
--addons/arccw_base_modified/lua/autorun/arccw_autorun.lua:
AddCSLuaFile()

-- the main object
ArcCW = {}

ArcCWInstalled = true

ArcCW.GenerateAttEntities = true

for _, v in pairs(file.Find("arccw/shared/*", "LUA")) do
    include("arccw/shared/" .. v)
    AddCSLuaFile("arccw/shared/" .. v)
end

for _, v in pairs(file.Find("arccw/client/*", "LUA")) do
    AddCSLuaFile("arccw/client/" .. v)
    if CLIENT then
        include("arccw/client/" .. v)
    end
end

-- TODO: Remove SP check after upcoming June 2023 update
if SERVER or game.SinglePlayer() then
    for _, v in pairs(file.Find("arccw/server/*", "LUA")) do
        include("arccw/server/" .. v)
    end
end

-- if you want to override arccw functions, put your override files in the arccw/mods directory so it will be guaranteed to override the base

for _, v in pairs(file.Find("arccw/mods/shared/*", "LUA")) do
    include("arccw/mods/shared/" .. v)
    AddCSLuaFile("arccw/mods/shared/" .. v)
end

for _, v in pairs(file.Find("arccw/mods/client/*", "LUA")) do
    AddCSLuaFile("arccw/mods/client/" .. v)
    if CLIENT then
        include("arccw/mods/client/" .. v)
    end
end

-- TODO: Remove SP check after upcoming June 2023 update
if SERVER or game.SinglePlayer() then
    for _, v in pairs(file.Find("arccw/mods/server/*", "LUA")) do
        include("arccw/mods/server/" .. v)
    end
end
--addons/arccw_weapons/lua/arccw/shared/attachments/15a_barrel_up.lua:
att.PrintName = "15a Short-up barrel"
att.Description = "Compact barrel intended for close-range battle."
att.SortOrder = 40
att.Icon = Material("interfaz/armas/swrp_att_e11_rearsight.png")
att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = "15a_barrel"
att.ActivateElements = {"15a_barrel_up"}

att.Mult_Range = 0.75
att.Mult_Recoil = 1.25
att.Mult_SightTime = 0.8
att.Mult_AccuracyMOA = 2
att.Mult_Damage = 1.08

att.Mult_ShootPitch = 1.1
--addons/arccw_weapons/lua/arccw/shared/attachments/15s_barrel_sniper.lua:
att.PrintName = "15s Sniper Barrel"
att.Description = "Extended barrel for DC-15s."
att.SortOrder = 40
att.Desc_Pros = {}
att.Icon = Material("interfaz/armas/swrp_att_a280c_grip.png")
att.Desc_Cons = {}

att.AutoStats = true
att.Slot = "15s_barrel"
att.ActivateElements = {"15a_barrel_extended"}

att.Override_MuzzleEffect = "wpn_muzzleflash_dc17_green"
att.Override_Tracer = "tracer_green"

att.Mult_MoveSpeed = 0.9

att.Mult_MoveDispersion = 1.25
att.Mult_SightTime = 1.15
att.Mult_Range = 2.5
att.Mult_RPM = 0.5
att.Mult_Damage = 2
att.Override_AccuracyMOA = 0.1
att.Mult_ShootPitch = 0.70

--addons/arccw_weapons/lua/arccw/shared/attachments/15s_mag_a280.lua:
att.PrintName = "15s Extended Magazine (A280)"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine for DC-15s"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Slot = "15s_mag"
att.ActivateElements = {"15s_mag_a280"}

att.AutoStats = true
att.HideIfBlocked = true
att.Override_ClipSize = 75

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1
att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95
att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25
att.Mult_HipDispersion = 1.3

--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_hammershot.lua:
att.PrintName = "Hammershot Module"
att.Icon = Material("interfaz/armas/sw_hammershot.png")
att.Description = "Higher damage at cost of lower fire-ratio."
att.Override_MuzzleEffect = "wpn_muzzleflash_dc17_orange"
att.Override_Tracer = "tracer_orange"
att.Mult_ShootPitch = 0.6

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.NotForNPCs = true
att.AutoStats = true
att.Slot = "ammo"

att.Reload = 1
att.Mult_DamageMin = 1.18
att.Mult_Recoil = 1.29
att.Mult_SightTime = 1.2
att.Mult_RPM = 0.63
att.Mult_Damage = 1.27
att.Mult_MuzzleVelocity = 1.28
--addons/arccw_weapons/lua/arccw/shared/attachments/gl_bacta.lua:
att.PrintName = "Grenade Launcher (Bacta)"
att.Icon = Material("interfaz/armas/sw_powercore.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Bacta)"
att.UBGL_Automatic = false
--att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_heal", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/optic_experimental.lua:
att.PrintName = "Experimental Scope"
att.Icon = Material("entities/acwatt_optic_micro.png")
att.Description = "test scope for swrp"

att.SortOrder = 2

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = false
att.Slot = "swoptic_module"

att.Model = "models/weapons/arccw/atts/dc17c_sight.mdl"
att.HideModel = false
att.ModelScale = Vector(1, 1, 1)
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 90, 0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 8.5, -1.73),
        Ang = Angle(0, 0, 0),
        Magnification = 1,
    }
}

att.Holosight = true
att.HolosightReticle = Material("#sw/visor/sw_ret_redux_blue.png", "smooth")
att.HolosightNoFlare = false
att.HolosightSize = 6
att.HolosightBone = "holosight"
att.HolosightPiece = "models/weapons/arccw/atts/dc17c_hsp.mdl"

att.HolosightMagnification = 2
att.HolosightBlackbox = true
att.HolosightNoHSP = false

att.Mult_SightTime = 1.08
att.Mult_SightedSpeedMult = 0.94
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_ondamove.lua:
att.PrintName = "On the Move"

att.Icon = Material("interfaz/iconos/kraken/sith merc arsenal/2232225357_452121849.png")
att.Description = "Expert training in high-verticality maneuvers and countless moving-while-shooting drills allow you to aim steadily even while moving between cover, across open ground, or while mid-air."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.SortOrder = 4

att.Mult_JumpDispersion = 0
att.Mult_MoveDispersion = .4

att.NotForNPCs = true
--lua/arccw/shared/attachments/uc_ammo_ap.lua:
att.PrintName = "\"AP\" Armor-piercing Rounds"
att.AbbrevName = "\"AP\" Armor-piercing"
att.SortOrder = 5
att.Icon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth")
att.Description = "Bullets designed to penetrate body armor, usually built around a penetrator of hardened steel, tungsten, or tungsten carbide.\nUpon impact on a hard target, the case is destroyed, but the penetrator continues its motion and penetrates the target."
att.Desc_Pros = {
    "uc.api.1",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_ammo"

att.AutoStats = true

att.Mult_Range = 2
att.Mult_Penetration = 2

att.Mult_Damage = 0.9
att.Mult_DamageMin = 0.9

att.Hook_Compatible = function(wep)
    if wep:GetIsShotgun() then
        return false
    end
end

local cov = GetConVar("arccw_uc_apobjmult")
local metalMats = { -- it's actually the good type
    [77] = true,
}
att.Hook_BulletHit = function(wep,data)
    local ent = data.tr.Entity
    if IsValid(ent) and (metalMats[data.tr.MatType] or !(ent:IsNPC() or ent:IsPlayer() or ent:IsNextBot())) then
        data.damage = data.damage * cov:GetFloat()
        local eff = EffectData()
        eff:SetOrigin(data.tr.HitPos)
        util.Effect("cball_bounce", eff)
    end
end

--lua/arccw/shared/attachments/uc_ammo_sg_magnum.lua:
att.PrintName = "\"MAG\" #000 Magnum Buckshot"
att.AbbrevName = "\"MAG\" #000 Buckshot"

att.SortOrder = 5
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[Buckshot load using fewer, larger diameter shots and a more intense powder load. This ammo type is particularly effective up close, but its energy fizzles out quickly.]]
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.pellet.0.75",
    "uc.accuracy.10",
}
att.Desc_Neutrals = {
}
att.Slot = {"ud_ammo_shotgun","uc_ammo"}

att.AutoStats = true

att.Mult_Num = 0.75
att.Mult_Damage = 1.25

att.Mult_Range = 0.5
att.Mult_RangeMin = 2

att.Mult_Recoil = 1.3
att.Add_AccuracyMOA = 10

att.Mult_HullSize = 1.5

att.Override_UC_ShellColor = Color(0.8 * 255, 0.8 * 255, 0.8 * 255)

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() or wep:GetBuff_Override("UC_Shotshell") then
        return false
    end
end
--lua/arccw/shared/attachments/uc_charm_urbancharm.lua:
att.PrintName = "Urban Charm"
att.Description = "The icon of a Garry's Mod addon."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/atts/uc_urbancharm.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.5, 0.5, 0.5)
att.CharmOffset = Vector(0, -1.1, -0.2)
att.CharmAngle = Angle(20, 0, 80)
att.CharmSkin = 0

att.Ignore = true --Toggles need to be done

att.ToggleLockDefault = true
att.ToggleStats = {
    {
        PrintName = "Common",
        CharmSkin = 0,
    },
    {
        PrintName = "Decay",
        CharmSkin = 1,
    },
    {
        PrintName = "Renewal",
        CharmSkin = 2,
    },
    {
        PrintName = "Anarchy",
        CharmSkin = 3,
    },
    {
        PrintName = "Ordinance",
        CharmSkin = 4,
    }
}

--lua/arccw/shared/attachments/uc_grip_bcmvfg.lua:
att.PrintName = "BCMGUNFIGHTER Vertical Grip Mod 3"
att.AbbrevName = "BCM Stubby Foregrip"
att.Icon = Material("entities/att/acwatt_uc_grip_bcmvfg.png", "mips smooth")
att.Description = "A short grip providing a more natural holding position, making the weapon easier to use while moving.\n"

att.SortOrder = 1300

att.AutoStats = true
att.Slot = "foregrip"

att.LHIK = true

att.ModelOffset = Vector(0, 0, -0.14)
att.Model = "models/weapons/arccw/atts/ud_foregrip_mod3.mdl"
-- att.ModelSkin  = 1

att.Mult_MoveDispersion = 0.75

att.Mult_SightedSpeedMult = 0.9

att.Override_HoldtypeActive = "smg"
att.Override_HoldtypeActive_Priority = 2
--lua/arccw/shared/attachments/uc_muzzle_supp_ssq.lua:
att.PrintName = "US G.I. 45 Suppressor"
att.AbbrevName = "G.I. Suppressor"
att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_ssq.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nEnhances ballistics performance significantly, but its low maximum pressure makes it incompatible with supersonic ammunition."
att.Desc_Neutrals = {"uc.exclusive.subsonic", "uc.subsonic"}

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/ud_silencer_ssq.mdl"
att.ModelOffset = Vector(0.5, 0, 0.0)
att.ModelScale = Vector(0.8, 0.8, 0.8)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75
att.Mult_Range = 1.25

att.Add_BarrelLength = 5
att.Mult_SightTime = 1.1
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

-- att.Hook_Compatible = function(wep,data)
--     local flags = wep:GetWeaponFlags()
--     if !(table.HasValue(flags,"cal_subsonic") or table.HasValue(flags,"powder_subsonic")) then
--         return false
--     end
-- end

att.Hook_Compatible = function(wep,data)
    if !ArcCW.UC.PistolAmmoTypes[wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo)] or wep:GetBuff("PhysBulletMuzzleVelocity") > ArcCW.UC.SubsonicThreshold then
        return false
    end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    return false
end

att.HideIfBlocked = true
--lua/arccw/shared/attachments/uc_optic_comp_m2.lua:
att.PrintName = "AIMPOINT CompM2 Red Dot (RDS)"
att.AbbrevName = "CompM2 (RDS)"
att.Icon = Material("entities/att/acwatt_uc_optic_comp_m2.png", "mips smooth")
att.Description = "Improves sighted visibility with a red-dot targeting reticle, while adding minimal extra weight."

att.SortOrder = 1

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"optic"}

att.Model = "models/weapons/arccw/atts/uc_comp_m2.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.ModelScale = Vector(0.9, 0.9, 0.9)

att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.5), -- -1.44
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE,
    }
}

att.Holosight = true
att.HolosightReticle = Material("hud/reticles/uc_reddot.png", "mips smooth")
att.HolosightPiece = "models/weapons/arccw/atts/uc_comp_m2_hsp.mdl"
att.HolosightNoFlare = false
att.HolosightSize = 1.5
att.HolosightBone = "holosight"
att.Colorable = true

att.Mult_SightedSpeedMult = .9
--lua/arccw/shared/attachments/uc_optic_trijicon_tars.lua:
att.PrintName = "Trijicon Tactical Advanced Riflescope (3-8x)"
att.AbbrevName = "TARS (3-8x)"
att.Icon = Material("entities/att/acwatt_uc_optic_trijicon_tars.png", "mips smooth")
att.Description = "Variable power scope, adjustable for a very wide range of magnifications."

att.SortOrder = 8

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom"
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"optic"}

att.Model = "models/weapons/arccw/atts/uc_trijicon_tars.mdl"
att.ModelOffset = Vector(0, 0, 0.1)
att.ModelScale = Vector(1.05,1.05,1.05)

att.AdditionalSights = {
    {
        Pos = Vector(0, 10.6, -1.51),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
		ViewModelFOV = 25,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ScopeMagnification = UC_HalfScope( 3 ),
        ScopeMagnificationMin = UC_HalfScope( 3 ),
        ScopeMagnificationMax = UC_HalfScope( 8 ),
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("hud/scopes/uc_tars_reticle.png", "mips smooth"),
            HolosightNoFlare = true,
            HolosightSize = 18,
            HolosightPiece = "models/weapons/arccw/atts/uc_trijicon_tars_hsp.mdl",
            HolosightBlackbox = true,
            HolosightMagnification = UC_HalfScope( 3 ),
            HolosightMagnificationMin = UC_HalfScope( 3 ),
            HolosightMagnificationMax = UC_HalfScope( 8 ),
            Colorable = true,
            SpecialScopeFunction = function(screen)
                render.PushRenderTarget(screen)

                DrawBloom(0,0.3,5,5,3,0.5,1,1,1)
                DrawSharpen(1,1.65)
                DrawMotionBlur(0.45,1,1/45)

                render.PopRenderTarget()
            end,
        },
    }
}

-- att.Holosight = true
-- att.HolosightReticle = Material("mifl_tarkov_reticle/dot.png", "mips smooth")

att.HolosightPiece = "models/weapons/arccw/atts/uc_trijicon_tars_hsp.mdl"
-- att.HolosightNoFlare = true
-- att.HolosightSize = 1
-- att.HolosightBone = "holosight"
att.Colorable = true

att.Mult_SightedSpeedMult = .7
att.Mult_SightTime = 1.1
--lua/arccw/shared/attachments/uc_tac_anpeq2_tan.lua:
att.PrintName = "Insight Technologies ATPIAL AN/PEQ-2 (Tan)"
att.AbbrevName = "AN/PEQ-2 (Tan)"
att.Icon = Material("entities/att/acwatt_uc_tac_anpeq2_tan.png", "mips smooth")
att.Description = "Large flashlight and laser module for rifles, with a stronger, more effective laser that also aids target acquisition.\nThe laser and flashlight can be toggled individually.\nThis unit is cosmetically colored tan."
att.Desc_Pros = {
    "uc.light"
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac"}
att.SortOrder = 20+1

att.Model = "models/weapons/arccw/atts/uc_anpeq2.mdl"
att.ModelOffset = Vector(0, 0.01, 0.35)
att.OffsetAng = Angle(0, 0,180)
att.ModelScale = Vector(1.2, 1.2, 1.2)
att.Laser = false
att.LaserStrength = 3.5 / 5
att.LaserBone = "laser"

att.ColorOptionsTable = {Color(255, 0, 0, 150)}

att.Mult_SightTime = 1.1
att.Mult_SightedSpeedMult = 0.9
att.Mult_MoveSpeed = 1

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightFarZ = 512 -- how far it goes
att.FlashlightNearZ = 1 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 235, 229)
att.FlashlightTexture = "effects/flashlight001"
att.FlashlightBrightness = 2
att.FlashlightBone = "laser"

att.ToggleStats = {
    {
        PrintName = "Laser",
        Laser = true,
        Mult_HipDispersion = 0.7,
        Mult_MoveDispersion = 0.8,
        Mult_SightTime = .9,
        Mult_SightedSpeedMult = .75
    },
    {
        PrintName = "Both",
        Laser = true,
        Flashlight = true,
        Mult_HipDispersion = 0.7,
        Mult_MoveDispersion = 0.8,
        Mult_SightTime = .9,
        Mult_SightedSpeedMult = .75
    },
    {
        PrintName = "Light",
        Flashlight = true,
    },
    {
        PrintName = "Off",
    }
}
--lua/arccw/shared/attachments/uc_tac_laser_green.lua:
att.PrintName = "Rail-Mounted Laser Sight (Green)"
att.AbbrevName = "Green Laser Sight"
att.Icon = Material("entities/att/acwatt_uc_tac_flashlight2.png", "mips smooth")
att.Description = "Projects a laser in the direction of the target, assisting the user to line up shots without iron sights."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac","tac_pistol"}
att.SortOrder = 29

att.Model = "models/weapons/arccw/atts/ud_flashlight_1.mdl"
att.ModelOffset = Vector(0,0,0)
att.OffsetAng = Angle(0,0,180)
att.ModelScale = Vector(1.2,1.2,1.2)
att.Laser = false
att.LaserStrength = 2 / 5
att.LaserBone = "light"

att.ColorOptionsTable = {Color(0, 255, 0, 150)}

att.ToggleStats = {
    {
        PrintName = "On",
        Laser = true,
        Mult_HipDispersion = 0.8,
        Mult_MoveDispersion = 0.8,
    },
    {
        PrintName = "Off",
        Laser = false,
    }
}
--lua/arccw/shared/attachments/uc_tp_endurance.lua:
att.PrintName = "Endurance"

att.Icon = Material("entities/att/arccw_uc_tp_endurance.png", "smooth mips")
att.Description = "Long courses of physical training allow you to bear more weight and control the recoil of your weapon, reducing the influence of your weapon's bulk on your speed and controlling its kick to stay on target for longer."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 17

att.Mult_MoveSpeed = 1.1
att.Mult_Recoil = 0.9
att.Mult_RecoilSide = 0.9

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/wepcamo_hyper.lua:
att.PrintName = "Hyperbeast"
att.Description = "Unleash the Hyperbeast."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Slot = "rep_vibrocamo"
att.Free = true

att.ActivateElements = {"wepcamo-hyper"}

att.SortOrder = 2 *-1
--addons/arccw_weapons/lua/arccw/shared/attachments/wepcamo_uk.lua:
att.PrintName = "United Kingdom"
att.Description = ""
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Slot = "rep_vibrocamo"
att.Free = true

att.ActivateElements = {"wepcamo-uk"}
att.SortOrder = 2 *-1
--addons/arccw_base_modified/lua/arccw/shared/sh_localization.lua:
if SERVER and game.SinglePlayer() then
    util.AddNetworkString("arccw_sp_reloadlangs")
end

ArcCW.LangTable = ArcCW.LangTable or {}
-- Converts raw string to a lang phrase. not case sensitive.
ArcCW.StringToLang = {
    -- Class
    ["pistol"] = "class.pistol",
    ["revolver"] = "class.revolver",
    ["machine pistol"] = "class.machinepistol",

    ["submachine gun"] = "class.smg", -- Preferred
    ["sub-machine gun"] = "class.smg",
    ["smg"] = "class.smg",

    ["personal defense weapon"] = "class.pdw", -- Preferred
    ["pdw"] = "class.pdw",

    ["shotgun"] = "class.shotgun",

    ["assault carbine"] = "class.assaultcarbine",
    ["carbine"] = "class.carbine",
    ["assault rifle"] = "class.assaultrifle",
    ["rifle"] = "class.rifle",

    ["battle rifle"] = "class.battlerifle",
    ["designated marksman rifle"] = "class.dmr",
    ["dmr"] = "class.dmr", -- Preferred
    ["sniper rifle"] = "class.sniperrifle", -- Preferred
    ["sniper"] = "class.sniperrifle",

    ["antimateriel rifle"] = "class.antimaterielrifle", -- Preferred
    ["antimaterial rifle"] = "class.antimaterielrifle",
    ["anti-material rifle"] = "class.antimaterielrifle",
    ["rocket launcher"] = "class.rocketlauncher",

    ["hand grenade"] = "class.grenade", -- Preferred
    ["grenade"] = "class.grenade",
    ["melee weapon"] = "class.melee", -- Preferred

    -- Attachment Slot
    ["optic"] = "attslot.optic",
    ["backup optic"] = "attslot.bkoptic",
    ["muzzle"] = "attslot.muzzle",
    ["barrel"] = "attslot.barrel",
    ["choke"] = "attslot.choke",
    ["underbarrel"] = "attslot.underbarrel",
    ["tactical"] = "attslot.tactical",
    ["grip"] = "attslot.grip",
    ["stock"] = "attslot.stock",
    ["fire group"] = "attslot.fcg",
    ["ammo type"] = "attslot.ammo",
    ["perk"] = "attslot.perk",
    ["charm"] = "attslot.charm",
    ["skin"] = "attslot.skin",
    ["magazine"] = "attslot.magazine",
    ["slide"] = "attslot.slide",

    ["iron sights"] = "attslot.optic.default",
    ["ironsights"] = "attslot.optic.default",
    ["standard barrel"] = "attslot.barrel.default",
    ["standard choke"] = "attslot.choke.default",
    ["standard muzzle"] = "attslot.muzzle.default",
    ["standard grip"] = "attslot.grip.default",
    ["standard stock"] = "attslot.stock.default",
    ["no stock"] = "attslot.stock.none",
    ["standard fcg"] = "attslot.fcg.default",
    ["standard magazine"] = "attslot.magazine.default",
}

-- Helper function for getting the overwrite or default language
function ArcCW.GetLanguage()
    local l = ArcCW.ConVars["language"] and string.lower(ArcCW.ConVars["language"]:GetString())
    if !l or l == "" then l = string.lower(GetConVar("gmod_language"):GetString()) end
    return l
end

-- Adds a string to the StringToLang table.
function ArcCW.AddStringToLang(str, phrase)
    if phrase == nil or phrase == "" or str == nil or str == "" then return nil end
    ArcCW.StringToLang[string.lower(str)] = phrase
end

-- Retrieves a lang phrase from a string. If the string is a phrase itself, it will be returned.
function ArcCW.GetPhraseFromString(str)
    if str == nil or str == "" then return nil end
    if ArcCW.StringToLang[string.lower(str)] then
        return ArcCW.StringToLang[string.lower(str)]
    end
    if ArcCW.LangTable["en"][string.lower(str)] then
        return string.lower(str)
    end
    return nil
end

-- Gets a translated string from a phrase. Will attempt to fallback to English.
-- Returns nil if no such phrase exists.
function ArcCW.GetTranslation(phrase, format)
    if phrase == nil or phrase == "" then return nil end
    local lang = ArcCW.GetLanguage()
    if !lang or lang == "" or !ArcCW.LangTable[lang] or !ArcCW.LangTable[lang][phrase] then
        lang = "en"
    end
    if ArcCW.LangTable[lang] and ArcCW.LangTable[lang][phrase] then
        local str = ArcCW.LangTable[lang][phrase]
        for i, v in pairs(format or {}) do
            -- print(i, v)
            str = string.Replace(str, "{" .. i .. "}", v)
        end
        return str
    end
    return nil
end

-- Attempts to translate a string (could be either a raw string or a phrase).
-- If fail, return the string itself.
function ArcCW.TryTranslation(str, format)
    if !str then return nil end
    local phrase = ArcCW.GetPhraseFromString(str)
    if !phrase then return str end

    return ArcCW.GetTranslation(phrase, format) or str
end

-- Adds a translated string for a specific language's phrase. lang defaults to English.
function ArcCW.AddTranslation(phrase, str, lang)
    if phrase == nil or phrase == "" or str == nil or str == "" then return nil end
    lang = lang and string.lower(lang) or "en"
    ArcCW.LangTable[lang] = ArcCW.LangTable[lang] or {}
    ArcCW.LangTable[lang][string.lower(phrase)] = str
end

-- Translates an ammo string. If enabled, we will use our custom names (pulse -> rifle, smg -> carbine);
-- Otherwise returns the in-game translation for it.
function ArcCW.TranslateAmmo(ammo)
    if isnumber(ammo) then ammo = game.GetAmmoName(ammo) end
    if !ammo or !isstring(ammo) then return nil end
    ammo = string.lower(ammo)

    local lang = ArcCW.GetLanguage()
    local str = "ammo." .. ammo
    if SERVER or ArcCW.ConVars["ammonames"]:GetBool() then
        if ArcCW.LangTable[lang] and ArcCW.LangTable[lang][str] then
            return ArcCW.LangTable[lang][str]
        elseif ArcCW.LangTable["en"][str] then
            return ArcCW.LangTable["en"][str]
        end
    end
    return SERVER and (ammo .. " ammo") or language.GetPhrase(ammo .. "_ammo")
end

if CLIENT then
    function ArcCW.LoadClientLanguage(files)
        local lang = ArcCW.GetLanguage()
        files = files or file.Find("arccw/client/cl_languages/*", "LUA")

        local lang_tbl = {}
        local lang_tbl_en = {}

        for _, v in pairs(files) do
            local exp = string.Explode("_", string.lower(string.Replace(v, ".lua", "")))
            if lang != "en" and exp[#exp] == lang then
                include("arccw/client/cl_languages/" .. v)
                for phrase, str in pairs(L) do
                    lang_tbl[phrase] = str
                end
                print("Loaded ArcCW cl_language file " .. v .. " with " .. table.Count(L) .. " strings.")
                L = nil
            elseif exp[#exp] == "en" then
                -- Always load english as backup
                include("arccw/client/cl_languages/" .. v)
                for phrase, str in pairs(L) do
                    lang_tbl_en[phrase] = str
                end
            end
        end
        table.Merge(lang_tbl_en, lang_tbl)
        for phrase, str in pairs(lang_tbl_en) do
            language.Add(phrase, str)
        end
    end
elseif SERVER then
    for _, v in pairs(file.Find("arccw/client/cl_languages/*", "LUA")) do
        AddCSLuaFile("arccw/client/cl_languages/" .. v)
    end
end

function ArcCW.LoadLanguages()
    ArcCW.LangTable = {}
    for _, v in pairs(file.Find("arccw/shared/languages/*", "LUA")) do
        include("arccw/shared/languages/" .. v)
        AddCSLuaFile("arccw/shared/languages/" .. v)

        local exp = string.Explode("_", string.lower(string.Replace(v, ".lua", "")))
        local lang = exp[#exp]

        if !lang then
            print("Failed to load ArcCW language file " .. v .. ", did not get language name (naming convention incorrect?)")
            continue
        elseif !L then
            print("Failed to load ArcCW language file " .. v .. ", did not get language table")
            continue
        end

        for phrase, str in pairs(L) do
            ArcCW.AddTranslation(phrase, str, lang)
        end

        -- Load StringToLang stuff incase it is needed
        if STL then
            for str, phrase in pairs(STL) do
                ArcCW.AddStringToLang(str, phrase)
            end
        end

        print("Loaded ArcCW language file " .. v .. " with " .. table.Count(L) .. " strings.")
        L = nil
        STL = nil
    end

    if CLIENT then
        ArcCW.LoadClientLanguage()
    end

    hook.Run("ArcCW_LocalizationLoaded")
end

ArcCW.LoadLanguages()
hook.Add("PreGamemodeLoaded", "ArcCW_Lang", function()
    if CLIENT and ArcCW.ConVars["ammonames"]:GetBool() then
        local ourlang = ArcCW.GetLanguage()
        for _, name in pairs(game.GetAmmoTypes()) do
            if ArcCW.LangTable[ourlang] and ArcCW.LangTable[ourlang]["ammo." .. string.lower(name)] then
                language.Add(name .. "_ammo", ArcCW.LangTable[ourlang]["ammo." .. string.lower(name)])
            elseif ArcCW.LangTable["en"]["ammo." .. string.lower(name)] then
                language.Add(name .. "_ammo", ArcCW.LangTable["en"]["ammo." .. string.lower(name)])
            end
        end
    end
end)

concommand.Add("arccw_reloadlangs", function(ply)
    if SERVER and !game.SinglePlayer() and IsValid(ply) and !ply:IsSuperAdmin() then return end

    ArcCW.LoadLanguages()
    if SERVER and game.SinglePlayer() then
        net.Start("arccw_sp_reloadlangs")
        net.Broadcast()
    end
end, nil, "Reloads all language files.")

if game.SinglePlayer() then
    net.Receive("arccw_sp_reloadlangs", function()
        ArcCW.LoadLanguages()
    end)
end

--lua/arccw/shared/languages/uc_en.lua:
L = {}

L["uc.title"] = "Urban Coalition"

L["uc.auto"] = "Fully automatic fire"
L["uc.3burst"] = "3-round burst fire"
L["uc.semionly"] = "Semi-automatic fire only"
L["uc.manual"] = "Weapon becomes manual action"
L["uc.manualonly"] = "Manual action only"
L["uc.nofs"] = "Inaccurate without optics"
L["uc.altnofs"] = "Inaccurate without optics. Too bad you can't equip any!"
L["uc.overheat"] = "Will overheat under sustained use"
L["uc.jam"] = "Will occasionally jam"
L["uc.homeboy"] = "Recoil becomes diagonal"
L["uc.pointman"] = "+15% Fire rate on semi-automatic weapons"
L["uc.match.1"] = "-25% Recoil for first shot"
L["uc.match.2"] = "-50% Trigger delay time"
L["uc.slam"] = "Slamfire firemode"
L["uc.invistracer"] = "Invisible tracers"
L["uc.frcd_visrec"] = "+100% Visual recoil"
L["uc.frcd_burst"] = "Worse performance on burst-fire weapons"
L["uc.cosmetic"] = "This attachment is entirely cosmetic."
L["uc.dualstage.pro"] = "-100% Trigger delay time"
L["uc.dualstage.con"] = "+0.1s Delay on first shot"--"-25% Fire rate for first shot"
L["uc.operator"] = "-80% Visual recoil"
L["uc.overload"] = "+1 Magazine capacity"
L["uc.underload"] = "-14% Magazine capacity"
L["uc.loosesprings"] = "+8% Magazine capacity"
L["uc.neverflinch"] = "No shooting movement speed loss"
L["uc.tracer"] = "Visible bullet trail"
L["uc.lowind"] = "Low ammo indication"
L["uc.alwaysphys"] = "Bullet has travel time"
L["uc.explode"] = "Blast damage on hit"
L["uc.reqslug"] = "Only usable with slug ammo types"
L["uc.oneprojectile"] = "One projectile"
L["uc.bus"] = "Double-tap +USE to toggle backup sights"
L["uc.light"] = "Increased visibility"
L["uc.technician"] = "-35% Malfunction fix time"
L["uc.flashhider"] = "Reduced muzzle flash"
L["uc.dragon"] = "Increased muzzle flash"
L["uc.subsonic"] = "No distant tail when suppressed"
L["uc.subsonic.vel"] = "339m/s Muzzle velocity"
L["uc.api.1"] = "Increased damage to objects"
L["uc.api.2"] = "Deals fire damage"
L["uc.swapreticle"] = "Double-tap +USE to toggle reticles"
L["uc.infiniteammo"] = "Infinite ammo"
L["uc.noprojectile"] = "No projectile"
L["uc.baton"] = "Target may drop their weapon"
L["uc.ignite"] = "Ignites targets"
L["uc.custcolor"] = "Use the menu in \"Utilities -> ArcCW -> Urban Coalition\" to modify color."
L["uc.supptail"] = "No distant tail if muzzle velocity < 340m/s"
L["uc.ubgl"] = "Underbarrel grenade launcher"
L["uc.confetti"] = "Pretty"

L["uc.nooptics"] = "Disables Optic attachments"
L["uc.noubs"] = "Disables Underbarrel attachments"
L["uc.nostocks"] = "Disables Stock attachments"
L["uc.nomuzzle"] = "Disables Muzzle attachments"
L["uc.nogrip"] = "Disables Grip Type attachments"
L["uc.nopowder"] = "Disables Powder Load attachments"
L["uc.muzzleblocking"] = "Incompatible with certain Tube and Barrel combinations"
L["uc.nohg"] = "Disables Handguard attachments"

L["uc.exclusive.pistol"] = "Exclusive to small caliber firearms"
L["uc.exclusive.rifle"] = "Exclusive to medium caliber firearms"
L["uc.exclusive.shotgun"] = "Exclusive to shotguns"
L["uc.exclusive.762"] = "Exclusive to Eastern rifle caliber firearms"
L["uc.exclusive.545"] = "Exclusive to Eastern carbine caliber firearms"
L["uc.exclusive.subsonic"] = "Exclusive to small caliber firearms with < 340m/s muzzle velocity"

L["uc.pellet.0.75"] = "-25% Pellets per shot"
L["uc.pellet.2x"] = "+100% Pellets per shot"
L["uc.pellet.8"] = "+8 Pellets per shot"
L["uc.pellet.12"] = "+12 Pellets per shot"
L["uc.pellet.24"] = "+24 Pellets per shot"
L["uc.penetration.8"] = "+8mm Penetration"
L["uc.penetration.12"] = "+12mm Penetration"
L["uc.sightdisp.50"] = "+50 MOA Dispersion in sights"
L["uc.disp.50"] = "+50 MOA Dispersion"
L["uc.disp.100"] = "+100 MOA Dispersion"
L["uc.accuracy.10"] = "+10 MOA Imprecision"
L["uc.accuracy.20"] = "+20 MOA Imprecision"
L["uc.accuracy.35"] = "+35 MOA Imprecision"

L["uc.40mm.nodmg"] = "No blast damage"
L["uc.40mm.mindmg"] = "Minimal blast damage"
L["uc.40mm.buckshot"] = "Fires pellets instead of a projectile"
L["uc.40mm.hornet"] = "Fires bullets instead of a projectile"
L["uc.40mm.incendiary"] = "Creates fire on detonation"
L["uc.40mm.napalm"] = "Creates napalm on detonation"
L["uc.40mm.flash"] = "Blinds targets on detonation"
L["uc.40mm.smoke"] = "Creates smokescreen on detonation"
L["uc.40mm.impact"] = "High impact damage"
L["uc.40mm.hedp"] = "Penetrates walls on impact"
L["uc.40mm.airburst"] = "Creates shrapnel on detonation"
L["uc.40mm.proximity"] = "Projectile detonates by proximity"
L["uc.40mm.arm"] = "0.2 second arm time"
L["uc.40mm.drag.high"] = "Projectile has high drag"
L["uc.40mm.drag.low"] = "Projectile has low drag"
L["uc.40mm.blast.high"] = "Increased blast radius"
L["uc.40mm.blast.low"] = "Reduced blast radius"

L["fcg.slam"] = "Slam-fire"
L["fcg.slam.abbrev"] = "SLAM"
L["fcg.frcd"] = "Forced-reset"
L["fcg.frcd.abbrev"] = "FRCD"
--addons/arccw_base_modified/lua/arccw/client/cl_languages/en.lua:
-- These strings are loaded into GMod's language library instead of our custom one.
-- They are only to be used in the options menu.
L = {}

-- Generic
L["arccw.adminonly"]                      = "These options require admin privileges to change. They are automatically networked in multiplayer games."
L["arccw.clientcfg"]                      = "All options in this menu can be customized by players, and do not need admin privileges."
-- Menus
L["arccw.menus.hud"]                      = "HUD"
L["arccw.menus.client"]                   = "Client"
L["arccw.menus.vmodel"]                   = "Viewmodel"
L["arccw.menus.perf"]                     = "Performance"
L["arccw.menus.server"]                   = "Server"
L["arccw.menus.mults"]                    = "Modifiers"
L["arccw.menus.npcs"]                     = "NPCs"
L["arccw.menus.atts"]                     = "Attachments"
L["arccw.menus.ammo"]                     = "Ammo"
L["arccw.menus.dev"]                      = "Developer"
L["arccw.menus.xhair"]                    = "Crosshair"
L["arccw.menus.bullet"]                   = "Bullet Physics"
L["arccw.menus.scopes"]                   = "Scopes"
L["arccw.bullet_help"]                    = "\nEnabling physical bullets in multiplayer may reduce the reliability of hit detection."
-- ArcCW_Options_Ammo
L["arccw.cvar.ammo_detonationmode"]       = "Ammo Detonation"
L["arccw.cvar.ammo_detonationmode.desc"]  = "-1 - don't explode\n 0 - simple explosion\n 1 - fragmentation\n 2 - frag + burning"
L["arccw.cvar.ammo_autopickup"]           = "Auto Pickup"
L["arccw.cvar.ammo_largetrigger"]         = "Large Pickup Trigger"
L["arccw.cvar.ammo_rareskin"]             = "Rare Skin Chance"
L["arccw.cvar.ammo_chaindet"]             = "Chain Detonation"
L["arccw.cvar.mult_ammohealth"]           = "Ammo Health (-1 for indestructible)"
L["arccw.cvar.mult_ammoamount"]           = "Ammo Amount"
-- ArcCW_Options_HUD
L["arccw.cvar.hud_showhealth"]            = "Show Health"
L["arccw.cvar.hud_showhealth.desc"]       = "Draw a custom health & armor counter."
L["arccw.cvar.hud_showammo"]              = "Show Ammo"
L["arccw.cvar.hud_showammo.desc"]         = "Custom ammo counter with firemode info and weapon name."
L["arccw.3d2d"]                           = "\n3D2D HUD" -- Obsolete
L["arccw.cvar.hud_3dfun"]                 = "Use 3D2D Ammo HUD"
L["arccw.cvar.hud_3dfun.desc"]            = "Use a 3D2D ammo counter."
L["arccw.cvar.hud_3dfun_decay"]           = "HUD Decay Time"
L["arccw.cvar.hud_3dfun_decay.desc"]      = "Time until the HUD starts fading away.\nSet to 0 to always stay visible."
L["arccw.cvar.hud_minimal"]               = "Allow Backup Ammo HUD"
L["arccw.cvar.hud_minimal.desc"]          = "If we can't draw our own HUD, use a minimal one."
L["arccw.cvar.hud_forceshow"]             = "Force HUD On"
L["arccw.cvar.hud_forceshow.desc"]        = "Don't play by the rules and draw our HUD anyways."
L["arccw.cvar.hudpos_deadzone_x"]         = "Deadzone X"
L["arccw.cvar.hudpos_deadzone_y"]         = "Deadzone Y"
L["arccw.cvar.hudpos_deadzone.desc"]      = "Use ArcCW on your HDTV!"
L["arccw.cvar.hudpos_size"]               = "HUD and Font Size"
L["arccw.cvar.hudpos_size.desc"]          = "Custom HUD scaling."
-- ArcCW_Options_Bullet
L["arccw.cvar.bullet_enable"]             = "Physical Bullets"
L["arccw.cvar.enable_penetration"]        = "Enable Penetration"
L["arccw.cvar.enable_ricochet"]           = "Enable Ricochet"
L["arccw.cvar.bullet_gravity"]            = "Gravity"
L["arccw.cvar.bullet_drag"]               = "Drag"
L["arccw.cvar.bullet_lifetime"]           = "Despawn Time"
L["arccw.cvar.bullet_velocity"]           = "Multiply Velocity"
L["arccw.cvar.bullet_imaginary"]          = "Imaginary Bullets"
L["arccw.cvar.bullet_imaginary.desc"]     = "Bullets will appear to continue to travel through the 3D skybox."
-- ArcCW_Options_Client
L["arccw.cvar.automaticreload"]           = "Automatic Reload"
L["arccw.cvar.automaticreload.desc"]      = "Automatically reload when your clip is empty."
L["arccw.cvar.toggleads"]                 = "Toggle Aim"
L["arccw.cvar.altfcgkey"]                 = "USE + RELOAD Toggles Firemode"
L["arccw.cvar.altubglkey"]                = "USE + RMB Toggles Underbarrel"
L["arccw.cvar.altsafety"]                 = "Hold Walk to Toggle Safety"
L["arccw.cvar.altlaserkey"]               = "E+WALK To Toggle Laser (Default WALK+E)"
L["arccw.cvar.autosave"]                  = "Autosave Attachments"
L["arccw.cvar.autosave.desc"]             = "Attempt to re-equip the last equipped set of attachments on weapon pickup."
L["arccw.cvar.embracetradition"]          = "Classic Customization HUD"
L["arccw.cvar.embracetradition.desc"]     = "Use the classic bulky customization HUD. Embrace tradition. Good on 4:3."
L["arccw.cvar.glare"]                     = "Scope Glare"
L["arccw.cvar.glare.desc"]                = "Glare visible on your scope lens when aiming."
L["arccw.cvar.shake"]                     = "Screen Shake"
L["arccw.cvar.shakevm"]                   = "Viewmodel Shake"
L["arccw.cvar.shake_info"]                = "Aggressive snap when you shoot a weapon."
L["arccw.cvar.2d3d"]                      = "Draw Help Text"
L["arccw.cvar.2d3d_info"]                 = "Draw name of weapons, ammo and attachments on the ground."
L["arccw.cvar.attinv_hideunowned"]        = "Hide Unowned Attachments"
L["arccw.cvar.attinv_darkunowned"]        = "Grey Out Unowned Attachments"
L["arccw.cvar.attinv_onlyinspect"]        = "Hide Customization UI"
L["arccw.cvar.attinv_simpleproscons"]     = "Simple Pros And Cons"
L["arccw.cvar.attinv_closeonhurt"]        = "Close menu on damage taken"
L["arccw.cvar.language"]                  = "Language"
L["arccw.cvar.language_info"]             = "Override the language. Leave blank for gmod_language."
L["arccw.cvar.font"]                      = "Font"
L["arccw.cvar.font_info"]                 = "Override the font. Leave blank for default."
-- ArcCW_Options_Perf
L["arccw.performance"]                    = "The options below may change performance."
L["arccw.cvar.cheapscopes"]               = "Cheap Scopes"
L["arccw.cvar.cheapscopes.desc"]          = "A cheaper PIP scope implementation like in modern games. Saves a significant amount of performance on big maps. \nYou can configure it in 'Scopes' tab."
L["arccw.cvar.cheapscopesv2_ratio"]       = "FOV Boost"
L["arccw.cvar.cheapscopesv2_ratio.desc"]  = "Cheap Scope field of view boost ratio. 0 is full FOV and full quality scope, 1 is default FOV with low quality scope."
L["arccw.cvar.cheapscopesv2.desc"]        = "A cheaper PIP scope implementation like in modern games."
L["arccw.cvar.scopepp"]                   = "Scope chromatic aberration"
L["arccw.cvar.thermalpp"]                 = "Thermal scope post-processing effects"
L["arccw.cvar.scopepp_refract"]           = "Scope lense refract effect (experimental)"
L["arccw.cvar.scopepp_refract_ratio"]     = "Refract ratio"
--["arccw.cvar.flatscopes"]                = "Flat Scopes"
--L["arccw.cvar.flatscopes.desc"]           = "For the ultimate performance gain.\nUse a traditional-style scope implementation that's not very impressive, but actually saves performance relative to even being unscoped."
L["arccw.cvar.muzzleeffects"]             = "Enable World Muzzle Effects"
L["arccw.cvar.fastmuzzles"]               = "Low Performance Muzzle Effects"
L["arccw.cvar.fasttracers"]               = "Low Performance Tracer Effects"
L["arccw.cvar.shelleffects"]              = "Enable World Case Effects"
L["arccw.cvar.att_showothers"]            = "Show Others' Attachments"
L["arccw.cvar.shelltime"]                 = "Case Lifetime"
L["arccw.cvar.blur"]                      = "Customization Blur"
L["arccw.cvar.blur_toytown"]              = "Aim Blur"
L["arccw.cvar.visibility"]                = "Worldmodel Visibility"
L["arccw.cvar.visibility.desc"]           = "Attachments will not render past this distance. -1 for always render."
-- ArcCW_Options_Viewmodel
L["arccw.cvar.vm_coolsway"]               = "Custom Swaying"
L["arccw.cvar.vm_coolview"]               = "Custom Camera Movement"
L["arccw.cvar.drawbarrel"]                = "Draw barrel in RT scopes (experimental)"
L["arccw.cvar.vm_addads"]                 = "Viewmodel FOV in ADS"
L["arccw.cvar.vm_right"]                  = "Viewmodel Right"
L["arccw.cvar.vm_forward"]                = "Viewmodel Forward"
L["arccw.cvar.vm_up"]                     = "Viewmodel Up"
L["arccw.cvar.vm_pitch"]                  = "Viewmodel Pitch"
L["arccw.cvar.vm_yaw"]                    = "Viewmodel Yaw"
L["arccw.cvar.vm_roll"]                   = "Viewmodel Roll"
L["arccw.cvar.vm_fov"]                    = "Viewmodel FOV"
L["arccw.cvar.vm_offsetwarn"]             = "Warning! Viewmodel offset settings may cause clipping or other undesired effects!"
L["arccw.cvar.vm_sway_sprint"]            = "Sprint Bob" -- This is intentionally flipped
L["arccw.cvar.vm_bob_sprint"]             = "Sprint Sway" -- Ditto
L["arccw.cvar.vm_swaywarn"]               = "The following only applies when Custom Swaying is enabled"
L["arccw.cvar.vm_look_ymult"]              = "Horizontal Look Sway"
L["arccw.cvar.vm_look_xmult"]              = "Vertical Look Sway"
L["arccw.cvar.vm_sway_xmult"]              = "Bob Right"
L["arccw.cvar.vm_sway_ymult"]              = "Bob Forward"
L["arccw.cvar.vm_sway_zmult"]              = "Bob Up"
L["arccw.cvar.vm_sway_wigglemult"]         = "Bob Wiggle"
L["arccw.cvar.vm_sway_speedmult"]          = "Bob Speed"
L["arccw.cvar.vm_sway_rotatemult"]         = "Bob Rotate"

L["arccw.cvar.vm_accelmult"]              = "Sway Tightness"
L["arccw.cvar.vm_viewwarn"]               = "The following only applies when Custom Camera Movement is enabled"
L["arccw.cvar.vm_coolviewmult"]           = "View Move Multiplier"
-- ArcCW_Options_Crosshair
L["arccw.crosshair.tfa"]                  = "TFA"
L["arccw.crosshair.cw2"]                  = "CW 2.0"
L["arccw.crosshair.cs"]                   = "Counter-Strike"
L["arccw.crosshair.light"]                = "Lightweight"
L["arccw.cvar.crosshair"]                 = "Enable Crosshair"
L["arccw.cvar.crosshair_length"]          = "Crosshair Length"
L["arccw.cvar.crosshair_thickness"]       = "Crosshair Thickness"
L["arccw.cvar.crosshair_gap"]             = "Crosshair Gap Scale"
L["arccw.cvar.crosshair_dot"]             = "Show Center Dot"
L["arccw.cvar.crosshair_shotgun"]         = "Use Shotgun Prongs"
L["arccw.cvar.crosshair_equip"]           = "Use Equipment Prongs"
L["arccw.cvar.crosshair_static"]          = "Static Crosshair"
L["arccw.cvar.crosshair_trueaim"]          = "Accurate Crosshair"
L["arccw.cvar.crosshair_clump"]           = "Use CW2-Style Clump Circle"
L["arccw.cvar.crosshair_clump_outline"]   = "Clump Circle Outline"
L["arccw.cvar.crosshair_clump_always"]    = "Clump Circle Always On"
L["arccw.cvar.crosshair_clr"]             = "Crosshair Color"
L["arccw.cvar.crosshair_outline"]         = "Outline Size"
L["arccw.cvar.crosshair_outline_clr"]     = "Outline Color"
L["arccw.cvar.scope_clr"]                 = "Sight Color"
-- ArcCW_Options_Mults
L["arccw.cvar.mult_damage"]               = "Damage"
L["arccw.cvar.mult_npcdamage"]            = "NPC Damage"
L["arccw.cvar.mult_range"]                = "Range"
L["arccw.cvar.mult_recoil"]               = "Recoil"
L["arccw.cvar.mult_penetration"]          = "Penetration"
L["arccw.cvar.mult_accuracy"]             = "Precision"
L["arccw.cvar.mult_hipfire"]              = "Hip Dispersion"
L["arccw.cvar.mult_movedisp"]             = "Move Dispersion"
L["arccw.cvar.mult_reloadtime"]           = "Reload Time"
L["arccw.cvar.mult_sighttime"]            = "ADS Time"
L["arccw.cvar.mult_defaultclip"]          = "Default Clip"
L["arccw.cvar.mult_attchance"]            = "Random Att. Chance"
L["arccw.cvar.mult_heat"]                 = "Heat Gain"
L["arccw.cvar.mult_shootwhilesprinting"]  = "Shoot While Sprinting"
-- ArcCW_Options_Atts
L["arccw.attdesc1"]                       = "ArcCW supports attachment inventory style behaviour (Like ACT3) as well as attachment locking style behaviour (Like CW2.0) as well as giving everyone all attachments for free (Like TFA Base)."
L["arccw.attdesc2"]                       = "Leave all options off for ACT3 style attachment inventory behaviour."
L["arccw.cvar.attinv_free"]               = "Free Attachments"
L["arccw.cvar.attinv_lockmode"]           = "Attachment Locking"
L["arccw.cvar.attinv_loseondie.desc"]     = "Lose Attachments Modes:\n0 - Disable\n1 = Removed on death\n2 = Drop Attachment Box on death"
L["arccw.cvar.attinv_loseondie"]          = "Lose Atts. On Death"
L["arccw.cvar.atts_pickx.desc"]           = "Pick X behaviour allows you to set a limit on attachments that can be placed on any weapon.\n0 = unlimited."
L["arccw.cvar.atts_pickx"]                = "Pick X"
L["arccw.cvar.enable_dropping"]           = "Attachment Dropping"
L["arccw.cvar.atts_spawnrand"]            = "Random Attachments on Spawn"
L["arccw.cvar.atts_ubglautoload"]         = "Underbarrel Weapons Automatically Loaded"
L["arccw.blacklist"]                      = "Blacklist Menu"
-- ArcCW_Options_Server
L["arccw.cvar.enable_customization"]      = "Enable Customization"
L["arccw.cvar.enable_customization.desc"] = "-1 will disable both customization and the entirety of the Customization UI.\n0 will not allow users to customize their weapons.\n1 will allow customization, the default."
L["arccw.cvar.truenames"]                 = "True Names (Requires Restart)"
L["arccw.cvar.equipmentammo.desc"]        = "There is a limit of 255 ammo types, and enabling this option can cause problems related to this. Requires restart."
L["arccw.cvar.equipmentammo"]             = "Equipment Unique Ammo Types"
L["arccw.cvar.equipmentsingleton.desc"]   = "Singletons can be used once and then remove themselves from your inventory. Requires restart."
L["arccw.cvar.equipmentsingleton"]        = "Grenade/Equipment Singleton"
L["arccw.cvar.equipmenttime"]             = "Equipment Self-Destruct Time"
L["arccw.cvar.throwinertia"]              = "Grenade Inherit Velocity"
L["arccw.cvar.limityear_enable"]          = "Enable Year Limit"
L["arccw.cvar.limityear"]                 = "Year Limit"
L["arccw.cvar.override_crosshair_off"]    = "Force Disable Crosshair"
L["arccw.cvar.override_barrellength"]     = "Enable Near-Walling"
L["arccw.cvar.doorbust"]                  = "Enable Door-Busting"
L["arccw.cvar.desync"]                    = "Desync Bullets"
L["arccw.cvar.desync.desc"]               = "Desync bullets between the server and the client, making the nospread cheat useless."
L["arccw.cvar.weakensounds"]              = "Weaken Sounds"
L["arccw.cvar.weakensounds.desc"]         = "Reduce all weapons' firing volume by this much decibels, making it easier to hide shooting sounds. Clamped to 60-150dB."
-- ArcCW_Options_Dev
L["arccw.dev_info1"]                      = "These are primarily related to attachments and are of use to developers only."
L["arccw.dev_info2"]                      = "Settings will not save."
L["arccw.cvar.dev_reloadonadmincleanup"]  = "Reload on Admin Cleanup"
L["arccw.cvar.dev_reloadonadmincleanup.desc"]    = "Disabled by default.\nDoing an admin cleanup will reload all attachment data."
L["arccw.cvar.dev_registerentities"]      = "Register Att. Entities"
L["arccw.cvar.dev_registerentities.desc"] = "Enabled by default.\nCreates entities for ArcCW attachments. Increases time to reload attachment data."
L["arccw.cvar.dev_reloadatts"]            = "Reload Attachment Data"
L["arccw.cvar.dev_reloadatts.desc"]       = "Reloads attachment data. Use after making a change to an attachment."
L["arccw.cvar.dev_reloadlangs"]           = "Reload Languages"
L["arccw.cvar.dev_reloadlangs.desc"]      = "Reloads all language files."
L["arccw.cvar.dev_spawnmenureload"]       = "Reload Spawnmenu"
L["arccw.cvar.dev_spawnmenureload.desc"]  = "Not exactly an ArcCW specific command, but here for the sake of convenience."
-- TTT Menus
L["arccw.cvar.attinv_loseondie.help"]     = "If enabled, players lose attachment on death and round end."
L["arccw.cvar.ammo_detonationmode.help"]  = "Determines what happens if ammo boxes are destroyed."
L["arccw.cvar.equipmenttime.help"]        = "Applies to deployable equipment like Claymores, in seconds."
L["arccw.cvar.ttt_bodyattinfo"]           = "Body Attachment Info"
L["arccw.cvar.ttt_bodyattinfo.help"]      = "If enabled, searching a body will reveal the attachments on the weapon used to kill someone."
L["arccw.cvar.ttt_bodyattinfo.desc"]      = "0 - Off; 1 - Detectives can see; 2 - Everyone can see"
L["arccw.cvar.attinv_free.help"]          = "If enabled, players have access to all attachments.\nCustomization mode may still restrict them from using them."
L["arccw.cvar.attinv_lockmode.help"]      = "If enabled, picking up one attachment unlocks it for every weapon, a-la CW2."
L["arccw.cvar.enable_customization.help"] = "If disabled, nobody can customize. This overrides Customization Mode."
L["arccw.cvar.ttt_replace"]               = "Auto-replace Weapons"
L["arccw.cvar.ttt_replaceammo"]           = "Auto-replace Ammo"
L["arccw.cvar.ttt_atts"]                  = "Randomize Attachments"
L["arccw.cvar.ttt_customizemode"]         = "Customization Mode"
L["arccw.cvar.ttt_customizemode.desc"]    = "0 - No restrictions; 1 - Restricted; 2 - Pregame only; 3 - Traitor/Detective only"
L["arccw.cvar.ttt_rolecrosshair"]         = "Enable role-based crosshair color"
L["arccw.cvar.ttt_inforoundstart"]        = "Enable round startup info"

-- 2020-11-22
L["arccw.cvar.ammo_replace"]              = "Replace HL2 Ammo Entities"

-- 2020-11-25
L["arccw.cvar.hud_3dfun_lite"]            = "Minimal Mode"
L["arccw.cvar.hud_3dfun_lite.desc"]       = "HUD will only show up when pressing RELOAD. Hold WALK to not reload when doing so."
L["arccw.cvar.hud_3dfun_right"]           = "3D2D Offset Right"
L["arccw.cvar.hud_3dfun_forward"]         = "3D2D Offset Forward"
L["arccw.cvar.hud_3dfun_up"]              = "3D2D Offset Up"
L["arccw.cvar.hud_3dfun_ammotype"]        = "Show Ammo Type"
L["arccw.cvar.hud_3dfun_ammotype.desc"]   = "Ammo HUD will also show weapon's current ammo type."

-- 2021-01-03
L["arccw.combobox.disabled"]              = "0 - Disabled"
L["arccw.cvar.attinv_loseondie.1"]        = "1 - Removed on death"
L["arccw.cvar.attinv_loseondie.2"]        = "2 - Drop attachment box on death"
L["arccw.cvar.ammo_detonationmode.-1"]    = "-1 - Don't explode"
L["arccw.cvar.ammo_detonationmode.0"]     = "0 - Simple explosion"
L["arccw.cvar.ammo_detonationmode.1"]     = "1 - Fragmentation"
L["arccw.cvar.ammo_detonationmode.2"]     = "2 - Frag + Burning"
L["arccw.cvar.enable_customization.-1"]   = "-1 - Disable UI and all customization"
L["arccw.cvar.enable_customization.0"]    = "0 - Players cannot customize"
L["arccw.cvar.enable_customization.1"]    = "1 - Enabled"
L["arccw.cvar.limityear.desc"]            = "If enabled, weapons with a trivia year later than the limit cannot be spawned.\nGood for gmod realism."

-- 2021-01-05
L["arccw.menus.binds"]                    = "Binds"
L["arccw.bindhelp"]                       = "All players can use this panel to set custom bindings for ArcCW features.\n\nBecause of a Garry's Mod limitation, for custom binds you must input the command provided in chat into the console yourself."
L["arccw.cvar.altbindsonly"]              = "Custom Binds Only"
L["arccw.cvar.altbindsonly.desc"]         = "If enabled, default controls will no longer work with ArcCW weapons. Please ensure all of the below buttons are bound so you have access to them."
L["arccw.bind.firemode"]                  = "Change Firemode"
L["arccw.bind.zoom_in"]                   = "Scope Zoom In"
L["arccw.bind.zoom_out"]                  = "Scope Zoom Out"
L["arccw.bind.toggle_inv"]                = "Customize Menu"
L["arccw.bind.switch_scope"]              = "Toggle Sights"
L["arccw.bind.toggle_ubgl"]               = "Toggle Underbarrel"
L["arccw.bind.melee"]                     = "Melee"
L["arccw.bind.msg"]                       = "Type into console: "

-- 2021-01-14
L["arccw.cvar.mult_startunloaded"]        = "Start Unloaded"
L["arccw.cvar.mult_defaultammo"]          = "Default Ammo"

-- 2021-01-18
L["arccw.cvar.dev_showignored"]           = "Load Ignored Atts"
L["arccw.cvar.dev_showignored.desc"]      = "Disabled by default.\nLoad attachments that have att.Ignore set to true. These attachments may be broken or unimplemented.\nThey will be highlighted in light yellow."
L["arccw.cvar.aimassist"]                 = "Enable Aim Assist"
L["arccw.cvar.aimassist.desc"]            = "Allow players to snap their view to NPCs and players near their aim."
L["arccw.cvar.aimassist_cl.desc"]         = "Snap your view to nearby NPCs and players. Only usable if enabled serverside!"
L["arccw.cvar.aimassist_head"]            = "Aim Assist Seeks Head"
L["arccw.cvar.aimassist_cone"]            = "Aim Assist Cone"
L["arccw.cvar.aimassist_distance"]        = "Aim Assist Distance"
L["arccw.cvar.aimassist_intensity"]       = "Aim Assist Intensity"

-- 2021-01-19
L["arccw.cvar.adjustsensthreshold"]       = "Adjust Sensitivity Threshold"
L["arccw.cvar.adjustsensthreshold.desc"]  = "If your total magnification is less than this, your sensitivity will not be adjusted while in sights."

-- 2021-01-20
L["arccw.cvar.crosshair_aa"]              = "Aim Assist Indicator"

-- 2021-1-25
L["arccw.menus.ttt_client"]               = "TTT (Client)"
L["arccw.menus.ttt_server"]               = "TTT (Server)"
L["arccw.ttt_clienthelp"]                 = "These options are TTT-specific, and can be changed by all players. Other tabs may contain non-TTT-specific configurations."
L["arccw.ttt_serverhelp"]                 = "These options are TTT-specific, and require admin privileges to change. They are automatically networked in multiplayer games."
L["arccw.cvar.ttt_customizemode.0"]       = "0 - Unrestricted"
L["arccw.cvar.ttt_customizemode.1"]       = "1 - Restricted"
L["arccw.cvar.ttt_customizemode.2"]       = "2 - Pre-game only"
L["arccw.cvar.ttt_customizemode.3"]       = "3 - Detectives/Traitors only"
L["arccw.cvar.ttt_bodyattinfo.1"]         = "1 - Detectives can see"
L["arccw.cvar.ttt_bodyattinfo.2"]         = "2 - Everyone can see"
L["arccw.cvar.mult_crouchdisp"]           = "Crouched Dispersion"
L["arccw.cvar.mult_crouchrecoil"]         = "Crouched Recoil"

-- 2021-2-19
L["arccw.cvar.dev_debug"]                 = "Debug Menu"
L["arccw.cvar.dev_debug.desc"]            = "Disabled by default.\nDraws a debug menu over your screen where you can view certain elements blah blah?"

L["arccw.cvar.attinv_sound"]              = "Customization Menu Sounds"
L["arccw.cvar.attinv_sound.desc"]         = "Enable or disable sounds for the customization menu."

-- 2021-3-2
L["arccw.ammohud"]                        = "\nAmmo HUD" -- Obsoletes "3D2D HUD" since they're basically the same now"
L["arccw.cvar.hud_fcgbars"]               = "Show Firemode Bars"
L["arccw.bind.toggle_att"]                = "Toggle Attachments"

-- 2021-05-05
L["arccw.cvar.attinv_gamemodebuttons"]    = "Gamemode-specific buttons"
L["arccw.cvar.attinv_gamemodebuttons.desc"] = "Shows helpful functions for gamemodes like TTT and DarkRP.\nIn addition to using these, you can hold USE to access original keybinds as well."

-- 2021-05-13
L["arccw.cvar.mult_malfunction"] = "Malfunction Chance"
L["arccw.cvar.malfunction"]    = "Malfunction Mode"
L["arccw.cvar.malfunction.0"]   = "0 - Force disable on all guns"
L["arccw.cvar.malfunction.1"]    = "1 - Enabled"
L["arccw.cvar.malfunction.2"]    = "2 - Force enable on all guns"

-- 2021-05-26
L["arccw.cvar.mult_meleedamage"] = "Melee Damage"
L["arccw.cvar.mult_meleetime"] = "Melee Time"

-- 2021-05-27
L["arccw.cvar.ammonames"] = "Custom Ammo Names"
L["arccw.cvar.ammonames.desc"] = "Replaces default ammo type names with custom ones that are a bit more realistic (such as Pulse Ammo to Rifle Ammo). Also replaces references everywhere else!"
L["arccw.cvar.att_showground"] = "Show Ground Attachments"

-- 2021-06-02
L["arccw.cvar.mult_bottomlessclip"] = "Bottomless Clip"
L["arccw.cvar.mult_infiniteammo"] = "Infinite Ammo"

-- 2021-06-07
L["arccw.cvar.bodydamagecancel"] = "Cancel Body Damage"
L["arccw.cvar.bodydamagecancel.desc"] = "When a weapon specifies limb damage modifiers, cancel Gmod's default multipliers. Disable when you have another mod that does this."

L["arccw.cvar.enable_sway"] = "Enable Sway"
L["arccw.cvar.enable_sway.desc"] = "Most weapons do not specify a sway value. If you wish to give sway to all weapons, use the 'Add Sway' slider."
L["arccw.cvar.add_sway"] = "Add Sway"
L["arccw.cvar.mult_sway"]    = "Multiply Sway"

-- 2021-08-15
L["arccw.cvar.mult_rpm"] = "Fire Rate"
L["arccw.cvar.mult_rpm.desc"] = "May be disastrous on performance. May also be a ton of fun."

-- 2021-08-16
L["arccw.cvar.dev_benchgun"] = "Benchgun"
L["arccw.cvar.dev_benchgun.desc"] = "Places the viewmodel in a stationary position, usually at world origin."
L["arccw.cvar.dev_benchgun_custom"] = "Benchgun Custom"
L["arccw.cvar.dev_benchgun_custom.desc"] = "Custom location to place the viewmodel at. Use getpos and place the result here.\nExample:\nsetpos 61 -397 -63;setang 0 96 0"

-- 2021-08-18
L["arccw.cvar.crosshair_prong_top"] = "Show Top Prong"
L["arccw.cvar.crosshair_prong_left"] = "Show Left Prong"
L["arccw.cvar.crosshair_prong_right"] = "Show Right Prong"
L["arccw.cvar.crosshair_prong_bottom"] = "Show Bottom Prong"
L["arccw.cvar.crosshair_tilt"] = "Tilted Crosshair"
L["arccw.cvar.attinv_giveonspawn"] = "Give Atts. On Spawn"

-- 2021-10-10
L["arccw.cvar.hud_fcgabbrev"] = "Abbreviate Firemode Names"

-- 2021-10-31
L["arccw.cvar.reloadincust"] = "Reloading In Customize Menu"
L["arccw.cvar.reloadincust.desc"] = "May allow players to cheese reload times by swapping magazine attachments.\nWill also disable left hand lowering in the customize menu."

-- 2021-11-11
L["arccw.cvar.freeaim"] = "Free Aim"
L["arccw.cvar.freeaim.1"] = "1 - Enabled"
L["arccw.cvar.freeaim.2"] = "2 - No Dispersion Tweak"

-- 2021-11-24
L["arccw.cvar.override_lunge_off"] = "Disable Melee Lunging"
L["arccw.cvar.override_lunge_off.desc"] = "Bashing with a weapon can allow you to dash a short distance if there is a target in front. This option disables that momentum for all weapons."

-- 2021-11-27
L["arccw.cvar.mult_movespeed"] = "Speed"
L["arccw.cvar.mult_movespeedads"] = "Speed in ADS"
L["arccw.cvar.mult_movespeedfire"] = "Speed while firing"

-- 2022-02-14
L["arccw.cvar.vm_nearwall"] = "Near-wall Movement"
L["arccw.cvar.nohl2flash"] = "Toggle attachments modes through flashlight bind"

-- 2022-03-24
L["arccw.cvar.dev_alwaysready"] = "Always Use Ready Animation"
L["arccw.cvar.dev_alwaysready.desc"] = "Always use the ready animation while drawing when available."

L["arccw.cvar.noinspect"] = "Disable inspect animations"

-- 2022-07-10
L["arccw.cvar.override_hud_off"] = "Force Disable HUD"
L["arccw.hud_svwarning"] = "The HUD can be disabled serverside by a server administrator."

-- 2023-10-10
L["arccw.cvar.2d3d.1"]  = "1 - When Pointed At"
L["arccw.cvar.2d3d.2"]  = "2 - Always"
--addons/arccw_base_modified/lua/arccw/client/cl_glint.lua:
local rnd        = render
local r_lightcol = rnd.GetLightColor

local glintmat = Material("effects/blueflare1")

local players
local playerssaver = {}

hook.Add("PostDrawEffects", "ArcCW_ScopeGlint", function()
    if playerssaver != players then -- less calls on GetAll
        players      = player.GetAll()
        playerssaver = players
    end

    cam.Start3D()
        for _, ply in ipairs(players) do
            if !IsValid(ply) then continue end

            if ply == LocalPlayer() and !ply:ShouldDrawLocalPlayer() then continue end

            local wep = ply:GetActiveWeapon()

            if !(IsValid(wep) and wep.ArcCW) then continue end

            if !wep:GetBuff_Override("ScopeGlint") then continue end

            if wep:GetState() != ArcCW.STATE_SIGHTS then continue end

            local vec = (ply:EyePos() - EyePos()):GetNormalized()
            local dot = vec:Dot(-ply:EyeAngles():Forward())

            dot = (dot * dot * 1.75) - 0.75
            dot = dot * (0.5 + (1 - wep:GetSightDelta()) * 0.5)

            if dot < 0 then continue end

            local pos = ply:EyePos() + (ply:EyeAngles():Forward() * 16) + (ply:EyeAngles():Right() * 8)

            local _, scope_i = wep:GetBuff_Override("ScopeGlint")

            if scope_i then
                local world = (wep.Attachments[scope_i].WElement or {}).Model

                if world and IsValid(world) then
                    local att = world:LookupAttachment("holosight") or world:LookupAttachment("scope")

                    if att then pos = world:GetAttachment(att).Pos end
                end
            end

            local lcolpos = r_lightcol(pos):Length()
            local lcoleye = r_lightcol(EyePos()):Length()

            local mag       = wep:GetBuff_Mult("Mult_GlintMagnitude") or 1
            local intensity = math.min(0.2 + (lcolpos + lcoleye) / 2 * 1, 1) * mag
            local col       = 255 * intensity

            rnd.SetMaterial(glintmat)
            rnd.DrawSprite(pos, 96 * dot, 96 * dot, Color(col, col, col))
        end
    cam.End3D()
end)
--addons/arccw_weapons/lua/autorun/arccw_stattrack.lua:
if CLIENT then
    matproxy.Add({
        name = "StatTrakDigit",

        init = function(self, mat, values)
            self.Digit = values.displaydigit
            self.Number = values.resultvar
        end,
    
        bind = function(self, mat, ent)
            if !IsValid(ent) then return end
            mat:SetInt(self.Number, 0) -- resetting
            
            local wep = ent:GetTable().Weapon
            if !wep then return end

            local killcount = wep:GetNWInt("STKills", 0)
            
            if wep:CheckFlags(_, {"st_global"}) then
                killcount = wep:GetNWInt("STFileKills", 0)
            end

            mat:SetInt(self.Number, tonumber(string.Replace(string.format("%6d", killcount)[6 - self.Digit], " ", "10"))) --calling 10th frame for empty char (titanfall counters)
        end
    })

    net.Receive("arrcwstattracksave", function()
        local oldwep = net.ReadEntity()
        local wep = LocalPlayer():GetActiveWeapon()
        if oldwep and wep!=oldwep then return end

        if !IsValid(wep) or !wep.ArcCW then return end
            
        if file.Exists("arccw_stattrack.json", "DATA") then
		--print("We found a kills file, importing...")
		if !wep.FileKillsTable then
			wep.FileKillsTable = util.JSONToTable(file.Read("arccw_stattrack.json", "DATA") or "") or {}
			wep.FileKills = wep.FileKillsTable[wep:GetClass()] or 0
			wep:SetNWInt("STFileKills", wep.FileKills)
		end
			
		local filekills = net.ReadUInt(20)
		wep.FileKills = filekills
	end

        -- print(wep)
        local curtable = {[wep:GetClass()] = wep:GetNWInt("STFileKills", 0)}
        
        if table.IsEmpty(curtable) then return end

        local content = util.TableToJSON(table.Merge(wep.FileKillsTable or {}, curtable))
    
        -- print("saved to file kills - ", wep:GetNWInt("STFileKills"))
    
        file.Write("arccw_stattrack.json", content)

        timer.Remove(wep:EntIndex() .. "filesaving") -- to be sure
    end)

    concommand.Add("arccw_stattrack_reset", function(ply)
        file.Write("arccw_stattrack.json", "{}")
        print("Okay done")
        
        if IsValid(ply) then
            local wep = ply:GetActiveWeapon()
            if IsValid(wep) then
                wep.FileKills = 0
                net.Start("arrcwstattracksend")
                net.WriteUInt(0, 20)
                net.SendToServer()
            end
        end
    end)
else
    util.AddNetworkString("arrcwstattracksend")
    util.AddNetworkString("arrcwstattracksave")

    local nextfilesave = CurTime()

    local function stkill(attacker)
        if !IsValid(attacker) then return end
        if !attacker:IsPlayer() then return end
        
        local wep = attacker:GetActiveWeapon()
        if !IsValid(wep) then return end
        if !wep.ArcCW then return end
        if wep:CheckFlags(_, {"killcounter"}) then return end
        
        local stkills = 0
        stkills = wep:GetNWInt("STKills", 0)
        local stfilekills = 0 
        stfilekills = wep:GetNWInt("STFileKills", 0)
        
        wep:SetNWInt("STFileKills", stfilekills+1)
        wep:SetNWInt("STKills", stkills+1)
    end

    hook.Add("OnNPCKilled", "ArcCWStattrack.KillNPC", function(npc, attacker, inflictor)
        stkill(attacker)
    end)

    hook.Add("PlayerDeath", "ArcCWStattrack.KillPlayer", function(victim, inflictor, attacker)
        stkill(attacker)
    end)

    net.Receive("arrcwstattracksend", function(len, ply)
        local filekills = net.ReadUInt(20)
        local wep = ply:GetActiveWeapon()
        wep.FileKills = filekills
        -- print("recieved some kill from file - ", filekills)
    end)
end

--addons/sh_lounge_chatbox/lua/chatbox/cl_markups.lua:
local matError = Material("icon16/error.png")
local matHourglass = Material("icon16/hourglass.png")
local matImage = Material("icon16/image.png")

local chat_hide_images = CreateClientConVar("lounge_chat_hide_images", 0, true, false)
local chat_hide_avatars = CreateClientConVar("lounge_chat_hide_avatars", 0, true, false)
local chat_disable_flashes = CreateClientConVar("lounge_chat_disable_flashes", 0, true, false)
local chat_no_url_parsing = CreateClientConVar("lounge_chat_no_url_parsing", 0, true, false)
local chat_imgurl_autoload = CreateClientConVar("lounge_chat_imgurl_autoload", 0, true, false)

LOUNGE_CHAT.ChatMarkups = {}

function LOUNGE_CHAT:RegisterChatMarkup(perm, match, func)
	table.insert(self.ChatMarkups, {
		perm = perm,
		match = match,
		func = func,
	})
end

local function noparse(s)
	return {{noparse = true}, s, {noparse = false}}
end

LOUNGE_CHAT:RegisterChatMarkup("lua", "<luabtn=(%d+),(%d+)>(.-)</luabtn>", function(data)
	local id = tonumber(data.args[1])
	local hover = tonumber(data.args[2]) == 1
	local text = (data.args[3] or ""):Trim()
	if (text == "" or !LOUNGE_CHAT.LuaButtons[id]) then
		return end
	
	local tab = {
		{origtext = text},
		{lua = LOUNGE_CHAT.LuaButtons[id], hover = hover or false},
		text,
		{lua = false},
	}

	return tab
end)

LOUNGE_CHAT:RegisterChatMarkup("bold", "<b>(.-)</b>", function(data)
	return {
		{font = LOUNGE_CHAT.FontsToBold[data.defaultfont] or "LOUNGE_CHAT_18_B"},
		(data.args[1] or ""),
		{font = data.defaultfont},
	}
end)

LOUNGE_CHAT:RegisterChatMarkup("underline", "<u>(.-)</u>", function(data)
	return {
		{underline = true},
		(data.args[1] or ""),
		{underline = false},
	}
end)

LOUNGE_CHAT:RegisterChatMarkup("timestamp", "<timestamp=(%d+)>", function(data)
	local time = tonumber(data.args[1])
	if (!time) then
		return end

	return {
		LOUNGE_CHAT.Color("timestamp"),
		{font = LOUNGE_CHAT.TimestampFont},
		{noparse = true},
		LOUNGE_CHAT.Timestamp(time),
		{noparse = false},
		{font = data.defaultfont},
		data.defaultcolor,
	}
end)

LOUNGE_CHAT:RegisterChatMarkup("color", "<defc=(%w+)>", function(data)
	local colname = data.args[1]
	return LOUNGE_CHAT.ParseColor(colname)
end)

LOUNGE_CHAT:RegisterChatMarkup("color", "<color=([,%w]+)>(.-)</color>", function(data)
	local colname = data.args[1]
	local tx = data.args[2]

	local col = LOUNGE_CHAT.ParseColor(colname)
	return {col, tx, data.defaultcolor}
end)

LOUNGE_CHAT:RegisterChatMarkup("color", "%^(%d)(%d)(%d)", function(data)
	local r, g, b = tonumber(data.args[1]), tonumber(data.args[2]), tonumber(data.args[3])
	if (!r or !g or !b) then
		return end

	local f = 255 / 9
	return Color(r * f, g * f, b * f)
end)

local function flashthink(me)
	if (chat_disable_flashes:GetBool()) then
		me:SetTextColor(me.m_DefaultColor)
		return
	end

	local sin = math.abs(math.sin(RealTime() * me.m_iFlashRate))
	local c = me.m_FlashColor
	me:SetTextColor(Color(c.r * sin, c.g * sin, c.b * sin, 255))
end

LOUNGE_CHAT:RegisterChatMarkup("flash", "<flash=([,%w]+),(%d+)>(.-)</flash>", function(data)
	local colname = data.args[1]
	local speed = math.Clamp(tonumber(data.args[2]) or 1, 1, 30)
	local tx = (data.args[3] or ""):Trim()
	if (tx == "") then
		return end

	local col = LOUNGE_CHAT.ParseColor(colname)

	local lbl = LOUNGE_CHAT:MakeChatLabel(tx, data.defaultfont, data.defaultcolor, data.parent, data.underline)
	lbl.m_FlashColor = col
	lbl.m_DefaultColor = data.defaultcolor
	lbl.m_iFlashRate = speed
	lbl.Think = flashthink

	return {col, lbl, data.defaultcolor}
end)

local function rainbowthink(me)
	if (chat_disable_flashes:GetBool()) then
		me:SetTextColor(me.m_DefaultColor)
		return
	end

	me.m_iHue = (me.m_iHue + FrameTime() * math.min(720, me.m_iRate)) % 360
	me:SetTextColor(HSVToColor(me.m_iHue, 1, 1))
end

LOUNGE_CHAT:RegisterChatMarkup("rainbow", "<rainbow=(%d+)>(.-)</rainbow>", function(data)
	local speed = math.Clamp(tonumber(data.args[1]) or 1, 1, 30)
	local tx = (data.args[2] or ""):Trim()
	if (tx == "") then
		return end

	local col = LOUNGE_CHAT.ParseColor(colname)

	local lbl = LOUNGE_CHAT:MakeChatLabel(tx, data.defaultfont, data.defaultcolor, data.parent, data.underline)
	lbl.m_DefaultColor = data.defaultcolor
	lbl.m_iHue = 0
	lbl.m_iRate = 72 * speed
	lbl.Think = rainbowthink

	return {col, lbl, data.defaultcolor}
end)

LOUNGE_CHAT:RegisterChatMarkup("glow", "<glow>(.-)</glow>", function(data)
	local lbl = LOUNGE_CHAT:MakeChatLabel((data.args[1] or ""):Trim(), LOUNGE_CHAT.FontsToGlow[data.defaultfont] or "LOUNGE_CHAT_18_G", data.defaultcolor, data.parent)
	lbl:SetContentAlignment(5)
	lbl:SetWide(lbl:GetWide() + LOUNGE_CHAT.BlurSize * 2)

		local lbl2 = LOUNGE_CHAT:MakeChatLabel(lbl:GetText(), data.defaultfont, data.defaultcolor, lbl, data.underline)
		lbl2:CenterHorizontal()

	return {lbl}
end)

local function glowthink(me)
	if (chat_disable_flashes:GetBool()) then
		me:SetTextColor(me.m_DefaultColor)
		return
	end

	local sin = math.abs(math.sin(RealTime() * me.m_iFlashRate))
	local c = me.m_DefaultColor
	me:SetTextColor(Color(c.r, c.g, c.b, 255 * sin))
end

LOUNGE_CHAT:RegisterChatMarkup("glowflash", "<glowflash=(%d+)>(.-)</glowflash>", function(data)
	local speed = math.Clamp(tonumber(data.args[1]) or 1, 1, 30)
	local tx = (data.args[2] or ""):Trim()
	if (tx == "") then
		return end

	local lbl = LOUNGE_CHAT:MakeChatLabel(tx, LOUNGE_CHAT.FontsToGlow[data.defaultfont] or "LOUNGE_CHAT_18_G", data.defaultcolor, data.parent)
	lbl.m_DefaultColor = data.defaultcolor
	lbl.m_iFlashRate = speed
	lbl:SetContentAlignment(5)
	lbl:SetWide(lbl:GetWide() + LOUNGE_CHAT.BlurSize * 2)
	lbl.Think = glowthink

		local lbl2 = LOUNGE_CHAT:MakeChatLabel(lbl:GetText(), data.defaultfont, data.defaultcolor, lbl, data.underline)
		lbl2:CenterHorizontal()

	return {lbl}
end)

LOUNGE_CHAT:RegisterChatMarkup("avatar", "<avatar>", function(data)
	if (chat_hide_avatars:GetBool()) then
		return end

	return LOUNGE_CHAT:Avatar(data.sender, nil, data.parent)
end)

// Avatar SteamID64
LOUNGE_CHAT:RegisterChatMarkup("avatar other", "<avatar=(%d+)>", function(data)
	if (chat_hide_avatars:GetBool()) then
		return end

	local steamid64 = (data.args[1] or ""):Trim()
	if (steamid64 == "") then
		return end

	return LOUNGE_CHAT:Avatar(steamid64, nil, data.parent)
end)

LOUNGE_CHAT:RegisterChatMarkup("external image", "<imgurl=(.-)>", function(data)
	if (chat_hide_images:GetBool()) then
		return end

	local url = (data.args[1] or ""):Trim()
	if (url == "") then
		return end

	local maxwi, maxhe = 32, 32

	local pnl = vgui.Create("DButton", data.parent)
	pnl:SetText("")
	pnl:SetToolTip(url)
	pnl:SetSize(32, 32)
	pnl.Paint = function(me, w, h)
		if (!me.m_bLoaded) then
			draw.RoundedBox(4, 0, 0, w, h, LOUNGE_CHAT.Color("bg"))

			local mat = matHourglass
			if (me.m_bFailed) then
				mat = matError
			elseif (me.m_bReadyToLoad) then
				mat = matImage
			end
			surface.SetMaterial(mat)
			surface.SetDrawColor(color_white)
			surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 16, 16, 0)
		else
			surface.SetMaterial(me.m_Image)
			surface.SetDrawColor(color_white)
			surface.DrawTexturedRect(0, 0, w, h)
		end
	end
	pnl.DoClick = function(me)
		if (me.m_bReadyToLoad) then
			me.m_bReadyToLoad = false
			me:StartLoading()
		else
			gui.OpenURL(url)
		end
	end
	pnl.LoadImage = function(me, img)
		me.m_bLoaded = true
		me.m_Image = img
		me:SetToolTip(url)
	end
	pnl.MarkFailed = function(me)
		me.m_bFailed = true
	end
	pnl.StartLoading = function(me)
		LOUNGE_CHAT.DownloadImage(
			url,
			function(mat)
				if (!IsValid(me)) then
					return end

				me:LoadImage(mat)
			end,
			function()
				if (!IsValid(me)) then
					return end

				me:MarkFailed()
			end
		)
	end

	local img = LOUNGE_CHAT.GetDownloadedImage(url)
	if (img) then
		pnl:LoadImage(img)
	elseif (chat_imgurl_autoload:GetBool()) then
		pnl:StartLoading()
	else
		pnl.m_bReadyToLoad = true
		pnl:SetToolTip(LOUNGE_CHAT.Lang("click_to_load_image") .. ": " .. url)
	end

	return pnl
end)

local function MakeURL(url, tx, data)
	return {{url = url}, tx, {url = false}}
end

LOUNGE_CHAT:RegisterChatMarkup("named url", "%[(.-)%]%((.-)%)", function(data)
	local name, url = data.args[1] or "", data.args[2] or ""
	if (name:Trim() == "" or url:Trim() == "") then
		return end

	if (!url:StartWith("http://") and !url:StartWith("https://")) then
		url = "http://" .. url
	end

	if (chat_no_url_parsing:GetBool()) then
		return noparse(url)
	end

	return MakeURL(url, name, data)
end)

LOUNGE_CHAT:RegisterChatMarkup("url", "(%s?)http(%w?)://(.+)", function(data)
	local s = data.args[2]
	local expl = string.Explode(" ", data.args[3])
	local url = expl[1]
	if (!url or url == "") then
		return end

	url = "http" .. s .. "://" .. url

	if (chat_no_url_parsing:GetBool()) then
		return noparse(url)
	end

	local lbl = MakeURL(url, url, data)
	return {(data.args[1] or ""), lbl[1], lbl[2], lbl[3], " ", table.concat(expl, " ", 2)}
end)

LOUNGE_CHAT:RegisterChatMarkup("line break", "<br>", function(data)
	return {{linebreak = true}}
end)

LOUNGE_CHAT:RegisterChatMarkup("emoticon", LOUNGE_CHAT.EmoticonsNoColon and "([_%w]+)" or ":([_%w]+):", function(data)
	if (chat_hide_images:GetBool()) then
		return end

	local id = data.args[1]
	if (!id) then
		return end
		
	local nid = LOUNGE_CHAT.EmoticonsNoColon and id or ":" .. id .. ":"

	local em = LOUNGE_CHAT.Emoticons[id]
	if (!em) then
		return noparse(nid)
	end

	local sender = data.sender
	if (IsValid(sender)) then
		local ok = true

		local rest = em.restrict
		if (rest) then
			ok = false

			if (rest.usergroups and table.HasValue(rest.usergroups, sender:GetUserGroup())) then
				ok = true
			elseif (rest.steamids) and (table.HasValue(rest.steamids, sender:SteamID()) or table.HasValue(rest.steamids, sender:SteamID64())) then
				ok = true
			end
		end

		if (!ok) then
			return noparse(nid)
		end
	end

	local img
	if (em.url) then
		img = vgui.Create("DPanel", data.parent)
		img.Paint = function(me, w, h)
			if (me.m_Image) then
				surface.SetDrawColor(color_white)
				surface.SetMaterial(me.m_Image)
				surface.DrawTexturedRect(0, 0, w, h)
			end
		end

		local mat = LOUNGE_CHAT.GetDownloadedImage(em.url)
		if (mat) then
			img.m_Image = mat
		else
			LOUNGE_CHAT.DownloadImage(
				em.url,
				function(mat)
					if (IsValid(img)) then
						img.m_Image = mat
					end
				end
			)
		end
	else
		img = vgui.Create("DImage", data.parent)
		img:SetImage(em.path)
	end

	img:SetToolTip(nid)
	img:SetSize(em.w, em.h)

	return img
end)

-- Examples to display in the parsers list

LOUNGE_CHAT.MarkupsExamples = {}

function LOUNGE_CHAT:RegisterMarkupExample(tx, example, perm)
	table.insert(self.MarkupsExamples, {tx = tx, example = example, perm = perm})
end

LOUNGE_CHAT:RegisterMarkupExample("<defc=(color name/rgb/hex)>", "<defc=red>Following text will be in red.", "color")
LOUNGE_CHAT:RegisterMarkupExample("<color=(color name/rgb/hex)>text</color>", "<color=0,255,0>This text will be in green</color>.", "color")
LOUNGE_CHAT:RegisterMarkupExample("^RGB (0-9)", "^009Following text will be in blue.", "color")
LOUNGE_CHAT:RegisterMarkupExample("<flash=(color name/rgb/hex),(rate)", "<flash=0,255,255,2>Slow flashing text in cyan</flash>", "flash")
LOUNGE_CHAT:RegisterMarkupExample("<rainbow=(rate)>", "<rainbow=2>Slow rainbow text</rainbow>", "rainbow")
LOUNGE_CHAT:RegisterMarkupExample(":(emoticon name):", ":emoticon_smile:", "emoticon")
LOUNGE_CHAT:RegisterMarkupExample("<avatar>", "<avatar>", "avatar")
LOUNGE_CHAT:RegisterMarkupExample("<avatar=(steamid64)>", "<avatar=76561197960279927>", "avatar other")
LOUNGE_CHAT:RegisterMarkupExample("<imgurl=(image url)>", "<imgurl=http://i.imgur.com/00Xaj13.png>", "external image")
LOUNGE_CHAT:RegisterMarkupExample("[url name](url)", "[Google](http://google.com/)", "named url")
--addons/sh_lounge_chatbox/lua/chatbox/cl_chatbox.lua:
-- TODO? save configs

local chat_x = CreateClientConVar("lounge_chat_x", 2 / 1080, true, false)
local chat_y = CreateClientConVar("lounge_chat_y", 0.52, true, false)
local chat_w = CreateClientConVar("lounge_chat_w", 550 / 1920, true, false)
local chat_h = CreateClientConVar("lounge_chat_h", 280 / 1080, true, false)
local chat_message_hidetime = CreateClientConVar("lounge_chat_hidetime", 15, true, false)
local chat_timestamps = CreateClientConVar("lounge_chat_timestamps", 0, true, false)
local chat_hide_options = CreateClientConVar("lounge_chat_hide_options", 0, true, false)
local chat_no_scroll_while_open = CreateClientConVar("lounge_chat_no_openscroll", 0, true, false)

--
cvars.AddChangeCallback("lounge_chat_x", function(cvar, old, new)
	if (IsValid(_LOUNGE_CHAT)) then
		local x = ScrW() * math.Clamp(tonumber(new) or chat_x:GetDefault(), 0, (ScrW() - _LOUNGE_CHAT:GetWide()) / ScrW())
		_LOUNGE_CHAT.x = x
	end
end)

cvars.AddChangeCallback("lounge_chat_y", function(cvar, old, new)
	if (IsValid(_LOUNGE_CHAT)) then
		local y = ScrH() * math.Clamp(tonumber(new) or chat_y:GetDefault(), 0, (ScrH() - _LOUNGE_CHAT:GetTall()) / ScrH())
		_LOUNGE_CHAT.y = y
	end
end)

cvars.AddChangeCallback("lounge_chat_w", function(cvar, old, new)
	if (IsValid(_LOUNGE_CHAT)) then
		local w = ScrW() * math.Clamp(tonumber(new) or chat_w:GetDefault(), 0, 1)
		_LOUNGE_CHAT:SetWide(w)
		_LOUNGE_CHAT.m_Close:AlignRight(0)
		_LOUNGE_CHAT.m_Options:MoveLeftOf(_LOUNGE_CHAT.m_Close)
	end
end)

cvars.AddChangeCallback("lounge_chat_h", function(cvar, old, new)
	if (IsValid(_LOUNGE_CHAT)) then
		local h = ScrH() * math.Clamp(tonumber(new) or chat_h:GetDefault(), 0, 1)
		_LOUNGE_CHAT:SetTall(h)
	end
end)

local chat_message_hidetime_cache = chat_message_hidetime:GetFloat()

cvars.AddChangeCallback("lounge_chat_hidetime", function(cvar, old, new)
	chat_message_hidetime_cache = tonumber(new) or 15
end)

--
local matClose = Material("shenesis/chat/close.png", "noclamp smooth")
local matSmile = Material("shenesis/chat/smile.png", "noclamp smooth")
local matOptions = Material("shenesis/chat/options.png", "noclamp smooth")

LOUNGE_CHAT.ChatboxOpen = false
LOUNGE_CHAT.History = {}

LOUNGE_CHAT.ChatboxFont = "LOUNGE_CHAT_18"
LOUNGE_CHAT.GlowFont = "LOUNGE_CHAT_18_G"
LOUNGE_CHAT.TimestampFont = "LOUNGE_CHAT_16"

local function IsPlayer(e)
	return type(e) == "Player" and IsValid(e)
end

local function RemoveIfValid(e)
	if (IsValid(e)) then
		e:Remove()
	end
end

local function FindPlayer(cont)
	for _, v in pairs (cont) do
		if (IsPlayer(v)) then
			return v
		end
	end

	return NULL
end

local nopaint = function() end

LOUNGE_CHAT.FontsToGlow = {}
LOUNGE_CHAT.FontsToBold = {}

function LOUNGE_CHAT:CreateChatboxFonts()
	local fntname = self.FontName
	local fntnamebold = self.FontNameBold
	local weight = 500
	local boldweight = 1000
	local sizes = {8, 10, 12, 14, 16, 18, 20, 24}

	for _, v in ipairs (sizes) do
		local n = "LOUNGE_CHAT_" .. v

		surface.CreateFont(n, {font = fntname, size = v, weight = weight})
		surface.CreateFont(n .. "_B", {font = fntnamebold, size = v, weight = boldweight})
		surface.CreateFont(n .. "_G", {font = fntnamebold, size = v, blursize = self.BlurSize, additive = true})

		self.FontsToGlow[n] = n .. "_G"
		self.FontsToBold[n] = n .. "_B"
	end
end

function LOUNGE_CHAT:CreateChatbox()
	RemoveIfValid(_LOUNGE_CHAT)
	RemoveIfValid(_LOUNGE_CHAT_EMOTICONS)

	local W, H = ScrW(), ScrH()
	local scale = math.Clamp(H / 1080, 0.7, 1)
	_LOUNGE_CHAT_SCALE = scale

	local wi, he = W * math.Clamp(chat_w:GetFloat(), 0, 1), H * math.Clamp(chat_h:GetFloat(), 0, 1)
	wi = math.max(wi, 400 * scale)
	he = math.max(he, 200 * scale)

	local x, y = W * math.Clamp(chat_x:GetFloat(), 0, (W - wi) / W), H * math.Clamp(chat_y:GetFloat(), 0, (H - he) / H)

	local frame = vgui.Create("DFrame")
	frame:SetTitle("")
	frame:ShowCloseButton(false)
	frame:SetSizable(true)
	frame:SetScreenLock(true)
	frame:SetMinWidth(wi * 0.5)
	frame:SetMinHeight(he * 0.5)
	frame:SetSize(wi, he)
	frame:SetPos(x, y)
	frame:DockPadding(4, 27, 4, 4)
	frame.m_fAlpha = 0
	frame.Paint = function(me, w, h)
		if (gui.IsGameUIVisible()) then
			return end

		if (self.ChatboxOpen or me.m_fAlpha > 0) then
			local ch, cb = self.Color("header"), self.Color("bg")
			local a = me.m_fAlpha or 255
			local af = me.m_fAlphaFrac or 1

			draw.RoundedBoxEx(4, 0, 0, w, 22, Color(ch.r, ch.g, ch.b, ch.a * af), true, true, false, false)
			draw.RoundedBoxEx(4, 0, 22, w, h - 22, Color(cb.r, cb.g, cb.b, cb.a * af), false, false, true, true)

			me.m_Title:SetAlpha(a)
			me.m_Close:SetAlpha(a)
			me.m_Entry:SetAlpha(a)
			me.m_Send:SetAlpha(a)
			me.m_Title:PaintManual()
			me.m_Close:PaintManual()
			me.m_Entry:PaintManual()
			me.m_Send:PaintManual()
		end

		me.m_History:PaintManual()
	end
	frame.OldThink = frame.Think
	frame.Think = function(me)
		if (!self.ChatboxOpen) then
			return end

		local ox, oy = me.x, me.y
		local ow, oh = me:GetSize()

		me:OldThink()

		if (me.Dragging) then
			if (ox ~= me.x) then
				RunConsoleCommand("lounge_chat_x", tostring(ox / W))
			end
			if (oy ~= me.y) then
				RunConsoleCommand("lounge_chat_y", tostring(oy / H))
			end
		end

		if (me.Sizing) then
			if (ow ~= me:GetWide()) then
				RunConsoleCommand("lounge_chat_w", tostring(ow / W))
			end
			if (oh ~= me:GetTall()) then
				RunConsoleCommand("lounge_chat_h", tostring(oh / H))
			end
		end
	end
	frame.OldOnMouseReleased = frame.OnMouseReleased
	frame.OnMouseReleased = function(me, mc)
		me:OldOnMouseReleased(mc)

		if (mc == MOUSE_RIGHT) then
			me:ShowMenu()
		end
	end
	frame.ShowMenu = function(me)
		local menu = self.Menu()

			menu:AddOption(self.Lang("clear_chat"), function()
				RunConsoleCommand("lounge_chat_clear")
			end)

			menu:AddOption(self.Lang("chat_parsers"), function()
				self:ShowParsers()
			end)

			menu:AddOption(self.Lang("chat_options"), function()
				self:ShowOptions()
			end)

			menu:AddOption(self.Lang("reset_position"), function()
				RunConsoleCommand("lounge_chat_x", chat_x:GetDefault())
				RunConsoleCommand("lounge_chat_y", chat_y:GetDefault())
			end)

			menu:AddOption(self.Lang("reset_size"), function()
				RunConsoleCommand("lounge_chat_w", chat_w:GetDefault())
				RunConsoleCommand("lounge_chat_h", chat_h:GetDefault())
			end)

		menu:Open()
	end
	_LOUNGE_CHAT = frame

		local title = self.Label("", "LOUNGE_CHAT_16", self.Color("text"), frame)
		title:SetPaintedManually(true)
		title:AlignTop(11 - title:GetTall() * 0.5)
		title.x = title.y * 2
		title.Think = function(me)
			if (!self.ChatboxOpen) then
				return end

			if (!me.m_fNextRefresh or CurTime() >= me.m_fNextRefresh) then
				me.m_fNextRefresh = CurTime() + 1

				local t = self.ChatTitle
				t = t:Replace("%hostname%", GetHostName())
				t = t:Replace("%players%", self.Lang("players_online") .. ": " .. #player.GetAll() .. "/" .. game.MaxPlayers())
				t = t:Replace("%uptime%", self.Lang("server_uptime") .. ": " .. self.SecondsToEnglish(CurTime()))

				me:SetText(t)
				me:SizeToContentsX()
			end
		end
		frame.m_Title = title

		local close = vgui.Create("DButton", frame)
		close:SetPaintedManually(true)
		close:SetText("")
		close:SetSize(22, 22)
		close:AlignRight(0)
		close.Paint = function(me, w, h)
			if (me.Hovered) then
				draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("close_hover"), false, true, false, false)
			end

			if (me:IsDown()) then
				draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("hover"), false, true, false, false)
			end

			surface.SetDrawColor(me:IsDown() and self.Color("text_down") or self.Color("text"))
			surface.SetMaterial(matClose)
			surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 12 * scale, 12 * scale, 0)

			local b = chat_hide_options:GetBool()
			if (!b) then
				frame.m_Options:PaintManual()
			end
			frame.m_Options:SetMouseInputEnabled(!b)
		end
		close.DoClick = function(me)
			self:CloseChatbox()
		end
		frame.m_Close = close

		local options = vgui.Create("DButton", frame)
		options:SetPaintedManually(true)
		options:SetText("")
		options:SetSize(22, 22)
		options:MoveLeftOf(close)
		options.Paint = function(me, w, h)
			local c = self.Color("text")

			surface.SetDrawColor(c.r, c.g, c.b, c.a * (me.Hovered and 1 or 0.5))
			surface.SetMaterial(matOptions)
			surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 12 * scale, 12 * scale, 0)
		end
		options.DoClick = function(me)
			frame:ShowMenu()
		end
		frame.m_Options = options

		local history = vgui.Create("DScrollPanel", frame)
		self.PaintScroll(history)
		history:SetPaintedManually(true)
		history:Dock(FILL)
		history:DockMargin(0, 0, 0, 4)
		history.PerformLayout = function(me)
			local h = me.pnlCanvas:GetTall()
			local w = me:GetWide()
			local y = 0

			me:Rebuild()

			me.VBar:SetUp(me:GetTall(), me.pnlCanvas:GetTall())
			y = me.VBar:GetOffset()

			if (me.VBar.Enabled) then w = w - me.VBar:GetWide() end

			me.pnlCanvas:SetWide(w)

			me:Rebuild()
			if (h > me:GetTall()) then
				me.pnlCanvas:AlignTop(y)
			else
				me.pnlCanvas:AlignBottom(0)
			end

			if (h ~= me.pnlCanvas:GetTall()) then
				me.VBar:SetScroll(me.VBar:GetScroll()) -- Make sure we are not too far down!
			end
		end
		history.Rebuild = function(me)
			-- Rewrite this shit to take invisible els into account
			local cv = me:GetCanvas()
			local chi = cv:GetChildren()
			local h = 4

			for _, v in ipairs (chi) do
				h = h + v:GetTall()
			end

			cv:SetTall(h + (#chi > 0 and 4 or 0))
		end
		history.ScrollToBottom = function(me)
			me:PerformLayout()

			local vbar = me.VBar

			local anim = vbar:NewAnimation(self.Anims.FadeInTime)
			anim.StartPos = vbar.Scroll
			anim.TargetPos = vbar.CanvasSize
			anim.Think = function(anim, pnl, fraction)
				pnl:SetScroll(Lerp(fraction, anim.StartPos, anim.TargetPos))
			end
		end
		history.Think = function(me)
			local sc = me.VBar:GetScroll()
			frame.m_iScrollMin = sc
			frame.m_iScrollMax = sc + frame:GetTall()
		end
		history.Paint = function(me, w, h)
			if (self.ChatboxOpen) then
				local ci = self.Color("inbg")
				local a = frame.m_fAlpha or 255
				local af = frame.m_fAlphaFrac or 1

				draw.RoundedBox(4, 0, 0, w, h, Color(ci.r, ci.g, ci.b, ci.a * af))

				me.VBar:SetAlpha(a)
			else
				me.VBar:SetAlpha(0)
			end
		end
		frame.m_History = history

			history:InvalidateParent(true)
			history.pnlCanvas:DockPadding(4, 4, 4, 4)

		local bottom = vgui.Create("DPanel", frame)
		bottom:SetDrawBackground(false)
		bottom:Dock(BOTTOM)
		frame.m_Bottom = bottom

			local entry = vgui.Create("DTextEntry", bottom)
			entry:SetFont(self.ChatboxFont)
			entry:SetTextColor(self.Color("text"))
			entry:SetHighlightColor(self.Color("header"))
			entry:SetDrawLanguageID(false)
			entry:SetPaintedManually(true)
			entry:SetUpdateOnType(true)
			entry:Dock(FILL)
			entry.OldOnKeyCodeTyped = entry.OnKeyCodeTyped
			entry.Paint = function(me, w, h)
				draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("inbg"), true, false, true, false)
				me:DrawTextEntryText(me:GetTextColor(), me:GetHighlightColor(), me:GetTextColor())

				if (vgui.GetKeyboardFocus() == frame) then
					me:RequestFocus()
				end
			end
			entry.OnKeyCodeTyped = function(me, kc)
				if (kc == KEY_ESCAPE) then
					self:CloseChatbox()
				elseif (kc == KEY_TAB) then
					local str = hook.Call("OnChatTab", GAMEMODE, me:GetValue())
					if (str) then
						me:SetText(str)
					end
				elseif (kc == KEY_UP) then
					if (#self.History > 0) then
						if (!me.m_iCurPos) then
							me.m_iCurPos = #self.History
							me:SetText(self.History[me.m_iCurPos])
							me:SetCaretPos(me:GetText():len())
						elseif (me.m_iCurPos > 1) then
							me.m_iCurPos = me.m_iCurPos - 1
							me:SetText(self.History[me.m_iCurPos])
							me:SetCaretPos(me:GetText():len())
						end
					end
				elseif (kc == KEY_DOWN) then
					if (me.m_iCurPos and me.m_iCurPos < #self.History) then
						me.m_iCurPos = me.m_iCurPos + 1
						me:SetText(self.History[me.m_iCurPos])
						me:SetCaretPos(me:GetText():len())
					end
				end

				me:OldOnKeyCodeTyped(kc)
			end
			entry.OnValueChange = function(me, val)
				hook.Call("ChatTextChanged", GAMEMODE, val)
			end
			entry.OnEnter = function(me)
				local val = me:GetValue()
				if (val:Trim() ~= "") then
 					local max = 500
					val = self.sub(val, 1, max)

--[[ 					if (val:find('"')) then
						LocalPlayer():ConCommand((frame.m_bTeam and "say_team" or "say") .. " \"" .. val .. "\"")
					else
						RunConsoleCommand(frame.m_bTeam and "say_team" or "say"	, val)
					end ]]

					net.Start("LOUNGE_CHAT.SendChat")
						net.WriteString(val)
					net.SendToServer()

					table.insert(self.History, val)
				end

				self:CloseChatbox()
			end
			frame.m_Entry = entry

			local send = LOUNGE_CHAT.Button("send", bottom, function()
				entry:OnEnter()
			end)
			send:SetPaintedManually(true)
			send:Dock(RIGHT)
			send:DockMargin(4, 0, 0, 0)
			send.OldPaint = send.Paint
			send.Paint = function(me, w, h)
				me:OldPaint(w, h)
				frame.m_Emoticons:PaintManual()
			end
			frame.m_Send = send

			local emoticons = LOUNGE_CHAT.Button("", bottom, function()
				entry:OnEnter()
			end)
			emoticons:SetPaintedManually(true)
			emoticons:SetWide(bottom:GetTall())
			emoticons:Dock(RIGHT)
			emoticons.m_bHovering = false
			emoticons.m_fAlphaFrac = 40 / 255
			emoticons.m_fAlpha = 40
			emoticons.Paint = function(me, w, h)
				draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("inbg"), false, true, false, true)

				local b = me.Hovered or (IsValid(_LOUNGE_CHAT_EMOTICONS) and _LOUNGE_CHAT_EMOTICONS:IsVisible())
				if (b ~= me.m_bHovering) then
					me.m_bHovering = b

					me:Stop()
					local anim = me:NewAnimation(self.Anims.FadeInTime)
					anim.m_fStart = me.m_fAlpha
					anim.m_fTarget = b and 200 or 40
					anim.Think = function(anim, _, fraction)
						me.m_fAlphaFrac = fraction
						me.m_fAlpha = Lerp(fraction, anim.m_fStart, anim.m_fTarget)
					end
				end

				local c = self.Color("text")
				surface.SetDrawColor(c.r, c.g, c.b, me.m_fAlpha)
				surface.SetMaterial(matSmile)
				surface.DrawTexturedRectRotated(h * 0.5, h * 0.5, 14, 14, 0)
			end
			emoticons.DoClick = function()
				self:ShowEmoticons()
			end
			frame.m_Emoticons = emoticons

	--self:ShowEmoticons()
end

function LOUNGE_CHAT:ShowParsers()
	if (IsValid(_LOUNGE_CHAT_PARSERS)) then
		_LOUNGE_CHAT_PARSERS:Remove()
	end

	local scale = math.Clamp(ScrH() / 1080, 0.7, 1)
	local wi, he = 500 * scale, 600 * scale

	local frame = vgui.Create("EditablePanel")
	frame:SetSize(wi, he)
	frame:Center()
	frame:MakePopup()
	frame.m_bF4Down = true
	frame.Think = function(me)
		if (input.IsKeyDown(KEY_ESCAPE)) then
			me:Close()

			gui.HideGameUI()
			timer.Simple(0, gui.HideGameUI)
		end
	end
	frame.Paint = function(me, w, h)
		draw.RoundedBox(4, 0, 0, w, h, self.Color("bg"))
	end
	frame.Close = function(me)
		if (me.m_bClosing) then
			return end

		me.m_bClosing = true
		me:AlphaTo(0, self.Anims.FadeOutTime, 0, function()
			me:Remove()
		end)
	end
	_LOUNGE_CHAT_PARSERS = frame

		local th = 48 * scale
		local m = th * 0.25
		local m5 = m * 0.5

		local header = vgui.Create("DPanel", frame)
		header:SetTall(th)
		header:Dock(TOP)
		header.Paint = function(me, w, h)
			draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("header"), true, true, false, false)
		end

			local title = self.Lang("chat_parsers")

			local titlelbl = self.Label(title, "LOUNGE_CHAT_24", self.Color("text"), header)
			titlelbl:Dock(LEFT)
			titlelbl:DockMargin(m, 0, 0, 0)

			local close = vgui.Create("DButton", header)
			close:SetText("")
			close:SetWide(th)
			close:Dock(RIGHT)
			close.Paint = function(me, w, h)
				if (me.Hovered) then
					draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("close_hover"), false, true, false, false)
				end

				if (me:IsDown()) then
					draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("hover"), false, true, false, false)
				end

				surface.SetDrawColor(me:IsDown() and self.Color("text_down") or self.Color("text"))
				surface.SetMaterial(matClose)
				surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 16 * scale, 16 * scale, 0)
			end
			close.DoClick = function(me)
				frame:Close()
			end

		local body = vgui.Create("DScrollPanel", frame)
		self.PaintScroll(body)
		body:SetDrawBackground(false)
		body:DockMargin(m, m, m, m)
		body:GetCanvas():DockPadding(m5, m5, m5, m5)
		body:Dock(FILL)
		body.Paint = function(me, w, h)
			draw.RoundedBox(4, 0, 0, w, h, self.Color("inbg"))
		end

			for i, ex in ipairs (self.MarkupsExamples) do
				if (ex.perm) then
					local rest = self.MarkupsPermissions[ex.perm]
					if (rest) then
						local okay = false

						if (rest.usergroups and table.HasValue(rest.usergroups, LocalPlayer():GetUserGroup())) then
							okay = true
						elseif (rest.steamids) and (table.HasValue(rest.steamids, LocalPlayer():SteamID()) or table.HasValue(rest.steamids, LocalPlayer():SteamID64())) then
							okay = true
						end

						if (!okay) then
							continue end
					end
				end

				local pnl = vgui.Create("DButton", body)
				pnl:SetText("")
				pnl:SetSize(wi - m * 2 - m5 * 2, 80 * scale)
				pnl:Dock(TOP)
				pnl:DockPadding(m5, m5, m5, m5)
				pnl.Paint = function(me, w, h)
					draw.RoundedBox(4, 0, 0, w, h, self.Color("bg"))
				end
				pnl.DoClick = function()
					local ch = _LOUNGE_CHAT
					if (IsValid(ch) and IsValid(ch.m_Entry) and self.ChatboxOpen) then
						local tx = ch.m_Entry:GetValue() .. ex.example
						ch.m_Entry:SetText(tx)
						ch.m_Entry:SetCaretPos(tx:len())

						frame:Close()
					end
				end

					local lbl = self.Label(ex.tx, "LOUNGE_CHAT_16_B", self.Color("text"), pnl)
					lbl:Dock(TOP)
					lbl:DockMargin(0, 0, 0, m5)

					local lbl = self.Label(self.Lang("usage") .. ": " .. ex.example, "LOUNGE_CHAT_16", self.Color("text"), pnl)
					lbl:Dock(TOP)

					local parsed = self:ParseLineWrap({ex.example}, pnl:GetWide() - m5 * 2, pnl, LocalPlayer())
					parsed:Dock(TOP)
					parsed:SetMouseInputEnabled(false)

				pnl:InvalidateLayout(true)
				pnl:SizeToChildren(false, true)

				if (i > 1) then
					pnl:DockMargin(0, m5, 0, 0)
				end
			end

	frame:SetAlpha(0)
	frame:AlphaTo(255, self.Anims.FadeInTime)
end

concommand.Add("lounge_chat_parsers", function()
	LOUNGE_CHAT:ShowParsers()
end)

local function urlpaint(me, w, h)
	if (me.m_Image) then
		surface.SetDrawColor(color_white)
		surface.SetMaterial(me.m_Image)
		surface.DrawTexturedRect(0, 0, w, h)
	end
end

function LOUNGE_CHAT:ShowEmoticons()
	local frame = _LOUNGE_CHAT
	local lx, ly = frame.m_Emoticons:LocalToScreen(0, 0)
	local x, y = frame:ScreenToLocal(lx, ly)

	local panelx, panely = frame:GetPos()
	local old = _LOUNGE_CHAT_EMOTICONS
	if (IsValid(old)) then
		if (old:IsVisible()) then
			old:Close()
		else
			old:SetPos(panelx+frame:GetWide()+AOCW(10), panely)
			old:SetSize(frame:GetWide() * 0.4, frame:GetTall())
			old:SetVisible(true)
			old:SetAlpha(0)
			old:AlphaTo(255, self.Anims.FadeInTime)
			old.m_bClosing = false
		end

		return
	end

	local pnl = vgui.Create("EditablePanel")
--[[ y ]]
--[[ 	pnl:ShowCloseButton(false)
	pnl:SetDraggable(false) ]]
	pnl:SetSize(frame:GetWide() * 0.4, frame:GetTall())
	pnl:SetPos(panelx+frame:GetWide()+AOCW(10), panely)
	pnl.Paint = function(me, w, h)
		draw.RoundedBox(4, 0, 0, w, h, self.Color("bg"))
	end
	pnl.Close = function(me)
		if (me.m_bClosing) then
			return end

		me.m_bClosing = true
		me:AlphaTo(0, self.Anims.FadeOutTime, 0, function()
			me:SetVisible()
		end)
	end
	_LOUNGE_CHAT_EMOTICONS = pnl



	local header = vgui.Create("DPanel", pnl)
	header:SetTall(AOCH(20))
	header:Dock(TOP)
	header.Paint = function(me, w, h)
		draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("header"), true, true, false, false)
	end

		local title = "Emojis"

		local titlelbl = self.Label(title, "LOUNGE_CHAT_24", self.Color("text"), header)
		titlelbl:Dock(LEFT)
		titlelbl:DockMargin(AOCW(5), 0, 0, 0)

		local close = vgui.Create("DButton", header)
		close:SetText("")
		close:SetWide(AOCW(61))
		close:Dock(RIGHT)
		close.Paint = function(me, w, h)
			if (me.Hovered) then
				draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("close_hover"), false, true, false, false)
			end

			if (me:IsDown()) then
				draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("hover"), false, true, false, false)
			end

			surface.SetDrawColor(me:IsDown() and self.Color("text_down") or self.Color("text"))
			surface.SetMaterial(matClose)
			surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 16, 16, 0)
		end
		close.DoClick = function(me)
			pnl:Close()
		end



		local scroll = vgui.Create("DScrollPanel", pnl)
		self.PaintScroll(scroll)
		scroll:Dock(FILL)
		scroll:DockMargin(4, 4, 4, 4)

			local ilist = vgui.Create("DIconLayout", scroll)
			ilist:Dock(FILL)

			for id, em in SortedPairs (self.Emoticons) do
				if (em.restrict) then
					local ok = false

					local rest = em.restrict
					if (rest.usergroups and table.HasValue(rest.usergroups, LocalPlayer():GetUserGroup())) then
						ok = true
					elseif (rest.steamids) and (table.HasValue(rest.steamids, LocalPlayer():SteamID()) or table.HasValue(rest.steamids, LocalPlayer():SteamID64())) then
						ok = true
					end

					if rest.vipOnly and LocalPlayer():GetAOCVIP() then 
						ok = true
					end

					if (!ok) then
						continue end
				end

				local img
				if (em.url) then
					img = vgui.Create("DButton", ilist)
					img:SetText("")
					img.Paint = urlpaint

					local mat = LOUNGE_CHAT.GetDownloadedImage(em.url)
					if (mat) then
						img.m_Image = mat
					else
						LOUNGE_CHAT.DownloadImage(
							em.url,
							function(mat)
								if (IsValid(img)) then
									img.m_Image = mat
								end
							end
						)
					end
				else
					img = vgui.Create("DImageButton", ilist)
					img:SetImage(em.path)
				end

				img:SetToolTip(":" .. id .. ":")
				img:SetSize(em.w, em.h)
				img.DoClick = function()
					if (IsValid(frame) and IsValid(frame.m_Entry)) then
						local tx = frame.m_Entry:GetValue() .. ":" .. id .. ":"
						frame.m_Entry:SetText(tx)
						frame.m_Entry:SetCaretPos(tx:len())

						pnl:Close()
					end
				end
			end

	pnl:SetAlpha(0)
	pnl:AlphaTo(255, self.Anims.FadeInTime)



	return pnl
end

function LOUNGE_CHAT:SplitLine(tx, fnt, maxwi, cont, i)
	-- Check where to split line for 1 single word bigger than the remaining space
	-- (retards spamming "aaaaaaaaaaaa")
	surface.SetFont(fnt)
	local sw = surface.GetTextSize(tx)
	if (sw >= maxwi) then
		local s = ""

		if (self.UseUTF8) then
			tx = utf8.force(tx)

			for p, c in utf8.codes(tx) do
				local n = s .. utf8.char(c)

				local sw2 = surface.GetTextSize(n)
				if (sw2 >= maxwi) then
					s = self.sub(n, 1, -3)
					table.insert(cont, i + 1, self.sub(tx, s:len() + 1))

					cont[i] = s
					return s
				else
					s = n
				end
			end
		else
			for j = 1, #tx do
				local n = s .. tx[j]

				local sw2 = surface.GetTextSize(n)
				if (sw2 >= maxwi) then
					s = string.sub(n, 1, -3)
					table.insert(cont, i + 1, tx:sub(s:len() + 1))

					cont[i] = s
					return s
				else
					s = n
				end
			end
		end
	end

	-- Check where to split line for spaced words
	local sw = surface.GetTextSize(" ")

	local expl = string.Explode(" ", tx)

	local line = {}
	local w = 0

	for id, wo in pairs (expl) do
		local _w, _h = surface.GetTextSize(wo)
		if (id == 1 or w + _w < maxwi) then
			w = w + _w + sw
			table.insert(line, wo)
		else
			table.insert(cont, i + 1, table.concat(expl, " ", id))
			break
		end
	end

	cont[i] = table.concat(line, " ")
	return cont[i]
end

function LOUNGE_CHAT:ParseMarkups(parent, sender, tx, defaultfont, defaultcolor, maxwi, cont, i, bypass, underline)
	local parsed = false
	for _, mup in ipairs (self.ChatMarkups) do
		local d = {string.find(tx, mup.match)}
		local s, e = d[1], d[2]
		if (s) then
			local okay = true

			if (mup.perm and IsValid(sender) and !bypass) then
				local rest = self.MarkupsPermissions[mup.perm]
				if (rest) then
					okay = false

					if (rest.usergroups and table.HasValue(rest.usergroups, sender:GetUserGroup())) then
						okay = true
					elseif (rest.steamids) and (table.HasValue(rest.steamids, sender:SteamID()) or table.HasValue(rest.steamids, sender:SteamID64())) then
						okay = true
					end
				end
			end

			if (okay) then
				table.remove(d, 1)
				table.remove(d, 1)

				parsed = true
				cont[i] = ""

				local before = self.sub(tx, 1, s - 1)
				local after = self.sub(tx, e + 1)
				if (before ~= "") then
					table.insert(cont, i + 1, before)
					i = i + 1
				end

				local res = mup.func({parent = parent, sender = sender, args = d, text = self.sub(tx, s, e), defaultfont = defaultfont, defaultcolor = defaultcolor, underline = underline, maxwi = maxwi, cont = cont, i = i})
				if (res) then
					if (istable(res) and !res.r) then
						for __, v in pairs (res) do
							table.insert(cont, i + 1, v)
							i = i + 1
						end
					else
						table.insert(cont, i + 1, res)
						i = i + 1
					end
				end

				if (after ~= "") then
					table.insert(cont, i + 1, after)
				end
			end

			break
		end
	end

	if (parsed) then
		return nil
	else
		return tx
	end
end

local messagequeue = {}

function LOUNGE_CHAT:MakeChatLabel(tx, font, color, parent, underline)
	local ele = self.Label(tx, font, color, parent)
	ele:SetExpensiveShadow(1, color_black)
	ele:SetWide(ele:GetWide() + 1)

	if (underline) then
		ele.Paint = function(me, w, h)
			LOUNGE_CHAT.UnderlinePaint(me, w, h)
		end
	end

	return ele
end

function LOUNGE_CHAT.UnderlinePaint(me, w, h)
	surface.SetDrawColor(me:GetTextColor())
	surface.DrawRect(0, h - 2, w, 1)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawRect(1, h - 1, w - 2, 1)
end

function LOUNGE_CHAT:ParseLineWrap(cont, maxwi, parent, sender)
	if (maxwi == true) then
		if (IsValid(_LOUNGE_CHAT)) then
			maxwi = _LOUNGE_CHAT.m_History:GetWide() - 24
		else
			if (!IsValid(LocalPlayer())) then
				table.insert(messagequeue, {
					cont = cont,
					maxwi = maxwi,
					parent = parent,
					sender = sender,
				})

				return
			end

			maxwi = 100 -- que
		end
	end

	local origtext = ""

	local line = vgui.Create("DPanel", parent)
	line:SetDrawBackground(false)
	line.Paint = nopaint
	line.OnMousePressed = function(me, mc)
		if (mc == MOUSE_RIGHT) then
			me:ShowMenu()
		end
	end
	line.ShowMenu = function(me, add)
		local menu = self.Menu()

			menu:AddOption(self.Lang("copy_message"), function()
				SetClipboardText(origtext)
			end)

			if (add) then
				for _, v in pairs (add) do
					menu:AddOption(self.Lang(v.text), function()
						v.func()
					end)
				end
			end

		menu:Open()
	end

		local contents = vgui.Create("DPanel", line)
		contents:Dock(FILL)
		contents:SetDrawBackground(false)
		contents.Paint = nopaint
		contents.OnMousePressed = function(me, mc)
			line:OnMousePressed(mc)
		end
		line.m_Contents = contents

	local bx = 0
	local x, y, w, lh = 0, 0, 0, 0
	local h = 0
	local nl = false
	local inline = {}

	local defaultfont = self.ChatboxFont
	local defaultcolor = color_white
	local noparse = false
	local bypassperm = false
	local underline = false
	local url, lua
	local urlbtns, luabtns = {}, {}

	local function urlpaint(me, w, h)
		local b = false
		for _, v in ipairs (me.m_Buttons) do
			if (IsValid(v) and v.Hovered) then
				b = true
				break
			end
		end

		me:SetTextColor(b and LOUNGE_CHAT.Color("url_hover") or LOUNGE_CHAT.Color("url"))

		LOUNGE_CHAT.UnderlinePaint(me, w, h)
	end

	local pre

	local tries = 0
	for i, el in pairs (cont) do
		tries = tries + 1
		if (tries > 512) then
			line:Remove()
			error("overflow!! (this shouldn't happen, report this to the author with the message)")
			return
		end

		local ele, forcebreak

		if (isstring(el) or isnumber(el)) then
			if (el == "") then
				continue end

			el = (noparse or url) and el or self:ParseMarkups(contents, sender, el, defaultfont, defaultcolor, maxwi - x, cont, i, bypassperm, underline)

			if (maxwi and el and el ~= "") then
				surface.SetFont(defaultfont)
				local _w, _h = surface.GetTextSize(el)
				if (_w > maxwi - x) then -- This string is gonna be too long, we need to split it!!
					el = self:SplitLine(el, defaultfont, maxwi - x, cont, i)
					if (el == "") then
						nl = true
					end
				end
			end

			if (el and el ~= "") then
				if (#inline == 0) then
					el = el:TrimLeft()
				end

				ele = self:MakeChatLabel(el, defaultfont, defaultcolor, contents, underline)

				if (url and url ~= "") then
					ele:SetMouseInputEnabled(true)
					ele:SetWide(ele:GetWide() + 1)
					ele:SetTall(ele:GetTall() + 2)
					ele.Paint = urlpaint
					ele.m_URL = url

						local realurl = ele.m_URL:Trim()

						local btn = vgui.Create("DButton", ele)
						btn:SetToolTip(realurl)
						btn:SetText("")
						btn:Dock(FILL)
						btn.Paint = function() end
						btn.DoClick = function(me)
							gui.OpenURL(realurl)
						end
						btn.DoRightClick = function(me)
							line:ShowMenu({
								{text = "copy_url", func = function()
									SetClipboardText(realurl)
								end}
							})
						end
						ele.m_Button = btn

					table.insert(urlbtns, btn)
					ele.m_Buttons = urlbtns
				end
			end
		elseif (istable(el)) then
			if (el.r) then
				defaultcolor = el
			elseif (el.font) then
				defaultfont = el.font
			elseif (el.linebreak) then
				forcebreak = true
			elseif (el.noparse ~= nil) then
				noparse = el.noparse
			elseif (el.bypass ~= nil) then
				bypassperm = el.bypass
			elseif (el.pre and i == 1) then
				ele = el.pre
				ele:SetParent(contents)
				pre = ele

				bx = bx + ele:GetWide() + (el.space or 0)
			elseif (el.url ~= nil) then
				url = el.url

				if (url == false) then
					for _, v in ipairs (urlbtns) do
						if (IsValid(v)) then
							v.m_Buttons = table.Copy(urlbtns)
						end
					end

					urlbtns = {}
				end
			elseif (el.origtext) then
				origtext = el.origtext
			elseif (el.lua ~= nil) then
				lua = el

				if (el.lua == false) then
					for _, v in ipairs (luabtns) do
						if (IsValid(v)) then
							v.m_Buttons = table.Copy(luabtns)
						end
					end

					luabtns = {}
					lua = nil
				end
			elseif (el.underline ~= nil) then
				underline = el.underline
			end
		elseif (IsPlayer(el)) then
			local coltouse = team.GetColor(el:Team())
			if (ROLE_DETECTIVE and el.IsActiveDetective and el:IsActiveDetective()) then
				coltouse = Color(50, 200, 255)
			end

			ele = self:MakeChatLabel(el:Nick(), defaultfont, coltouse, contents)
		elseif (ispanel(el)) then
			ele = el
		end

		if (lua and ispanel(ele) and IsValid(ele)) then
			local func = lua.lua

			ele:SetMouseInputEnabled(true)
			ele:SetCursor("user")
			ele.m_Lua = lua

				local btn = vgui.Create("DButton", ele)
				btn:SetText("")
				btn:Dock(FILL)
				btn.Paint = function() end
				btn.DoClick = function(me)
					func()
				end
				btn.DoRightClick = function(me)
					line:ShowMenu()
				end
				ele.m_Button = btn

				if (lua.hover) then
					btn.OnCursorEntered = function(me)
						func()
					end
				end
		end

		local function newl()
			if (lh == 0) then
				lh = draw.GetFontHeight(defaultfont)
			end

			x = bx
			h = h + lh
			y = y + lh
			lh = 0
			inline = {}
		end

		if (IsValid(ele)) then
			local wi, he = ele:GetWide(), ele:GetTall()
			if (i == 1 and bx > 0) then
				wi = math.max(wi, bx)
			end

			if (x + wi > maxwi) then
				newl()
			end

			if (he > lh) then
				lh = he

				-- center vertically all prior elements in the line to take in account the new line height
				for _, v in ipairs (inline) do
					v:AlignTop(y + lh * 0.5 - v:GetTall() * 0.5)
				end
			end

			if (ele:GetName() ~= "DButton") then
				ele.OnMousePressed = function(me, mc)
					line:OnMousePressed(mc)
				end
			end

			ele:SetPos(x, y + lh * 0.5 - he * 0.5)
			x = x + wi
			w = x
			table.insert(inline, ele)
		end

		if (nl or forcebreak) then
			newl()
			nl = false
			forcebreak = false
		end
	end

	if (lh > 0) then
		h = h + lh
	end

	line:SetSize(w, h)

	return line
end

function LOUNGE_CHAT:AddToChatbox(el)
	if (!IsValid(_LOUNGE_CHAT)) then
		return end

	--
	el:SetAlpha(0)
	el:AlphaTo(255, self.Anims.FadeInTime)

	el.m_fLastVisible = RealTime()
	el.Think = function(me)
		-- Dynvis
		local sc = _LOUNGE_CHAT.m_iScrollMin
		local sc2 = _LOUNGE_CHAT.m_iScrollMax

		local a, b = me.y, me.y + me:GetTall()
		me.m_Contents:SetVisible((a >= sc and a <= sc2) or (b >= sc and b <= sc2))

		-- fadeout
		local rt = RealTime()
		if (!self.ChatboxOpen) then
			if (rt - me.m_fLastVisible >= chat_message_hidetime_cache and !me.m_bFading) then
				me.m_bFading = true
				me:AlphaTo(0, self.Anims.TextFadeOutTime)
			end
		else
			me.m_bFading = nil
			me.m_fLastVisible = rt
			me:Stop()
			me:SetAlpha(255)
		end
	end

	local his = _LOUNGE_CHAT.m_History
	local can = his:GetCanvas()

	if (self.MaxMessages > 0 and #can:GetChildren() > self.MaxMessages) then
		local i = 0
		while (#can:GetChildren() - i > self.MaxMessages) do
			local child = can:GetChild(i)
			if (IsValid(child)) then
				child:Remove()
				i = i + 1
			else
				break
			end
		end
	end

	his:AddItem(el)
	el:Dock(TOP)
	-- no
	can:SetTall(can:GetTall() + el:GetTall())
	his.VBar:SetUp(his:GetTall(), can:GetTall())

	if not (self.ChatboxOpen and chat_no_scroll_while_open:GetBool()) then
		-- his.VBar:SetScroll(can:GetTall() + el:GetTall())
		his:GetCanvas():InvalidateLayout(true)
		timer.Simple(0, function()
			if (!IsValid(his) or !IsValid(el)) then
				return end

			his:ScrollToBottom()
		end)
	end

	chat.PlaySound()

	return el
end

function LOUNGE_CHAT:OpenChatbox(bteam)
	if (self.ChatboxOpen) then
		return end

	hook.Call("StartChat", GAMEMODE, bteam)

	if (!IsValid(_LOUNGE_CHAT)) then
		self:CreateChatbox()
	end
	if (IsValid(_LOUNGE_CHAT_EMOTICONS)) then
		_LOUNGE_CHAT_EMOTICONS:SetVisible(false)
	end

	-- Fade in
	_LOUNGE_CHAT.m_fAlpha = 0
	_LOUNGE_CHAT:Stop()
	_LOUNGE_CHAT:NewAnimation(self.Anims.FadeInTime).Think = function(anim, me, frac)
		me.m_fAlpha = 255 * frac
	end

	--
	_LOUNGE_CHAT:MakePopup()

	_LOUNGE_CHAT.m_Entry.m_iCurPos = nil
	_LOUNGE_CHAT.m_Entry:RequestFocus()

	if (ROLE_TRAITOR and LocalPlayer().IsSpecial and !LocalPlayer():IsSpecial()) then
		bteam = false
	end
	_LOUNGE_CHAT.m_bTeam = bteam

	self.ChatboxOpen = true
 
	net.Start("LOUNGE_CHAT.Typing")
		net.WriteBool(true)
	net.SendToServer() 
end

function LOUNGE_CHAT:CloseChatbox()
	if (IsValid(_LOUNGE_CHAT_EMOTICONS)) then
		_LOUNGE_CHAT_EMOTICONS:Close()
	end

	self.ChatboxOpen = false

	net.Start("LOUNGE_CHAT.Typing")
		net.WriteBool(false)
	net.SendToServer()

	hook.Call("ChatTextChanged", GAMEMODE, "")
	hook.Call("FinishChat", GAMEMODE)

	-- Fade out
	local a = _LOUNGE_CHAT.m_fAlpha or 255

	_LOUNGE_CHAT:Stop()
	_LOUNGE_CHAT:NewAnimation(self.Anims.FadeOutTime * (a / 255)).Think = function(anim, me, frac)
		me.m_fAlpha = a * (1 - frac)
	end

	--
	_LOUNGE_CHAT:SetKeyboardInputEnabled(false)
	_LOUNGE_CHAT:SetMouseInputEnabled(false)

	_LOUNGE_CHAT.m_Entry:SetText("")
end

chat.OldGetChatBoxPos = chat.OldGetChatBoxPos or chat.GetChatBoxPos
chat.OldGetChatBoxSize = chat.OldGetChatBoxSize or chat.GetChatBoxSize
chat.OldAddText = chat.OldAddText or chat.AddText

function chat.GetChatBoxPos()
	if (IsValid(_LOUNGE_CHAT)) then
		return _LOUNGE_CHAT:GetPos()
	else
		return chat.OldGetChatBoxPos()
	end
end

function chat.GetChatBoxSize()
	if (IsValid(_LOUNGE_CHAT)) then
		return _LOUNGE_CHAT:GetSize()
	else
		return chat.OldGetChatBoxSize()
	end
end

function chat.AddText(...)
	local args = {...}

	local t = {}
	for _, v in pairs (args) do
		if (isstring(v)) then
			table.insert(t, v)
		end
	end
	local origtext = table.concat(t, "")
	table.insert(args, {origtext = origtext})

	chat.OldAddText(...)
	LOUNGE_CHAT:AddToChatbox(LOUNGE_CHAT:ParseLineWrap(args, true))
end

concommand.Add("lounge_chat_clear", function()
	_LOUNGE_CHAT.m_History:Clear()
end)

local con = {}
local tab = {}
local function Add(el, console, i)
	if (istable(el) and #el > 1) then
		table.Add(tab, el)
	else
		if (i) then
			table.insert(tab, i, el)
		else
			table.insert(tab, el)
		end
	end

	if (console) then
		if (istable(el) and !el.r) then
			table.Add(con, el)
		else
			if (i) then
				table.insert(con, i, el)
			else
				table.insert(con, el)
			end
		end
	end
end

-- this is terrible and should be rewritten
function LOUNGE_CHAT:OnPlayerChat(ply, text, bteam, bdead, preftext, prefcolor, color)


	con = {}
	tab = {}

	Add({bypass = true})

	local textcol = color_white
	local namecol = IsValid(ply) and team.GetColor(ply:Team()) or color_white

	if (IsValid(ply)) then
		local ccp = self.CustomColorsPlayers[ply:SteamID()] or self.CustomColorsPlayers[ply:SteamID64()]
		local ccu = self.CustomColorsGroups[ply:GetUserGroup()]
		namecol = ccp or ccu or namecol
	end

	-- (shitty) dayz tags
	if (engine.ActiveGamemode() == "dayz") or (DrawHPImage and DrawAmmoInfo) then
		local sign = text:sub(1, 1)
		if (self.DayZ_ChatTags[sign]) then
			local fs = string.find(text, " ")
			if (fs) then
				local cmd = self.sub(text, 2, fs - 1)
				local tag = self.DayZ_ChatTags[sign][cmd]
				if (tag) then
					Add({tag.tagcolor, tag.tag}, true)
					text = self.sub(text, fs + 1)
				end
			end
		end
	end

	if (IsValid(ply)) then
		-- customtags
		if (ATAG) then
			local pieces, messageColor, nameColor = ply:getChatTag()
			if (pieces) then
				for _, p in pairs (pieces) do
					Add({p.color, p.name})

					if (!nameColor) then
						namecol = p.color
					end
				end

				namecol = nameColor or namecol
				textcol = messageColor or textcol
			end
		elseif (self.EnableCustomTags) then
			local ct = self.CustomTagsPlayers[ply:SteamID()] or self.CustomTagsPlayers[ply:SteamID64()]
			if (ct) then
				Add(ct)
			else
				ct = self.CustomTagsGroups[ply:GetUserGroup()]
				if (ct) then
					Add(ct)
				end
			end
		end

		-- TeamTags
		if (self.TeamTags) then
			local t = ply:Team()

			local tx = string.format(self.TeamTagsFormat, team.GetName(t))
			if (self.TeamTagsCase == 1) then
				tx = tx:upper()
			elseif (self.TeamTagsCase == -1) then
				tx = tx:lower()
			end

			Add({
				team.GetColor(t),
				tx
			})
		end

		if (!self.ProfanityBypass[ply:GetUserGroup()]) then
			for _, word in pairs (self.ProfanityFilter) do
				local tries = 0
				local s, e = string.find(text:lower(), word)
				while (s and tries <= 128) do
					text = text:sub(1, s - 1) .. string.rep(self.CensorCharacter, e - s + 1) .. text:sub(e + 1)
					tries = tries + 1
					s, e = string.find(text, word)
				end
			end
		end
	end

	-- TTT detective color
	if (IsValid(ply) and ROLE_DETECTIVE and ply.IsActiveDetective and ply:IsActiveDetective()) then
		namecol = Color(50, 200, 255)
	end

	if (bdead) then
		Add(self.TagDead)
		table.Add(con, self.TagDeadConsole)
	end

	if (bteam) then
		if (ROLE_TRAITOR and LocalPlayer().IsSpecial and !LocalPlayer():IsSpecial()) then
			bteam = false
		end

		if (bteam == true and IsValid(ply)) then
			Add({team.GetColor(ply:Team()), self.TagTeam})

			table.insert(con, team.GetColor(ply:Team()))
			table.Add(con, self.TagTeamConsole)
		elseif (istable(bteam) and bteam.color and bteam.text) then
			Add({bteam.color, bteam.text}, true)
		end
	end

	-- should be darkrp
	local darkrp = DarkRP and preftext and prefcolor and color
	if (darkrp) then
		if (preftext) then
			Add({prefcolor, preftext})
			textcol = messageColor or color
		end
	end

	if (IsValid(ply)) then
		if (self.ShowPlayerAvatar and !GetConVar("lounge_chat_hide_avatars"):GetBool()) then
			local av = self:Avatar(ply)
			av.m_bMessageAvatar = true

			Add({
				pre = av,
				space = 4,
			}, false, 1)
		end
	end

	local ts = chat_timestamps:GetBool()
	if (ts) then
		table.insert(con, 1, "[" .. self.Timestamp() .. "] ")
		table.insert(con, 1, self.Color("timestamp"))
	end

	if (self.MessageStyle == 0 and ts) then
		Add("<timestamp=" .. os.time() .. "> - ", nil, 2)
	end

	if (darkrp) then
		table.insert(con, prefcolor)
		table.insert(con, preftext)
		table.insert(con, textcol)
		table.insert(con, ": " .. text)
	else
		if (IsValid(ply)) then
			if (self.DisallowParsersInName) then
				Add({namecol, {noparse = true}, ply:Nick(), {noparse = false}}, true)
			else
				Add({namecol, ply:Nick()}, true)
			end
		else
			Add(self.ConsoleName, true)
		end
	end

	if (self.MessageStyle == 1) then
		if (ts) then
			Add({textcol, " - <timestamp=" .. os.time() .. ">"}, nil, 2)
		end

		Add({linebreak = true})
	end

	Add({bypass = false})

	Add({textcol, (self.MessageStyle == 1 and "" or ": ") .. text})
	if (!darkrp) then
		table.Add(con, {textcol, ": " .. text})
	end

	-- console friendly message
	--chat.OldAddText(unpack(con))

	-- actual message
	--table.insert(tab, {origtext = text})
	--self:AddToChatbox(self:ParseLineWrap(tab, true, nil, ply))
end


-- for developers. The text is not styled so you will have to do that yourself
-- The func is called when the player clicks on the message label
-- set hover to true to trigger the func on text hover
function LOUNGE_CHAT:AddLuaMessage(text, func, hover)
	local tab = {
		{origtext = text},
		{lua = func, hover = hover or false},
		text,
		{lua = false},
	}

	self:AddToChatbox(self:ParseLineWrap(tab, true, nil, ply))
end

LOUNGE_CHAT.LuaButtons = {}

function LOUNGE_CHAT:MakeLuaButton(text, func, hover)
	local i = #self.LuaButtons + 1
	self.LuaButtons[i] = func

	return "<luabtn=" .. i .. "," .. (hover and 1 or 0) .. ">" .. text .. "</luabtn>"
end

hook.Add("OnPlayerChat", "LOUNGE_CHAT.OnPlayerChat", function(ply, text, bteam, bdead, preftext, prefcolor, color)
	LOUNGE_CHAT:OnPlayerChat(ply, text, bteam, bdead, preftext, prefcolor, color)
	return true
end)

hook.Add("PlayerBindPress", "LOUNGE_CHAT.PlayerBindPress", function(ply, bind, press)
	if (bind:find("messagemode")) then
		LOUNGE_CHAT:OpenChatbox(bind:find("messagemode2"))
		return true
	end
end)

hook.Add("ChatText", "LOUNGE_CHAT.ChatText", function(index, name, text, typ)
	if (index ~= 0) then
		return end

	chat.AddText(text)
end)

hook.Add("HUDShouldDraw", "LOUNGE_CHAT.HUDShouldDraw", function(h)
	if (h == "CHudChat") then
		return false
	end
end)

LOUNGE_CHAT:CreateChatboxFonts()

hook.Add("InitPostEntity", "LOUNGE_CHAT.InitPostEntity", function()
	-- "Load twice because apparently once is not enough"
	LOUNGE_CHAT:CreateChatboxFonts()
end)

hook.Add("Think", "LOUNGE_CHAT.Think", function()
	if (IsValid(LocalPlayer())) then
		hook.Remove("Think", "LOUNGE_CHAT.Think")
		hook.Remove("OnPlayerChat", "ATAG_ChatTags")

		LOUNGE_CHAT:CreateChatbox()

		for _, v in pairs (messagequeue) do
			LOUNGE_CHAT:AddToChatbox(LOUNGE_CHAT:ParseLineWrap(v.cont, v.maxwi, v.parent, v.sender))
		end

		-- TTT override
		if (ROLE_TRAITOR) then
			net.Receive("TTT_RoleChat", LOUNGE_CHAT.TTT_RoleChat)
			net.Receive("TTT_LastWordsMsg", LOUNGE_CHAT.TTT_LastWordsMsg)
		end
	end
end)

-- shitty override for a shitty gamemode
net.Receive("LOUNGE_CHAT.TTTRadio", function()
	local sender = net.ReadEntity()
	local msg = net.ReadString()
	local param = net.ReadString()
	if not (IsValid(sender) and sender:IsPlayer()) then
		return end

	GAMEMODE:PlayerSentRadioCommand(sender, msg, param)

	-- if param is a language string, translate it
	-- else it's a nickname
	local lang_param = LANG.GetNameParam(param)
	if (lang_param) then
		if lang_param == "quick_corpse_id" then
			-- special case where nested translation is needed
			param = LANG.GetParamTranslation(lang_param, {player = net.ReadString()})
		else
			param = LANG.GetTranslation(lang_param)
		end
	end

	local text = LANG.GetParamTranslation(msg, {player = param})

	-- don't want to capitalize nicks, but everything else is fair game
	if (lang_param) then
		text = util.Capitalize(text)
	end

	if (sender:IsDetective()) then
		LOUNGE_CHAT:OnPlayerChat(
			sender,
			text,
			{
				color = Color(20, 100, 255),
				text = Format("(%s) ", string.upper(LANG.GetTranslation("detective")))
			},
			false
		)
	else
		LOUNGE_CHAT:OnPlayerChat(sender, text, false, false)
	end
end)

function LOUNGE_CHAT.TTT_RoleChat()
	local role = net.ReadUInt(2)
	local sender = net.ReadEntity()
	if not (IsValid(sender)) then
		return end

	local text = net.ReadString()

	if (role == ROLE_TRAITOR) then
		LOUNGE_CHAT:OnPlayerChat(
			sender,
			text,
			{
				color = Color(255, 30, 40),
				text = Format("(%s) ", string.upper(LANG.GetTranslation("traitor")))
			},
			false
		)
	elseif (role == ROLE_DETECTIVE) then
		LOUNGE_CHAT:OnPlayerChat(
			sender,
			text,
			{
				color = Color(20, 100, 255),
				text = Format("(%s) ", string.upper(LANG.GetTranslation("detective")))
			},
			false
		)
	end
end

function LOUNGE_CHAT.TTT_LastWordsMsg()
	local sender = net.ReadEntity()
	if not (IsValid(sender)) then
		return end

	local text = net.ReadString()

	LOUNGE_CHAT:OnPlayerChat(
		sender,
		text,
		{
			color = Color(150, 150, 150),
			text = Format("(%s) ", string.upper(LANG.GetTranslation("last_words"))),
		},
		false
	)
end
--addons/sh_lounge_chatbox/lua/chatbox_tags.lua:
/**
* Tags configuration
* This is not a dedicated tags add-on, there are probably better add-ons out there for tags.
**/

-- Tag to display for a dead player's message in the CHAT
-- You can use parsers here.
LOUNGE_CHAT.TagDead = "<color=255,0,0>*DEAD*</color> "

-- Tag to display for a player's team message in the CHAT
-- The color preceding this will be the player's team color.
-- You can use parsers here.
LOUNGE_CHAT.TagTeam = "(TEAM) "

-- Tag to display for a dead player's message in the CONSOLE
-- You can't put parsers in there. What you can do is use a table for different text/colors.
LOUNGE_CHAT.TagDeadConsole = {Color(255, 0, 0), "*DEAD* "}

-- Tag to display for a player's team message in the CONSOLE
-- The color preceding this will be the player's team color.
-- You can't put parsers in there. What you can do is use a table for different text/colors.
LOUNGE_CHAT.TagTeamConsole = {"(TEAM) "}

/**
* Name Color configuration
*/

-- Here you can set up custom name colors for specific usergroups.
-- By default the name color is the player's team color.
LOUNGE_CHAT.CustomColorsGroups = {
	["superadmin"] = Color(255, 0, 0),
}

-- Here you can set up custom name colors for specific players.
-- This takes priority over the usergroup custom color.
-- By default the name color is the player's team color.
LOUNGE_CHAT.CustomColorsPlayers = {
	["STEAM_0:1:8039869"] = Color(0, 255, 255),
	["76561197976345467"] = Color(0, 255, 255),
}

/**
* Team Tags configuration
*/

-- Set to true to display the player's team name before their name.
LOUNGE_CHAT.TeamTags = false

-- Set to 1 to change the team tag's case to uppercase.
-- Set to -1 to change it to lowercase.
LOUNGE_CHAT.TeamTagsCase = 1

-- (Advanced) String format of the team tag. Leave it alone if you don't know what this does.
LOUNGE_CHAT.TeamTagsFormat = "[%s]"

/**
* DayZ Tags configuration
* Because the generic DayZ gamemode for sale on gmodstore is terribly coded in general,
* we have to discard its tag system and use our own instead.
* Don't touch this if you don't know what this does.
**/

local ooc = {
	tagcolor = Color(100, 100, 100),
	tag = "[OOC] ",
}

LOUNGE_CHAT.DayZ_ChatTags = {
	["!"] = {
		["ooc"] = ooc,
		["g"] = ooc,
		["y"] = ooc,
	},
	["/"] = {
		["ooc"] = ooc,
		["g"] = ooc,
		["y"] = ooc,
		["/"] = ooc,
	},
}

/**
* Custom Tags configuration
* If aTags is installed, this won't be used at all.
**/

-- Enable custom tags for specific usergroups/players.
LOUNGE_CHAT.EnableCustomTags = true

-- Here is where you set up custom tags for usergroups.
-- If there's a custom tag for a specific SteamID/SteamID64, it'll take priority over the one here.
-- If you don't want a group to have a custom tag, then don't put it in the table.
-- You can use parsers here.
LOUNGE_CHAT.CustomTagsGroups = {
	["vip"] = ":award_star_gold_1: <color=gold>(VIP)</color>",
	["admin"] = ":shield: <color=green>(Admin)</color>",
	["superadmin"] = ":star: <flash=red,5>(Super Admin)</flash>",
}

-- Here is where you set up custom tags for specific players. Accepts SteamIDs and SteamID64s.
-- This takes priority over the usergroup custom tag.
-- You can use parsers here.
LOUNGE_CHAT.CustomTagsPlayers = {
	["STEAM_0:1:8039869"] = "<color=aquamarine>(:script: Chatbox author)</color>",
	["76561197976345467"] = "<color=aquamarine>(:script: Chatbox author)</color>",
}
--lua/autorun/awv2_addparticle.lua:
game.AddParticles( "particles/thw_river_aw.pcf" )
--addons/aoc_fire_system/lua/ch_fire_system/shared/fire_darkrpadds.lua:
-- this aint darkrp
--addons/fspectate/lua/fspectate/sh_init.lua:
if not CAMI then return end

CAMI.RegisterPrivilege{
    Name = "FSpectate",
    MinAccess = "admin"
}

CAMI.RegisterPrivilege{
    Name = "FSpectateTeleport",
    MinAccess = "admin"
}

--addons/gm_express_binding/lua/autorun/gm_express_bindings.lua:
include( "gm_express_bindings/sh_init.lua" )

--addons/gm_express_binding/lua/gm_express_bindings/sh_init.lua:
AddCSLuaFile()

ExpressBindings = {}
ExpressBindings.Modules = {}
ExpressBindings.waiting = {}

if SERVER then
    util.AddNetworkString( "express_bindings_change" )
end

local loaded = false
function ExpressBindings.waitForExpress( name, cb )
    if loaded then
        ErrorNoHalt( "ExpressBindings.waitForExpress called after Express was loaded!" )
        return cb()
    end

    ExpressBindings.waiting[name] = cb
end

-- Creates a toggleable module. Handles changes and enable/disable callbacks
function ExpressBindings.RegisterModule( name, module )
    local cvarName = "express_bindings_enable_" .. name
    local cvar = CreateConVar( cvarName, module.default and 1 or 0, FCVAR_ARCHIVE + FCVAR_REPLICATED, "Express Bindings: Enable/Disable " .. name )
    module.setting = cvar

    if SERVER then
        -- Server broadcasts changes to clients using net instead of cvar callbacks
        -- due to a bug where cvar callbacks are not called on clients for replicated cvars
        cvars.AddChangeCallback( cvarName, function( _, _, new )
            new = tobool( new )

            net.Start( "express_bindings_change" )
                net.WriteString( name )
                net.WriteBool( new )
            net.Broadcast()

            if not module:IsValid() then return end

            if new then
                module.Enable()
            else
                module.Disable()
            end
        end, "module_toggle" )
    end

    -- First load setting
    ExpressBindings.waitForExpress( name, function()
        if cvar:GetBool() and module:IsValid() then
            module.Enable()
        end
    end )

    ExpressBindings.Modules[name] = module
end

hook.Add( "ExpressLoaded", "ExpressBindings_Loader", function()
    hook.Add( "Think", "ExpressBindings_Loader", function()
        hook.Remove( "Think", "ExpressBindings_Loader" )
        loaded = true

        for name, cb in pairs( ExpressBindings.waiting ) do
            local success, err = pcall( cb )
            if not success then
                ErrorNoHalt( "ExpressBindings Loader (" .. name .. ") : " .. err )
            end
        end
    end )
end )

if CLIENT then
    net.Receive( "express_bindings_change", function()
        local moduleName = net.ReadString()
        local enabled = net.ReadBool()

        local module = ExpressBindings.Modules[moduleName]
        if not module:IsValid() then return end

        ProtectedCall( enabled and module.Enable or module.Disable )
    end )
end

include( "sh_loader.lua" )

--addons/billy_gas/lua/gmodadminsuite/sh_core.lua:
AddCSLuaFile()

--######## LOAD CONFIG ########--

GAS:HeaderPrint("")
GAS:HeaderPrint("Loading configs...", GAS_PRINT_TYPE_INFO)

GAS.Config = {}

local function InstallConfigAddon()
	if (SERVER) then
		GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "Looks like the GmodAdminSuite Config Addon has not been installed to your server: ", {Link = "https://gmodsto.re/gmodadminsuite-config-addon"}, "\nYou need to install this addon in order to use & configure GmodAdminSuite.")
	end
end

if (not file.Exists("gmodadminsuite_config.lua", "LUA")) then
	return InstallConfigAddon()
else
	local worked = include("gmodadminsuite_config.lua")
	if (not worked) then
		if (SERVER) then
			GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "GmodAdminSuite config failed to load. You probably have an error in your config. Please read your server's console.")
			return
		end
		return
	else
		GAS:HeaderPrint("Config successfully loaded", GAS_PRINT_COLOR_GOOD, GAS_PRINT_TYPE_INFO)
	end
end

if (not file.Exists("gmodadminsuite_lua_functions.lua", "LUA")) then
	return InstallConfigAddon()
else
	local worked = include("gmodadminsuite_lua_functions.lua")
	if (not worked) then
		if (SERVER) then
			GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "GmodAdminSuite Lua functions config failed to load. You probably have an error in your config. Please read your server's console.")
			return
		end
		return
	else
		GAS:HeaderPrint("Lua functions successfully loaded", GAS_PRINT_COLOR_GOOD, GAS_PRINT_TYPE_INFO)
	end
end

if (SERVER) then
	if (not file.Exists("gmodadminsuite_mysql_config.lua", "LUA")) then
		return InstallConfigAddon()
	else
		GAS.Config.MySQL = {}
		local worked = include("gmodadminsuite_mysql_config.lua")
		if (not worked) then
			GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "GmodAdminSuite MySQL config failed to load. You probably have an error in your config. Please read your server's console.")
			return
		else
			GAS:HeaderPrint("MySQL config successfully loaded", GAS_PRINT_COLOR_GOOD, GAS_PRINT_TYPE_INFO)
		end
	end

	if (not file.Exists("gmodadminsuite_steam_apikey.lua", "LUA")) then
		return InstallConfigAddon()
	else
		GAS.SteamAPI = {}
		GAS.SteamAPI.Config = {}
		local worked = include("gmodadminsuite_steam_apikey.lua")
		if (not worked) then
			GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "GmodAdminSuite Steam API key config failed to load. You probably have an error in your config. Please read your server's console.")
			return
		end
	end
end

--######## ADD RESOURCES ########--

if (SERVER) then
	-- Fonts must be downloaded from the server
	resource.AddFile("resource/fonts/circular-bold.ttf")
	resource.AddFile("resource/fonts/circular-medium.ttf")
	resource.AddFile("resource/fonts/rubik.ttf")
	resource.AddFile("resource/fonts/rubik-bold.ttf")

	if (GAS.Config.WorkshopDL == true or GAS.Config.WorkshopDL == nil) then
		resource.AddWorkshop("1596971443")
	end
	if (GAS.Config.ServerDL == true) then
		for _,v in ipairs({"materials/gmodadminsuite/*", "sound/gmodadminsuite/*"}) do
			local files = file.Find(v, "GAME")
			for _,f in pairs(files) do
				resource.AddFile((v:gsub("%*$", "")) .. f)
			end
		end
	end
else
	for _,v in ipairs((file.Find("sound/gmodadminsuite/*", "GAME"))) do
		util.PrecacheSound("sound/gmodadminsuite/" .. v)
	end
end

--######## Account ID ########--

function GAS:SteamID64ToAccountID(steamid64)
	return GAS:SteamIDToAccountID(util.SteamIDFrom64(steamid64))
end

function GAS:SteamIDToAccountID(steamid)
	local acc32 = tonumber(steamid:sub(11))
	return (acc32 * 2) + tonumber(steamid:sub(9,9))
end

function GAS:AccountIDToSteamID(account_id)
	local sid32 = tonumber(account_id) / 2
	if (sid32 % 1 > 0) then
		return "STEAM_0:1:" .. math.floor(sid32)
	else
		return "STEAM_0:0:" .. sid32
	end
end

function GAS:AccountIDToSteamID64(account_id)
	return util.SteamIDTo64(GAS:AccountIDToSteamID(account_id))
end

--######## MISC ########--

function GAS:IsIPAddress(ip_address, forbid_port)
	local v1,v2,v3,v4,port = ip_address:match("^(%d+)%.(%d+)%.(%d+)%.(%d+)(.*)")
	return
		(v1 ~= nil and (v1 == "0" or (not v1:find("^0") and tonumber(v1) >= 1 and tonumber(v1) <= 255))) and
		(v2 ~= nil and (v2 == "0" or (not v2:find("^0") and tonumber(v2) >= 1 and tonumber(v2) <= 255))) and
		(v3 ~= nil and (v3 == "0" or (not v3:find("^0") and tonumber(v3) >= 1 and tonumber(v3) <= 255))) and
		(v4 ~= nil and (v4 == "0" or (not v4:find("^0") and tonumber(v4) >= 1 and tonumber(v4) <= 255))) and
		(
			(forbid_port == true and (port == nil or #port == 0)) or
			
			(not forbid_port and (
					(port == nil or #port == 0) or
					(port ~= nil and #port > 1 and #port <= 6 and port:sub(1,1) == ":" and
						(port:sub(2) == "0" or
							(tonumber(port:sub(2)) ~= nil and not port:sub(2):find("^0") and tonumber(port:sub(2)) >= 0 and tonumber(port:sub(2)) <= 65535)
						)
					)
				)
			)
		)
end

function GAS:BoolToBit(bool)
	if (bool == true) then
		return 1
	elseif (bool == false) then
		return 0
	end
end
function GAS:BitToBool(bit)
	if (tonumber(bit) == 1) then
		return true
	elseif (tonumber(bit) == 0) then
		return false
	end
end

function GAS:Unvectorize(vec)
	if (vec.r and vec.g and vec.b) then
		local vec_a = ""
		if (vec.a and vec.a ~= 255) then
			vec_a = "," .. vec.a
		end
		return vec.r .. "," .. vec.g .. "," .. vec.b .. vec_a
	elseif (vec.p and vec.y and vec.r) then
		return vec.p .. "," .. vec.y .. "," .. vec.r
	elseif (vec.x and vec.y and vec.z) then
		return vec.x .. "," .. vec.y .. "," .. vec.z
	end
end

function GAS:SetClipboardText(text)
	SetClipboardText(text)
	GAS:PlaySound("confirmed")
	bVGUI.MouseInfoTooltip.Create(GAS:Phrase("copied"))
end

function GAS:OpenURL(url)
	GAS:PlaySound("popup")
	gui.OpenURL(url)
end

function GAS:table_Flip(tbl)
	local new_tbl = {}
	for i,v in pairs(tbl) do
		new_tbl[v] = i
	end
	return new_tbl
end

function GAS:table_IsEmpty(tbl)
	return next(tbl) == nil
end

function GAS:table_ValuesFromKey(tab, key)
	local res = {}
	for k, v in pairs( tab ) do
		if ( v[ key ] ~= nil ) then res[ #res + 1 ] = v[ key ] end
	end
	return res
end

function GAS:table_RemoveEmptyChildren(tbl, tbl_key, parent_tbl)
	for k,v in pairs(tbl) do
		if (type(v) == "table") then
			if (GAS:table_IsEmpty(v)) then
				tbl[k] = nil
				if (tbl_key ~= nil and parent_tbl ~= nil and GAS:table_IsEmpty(tbl)) then
					parent_tbl[tbl_key] = nil
				end
			else
				tbl[k] = GAS:table_RemoveEmptyChildren(v, k, tbl)
			end
		end
	end
	if (GAS:table_IsEmpty(tbl)) then
		if (tbl_key == nil and parent_tbl == nil) then
			return {}
		else
			return nil
		end
	else
		return tbl
	end
end

function GAS:utf8_force_strip(str)
	return (utf8.force(str):gsub("�", ""))
end

--######## LUA FUNCTIONS ########--

function GAS:RunLuaFunction(lua_func_name, ...)
	if (not GAS.LuaFunctions[lua_func_name]) then
		GAS:print("Tried to run a Lua function that doesn't exist! (" .. lua_func_name .. ")", GAS.PRINT_ERROR)
	else
		return GAS.LuaFunctions[lua_func_name](...)
	end
end

--######## TEAM HELPERS ########--

local indexed_teams = {}
function GAS:TeamFromName(team_name)
	if (indexed_teams[team_name] ~= nil) then
		return indexed_teams[indexed_teams]
	else
		for i,v in pairs(team.GetAllTeams()) do
			if (v.Name == team_name) then
				indexed_teams[i] = v.Name
				return i
			end
		end
	end
end

--######## SOUND ########--

local sounds = {alert = "gmodadminsuite/alert.mp3"}
function GAS:PlaySound(sound_name)
	surface.PlaySound(sounds[sound_name] or "gmodadminsuite/" .. sound_name .. ".ogg")
end

--######## MARKUP HELPERS ########--

function GAS:MarkupToPlaintext(str)
	str = tostring(str)
	if (markup and markup.ToPlaintext) then
		return markup.ToPlaintext(str)
	else
		return (str:gsub("</?%a+=?.->",""))
	end
end

function GAS:EscapeMarkup(str)
	str = tostring(str)
	if (markup and markup.Escape) then
		return markup.Escape(str)
	else
		return (str:gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;"))
	end
end

local special_markdown_chars = {"\\","`","*","_","{","}","[","]","(",")","#","+","-",".","!"}
function GAS:EscapeMarkdown(str)
	for _,v in ipairs(special_markdown_chars) do
		str = (str:gsub("%" .. v, "\\" .. v))
	end
	return str
end

function GAS:EscapeJSON(str)
	return (str:gsub("\\", "\\\\"):gsub('"', '\\"'))
end

--######## MySQL ########--

if (SERVER) then
	GAS:EndHeader()
	GAS:StartHeader("Database")
	if (GAS.Config.MySQL.Enabled == true) then
		GAS:HeaderPrint("MySQL enabled", GAS_PRINT_TYPE_INFO)
		local mysqloo_installed = false
		if (system.IsLinux() or system.IsWindows()) then
			local module_name = system.IsLinux() and (jit.arch == "x64" and "gmsv_mysqloo_linux64.dll" or "gmsv_mysqloo_linux.dll") or (jit.arch == "x64" and "gmsv_mysqloo_win64.dll" or "gmsv_mysqloo_win32.dll")
			if (file.Exists("lua/bin/" .. module_name, "GAME")) then
				mysqloo_installed = true
			else
				GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "You do not have the required MySQLOO module installed on your server (lua/bin/" .. module_name .. ") MySQLOO is required to communicate with your MySQL Server.\n", {Link = "https://github.com/FredyH/MySQLOO#install-instructions"})
			end
		else
			GAS.BillysErrors:AddMessage(BillysErrors.IMPORTANCE_FATAL, "You must be running Linux or Windows to use MySQL and its required module, MySQLOO.\n", {Link = "https://github.com/FredyH/MySQLOO#install-instructions"})
		end
		if (mysqloo_installed) then
			GAS:HeaderPrint("MySQLOO is installed!", GAS_PRINT_COLOR_GOOD, GAS_PRINT_TYPE_INFO)
		else
			return
		end
	else
		GAS:HeaderPrint("MySQL disabled, using local server database", GAS_PRINT_TYPE_INFO)
	end

	include("sv_database.lua")
	GAS:EndHeader()
else
	GAS:EndHeader()
end

--######## NETWORKING ########--

include("sh_networking.lua")

--######## HOOKING ########--

function GAS:hook(event, identifier, func)
	GAS:unhook(event, identifier)
	hook.Add(event, "gmodadminsuite:" .. identifier, func)
end
function GAS:unhook(event, identifier)
	hook.Remove(event, "gmodadminsuite:" .. identifier)
end

if (SERVER) then include("gmodadminsuite/sv_hooks.lua") end

--######## TIMERS ########--

function GAS:timer(name, ...)
	GAS:untimer(name)
	timer.Create("gmodadminsuite:" .. name, ...)
end
function GAS:untimer(name)
	timer.Remove("gmodadminsuite:" .. name)
end

--######## CONFIGS ########--

if (not file.IsDir("gmodadminsuite/configs", "DATA")) then
	file.CreateDir("gmodadminsuite/configs", "DATA")
end
if (SERVER) then
	GAS:netInit("getconfig")
	GAS:netInit("uncacheconfig")

	function GAS:DeleteConfig(config_name)
		file.Delete("gmodadminsuite/configs/" .. config_name .. ".txt")
		GAS.ConfigCache[config_name] = nil
	end

	GAS.ConfigCache = {}
	function GAS:GetConfig(config_name, default_config)
		if (GAS.ConfigCache[config_name]) then return GAS.ConfigCache[config_name] end
		if (file.Exists("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA")) then
			local config = file.Read("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA")
			if (config) then
				config = GAS:DeserializeTable(config)
				if (config) then
					GAS.ConfigCache[config_name] = config
					return config
				end
			end
			GAS:print("Failed to load config: " .. config_name .. "; reverting to default config.", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
			GAS.BillysErrors:AddMessage({"Failed to load config: " .. config_name .. "; reverting to default config."})
		end
		if (default_config) then
			GAS:SaveConfig(config_name, default_config)
			return default_config
		end
	end
	function GAS:SaveConfig(config_name, config)
		GAS.ConfigCache[config_name] = config

		local serialized_config = GAS:SerializeTable(config)

		file.Write("gmodadminsuite/configs/" .. config_name .. ".txt", serialized_config)

		GAS:netStart("uncacheconfig")
			net.WriteString(config_name)
		net.Broadcast()

		return config
	end

	GAS:netReceive("getconfig", function(ply)
		local config_name = net.ReadString()
		if (file.Exists("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA")) then
			local data = util.Compress(file.Read("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA"))
			local data_len = #data
			GAS:netStart("getconfig")
				net.WriteString(config_name)
				net.WriteUInt(data_len, 32)
				net.WriteData(data, data_len)
			net.Send(ply)
		end
	end)
else
	GAS.ConfigCache = {}

	GAS.ConfigCallbacks = {}
	function GAS:GetConfig(config_name, callback)
		if (callback) then
			GAS.ConfigCallbacks[config_name] = callback
		end
		if (GAS.ConfigCache[config_name]) then
			if (callback) then
				callback(GAS.ConfigCache[config_name])
			end
			return GAS.ConfigCache[config_name]
		end
		GAS:netStart("getconfig")
			net.WriteString(config_name)
		net.SendToServer()
	end
	GAS:netReceive("getconfig", function()
		local config_name = net.ReadString()
		local data_len = net.ReadUInt(32)
		local data = net.ReadData(data_len)
		data = util.Decompress(data)
		data = GAS:DeserializeTable(data)

		GAS.ConfigCache[config_name] = data

		GAS.ConfigCallbacks[config_name](data)
	end)

	GAS.LocalConfigCache = {}
	function GAS:GetLocalConfig(config_name, default_config)
		if (GAS.LocalConfigCache[config_name]) then return GAS.LocalConfigCache[config_name] end

		if (file.Exists("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA")) then
			local config = file.Read("gmodadminsuite/configs/" .. config_name .. ".txt", "DATA")
			if (config) then
				config = GAS:DeserializeTable(config)
				if (config) then
					GAS.LocalConfigCache[config_name] = config
					return config
				end
			end
		end

		if (default_config) then
			GAS:SaveLocalConfig(config_name, default_config)
			return default_config
		end
	end
	function GAS:SaveLocalConfig(config_name, config)
		GAS.LocalConfigCache[config_name] = config
		file.Write("gmodadminsuite/configs/" .. config_name .. ".txt", GAS:SerializeTable(config))
		return config
	end

	function GAS:UncacheConfig(config_name)
		GAS.ConfigCache[config_name] = nil
	end
	GAS:netReceive("uncacheconfig", function()
		GAS:UncacheConfig(net.ReadString())
	end)
end

--######## SERIALIZATION ########--

GAS.von = include("gmodadminsuite/thirdparty/von.lua")
GAS.pon = include("gmodadminsuite/thirdparty/pon.lua")
GAS.spon = include("gmodadminsuite/thirdparty/spon.lua")
function GAS:SerializeTable(tbl)
	return GAS.von.serialize(tbl)
end
function GAS:DeserializeTable(tbl)
	local succ, r = pcall(GAS.von.deserialize, tbl)
	if (not succ) then
		return GAS.spon.decode(tbl)
	else
		return r
	end
end

--######## LANGUAGE ########--

include("gmodadminsuite/sh_language.lua")

--######## OFFLINE PLAYER DATA ########--

include("gmodadminsuite/sh_offline_player_data.lua")

--######## TEAMS ########--

include("gmodadminsuite/sh_teams.lua")

--######## STEAM API ########--

if (SERVER) then include("gmodadminsuite/sv_steam_avatar.lua") end

--######## AFK ########--

include("gmodadminsuite/sh_afk.lua")

--######## COUNTRY CODES ########--

if (CLIENT) then include("gmodadminsuite/cl_country_codes.lua") end


--######## COMMANDS ########--

local CmdRegistrations = {}
function GAS:RegisterCommand(text, module_name)
	if (GAS.Commands and GAS.Commands.Loaded) then
		GAS.Commands:RegisterCommand(text, module_name)
	else
		table.insert(CmdRegistrations, {text, module_name})
	end
end
GAS:hook("gmodadminsuite:Commands:Loaded", "CommandManagerLoaded", function()
	if (not CmdRegistrations) then return end
	for _,v in ipairs(CmdRegistrations) do
		GAS.Commands:RegisterCommand(unpack(v))
	end
	CmdRegistrations = nil
end)

--######## REGISTRY TABLES ########--

include("gmodadminsuite/sh_registry_tbl.lua")

--######## XEON ########--

if (SERVER) then include("gmodadminsuite/sv_xeon.lua") end

--######## INCLUDE FILES ########--

function GAS:Init()
	include("gmodadminsuite/sh_modules.lua")
	include("gmodadminsuite/sh_permissions.lua")

	if (CLIENT) then
		include("gmodadminsuite/cl_menubar.lua")
		include("gmodadminsuite/cl_contextmenu.lua")
		include("gmodadminsuite/cl_selection_prompts.lua")
		include("gmodadminsuite/cl_menu.lua")
	else
		include("gmodadminsuite/sv_menu.lua")
	end
end
GAS:Init()
--addons/billy_gas/lua/gmodadminsuite/modules/secondaryusergroups/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "Secondary Usergroups",

		open_menu          = "Open Menu",
		custom_ellipsis    = "Custom...",
		usergroup_ellipsis = "Usergroup...",
		players            = "Players",
		settings           = "Settings",
		players            = "Players",
		give_usergroup     = "Give Usergroup",
		usergroup_ellipsis = "Usergroup...",
		usergroup_is_main  = "This is the user's main usergroup, and cannot be given or revoked.",
		help               = "Help",
		offline_btn        = "New Player...",
		loading_ellipsis   = "Loading...",
		unknown            = "Unknown",

} end }
--addons/tools/lua/vgui/stackercontrolpresets.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:OpenPresetEditor()
--
--]]--
function PANEL:OpenPresetEditor()
	if ( not self.m_strPreset ) then return end
	self.Window = vgui.Create( "StackerPresetEditor" )
	self.Window:MakePopup()
	self.Window:Center()
	self.Window:SetType( self.m_strPreset )
	self.Window:SetConVars( self.ConVars )
	self.Window:SetPresetControl( self )
end

vgui.Register( "StackerControlPresets", PANEL, "ControlPresets" )
--addons/lvs_base/lua/includes/circles/circles.lua:
if SERVER then return false end

local _R = debug.getregistry()
if _R.Circles then return _R.Circles end

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local New do
	local err_number = "bad argument #%i to 'New' (number expected, got %s)"

	function New(t, r, x, y, ...)
		assert(isnumber(t), string.format(err_number, 1, type(t)))
		assert(isnumber(r), string.format(err_number, 2, type(r)))
		assert(isnumber(x), string.format(err_number, 3, type(x)))
		assert(isnumber(y), string.format(err_number, 4, type(y)))

		local circle = setmetatable({}, CIRCLE)

		circle:SetType(t)
		circle:SetRadius(r)
		circle:SetX(x)
		circle:SetY(y)

		circle:SetVertices({Count = 0})

		if t == CIRCLE_OUTLINED then
			local outline_width = ...
			assert(outline_width == nil or isnumber(outline_width), string.format(err_number, 5, type(outline_width)))

			circle:SetOutlineWidth(outline_width)
		elseif t == CIRCLE_BLURRED then
			local blur_layers, blur_density = ...
			assert(blur_layers == nil or isnumber(blur_layers), string.format(err_number, 5, type(blur_layers)))
			assert(blur_density == nil or isnumber(blur_density), string.format(err_number, 6, type(blur_density)))

			circle:SetBlurLayers(blur_layers)
			circle:SetBlurDensity(blur_density)
		end

		return circle
	end
end

local RotateVertices do
	local err_table = "bad argument #1 to 'RotateVertices' (table expected, got %s)"
	local err_number = "bad argument #%i to 'RotateVertices' (number expected, got %s)"

	function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
		assert(istable(vertices), string.format(err_table, type(vertices)))
		assert(isnumber(ox), string.format(err_number, 2, type(ox)))
		assert(isnumber(oy), string.format(err_number, 3, type(oy)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))

		local rotation = math.rad(rotation)
		local c = math.cos(rotation)
		local s = math.sin(rotation)

		for i = 1, vertices.Count or #vertices do
			local vertex = vertices[i]
			local vx, vy = vertex.x, vertex.y

			vx = vx - ox
			vy = vy - oy

			vertex.x = ox + (vx * c - vy * s)
			vertex.y = oy + (vx * s + vy * c)

			if rotate_uv == false then
				local u, v = vertex.u, vertex.v
				u, v = u - 0.5, v - 0.5

				vertex.u = 0.5 + (u * c - v * s)
				vertex.v = 0.5 + (u * s + v * c)
			end
		end
	end
end

local CalculateVertices do
	local err_number = "bad argument #%i to 'CalculateVertices' (number expected, got %s)"

	function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		assert(isnumber(radius), string.format(err_number, 3, type(radius)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))
		assert(isnumber(start_angle), string.format(err_number, 5, type(start_angle)))
		assert(isnumber(end_angle), string.format(err_number, 6, type(end_angle)))
		assert(isnumber(distance), string.format(err_number, 7, type(distance)))

		local vertices = {Count = 0}
		local step = distance / radius

		local rad_start_angle = math.rad(start_angle)
		local rad_end_angle = math.rad(end_angle)
		local rad_rotation = math.rad(rotation)

		for a = rad_start_angle, rad_end_angle + step, step do
			a = math.min(a, rad_end_angle)

			local c = math.cos(a + rad_rotation)
			local s = math.sin(a + rad_rotation)

			local vertex = {
				x = x + c * radius,
				y = y + s * radius,
			}

			if rotate_uv == false then
				vertex.u = 0.5 + math.cos(a) / 2
				vertex.v = 0.5 + math.sin(a) / 2
			else
				vertex.u = 0.5 + c / 2
				vertex.v = 0.5 + s / 2
			end

			vertices.Count = vertices.Count + 1
			vertices[vertices.Count] = vertex
		end

		if end_angle - start_angle ~= 360 then
			table.insert(vertices, 1, {
				x = x, y = y,
				u = 0.5, v = 0.5,
			})

			vertices.Count = vertices.Count + 1
		else
			table.remove(vertices)
			vertices.Count = vertices.Count - 1
		end

		return vertices
	end
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:IsValid()
	return (
		not self.m_Dirty and
		self.m_Vertices.Count >= 3 and
		self.m_Radius >= 1 and
		self.m_Distance >= 1
	)
end

function CIRCLE:Calculate()
	local rotate_uv = self.m_RotateMaterial

	local radius = self.m_Radius
	local x, y = self.m_X, self.m_Y

	local rotation = self.m_Rotation
	local start_angle = self.m_StartAngle
	local end_angle = self.m_EndAngle

	local distance = self.m_Distance

	assert(radius >= 1, string.format("circle radius should be >= 1 (%.4f)", radius))
	assert(distance >= 1, string.format("circle distance should be >= 1 (%.4f)", distance))

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if self.m_Type == CIRCLE_OUTLINED then
		local inner = self.m_ChildCircle or self:Copy()
		local inner_r = radius - self.m_OutlineWidth

		inner:SetType(CIRCLE_FILLED)

		inner:SetPos(x, y)
		inner:SetRadius(inner_r)
		inner:SetRotation(rotation)
		inner:SetAngles(start_angle, end_angle)
		inner:SetDistance(distance)

		inner:SetColor(false)
		inner:SetMaterial(false)

		inner:SetShouldRender(inner_r >= 1)
		inner:SetDirty(inner.m_ShouldRender)

		self:SetShouldRender(inner_r < radius)
		self:SetChildCircle(inner)
	elseif self.m_ChildCircle then
		self.m_ChildCircle = nil
	end

	self:SetDirty(false)

	return self
end

do
	local blur = Material("pp/blurscreen")

	function CIRCLE:__call()
		if self.m_Dirty then self:Calculate() end

		if not self:IsValid() then return false end
		if not self.m_ShouldRender then return false end

		do
			local col, mat = self.m_Color, self.m_Material

			if IsColor(col) then
				if col.a <= 0 then return end
				surface.SetDrawColor(col.r, col.g, col.b, col.a)
			end

			if mat == true then
				draw.NoTexture()
			elseif TypeID(mat) == TYPE_MATERIAL then
				surface.SetMaterial(mat)
			end
		end

		if self.m_Type == CIRCLE_OUTLINED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				self.m_ChildCircle()

				render.SetStencilCompareFunction(STENCIL_GREATER)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.DrawPoly(self.m_Vertices)
			render.SetStencilEnable(false)
		elseif self.m_Type == CIRCLE_BLURRED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				surface.DrawPoly(self.m_Vertices)

				render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.SetMaterial(blur)

				local sw, sh = ScrW(), ScrH()

				for i = 1, self.m_BlurLayers do
					blur:SetFloat("$blur", (i / self.m_BlurLayers) * self.m_BlurDensity)
					blur:Recompute()

					render.UpdateScreenEffectTexture()
					surface.DrawTexturedRect(0, 0, sw, sh)
				end
			render.SetStencilEnable(false)
		else
			surface.DrawPoly(self.m_Vertices)
		end

		return true
	end

	CIRCLE.Draw = CIRCLE.__call
end

do
	local err_number = "bad argument #%i to 'Translate' (number expected, got %s)"

	function CIRCLE:Translate(x, y)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))

		if x ~= 0 or y ~= 0 then
			self.m_X = self.m_X + x
			self.m_Y = self.m_Y + y

			if self:IsValid() then
				for i = 1, self.m_Vertices.Count do
					local vertex = self.m_Vertices[i]

					vertex.x = vertex.x + x
					vertex.y = vertex.y + y
				end

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Translate(x, y)
				end
			end
		end

		return self
	end
end

do
	local err_number = "bad argument #1 to 'Scale' (number expected, got %s)"

	function CIRCLE:Scale(scale)
		assert(isnumber(scale), string.format(err_number, type(scale)))

		if scale ~= 1 then
			self.m_Radius = self.m_Radius * scale

			if self:IsValid() then
				local x, y = self.m_X, self.m_Y

				for i = 1, self.m_Vertices.Count do
					local vertex = self.m_Vertices[i]

					vertex.x = x + (vertex.x - x) * scale
					vertex.y = y + (vertex.y - y) * scale
				end

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Scale(scale)
				end
			end
		end

		return self
	end
end

do
	local err_number = "bad argument #1 to 'Rotate' (number expected, got %s)"

	function CIRCLE:Rotate(rotation)
		assert(isnumber(rotation), string.format(err_number, type(rotation)))

		if rotation ~= 0 then
			self.m_Rotation = self.m_Rotation + rotation

			if self:IsValid() then
				local x, y = self.m_X, self.m_Y
				local vertices = self.m_Vertices
				local rotate_uv = self.m_RotateMaterial

				RotateVertices(vertices, x, y, rotation, rotate_uv)

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Rotate(rotation)
				end
			end
		end

		return self
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if default ~= nil and value == nil then
				value = default
			end

			if self[varname] ~= value then
				if dirty then
					self[dirty] = true
				end

				if callback ~= nil then
					local new = callback(self, self[varname], value)
					value = new ~= nil and new or value
				end

				self[varname] = value
			end

			return self
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		circle:Translate(new - old, 0)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Translate(new - old, 0)
		end
	end

	local function OffsetVerticesY(circle, old, new)
		circle:Translate(0, new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Translate(0, new - old)
		end
	end

	local function UpdateRotation(circle, old, new)
		circle:Rotate(new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Rotate(new - old)
		end
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)
	AccessorFunc("ShouldRender", true)

	AccessorFunc("Color", false)						-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)						-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)				-- Sets whether or not the circle's UV points should be rotated with the vertices.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty")		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX)		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY)		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty")				-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty")			-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")			-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")				-- The maximum distance between each of the circle's vertices. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurLayers", 3)						-- The circle's blur layers if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurDensity", 2)						-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")			-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		x = tonumber(x) or self.m_X
		y = tonumber(y) or self.m_Y

		if self:IsValid() then
			self:Translate(x - self.m_X, y - self.m_Y)
		else
			self.m_X = x
			self.m_Y = y
		end

		return self
	end

	function CIRCLE:SetAngles(s, e)
		s = tonumber(s) or self.m_StartAngle
		e = tonumber(e) or self.m_EndAngle

		self:SetDirty(self.m_Dirty or s ~= self.m_StartAngle or e ~= self.m_EndAngle)

		self.m_StartAngle = s
		self.m_EndAngle = e

		return self
	end

	function CIRCLE:GetPos()
		return self.m_X, self.m_Y
	end

	function CIRCLE:GetAngles()
		return self.m_StartAngle, self.m_EndAngle
	end
end

_R.Circles = {
	_MT = CIRCLE,

	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles

--addons/weapon_jedi/lua/lscs/combos/djemso.lua:
COMBO.id = "djemso"
COMBO.PrintName = "Form V | Djem So"
COMBO.Author = "Deltaa"
COMBO.Description = "Weg des Kraytdrachen"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "lscs_djemso"

COMBO.DamageMultiplier = 1
COMBO.MaxBlockPoints = 125

COMBO.Attacks = {
	["FRONT_DASH"] = {
		AttackAnim = "phalanx_h_s1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["____"] = {
		AttackAnim = "vanguard_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:lscsSetTimedMove(1, CurTime(), 0.5, Vector(150, 0, 0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["-45-"] = {
		AttackAnim = "judge_a_s1_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()

			ply:SetVelocity(Vector(100, 0, 200) + Angle(0, ply:EyeAngles().y, 0):Forward() * 1000 )
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(50, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
    ["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.7, Vector(250,0,0))

			timer.Simple(0.2, function()
				if not IsValid(weapon) then return end

				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid(weapon) then return end

				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function(weapon, ply) end,
		Delay = 0.1,
		Duration = 2,
	},
	["__S_"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "vanguard_r_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(0,-59,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.2,
	},
	["___D"] = {
		AttackAnim = "vanguard_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["W__D"] = {
		AttackAnim = "vanguard_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.5,
	},
	["WA__"] = {
		AttackAnim = "vanguard_h_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "vanguard_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(-1,1,0))
		end,
		FinishAttack = function(weapon, ply) end,
		Delay = 0.2,
		Duration = 0.8,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function(weapon, ply)  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity(Angle(0, ply:EyeAngles().y, 0):Forward() * 1000)
			end

			ply:lscsSetTimedMove(1, CurTime(), 0.4, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.4,
	},
}
--addons/weapon_jedi/lua/lscs/combos/zephra.lua:
COMBO.id = "zephra"
COMBO.PrintName = "Unterform VI | Ze'phra"
COMBO.Author = "Deltaa"
COMBO.Description = "Die tödlichste Form"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "lscs_zephra"

COMBO.DamageMultiplier = 0.8
COMBO.MaxBlockPoints = 125

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "wos_ryoku_a_s2_land",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(1)

            timer.Simple(0.1, function()
                if not IsValid( weapon ) then return end
                ply:EmitSound("physics/concrete/boulder_impact_hard2.wav")
            end)

            ply:SetVelocity(Vector(0,0,-1500))
			ply:lscsSuppressFalldamage(CurTime() + 5)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["FRONT_DASH"] = {
		AttackAnim = "vanguard_a_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(1)
			end)
			timer.Simple(0.3, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(1)
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(2)
			end)
			timer.Simple(0.6, function()
				if not IsValid(weapon) then return end
				weapon:DoAttackSound(3)
			end)

			if ply:OnGround() then
				ply:SetVelocity(Angle(0,ply:EyeAngles().y,0):Forward() * 2500)
			else
				ply:SetVelocity(Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0, 0, 40))
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.9,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "wos_bs_shared_recover_left",
		BeginAttack = function( weapon, ply )  
			ply:SetVelocity(Vector(0,0,0) - Angle(0,ply:EyeAngles().y,0):Right() * 300 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "wos_bs_shared_recover_right",
		BeginAttack = function( weapon, ply )  
			ply:SetVelocity( Vector(0,0,0) + Angle(0,ply:EyeAngles().y,0):Right() * 300 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["____"] = {
		AttackAnim = "ryoku_r_c4_t3",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(100, 0, 0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s2_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(1)
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "ryoku_b_s1_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(1)
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(100, 0, 0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["W_S_"] = {
		AttackAnim = "pure_h_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(400,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.3, Vector(225,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.7, 0.6, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(nil, 1)
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	},
	["__S_"] = {
		AttackAnim = "vanguard_b_s4_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(1)
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(100,0,0))

            timer.Simple(0.2, function()
                if not IsValid( weapon ) then return end
                weapon:DoAttackSound(1)
            end)

            timer.Simple(0.4, function()
                if not IsValid( weapon ) then return end
                weapon:DoAttackSound(2)
            end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["_A__"] = {
		AttackAnim = "pure_b_right_t1",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(0,-150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.2, Vector(0,-80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.6, 0.4, Vector(0,0,0) )

			weapon:DoAttackSound(1, 1)
			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 2 )
			end)
			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["___D"] = {
		AttackAnim = "pure_b_s2_t3",
		AttackAnimStart = 0.3,
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(0,150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.2, Vector(0,80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.6, 0.4, Vector(0,0,0) )

			weapon:DoAttackSound( math.random(1,2), 1 )

			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(nil, 1)
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "pure_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(150,150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.3, Vector(80,80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 1, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 1 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.9, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.25,
	},
	["WA__"] = {
		AttackAnim = "pure_b_right_t3",
		AttackAnimStart = 0.1,
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(150,-150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.3, Vector(80,-80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 1, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 1 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.9, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.25,
	},
	["__SD"] = {
		AttackAnim = "pure_h_s1_t3",
		AttackAnimStart = 0.2,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(2, 1)
			timer.Simple(0.35, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(math.random(1,2), 1)
			end)

			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(150,80,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.5, 0.5, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.5,
	},
	["_AS_"] = {
		AttackAnim = "pure_b_s2_t2",
		AttackAnimStart = 0.05,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			timer.Simple(0.35, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(math.random(1,2), 1)
			end)
			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(150,-80,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.5, 0.5, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["W___"] = {
		AttackAnim = "vanguard_h_right_t3",
		AttackAnimStart = 0,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1)

			if ply:OnGround() then
				ply:SetVelocity(Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end

			ply:lscsSetTimedMove(1, CurTime(), 0.9, Vector(250, 0, 0))

            timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(1)
			end)

            timer.Simple(0.3, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(1)
			end)

            timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(2)
			end)

            timer.Simple(0.7, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(3)
			end)

			-- timer.Simple(0.7, function()
			-- 	if not IsValid( weapon ) then return end
			-- 	weapon:DoAttackSound( 3, 1 )
			-- end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
}
--addons/lvs_base/lua/lvs_framework/autorun/cl_hud.lua:

--LVS.HudForceDefault = true

LVS.HudEditors = LVS.HudEditors or {}
LVS.HudEditorsHide = {}

local function ResetFrame( id )
	if not LVS.HudEditors[ id ] then return end

	LVS.HudEditors[ id ].w = LVS.HudEditors[ id ].DefaultWidth
	LVS.HudEditors[ id ].h = LVS.HudEditors[ id ].DefaultHeight
	LVS.HudEditors[ id ].X = LVS.HudEditors[ id ].DefaultX
	LVS.HudEditors[ id ].Y = LVS.HudEditors[ id ].DefaultY
	LVS.HudEditorsHide[ id ] = nil
end

local function MakeFrame( id, X, Y, w, h, minw, minh, text )
	local Frame = vgui.Create("DFrame")
	Frame:SetSize( w, h )
	Frame:SetPos( X, Y )
	Frame:SetTitle( text )
	Frame:SetScreenLock( true )
	Frame:MakePopup()
	Frame:SetSizable( true )
	Frame:SetMinWidth( minw )
	Frame:SetMinHeight( minh )
	Frame.id = id
	Frame.OnClose = function( self )
		ResetFrame( self.id )
	end
	Frame.Paint = function(self, w, h )
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0, 0, w, h)

		surface.SetDrawColor(80,80,80,255)
		surface.DrawRect(0, 0, 2, h)
		surface.DrawRect(w - 2, 0, 2, h)
		surface.DrawRect(0, 0, w, 2)
		surface.DrawRect(0, h - 2, w, 2)

		if not LVS.HudEditors[ self.id ] then return end

		local Width = self:GetWide()
		local Height = self:GetTall()

		LVS.HudEditors[ self.id ].w = Width
		LVS.HudEditors[ self.id ].h = Height

		LVS.HudEditors[ self.id ].X = math.min( self:GetX(), ScrW() - Width )
		LVS.HudEditors[ self.id ].Y = math.min( self:GetY(), ScrH() - Height )

		if self:IsDragging() or input.IsMouseDown( MOUSE_LEFT ) then return end

		local Ratio = LVS.HudEditors[ self.id ].DefaultHeight / LVS.HudEditors[ self.id ].DefaultWidth

		if math.Round( Height / Width, 2 ) ~= math.Round( Ratio ,2 ) then
			local NewHeight = Width * Ratio

			self:SetHeight( NewHeight )

			LVS.HudEditors[ self.id ].h = NewHeight
		end
	end

	local DCheckbox = vgui.Create( "DCheckBoxLabel", Frame )
	DCheckbox:Dock( RIGHT )
	DCheckbox:DockMargin( 0, 0, 0, 0 )
	DCheckbox:SetText("Hide")	
	DCheckbox:SizeToContents()
	DCheckbox.id = id
	DCheckbox:SetChecked( LVS.HudEditorsHide[ id ] == true )
	DCheckbox.OnChange = function( self, bVal )
		if not self.id then return end

		if bVal then LVS.HudEditorsHide[ self.id ] = true return end

		LVS.HudEditorsHide[ self.id ] = nil
	end

	LVS.HudEditors[ id ].Frame = Frame

	return Frame
end

local ScreenWidth = ScrW()
local ScreenHeight = ScrH()

local function SaveEditors()
	if LVS.HudForceDefault then return end

	if ScreenWidth ~= ScrW() or ScreenHeight ~= ScrH() then return end -- player changed resolution while ingame... don't save because everything is fucked up now...

	local SaveString = ""
	for id, data in pairs( LVS.HudEditors ) do
		local w = data.w
		local h = data.h

		local X = math.min( data.X / ScrW(), 1 )
		local Y = math.min( data.Y / ScrH(), 1 )

		local hide = LVS.HudEditorsHide[ id ] and "?" or " "

		SaveString = SaveString..id.."~"..hide.."~"..w.."#"..h.."/"..X.."#"..Y.."\n"
	end

	file.Write( "lvs_hud_settings.txt", SaveString )
end

local function LoadEditors()
	if LVS.HudForceDefault then return end

	local LoadString = file.Read( "lvs_hud_settings.txt" )

	if not LoadString then return end

	for _, garbage in pairs( string.Explode( "\n", LoadString ) ) do
		local data1 = string.Explode( "~", garbage )

		if not data1[3] then continue end

		local data2 =  string.Explode( "/", data1[3] )

		local size = string.Explode( "#", data2[1] )
		local pos = string.Explode( "#", data2[2] )

		local ID = data1[1]

		if not LVS.HudEditors[ ID ] or not size[1] or not size[2] or not pos[1] or not pos[2] then continue end

		LVS.HudEditors[ ID ].w = math.max( LVS.HudEditors[ ID ].minw, size[1] )
		LVS.HudEditors[ ID ].h = math.max( LVS.HudEditors[ ID ].minh, size[2] )
		LVS.HudEditors[ ID ].X = math.min( pos[1] * ScrW(), ScrW() - size[1] )
		LVS.HudEditors[ ID ].Y = math.min( pos[2] * ScrH(), ScrH() - size[2] )

		if data1[2] == "?" then
			LVS.HudEditorsHide[ ID ] = true
		end
	end
end

function LVS:AddHudEditor( id, X, Y, w, h, minw, minh, text, func )
	LVS.HudEditors[ id ] = {
		DefaultX = X,
		DefaultY = Y,
		DefaultWidth = w,
		DefaultHeight = h,
		X = X,
		Y = Y,
		w = w,
		h = h,
		minw = minw,
		minh = minh,
		text = text,
		func = func,
	}
end

hook.Add( "OnContextMenuOpen", "!!!!!LVS_hud", function()
	if not IsValid( LocalPlayer():lvsGetVehicle() ) then return end

	if not GetConVar( "lvs_edit_hud" ):GetBool() then return end

	LVS:OpenEditors()

	return false
end )

hook.Add( "InitPostEntity", "!!!lvs_load_hud", function()
	LoadEditors()
end )

function LVS:OpenEditors()
	for id, editor in pairs( LVS.HudEditors ) do
		if IsValid( editor.Frame ) then continue end

		MakeFrame( id, editor.X, editor.Y, editor.w, editor.h, editor.minw, editor.minh, editor.text )
	end

	local T = CurTime()
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()

	ply.SwitcherTime = T + 9999

	if not IsValid( pod ) then return end

	pod._SelectActiveTime = T + 9999
end

function LVS:CloseEditors()
	SaveEditors()

	for id, editor in pairs( LVS.HudEditors ) do
		if not IsValid( editor.Frame ) then continue end
		editor.Frame:Remove()
	end

	local T = CurTime()
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()

	ply.SwitcherTime = T

	if not IsValid( pod ) then return end

	pod._SelectActiveTime = T
end

hook.Add( "OnContextMenuClose", "!!!!!LVS_hud", function()
	LVS:CloseEditors()
end )

function LVS:DrawDiamond( X, Y, radius, perc )
	if perc <= 0 then return end

	local segmentdist = 90

	draw.NoTexture()

	for a = 90, 360, segmentdist do
		local Xa = math.Round( math.sin( math.rad( -a ) ) * radius, 0 )
		local Ya = math.Round( math.cos( math.rad( -a ) ) * radius, 0 )

		local C = math.sqrt( radius ^ 2 + radius ^ 2 )

		if a == 90 then
			C = C * math.min(math.max(perc - 0.75,0) / 0.25,1)
		elseif a == 180 then
			C = C * math.min(math.max(perc - 0.5,0) / 0.25,1)
		elseif a == 270 then
			C = C * math.min(math.max(perc - 0.25,0) / 0.25,1)
		elseif a == 360 then
			C = C * math.min(math.max(perc,0) / 0.25,1)
		end

		if C > 0 then
			local AxisMoveX = math.Round( math.sin( math.rad( -a + 135) ) * (C + 3) * 0.5, 0 )
			local AxisMoveY =math.Round( math.cos( math.rad( -a + 135) ) * (C + 3) * 0.5, 0 )

			surface.DrawTexturedRectRotated(X - Xa - AxisMoveX, Y - Ya - AxisMoveY,3, math.ceil( C ), a - 45)
		end
	end
end

local function PaintIdentifier( ent )
	if not LVS.ShowIdent or LVS:IsIndicatorForced() then return end

	local VehicleIdentifierRange = ent.VehicleIdentifierRange
	local MyPos = ent:GetPos()
	local MyTeam = ent:GetAITEAM()

	for _, v in pairs( LVS:GetVehicles() ) do
		if not IsValid( v ) or v == ent then continue end

		local rPos = v:LocalToWorld( v:OBBCenter() )

		local Pos = rPos:ToScreen()
		local Dist = (MyPos - rPos):Length()

		if Dist > VehicleIdentifierRange or util.TraceLine( {start = ent:LocalToWorld( ent:OBBCenter() ),endpos = rPos,mask = MASK_NPCWORLDSTATIC,} ).Hit then continue end

		local Alpha = 255 * (1 - (Dist / VehicleIdentifierRange) ^ 2)
		local Team = v:GetAITEAM()
		local IndicatorColor = Color( 255, 0, 0, Alpha )

		if Team == 0 then
			if MyTeam == 0 then continue end

			IndicatorColor = Color( 0, 255, 0, Alpha )
		else
			if Team == 1 or Team == 2 then
				if Team ~= MyTeam and MyTeam ~= 0 then
					IndicatorColor = Color( 255, 0, 0, Alpha )
				else
					IndicatorColor = Color( 0, 127, 255, Alpha )
				end
			end
		end

		if Team > 3 then continue end

		v:LVSHudPaintVehicleIdentifier( Pos.x, Pos.y, IndicatorColor )
	end
end

hook.Add( "HUDPaint", "!!!!!LVS_hud", function()
	local ply = LocalPlayer()

	if ply:GetViewEntity() ~= ply then return end

	local Pod = ply:GetVehicle()
	local Parent = ply:lvsGetVehicle()

	if not IsValid( Pod ) or not IsValid( Parent ) then
		ply._lvsoldPassengers = {}

		return
	end

	local X = ScrW()
	local Y = ScrH()

	--PaintIdentifier( Parent )
	Parent:LVSHudPaint( X, Y, ply )

	local base = Pod:lvsGetWeapon()
	if IsValid( base ) then
		local weapon = base:GetActiveWeapon()
		if weapon and weapon.HudPaint then
			weapon.HudPaint( base, X, Y, ply )
		end
	else
		local weapon = Parent:GetActiveWeapon()
		if ply == Parent:GetDriver() and weapon and weapon.HudPaint then
			weapon.HudPaint( Parent, X, Y, ply )
		end
	end

	for id, editor in pairs( LVS.HudEditors ) do
		if LVS.HudEditorsHide[ id ] then continue end

		local ScaleX = editor.w / editor.DefaultWidth
		local ScaleY = editor.h / editor.DefaultHeight

		local PosX = editor.X / ScaleX
		local PosY = editor.Y / ScaleY

		local Width = editor.w / ScaleX
		local Height = editor.h / ScaleY

		local ScrW = X / ScaleX
		local ScrH = Y / ScaleY

		if ScaleX == 1 and ScaleY == 1 then
			editor:func( Parent, PosX, PosY, Width, Height, ScrW, ScrH, ply )
		else
			local m = Matrix()
			m:Scale( Vector( ScaleX, ScaleY, 1 ) )

			cam.PushModelMatrix( m )
				editor:func( Parent, PosX, PosY, Width, Height, ScrW, ScrH, ply )
			cam.PopModelMatrix()
		end
	end
end )
--addons/lvs_base/lua/lvs_framework/autorun/lvs_damagenotify.lua:

if CLIENT then 
	net.Receive( "lvs_hurtmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) then return end

		vehicle:HurtMarker( net.ReadFloat() )
	end )

	net.Receive( "lvs_hitmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		local IsCrit = net.ReadBool()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply,  IsCrit and "crit" or "hit" )

			return
		end

		if IsCrit then
			vehicle:CritMarker()
		else
			vehicle:HitMarker()
		end
	end )

	net.Receive( "lvs_killmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply, "kill" )

			return
		end

		vehicle:KillMarker()
	end )

	net.Receive( "lvs_armormarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		local IsDamage = net.ReadBool()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply, IsDamage and "armorcrit" or "armor" )

			return
		end

		vehicle:ArmorMarker( IsDamage )
	end )

	return
end

util.AddNetworkString( "lvs_hitmarker" )
util.AddNetworkString( "lvs_hurtmarker" )
util.AddNetworkString( "lvs_killmarker" )
util.AddNetworkString( "lvs_armormarker" )
--addons/lvs_base/lua/lvs_framework/autorun/lvs_keybinding.lua:

hook.Add( "LVS:Initialize", "!!11lvs_default_keys", function()
	local KEYS = {
		{
			name = "ATTACK",
			category = "Armament",
			name_menu = "Attack",
			default = MOUSE_LEFT,
			cmd = "lvs_lmb"
		},
		{
			name = "ZOOM",
			category = "Armament",
			name_menu = "Zoom",
			default = MOUSE_RIGHT,
			cmd = "lvs_rmb"
		},
		{
			name = "~SELECT~WEAPON#1",
			category = "Armament",
			name_menu = "Select Weapon 1",
			cmd = "lvs_select_weapon1"
		},
		{
			name = "~SELECT~WEAPON#2",
			category = "Armament",
			name_menu = "Select Weapon 2",
			cmd = "lvs_select_weapon2"
		},
		{
			name = "~SELECT~WEAPON#3",
			category = "Armament",
			name_menu = "Select Weapon 3",
			cmd = "lvs_select_weapon3"
		},
		{
			name = "~SELECT~WEAPON#4",
			category = "Armament",
			name_menu = "Select Weapon 4",
			cmd = "lvs_select_weapon4"
		},
		--[[ only adding 4 because i dont want to bloat the menu. There can be added as many keys as neededed the system should figure it out by itself
		{
			name = "~SELECT~WEAPON#5",
			category = "Armament",
			name_menu = "Select Weapon 5",
			cmd = "lvs_select_weapon5"
		},
		]]
		{
			name = "EXIT",
			category = "Misc",
			name_menu = "Exit Vehicle",
			default = "+use",
			cmd = "lvs_exit"
		},
		{
			name = "VIEWDIST",
			category = "Misc",
			name_menu = "Enable Mouse-Wheel Set-Camera-Distance",
			default = MOUSE_MIDDLE,
			cmd = "lvs_viewzoom"
		},
		{
			name = "VIEWHEIGHT",
			category = "Misc",
			name_menu = "Set-Camera-Distance => Set-Camera-Height",
			default = "phys_swap",
			cmd = "lvs_viewheight"
		},
		{
			name = "THIRDPERSON",
			category = "Misc",
			name_menu = "Toggle Thirdperson",
			default = "+duck",
			cmd = "lvs_thirdperson"
		},
		{
			name = "FREELOOK",
			category = "Misc",
			name_menu = "Freelook (Hold)",
			default = "+walk",
			cmd = "lvs_freelook"
		},
		{
			name = "ENGINE",
			category = "Misc",
			name_menu = "Toggle Engine",
			default = "+reload",
			cmd = "lvs_startengine"
		},
		{
			name = "VSPEC",
			category = "Misc",
			name_menu = "Toggle Vehicle-specific Function",
			default = "+jump",
			cmd = "lvs_special"
		},
	}

	for _, v in pairs( KEYS ) do
		LVS:AddKey( v.name, v.category, v.name_menu, v.cmd, v.default )
	end
end )

if SERVER then return end

concommand.Add( "lvs_mouseaim_toggle", function( ply, cmd, args )
	local OldVar = GetConVar( "lvs_mouseaim" ):GetInt()

	if OldVar == 0 then
		ply:PrintMessage( HUD_PRINTTALK, "[LVS] Mouse-Aim: Enabled" )
		RunConsoleCommand( "lvs_mouseaim", "1" )

	else
		ply:PrintMessage( HUD_PRINTTALK, "[LVS] Mouse-Aim: Disabled" )
		RunConsoleCommand( "lvs_mouseaim", "0" )
	end
end )

hook.Add( "PlayerBindPress", "!!!!_LVS_PlayerBindPress", function( ply, bind, pressed )
	if not ply.lvsGetVehicle then return end

	local vehicle = ply:lvsGetVehicle()

	if not IsValid( vehicle ) then return end

	if not ply:lvsKeyDown( "VIEWDIST" ) then
		if string.find( bind, "invnext" ) then
			vehicle:NextWeapon()
		end
		if string.find( bind, "invprev" ) then
			vehicle:PrevWeapon()
		end
	end

	if string.find( bind, "+zoom" ) then
		if vehicle.lvsDisableZoom then
			return true
		end
	end
end )

hook.Add( "SpawnMenuOpen", "!!!lvs_spawnmenudisable", function()
	local ply = LocalPlayer() 

	if not ply._lvsDisableSpawnMenu or not IsValid( ply:lvsGetVehicle() ) then return end

	return false
end )

hook.Add( "ContextMenuOpen", "!!!lvs_contextmenudisable", function()
	local ply = LocalPlayer() 

	if not ply._lvsDisableContextMenu or not IsValid( ply:lvsGetVehicle() ) then return end

	return false
end )

--addons/lvs_base/lua/lvs_framework/autorun/lvs_pod.lua:

local meta = FindMetaTable( "Vehicle" )

if CLIENT then
	function meta:lvsGetPodIndex()
		local id = self:GetNWInt( "pPodIndex", -1 )

		if id ~= -1 then return id end

		-- code below is bandaid fix for ent:GetNWInt taking up to 5 minutes to update on client...

		local mat = self:GetMaterial()

		-- material is more reliable than ent:GetNWInt... unless someone has changed it on client...
		if string.StartsWith(mat, "podindexlvs") then

			local id_by_material = tonumber( string.TrimLeft( mat, "podindexlvs" ) )

			if id_by_material then return id_by_material end
		end

		local col = self:GetColor()
		local id_by_color = col.r

		-- 255 or 0 is suspicous...
		if id_by_color == 255 or id_by_color == 0 then return -1 end

		-- lets just assume its right... right?
		if id_by_color == col.g and id_by_color == col.b then
			return id_by_color
		end

		return -1
	end

	function meta:GetCameraHeight()
		if not self._lvsCamHeight then
			self._lvsCamHeight = 0

			net.Start("lvs_camera")
				net.WriteEntity( self )
			net.SendToServer()
		end

		return self._lvsCamHeight
	end

	function meta:SetCameraHeight( newheight )
		self._lvsCamHeight = newheight
	end

	function meta:lvsGetWeapon()
		if self._lvsWeaponEntChecked then
			return self._lvsWeaponEnt
		end

		local found = false

		for _, ent in ipairs( self:GetChildren() ) do
			if not ent.LVS_GUNNER then continue end

			self._lvsWeaponEntChecked = true
			self._lvsWeaponEnt = ent

			found = true

			break
		end

		return found and self._lvsWeaponEnt or NULL
	end

	net.Receive( "lvs_select_weapon", function( length)
		local ply = LocalPlayer()
		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) or vehicle:GetDriver() ~= ply then return end

		vehicle._SelectActiveTime = CurTime() + 2
	end)

	
	net.Receive( "lvs_camera", function( length, ply )
		local pod = net.ReadEntity()

		if not IsValid( pod ) then return end

		pod:SetCameraHeight( net.ReadFloat() )
	end)

	return
end

function meta:lvsGetPodIndex()
	return self:GetNWInt( "pPodIndex", -1 )
end

function meta:GetCameraHeight()
	return (self._lvsCamHeight or 0)
end

util.AddNetworkString( "lvs_select_weapon" )
util.AddNetworkString( "lvs_camera" )

net.Receive( "lvs_select_weapon", function( length, ply )
	if not IsValid( ply ) then return end

	local ID = net.ReadInt( 5 )
	local Increment = net.ReadBool()

	local base = ply:lvsGetWeaponHandler()

	if not IsValid( base ) then return end

	if Increment then
		base:SelectWeapon( base:GetSelectedWeapon() + ID )
	else
		base:SelectWeapon( ID )
	end
end)

net.Receive( "lvs_camera", function( length, ply )
	if not IsValid( ply ) then return end

	local pod = net.ReadEntity()

	if not IsValid( pod ) then return end

	net.Start("lvs_camera")
		net.WriteEntity( pod )
		net.WriteFloat( pod:GetCameraHeight() )
	net.Send( ply )
end)

function meta:SetCameraHeight( newheight )
	self._lvsCamHeight = newheight

	net.Start("lvs_camera")
		net.WriteEntity( self )
		net.WriteFloat( newheight )
	net.Broadcast()
end

function meta:lvsAddWeapon( ID )
	if IsValid( self._lvsWeaponEnt ) then
		return self._lvsWeaponEnt
	end

	local weapon = ents.Create( "lvs_base_gunner" )

	if not IsValid( weapon ) then return NULL end

	weapon:SetPos( self:LocalToWorld( Vector(0,0,33.182617) ) ) -- location exactly where ply:GetShootPos() is. This will make AI-Tracing easier.
	weapon:SetAngles( self:LocalToWorldAngles( Angle(0,90,0) ) )
	weapon:SetOwner( self )
	weapon:Spawn()
	weapon:Activate()
	weapon:SetParent( self )
	weapon:SetPodIndex( ID )
	weapon:SetDriverSeat( self )

	self._lvsWeaponEnt = weapon

	weapon:SetSelectedWeapon( 1 )

	return weapon
end

function meta:lvsGetWeapon()
	return self._lvsWeaponEnt
end

function meta:lvsSetPodIndex( index )
	-- garbage networking
	self:SetNWInt( "pPodIndex", index )

	-- more reliable networking, lol
	self:SetMaterial( "podindexlvs"..index )
	self:SetColor( Color( index, index, index, 0 ) )
end

--lua/autorun/mandalorian_npc_hostile.lua:
local Category = "StarWars"

local NPC = { 	Name = "Mandalorian Bounty Hunter Hostile", 
	Class = "npc_combine_s",
	Model = "models/Porky-da-Corgi/StarWars/Mandalorians/bountyhunter_npc_hostile.mdl",
	Health = "100",
	Numgrenades = "4",
	Category = Category	}

list.Set( "NPC", "npc_mandalorian_hostile", NPC )
--addons/billy_gas/lua/openpermissions_config.lua:
--[[

	   ____                   ____                      _           _                 
	  / __ \____  ___  ____  / __ \___  _________ ___  (_)_________(_)___  ____  _____
	 / / / / __ \/ _ \/ __ \/ /_/ / _ \/ ___/ __ `__ \/ / ___/ ___/ / __ \/ __ \/ ___/
	/ /_/ / /_/ /  __/ / / / ____/  __/ /  / / / / / / (__  |__  ) / /_/ / / / (__  ) 
	\____/ .___/\___/_/ /_/_/    \___/_/  /_/ /_/ /_/_/____/____/_/\____/_/ /_/____/  
	    /_/                                                                           

	Welcome to the OpenPermissions configuration file.
	This is where you'll define who is an OpenPermissions Operator.

	Operators have maximum permissions - you could call them "superadmins" of OpenPermissions.
	They have access to changing the permissions of the server, so only add people you trust here!

]]

-- Enter usergroups that should be Operators
OpenPermissions.Operators.Usergroups = {"superadmin", "operator", "developer", "owner", "founder"}

-- Enter SteamIDs or SteamID64s of people who should be Operators
OpenPermissions.Operators.SteamIDs = {"STEAM_0:1:40314158", "76561198040894045"}

-- Don't delete the line below; your config will break.
return true
--addons/admin_sam/lua/sam/libs/message_pack/sh_messagepack.lua:
if SAM_LOADED then return end
--
-- lua-MessagePack : <https://fperrad.frama.io/lua-MessagePack/>
--
local SIZEOF_NUMBER = string.pack and #string.pack('n', 0.0) or 8
local maxinteger
local mininteger
local assert = assert
local error = error
local pairs = pairs
local pcall = pcall
local setmetatable = setmetatable
local tostring = tostring
local char = string.char
local format = string.format
local floor = math.floor
local tointeger = floor
local frexp = math.frexp
local ldexp = math.ldexp
local huge = math.huge
local tconcat = table.concat
local type = sam.type
local isnumber = sam.isnumber
local _ENV = nil
local m = {}

--[[ debug only
local function hexadump (s)
	return (s:gsub('.', function (c) return format('%02X ', c:byte()) end))
end
m.hexadump = hexadump
--]]
local function argerror(caller, narg, extramsg)
	error("bad argument #" .. tostring(narg) .. " to " .. caller .. " (" .. extramsg .. ")")
end

local function typeerror(caller, narg, arg, tname)
	argerror(caller, narg, tname .. " expected, got " .. type(arg))
end

local function checktype(caller, narg, arg, tname)
	if type(arg) ~= tname then
		typeerror(caller, narg, arg, tname)
	end
end

local packers = setmetatable({}, {
	__index = function(t, k)
		if k == 1 then return end -- allows ipairs
		error("pack '" .. k .. "' is unimplemented")
	end
})

m.packers = packers

packers["nil"] = function(buffer)
	buffer[#buffer + 1] = char(0xC0) -- nil
end

packers["boolean"] = function(buffer, bool)
	if bool then
		buffer[#buffer + 1] = char(0xC3) -- true
	else
		buffer[#buffer + 1] = char(0xC2) -- false
	end
end

packers["string_compat"] = function(buffer, str)
	local n = #str

	if n <= 0x1F then
		buffer[#buffer + 1] = char(0xA0 + n) -- fixstr
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDA, floor(n / 0x100), n % 0x100) -- str16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDB, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- str32
	else
		error"overflow in pack 'string_compat'"
	end

	buffer[#buffer + 1] = str
end

packers["_string"] = function(buffer, str)
	local n = #str

	if n <= 0x1F then
		buffer[#buffer + 1] = char(0xA0 + n) -- fixstr
	elseif n <= 0xFF then
		buffer[#buffer + 1] = char(0xD9, n) -- str8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDA, floor(n / 0x100), n % 0x100) -- str16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDB, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- str32
	else
		error("overflow in pack 'string'")
	end

	buffer[#buffer + 1] = str
end

packers["binary"] = function(buffer, str)
	local n = #str

	if n <= 0xFF then
		buffer[#buffer + 1] = char(0xC4, n) -- bin8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xC5, floor(n / 0x100), n % 0x100) -- bin16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xC6, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- bin32
	else
		error("overflow in pack 'binary'")
	end

	buffer[#buffer + 1] = str
end

local set_string = function(str)
	if str == "string_compat" then
		packers["string"] = packers["string_compat"]
	elseif str == "string" then
		packers["string"] = packers["_string"]
	elseif str == "binary" then
		packers["string"] = packers["binary"]
	else
		argerror("set_string", 1, "invalid option '" .. str .. "'")
	end
end

m.set_string = set_string

packers["map"] = function(buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer + 1] = char(0x80 + n) -- fixmap
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDE, floor(n / 0x100), n % 0x100) -- map16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDF, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- map32
	else
		error("overflow in pack 'map'")
	end

	for k, v in pairs(tbl) do
		packers[type(k)](buffer, k)
		packers[type(v)](buffer, v)
	end
end

packers["array"] = function(buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer + 1] = char(0x90 + n) -- fixarray
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDC, floor(n / 0x100), n % 0x100) -- array16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDD, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- array32
	else
		error("overflow in pack 'array'")
	end

	for i = 1, n do
		local v = tbl[i]
		packers[type(v)](buffer, v)
	end
end

local set_array = function(array)
	if array == "without_hole" then
		packers["_table"] = function(buffer, tbl)
			local is_map, n, max = false, 0, 0

			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end

				n = n + 1
			end

			-- there are holes
			if max ~= n then
				is_map = true
			end

			if is_map then
				packers["map"](buffer, tbl, n)
			else
				packers["array"](buffer, tbl, n)
			end
		end
	elseif array == "with_hole" then
		packers["_table"] = function(buffer, tbl)
			local is_map, n, max = false, 0, 0

			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end

				n = n + 1
			end

			if is_map then
				packers["map"](buffer, tbl, n)
			else
				packers["array"](buffer, tbl, max)
			end
		end
	elseif array == "always_as_map" then
		packers["_table"] = function(buffer, tbl)
			local n = 0

			for k in pairs(tbl) do
				n = n + 1
			end

			packers["map"](buffer, tbl, n)
		end
	else
		argerror("set_array", 1, "invalid option '" .. array .. "'")
	end
end

m.set_array = set_array

packers["table"] = function(buffer, tbl)
	packers["_table"](buffer, tbl)
end

packers["unsigned"] = function(buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer + 1] = char(n) -- fixnum_pos
		elseif n <= 0xFF then
			buffer[#buffer + 1] = char(0xCC, n) -- uint8
		elseif n <= 0xFFFF then
			buffer[#buffer + 1] = char(0xCD, floor(n / 0x100), n % 0x100) -- uint16
		elseif n <= 4294967295.0 then
			buffer[#buffer + 1] = char(0xCE, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- uint32
		else
			buffer[#buffer + 1] = char(0xCF, 0, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- uint64 -- only 53 bits from double
		end
	else
		if n >= -0x20 then
			buffer[#buffer + 1] = char(0x100 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer + 1] = char(0xD0, 0x100 + n) -- int8
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0xFF, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	end
end

packers["signed"] = function(buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer + 1] = char(n) -- fixnum_pos
		elseif n <= 0x7FFF then
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n <= 0x7FFFFFFF then
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	else
		if n >= -0x20 then
			buffer[#buffer + 1] = char(0xE0 + 0x20 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer + 1] = char(0xD0, 0x100 + n) -- int8
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0xFF, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	end
end

local set_integer = function(integer)
	if integer == "unsigned" then
		packers["integer"] = packers["unsigned"]
	elseif integer == "signed" then
		packers["integer"] = packers["signed"]
	else
		argerror("set_integer", 1, "invalid option '" .. integer .. "'")
	end
end

m.set_integer = set_integer

packers["float"] = function(buffer, n)
	local sign = 0

	if n < 0.0 then
		sign = 0x80
		n = -n
	end

	local mant, expo = frexp(n)

	if mant ~= mant then
		buffer[#buffer + 1] = char(0xCA, 0xFF, 0x88, 0x00, 0x00) -- nan
	elseif mant == huge or expo > 0x80 then
		if sign == 0 then
			buffer[#buffer + 1] = char(0xCA, 0x7F, 0x80, 0x00, 0x00) -- inf
		else
			buffer[#buffer + 1] = char(0xCA, 0xFF, 0x80, 0x00, 0x00) -- -inf
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
		buffer[#buffer + 1] = char(0xCA, sign, 0x00, 0x00, 0x00) -- zero
	else
		expo = expo + 0x7E
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 24))
		buffer[#buffer + 1] = char(0xCA, sign + floor(expo / 0x2), (expo % 0x2) * 0x80 + floor(mant / 0x10000), floor(mant / 0x100) % 0x100, mant % 0x100)
	end
end

packers["double"] = function(buffer, n)
	local sign = 0

	if n < 0.0 then
		sign = 0x80
		n = -n
	end

	local mant, expo = frexp(n)

	if mant ~= mant then
		buffer[#buffer + 1] = char(0xCB, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- nan
	elseif mant == huge or expo > 0x400 then
		if sign == 0 then
			buffer[#buffer + 1] = char(0xCB, 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- inf
		else
			buffer[#buffer + 1] = char(0xCB, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- -inf
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x3FE then
		buffer[#buffer + 1] = char(0xCB, sign, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- zero
	else
		expo = expo + 0x3FE
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 53))
		buffer[#buffer + 1] = char(0xCB, sign + floor(expo / 0x10), (expo % 0x10) * 0x10 + floor(mant / 0x1000000000000), floor(mant / 0x10000000000) % 0x100, floor(mant / 0x100000000) % 0x100, floor(mant / 0x1000000) % 0x100, floor(mant / 0x10000) % 0x100, floor(mant / 0x100) % 0x100, mant % 0x100)
	end
end

local set_number = function(number)
	if number == "float" then
		packers["number"] = function(buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers["integer"](buffer, n)
			else
				packers["float"](buffer, n)
			end
		end
	elseif number == "double" then
		packers["number"] = function(buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers["integer"](buffer, n)
			else
				packers["double"](buffer, n)
			end
		end
	else
		argerror("set_number", 1, "invalid option '" .. number .. "'")
	end
end

m.set_number = set_number

for k = 0, 4 do
	local n = tointeger(2 ^ k)
	local fixext = 0xD4 + k

	packers["fixext" .. tostring(n)] = function(buffer, tag, data)
		assert(#data == n, "bad length for fixext" .. tostring(n))
		buffer[#buffer + 1] = char(fixext, tag < 0 and tag + 0x100 or tag)
		buffer[#buffer + 1] = data
	end
end

packers["ext"] = function(buffer, tag, data)
	local n = #data

	if n <= 0xFF then
		buffer[#buffer + 1] = char(0xC7, n, tag < 0 and tag + 0x100 or tag) -- ext8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xC8, floor(n / 0x100), n % 0x100, tag < 0 and tag + 0x100 or tag) -- ext16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xC9, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100, tag < 0 and tag + 0x100 or tag) -- ext&32
	else
		error("overflow in pack 'ext'")
	end

	buffer[#buffer + 1] = data
end

function m.pack(data)
	local buffer = {}
	packers[type(data)](buffer, data)

	return tconcat(buffer)
end

local unpackers -- forward declaration

local function unpack_cursor(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local val = s:byte(i)
	c.i = i + 1

	return unpackers[val](c, val)
end

m.unpack_cursor = unpack_cursor

local function unpack_str(c, n)
	local s, i, j = c.s, c.i, c.j
	local e = i + n - 1

	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i + n - 1
	end

	c.i = i + n

	return s:sub(i, e)
end

local function unpack_array(c, n)
	local t = {}

	for i = 1, n do
		t[i] = unpack_cursor(c)
	end

	return t
end

local function unpack_map(c, n)
	local t = {}

	for i = 1, n do
		local k = unpack_cursor(c)
		local val = unpack_cursor(c)

		if k == nil or k ~= k then
			k = m.sentinel
		end

		if k ~= nil then
			t[k] = val
		end
	end

	return t
end

local function unpack_float(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x2 + floor(b2 / 0x80)
	local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4

	if sign then
		sign = -1
	else
		sign = 1
	end

	local n

	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0xFF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0 / 0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 0x800000, expo - 0x7F)
	end

	c.i = i + 4

	return n
end

local function unpack_double(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x10 + floor(b2 / 0x10)
	local mant = ((((((b2 % 0x10) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8

	if sign then
		sign = -1
	else
		sign = 1
	end

	local n

	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0x7FF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0 / 0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 4503599627370496.0, expo - 0x3FF)
	end

	c.i = i + 8

	return n
end

local function unpack_uint8(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local b1 = s:byte(i)
	c.i = i + 1

	return b1
end

local function unpack_uint16(c)
	local s, i, j = c.s, c.i, c.j

	if i + 1 > j then
		c:underflow(i + 1)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2 = s:byte(i, i + 1)
	c.i = i + 2

	return b1 * 0x100 + b2
end

local function unpack_uint32(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	c.i = i + 4

	return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
end

local function unpack_uint64(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	c.i = i + 8

	return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
end

local function unpack_int8(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local b1 = s:byte(i)
	c.i = i + 1

	if b1 < 0x80 then
		return b1
	else
		return b1 - 0x100
	end
end

local function unpack_int16(c)
	local s, i, j = c.s, c.i, c.j

	if i + 1 > j then
		c:underflow(i + 1)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2 = s:byte(i, i + 1)
	c.i = i + 2

	if b1 < 0x80 then
		return b1 * 0x100 + b2
	else
		return ((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) - 1
	end
end

local function unpack_int32(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	c.i = i + 4

	if b1 < 0x80 then
		return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
	else
		return ((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) - 1
	end
end

local function unpack_int64(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	c.i = i + 8

	if b1 < 0x80 then
		return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	else
		return ((((((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) * 0x100 + (b5 - 0xFF)) * 0x100 + (b6 - 0xFF)) * 0x100 + (b7 - 0xFF)) * 0x100 + (b8 - 0xFF)) - 1
	end
end

function m.build_ext(tag, data)
	return nil
end

local function unpack_ext(c, n, tag)
	local s, i, j = c.s, c.i, c.j
	local e = i + n - 1

	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i + n - 1
	end

	c.i = i + n

	return m.build_ext(tag, s:sub(i, e))
end

local fn_1 = function(c, val) return val end
local fn_2 = function(c, val) return unpack_map(c, val % 0x10) end
local fn_3 = function(c, val) return unpack_array(c, val % 0x10) end
local fn_4 = function(c, val) return unpack_str(c, val % 0x20) end
local fn_5 = function(c, val) return val - 0x100 end

unpackers = setmetatable({
	[0xC0] = function() return nil end,
	[0xC2] = function() return false end,
	[0xC3] = function() return true end,
	[0xC4] = function(c) return unpack_str(c, unpack_uint8(c)) end, -- bin8
	[0xC5] = function(c) return unpack_str(c, unpack_uint16(c)) end, -- bin16
	[0xC6] = function(c) return unpack_str(c, unpack_uint32(c)) end, -- bin32
	[0xC7] = function(c) return unpack_ext(c, unpack_uint8(c), unpack_int8(c)) end,
	[0xC8] = function(c) return unpack_ext(c, unpack_uint16(c), unpack_int8(c)) end,
	[0xC9] = function(c) return unpack_ext(c, unpack_uint32(c), unpack_int8(c)) end,
	[0xCA] = unpack_float,
	[0xCB] = unpack_double,
	[0xCC] = unpack_uint8,
	[0xCD] = unpack_uint16,
	[0xCE] = unpack_uint32,
	[0xCF] = unpack_uint64,
	[0xD0] = unpack_int8,
	[0xD1] = unpack_int16,
	[0xD2] = unpack_int32,
	[0xD3] = unpack_int64,
	[0xD4] = function(c) return unpack_ext(c, 1, unpack_int8(c)) end,
	[0xD5] = function(c) return unpack_ext(c, 2, unpack_int8(c)) end,
	[0xD6] = function(c) return unpack_ext(c, 4, unpack_int8(c)) end,
	[0xD7] = function(c) return unpack_ext(c, 8, unpack_int8(c)) end,
	[0xD8] = function(c) return unpack_ext(c, 16, unpack_int8(c)) end,
	[0xD9] = function(c) return unpack_str(c, unpack_uint8(c)) end,
	[0xDA] = function(c) return unpack_str(c, unpack_uint16(c)) end,
	[0xDB] = function(c) return unpack_str(c, unpack_uint32(c)) end,
	[0xDC] = function(c) return unpack_array(c, unpack_uint16(c)) end,
	[0xDD] = function(c) return unpack_array(c, unpack_uint32(c)) end,
	[0xDE] = function(c) return unpack_map(c, unpack_uint16(c)) end,
	[0xDF] = function(c) return unpack_map(c, unpack_uint32(c)) end
}, {
	__index = function(t, k)
		if k < 0xC0 then
			if k < 0x80 then
				return fn_1
			elseif k < 0x90 then
				return fn_2
			elseif k < 0xA0 then
				return fn_3
			else
				return fn_4
			end
		elseif k > 0xDF then
			return fn_5
		else
			return function()
				error("unpack '" .. format("%#x", k) .. "' is unimplemented")
			end
		end
	end
})

local function cursor_string(str)
	return {
		s = str,
		i = 1,
		j = #str,
		underflow = function()
			error"missing bytes"
		end
	}
end

local function cursor_loader(ld)
	return {
		s = '',
		i = 1,
		j = 0,
		underflow = function(self, e)
			self.s = self.s:sub(self.i)
			e = e - self.i + 1
			self.i = 1
			self.j = 0

			while e > self.j do
				local chunk = ld()

				if not chunk then
					error"missing bytes"
				end

				self.s = self.s .. chunk
				self.j = #self.s
			end
		end
	}
end

function m.unpack(s)
	checktype("unpack", 1, s, "string")
	local cursor = cursor_string(s)
	local data = unpack_cursor(cursor)

	if cursor.i <= cursor.j then
		error("extra bytes")
	end

	return data
end

function m.unpacker(src)
	if type(src) == "string" then
		local cursor = cursor_string(src)

		return function()
			if cursor.i <= cursor.j then return cursor.i, unpack_cursor(cursor) end
		end
	elseif type(src) == "function" then
		local cursor = cursor_loader(src)

		return function()
			if cursor.i > cursor.j then
				pcall(cursor.underflow, cursor, cursor.i)
			end

			if cursor.i <= cursor.j then return true, unpack_cursor(cursor) end
		end
	else
		argerror("unpacker", 1, "string or function expected, got " .. type(src))
	end
end

set_string("string")
set_integer("unsigned")

if SIZEOF_NUMBER == 4 then
	maxinteger = 16777215
	mininteger = -maxinteger
	m.small_lua = true
	unpackers[0xCB] = nil -- double
	unpackers[0xCF] = nil -- uint64
	unpackers[0xD3] = nil -- int64
	set_number("float")
else
	maxinteger = 9007199254740991
	mininteger = -maxinteger
	set_number("double")

	if SIZEOF_NUMBER > 8 then
		m.long_double = true
	end
end

set_array("always_as_map")
m._VERSION = "0.5.2"
m._DESCRIPTION = "lua-MessagePack : a pure Lua implementation"
m._COPYRIGHT = "Copyright (c) 2012-2019 Francois Perrad"

return m
--
-- This library is licensed under the terms of the MIT/X11 license,
-- like Lua itself.
--

--addons/admin_sam/lua/sam/libs/sh_sfs.lua:
-- SFS (Srlion's Fast Serializer)
-- we try to avoid NYI operations in luajit as much as possible
-- unforunately, we can't avoid all of them in luajit 2.0.5 - pairs & table.concat
-- https://github.com/tarantool/tarantool/wiki/LuaJIT-Not-Yet-Implemented
-- we don't use string concating because it's also NYI in luajit 2.0.5
-- we never error so we don't get blacklisted by the jit compiler
-- errors return strings instead of throwing errors

-- this is intentionally made for net messages, so you don't have to use pcall to check if there are any errors
-- you should use this without using util.Compress, as this just adds one byte to each value, you will probably end up with a larger string if you compress it

-- this idea is from messagepack which is really smart
-- small numbers (0 ~ 127) and (-32 ~ -1) are encoded as a single byte
-- tables and arrays are encoded with a prefix byte, which is the number of elements in the table or array, but it can be one byte if it's less than 16
-- strings are encoded with a prefix byte, which is the length of the string, but it can be one byte if it's less than 32

local math = math
local HUGE = math.huge
local floor = math.floor
local internal_type = type
local IsColor = IsColor
local type = function(v)
    if IsColor(v) then
        return "Color"
    end
    return internal_type(v)
end

-- string.char is not jit compiled in luajit 2.0.5
local chars = {}; do
    for i = 0, 255 do
        chars[i] = string.char(i)
    end
end

local MAX_NUMBER = 1.7976931348623e+308
local MIN_NUMBER = -MAX_NUMBER

---
local POSITIVE_INT = 0x00
local POSITIVE_INT_END = 0x7f

local TABLE_FIXED = 0x80
local TABLE_FIXED_END = 0x8f

local ARRAY_FIXED = 0x90
local ARRAY_FIXED_END = 0x9f

local STR_FIXED = 0xa0
local STR_FIXED_END = 0xbf

local NIL = 0xc0
local FALSE = 0xc1
local TRUE = 0xc2

local UINT_8 = 0xc3
local UINT_16 = 0xc4
local UINT_32 = 0xc5
local UINT_52 = 0xc6

local NINT_8 = 0xc7
local NINT_16 = 0xc8
local NINT_32 = 0xc9
local NINT_52 = 0xca

local DOUBLE = 0xcb

local STR_8 = 0xcc
local STR_16 = 0xcd
local STR_32 = 0xce

local ARRAY_8 = 0xcf
local ARRAY_16 = 0xd0
local ARRAY_32 = 0xd1

local TABLE_8 = 0xd2
local TABLE_16 = 0xd3
local TABLE_32 = 0xd4

local VECTOR = 0xd5
local ANGLE = 0xd6

local ENTITY = 0xd7
local PLAYER = 0xd8

local COLOR = 0xd9

-- this was added in version 2.0.0
-- it's used for arrays that start at 0, I'm not sure if lua 5.1 has same behavior as luajit 2.0.5
-- but luajit 2.0.5 supports starting arrays at 0 index, so checking if table is an array or not gets messed up and output is wrong
-- so if you supply local t = {[0] = 0, 1, 2, 3} and do next(t, #t) it will return (nil, nil) instead of (0, 0)
local ARRAY_ZERO_BASED_INDEX = 0xda

local FREE_FOR_CUSTOM = 0xdb
local FREE_FOR_CUSTOM_END = 0xdf

local NEGATIVE_INT = 0xe0
local NEGATIVE_INT_END = 0xff
---

local encoders = {}
local Encoder = {
    encoders = encoders
}
do
    local pairs = pairs
    local next = next
    local ceil = math.ceil
    local log = math.log
    local concat = table.concat
    local write, write_unsigned, write_double

    -- garry's mod related
    local Vector_Unpack, Angle_Unpack
    local Entity_EntIndex, Player_UserID
    if FindMetaTable then
        Vector_Unpack = FindMetaTable("Vector").Unpack
        Angle_Unpack = FindMetaTable("Angle").Unpack

        Entity_EntIndex = FindMetaTable("Entity").EntIndex
        Player_UserID = FindMetaTable("Player").UserID
    end
    --

    local get_encoder = function(buf, t)
        local encoder = encoders[type(t)]
        if encoder == nil then
            write(buf, "Unsupported type: ")
            write(buf, type(t))
            return nil
        end
        return encoder
    end

    local buffer = {
        [0] = 0 -- buffer length
    }

    -- this function is obviously not jit compiled in luajit 2.0.5 but internal functions are
    function Encoder.encode(val, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        local encoder = get_encoder(buffer, val)
        if encoder == nil then
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        if encoder(buffer, val, arg) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function Encoder.encode_array(arr, len, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        if encoders.array(buffer, arr, len) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function write(buf, chr)
        local buf_len = buf[0] + 1
        buf[0] = buf_len
        buf[buf_len] = chr
    end
    Encoder.write = write

    encoders["nil"] = function(buf)
        write(buf, chars[NIL])
    end

    function encoders.boolean(buf, bool)
        if bool == true then
            write(buf, chars[TRUE])
        else
            write(buf, chars[FALSE])
        end
    end

    function encoders.array(buf, arr, len, start_index)
        start_index = (start_index == nil or start_index ~= 0 and start_index ~= 1) and 1 or start_index

        if len < 0 then
            write(buf, "Array size cannot be negative: ")
            write(buf, len)
            return true
        elseif len > 0xFFFFFFFF then
            write(buf, "Array size too large to encode: ")
            write(buf, len)
            return true
        end

        if len <= 0xF then
            write(buf, chars[ARRAY_FIXED + len])
        else
            write_unsigned(buf, ARRAY_8, len)
        end

        if start_index == 0 then
            write(buf, chars[ARRAY_ZERO_BASED_INDEX])
        end

        for idx = start_index, len do
            local val = arr[idx]
            local encoder = get_encoder(buf, val)
            if encoder == nil then return true end
            encoder(buf, val)
        end
    end

    -- we can't check if a table is an array or not because lua tables are not arrays, they are tables
    -- use Encoder.encode_array if you want to encode an array
    function encoders.table(buf, tbl)
        -- check if it's an array, it's not accurate for arrays with holes but better than nothing
        do
            -- this is the fastest possible way, a lot better than cbor's/messagepack's/pon's way of checking if it's an array
            local tbl_len = #tbl
            if tbl_len > 0 and next(tbl, tbl_len) == nil and ((tbl_len == 1 and next(tbl) == 1) or (tbl_len > 1 and next(tbl, tbl_len - 1) == tbl_len)) then
                if tbl[0] ~= nil then
                    return encoders.array(buf, tbl, tbl_len, 0)
                else
                    return encoders.array(buf, tbl, tbl_len)
                end
            end
        end

        local buf_len = buf[0]
        local table_start = buf_len -- we store the start of the table so when we write the table size, we can change the current buffer index to the start of the table
        -- we have no way to get the table size without iterating through it, so we just add 5 empty strings to the buffer as a placeholder
        -- we add 5 empty strings because we don't know if table size is going to be a fixed number, uint8, uint16 or uint32
        -- uint32 takes 5 bytes, so we add 5 empty strings
        do
            for idx = 1, 5 do
                buf[buf_len + idx] = ""
            end
            buf_len = buf_len + 5
            buf[0] = buf_len
        end

        local table_count = 0
        for key, val in pairs(tbl) do
            table_count = table_count + 1

            local encoder_key = get_encoder(buf, key)
            if encoder_key == nil then return true end
            encoder_key(buf, key)

            local encoder_val = get_encoder(buf, val)
            if encoder_val == nil then return true end
            encoder_val(buf, val)
        end

        local table_end = buf[0] -- we store the end of the table because we need to change current buffer index to the start of the table to write the table size
        buf[0] = table_start -- change current buffer index to the start of the table

        -- write the table size
        if table_count <= 0xF then
            write(buf, chars[TABLE_FIXED + table_count])
        else
            if table_count > 0xFFFFFFFF then
                write(buf, "Table size too large to encode: ")
                write(buf, table_count)
                return true
            end
            write_unsigned(buf, TABLE_8, table_count)
        end

        buf[0] = table_end -- change current buffer index back to the end of the table
    end

    function encoders.string(buf, str)
        local str_len = #str
        if str_len > 0xFFFFFFFF then
            write(buf, "String too large to encode: ")
            write(buf, str_len)
            return true
        end

        if str_len <= 0x1F then
            write(buf, chars[STR_FIXED + str_len])
        else
            write_unsigned(buf, STR_8, str_len)
        end
        write(buf, str)
    end

    function encoders.number(buf, num)
        if (num > MAX_NUMBER and num ~= HUGE) or (num < MIN_NUMBER and num ~= -HUGE) then
            write(buf, "Number too large to encode: ")
            write(buf, num)
            return true
        end

        if num % 1 ~= 0 or num > 0xFFFFFFFFFFFFF or num < -0xFFFFFFFFFFFFF then -- DOUBLE
            write_double(buf, DOUBLE, num)
            return
        end

        if num < 0 then
            num = -num
            if num <= 0x1F then
                write(buf, chars[NEGATIVE_INT + num])
            else
                write_unsigned(buf, NINT_8, num)
            end
        else
            if num <= 0x7F then
                write(buf, chars[POSITIVE_INT + num])
            else
                write_unsigned(buf, UINT_8, num)
            end
        end
    end

    function encoders.Vector(buf, vec)
        write(buf, chars[VECTOR])
        local x, y, z = Vector_Unpack(vec)
        encoders.number(buf, x)
        encoders.number(buf, y)
        encoders.number(buf, z)
    end

    function encoders.Angle(buf, ang)
        write(buf, chars[ANGLE])
        local p, y, r = Angle_Unpack(ang)
        encoders.number(buf, p)
        encoders.number(buf, y)
        encoders.number(buf, r)
    end

    function encoders.Entity(buf, ent)
        write(buf, chars[ENTITY])
        encoders.number(buf, Entity_EntIndex(ent))
    end

    function encoders.Player(buf, ply)
        write(buf, chars[PLAYER])
        encoders.number(buf, Player_UserID(ply))
    end

    function encoders.Color(buf, col)
        write(buf, chars[COLOR])
        encoders.number(buf, col.r)
        encoders.number(buf, col.g)
        encoders.number(buf, col.b)
        encoders.number(buf, col.a)
    end

    function write_unsigned(buf, tag, num)
        if num <= 0xFF then -- uint8
            write(buf, chars[tag + 0x00])
            write(buf, chars[num])
        elseif num <= 0xFFFF then -- uint16
            write(buf, chars[tag + 0x01])
            write(buf, chars[floor(num / 256)])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFF then -- uint32
            write(buf, chars[tag + 0x02])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFFFFFFF then -- uint52
            write(buf, chars[tag + 0x3])
            write(buf, chars[num % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x100000000) % 256])
            write(buf, chars[floor(num / 0x10000000000) % 256])
            write(buf, chars[floor(num / 0x1000000000000) % 256])
        end
    end
    Encoder.write_unsigned = write_unsigned

    -- i can't remember where i got this from, but it's not mine (i swear i always credit people)
    local log2 = log(2)
    function write_double(buf, tag, value)
        local abs_value = value < 0 and -value or value
        --IEEE double-precision floating point number
        --Specification: https://en.wikipedia.org/wiki/Double-precision_floating-point_format
        --Separate out the sign, exponent and fraction
        local sign = value < 0 and 1 or 0
        local exponent = ceil(log(abs_value) / log2) - 1
        local fraction = abs_value / (2 ^ exponent) - 1
        --Make sure the exponent stays in range - allowed values are -1023 through 1024
        if exponent < -1023 then
            --We allow this case for subnormal numbers and just clamp the exponent and re-calculate the fraction
            --without the offset of 1
            exponent = -1023
            fraction = abs_value / (2 ^ exponent)
        elseif abs_value ~= HUGE and exponent > 1024 then
            write(buf, "Exponent out of range: ")
            write(buf, value)
            return true
        end

        --Handle special cases
        if value == 0 then
            --Zero
            exponent = -1023
            fraction = 0
        elseif abs_value == HUGE then
            --Infinity
            exponent = 1024
            fraction = 0
        elseif value ~= value then
            --NaN
            exponent = 1024
            fraction = 1
        end

        local exp_out = exponent + 1023
        local fraction_out = fraction * 0x10000000000000

        write(buf, chars[tag])
        write(buf, chars[128 * sign + floor(exp_out / 16)])
        write(buf, chars[(exp_out % 16) * 16 + floor(fraction_out / 0x1000000000000)])
        write(buf, chars[floor(fraction_out / 0x10000000000) % 256])
        write(buf, chars[floor(fraction_out / 0x100000000) % 256])
        write(buf, chars[floor(fraction_out / 0x1000000) % 256])
        write(buf, chars[floor(fraction_out / 0x10000) % 256])
        write(buf, chars[floor(fraction_out / 0x100) % 256])
        write(buf, chars[floor(fraction_out % 256)])
    end
    Encoder.write_double = write_double
end

local decoders = {}
local Decoder = {
    decoders = decoders
}
do
    local sub = string.sub

    local read_type, read_byte, read_word, read_dword
    local decode_array, decode_table, decode_string, decode_double

    -- garry's mod related
    local Vector, Angle, Entity, Player, Color = Vector, Angle, Entity, Player, Color
    --

    local str_byte = string.byte
    local byte = function(ctx, size)
        local index = ctx[1]
        if index + size - 1 > ctx[3] then -- buffer length
            return nil, "Attemped to read beyond buffer size"
        elseif index + size - 1 > ctx[4] then -- max size
            return nil, "Max decode size exceeded"
        end
        ctx[1] = index + size
        return str_byte(ctx[2], index, index + size - 1)
    end
    Decoder.byte = byte

    local get_decoder = function(ctx)
        local t = read_type(ctx)
        local decoder = decoders[t]
        if decoder == nil then
            return nil, "Unsupported type: ", t
        end
        return decoder
    end
    Decoder.get_decoder = get_decoder

    local context = {
        1,  -- index
        "", -- buffer
        0,  -- buffer length
        HUGE, -- max size for decode, useful when decoding from user input that was sent over netmessages
    }

    local decode = function()
        if context[3] < 1 then -- this will make string.byte fail
            return nil, "Buffer is empty"
        end

        local err, err_2
        local decoder
        local val

        decoder, err, err_2 = get_decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        val, err, err_2 = decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        return val
    end

    function Decoder.decode(str)
        if type(str) ~= "string" then
            return nil, "str is not a string", str
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = HUGE

        return decode()
    end

    function Decoder.decode_with_max_size(str, max_size)
        if type(str) ~= "string" then
            return nil, "str is not a string", str
        end

        if type(max_size) ~= "number" then
            return nil, "max_size is not a number", max_size
        end

        if max_size < 0 then
            return nil, "max_size can either be a positive number or math.huge for unlimited", max_size
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = max_size

        return decode()
    end

    decoders[NIL] = function(ctx)
        ctx[1] = ctx[1] + 1
        return nil
    end

    decoders[FALSE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return false
    end

    decoders[TRUE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return true
    end

    --
    decoders[ARRAY_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - ARRAY_FIXED
        return decode_array(ctx, len)
    end

    for i = ARRAY_FIXED + 1, ARRAY_FIXED_END do
        decoders[i] = decoders[ARRAY_FIXED]
    end
    --

    decoders[ARRAY_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if len == nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    --
    decoders[TABLE_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - TABLE_FIXED
        return decode_table(ctx, len)
    end

    for i = TABLE_FIXED + 1, TABLE_FIXED_END do
        decoders[i] = decoders[TABLE_FIXED]
    end
    --

    decoders[TABLE_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    --
    decoders[STR_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        local len = bty - STR_FIXED
        return decode_string(ctx, len)
    end

    for i = STR_FIXED + 1, STR_FIXED_END do
        decoders[i] = decoders[STR_FIXED]
    end
    --

    decoders[STR_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    --
    decoders[POSITIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return bty - POSITIVE_INT
    end

    for i = POSITIVE_INT + 1, POSITIVE_INT_END do
        decoders[i] = decoders[POSITIVE_INT]
    end
    --

    decoders[UINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u8, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return u8
    end

    decoders[UINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return u16
    end

    decoders[UINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return u32
    end

    decoders[UINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000)
    end

    --
    decoders[NEGATIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        return NEGATIVE_INT - bty
    end

    for i = NEGATIVE_INT + 1, NEGATIVE_INT_END do
        decoders[i] = decoders[NEGATIVE_INT]
    end
    --

    decoders[NINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n8, err = read_byte(ctx)
        if n8 == nil then
            return nil, err
        end
        return -n8
    end

    decoders[NINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n16
    end

    decoders[NINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n32
    end

    decoders[NINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return -(b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000))
    end

    decoders[DOUBLE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return decode_double(ctx)
    end

    decoders[VECTOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local x, y, z

        -- x
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        x, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- z
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        z, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Vector(x, y, z)
    end

    decoders[ANGLE] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local p, y, r

        -- p
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        p, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Angle(p, y, r)
    end

    decoders[ENTITY] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local ent_index

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        ent_index, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Entity(ent_index)
    end

    decoders[PLAYER] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local user_id

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        user_id, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Player(user_id)
    end

    decoders[COLOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local r, g, b, a

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- g
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        g, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- b
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        b, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- a
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        a, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Color(r, g, b, a)
    end

    function decode_array(ctx, len)
        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local arr = {nil, nil, nil, nil, nil, nil, nil, nil}

        local start_index = 1
        if read_type(ctx) == ARRAY_ZERO_BASED_INDEX then
            ctx[1] = ctx[1] + 1
            start_index = 0
        end

        for idx = start_index, len do
            local err, err_2
            local decoder
            local val

            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end

            arr[idx] = val
        end

        return arr
    end
    Decoder.decode_array = decode_array

    function decode_table(ctx, len)
        local err, err_2
        local decoder
        local key, val

        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local tbl = {nil, nil, nil, nil, nil, nil, nil, nil}
        for _ = 1, len do
            -- key
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            key, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            -- val
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            tbl[key] = val
        end

        return tbl
    end
    Decoder.decode_table = decode_table

    function decode_string(ctx, len)
        local index = ctx[1]
        if index + len - 1 > ctx[3] then
            return nil, "Attemped to read beyond buffer size"
        elseif index + len - 1 > ctx[4] then
            return nil, "Max decode size exceeded"
        end

        ctx[1] = index + len

        return sub(ctx[2], index, index + len - 1)
    end
    Decoder.decode_string = decode_string

    function decode_double(ctx)
        local b1, b2, b3, b4, b5, b6, b7, b8 = byte(ctx, 8)
        if b1 == nil then
            return nil, b2
        end

        --Separate out the values
        local sign = b1 >= 128 and 1 or 0
        local exponent = (b1 % 128) * 16 + floor(b2 / 16)
        local fraction = (b2 % 16) * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8
        --Handle special cases
        if exponent == 2047 then
            --Infinities
            if fraction == 0 then return ((sign == 0 and 1) or -1) * HUGE end
            --NaN
            if fraction == 0xfffffffffffff then return 0 / 0 end
        end

        --Combine the values and return the result
        if exponent == 0 then
            --Handle subnormal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * (fraction / 0x10000000000000)
        else
            --Handle normal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * ((fraction / 0x10000000000000) + 1)
        end
    end
    Decoder.decode_double = decode_double

    function read_type(ctx)
        local typ = str_byte(ctx[2], ctx[1])
        return typ
    end
    Decoder.read_type = read_type

    function read_byte(ctx)
        local bty, err = byte(ctx, 1)
        if bty == nil then
            return nil, err
        end
        return bty
    end
    Decoder.read_byte = read_byte

    function read_word(ctx)
        local b1, b2 = byte(ctx, 2)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x100 + b2
    end
    Decoder.read_word = read_word

    function read_dword(ctx)
        local b1, b2, b3, b4 = byte(ctx, 4)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x1000000 + b2 * 0x10000 + b3 * 0x100 + b4
    end
    Decoder.read_dword = read_dword
end

return {
    Encoder = Encoder, -- to allow usage of internal functions
    Decoder = Decoder, -- to allow usage of internal functions

    encode = Encoder.encode,
    encode_with_buffer = Encoder.encode_with_buffer,
    encode_array = Encoder.encode_array,

    decode = Decoder.decode,
    decode_with_max_size = Decoder.decode_with_max_size,

    set_type_function = function(t_fn) -- this is for me as I have custom type function in sam/scb to allow type function to get jit compiled :c
        type = t_fn
    end,

    add_encoder = function(typ, encoder)
        encoders[typ] = encoder
        if FREE_FOR_CUSTOM == FREE_FOR_CUSTOM_END then
            return nil, "No more free slots for custom encoders"
        end
        FREE_FOR_CUSTOM = FREE_FOR_CUSTOM + 1
        return FREE_FOR_CUSTOM - 1
    end,

    add_decoder = function(typ, decoder)
        decoders[typ] = decoder
    end,

    chars = chars,
    VERSION = "2.0.8"
}

--addons/admin_sam/lua/sam/sh_lang.lua:
if SAM_LOADED then return end

local lang = sam.load_file("sam_language.lua", "sh")

local original = lang
if not isstring(lang) then
	lang = "english"
end

local lang_path = "sam_languages/" .. lang .. ".lua"

if not file.Exists(lang_path, "LUA") then
	lang_path = "sam_languages/english.lua"
	if not file.Exists(lang_path, "LUA") then
		-- maybe they deleted english lang????
		sam.print("SAM is broken!")
		sam.print("Language '" .. tostring(original) .. "' doesn't exist and 'english' language file doesn't exist")
		return false
	else
		sam.print("Language '" .. tostring(original) .. "' doesn't exist falling back to english")
	end
end

local Language = sam.load_file(lang_path, "sh_")

local sub, find = string.sub, string.find

local white_color = Color(236, 240, 241)

do
	local args = {}
	function sam.add_message_argument(arg, func)
		if isstring(arg) and isfunction(func) then
			args[arg] = func
		end
	end

	local insert = function(t, v)
		t.__cnt = t.__cnt + 1
		t[t.__cnt] = v
	end

	function sam.format_message(msg, tbl, result, result_n)
		msg = Language[msg] or msg

		result = result or {}
		result.__cnt = result_n or 0

		local pos = 0
		local start, _end, arg, arg2 = nil, 0, nil, nil

		while true do
			start, _end, arg, arg2 = find(msg, "%{ *([%w_%#]+)([^%{}]-) *%}", _end)
			if not start then break end

			if pos ~= start then
				local txt = sub(msg, pos, start - 1)
				if txt ~= "" then
					insert(result, white_color)
					insert(result, txt)
				end
			end

			local ma = args[sub(arg, 1, 1)]
			if not ma then
				insert(result, "{" .. arg .. " " .. arg2 .. "}")
			else
				ma(result, tbl and tbl[arg], arg, unpack(arg2:Trim():Split(" ")))
			end

			pos = _end + 1
		end

		if pos <= #msg then
			insert(result, white_color)
			insert(result, sub(msg, pos))
		end

		return result
	end

	/*
		Admin
	*/
	sam.add_message_argument("A", function(result, admin)
		if sam.isconsole(admin) then
			-- we need to show that it's the real console!!!!!
			insert(result, Color(236, 240, 241))
			insert(result, "*")
			insert(result, Color(13, 130, 223))
			insert(result, "Console")
		else
			if sam.type(admin) == "Player" then
				if CLIENT and LocalPlayer() == admin then
					insert(result, Color(255, 215, 0))
					insert(result, sam.language.get("You"))
				else
					insert(result, Color(13, 130, 223))
					insert(result, admin:Name())
				end
			else
				insert(result, Color(13, 130, 223))
				insert(result, admin)
			end
		end
	end)

	/*
		Target(s)
	*/
	sam.add_message_argument("T", function(result, targets)
		for k, v in ipairs(sam.get_targets_list(targets)) do
			insert(result, v)
		end
	end)

	/*
		Value(s)
	*/
	sam.add_message_argument("V", function(result, value)
		insert(result, Color(0, 230, 64))
		insert(result, tostring(value))
	end)

	/*
		Text(s)
	*/
	sam.add_message_argument("S", function(result, text, _, color)
		insert(result, sam.get_color(color) or white_color)
		insert(result, tostring(text))
	end)

	-- https://gist.github.com/fernandohenriques/12661bf250c8c2d8047188222cab7e28
	local hex_rgb = function(hex)
		local r, g, b
		if #hex == 4 then
			r, g, b = tonumber(hex:sub(2, 2), 16) * 17, tonumber(hex:sub(3, 3), 16) * 17, tonumber(hex:sub(4, 4), 16) * 17
		else
			r, g, b = tonumber(hex:sub(2, 3), 16), tonumber(hex:sub(4, 5), 16), tonumber(hex:sub(6, 7), 16)
		end

		if not r or not g or not b then
			return color_white
		end

		return Color(r, g, b)
	end

	/*
		Colored Text(s)
	*/
	sam.add_message_argument("#", function(result, _, color, ...)
		local text = table.concat({...}, " ")
		insert(result, hex_rgb(color))
		insert(result, text)
	end)
end

function sam.get_message(msg)
	msg = Language[msg]
	if not msg then
		return false
	else
		return {Color(236, 240, 241), msg}
	end
end

function sam.language.get(key)
	return Language[key]
end

function sam.language.Add(key, value)
	Language[key] = value
end
--addons/admin_sam/lua/sam/command/arguments/number.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local get_number = function(argument, input, gsub)
	if (input == "" or input == nil) and argument.optional then
		if argument.default ~= nil then
			return argument.default
		end
		return ""
	end

	local number = tonumber(input)
	if gsub ~= false and not isnumber(number) then
		number = tonumber(input:gsub("%D", ""), 10 /*gsub returns two args*/)
	end

	return number
end

command.new_argument("number")
	:OnExecute(function(argument, input, ply, _, result, i)
		local number = get_number(argument, input)
		if number == "" then
			result[i] = nil
		elseif not number then
			ply:sam_send_message("invalid", {
				S = argument.hint or "number", S_2 = input
			})
			return false
		else
			if argument.min then
				number = math.max(number, argument.min)
			end

			if argument.max then
				number = math.min(number, argument.max)
			end

			if argument.round then
				number = math.Round(number)
			end

			result[i] = number
		end
	end)
	:Menu(function(set_result, body, buttons, argument)
		local number_entry = buttons:Add("SAM.TextEntry")
		number_entry:SetUpdateOnType(true)
		number_entry:SetNumeric(true)
		number_entry:SetTall(25)

		number_entry:SetCheck(function(number)
			number = get_number(argument, number, false)
			set_result(number)
			return number or false
		end)

		local hint = argument.hint or "number"
		if argument.default then
			hint = hint .. " = " .. tostring(argument.default)
		end
		number_entry:SetPlaceholder(hint)

		return number_entry
	end)
:End()
--addons/admin_sam_sui/lua/includes/modules/sui.lua:
if sui then return end

AddCSLuaFile()

sui = {}

do
	local wspace_chs = {} -- whitespace  characters except a normal space " "
	for k, v in ipairs({0x0c, 0x0a, 0x0d, 0x09, 0x0b}) do
		wspace_chs[string.char(v)] = true
	end
	sui.wspace_chs = wspace_chs

	local cntrl_chs = {string.char(0x7f)} -- control characters
	for i = 0x00, 0x1f do
		cntrl_chs[string.char(i)] = true
	end
	sui.cntrl_chs = cntrl_chs
end

if SERVER then
	AddCSLuaFile("sui/libs/tdlib/cl_tdlib.lua")
	AddCSLuaFile("sui/libs/bshadows.lua")
	AddCSLuaFile("sui/libs/gif_loader.lua")
	AddCSLuaFile("sui/libs/png_encoder.lua")
	AddCSLuaFile("sui/libs/types.lua")
	AddCSLuaFile("sui/cl_base.lua")
else
	include("sui/libs/tdlib/cl_tdlib.lua")
	include("sui/libs/bshadows.lua")
	include("sui/libs/types.lua")
	include("sui/cl_base.lua")
end

if SERVER then
	for _, f in ipairs(file.Find("sui/vgui/*.lua", "LUA")) do
		AddCSLuaFile("sui/vgui/" .. f)
	end
end
--addons/admin_sam_sui/lua/sui/vgui/sui_label.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local MOUSE_LEFT = MOUSE_LEFT

local SysTime = SysTime

local PANEL = {}

AccessorFunc(PANEL, "m_colText", "TextColor")
AccessorFunc(PANEL, "m_colTextStyle", "TextStyleColor")
AccessorFunc(PANEL, "m_FontName", "Font")

AccessorFunc(PANEL, "m_bDoubleClicking", "DoubleClickingEnabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_bAutoStretchVertical", "AutoStretchVertical", FORCE_BOOL)
AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBackground", "PaintBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bBackground", "DrawBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bDisabled", "Disabled", FORCE_BOOL)

AccessorFunc(PANEL, "m_bIsToggle", "IsToggle", FORCE_BOOL)
AccessorFunc(PANEL, "m_bToggle", "Toggle", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBright", "Bright", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDark", "Dark", FORCE_BOOL)
AccessorFunc(PANEL, "m_bHighlight",	"Highlight", FORCE_BOOL)

PANEL:SetIsToggle(false)
PANEL:SetToggle(false)
PANEL:SetDisabled(false)
PANEL:SetDoubleClickingEnabled(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local SetPaintBackgroundEnabled = Panel.SetPaintBackgroundEnabled
local SetPaintBorderEnabled = Panel.SetPaintBorderEnabled
local InvalidateLayout = Panel.InvalidateLayout
local SetFGColor = Panel.SetFGColor
function PANEL:Init()
	SetMouseInputEnabled(self, false)
	SetPaintBackgroundEnabled(self, false)
	SetPaintBorderEnabled(self, false)
end

function PANEL:AllowScale()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self:SizeToContents()
end

function PANEL:SetFont(font)
	if self.m_FontName == font then return end

	self.m_FontName = font
	self:SetFontInternal(self.m_FontName)
end

function PANEL:SetTextColor(col)
	if self.m_colText == col then return end

	self.m_colText = col
	SetFGColor(self, col.r, col.g, col.b, col.a)
end
PANEL.SetColor = PANEL.SetTextColor

function PANEL:GetColor()
	return self.m_colText or self.m_colTextStyle
end

function PANEL:Toggle()
	if not self:GetIsToggle() then return end

	self:SetToggle(not self:GetToggle())
	self:OnToggled(self:GetToggle())
end

function PANEL:SetDisabled(bDisabled)
	self.m_bDisabled = bDisabled
	InvalidateLayout(self)
end

function PANEL:SetEnabled(bEnabled)
	self:SetDisabled(not bEnabled)
end

function PANEL:IsEnabled()
	return not self:GetDisabled()
end

function PANEL:ApplySchemeSettings()
	local col = self:GetColor()
	if not col then return end

	self:SetFGColor(col.r, col.g, col.b, col.a)
end

function PANEL:AutoStretchVerticalThink()
	self:SizeToContentsY()
end

function PANEL:SetAutoStretchVertical(enable)
	self.m_bAutoStretchVertical = enable
	self.Think = enable and self.AutoStretchVerticalThink or nil
end

function PANEL:OnCursorEntered()
	InvalidateLayout(self, true)
end

function PANEL:OnCursorExited()
	InvalidateLayout(self, true)
end

function PANEL:OnMousePressed(mousecode)
	if self:GetDisabled() then return end

	if mousecode == MOUSE_LEFT and not dragndrop.IsDragging() and self.m_bDoubleClicking then
		if self.LastClickTime and SysTime() - self.LastClickTime < 0.2 then

			self:DoDoubleClickInternal()
			self:DoDoubleClick()
			return
		end

		self.LastClickTime = SysTime()
	end

	if self:IsSelectable() and mousecode == MOUSE_LEFT and input.IsShiftDown() then
		return self:StartBoxSelection()
	end

	self:MouseCapture(true)
	self.Depressed = true
	self:OnDepressed()
	InvalidateLayout(self, true)

	self:DragMousePress(mousecode)
end

function PANEL:OnMouseReleased(mousecode)
	self:MouseCapture(false)

	if self:GetDisabled() then return end
	if not self.Depressed and dragndrop.m_DraggingMain ~= self then return end

	if self.Depressed then
		self.Depressed = nil
		self:OnReleased()
		InvalidateLayout(self, true)
	end

	if self:DragMouseRelease(mousecode) then return end

	if self:IsSelectable() and mousecode == MOUSE_LEFT then
		local canvas = self:GetSelectionCanvas()
		if canvas then
			canvas:UnselectAll()
		end
	end

	if not self.Hovered then return end

	self.Depressed = true

	if mousecode == MOUSE_RIGHT then
		self:DoRightClick()
	end

	if mousecode == MOUSE_LEFT then
		self:DoClickInternal()
		self:DoClick()
	end

	if mousecode == MOUSE_MIDDLE then
		self:DoMiddleClick()
	end

	self.Depressed = nil
end

function PANEL:OnReleased()
end

function PANEL:OnDepressed()
end

function PANEL:OnToggled(bool)
end

function PANEL:DoClick()
	self:Toggle()
end

function PANEL:DoRightClick()
end

function PANEL:DoMiddleClick()
end

function PANEL:DoClickInternal()
end

function PANEL:DoDoubleClick()
end

function PANEL:DoDoubleClickInternal()
end

sui.register("Label", PANEL, "Label")
--addons/admin_sam_sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
local IsValid = IsValid

local TDLib_Classes = sui.TDLib.LibClasses
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local Panel = {}

function Panel:Init()
	self.tabs = {}

	local tab_scroller = self:Add(NAME .. ".ScrollPanel")
	tab_scroller:Dock(LEFT)

	function tab_scroller:Paint(w, h)
		self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet_bar"))
	end

	self.tabs_wide = 48
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:ScaleChanged()
	local tabs_wide = SUI.Scale(self.tabs_wide)
	self.tab_scroller:SetWide(tabs_wide)

	self:InvalidateLayout(true)

	local tabs = self.tabs
	for i = 1, #self.tabs do
		tabs[i].img:SetMinus(SUI.Scale(20))
	end
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet"))
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local tab_Paint = function(s, w, h)
	local cur_col
	if s.active then
		cur_col = GetColor("column_sheet_tab_active")
	elseif s.Hovered then
		cur_col = GetColor("column_sheet_tab_hover")
	else
		cur_col = GetColor("column_sheet_tab")
	end

	s:RoundedBox("Backgrounds", 0, 0, 0, w, h, cur_col)
end

local tab_OnRemove = function(s)
	table.RemoveByValue(s.parent.tabs, s)
end

function Panel:AddSheet(mat, load_func)
	local tab = self.tab_scroller:Add(NAME .. ".Button")
	tab:Dock(TOP)
	tab:SetText("")
	tab:SetTall(self.tabs_wide)

	tab.On = TDLib_Classes.On

	tab.DoClick = tab_DoClick
	tab.Paint = tab_Paint
	tab:On("OnRemove", tab_OnRemove)

	tab.parent = self
	tab.load_func = load_func

	local img = tab:Add(NAME .. ".Image")
	img:Dock(FILL)
	img:SetImage(mat)
	img:SetMinus(SUI.Scale(20))

	tab.img = img

	self.tab_scroller:AddItem(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function Panel:GetActiveTab()
	return self.active_tab
end

function Panel:SetActiveTab(new_tab)
	if new_tab == self.active_tab then return end

	if not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)
		panel:SetAlpha(0)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	local old_active_tab = self.active_tab
	local delay = 0
	if old_active_tab and IsValid(old_active_tab.panel) then
		old_active_tab.active = false
		delay = 0.2
		old_active_tab.panel:AlphaTo(0, delay, 0, function(_, p)
			if p:IsValid() then
				p:SetVisible(false)
			end
		end)
	end

	new_tab.active = true
	new_tab.panel:SetVisible(true)
	new_tab.panel:AlphaTo(255, 0.2, delay)
	self.active_tab = new_tab
end

sui.register("ColumnSheet", Panel, "EditablePanel")
--addons/admin_sam/lua/sam/sh_motd.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config
local command = sam.command

if CLIENT then
	config.add_menu_setting("MOTD URL (Leave empty for no MOTD)", function()
		local entry = vgui.Create("SAM.TextEntry")
		entry:SetPlaceholder("")
		entry:SetNoBar(true)
		entry:SetConfig("MOTDURL", "")

		return entry
	end)
end

local motd
local load_motd = function()
	local url = config.get("MOTDURL", "")
	if url == "" then
		command.remove_command("motd")
		hook.Remove("HUDPaint", "SAM.OpenMOTD")
		return
	end

	if IsValid(motd) then
		motd:Remove()
	end

	command.set_category("Menus")

	command.new("motd")
		:Help("Open MOTD menu")
		:OnExecute(function(ply)
			sam.netstream.Start(ply, "OpenMOTD")
		end)
	:End()

	if CLIENT then
		function sam.menu.open_motd()
			if IsValid(motd) then
				motd:Remove()
			end

			motd = vgui.Create("SAM.Frame")
			motd:Dock(FILL)
			motd:DockMargin(40, 40, 40, 40)
			motd:MakePopup()

			function motd.close.DoClick()
				motd:Remove()
			end

			local html = motd:Add("DHTML")
			html:Dock(FILL)
			html:OpenURL(url)
		end

		sam.netstream.Hook("OpenMOTD", function()
			sam.menu.open_motd()
		end)

		hook.Add("HUDPaint", "SAM.OpenMOTD", function()
			sam.menu.open_motd()
			hook.Remove("HUDPaint", "SAM.OpenMOTD")
		end)
	end
end
config.hook({"MOTDURL"}, load_motd)
--addons/admin_sam/lua/sam/modules/utime.lua:
if SAM_LOADED then return end

local PLAYER = FindMetaTable("Player")

function PLAYER:GetUTime()
	return self:sam_get_nwvar("TotalUTime")
end

function PLAYER:SetUTime(time)
	self:sam_set_nwvar("TotalUTime", time)
end

function PLAYER:GetUTimeStart()
	return self:sam_get_nwvar("UTimeStart")
end

function PLAYER:SetUTimeStart(time)
	self:sam_set_nwvar("UTimeStart", time)
end

function PLAYER:GetUTimeSessionTime()
	return CurTime() - self:GetUTimeStart()
end

function PLAYER:GetUTimeTotalTime()
	return self:GetUTime() + CurTime() - self:GetUTimeStart()
end

if SERVER then
	hook.Add("SAM.AuthedPlayer", "SAM.UTime", function(ply)
		ply:SetUTime(ply:sam_get_play_time())
		ply:SetUTimeStart(CurTime())
	end)
end
--addons/aocrp_emplacements/lua/autorun/sh_emplacements.lua:
hook.Add("Initialize", "PlaceableEmplacements.AddAmmoTypes", function()
    game.AddAmmoType( {
    	name = "emplacement_14mm",
    	dmgtype = DMG_DIRECT,
    	tracer = TRACER_NONE,
    	plydmg = 0,
    	npcdmg = 0,
    	force = 0,
    	minsplash = 0,
    	maxsplash = 0
    } )
    game.AddAmmoType( {
    	name = "emplacement_40mm",
    	dmgtype = DMG_DIRECT,
    	tracer = TRACER_NONE,
    	plydmg = 0,
    	npcdmg = 0,
    	force = 0,
    	minsplash = 0,
    	maxsplash = 0
    } )
    game.AddAmmoType( {
    	name = "emplacement_762",
    	dmgtype = DMG_DIRECT,
    	tracer = TRACER_NONE,
    	plydmg = 0,
    	npcdmg = 0,
    	force = 0,
    	minsplash = 0,
    	maxsplash = 0
    } )
    game.AddAmmoType( {
    	name = "emplacement_railcannon",
    	dmgtype = DMG_DIRECT,
    	tracer = TRACER_NONE,
    	plydmg = 0,
    	npcdmg = 0,
    	force = 0,
    	minsplash = 0,
    	maxsplash = 0
    } )

end)


if CLIENT then
	language.Add("emplacement_14mm_ammo", "14mm Emplacement")
	language.Add("emplacement_40mm_ammo", "14mm Emplacement")
	language.Add("emplacement_762_ammo", "14mm Emplacement")
	language.Add("emplacement_railcannon_ammo", "14mm Emplacement")
end
--addons/aoc_nextbots/lua/summe_nextbots/sh_config.lua:
AOCRPNextbots.Config = {}

-- Here you can set the NPCs that you can spawn with the pod and the dispenser.
AOCRPNextbots.Config.Tool = {
    [1] = {
        name = "B1 Kampfdroide",
        class = "aocrp_nextbot_b1",
        previewModel = "models/cis_npc/b1_battledroids/assault/b1_battledroid_assault.mdl",
        pod = true,
        dispenser = true,
        health = 300
    },

    [2] = {
        name = "Aqua Droide",
        class = "aocrp_nextbot_aqua",
        previewModel = "models/valley/aquadroid/aquadroid.mdl",
        pod = true,
        dispenser = true,
        health = 400
    },

    [3] = {
        name = "B1 Heavy",
        class = "aocrp_nextbot_b1_heavy",
        previewModel = "models/cis_npc/b1_battledroids/heavy/b1_battledroid_heavy.mdl",
        pod = true,
        dispenser = true,
        health = 400
    },

    [4] = {
        name = "B1 Sniper",
        class = "aocrp_nextbot_b1_sniper",
        previewModel = "models/cis_npc/hydro/b1_battledroids/aat/b1_battledroid_aat.mdl",
        health = 300
    },

    [5] = {
        name = "B2 Superkampfdroide",
        class = "aocrp_nextbot_b2",
        previewModel = "models/player/hydro/b2_battledroid/b2_battledroid.mdl",
        pod = true,
        dispenser = true,
        health = 800
    },

    [6] = {
        name = "B2 Jet",
        class = "aocrp_nextbot_b2_jetpack",
        previewModel = "models/player/hydro/b2_battledroid/b2_battledroid.mdl",
        health = 800
    },

    [7] = {
        name = "BX Kommandodroide",
        class = "aocrp_nextbot_bx",
        previewModel = "models/npc/bx100_commando_droid/regular/bx100_commando_droid_regular.mdl",
        pod = true,
        dispenser = true,
        health = 600
    },

    [8] = {
        name = "Droideka",
        class = "aocrp_nextbot_droideka",
        previewModel = "models/npc/starwars/droidekas/droideka.mdl",
        dispenser = true,
        health = 1000
    },

    [9] = {
        name = "Crab Droid",
        class = "aocrp_nextbot_crab",
        previewModel = "models/npc/starwars/crabby/crabdroid.mdl",
        health = 1200
    },

    [10] = {
        name = "Trandoshaner",
        class = "aocrp_nextbot_trando",
        previewModel = "models/npc_hcn/starwars/bf/bossk/bossk.mdl",
        health = 600
    },

    [11] = {
        name = "Civilian Droid",
        class = "acorp_nextbot_droid",
        previewModel = "models/player/swtor/droids/bodyguard_droid.mdl",
        health = 300
    },

    [12] = {
        name = "Mandalorianer",
        class = "aocrp_nextbot_uglymando",
        previewModel = "models/porky-da-corgi/starwars/mandalorians/bountyhunter_npc.mdl",
        health = 600
    },

    [13] = {
        name = "Ben",
        class = "aocrp_nextbot_combine",
        previewModel = "models/Combine_Soldier.mdl",
        health = 400
    },

    [14] = {
        name = "Ben 2",
        class = "aocrp_nextbot_elitecombine",
        previewModel = "models/Combine_Super_Soldier.mdl",
        health = 400
    },

    [15] = {
        name = "Ben 3",
        class = "aocrp_nextbot_combine",
        previewModel = "models/Police.mdl",
        health = 400
    }
}

-- Can droids open doors? May possibly save performance if you disable it.
AOCRPNextbots.Config.CanOpenDoors = true

-- Should the NPC check if the new enemy is in his vision field before setting him to the new target? Could cause performance problems.
AOCRPNextbots.Config.CheckFieldOfVision = false

-- Should headshots do more damage?
AOCRPNextbots.Config.Headshots = true

-- Enable the debug mode on default for everyone? Admins can activate it anytime via AOCRPNextbots_debug in their client console.
AOCRPNextbots.Config.Debug = false
--addons/aocrp_pixelui/lua/pixelui/core/cl_overrides.lua:

PIXEL.UI.Overrides = PIXEL.UI.Overrides or {}

function PIXEL.UI.CreateToggleableOverride(method, override, toggleGetter)
    return function(...)
        return toggleGetter(...) and override(...) or method(...)
    end
end

local overridePopupsCvar = CreateClientConVar("pixel_ui_override_popups", (PIXEL.OverrideDermaMenus > 1) and "1" or "0", true, false, "Should the default derma popups be restyled with PIXEL UI?", 0, 1)
function PIXEL.UI.ShouldOverrideDermaPopups()
    local overrideSetting = PIXEL.OverrideDermaMenus

    if not overrideSetting or overrideSetting == 0 then return false end
    if overrideSetting == 3 then return true end

    return overridePopupsCvar:GetBool()
end
--addons/aocrp_pixelui/lua/pixelui/core/cl_scaling.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local scrH = ScrH
local max = math.max
function PIXEL.Scale(value)
    return max(value * (scrH() / 1080), 1)
end

local constants = {}
local scaledConstants = {}
function PIXEL.RegisterScaledConstant(varName, size)
    constants[varName] = size
    scaledConstants[varName] = PIXEL.Scale(size)
end

function PIXEL.GetScaledConstant(varName)
    return scaledConstants[varName]
end

hook.Add("OnScreenSizeChanged", "PIXEL.UI.UpdateScaledConstants", function()
    for varName, size in pairs(constants) do
        scaledConstants[varName] = PIXEL.Scale(size)
    end
end)

--addons/aocrp_pixelui/lua/pixelui/elements/cl_avatar.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]
local PANEL = {}

AccessorFunc(PANEL, "MaskSize", "MaskSize", FORCE_NUMBER)

function PANEL:Init()
    self.Avatar = vgui.Create("AvatarImage", self)
    self.Avatar:SetPaintedManually(true)

    self.CirclePoly = {}
    self:SetMaskSize(1)
end

function PANEL:PerformLayout(w, h)
    self.Avatar:SetSize(w, h)

    self.CirclePoly = {}
    local maskSize = self:GetMaskSize()

    local t = 0
    for i = 1, 360 do
        t = math.rad(i * 720) / 720
        self.CirclePoly[i] = {x = w / 2 + math.cos(t) * maskSize, y = h / 2 + math.sin(t) * maskSize}
    end
end

function PANEL:SetPlayer(ply, size)
    self.Avatar:SetPlayer(ply, size)
end

function PANEL:SetSteamID(id, size)
    self.Avatar:SetSteamID(id, size)
end

local render = render
local surface = surface
local whiteTexture = surface.GetTextureID("vgui/white")
function PANEL:Paint(w, h)
    render.ClearStencil()
    render.SetStencilEnable(true)

    render.SetStencilWriteMask(1)
    render.SetStencilTestMask(1)

    render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
    render.SetStencilPassOperation(STENCILOPERATION_ZERO)
    render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
    render.SetStencilReferenceValue(1)

    surface.SetTexture(whiteTexture)
    surface.SetDrawColor(255, 255, 255, 255)
    surface.DrawPoly(self.CirclePoly)

    render.SetStencilFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
    render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
    render.SetStencilReferenceValue(1)

    self.Avatar:SetPaintedManually(false)
    self.Avatar:PaintManual()
    self.Avatar:SetPaintedManually(true)

    render.SetStencilEnable(false)
    render.ClearStencil()
end

vgui.Register("PIXEL.Avatar", PANEL, "Panel")
--addons/aocrp_pixelui/lua/pixelui/elements/cl_property_sheet.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "m_sText", "Text")
AccessorFunc(PANEL, "m_pPropertySheet", "PropertySheet")
AccessorFunc(PANEL, "m_pPanel", "Panel")

PIXEL.RegisterFont("UI.Tab", "Open Sans Bold", 16)

function PANEL:Init()
	self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, -4)
	self.SelectedCol = PIXEL.Colors.Primary
	self.UnselectedTextCol = PIXEL.Colors.SecondaryText
	self.SelectedTextCol = PIXEL.Colors.PrimaryText

	self.Color = PIXEL.CopyColor(self.BackgroundCol)
	self.TextColor = PIXEL.CopyColor(self.UnselectedTextCol)
end

function PANEL:Setup(text, propertySheet, panel)
	self:SetText(text)
	self:SetPropertySheet(propertySheet)
	self:SetPanel(panel)

	PIXEL.SetFont("UI.Tab")
	self:SetWide(PIXEL.GetTextSize(text) + PIXEL.Scale(16))
end

function PANEL:IsActive()
	return self:GetPropertySheet():GetActiveTab() == self
end

function PANEL:DoClick()
	self:GetPropertySheet():SetActiveTab(self)
end

function PANEL:GetTabHeight()
	return PIXEL.Scale(24)
end

function PANEL:DragHoverClick(hoverTime)
	self:DoClick()
end

function PANEL:DoRightClick()
	if not IsValid(self:GetPropertySheet()) then return end

	local tabs = vgui.Create("PIXEL.Menu", self)

	for k, v in pairs(self:GetPropertySheet().Items) do
		if not v or not IsValid(v.Tab) or not v.Tab:IsVisible() then continue end

		tabs:AddOption(v.Tab:GetText(), function()
			if not v or not IsValid(v.Tab) or not IsValid(self:GetPropertySheet()) or not IsValid(self:GetPropertySheet().tabScroller) then return end
			v.Tab:DoClick()
			self:GetPropertySheet().tabScroller:ScrollToChild(v.Tab)
		end)
	end

	tabs:Open()
end

function PANEL:Paint(w, h)
	self.Color = PIXEL.LerpColor(FrameTime() * 12, self.Color, (self:IsActive() or self:IsHovered()) and self.SelectedCol or self.BackgroundCol)
	self.TextColor = PIXEL.LerpColor(FrameTime() * 12, self.TextColor, (self:IsActive() or self:IsHovered()) and self.SelectedTextCol or self.UnselectedTextCol)

	PIXEL.DrawRoundedBoxEx(PIXEL.Scale(6), 0, 0, w, h, self.Color, true, true)
	PIXEL.DrawSimpleText(self:GetText(), "UI.Tab", w * .5, h * .5, self.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

vgui.Register("PIXEL.Tab", PANEL, "PIXEL.Button")


PANEL = {}

AccessorFunc(PANEL, "m_pActiveTab", "ActiveTab")
AccessorFunc(PANEL, "m_iPadding", "Padding")
AccessorFunc(PANEL, "m_fFadeTime", "FadeTime")

function PANEL:Init()
	self.tabScroller = vgui.Create("DHorizontalScroller", self)
	self.tabScroller:SetOverlap(PIXEL.Scale(5))
	self.tabScroller:Dock(TOP)
	self.tabScroller:DockMargin(PIXEL.Scale(3), 0, PIXEL.Scale(3), 0)

	self:SetFadeTime(0.1)
	self:SetPadding(PIXEL.Scale(8))

	self.animFade = Derma_Anim("Fade", self, self.CrossFade)

	self.Items = {}

	self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 2)
end

function PANEL:AddSheet(label, panel, material, noStretchX, noStretchY, tooltip)
	if not IsValid(panel) then
		ErrorNoHalt("PIXEL.PropertySheet:AddSheet tried to add invalid panel!")
		debug.Trace()
		return
	end

	local sheet = {}

	sheet.Name = label

	sheet.Tab = vgui.Create("PIXEL.Tab", self)
	sheet.Tab:SetTooltip(tooltip)
	sheet.Tab:Setup(label, self, panel, material)

	sheet.Panel = panel
	sheet.Panel.NoStretchX = noStretchX
	sheet.Panel.NoStretchY = noStretchY
	sheet.Panel:SetPos(self:GetPadding(), PIXEL.Scale(24) + self:GetPadding())
	sheet.Panel:SetVisible(false)

	panel:SetParent(self)

	table.insert(self.Items, sheet)

	if not self:GetActiveTab() then
		self:SetActiveTab(sheet.Tab)
		sheet.Panel:SetVisible(true)
	end

	self.tabScroller:AddPanel(sheet.Tab)

	return sheet
end

function PANEL:SetActiveTab(active)
	if not IsValid(active) or self.m_pActiveTab == active then return end

	if IsValid(self.m_pActiveTab) then
		self:OnActiveTabChanged(self.m_pActiveTab, active)

		if self:GetFadeTime() > 0 then
			self.animFade:Start(self:GetFadeTime(), {OldTab = self.m_pActiveTab, NewTab = active})
		else
			self.m_pActiveTab:GetPanel():SetVisible(false)
		end
	end

	self.m_pActiveTab = active
	self:InvalidateLayout()
end

function PANEL:OnActiveTabChanged(old, new) end

function PANEL:Think()
	self.animFade:Run()
end

function PANEL:GetItems()
	return self.Items
end

function PANEL:CrossFade(anim, delta, data)
	if not data or not IsValid(data.OldTab) or not IsValid(data.NewTab) then return end

	local old = data.OldTab:GetPanel()
	local new = data.NewTab:GetPanel()

	if not IsValid(old) and not IsValid(new) then return end

	if anim.Finished then
		if IsValid(old) then
			old:SetAlpha(255)
			old:SetZPos(0)
			old:SetVisible(false)
		end

		if IsValid(new) then
			new:SetAlpha(255)
			new:SetZPos(0)
			new:SetVisible(true)
		end

		return
	end

	if anim.Started then
		if IsValid(old) then
			old:SetAlpha(255)
			old:SetZPos(0)
		end

		if IsValid(new) then
			new:SetAlpha(0)
			new:SetZPos(1)
		end
	end

	if IsValid(old) then
		old:SetVisible(true)
		if not IsValid(new) then old:SetAlpha(255 * (1 - delta)) end
	end

	if IsValid(new) then
		new:SetVisible(true)
		new:SetAlpha(255 * delta)
	end
end

function PANEL:PerformLayout()
	local activeTab = self:GetActiveTab()
	local padding = self:GetPadding()

	if not IsValid(activeTab) then return end

	activeTab:InvalidateLayout(true)

	self.tabScroller:SetTall(activeTab:GetTall())

	local activePanel = activeTab:GetPanel()

	for k, v in pairs(self.Items) do
		if v.Tab:GetPanel() == activePanel then
			if IsValid(v.Tab:GetPanel()) then v.Tab:GetPanel():SetVisible(true) end
			v.Tab:SetZPos(100)
		else
			if IsValid(v.Tab:GetPanel()) then v.Tab:GetPanel():SetVisible(false) end
			v.Tab:SetZPos(1)
		end
	end

	if IsValid(activePanel) then
		if not activePanel.NoStretchX then
			activePanel:SetWide(self:GetWide() - padding * 2)
		else
			activePanel:CenterHorizontal()
		end

		if not activePanel.NoStretchY then
			local _, y = activePanel:GetPos()
			activePanel:SetTall(self:GetTall() - y - padding)
		else
			activePanel:CenterVertical()
		end

		activePanel:InvalidateLayout()
	end

	self.animFade:Run()
end

function PANEL:SizeToContentWidth()
	local wide = 0

	for k, v in pairs(self.Items) do
		if IsValid(v.Panel) then
			v.Panel:InvalidateLayout(true)
			wide = math.max(wide, v.Panel:GetWide() + self:GetPadding() * 2)
		end
	end

	self:SetWide(wide)
end

function PANEL:SwitchToName(name)
	for k, v in pairs(self.Items) do
		if v.Name == name then
			v.Tab:DoClick()
			return true
		end
	end

	return false
end

function PANEL:CloseTab(tab, removePanelToo)
	for k, v in pairs(self.Items) do
		if v.Tab ~= tab then continue end
		table.remove(self.Items, k)
	end

	for k, v in pairs(self.tabScroller.Panels) do
		if v ~= tab then continue end
		table.remove(self.tabScroller.Panels, k)
	end

	self.tabScroller:InvalidateLayout(true)

	if tab == self:GetActiveTab() then
		self.m_pActiveTab = self.Items[#self.Items].Tab
	end

	local pnl = tab:GetPanel()
	if removePanelToo then
		pnl:Remove()
	end

	tab:Remove()

	self:InvalidateLayout(true)

	return pnl
end

function PANEL:Paint(w, h)
	local activeTab = self:GetActiveTab()
	local offset = activeTab and activeTab:GetTall() or 0

	PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, offset, w, h - offset, self.BackgroundCol)
end

vgui.Register("PIXEL.PropertySheet", PANEL, "Panel")
--addons/aocrp_pixelui/lua/pixelui/elements/cl_text_button.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "TextAlign", "TextAlign", FORCE_NUMBER)
AccessorFunc(PANEL, "TextSpacing", "TextSpacing", FORCE_NUMBER)
AccessorFunc(PANEL, "Font", "Font", FORCE_STRING)

PIXEL.RegisterFont("UI.TextButton", "Open Sans SemiBold", 20)

function PANEL:Init()
    self:SetText("Button")
    self:SetTextAlign(TEXT_ALIGN_CENTER)
    self:SetTextSpacing(PIXEL.Scale(6))
    self:SetFont("UI.TextButton")

    self:SetSize(PIXEL.Scale(100), PIXEL.Scale(30))
end

function PANEL:SizeToText()
    PIXEL.SetFont(self:GetFont())
    self:SetSize(PIXEL.GetTextSize(self:GetText()) + PIXEL.Scale(14), PIXEL.Scale(30))
end

function PANEL:PaintExtra(w, h)
    local textAlign = self:GetTextAlign()
    local textX = (textAlign == TEXT_ALIGN_CENTER and w / 2) or (textAlign == TEXT_ALIGN_RIGHT and w - self:GetTextSpacing()) or self:GetTextSpacing()

    if not self:IsEnabled() then
        PIXEL.DrawSimpleText(self:GetText(), self:GetFont(), textX, h / 2, PIXEL.Colors.DisabledText, textAlign, TEXT_ALIGN_CENTER)
        return
    end

    PIXEL.DrawSimpleText(self:GetText(), self:GetFont(), textX, h / 2, PIXEL.Colors.PrimaryText, textAlign, TEXT_ALIGN_CENTER)
end

vgui.Register("PIXEL.TextButton", PANEL, "PIXEL.Button")
--lua/autorun/venator_colorchange.lua:
// Created by Airfox aka. Konsti
// Huge thanks to him!

if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end

local nextTick = nextTick or 0
local materialHull = Material("kingpommes/starwars/venator/hull_red")
local materialHullPanel = Material("kingpommes/starwars/venator/hull_panels_red")
local materialPropperHull = Material("kingpommes/starwars/venator/hull_red")
local materialPropperHullPanel = Material("models/kingpommes/starwars/venator/propper/hull_red")
local materialPropperInsignia = Material("models/kingpommes/starwars/venator/propper/venator_insignia")
local republicLook = true

materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/venator_insignia")

if SERVER then
	util.AddNetworkString("Venator_Ext_ColorNet")

	-- Networks current state to every new player that joins the server.
	hook.Add("PlayerInitialSpawn", "Venator_Ext_ColorConnectSync", function(ply)
		net.Start("Venator_Ext_ColorNet")
			net.WriteBool(republicLook)
		net.Send(ply)
	end)
end

hook.Add("Think", "Venator_Ext_ColorThink", function()
	if nextTick > CurTime() then return end

	nextTick = CurTime() + 1
	
	if SERVER then
		-- Finds all entities with this name.
		local entities = ents.FindByName("colorchange_target")

		-- Checks if an entity has been found and alarm is on. Also if the network has already been sent.
		if #entities >= 1 and republicLook then
			republicLook = false
			net.Start("Venator_Ext_ColorNet")
				net.WriteBool(republicLook)
			net.Broadcast()

			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull_red" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/invis")
			end
		elseif #entities == 0 and not republicLook then
			republicLook = true
			net.Start("Venator_Ext_ColorNet")
				net.WriteBool(republicLook)
			net.Broadcast()

			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/venator_insignia")
			end
		end
	elseif CLIENT then
		-- Checks if alarm is on. 
		if not republicLook then
			-- Changes between textured.
			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull_red" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/invis")
			end
		else
			-- Resets the texture to default, when the border should be visible.
			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/venator_insignia")
			end
		end
	end
end)

if CLIENT then
	-- Receives current state.
	net.Receive("Venator_Ext_ColorNet", function(len)
		republicLook = net.ReadBool()
	end)
end
--addons/vyhub-gmod/lua/autorun/vyhub_load.lua:

local f = string.format

VyHub = VyHub or {}
VyHub.Config = VyHub.Config or {}
VyHub.Lib = VyHub.Lib or {}
VyHub.ready = false

local vyhub_root = "vyhub"

local color_warn = Color(211, 120, 0)
local color_err = Color(255, 0, 0)
local color_green = Color(0, 255, 0)

function VyHub:msg(message, type)
    type = type or "neutral"

    // Remove color tags
    message = string.gsub(message, "<([%l]+)>([^<]+)</%1>", "%2")

	if type == "success" then
		MsgC("[VyHub] ", color_green, message .. "\n")
	elseif type == "error" then
		MsgC("[VyHub] [ERROR] ", color_err, message .. "\n")
	elseif type == "neutral" then
		MsgC("[VyHub] ", color_white, message .. "\n")
    elseif type == "warning" then
		MsgC("[VyHub] [WARN] ", color_warn, message .. "\n")
    elseif type == "debug" and VyHub.Config.debug then
		MsgC("[VyHub] [Debug] ", color_white, message .. "\n")
	end
end

VyHub:msg("Initializing...")

if SERVER then
    addon_incomplete = false

    if file.Exists( vyhub_root .. '/lang/en.json', "LUA") then
        if file.Exists( vyhub_root .. '/config/sv_config.lua', "LUA") then
            hook.Run("vyhub_loading_start")

            -- libs
            VyHub:msg("Loading lib files...")
            local files = file.Find( vyhub_root .."/lib/*.lua", "LUA" )
            for _, file in ipairs( files ) do
                AddCSLuaFile( vyhub_root .. "/lib/" .. file )
                include( vyhub_root .. "/lib/" .. file )
            end

            -- Shared Config
            include( vyhub_root .. '/config/sh_config.lua' )
            AddCSLuaFile( vyhub_root .. "/config/sh_config.lua" )

            -- Language
            VyHub:msg('Loading ' .. VyHub.Config.lang .. ' language...')
            include( vyhub_root .. '/shared/sh_lang.lua' )

            -- Config Files
            VyHub:msg("Loading config files...")
            include( vyhub_root .. '/config/sv_config.lua' )

            -- Shared Files
            VyHub:msg("Loading shared files...")
            local files = file.Find( vyhub_root .."/shared/*.lua", "LUA" )
            for _, file in ipairs( files ) do
                AddCSLuaFile( vyhub_root .. "/shared/" .. file )
                include( vyhub_root .. "/shared/" .. file )
            end
            
            -- Client Files
            VyHub:msg("Loading client files...")
            local files = file.Find( vyhub_root .."/client/*.lua", "LUA" )
            for _, file in ipairs( files ) do
                AddCSLuaFile( vyhub_root .."/client/" .. file )
            end

            -- Server Files
            VyHub:msg("Loading server files...")
            local files = file.Find( vyhub_root .. "/server/*.lua", "LUA" )
            for _, file in ipairs( files ) do
                include( vyhub_root .. "/server/" .. file )
            end

            game.ConsoleCommand("sv_hibernate_think 1\n")

            file.CreateDir("vyhub")

            VyHub.Config:load_cache_config()

            timer.Simple(2, function()
                hook.Run("vyhub_loading_finish")
            end)
            
            VyHub:msg("Finished loading!")
        else
            VyHub:msg("Could not find lua/vyhub/config/sv_config.lua. Please make sure it exists.", "error")
        end
    else
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("Could not find language files!!! Please make sure to download a correct vyhub-gmod release here: https://github.com/matbyte-com/vyhub-gmod/releases", "error")
        VyHub:msg("Cannot proceed with initialization.", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
    end
end


if CLIENT then
    if file.Exists( vyhub_root .. '/shared/sh_lang.lua', "LUA") then
        hook.Run("vyhub_loading_start")
        
        -- libs
        VyHub:msg("Loading lib files...")
        local files = file.Find( vyhub_root .."/lib/*.lua", "LUA" )
        for _, file in ipairs( files ) do
            include( vyhub_root .. "/lib/" .. file )
        end

        -- Language
        VyHub:msg('Loading language...')
        include( vyhub_root .. '/shared/sh_lang.lua' )

        -- Config Files
        VyHub:msg("Loading config files...")
        local files = file.Find( vyhub_root .."/config/*.lua", "LUA" )
        for _, file in ipairs( files ) do
            if not string.StartWith(file, 'sv_') then
                include( vyhub_root .. "/config/" .. file )
            end
        end

        -- Shared Files
        VyHub:msg("Loading shared files...")
        local files = file.Find( vyhub_root .."/shared/*.lua", "LUA" )
        for _, file in ipairs( files ) do
            include( vyhub_root .. "/shared/" .. file )
        end

        -- Client Files
        VyHub:msg("Loading client files...")
        local files = file.Find( vyhub_root .."/client/*.lua", "LUA" )
        for _, file in ipairs( files ) do
            include( vyhub_root .."/client/" .. file )
        end

        timer.Simple(2, function()
            hook.Run("vyhub_loading_finish")
        end)
        
        VyHub:msg("Finished loading!")
    else
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("VyHub not correctly loaded. Please check the server log.", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
        VyHub:msg("!!!", "error")
    end
end

--addons/vyhub-gmod/lua/vyhub/shared/sh_group.lua:
VyHub.Group = VyHub.Group or {}

function VyHub.Group:get(groupname)
    if VyHub.groups_mapped == nil then
        return nil
    end

    return VyHub.groups_mapped[groupname]
end
--lua/wos/anim_extension/extensions/wos_exp.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Experimental" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Experimental\n" )
--lua/wos/anim_extension/core/sh_prone_support.lua:
--[[-------------------------------------------------------------------
	wiltOS Prone Compatability:
		Fixes hold types for Prone Mod
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.HoldTypes = wOS.AnimExtension.HoldTypes or {}

hook.Add("prone.Initialized", "wOS.AnimExtension.AddProneTypes", function()
	for holdtype, data in pairs( wOS.AnimExtension.HoldTypes ) do
		local iseq = prone.GetIdleAnimation( data.BaseHoldType ) 
		local mseq = prone.GetMovingAnimation( data.BaseHoldType ) 
		prone.AddNewHoldTypeAnimation( holdtype, mseq, iseq )
	end
end )


--lua/wos/anim_extension/holdtypes/g_combo1.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_combo1"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "combo1" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "combo1" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/g_combo32.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_combo32"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "combo32" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "combo32" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/g_rollleft.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_rollleft"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "rollleft" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "rollleft" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "wos_judge_a_idle"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/rollsword.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "rollsword"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "rollsword" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "rollsword" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "wos_judge_a_idle"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--addons/z_anticrash_v1.4.6/lua/z_anticrash/languages/ch.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local ch = {
	
	-- Stats
	lag = "延迟",
	collisions = "物理碰撞",
	props = "PROPS",
	propsFrozen = "被冻结props",
	npcs = "NPC",
	vehicles = "车辆",
	players = "玩家",
	uptime = "更新时间",
	entities = "实体",
	spawned = "出生点",
	fps = "帧数",
	tickrate = "点击率",
	runAntiLagMeasures = "运行防滞后措施",
	
	-- Users
	search = "搜索",
	constraints = "制约措施",
	showEntities = "显示实体",
	hideEntities = "隐藏实体",
	resetMap = "重置地图",
	freezeEntities = "冻结实体",
	removeEntities = "移除实体",
	
	-- Global
	noCollideEntities = "无碰撞实体",
	
	-- Lag
	heavyLag = "检测到严重滞后！",
	lagIsStuck = "警告：服务器滞后了！",
	crashPrevented = "防止服务器崩溃！",
	cleaningMap = "+ 清理地图...",
	removingEnts = "+ 移除了%s个实体",
	revertChanges = "+ 移除%s个最近%s分钟内创建的实体",
	freezeingEnts = "+ 冻结了%s个实体",
	noCollidingEnts = "+ 无碰撞了%s实体",
	offenderWarning = "%s个可疑的滞后，有(%s)个实体",
	freezingAllEntities = "冻结所有实体(%s)",

	-- Dupes
	dupesNotEnabled = "这个服务器上没有启用复制功能！",
	advDupesNotEnabled = "该服务器未启用高级复制功能！",
	dupeExceedsSize = "复制的东西超过了最大尺寸的限制！(最小:%s, 最大:%s)",
	dupeInformation = "%s复制中，其中包含%s个实体和%s个限制",
	
	-- Notifications
	triggeredAntiLagMeasures = "触发了防滞后措施！",
	ranAntilagMeasures = "正在运行防滞后措施！",
	hasNoEntities = "没有实体！",
	youRemovedFrom = "你删除%s个属于%s实体！",
	removedYourObjects = "已删除你生成的实体！",
	youFrozeFrom = "你冻结了%s个属于%s的实体！",
	frozeYourObjects = "已冻结你生成的实体！",
	enabledSpawnAbility = "已重新启用你的生成功能！",
	disabledSpawnAbility = "已禁用你的生成功能！",
	youEnabledSpawnAbility = "你启用了%s的生成功能！",
	youDisabledSpawnAbility = "你禁用了%s的生成功能！",
	
	resetTheMap = "重置地图！",
	noEntNameFound = "%s未找到！",
	noEntitiesFound = "没有找到实体！",
	noUnfrozenEntsFound = "没有找到已解冻实体!",
	noUnCollidedEntsFound = "没有找到无碰撞实体！",
	freezeAllEnts = "%s冻结了所有%s！(%s)",
	noCollideAllEnts = "%s无碰撞了所有%s！(%s)",
	removedAllEntName = "%s移除了所有%s！(%s)",
	entitiesLowCase = "实体",
	
	-- Console Log
	removedEntitiesFrom = "%s移除了%s个属于%s的实体！",
	frozeEntitiesFrom = "%s冻结了%s个属于%s的实体！",
	enabledSpawningCapabilities = "%s启用了%s的生成功能！",
	disabledSpawningCapabilities = "%s禁用了%s生成功能！",
	removingHighCollision = "删除高碰撞%s(%s)从%s！",
	
}

return ch
--addons/z_anticrash_v1.4.6/lua/z_anticrash/languages/es.lua:
local es = {
 
	-- Stats
	lag = "LAG",
	collisions = "COLISIONES",
	props = "PROPS",
	propsFrozen = "PROPS CONGELADOS",
	npcs = "NPCS",
	vehicles = "VEHÍCULOS",
	players = "JUGADORES",
	uptime = "TIEMPO ACTIVO",
	entities = "ENTIDADES",
	spawned = "GENERADOS/AS",
	fps = "FPS",
	tickrate = "TICKRATE",
	runAntiLagMeasures = "EJECUTAR MEDIDAS ANTI-LAG",
 
	-- Users
	search = "Buscar",
	constraints = "INTERACCIONES",
	showEntities = "Mostrar Entidades",
	hideEntities = "Ocultar Entidades",
	resetMap = "Reiniciar Mapa",
	freezeEntities = "Congelar Entidades",
	removeEntities = "Remover Entidades",
 
	-- Global
	noCollideEntities = "Entidades Sin Colisiones",
 
	-- Lag
	heavyLag = "¡Gran nivel de lag detectado!",
	lagIsStuck = "¡Advertencia: atasco de lag!",
	crashPrevented = "¡Se previno un crasheo del servidor!",
	cleaningMap = "+ Limpiando mapa...",
	removingEnts = "+ Removiendo %s entidades",
	revertChanges = "+ Removiendo %s entidades creadas en los últimos %s minutos",
	freezeingEnts = "+ Congelando %s entidades",
	noCollidingEnts = "+ Removiendo colisiones en %s entidades",
	offenderWarning = "¡%s ha generado una cantidad sospechosa de entidades (%s). Esto podría generar lag. ",
	freezingAllEntities = "Congeló todas las entidades (%s)",
 
	-- Dupes
	dupesNotEnabled = "¡Los Duplicados no están permitidos en este servidor!",
	advDupesNotEnabled = "¡Los Duplicados Avanzados (advDupes) no están permitidos en este servidor!",
	dupeExceedsSize = "¡Ese Duplicado excede el tamaño límite! (tamaño:%s, máximo:%s)",
	dupeInformation = "%s ha generado un Duplicado, el cual contiene %s entidades y %s Interacciones",
 
	-- Notifications
	triggeredAntiLagMeasures = "ha provocado que se activen las Medidas Anti-Lag.",
	ranAntilagMeasures = "ha activado las Medidas Anti-Lag.",
	hasNoEntities = "no tiene entidades.",
	youRemovedFrom = "¡Has removido %s entidades de %s!",
	removedYourObjects = "removió tus entidades",
	youFrozeFrom = "¡Has congelado %s entidades de %s!",
	frozeYourObjects = "congeló tus entidades.",
	enabledSpawnAbility = "te otorgó permiso nuevamente para generar entidades.",
	disabledSpawnAbility = "te removió los permisos para generar entidades.",
	youEnabledSpawnAbility = "¡Has habilitado a %s la capacidad de generar entidades!",
	youDisabledSpawnAbility = "¡Has deshabilitado a %s la capacidad de generar entidades!",
 
	resetTheMap = "reinició el mapa.",
	noEntNameFound = "No se ha encontrado la entidad %s",
	noEntitiesFound = "¡No se encontraron entidades!",
	noUnfrozenEntsFound = "¡No se encontraron entidades descongeladas!",
	noUnCollidedEntsFound = "¡No se encontraron entidades sin colisiones!",
	freezeAllEnts = "¡%s congeló todos los/las %s! (%s)",
	noCollideAllEnts = "%s le removió las colisiones a todos los/las %s! (%s)",
	removedAllEntName = "¡%s removió todos los/las %s! (%s)",
	entitiesLowCase = "entidades",
	removingOutOfBounds = "Removiendo %s fuera de límites",
 
	-- Console Log
	removedEntitiesFrom = "¡%s removió %s entidades de %s!",
	frozeEntitiesFrom = "¡%s congeló %s entidades de %s!",
	enabledSpawningCapabilities = "¡%s reactivó la capacidad de generar entidades de %s!",
	disabledSpawningCapabilities = "¡%s deshabilitó la capacidad de generar entidades de %s!",
	removingHighCollision = "¡Removiendo %s con niveles de colisión altos (%s) de %s!",
 
	-- Exploits
	chatClearKick = "¡%s fue kickeado por intentar usar el exploit ChatClear!",
 
}
 
return es
--addons/z_anticrash_v1.4.6/lua/z_anticrash/shared/sh_exploits.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

/*
	Measures against various exploits
*/

/*
	Name: Chatclear exploit 
	Used by: Angry script kiddies that got banned from their fav DarkRP server
*/

if SH_ANTICRASH.SETTINGS.EXPLOITS.CHATCLEAR then

	local kickMsg = [[
===================================	
KICKED!

By: Anti-Crash

Reason: ChatClear exploit!

===================================	]]

	local function IsOffender(str)
		
		local filteredStr = string.gsub(str, "[%c%s]", '')
		
		return #filteredStr == 0
		
	end

	if CLIENT then

		local function ChatFilter(ply, str, isTeam, isDead)
		
			if IsOffender(str) then 
				return true 
			end
		
		end
		hook.Add("OnPlayerChat","z_anticrash_ChatFilter",ChatFilter)

	end

	if SERVER then

		local offenders = {}

		local function ChatFilter(ply, str, isTeam)

			if IsOffender(str) then
				
				offenders[ply] = (offenders[ply] or 0) + 1
				
				if SH_ANTICRASH.SETTINGS.EXPLOITS.CHATCLEARKICK and offenders[ply] > SH_ANTICRASH.SETTINGS.EXPLOITS.CHATCLEARKICKAMOUNT then
					ply:Kick(kickMsg)
					
					local plyFormat = SH_ANTICRASH.UTILS.LOG.GetPlayerFormat(ply)
					SH_ANTICRASH.UTILS.LOG.Print("##chatClearKick %"..plyFormat)
				end
				
				return true
				
			end
		
		end
		hook.Add("PlayerSay","z_anticrash_ChatFilter",ChatFilter)

	end
	
end

/*
	Name: Blackscreen exploit + Fading Door post processing exploit
	Used by: Roblox kiddies that wanna ruin the fun for everyone
	Reference: Thanks to SnowboiTheGr8 for patching this exploit in his crident anticrash
	Link: https://github.com/SnowboiTheGr8/gmod-anticrash/blob/master/lua/autorun/server/sv_crident-anticrash.lua
*/

if SERVER then

	local function IsBlackoutMaterial(mat)
		return string.StartWith(mat, "pp/") and string.EndsWith(mat, "/copy")
	end

	local function BlockBlackoutProps(ply, model, ent)
		
		local mat = ent:GetMaterial()
		
		if IsBlackoutMaterial(mat) then
			ent:Remove()
		end
	
	end
	hook.Add("PlayerSpawnedProp", "z_anticrash_BlockBlackoutProps", BlockBlackoutProps)

	local function BlockBlackoutMaterial(ply, tr, tool)
	
		local toolName = tool:lower()
	
		if toolName == "material" then
		
			local tool = ply:GetActiveWeapon():GetToolObject()
			local mat = string.lower(tool:GetClientInfo("override"))
			
			if IsBlackoutMaterial(mat) then
				return false
			end
			
		end
		
		if toolName == "fading_door" then
		
			local tool = ply:GetActiveWeapon():GetToolObject()
			local mat = string.lower(tool:GetClientInfo("mat"))

			if IsBlackoutMaterial(mat) then
				return false
			end
		
		end

	end
	hook.Add( "CanTool", "z_anticrash_BlockBlackoutMaterial", BlockBlackoutMaterial)

end

/*
	Name: ModelScale exploit
	Used by: Frustrated virgin nerds
	Reference: Thanks to Reism for patching this in his workshop mod
	Link: https://steamcommunity.com/sharedfiles/filedetails/?id=1535483797
*/

if SERVER then

	local function PatchModelScaleExploit(ply, tr, tool)

		local dupeTbl

		if tool == "adv_duplicator" then
			dupeTbl = ply:GetActiveWeapon():GetToolObject().Entities
			
		elseif tool == "advdupe2" and ply.AdvDupe2 then
			 dupeTbl = ply.AdvDupe2.Entities
			 
		elseif tool == "duplicator" and ply.CurrentDupe then
			dupeTbl = ply.CurrentDupe.Entities
			
		end

		if !dupeTbl then return end
		
		for k, dupeElement in pairs(dupeTbl) do
			
			if !dupeElement.ModelScale then 
				continue 
			end
			
			if dupeElement.ModelScale > 10 or dupeElement.ModelScale < 0.1 then
				dupeElement.ModelScale = 1
			end
			
		end

	end
	hook.Add( "CanTool", "z_anticrash_PatchModelScaleExploit", PatchModelScaleExploit)

end

/*
	Name: SetAngles/SetPos exploits
	Used by: Little kiddos who wanna be cool
	Reference: Special thanks to the kiddos who spammed this method on my server
*/

local ent = FindMetaTable("Entity")
ent.__oldSetAngles = ent.__oldSetAngles or ent.SetAngles
ent.__oldSetPos = ent.__oldSetPos or ent.SetPos

local phys = FindMetaTable("PhysObj")
phys.__oldSetAngles = phys.__oldSetAngles or phys.SetAngles
phys.__oldSetPos = phys.__oldSetPos or phys.SetPos

function ent:SetAngles(oldAngles)

	angles = oldAngles or Angle()
	angles.p = oldAngles.p or 0
	angles.y = oldAngles.y or 0
	angles.r = oldAngles.r or 0
	
	self:__oldSetAngles(angles)

end

function ent:SetPos(oldPos)

	pos = oldPos or Vector()
	pos.x = oldPos.x or 0
	pos.y = oldPos.y or 0
	pos.z = oldPos.z or 0
	
	self:__oldSetPos(pos)

end

function phys:SetAngles(oldAngles)

	angles = oldAngles or Angle()
	angles.p = oldAngles.p or 0
	angles.y = oldAngles.y or 0
	angles.r = oldAngles.r or 0
	
	self:__oldSetAngles(angles)

end

function phys:SetPos(oldPos)

	pos = oldPos or Vector()
	pos.x = oldPos.x or 0
	pos.y = oldPos.y or 0
	pos.z = oldPos.z or 0
	
	self:__oldSetPos(pos)

end

/*
	Name: ApplyForce (slider) exploit
	Used by: E2 kiddos
	Reference: Thanks to CaptainPRICE (https://github.com/wiremod/wire/issues/1189) for finding the magic number
*/

local phys = FindMetaTable("PhysObj")
phys.__oldApplyForceCenter = phys.__oldApplyForceCenter or phys.ApplyForceCenter
phys.__oldApplyForceOffset = phys.__oldApplyForceOffset or phys.ApplyForceOffset

function phys:ApplyForceCenter(force)
	
	force = force or Vector()
	force.x = math.Clamp(force.x, -1e38, 1e38)
	force.y = math.Clamp(force.y, -1e38, 1e38)
	force.z = math.Clamp(force.z, -1e38, 1e38)
	
	self:__oldApplyForceCenter(force)

end

function phys:ApplyForceOffset(force, pos)

	force = force or Vector()
	force.x = math.Clamp(force.x, -1e38, 1e38)
	force.y = math.Clamp(force.y, -1e38, 1e38)
	force.z = math.Clamp(force.z, -1e38, 1e38)
	
	self:__oldApplyForceOffset(force, pos)

end

/*
	Name: DataTable console spam (not an exploit)
	-> DataTable warning: (class prop_vehicle_airboat): Out-of-range value (-0.140234) in SendPropFloat 'm_flCycle', clamping.
	-> DataTable warning: prop_physics: Out-of-range value (50.000000) in SendPropFloat 'm_flSpread', clamping.
*/

local ent = FindMetaTable("Entity")
ent.__oldSetCycle = ent.__oldSetCycle or ent.SetCycle

function ent:SetCycle(val)

	val = math.Clamp(val or 0, 0, 1)
	
	self:__oldSetCycle(val)

end

/*
	Name: Model Manipulator Flex exploit
	-> Will block everyone's screen by messing up the model meshes
*/

local ent = FindMetaTable("Entity")

// No need to keep old, disable completely
function ent:SetFlexScale() end
--addons/z_anticrash_v1.4.6/lua/z_anticrash/panels/p_stats.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local PANEL = {}
local scrW,scrH = ScrW(),ScrH()
local graphOffset = 10

function PANEL:Init(realInit, hideButtons)

	if !realInit then return end
	
	local pWide, pTall = self:GetSize()
	local graphW, graphH = pWide-(graphOffset*2), pTall*0.4
	
	-- Graph
	local graphPanel = CL_ANTICRASH.CreateGraph(graphOffset, graphOffset, graphW, graphH, self)
	
	-- Graph Information
	local infoMarginW, infoMarginH  = 10, 10
	local infoW, infoH = graphW/2-(infoMarginW/2), pTall*0.05 
	local categoryOffset = 26
	
	local lagInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, graphPanel:GetBottomY()+categoryOffset, infoW, infoH, SH_ANTICRASH.Translate("lag"), "ZLAG", false, self, true)
	local collisionInfo = CL_ANTICRASH.CreateGraphInfoLabel(lagInfo:GetRightX()+infoMarginW, graphPanel:GetBottomY()+categoryOffset, infoW, infoH, SH_ANTICRASH.Translate("collisions"), "COLLISIONS",true, self, true)
	
	local propInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, collisionInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("props"), "PROPS", true, self, true)
	local frozenInfo = CL_ANTICRASH.CreateGraphInfoLabel(propInfo:GetRightX()+infoMarginW, collisionInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("propsFrozen"), "FROZENPROPS", true, self, true)
	
	local npcInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, frozenInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("npcs"), "NPCS",true, self, true)
	local vehicleInfo = CL_ANTICRASH.CreateGraphInfoLabel(npcInfo:GetRightX()+infoMarginW, frozenInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("vehicles"), "VEHICLES", true, self, true)
	
	-- Extra Information
	local playerInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, vehicleInfo:GetBottomY()+categoryOffset, infoW, infoH, SH_ANTICRASH.Translate("players"), "PLAYERS",true, self)
	local uptimeInfo = CL_ANTICRASH.CreateGraphInfoLabel(playerInfo:GetRightX()+infoMarginW, vehicleInfo:GetBottomY()+categoryOffset, infoW, infoH, SH_ANTICRASH.Translate("uptime"), "UPTIME",true, self) 
	
	local entityInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, playerInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("entities"), "ENTITIES", true, self)
	local spawnedInfo = CL_ANTICRASH.CreateGraphInfoLabel(entityInfo:GetRightX()+infoMarginW, playerInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("spawned"), "SPAWNED", true, self)
	
	local fpsInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, entityInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("fps"), "FPS",true, self)
	local tickrateInfo = CL_ANTICRASH.CreateGraphInfoLabel(fpsInfo:GetRightX()+infoMarginW, entityInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("tickrate"), "TICKRATE", true, self)
	
	if !hideButtons then
	
		-- Open stats overlay
		CL_ANTICRASH.CreateButtonColorFade(graphOffset, pTall-categoryOffset-53, graphW, infoH, SH_ANTICRASH.Translate("toggleOverlay"), "z_anticrash_graph_btn", SH_ANTICRASH.VARS.COLOR.GREY, color_white, self, function()
			CL_ANTICRASH.PlaySound("togglePress")
			RunConsoleCommand("anticrash_overlay_open")
		end)
	
		-- Run anti-lag measures
		CL_ANTICRASH.CreateButtonColorFade(graphOffset, pTall-categoryOffset-13, graphW, infoH, SH_ANTICRASH.Translate("runAntiLagMeasures"), "z_anticrash_graph_btn", SH_ANTICRASH.VARS.COLOR.BLUE, color_white, self, function()
			CL_ANTICRASH.PlaySound("runAntiLag")
			net.Start( "sv_anticrash_TriggerAntiLagMeasures" )
			net.SendToServer()
		end)
	
	end
	
end
vgui.Register('p_anticrash_stats',PANEL,'DScrollPanel')
--addons/z_anticrash_v1.4.6/lua/z_anticrash/panels/p_users.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local PANEL = {}
local scrW,scrH = ScrW(),ScrH()
local lastOpenedUser = nil

local flagTexID = surface.GetTextureID("z_anticrash/icons/flag")
local circleTexID = surface.GetTextureID("z_anticrash/vgui/circle")


function PANEL:Init(realInit)

	if !realInit then return end

	CL_ANTICRASH.SkinScrollPanel(self)
		
	local pWide, pTall = self:GetSize()
	local filterPanels = {}
	
	// Search bar
	local searchInputBg, searchInput = CL_ANTICRASH.CreateTextInput(10, 0, pWide-20, 30, "", "z_anticrash_user_info_search", color_white, self)
	searchInput:SetPlaceholderColor(SH_ANTICRASH.VARS.COLOR.LIGHTGREY)
	searchInput:SetPlaceholderText(SH_ANTICRASH.Translate("search"))
	
	CL_ANTICRASH.HookSearchInputFilter(searchInput,filterPanels)
	
	// Player panels
	local panelOffset = 10
	local plyPanelW = pWide-(panelOffset*2)
	local plyPanelH, plyPanelHE = 30, 194
	
	local startY = searchInputBg:GetBottomY()+panelOffset
	local prevY = startY
	local prevPlyPanel = nil
	
	-- Prevent overlapping scroll items
	local _, selfY = self:GetPos()
	local selfW, selfH = self:GetSize()
	self:SetPos(0,selfY+panelOffset)
	self:SetSize(selfW,(selfH-panelOffset*2))
		
	local function AddPlayerPanel(ply)
		
		local plyPanel = vgui.Create("DPanel", self)
		local nick = ply:Nick()
		
		plyPanel.isExpanded = false
		plyPanel.prevPnl = prevPlyPanel
		plyPanel.panelOffset = panelOffset
		
		plyPanel:SetPos(panelOffset,prevY)
		plyPanel:SetSize(plyPanelW,plyPanelH)
		plyPanel.Think = function(self)
			
			if self.prevPnl then
				self:SetPos(panelOffset,self.prevPnl:GetBottomY()+panelOffset)
			else
				self:SetPos(panelOffset,startY)
			end
			
		end
		
		prevY = prevY + plyPanelH + panelOffset
		prevPlyPanel = plyPanel
		table.insert(filterPanels,{
			filterStr = nick,
			filterPanel = plyPanel
		})

		local plyBtn = vgui.Create("DButton", plyPanel)
		plyBtn:SetSize(plyPanelW,plyPanelH)
		plyBtn:SetFont("z_anticrash_graph_btn")
		plyBtn:SetText(nick)
		plyBtn:SetTextColor(color_white)
		
		local flagCol = ColorAlpha(SH_ANTICRASH.VARS.COLOR.RED,150) 
		plyBtn.Paint = function(self, w, h)
		
			-- Bg
			draw.RoundedBox(4, 0, 0, w, h, SH_ANTICRASH.VARS.COLOR.LIGHTDARK)
			
			local flagCount = ply:z_anticrashGetFlaggedCount()
			
			if IsValid(flagCount) then
				if flagCount > 0 then
				
					-- Flag icon
					local flagOffset = 7
					local flagSize = h-(flagOffset*2)
					local flagX = w-flagSize-flagOffset
					surface.SetDrawColor( flagCol )
					surface.SetTexture( flagTexID )
					surface.DrawTexturedRect( flagX, flagOffset, flagSize, flagSize )
					
					-- Flag txt
					surface.SetFont( "z_anticrash_flag_count" )
					local flagTxtW, flagTxtH = surface.GetTextSize( flagCount )
					
					surface.SetTextColor( flagCol )
					surface.SetTextPos( flagX-flagTxtW, h/2-flagTxtH/2 ) 
					surface.DrawText( flagCount )
					
					
				end
			end
			
		end
		plyBtn.DoClick = function(self)
			
			local newH = plyPanelHE
			
			if plyPanel.isExpanded then
				newH = plyPanelH
				
				-- Only reset last choice when no other active panel was opened
				if lastOpenedUser == ply then
					lastOpenedUser = nil
				end
				
			else
				lastOpenedUser = ply
			end
			
			plyPanel:SizeTo( -1, newH, 0.25 )
			plyPanel.isExpanded = !plyPanel.isExpanded
			CL_ANTICRASH.PlaySound("plyPress")
			
		end
		
		if lastOpenedUser == ply then
			plyBtn:DoClick()
		end
		
		-- Can spawn btn
		local circleSize = 20
		local canSpawnBtn = vgui.Create("DButton",plyBtn)
		canSpawnBtn:SetPos(7,5)
		canSpawnBtn:SetSize(plyPanelH,plyPanelH)
		canSpawnBtn:SetText("")
		canSpawnBtn.Paint = function(self, w, h)
		
			-- Circle bg
			surface.SetDrawColor( ColorAlpha(SH_ANTICRASH.VARS.COLOR.GREEN, 255-self.__bgAlpha) )
			surface.SetTexture( circleTexID )
			surface.DrawTexturedRect(0, 0, circleSize, circleSize)
			
			-- Circle FG
			surface.SetDrawColor( ColorAlpha(SH_ANTICRASH.VARS.COLOR.RED, self.__bgAlpha) )
			surface.SetTexture( circleTexID )
			surface.DrawTexturedRect(0, 0, circleSize, circleSize)
			
		end
		canSpawnBtn.__bgAlpha = (ply:z_anticrashGetCanSpawnGlobal() and 0) or 255
		canSpawnBtn.__nextCheckSelected = 0
		canSpawnBtn.Think = function(self, w, h)
			
			if self.__nextCheckSelected < CurTime() then
				self.isSelected = ply:z_anticrashGetCanSpawnGlobal()
			end
		
			-- alpha fade
			if self.isSelected then
				self.__bgAlpha = math.Approach(self.__bgAlpha, 0, 3)
			else
				self.__bgAlpha = math.Approach(self.__bgAlpha, 255, 3)
			end
		end
		canSpawnBtn.DoClick = function(self)
			
			CL_ANTICRASH.PlaySound("togglePress")
			
			self.__nextCheckSelected = CurTime() + 1
			self.isSelected = !self.isSelected
			
			net.Start("sv_anticrash_SetCanSpawnGlobal")
				net.WriteEntity(ply)
				net.WriteBool(self.isSelected)
			net.SendToServer()
			
		end
		
		-- Info panels
		local infoPnlOffset = 6
		local infoPnlW, infoPnlH = plyPanel:GetWide()/2 - (infoPnlOffset*1.5), 22
		
		local entInfoPanel = CL_ANTICRASH.CreateUserInfoPanel(infoPnlOffset, plyBtn:GetBottomY()+infoPnlOffset, infoPnlW, infoPnlH, SH_ANTICRASH.Translate("entities"), "ENTITIES", "GetEntityCount", ply, plyPanel)
		local spawnedEntInfoPanel = CL_ANTICRASH.CreateUserInfoPanel(entInfoPanel:GetRightX()+infoPnlOffset, plyBtn:GetBottomY()+infoPnlOffset, infoPnlW, infoPnlH, SH_ANTICRASH.Translate("spawned"), "SPAWNEDENTS", "GetSpawnedEntitiesCount", ply, plyPanel)
		
		local propInfoPanel = CL_ANTICRASH.CreateUserInfoPanel(infoPnlOffset, entInfoPanel:GetBottomY()+infoPnlOffset, infoPnlW, infoPnlH, SH_ANTICRASH.Translate("props"), "PROPS", "GetPropCount", ply, plyPanel)
		local constraintsInfoPanel = CL_ANTICRASH.CreateUserInfoPanel(propInfoPanel:GetRightX()+infoPnlOffset, entInfoPanel:GetBottomY()+infoPnlOffset, infoPnlW, infoPnlH, SH_ANTICRASH.Translate("constraints"), "CONSTRAINTS", "GetConstraintCount", ply, plyPanel)
		
		-- Entity vision button
		local buttonW, buttonH = plyPanel:GetWide() - (infoPnlOffset*2), 20
		local entVisionHasPlayer = CL_ANTICRASH.ENTVISION.HasPlayer(ply)
		
		local function entVisionBtnText()
			return entVisionHasPlayer and SH_ANTICRASH.Translate("hideEntities") or SH_ANTICRASH.Translate("showEntities")
		end
		
		local entityVisionBtn = CL_ANTICRASH.CreateColorSwitchButton(infoPnlOffset, constraintsInfoPanel:GetBottomY()+(infoPnlOffset*3), buttonW, buttonH, entVisionBtnText(), "z_anticrash_user_info_button", SH_ANTICRASH.VARS.COLOR.DARKPURPLE, SH_ANTICRASH.VARS.COLOR.CONTRASTFUCHSIA, entVisionHasPlayer, plyPanel, function(self)
			
			CL_ANTICRASH.PlaySound("togglePress")
			
			if !entVisionHasPlayer then
				CL_ANTICRASH.ENTVISION.AddPlayer(ply)
			else
				CL_ANTICRASH.ENTVISION.RemovePlayer(ply)
			end
			
			entVisionHasPlayer = !entVisionHasPlayer
			self.__isSelected = entVisionHasPlayer
			self:SetText(entVisionBtnText())
			
		end)
		
		-- Entity Control buttons
		local freezeEntsBtn = CL_ANTICRASH.CreateButtonColorFade(infoPnlOffset, entityVisionBtn:GetBottomY()+(infoPnlOffset*3), buttonW, buttonH, SH_ANTICRASH.Translate("freezeEntities"), "z_anticrash_user_info_button", SH_ANTICRASH.VARS.COLOR.SUPERDARKORGANGE, color_white, plyPanel, function()
			CL_ANTICRASH.PlaySound("gmodPress")
			net.Start("sv_anticrash_FreezeEntitiesFrom")
				net.WriteEntity(ply)
			net.SendToServer()
		end)
	
		local removeEntsBtn = CL_ANTICRASH.CreateButtonColorFade(infoPnlOffset, freezeEntsBtn:GetBottomY()+infoPnlOffset, buttonW, buttonH, SH_ANTICRASH.Translate("removeEntities"), "z_anticrash_user_info_button", SH_ANTICRASH.VARS.COLOR.DARKRED, color_white, plyPanel, function()
			CL_ANTICRASH.PlaySound("gmodPress")
			net.Start("sv_anticrash_RemoveEntitiesFrom")
				net.WriteEntity(ply)
			net.SendToServer()
		end)
		
		local userInfoDivider = constraintsInfoPanel:GetBottomY()+infoPnlOffset
		local entVisionDivider = entityVisionBtn:GetBottomY()+infoPnlOffset
		plyPanel.Paint = function(self, w, h)
		
			-- Bg
			draw.RoundedBox(4, 0, 0, w, h, SH_ANTICRASH.VARS.COLOR.DARKY)
			
			-- Divider lines
			-- local dividerW = w/2
			-- local dividerX = w/2-(dividerW/2)
			draw.RoundedBox(4, 0, userInfoDivider, w, 4, SH_ANTICRASH.VARS.COLOR.DARK)
			draw.RoundedBox(4, 0, entVisionDivider, w, 4, SH_ANTICRASH.VARS.COLOR.DARK)
			
		end
	
	end
	

	local plys = player.GetAll()
	
	-- Sort players alphabetically & by flags
	table.sort( plys, function(a, b) 
		
		local aFlags = a:z_anticrashGetFlaggedCount()
		local bFlags = b:z_anticrashGetFlaggedCount()
		
		if aFlags == bFlags then
			return a:Nick():lower() < b:Nick():lower()
		end
		
		return aFlags > bFlags
		
	end )
	
	for i=1, #plys do
		AddPlayerPanel(plys[i])
	end

end
vgui.Register('p_anticrash_users',PANEL,'DScrollPanel')
--lua/autorun/client/navmesh_merger_cl.lua:
local nextRecieve = 0
net.Receive( "navoptimizer_nag", function()
    if nextRecieve > CurTime() then return end
    nextRecieve = CurTime() + 5

    if system.HasFocus() then return end
    system.FlashWindow()

end )
--addons/wos-passiveevent-ageo/lua/wos/pes/vgui/wos_viewnodes.lua:
local PANEL = {}

local bgMaterial = Material("wos/pes/bg.png", "noclamp smooth")

local borderBlack = Color(0, 0, 0, 150)
local bgBlack = Color(36,36,36) -- annoyingly 1 rgb off when actual rendering from the png WHY SOURCE WHYYYYY
local bgLighter = Color(255,255,255,100)

local bgWhite = Color(200,200,200)

function PANEL:AddNode( id, input_data )
	self.EventID = id
	local id = #self.Nodes + 1
	local x,y = self:GetCenter()
	
    local dbutton = vgui.Create("DButton", self._background)
    dbutton.main = self

	local wide = 280 * (ScrW()/1920)
    local tall = wide*0.8

    dbutton:SetPos(x-50, y-50)
	dbutton:SetSize( wide, tall )
    dbutton.ID = id
	dbutton:SetFont( "wOS.PES.NodeText" )


	-- dbutton.Links = input_data.Links
	-- dbutton.Active = input_data.Active
	-- dbutton.Type = input_data.Type

	-- dbutton:SetPos( input_data.Pos.x, input_data.Pos.y )
	-- dbutton:SetText( "" )
	-- dbutton.TextName = input_data.Name


	dbutton.DoClick = function()
		local isActive = dbutton.Active
		if not isActive then return end
		if IsValid(nodeWatchingMenu) then
			nodeWatchingMenu:Remove()
		end

        local dummy_frame = vgui.Create( "DFrame" )
        dummy_frame:SetSize( ScrW(), ScrH() )
        dummy_frame:SetTitle( "" )
        dummy_frame:ShowCloseButton( false )
        dummy_frame:SetDraggable( false )
        dummy_frame.Paint = function( pan, ww, hh )
            draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
        end
        dummy_frame:MakePopup()

		nodeWatchingMenu = vgui.Create("DFrame")
		nodeWatchingMenu:MakePopup()
		nodeWatchingMenu:SetSize(ScrW() * 0.25, ScrH() *0.25)
		nodeWatchingMenu:Center()

		nodeWatchingMenu.Think = function()
			nodeWatchingMenu:MoveToFront()
			if !IsValid(self) or not self:GetParent():IsVisible() then 
				nodeWatchingMenu:Remove()
			end
		end

        dummy_frame.Think = function( pan ) 
            if not IsValid( nodeWatchingMenu ) then
                pan:Remove()
            end
        end

		local scroll = vgui.Create("DScrollPanel", nodeWatchingMenu)
		local bw,bh = nodeWatchingMenu:GetSize()

		scroll:SetSize(bw, bh * 0.5)
		scroll:Dock(TOP)

		local button = vgui.Create("DButton", scroll)
		button:SetText("")
		button:Dock(TOP)
		button.Paint = function(self, w, h)
			local a, b = draw.SimpleText("ACTIVATE TRIGGERS", "wOS.PES.NodeText", 5, h/2, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			if a != w and b != h then
				button:SetSize(a, b)
			end
			surface.SetDrawColor(255,255,255)
			surface.DrawLine(5, h-1, w*0.75, h-1)
		end
		
		local bg = vgui.Create("DPanel", scroll)
		bg:Dock(TOP)

		button.DoClick = function()
			if bg:GetTall() == 0 then
				bg:SizeToChildren()
			else
				bg:SetTall(0)
			end
		end

		local noTriggers = true

		if dbutton.Type then
			local nodeData = wOS.PES.Nodes:Get(dbutton.Type)
			-- if chec
			local maxTriggers = #nodeData.Triggers
		
			for index, tdata in ipairs(nodeData.Triggers) do
				
				local trigger = tdata
				local trigger_name = trigger
				if istable( tdata ) then
					trigger = tdata.Type or trigger
					trigger_name = tdata.Name or trigger_name
				end

				local but = vgui.Create("DButton", bg)
				but:SetText( trigger_name )
				but:Dock(TOP)
				but.DoClick = function()
					wOS.PES.RequestTriggerStart(self.EventID, id, trigger)
					nodeWatchingMenu:Remove()
				end
				noTriggers = false
			end
		end

		if noTriggers then
			local but = vgui.Create("DButton", bg)
			but:SetText("Instant")
			but:Dock(TOP)
			but.DoClick = function()
				wOS.PES.RequestTriggerStart(self.EventID, id, "Instant")
			end
		end

		bg:SizeToChildren()
		bg:SetTall(100)
	end

	dbutton.Links = {}

	local VGUI_NodeMeta = vgui.GetControlTable( "WOS_PES_NODE" )
	dbutton.EventViewerNode = true
	dbutton.TriggerColorHierarchy = VGUI_NodeMeta.TriggerColorHierarchy
	dbutton.GetTriggerPos = VGUI_NodeMeta.GetTriggerPos
	dbutton.Paint = VGUI_NodeMeta.Paint
	dbutton.FormLinks = self.FormLinks
	dbutton.DrawTriangleRight = VGUI_NodeMeta.DrawTriangleRight

	-- function dbutton:GetTriggerPos(triggerName)
	-- 	if self.Type then
	-- 		local nodeData = wOS.PES.Nodes:Get(self.Type)
	-- 		-- if check
	-- 		local maxTriggers = #nodeData.Triggers
	-- 		for index, trigger in ipairs(nodeData.Triggers) do
	-- 			if trigger == triggerName then
	-- 				return 50 + 16 *(index - (maxTriggers +1)/2)
	-- 			end
	-- 		end

	-- 		return false
	-- 	end

    -- 	return self:GetTall() * 0.5
	-- end

	-- function dbutton:Paint(w, h)
	-- 	if dbutton.Active then
	-- 		draw.RoundedBox(6, 0, 0, w, h, Color(0, 255, 0, 255))	    
	-- 	else
	-- 		draw.RoundedBox(6, 0, 0, w, h, Color(0, 0, 0, 255))
	-- 	end
	--     draw.RoundedBox(5, 1, 1, w-2, h-2, Color(255, 255, 255, 127))
	-- end

    self.Nodes[id] = dbutton

	return dbutton
end

function PANEL:Init()
    self.CreationType = WOS_PES.CREATOR.EVENT
	self._x = 0
	self.Nodes = {}
	self._y = 0

    self._tx = 0
    self._ty = 0

    self.Links = {}
	
	self._background = vgui.Create("DButton", self)
    self._background:SetSize(1920*4, 1920*4)
    self._background:Center()
    self._background:SetText("")
    self._background.Paint = function(sef, w, h)

		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(bgMaterial)
		surface.DrawTexturedRectUV(0,0,w,h,0,0,w,h)

        for id, pnl in pairs(self.Nodes) do
		    if !IsValid(pnl) then
                return
			end

            for triggerName, panelTable in pairs(pnl.Links) do
                for index, oid in ipairs(panelTable) do
                    local oPnl = self.Nodes[oid]
                    if !IsValid(oPnl) then
                        continue
                    end

					if not oPnl.MakeOtherLink then
						self:MakeOtherLink(triggerName, oPnl)
						oPnl.MakeOtherLink = true
					end

                    local x,y = pnl:GetPos()
                    local w,h = oPnl:GetPos()
                    local posY, id, col = pnl:GetTriggerPos(triggerName)

                    if !posY then
                        self:RemoveLink(pnl, triggerName, oPnl)
                        continue
                    end

                    h = h + oPnl:GetTall()*0.5
                    y = y + posY

                    x = x + pnl:GetWide() + pnl:GetWide()*0.04
                    col = col or color_white

                    surface.SetDrawColor( col )
                    surface.DrawLine( x, y, w, h )
                end
            end
        end
    end

    self._background.OnDepressed = function( s )
        self:StartDragging()
    end

    self._background.OnReleased = function( s )
        self:StopDragging()
    end
end

function PANEL:StopDragging()
    self.Dragging = false
end

function PANEL:StartDragging()
    self.Dragging = true

    if IsValid(self.ViewingNode) then
        self.ViewingNode:NodeClose()
        self.ViewingNode = false
    end

    local x,y = gui.MousePos()

    self.mousepos = {x = x, y = y}
end

function PANEL:OnSizeChanged(nW, nH)
    self._background:Center()
end

function PANEL:GetCenter()
    local aX = self._background:GetWide()/2 - self._x
    local aY = self._background:GetTall()/2 - self._y

    return aX, aY
end

local speed = 100

function PANEL:Think()
    if not self.Dragging then return end
	
	local x,y = gui.MousePos()
	if !self.mousepos then
		self.mousepos = {x = x, y = y}
	end
	local dX = x - self.mousepos.x
	local dY = y - self.mousepos.y

	local oldMouseY = self.mousepos.y
	self.mousepos = {x = x, y = y}

	self._tx = dX + self._x
	self._ty = dY + self._y
	local posChanged = false

	if self.tx != self._x then
		posChanged = true
		self._x = math.Approach(self._x, self._tx, FrameTime() * speed*self:GetWide())
	end

	if self.ty != self._y then
		local x,y = self._background:GetPos()

		posChanged = true
		self._y = math.Approach(self._y, self._ty, FrameTime() * speed*self:GetTall())
	end

	if posChanged then
		local aX = self:GetWide()/2 -self._background:GetWide()/2
		local aY = self:GetTall()/2 -self._background:GetTall()/2
		local x,y = self._background:GetPos()

		self._background:SetPos( aX+self._x,  aY + self._y)
	end

end

function PANEL:MakeOtherLink(name, oNode)
	local link = vgui.Create("DPanel", oNode)
	link:SetSize( oNode:GetWide()*0.08, oNode:GetWide()*0.08 )
	link:SetPos( link:GetWide()*-0.5, oNode:GetTall()*0.5 - link:GetTall()*0.5 )
	link:SetText( "" )
	link.Name = name or "Output"
	link.TriggerColor = Color( 255, 255, 255 )
	
	link.Paint = function(s, w, h)
		local wasEnabled = DisableClipping( true )            
		local col = s.TriggerColor
		if s.Hovered then col = Color(150,150,150) end
		draw.RoundedBox( h*0.3, 0, 0, w, h, col )
		DisableClipping( wasEnabled )
	end
end

function PANEL:FormLinks()

    local function makeLink( name, trigger_label, trigger_description )
        local link = vgui.Create("DPanel", self)

        local t_pos, id, trigcol = self:GetTriggerPos( name )
        id = id or 1
        link.TriggerColor = trigcol or self.TriggerColorHierarchy[id]
        link:SetSize( self:GetWide()*0.08, self:GetWide()*0.08 )
        link:SetPos( self:GetWide() - link:GetWide()*0.5, t_pos - link:GetTall()*0.5 )
        link:SetText( "" )

        link.NLabel = trigger_label or name
        link.NDescription = desc or ""
        link.Name = name or "Output"

        link:SetToolTip(name)
        link.Paint = function(s, w, h)
            local col = s.TriggerColor
            local wasEnabled = DisableClipping( true )
            self:DrawTriangleRight( w*0.5, h*0.5, w, h, col )
            draw.SimpleText( s.NLabel, "DermaDefaultBold", w*-0.2, h/2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

            DisableClipping( wasEnabled )
        end
    end

	-- for triggerName, panelTable in pairs(pnl.Links) do
	-- 	for index, oid in ipairs(panelTable) do
	-- 		local oPnl = self.Nodes[oid]
	-- 		if !IsValid(oPnl) then
	-- 			continue
	-- 		end

	-- 		local x,y = pnl:GetPos()
	-- 		local w,h = oPnl:GetPos()
	-- 		local posY, id, col = pnl:GetTriggerPos(triggerName)

	-- 		if !posY then
	-- 			self:RemoveLink(pnl, triggerName, oPnl)
	-- 			continue
	-- 		end

	-- 		h = h + oPnl:GetTall()*0.5
	-- 		y = y + posY

	-- 		x = x + pnl:GetWide() + pnl:GetWide()*0.04
	-- 		col = col or color_white

	-- 		surface.SetDrawColor( col )
	-- 		surface.DrawLine( x, y, w, h )
	-- 	end
	-- end

	-- 	if dbutton.Type then
	-- 		local nodeData = wOS.PES.Nodes:Get(dbutton.Type)
	-- 		-- if chec
	-- 		local maxTriggers = #nodeData.Triggers
		
	-- 		for index, tdata in ipairs(nodeData.Triggers) do
				
	-- 			local trigger = tdata
	-- 			local trigger_name = trigger
	-- 			if istable( tdata ) then
	-- 				trigger = tdata.Type or trigger
	-- 				trigger_name = tdata.Name or trigger_name
	-- 			end

	-- 			local but = vgui.Create("DButton", bg)
	-- 			but:SetText( trigger_name )
	-- 			but:Dock(TOP)
	-- 			but.DoClick = function()
	-- 				wOS.PES.RequestTriggerStart(self.EventID, id, trigger)
	-- 				nodeWatchingMenu:Remove()
	-- 			end
	-- 			noTriggers = false
	-- 		end
	-- 	end

    local nodeLinks = self.Links

    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        if nodeData and nodeData.Triggers then
            for index, tdata in ipairs(nodeData.Triggers) do
                
                local name = tdata
                local trigger_label = name
                local trigger_description = "This will fire when this condition is met"
                if istable( tdata ) then
                    name = tdata.Type or name
                    trigger_label = tdata.Name or trigger_label
                    trigger_description = tdata.Description or trigger_description
                end
                makeLink(name, trigger_label, trigger_description )
            end
            return
        end
    end

    makeLink("Instant")
end

vgui.Register( "WOS_PES_ViewNodeBG", PANEL, "Panel" )
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/entity.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "Entity"
VAR.DirtyValidate = true
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Select the entity to be saved", key = "gui/lmb.png", },
}

VAR.IsValid = function(varTable, value)
    -- TODO


    if #varTable == 0 then
        return false
    end


    return true
end

VAR.DermaElement = function(varTable, varData)
    if !varData then varData = {} end
    local element = vgui.Create("DModelPanel")

    return element -- make multiple of these through a base panel
end

VAR.GetValue = function(dermaElement)
    if dermaElement.Data then
        local ent = dermaElement.Data
        --if IsValid(ent) then dermaElement:SetEntity(ent) end
        return dermaElement.Data
    end
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data

    local ent = ply:GetEyeTrace().Entity
    if IsValid(ent) then
        local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, ent:GetPos() )
        if isbool( allowed ) and allowed == false then return end
        dermaElement.Data = {
            Model = ent:GetModel(),
            Position = ent:GetPos(),
            Angle = ent:GetAngles(),
            Class = ent:GetClass(),
            // read var data
            // read bodygroup
            // read pose
        }
    end
end
 
VAR.OnStart = function(node, varData, var)
    if varData != {} then return end
    local entData = varData

    local ent = wOS.PES:SpawnEntity(entData)
    
    if not ent then return end 

    if not istable( ent ) then
        node:SetVar(var.Name, ent)
        return
    end

    -- // This enforces the first entry without having to hunt for it
    -- for _, entity in pairs( ent ) do
    --     node:SetVar( var.Name, entity )
    --     return
    -- end

end

VAR.OnEnd = function(node, varData, var)
    if not node:ShouldCleanAll() then return end
    if IsValid(varData) then
        varData:Remove()
    end
end

VAR.Draw3D = function(wep, ply, element)
    local ent = element.Values
    if ent then
        if not isvector(ent.Position) then return end

        local vec = ent.Position

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/tentitydatacopy.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "TableEntityData"
VAR.DirtyValidate = true

VAR.ToolTips = {
    { text = "Add the entity data of the entity you are aiming at to the list", key = "gui/lmb.png", },
    { text = "Remove the last added entity data from the list", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)

    if varTable.Internal then return false end
    if not value or #value < 1 then
        return false
    end
    
    for index, data in pairs(value) do
        if not data.Index then continue end
        local ent = ents.GetByIndex(data.Index)
        if IsValid(ent) then
            if ent:CreatedByMap() then continue end
            value[index] = wOS.PES.ReadEntity(ent)
        end
    end

    return true
end

VAR.UseTool = true

local function OpenOverlayEditor( id, vardata, base_panel )
    local panel = vgui.Create("DPanel")
    panel:SetSize( ScrW(), ScrH() )
    panel.Think = function( pan ) if not IsValid( base_panel ) then pan:Remove() end end
    panel.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    panel:MakePopup()

    local frame = vgui.Create( "DFrame", panel )
    frame:ShowCloseButton( true )
    frame:SetTitle("")
    frame:SetDraggable( false )
    frame:SetSize( ScrW()*0.25, ScrH()*0.4 )
    frame:Center()
    frame.OnClose = function( pan )
        panel:Remove()
    end
	frame.Think = function( pan )
		pan:MoveToFront()
	end
 
    local editor = vgui.Create( "WOS_PES_DATACOPY_EDITOR", frame )
    editor:Dock( FILL )
    editor:SetVariableData( vardata )
    editor:SetBasePanel( base_panel )

    local delete_butt = vgui.Create( "DButton", frame )
    delete_butt:SetText( "Delete Entity" )
    delete_butt:Dock( BOTTOM )
    delete_butt.DoClick = function( pan )
        base_panel.Data[ id ] = nil
        base_panel:RefreshList()
        panel:Remove()
    end

    local save_butt = vgui.Create( "DButton", frame )
    save_butt:SetText( "Save Changes" )
    save_butt:Dock( BOTTOM )
    save_butt.DoClick = function( pan )
        base_panel.Data[ id ] = editor:GetVariableData()
        base_panel:RefreshList()
        panel:Remove()
    end

end

VAR.DermaElement = function(varTable, varData)
    varData = varData or {}
    local panel = vgui.Create("DPanel")
    panel:SetTall( 180 )
    
    panel.Data = {}
    for index, data in pairs( varData ) do
        panel.Data[ index ] = data
    end

    local listView = vgui.Create("DListView", panel)
    listView:Dock( FILL )
    listView:AddColumn("Entity")
    listView.RefreshList = function( pan )
        pan:Clear()
        if not panel.Data or #panel.Data < 1 then
            pan:AddLine( "Entities needs to be selected!" )
            return
        end

        for id, edata in pairs( panel.Data or {} ) do
            local name = edata.Class or ( "Entity " .. edata.Index )
            local line = pan:AddLine( name )
            line.ID = id
            line.Data = edata
        end
        
    end

    listView.OnRowRightClick = function( pan, id, line )
       OpenOverlayEditor( line.ID, line.Data, panel )
    end

    listView:RefreshList()
    panel.RefreshList = function() listView:RefreshList() end

    return panel -- make multiple of these through a base panel
end

VAR.GetValue = function(dermaElement)
    if dermaElement.Data then
        //local ent = dermaElement.Data[1]
        --if IsValid(ent) then dermaElement:SetEntity(ent) end
        return dermaElement.Data
    end
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}

    local ent = ply:GetEyeTrace().Entity
    if IsValid(ent) then
        local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, ent:GetPos() )
        if isbool( allowed ) and allowed == false then return end
        dermaElement.Data[#dermaElement.Data + 1] = {
            Position = ent:GetPos(),
            Index = ent:EntIndex()
        }
        ply:ChatPrint( "Entity Added: " .. ent:GetClass() )
        dermaElement:RefreshList()
    end
end

VAR.SecondaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data || {}
    dermaElement.Data[#dermaElement.Data] = nil
end

/*
		Angles	=	-0.125 104.219 0.125
		Class	=	prop_physics
		Color:
				a	=	255
				b	=	255
				g	=	255
				r	=	255
		Model	=	models/props_borealis/bluebarrel001.mdl
		Pos	=	-3299.468750 -2135.687500 90.125000
		SubMaterials:
*/

VAR.Draw3D = function(wep, ply, element)
    local tVec = element.Data || {}

    for index, ent in ipairs(tVec) do
        if not isvector(ent.Position) then continue end

        local vec = ent.Position

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/core/sh_settings.lua:
// Might want to spilt files up

wOS.PES.Settings = wOS.PES.Settings or {}

wOS.PES.Settings.List = wOS.PES.Settings.List or {}

function wOS.PES.Settings.GetList()
	return wOS.PES.Settings.List
end

function wOS.PES.Settings.Register(tbl)
	wOS.PES.Settings.List[tbl.Name] = tbl
end

wOS.PES.Settings.Register({
	Name = "Random Events Run",
	Description = "",
	Type = "Boolean",
	Default = true,
})

wOS.PES.Settings.Values = wOS.PES.Settings.Values  or {}


function wOS.PES.Settings.Get(varName, fallback)
	if wOS.PES.Settings.Values[varName] != nil then
		return wOS.PES.Settings.Values[varName]
	elseif wOS.PES.Settings.List[varName] then
		return wOS.PES.Settings.List[varName].Default
	end

	return fallback
end


if SERVER then

	hook.Call( "wOS.PES.PostLoaded", "Settings.Sync", function()
		// For the players that missed the auth request

		if file.Exists("wos/pes/settings.json") then
			local json = file.Read("wos/pes/settings.json")

			local tbl = util.JSONToTable(json)
			if tbl then
				wOS.PES.Settings.Values = tbl
			end
		end
		local func = hook.GetTable()["PlayerAuthed"]["wOS.PES.Settings.Sync"]
		for index, ply in ipairs(player.GetAll()) do
			func(ply)
		end
	end )

	util.AddNetworkString("wOS.PES.Sync.Setting")
	util.AddNetworkString("wOS.PES.Sync.Settings")

	function wOS.PES.Settings.Set(varName, value, ply)
		wOS.PES.Settings.Values[varName] = value

		net.Start("wOS.PES.Sync.Setting")
			net.WriteString(varName)
			net.WriteType(value)
		net.Broadcast()

		//hook.Call("wOS.PES.SettingSet" .. varName, nil, varName, value, ply)
		
		timer.Create("wOS.PES.Settings.Save", 0, 1,  function()
			local json = util.TableToJSON(wOS.PES.Settings.Values)
			file.Write("wos/pes/settings.json", json)
		end)
	end

	hook.Add("PlayerAuthed", "wOS.PES.Settings.Sync", function(ply)
		timer.Simple(5, function()
			net.Start("wOS.PES.Sync.Settings")
				local count = table.Count(wOS.PES.Settings.Values)

				net.WriteUInt(count, 8)

				local keyTbl = table.GetKeys(wOS.PES.Settings.Values)
				for x = 1, count do
					net.WriteString(keyTbl[x])
					net.WriteType(wOS.PES.Settings.Values[ keyTbl[x] ])
				end
			net.Send(ply)
		end)
	end)
else
	net.Receive("wOS.PES.Sync.Settings", function()
		local count = net.ReadUInt(8)

		local settings = {}
		for x = 1, count do
			settings[net.ReadString()] = net.ReadType()
		end
	end)

	net.Receive("wOS.PES.Sync.Setting", function()
		wOS.PES.Settings.Values[net.ReadString()] = net.ReadType()
	end)
end

function wOS.PES:SelectableMaps()
	return wOS.PES.Modules:Get("map").Maps
end

function wOS.PES:SelectableNextBots()
    local npcs = {}

    for k, v in pairs(AOCRPNextbots.Config.Tool) do
        table.insert(npcs, v.name)
    end

    return npcs
end

function wOS.PES:SpawnableWeapons()
	// Default the HL2 weapons
	local dummy_tbl = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["weapon_crowbar"] = true,
		["weapon_pistol"] = true,
		["weapon_357"] = true,
		["weapon_smg1"] = true,
		["weapon_ar2"] = true,
		["weapon_shotgun"] = true,
		["weapon_crossbow"] = true,
		["weapon_frag"] = true,
		["weapon_rpg"] = true,
		["weapon_bugbait"] = true,
	}
	// Get only real, spawnable weapons
	for _, weapon in pairs(weapons.GetList()) do
		if !weapon.Spawnable then continue end
		dummy_tbl[ weapon.ClassName ] = true
	end

	// Relooping ensures it's in alphabetical order
	local tbl = {}
	for weapon, _ in SortedPairs( dummy_tbl ) do
		table.insert( tbl, weapon )
	end

	return tbl
end
--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_pes_basicobj/cl_wos_pes_basicobj.lua:
local ENT = {}

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.RenderGroup = RENDERGROUP_BOTH

ENT.PrintName		= "Generic Objective"
ENT.Author			= "wiltOS Technologies"
ENT.Contact			= "N/A"
ENT.Purpose			= "PES B"
ENT.Instructions	= "Grab and run"
ENT.Spawnable = false

function ENT:SetupDataTables()
    self:NetworkVar( "Entity", 0, "TargetPlayer" )
    self:NetworkVar( "String", 0, "FlagName" )

    if SERVER then
        self:SetTargetPlayer( NULL )
        self:SetFlagName( "Flag" )
    end
end

function ENT:Initialize()
	self:SetRenderBounds( vector_origin, vector_origin, Vector( 100, 100, 100 ) )
	self.HookName = "wOS.PES.FlagHalo." .. self:EntIndex()
	hook.Add("PreDrawHalos", self.HookName, function()
		if not IsValid( self ) then 
			hook.Remove( "PreDrawHalos", self.HookName )
			return
		end
		if !IsValid( self:GetTargetPlayer() ) then return end
		halo.Add( {self:GetTargetPlayer()}, Color( 255, 0, 0 ), 5, 5, 1 )
	end)

end

function ENT:OnRemove()
	hook.Remove( "PreDrawHalos", self.HookName )
end

function ENT:Draw()

	if IsValid(self:GetTargetPlayer()) then return end
	self:DrawModel()

end

function ENT:DrawTranslucent()
	if IsValid(self:GetTargetPlayer()) then return end

	local ang = EyeAngles()
	ang.p = 90
	ang.y = ang.y + 180
	ang.r = 0
	ang:RotateAroundAxis( ang:Up(), 90 )

	local mins, maxs = self:OBBMins(), self:OBBMaxs()
	local diff = maxs.z - mins.z

	cam.Start3D2D( self:GetPos() + self:GetUp()*diff*1.2, ang, 0.1 )
		draw.SimpleText( self:GetFlagName(), "wOS.PES.3DFont", 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	cam.End3D2D()
end

scripted_ents.Register(ENT, "wos_pes_basicobj")
--addons/billy_gas/lua/vgui/bvgui/frame.lua:
bVGUI.Frames = {}

local voice_enum
local voice_key
local function GetVoiceKeyEnum()
	voice_key = input.LookupBinding("+voicerecord", true)
	if (voice_key) then
		for i,v in pairs(_G) do
			if (i:sub(1,4) == "KEY_") then
				if (input.GetKeyName(v) == voice_key) then
					voice_enum = v
					break
				end
			end
		end
	end
end
GetVoiceKeyEnum()
timer.Create("bVGUI.voicerecord_bind", 10, 0, function()
	if (voice_key ~= input.LookupBinding("+voicerecord", true)) then
		GetVoiceKeyEnum()
	end
end)

local PANEL = {}

function PANEL:OnKeyCodePressed(key_code)
	if (GAS and GAS.LocalConfig and GAS.LocalConfig.AllowVoiceChat == false) then return end
	if (voice_enum and key_code == voice_enum) then
		if (permissions and permissions.EnableVoiceChat) then
			permissions.EnableVoiceChat(true)
		else
			RunConsoleCommand("+voicerecord")
		end
	end
end
function PANEL:OnKeyCodeReleased(key_code)
	if (GAS and GAS.LocalConfig and GAS.LocalConfig.AllowVoiceChat == false) then return end
	if (voice_enum and key_code == voice_enum) then
		if (permissions and permissions.EnableVoiceChat) then
			permissions.EnableVoiceChat(false)
		else
			RunConsoleCommand("-voicerecord")
		end
	end
end

function PANEL:Init()
	table.insert(bVGUI.Frames, self)

	local this = self

	self:DockPadding(0, 24, 0, 0)
	self.lblTitle:SetVisible(false)
	self.btnClose:SetVisible(false)
	self.btnMaxim:SetVisible(false)
	self.btnMinim:SetVisible(false)

	self.ColorCycling = {}
	self.ColorCycling.IntendedColor = table.Copy(bVGUI.COLOR_GMOD_BLUE)
	self.ColorCycling.CurrentColor = table.Copy(bVGUI.COLOR_GMOD_BLUE)

	self.bVGUI_Toolbar = vgui.Create("DPanel", self)
	self.bVGUI_Toolbar:SetTall(24)
	self.bVGUI_Toolbar:SetCursor("sizeall")
	function self.bVGUI_Toolbar:OnMousePressed()
		if (this.Fullscreened ~= false or this:GetDraggable() == false) then return end
		this.Dragging = { gui.MouseX() - this.x, gui.MouseY() - this.y }
	end
	function self.bVGUI_Toolbar:OnMouseReleased()
		this.Dragging = nil
	end
	function self.bVGUI_Toolbar:Paint(w,h)
		surface.SetDrawColor(this.ColorCycling.CurrentColor)
		surface.DrawRect(0,0,w,h)

		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
		surface.DrawTexturedRect(0,0,w,h)
	end
	function self.bVGUI_Toolbar:PaintOver(w,h)
		if (this.DrawBorder ~= false) then
			surface.SetDrawColor(bVGUI.COLOR_BLACK)
			surface.DrawLine(0,h - 1,w,h - 1)
		end
	end

	self.MenuOpen = false
	self.bVGUI_MenuButton = vgui.Create("bVGUI.ToolbarButton_IMGText", self.bVGUI_Toolbar)
	self.bVGUI_MenuButton:Dock(LEFT)
	self.bVGUI_MenuButton:SetMaterial(bVGUI.ICON_MENU)
	self.bVGUI_MenuButton:SetHoverMaterial(bVGUI.ICON_MENU_INVERTED)
	self.bVGUI_MenuButton:SetText(self:GetTitle())
	self.bVGUI_MenuButton.bVGUI_Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 14))
	function self.bVGUI_MenuButton:DoClick()
		if (GAS and GAS.PlaySound) then GAS:PlaySound("btn_light") end
		if (this.MenuClicked) then
			this:MenuClicked()
		elseif (not IsValid(this.DermaMenu) and this.DermaMenuOptions) then
			this.DermaMenu = DermaMenu()
			this:DermaMenuOptions(this.DermaMenu)
			this.DermaMenu:Open(self:LocalToScreen(0,self:GetTall() - 1))
			function this.DermaMenu:OptionSelected()
				this.DermaMenu = nil
			end
		elseif (IsValid(this.DermaMenu)) then
			this.DermaMenu:Hide()
			this.DermaMenu:Remove()
			this.DermaMenu = nil
		elseif (this.DermaMenu ~= nil) then
			this.DermaMenu = nil
		end
	end

	self.bVGUI_CloseButton = vgui.Create("bVGUI.ToolbarButton_IMG", self.bVGUI_Toolbar)
	self.bVGUI_CloseButton:SetSize(20,24)
	self.bVGUI_CloseButton:Dock(RIGHT)
	self.bVGUI_CloseButton:SetMaterial(bVGUI.ICON_CLOSE)
	self.bVGUI_CloseButton:SetHoverMaterial(bVGUI.ICON_CLOSE_INVERTED)
	function self.bVGUI_CloseButton:DoClick()
		if (GAS and GAS.PlaySound) then GAS:PlaySound("btn_heavy") end
		this:Close()
	end

	self.Fullscreened = false
	self.bVGUI_FullscreenButton = vgui.Create("bVGUI.ToolbarButton_IMG", self.bVGUI_Toolbar)
	self.bVGUI_FullscreenButton:SetSize(24,24)
	self.bVGUI_FullscreenButton:Dock(RIGHT)
	self.bVGUI_FullscreenButton:SetMaterial(bVGUI.ICON_FULLSCREEN)
	self.bVGUI_FullscreenButton:SetHoverMaterial(bVGUI.ICON_FULLSCREEN_INVERTED)

	function self.bVGUI_FullscreenButton:DoClick()
		if (this.Fullscreened == false) then
			if (GAS and GAS.PlaySound) then GAS:PlaySound("jump") end

			this.Fullscreened = {this:GetWide(), this:GetTall()}
			this.bVGUI_Toolbar:SetCursor("arrow")

			this:Stop()
			this:SizeTo(ScrW() - (self.OffsetX or 0), ScrH(), 0.5, 0, 0.5)
			this:MoveTo(self.OffsetX or 0, 0, 0.5, 0, 0.5)
		else
			if (GAS and GAS.PlaySound) then GAS:PlaySound("delete") end

			this:Stop()
			this:MoveTo((ScrW() / 2) - (this.Fullscreened[1] / 2), (ScrH() / 2) - (this.Fullscreened[2] / 2), 0.5, 0, 0.5)
			this:SizeTo(this.Fullscreened[1], this.Fullscreened[2], 0.5, 0, 0.5)

			this.Fullscreened = false
			this.bVGUI_Toolbar:SetCursor("sizeall")
		end
		timer.Simple(0.5, function()
			if (IsValid(this)) then
				this:InvalidateLayout(true)
				local function recursive(children)
					for _,child in ipairs(children) do
						if (child.RerenderMarkups) then
							child:RerenderMarkups()
						end
						recursive(child:GetChildren())
					end
				end
				recursive(this:GetChildren())
			end
		end)
	end

	self.Pinned = false
	self.bVGUI_PinButton = vgui.Create("bVGUI.ToolbarButton_IMG", self.bVGUI_Toolbar)
	self.bVGUI_PinButton:SetSize(24,24)
	self.bVGUI_PinButton:Dock(RIGHT)
	self.bVGUI_PinButton:SetMaterial(bVGUI.ICON_PIN)
	self.bVGUI_PinButton:SetHoverMaterial(bVGUI.ICON_PIN_INVERTED)

	function self.bVGUI_PinButton:DoClick()
		self:TogglePin()
		if (GAS and GAS.PlaySound) then
			if (this.Pinned) then
				GAS:PlaySound("drip_up")
			else
				GAS:PlaySound("drip_down")
			end
		end
	end
	function self.bVGUI_PinButton:TogglePin()
		this.Pinned = not this.Pinned
		if (this.Pinned) then
			this:KillFocus()
			this:SetMouseInputEnabled(false)
			this:SetKeyboardInputEnabled(false)
			this:SetAlpha(200)

			gui.HideGameUI()
			timer.Simple(0, function()

				this.pin_overlay = vgui.Create("DPanel")
				this.pin_overlay:SetCursor("hand")
				this.pin_overlay:SetMouseInputEnabled(true)
				function this.pin_overlay:Paint(w,h)
					if (not IsValid(this)) then
						self:Remove()
						return
					end
					self:SetSize(this:GetSize())
					self:SetPos(this:GetPos())
					if (gui.IsGameUIVisible()) then
						bVGUI_GlobalPinned = nil
						for _,v in ipairs(bVGUI.Frames) do
							if (v.Pinned and IsValid(v.bVGUI_PinButton) and v.bVGUI_PinButton:IsVisible()) then
								v.bVGUI_PinButton:TogglePin()
							end
						end
					end
				end
				function this.pin_overlay:OnMouseReleased(m)
					self:Remove()
					this.bVGUI_PinButton:DoClick()

					for _,v in ipairs(bVGUI.Frames) do
						if (v ~= this and v.Pinned and IsValid(v.bVGUI_PinButton) and v.bVGUI_PinButton:IsVisible()) then
							v.bVGUI_PinButton:TogglePin()
						end
					end
				end

			end)

			for _,v in ipairs(bVGUI.Frames) do
				if (v ~= this and not v.Pinned and IsValid(v.bVGUI_PinButton) and v.bVGUI_PinButton:IsVisible()) then
					v.bVGUI_PinButton:TogglePin()
				end
			end
		else
			if (IsValid(this.pin_overlay)) then
				this.pin_overlay:Remove()
			end
			this:MakePopup()
			this:SetAlpha(255)
		end

		gui.EnableScreenClicker(false)

		if (this.Pinned) then
			if (not bVGUI_GlobalPinned) then
				bVGUI_GlobalPinned = true
				notification.AddLegacy(bVGUI.L("pin_tip"), NOTIFY_UNDO, 3)
			end
		else
			bVGUI_GlobalPinned = nil
		end

		if (this.Pinned and this.OnPinned) then
			this:OnPinned()
		elseif (not this.Pinned and this.OnUnpinned) then
			this:OnUnpinned()
		end
	end

	function self:OnChildAdded(child)
		child.IsDefaultChild = false
	end
end

function PANEL:OnClose()
	if (self.CloseFrames) then
		for v in pairs(self.CloseFrames) do
			if (IsValid(v)) then v:Close() end
		end
	end
	if (self.ClosePanels) then
		for v in pairs(self.ClosePanels) do
			if (IsValid(v)) then v:Remove() end
		end
	end
end

function PANEL:OnResize(w, h)

end

local drag_icon = Material("vgui/bvgui/drag.png", "smooth")
function PANEL:EnableUserResize()
	local this = self
	self.UserResize = vgui.Create("bVGUI.BlankPanel", self)
	self.UserResize:SetMouseInputEnabled(true)
	self.UserResize:SetCursor("sizenwse")
	self.UserResize:SetSize(18,18)
	self.UserResize:MoveToFront()
	function self.UserResize:OnMousePressed(m)
		self.Dragging = true
	end
	function self.UserResize:Think()
		if (self.Dragging == true) then
			if (input.IsMouseDown(MOUSE_LEFT)) then
				local x,y = gui.MousePos()
				if (not self.StartingCoords) then
					self.StartingCoords = {x,y}
				end
				if (not self.StartingSize) then
					self.StartingSize = {this:GetSize()}
				end

				local new_x, new_y = self.StartingSize[1] + (x - self.StartingCoords[1]), self.StartingSize[2] + (y - self.StartingCoords[2])
				this:OnResize(new_x, new_y)
				this:SetSize(math.max(new_x, this:GetMinWidth()), math.max(new_y, this:GetMinHeight()))
				this:InvalidateChildren(true)
			else
				self.StartingCoords = nil
				self.StartingSize = nil
				self.Dragging = false

				local function recursive(children)
					for _,child in ipairs(children) do
						if (child.RerenderMarkups) then
							child:RerenderMarkups()
						end
						recursive(child:GetChildren())
					end
				end
				recursive(this:GetChildren())
			end
		end
	end
	function self.UserResize:Paint(w,h)
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(drag_icon)
		local width,height = 12,12
		surface.DrawTexturedRect(w / 2 - width / 2, h / 2 - height / 2, width, height)
	end
end

function PANEL:ShowCloseButton(showclosebutton)
	self.bVGUI_CloseButton:SetVisible(showclosebutton)
end

function PANEL:ShowFullscreenButton(showfullscreenbutton)
	self.bVGUI_FullscreenButton:SetVisible(showfullscreenbutton)
end

function PANEL:ShowPinButton(showpinbutton)
	self.bVGUI_PinButton:SetVisible(showpinbutton)
end

function PANEL:SetDraggable(draggable)
	self.m_bDraggable = draggable
	if (draggable) then
		self.bVGUI_Toolbar:SetCursor("sizeall")
	else
		self.bVGUI_Toolbar:SetCursor("default")
	end
end

function PANEL:PaintOver(w,h)
	if (self.DrawBorder ~= false) then
		surface.SetDrawColor(bVGUI.COLOR_BLACK)
		surface.DrawOutlinedRect(0,0,w,h)
	end
end

function PANEL:PerformLayout(w, h)
	self.bVGUI_Toolbar:SetWide(self:GetWide())
	for _,v in pairs(self:GetChildren()) do
		v:InvalidateLayout(true)
	end
	if (IsValid(self.UserResize)) then
		self.UserResize:AlignRight(0)
		self.UserResize:AlignBottom(0)
	end
	if (self.PostPerformLayout) then
		self:PostPerformLayout(w, h)
	end
end

function PANEL:SetTitle(title)
	self.lblTitle:SetText(title)
	self.bVGUI_MenuButton:SetText(title)
end

local frame_bg = Color(30,34,42,250)
local blur = Material("pp/blurscreen")
function PANEL:Paint(w,h)
	if (self.DrawBlur == true) then
		local x,y = self:LocalToScreen(0,0)
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(blur)
		for i = -0.2, 2, 0.2 do
			blur:SetFloat("$blur", i * 1.0)
			blur:Recompute()
			render.UpdateScreenEffectTexture()
			surface.DrawTexturedRect(-x,-y,ScrW(),ScrH())
		end

		surface.SetDrawColor(frame_bg)
		surface.DrawRect(0,0,w,h)
	else
		surface.SetDrawColor(30,34,42,253)
		surface.DrawRect(0,0,w,h)

		surface.SetDrawColor(255,255,255,210)
		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LARGE)
		surface.DrawTexturedRect(0,0,w,h)
	end

	local r = Lerp(0.01, self.ColorCycling.CurrentColor.r, self.ColorCycling.IntendedColor.r)
	local g = Lerp(0.01, self.ColorCycling.CurrentColor.g, self.ColorCycling.IntendedColor.g)
	local b = Lerp(0.01, self.ColorCycling.CurrentColor.b, self.ColorCycling.IntendedColor.b)
	if (self.ColorCycling.r_ceil) then r = bVGUI.CEIL(r) else r = bVGUI.FLOOR(r) end
	if (self.ColorCycling.g_ceil) then g = bVGUI.CEIL(g) else g = bVGUI.FLOOR(g) end
	if (self.ColorCycling.b_ceil) then b = bVGUI.CEIL(b) else b = bVGUI.FLOOR(b) end
	self.ColorCycling.CurrentColor.r = r
	self.ColorCycling.CurrentColor.g = g
	self.ColorCycling.CurrentColor.b = b
end
function PANEL:CycleColors(col)
	self.ColorCycling.r_ceil = col.r > self.ColorCycling.IntendedColor.r
	self.ColorCycling.g_ceil = col.g > self.ColorCycling.IntendedColor.g
	self.ColorCycling.b_ceil = col.b > self.ColorCycling.IntendedColor.b
	self.ColorCycling.IntendedColor = table.Copy(col)
end

derma.DefineControl("bVGUI.Frame", nil, PANEL, "DFrame")
--addons/billy_gas/lua/vgui/bvgui/header.lua:
local PANEL = {}

function PANEL:Init()
	self:SetTall(24)
	self:DockPadding(5,5,5,5)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetTextColor(bVGUI.COLOR_BLACK)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 14))
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)

	self:SetText("Header")
	self:SetColor(bVGUI.COLOR_GMOD_BLUE)
end

function PANEL:SetText(text)
	self.Text = text
	self.Label:SetText(self.Text)
end
function PANEL:SetColor(color)
	self.Color = color
	self.Label:SetTextColor(bVGUI.TextColorContrast(color))
end

function PANEL:SetIcon(icon)
	if (icon == false) then
		if (IsValid(self.IconLeft)) then
			self.IconLeft:Remove()
		end
		if (IsValid(self.IconRight)) then
			self.IconRight:Remove()
		end
	else
		if (IsValid(self.IconLeft)) then
			self.IconLeft:SetImage(icon)
		else
			self.IconLeft = vgui.Create("DImage", self)
			self.IconLeft:SetSize(16,16)
			self.IconLeft:SetImage(icon)
		end

		if (IsValid(self.IconRight)) then
			self.IconRight:SetImage(icon)
		else
			self.IconRight = vgui.Create("DImage", self)
			self.IconRight:SetSize(16,16)
			self.IconRight:SetImage(icon)
		end
	end
end

function PANEL:PerformLayout()
	if (IsValid(self.IconLeft)) then
		self.IconLeft:AlignLeft(5)
		self.IconLeft:CenterVertical()
	end
	if (IsValid(self.IconRight)) then
		self.IconRight:AlignRight(5)
		self.IconRight:CenterVertical()
	end
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(self.Color)
	surface.DrawRect(0,0,w,h)

	surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
	surface.DrawTexturedRect(0,0,w,h)
end
function PANEL:PaintOver(w,h)
	surface.SetDrawColor(0,0,0,200)
	surface.DrawRect(0,h - 1,w,1)
end

derma.DefineControl("bVGUI.Header", nil, PANEL, "DPanel")
--addons/billy_gas/lua/vgui/bvgui/permissions_selector.lua:
local PANEL = {}

function PANEL:Init()
	self.Rows = {}
	self.Headers = {}
	self.Categories = {}
	self.Permissions = {}
end

function PANEL:NormalCheckboxes()
	self.UseNormalCheckboxes = true
end

function PANEL:Clear()
	for i,v in ipairs(table.Merge(self.Rows, self.Headers)) do
		v:Remove()
	end
	self.Rows = {}
	self.Headers = {}
	self.Categories = {}
	self.Permissions = {}
	self:InvalidateLayout(true)
end

function PANEL:AddPermission(permission)
	table.insert(self.Permissions, permission)
end

function PANEL:AddHeader(header_text, header_col)
	local header = vgui.Create("bVGUI.Header", self)
	header.HeaderIndex = table.insert(self.Headers, header)
	header:Dock(TOP)
	header:SetText(header_text)
	header:SetColor(header_col)
end

function PANEL:AddPermissionGroup(header_text, header_col, rows, header_val)
	self:AddHeader(header_text, header_col)

	self.Categories[header_val or header_text] = {}

	for _,v in ipairs(rows) do
		local row = vgui.Create("bVGUI.PermissionsSelector_Row", self)
		row.RowIndex = table.insert(self.Rows, row)
		row.CategoryIndex = table.insert(self.Categories[header_val or header_text], row)
		row.Category = header_val or header_text
		row:Dock(TOP)
		row:SetText(v.text)
		row:SetTextColor(v.text_col)
		row:SetControlsAll(v.controls_all or false)
		row.PermissionValue = v.value
		if (v.checked) then
			row:SetChecks(v.checked)
		end
	end
end

function PANEL:AddSuperGroup(text, text_col)
	local row = vgui.Create("bVGUI.PermissionsSelector_Row", self)
	row.RowIndex = table.insert(self.Rows, row)
	row:Dock(TOP)
	row:SetText(text)
	row:SetTextColor(text_col)
	row:SetSuperGroup(true)
	self.SuperGroupRow = row
end

function PANEL:AddRow(header_val, v, header_text)
	local i = 0
	local last_row
	local found = false
	for row_i, row in pairs(self.Rows) do
		i = i + 1
		if (row.Category == (header_val or header_text)) then
			last_row = row
			found = true
		elseif (found) then
			break
		end
	end
	local row = vgui.Create("bVGUI.PermissionsSelector_Row", self)
	row.RowIndex = table.insert(self.Rows, i, row)
	row.CategoryIndex = table.insert(self.Categories[header_val or header_text], row)
	row.Category = header_val or header_text
	row:Dock(TOP)
	row:MoveToAfter(last_row)
	row:SetText(v.text)
	row:SetTextColor(v.text_col)
	row:SetControlsAll(v.controls_all or false)
	row.PermissionValue = v.value
	if (v.checked) then
		row:SetChecks(v.checked)
	end
end

function PANEL:GetPermissions()
	local permissions = {}
	if (self.SuperGroupRow) then
		for checkbox_i, checkbox in ipairs(self.SuperGroupRow.Checkboxes) do
			if (self.UseNormalCheckboxes) then
				if (checkbox:GetChecked() ~= false) then
					permissions["*"] = {}
					permissions["*"][checkbox_i] = true
					return permissions
				end
			else
				if (checkbox:GetChecked() ~= 0) then
					permissions["*"] = {}
					permissions["*"][checkbox_i] = checkbox:GetChecked()
					return permissions
				end
			end
		end
	end
	for category_i, rows in pairs(self.Categories) do
		permissions[category_i] = {}
		for row_i, row in ipairs(rows) do
			if (row.ControlsAll == true) then
				for checkbox_i, checkbox in ipairs(table.Reverse(row.Checkboxes)) do
					if (checkbox:GetChecked() ~= 0) then
						permissions[category_i]["*"] = permissions[category_i]["*"] or {}
						permissions[category_i]["*"][checkbox_i] = checkbox:GetChecked()
					end
				end
				if (permissions[category_i]["*"]) then
					if (table.Count(permissions[category_i]["*"]) == #row.Checkboxes) then
						break
					end
				end
			else
				permissions[category_i][row.PermissionValue or row.Label:GetText()] = {}
				for checkbox_i, checkbox in ipairs(table.Reverse(row.Checkboxes)) do
					if (checkbox:GetChecked() ~= 0) then
						permissions[category_i][row.PermissionValue or row.Label:GetText()][checkbox_i] = checkbox:GetChecked()
					end
				end
			end
		end
		if (permissions[category_i]["*"] and table.Count(permissions[category_i]) > 1) then
			permissions[category_i]["*"] = nil
		end
	end
	return permissions
end

function PANEL:UpdateCheckboxes()
	--[[
	local super_merges = {}
	local merges = {}
	for category_i, rows in pairs(self.Categories) do
		merges[category_i] = {}
		for row_i, row in ipairs(rows) do
			if (row.ControlsAll) then continue end
			for checkbox_i, checkbox in ipairs(row.Checkboxes) do
				if (super_merges[checkbox_i] == nil) then
					super_merges[checkbox_i] = checkbox:GetChecked()
				elseif (super_merges[checkbox_i] ~= false and super_merges[checkbox_i] ~= checkbox:GetChecked()) then
					super_merges[checkbox_i] = false
				end
				if (merges[category_i][checkbox_i] == nil) then
					merges[category_i][checkbox_i] = checkbox:GetChecked()
				elseif (merges[category_i][checkbox_i] ~= false and merges[category_i][checkbox_i] ~= checkbox:GetChecked()) then
					merges[category_i][checkbox_i] = false
				end
			end
		end
	end
	for category_i, checkboxes in pairs(merges) do
		for checkbox_i, checked in ipairs(checkboxes) do
			if (not self.Categories[category_i][1].ControlsAll) then continue end
			self.Categories[category_i][1].Checkboxes[checkbox_i]:SetChecked(checked or 0)
		end
	end
	if (IsValid(self.SuperGroupRow)) then
		for checkbox_i, checked in ipairs(super_merges) do
			self.SuperGroupRow.Checkboxes[checkbox_i]:SetChecked(checked or 0)
		end
	end
	]]
end

derma.DefineControl("bVGUI.PermissionsSelector", nil, PANEL, "bVGUI.LoadingScrollPanel")

local PANEL = {}

function PANEL:Init()
	local this = self
	self.PermissionsSelector = self:GetParent():GetParent()

	self:Dock(TOP)
	self:DockPadding(5,0,5,0)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:Dock(LEFT)

	self.Checkboxes = {}
	for i,v in ipairs(table.Reverse(self.PermissionsSelector.Permissions)) do
		local checkbox
		if (self.PermissionsSelector.UseNormalCheckboxes) then
			checkbox = vgui.Create("bVGUI.Checkbox", self)
		else
			checkbox = vgui.Create("bVGUI.Checkbox_Crossable", self)
		end
		checkbox.CheckboxIndex = table.insert(self.Checkboxes, checkbox)
		checkbox:Dock(RIGHT)
		checkbox:SetTooltip(v)
		checkbox:DockMargin(0,3.5,5,3.5)
		function checkbox:OnChange()
			if (this.PermissionsSelector.SuperGroupRow) then
				local super_checkbox = this.PermissionsSelector.SuperGroupRow.Checkboxes[self.CheckboxIndex]
				if (self:GetChecked() ~= super_checkbox:GetChecked()) then
					if (this.PermissionsSelector.UseNormalCheckboxes) then
						super_checkbox:SetChecked(false)
					else
						super_checkbox:SetChecked(0)
					end
				end
			end
			if (self:GetParent().IsSuperGroup == true) then
				for category_i, rows in pairs(this.PermissionsSelector.Categories) do
					for row_i, row in ipairs(rows) do
						row.Checkboxes[self.CheckboxIndex]:SetChecked(self:GetChecked())
					end
				end
			else
				for i,v in ipairs(this.PermissionsSelector.Categories[self:GetParent().Category]) do
					if (v.ControlsAll) then
						local controls_all_checkbox = v.Checkboxes[self.CheckboxIndex]
						if (self:GetChecked() ~= controls_all_checkbox:GetChecked()) then
							if (this.PermissionsSelector.UseNormalCheckboxes) then
								controls_all_checkbox:SetChecked(false)
							else
								controls_all_checkbox:SetChecked(0)
							end
						end
						break
					end
				end

				if (self:GetParent().ControlsAll == true) then
					for i,v in ipairs(this.PermissionsSelector.Categories[self:GetParent().Category]) do
						if (v.ControlsAll) then continue end
						v.Checkboxes[self.CheckboxIndex]:SetChecked(self:GetChecked())
					end
				end

				this.PermissionsSelector:UpdateCheckboxes()
			end
			if (this.PermissionsSelector.OnPermissionsChanged) then
				this.PermissionsSelector:OnPermissionsChanged()
			end
		end
	end
end

function PANEL:Paint(w,h)
	if (self.RowIndex % 2 == 0) then
		surface.SetDrawColor(31, 35, 43)
	else
		surface.SetDrawColor(33, 37, 45)
	end
	surface.DrawRect(0,0,w,h)
end

function PANEL:SetText(text)
	self.Label:SetText(text)
	self.Label:SizeToContents()
end

function PANEL:SetTextColor(text_col)
	self.Label:SetTextColor(text_col)
end

function PANEL:SetControlsAll(controls_all)
	self.ControlsAll = controls_all
end

function PANEL:SetSuperGroup(supergroup)
	self.IsSuperGroup = supergroup
end

function PANEL:SetChecks(checked)
	for i,v in ipairs(table.Reverse(self.Checkboxes)) do
		if (checked[i]) then
			v:SetChecked(checked[i])
		end
	end
end

derma.DefineControl("bVGUI.PermissionsSelector_Row", nil, PANEL, "DPanel")
--addons/billy_gas/lua/vgui/bvgui/toolbarbutton.lua:
--/// bVGUI.ToolbarButton_IMG ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("hand")
	self.bVGUI_IMG = vgui.Create("DImage", self)
	self.bVGUI_IMG:SetSize(16,16)
end

function PANEL:Paint()
	if (self:IsHovered()) then
		if (not self._IsHovered) then
			self._IsHovered = true
			self.bVGUI_IMG:SetMaterial(self.HoverMaterial)
		end
	else
		if (self._IsHovered) then
			self._IsHovered = nil
			self.bVGUI_IMG:SetMaterial(self.DefaultMaterial)
		end
	end
end

function PANEL:SetMaterial(mat)
	self.bVGUI_IMG:SetMaterial(mat)
	self.DefaultMaterial = mat
end
function PANEL:SetHoverMaterial(mat)
	self.HoverMaterial = mat
end

function PANEL:OnMouseReleased()
	self:DoClick()
end

function PANEL:PerformLayout()
	self.bVGUI_IMG:Center()
end

derma.DefineControl("bVGUI.ToolbarButton_IMG", nil, PANEL, "DPanel")

--/// bVGUI.ToolbarButton_IMGText ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("hand")

	self.bVGUI_IMG = vgui.Create("DImage", self)
	self.bVGUI_IMG:SetSize(16,16)

	self.bVGUI_Text = vgui.Create("DLabel", self)
	self.bVGUI_Text:SetText("Menu")
	self.bVGUI_Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	self.bVGUI_Text:SetTextColor(bVGUI.COLOR_DARK_GREY)
end

function PANEL:Paint()
	if (self:IsHovered()) then
		if (not self._IsHovered) then
			self._IsHovered = true
			self.bVGUI_IMG:SetMaterial(self.HoverMaterial)
			self.bVGUI_Text:SetTextColor(bVGUI.COLOR_WHITE)
		end
	else
		if (self._IsHovered) then
			self._IsHovered = nil
			self.bVGUI_IMG:SetMaterial(self.DefaultMaterial)
			self.bVGUI_Text:SetTextColor(bVGUI.COLOR_DARK_GREY)
		end
	end
end

function PANEL:SetMaterial(mat)
	self.bVGUI_IMG:SetMaterial(mat)
	self.DefaultMaterial = mat
end
function PANEL:SetHoverMaterial(mat)
	self.HoverMaterial = mat
end

function PANEL:SetText(txt)
	self.bVGUI_Text:SetText(txt)
	self:PerformLayout()
end

function PANEL:PerformLayout()
	self.bVGUI_IMG:AlignLeft(5)
	self.bVGUI_IMG:CenterVertical()

	self.bVGUI_Text:SizeToContents()
	self.bVGUI_Text:AlignLeft(5 + 16 + 5)
	self.bVGUI_Text:CenterVertical()

	self:SetWide(5 + 16 + 5 + self.bVGUI_Text:GetWide() + 5 + 2)
end

function PANEL:OnMouseReleased()
	self:DoClick()
end

derma.DefineControl("bVGUI.ToolbarButton_IMGText", nil, PANEL, "DPanel")
--addons/billy_gas/lua/vgui/bvgui/tooltip.lua:
local bg_color = Color(43,48,58,255)

local PANEL = {}

function PANEL:Init()
	self:SetDrawOnTop(true)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.Label:SetText("Tooltip")
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetContentAlignment(5)
	self.Label:SetWrap(true)

	self.Arrow = {
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0}
	}
end

function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, self.BackgroundColor or bg_color)
	surface.DisableClipping(true)

	surface.SetDrawColor(self.BackgroundColor or bg_color)
	draw.NoTexture()

	self.Arrow[1].x = w / 2 - 7
	self.Arrow[1].y = h

	self.Arrow[2].x = w / 2 + 7
	self.Arrow[2].y = h

	self.Arrow[3].x = w / 2
	self.Arrow[3].y = h + 7

	surface.DrawPoly(self.Arrow)

	surface.DisableClipping(false)
end

function PANEL:Think()
	local x,y = self.Label:GetSize()
	self:SetSize(x + 15, y + 7)
	self.Label:Center()

	local x,y = gui.MousePos()
	self.XPos = Lerp(FrameTime() * 15, self.XPos or x, x)
	self.YPos = Lerp(FrameTime() * 15, self.YPos or y, y)
	
	self:SetPos(self.XPos - self:GetWide() / 2, self.YPos - self:GetTall() - 14 - 5)

	if (not system.HasFocus()) then
		self:Remove()
	elseif (self.VGUI_Element) then
		if (not IsValid(self.VGUI_Element)) then
			self:Remove()
		elseif (vgui.GetHoveredPanel() ~= self.VGUI_Element) then
			if (self.HoverFrameNumber) then
				if (FrameNumber() > self.HoverFrameNumber) then
					self:Remove()
				end
			else
				self.HoverFrameNumber = FrameNumber() + 1
			end
		end
	end
end

function PANEL:SetText(text)
	self.Label:SetText(text)
	self.Label:SetWrap(false)
	self.Label:SizeToContentsX()
	if (self.Label:GetWide() >= 200) then
		self.Label:SetWide(200)
		self.Label:SetWrap(true)
		self.Label:SetAutoStretchVertical(true)
	end
end
function PANEL:GetText()
	return self.Label:GetText()
end

function PANEL:SetTextColor(col)
	self.Label:SetTextColor(col)
end
function PANEL:GetTextColor()
	return self.Label:GetTextColor()
end

function PANEL:SetBackgroundColor(col)
	self.BackgroundColor = col
end
function PANEL:GetBackgroundColor()
	return self.BackgroundColor
end

function PANEL:SetVGUIElement(elem)
	self.VGUI_Element = elem
end
function PANEL:GetVGUIElement()
	return self.VGUI_Element
end

derma.DefineControl("bVGUI.Tooltip", nil, PANEL, "DPanel")

bVGUI.CreateTooltip = function(options)
	bVGUI.DestroyTooltip()

	bVGUI.Tooltip = vgui.Create("bVGUI.Tooltip")
	bVGUI.Tooltip:SetVGUIElement(options.VGUI_Element)
	bVGUI.Tooltip:SetText(options.Text)
	bVGUI.Tooltip:SetTextColor(options.TextColor or bVGUI.COLOR_WHITE)
	bVGUI.Tooltip:SetBackgroundColor(options.BackgroundColor or bg_color)
end
bVGUI.DestroyTooltip = function()
	if (IsValid(bVGUI.Tooltip)) then
		if (bVGUI.Tooltip.Closing ~= true) then
			bVGUI.Tooltip:Remove()
		end
	end
end

bVGUI.AttachTooltip = function(pnl, options)
	pnl:SetMouseInputEnabled(true)
	options.VGUI_Element = pnl
	if (pnl.bVGUI_TooltipOptions) then
		pnl.bVGUI_TooltipOptions = options
		return
	else
		pnl.bVGUI_TooltipOptions = options
	end

	pnl.bVGUI_TOOLTIP_OLD_CURSOR_ENTER = pnl.bVGUI_TOOLTIP_OLD_CURSOR_ENTER or pnl.OnCursorEntered
	pnl.bVGUI_TOOLTIP_OLD_CURSOR_EXIT = pnl.bVGUI_TOOLTIP_OLD_CURSOR_EXIT or pnl.OnCursorExited
	function pnl:OnCursorEntered(...)
		bVGUI.CreateTooltip(self.bVGUI_TooltipOptions)
		if (self.bVGUI_TOOLTIP_OLD_CURSOR_ENTER) then self.bVGUI_TOOLTIP_OLD_CURSOR_ENTER(self, ...) end
	end
	function pnl:OnCursorExited(...)
		bVGUI.DestroyTooltip()
		if (self.bVGUI_TOOLTIP_OLD_CURSOR_EXIT) then self.bVGUI_TOOLTIP_OLD_CURSOR_EXIT(self, ...) end
	end
end

bVGUI.UnattachTooltip = function(pnl)
	pnl.bVGUI_TooltipOptions = nil
	pnl.OnCursorEntered = pnl.bVGUI_TOOLTIP_OLD_CURSOR_ENTER
	pnl.OnCursorExited = pnl.bVGUI_TOOLTIP_OLD_CURSOR_EXIT
end
--addons/tools/lua/vgui/stackerpreseteditor.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local vgui = vgui
local pairs = pairs
local AccessorFunc = AccessorFunc
local GetConVarString = GetConVarString

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

AccessorFunc( PANEL, "m_ConCommands", "ConCommands" )

--[[--------------------------------------------------------------------------
--
--	PANEL:Add()
--
--]]--
function PANEL:Add()
	if ( not self.m_ConVars ) then return end
	
	local ToName = self.txtName:GetValue()
	if ( not ToName or ToName == "" ) then return end
	
	-- Todo, Handle name collision
	local tabValues = {}
	
	for k, v in pairs( self.m_ConVars ) do
		tabValues[ v.CCmd ] = GetConVarString( v.CVar )
	end
		
	presets.Add( self.m_strType, ToName, tabValues )
	self:Update()
	self.PresetList:SelectByName( ToName )
	self.txtName:SetText( "" )
	
	if ( self.m_PresetControl ) then
		self.m_PresetControl:Update()
	end
end

vgui.Register( "StackerPresetEditor", PANEL, "PresetEditor" )
--gamemodes/starwarsrp/gamemode/modules/unit/sh_unit.lua:
AOCRP.Unit = {}

function AOCRP.Unit:GetRankName(rankid, unitid)
    if !AOCRP.Ranks[rankid] then 
        return AOCRP.Ranks[0].name
    end
    if unitid == 9 then 
        return AOCRP.Ranks[rankid].navyprefix
    end
    return AOCRP.Ranks[rankid].name
end

function AOCRP.Unit:GetRankPrefix(rankid, unitid)
    if !AOCRP.Ranks[rankid] then 
        return AOCRP.Ranks[0].prefix
    end
    if unitid == 9 then 
        return AOCRP.Ranks[rankid].navyname
    end
    return AOCRP.Ranks[rankid].prefix
end


function AOCRP.Unit:GetUnits()
    return AOCRP.Units
end 

function AOCRP.Unit:GetData(unitid)
    return AOCRP.Units[unitid]
end

function AOCRP.Unit:GetHighestRanking(unitid)

    local currentHighest = nil
    for k, v in ipairs(player.GetAll()) do
        if v:GetUnitID() == unitid then
            if currentHighest == nil then
                currentHighest = v
                continue 
            end
            if v:GetRankID() > currentHighest:GetRankID() then 
                currentHighest = v
            end
        end
    end
    return currentHighest
end

function AOCRP.Unit:GetOverallHighestRanking()

    local currentHighest = nil
    for k, v in ipairs(player.GetAll()) do

            if currentHighest == nil then
                currentHighest = v
                continue 
            end
            if v:GetRankID() > currentHighest:GetRankID() then 
                currentHighest = v
            end

    end
    return currentHighest
end


function AOCRP.Unit:GetStaerke(unitid)

    local off = 0
    local unteroff = 0
    local obm = 0
    local soldat = 0
    local insgesamt = 0


    for k, v in ipairs(player.GetAll()) do
        if v:GetUnitID() == unitid then
            insgesamt = insgesamt + 1
            if v:GetRankID() >= 15 then 
                off = off + 1
                continue
            end
            if v:GetRankID() >= 11 then 
                unteroff = unteroff + 1
                continue
            end
            if v:GetRankID() >= 7 then 
                obm = obm + 1
                continue
            end
            soldat = soldat + 1
        end
    end
    return off.." / "..unteroff.." / "..obm.." / "..soldat .. " / ".. insgesamt
end


function AOCRP.Unit:GetGesamtStaerke()

    local off = 0
    local unteroff = 0
    local obm = 0
    local soldat = 0
    local insgesamt = 0


    for k, v in ipairs(player.GetAll()) do

            insgesamt = insgesamt + 1
            if v:GetRankID() >= 15 then 
                off = off + 1
                continue
            end
            if v:GetRankID() >= 11 then 
                unteroff = unteroff + 1
                continue
            end
            if v:GetRankID() >= 7 then 
                obm = obm + 1
                continue
            end
            soldat = soldat + 1

    end
    return off.." / "..unteroff.." / "..obm.." / "..soldat .. " / ".. insgesamt
end


if SERVER then 


        
    AOCRP.UnitLog = {}

    function AOCRP.UnitLog:Add(unitid, text)

        local insertObj = mysql:Insert("unitlog");
        insertObj:Insert("unitid",unitid);
        insertObj:Insert("text", text);
        insertObj:Execute();

    end

    function AOCRP.UnitLog:AddCharPlusUnit(cloneid, unitid, text)
        AOCRP.UnitLog:Add(unitid, text)
        AOCRP.CharSys:CharLogEntry(cloneid, text)
    end



    function AOCRP.Unit:UpdateVar(unitid, var, value, callback)
        local updateObj = mysql:Update("unit");
        updateObj:Update(var, value);
        updateObj:Where("unitid", unitid);
        updateObj:Callback(function(result, status, lastID)
            if callback then
            callback(cloneid, var, value)
            end
            AOCRP.Unit:ReloadUnitData()
        end);
    
        updateObj:Execute(); 
    
    end



    -- Function to convert date string to desired format
    local function convertDate(inputDate)
        local day, month, year, hour, minute = inputDate:match("(%d%d).(%d%d).(%d%d) (%d%d):(%d%d)")

        -- Check if the input date matches the expected format
        if day and month and year and hour and minute then
            local formattedDate = string.format("20%s-%s-%s %s:%s:00", year, month, day, hour, minute)

            -- Check if the date is in the future
            local currentTime = os.time()
            local inputTime = os.time({year = tonumber("20"..year), month = tonumber(month), day = tonumber(day), hour = tonumber(hour), min = tonumber(minute)})
            
            if inputTime > currentTime then
                return formattedDate
            else
                return false, "Datum muss in der Zukunft liegen."
            end
        else
            return false, "Falsches Format. Nutze: dd.mm.yy hh:mm"
        end
    end



    local function HexToColor(hexString)
        local red = tonumber(hexString:sub(2,3), 16)
        local green = tonumber(hexString:sub(4,5), 16)
        local blue = tonumber(hexString:sub(6,7), 16)
        return Color(red, green, blue)
    end

    function AOCRP.Unit:SetNextTO(ply, input)

        if ply:GetRankID() < 7 then ply:ChatPrint("*** Hierfür musst du mindestens Lance Corporal sein.") return end

        local unit = ply:GetUnitID()
        local inputDateString = "06.04.24 12:00"
        local success, convertedDate = convertDate(input)
        if success then
            AOCRP.Unit:UpdateVar(unit, "tryout", success)
            AOCRP.UnitLog:Add(unit, ply:Nick().." hat den Zeitpunkt des nächsten TOs auf "..success.." gesetzt.")
            AOCRP.HUD:Notification(player.GetAll(), {title=AOCRP.Units[unit].name, text="Nächstes Tryout findet statt am: "..input, titlecolor=HexToColor(AOCRP.Units[unit].colorhex), delay=30,sound="everfall/miscellaneous/ux/award/missions_award_star_01.mp3"}) 
        else
            ply:ChatPrint("*** ".. convertedDate)
        end
    end 
end



if SERVER then 
    util.AddNetworkString("AOCRP.Unit.ReloadUnitData")
end


    function AOCRP.Unit:ReloadUnitData()

        if SERVER then 
            net.Start("AOCRP.Unit.ReloadUnitData")
            net.Broadcast()
        end 

        if CLIENT then 

            AOCRP.API:Request("getunits", function(data) 

                if #data > 0 then
                    AOCRP.Units = {}
                    for k, v in pairs(data) do
                        AOCRP.Units[v.unitid] = v
                    end
                end

            end, {}, 
            function(err) 
                print(err) 
            end)
        end
    end 

    if CLIENT then

        net.Receive("AOCRP.Unit.ReloadUnitData", function(len, ply)
            AOCRP.Unit:ReloadUnitData()
        end)  
    end

    function AOCRP.Unit:GetTryoutDate(unitid)
        local unit = AOCRP.Unit:GetData(unitid)
        local dateString = unit.tryout
    
        if dateString == "0000-00-00 00:00:00" then
            return "-"
        end
    
        local year, month, day, hour, minute = dateString:match("(%d%d%d%d)-(%d%d)-(%d%d) (%d%d):(%d%d):%d%d")
        
        if year and month and day and hour and minute then
            local inputTime = os.time({year = tonumber(year), month = tonumber(month), day = tonumber(day), hour = tonumber(hour), min = tonumber(minute)})
            local currentTime = os.time()
            if inputTime > currentTime then
                return string.format("%s.%s.%s %s:%s", day, month, string.sub(year, 3), hour, minute)
            else
                return "-"
            end
        else
            return "-"
        end
    end
    
    



if SERVER then
    util.AddNetworkString("AOCRP.Unit.RecieveInvite")
end

if CLIENT then
    
    net.Receive("AOCRP.Unit.RecieveInvite", function(len, ply)

        local requestor = net.ReadString()
        local unit = net.ReadString()
        AOCDerma:DermaApprove( requestor.." möchte dich in die "..unit.." aufnehmen", "Neue Einladung", function() net.Start("AOCRP.UnitMgmt.AcceptInvite") net.SendToServer() end, function() end, "Einheit beitreten", "Einladung ablehnen" )
    end)    
    
end
--gamemodes/starwarsrp/gamemode/modules/gui/cl_bindmenu.lua:
--Test
AOCRP_Binds = {}

AOCRP_Binds.List = {}


AOCRP_Binds.Categories = {}

function AOCRP_Binds:AddBind(id, name, help, default, func, func2, category)
    local newBind = {}
    newBind.Name = name
    newBind.Help = help
    newBind.DefaultKey = default
    newBind.Function = func
    newBind.Key = default
    newBind.FunctionUp = func2 or function() end
    newBind.category = category
    self.List[id] = newBind

    if !table.HasValue(self.Categories, category) then
        table.insert(self.Categories, category)
    end
end


function AOCRP_Binds:FindBindToKey(key)
    for k, v in pairs(self.List) do
        if v.Key == key then
            return v
        end
    end
    return false
end

function AOCRP_Binds:FindBindByID(id)
    return self.List[id].Key 
end




for k, v in pairs(AOCRP.Config.Binds) do
    cat = "Unbekannt"
    if v.category then
        cat = v.category
    end
    AOCRP_Binds:AddBind(k, v.name, v.desc, v.defaultkey, v.downFunc, v.upFunc, cat)
end


function AOCRP_Binds:SaveBinds()
    local savetable = {}
    for k, v in pairs(self.List) do
        savetable[k] = v.Key
    end
    local json = util.TableToJSON(savetable)
    file.Write( "aocrp_keybinds.json", json) 

    AOCRP_Binds:LoadBindsFromData()
end

function AOCRP_Binds:LoadBindsFromData()
    if file.Exists( "aocrp_keybinds.json", "DATA" ) then
        local json = file.Read( "aocrp_keybinds.json", "DATA" )
        local bindtable = util.JSONToTable(json)
        for k, v in pairs(bindtable) do
            if AOCRP_Binds.List[k] then
                AOCRP_Binds.List[k].Key = v
            end
        end
    end
end





function AOCRP_Binds:OpenMenu()

    if ValidPanel(AOCBindMenuFrame) then AOCBindMenuFrame:Remove() end
    AOCBindMenuFrame = AOCDerma:DefaultFrame()
    AOCBindMenuFrame:SetSize(AOCW(700),AOCH(1000))
    AOCBindMenuFrame:Center()
    AOCBindMenuFrame:SetNewTitle("Tastenbelegungen")
    AOCBindMenuFrame:SetSizable(false)
    AOCBindMenuFrame:SetDraggable(false)


    BindMenuOptions = vgui.Create("DPanel", AOCBindMenuFrame)
    BindMenuOptions:Dock(BOTTOM)
    BindMenuOptions:SetTall(AOCH(60))
    BindMenuOptions:DockMargin(0,10,0,0)
    function BindMenuOptions:Paint(w,h)
        --draw.RoundedBox(0,0,0,w,h,Color(255,0,0))
    end

    local save = AOCDerma:Button(BindMenuOptions, "Speichern", 
    function() 
    
        AOCRP_Binds:SaveBinds()
        AOCRP_Binds:LoadBindsFromData()
        AOCBindMenuFrame:Remove()
        AOCRP_Binds:OpenMenu()

    end, "lb")
    save:Dock(LEFT)
    --save:SetWide(AOCW(180))
    save.akzent = Color(0,116,0,255)
    save.akzenthover = Color(0,170,0,255)

        local default = AOCDerma:Button(BindMenuOptions, "Standard", 
        function() 
            for k, v in pairs(AOCRP_Binds.List) do
                v.Key = v.DefaultKey
                AOCBindMenuFrame:Remove()
                AOCRP_Binds:OpenMenu()
            end
        
        end, "rb")
    default:Dock(RIGHT)
    --default:SetWide(AOCW(180))




    local ScrollPanel = AOCDerma:ScrollBar(AOCBindMenuFrame) 
    ScrollPanel:Dock( FILL )





    for k, v in SortedPairs(self.List) do
        local bind = ScrollPanel:Add("DPanel")
        function bind:Paint(width, height) 
            draw.RoundedBox(0, 0, 0, width, height, Color(0,0,0,100))
        end
        bind:Dock(TOP)
        bind:SetTall(AOCH(80))
        bind:DockPadding(10,5,5,5)
        bind:DockMargin(0, 0, 0, 5)

        local txtpanel = vgui.Create("DPanel", bind)
        function txtpanel:Paint(width, height) end
        txtpanel:Dock(LEFT)
        txtpanel:SetWide(ScrW())
        local txt = vgui.Create("DLabel", txtpanel)
        txt:SetText(v.Name)
        txt:Dock(TOP)
        txt:SetFont(PIXEL.UI.RegisteredFonts["AOCRP_BindMenu_BindTitle"])
        txt:SizeToContents()
        txt:SetColor(Color(255,255,255,255))
        
        local txt = vgui.Create("DLabel", txtpanel)
        txt:SetText(v.Help)
        txt:Dock(TOP)
        txt:SetFont(PIXEL.UI.RegisteredFonts["AOCRP_BindMenu_BindHelp"])
        txt:SizeToContents()
        txt:SetColor(Color(200,200,200,255))
        local text = "NONE"
        
        local btn = vgui.Create("DBinder",bind)
        --btn:SetValue(KEY_NONE)
         btn:SetValue(v.Key)
         btn:SetWide(AOCW(150))
       
        btn:SetText("")

        function btn:SetInitalText()
            local str = input.GetKeyName( self:GetSelectedNumber() )
            if ( !str ) then str = "N/A" end

            str = language.GetPhrase( str )

            self.BtnText = str
        end
        btn:SetInitalText()

        function btn:DoClick()

            self.BtnText = "..."
            input.StartKeyTrapping()
            self.Trapping = true

        end

        function btn:Paint(w,h)


            surface.SetFont(PIXEL.UI.RegisteredFonts["AOCRP_BindMenu_BindButton"])
            local txtW, txtH = surface.GetTextSize(self.BtnText)

                        draw.RoundedBox(0,0,h-1,w,1,Color(255,255,255))
            draw.DrawText(string.upper(self.BtnText),PIXEL.UI.RegisteredFonts["AOCRP_BindMenu_BindButton"],w/2,h/2-txtH/2,Color(255,255,255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
        end
        btn:Dock(RIGHT)


        function btn:UpdateText()

            local str = input.GetKeyName( self:GetSelectedNumber() )
            if ( !str ) then str = "NONE" end

            str = language.GetPhrase( str )

            self.BtnText = str

        end
        
        function btn:OnChange(key)
            --self.akzent = Color(255,100,0,255)
            v.Key = key
        end


    end

    
end

concommand.Add( "aocrp_binds", function( ply, cmd, args )
    AOCRP.Keybinds:OpenMenu()
end )


timer.Simple(1, function() 
    if !file.Exists( "aocrp_keybinds.json", "DATA" ) then
        AOCRP_Binds:SaveBinds()
    else   
        AOCRP_Binds:LoadBindsFromData()
    end
end)


hook.Add( "PlayerButtonDown", "AOCRP.Bind.PlayerButtonDown", function( ply, button )
		if ( !IsFirstTimePredicted() ) then return end
        local bind = AOCRP_Binds:FindBindToKey(button)
        if bind then
            bind.Function()
        end
end)

hook.Add( "PlayerButtonUp", "AOCRP.Bind.PlayerButtonDown", function( ply, button )
    if ( !IsFirstTimePredicted() ) then return end
    local bind = AOCRP_Binds:FindBindToKey(button)
    if bind then
        bind.FunctionUp()
    end
end)


AOCRP.Keybinds = {}
AOCDerma:RegisterFont("Keybinds.Title", "Agency FB", 40, 1000)
AOCDerma:RegisterFont("Keybinds.Name", "Agency FB", 30, 100)
AOCDerma:RegisterFont("Keybinds.Description", "Agency FB", 18, 1)
AOCDerma:RegisterFont("Keybinds.Button", "Agency FB", 30, 1000)
function AOCRP.Keybinds:OpenMenu()
    self:CloseMenu()

    self.Frame = AOCDerma:DefaultFrame("Tastenbelegungen")
    self.Frame:SetSize(AOCW(700), AOCH(1000))
    self.Frame:Center()

    self.Options = vgui.Create("DPanel", self.Frame)
    self.Options:Dock(BOTTOM)
    self.Options:SetTall(AOCH(60))
    self.Options:DockMargin(0, AOCH(10), 0, 0)
    function self.Options:Paint(w, h)
    end

    self.Scroll = AOCDerma:ScrollBar(self.Frame)
    self.Scroll:Dock(FILL)

    for k, category in SortedPairsByValue(AOCRP_Binds.Categories) do
        local categoryLabel = vgui.Create("DLabel", self.Scroll)
        categoryLabel:Dock(TOP)
        categoryLabel:DockMargin(AOCW(10), 0, AOCW(10), 0)
        categoryLabel:SetTall(AOCH(60))
        categoryLabel:SetFont(AOCDerma:Font("Keybinds.Title"))
        categoryLabel:SetText(category)
        categoryLabel:SetColor(Color(255, 255, 255))

        for name, bind in SortedPairs(AOCRP_Binds.List) do
            if bind.category == category then
                local bindPanel = vgui.Create("DPanel", self.Scroll)
                bindPanel:Dock(TOP)
                bindPanel:DockMargin(AOCW(10), AOCH(5), AOCW(5), AOCH(5))
                bindPanel:SetTall(AOCH(60))
                function bindPanel:Paint(w, h)
                    draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200))
                end

                local namePanel = vgui.Create("DPanel", bindPanel)
                namePanel:Dock(LEFT)
                namePanel:SetWide(ScrW())
                function namePanel:Paint(w, h)
                end

                local nameLabel = vgui.Create("DLabel", namePanel)
                nameLabel:Dock(TOP)
                namePanel:DockMargin(AOCW(15), AOCH(5), AOCW(5), 0)
                nameLabel:SetFont(AOCDerma:Font("Keybinds.Name"))
                nameLabel:SetText(bind.Name)
                nameLabel:SetColor(Color(255, 255, 255))
                nameLabel:SizeToContents()

                local helpPanel = vgui.Create("DLabel", namePanel)
                helpPanel:Dock(TOP)
                helpPanel:DockMargin(AOCW(5), 0, AOCW(5), 0)
                helpPanel:SetFont(AOCDerma:Font("Keybinds.Description"))
                helpPanel:SetText(bind.Help)
                helpPanel:SetColor(Color(255, 255, 255))
                helpPanel:SizeToContents()

                local binder = vgui.Create("DBinder", bindPanel)
                binder:SetValue(bind.Key)
                binder:SetText("")
                binder:SetWide(AOCW(150))
                binder:Dock(RIGHT)
                function binder:SetInitialText()
                    local bindKey = input.GetKeyName(self:GetSelectedNumber())
                    if not bindKey then bindKey = "N/A" end

                    bindKey = language.GetPhrase(bindKey)

                    self.binderText = bindKey
                end
                binder:SetInitialText()

                function binder:DoClick()
                    self.binderText = "..."
                    input.StartKeyTrapping()
                    self.Trapping = true
                end
                function binder:Paint(width, height)
                    surface.SetFont(AOCDerma:Font("Keybinds.Name"))
                    local _, textHeight = surface.GetTextSize(self.binderText)

                    draw.DrawText(string.upper(self.binderText), AOCDerma:Font("Keybinds.Button"), width / 2, height / 2 - textHeight / 2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

                    draw.RoundedBox(0, 0, height - 1, width, 1, Color(255, 255, 255))
                end
                function binder:UpdateText()
                    local bindKey = input.GetKeyName(self:GetSelectedNumber())
                    if not bindKey then bindKey = "N/A" end

                    bindKey = language.GetPhrase(bindKey)

                    self.binderText = bindKey
                    bind.Key = self:GetSelectedNumber()
                    AOCRP_Binds:SaveBinds()
                end
                function binder:DoRightClick()
                    self:SetValue(0)
                end
            end
        end
    end

    self.ResetButton = AOCDerma:Button(self.Options, "Zurücksetzen", function()
        for k, v in pairs(AOCRP_Binds.List) do
            v.Key = v.DefaultKey
        end
        AOCRP_Binds:SaveBinds()
        AOCRP.Keybinds:OpenMenu()
    end, "tblrc")
    self.ResetButton:Dock(FILL)
end

function AOCRP.Keybinds:CloseMenu()
    if IsValid(self.Frame) then
        self.Frame:Remove()
    end
end

--gamemodes/starwarsrp/gamemode/modules/gear/sh_gearedit.lua:
AOCRP.Gear = AOCRP.Gear or {}

if CLIENT then



    local function textentry(pnl, lbl, val)
        local DLabel = vgui.Create( "DLabel", pnl )
        DLabel:Dock(TOP)
        DLabel:SetText( lbl )
        
        entry = vgui.Create( "DTextEntry", pnl ) -- create the form as a child of frame
        entry:Dock( TOP )
        entry:SetTall(30)
        entry:SetValue(val) 
        return entry 
    end

    local function unitchooser(pnl,lbl, val)
        --PrintTable(AOCRP.Units)
        val = val or 0
        val = tonumber(val)
        local DLabel = vgui.Create( "DLabel", pnl )
        DLabel:Dock(TOP)
        DLabel:SetText( lbl )

        local chooser = vgui.Create( "DComboBox",pnl )
        chooser:Dock(TOP)
        --datafields.unitid:SetValue( geardata.unitid )

        for k, v in pairs( AOCRP.Units ) do
            if k == val then
                chooser:AddChoice( v.name, k, true )
            else
                chooser:AddChoice( v.name, k )
            end
        end    
        
        return chooser
    end


    local function autolistgearchooser(pnl,lbl, val)
        --PrintTable(AOCRP.Units)
        val = val or 0
        val = tonumber(val)
        local DLabel = vgui.Create( "DLabel", pnl )
        DLabel:Dock(TOP)
        DLabel:SetText( lbl )

        local chooser = vgui.Create( "DComboBox",pnl )
        chooser:Dock(TOP)
        --datafields.unitid:SetValue( geardata.unitid )

        if val == 0 then 
            chooser:AddChoice( "Keine Weiterleitung", 0, true)
        else 
            chooser:AddChoice( "Keine Weiterleitung", 0 )
        end
        for k, v in pairs( AOCRP.Gears ) do
            if k == val then
                chooser:AddChoice( v.name, k, true )
            else
                chooser:AddChoice( v.name, k )
            end
        end    
        
        return chooser
    end

    
    local function listViewToTblAndThenToJsonForSave(listview)

        local returnval = "[]"
        local tbl = {}
        for k, line in pairs( listview:GetLines() ) do
            table.insert(tbl,line:GetValue(1))
        end
        if #tbl > 0 then
            returnval = util.TableToJSON(tbl)
        else
            returnval = "[]"
        end
        return returnval
    end

    local function jsoneditor(pnl,lbl,datalbl,data,autocomplete)
        data = data or {}
        local DLabel = vgui.Create( "DLabel", pnl )
        DLabel:Dock(TOP)
        DLabel:SetText( lbl )
        local listview = vgui.Create( "DListView", pnl )
        listview:Dock( TOP )
        listview:SetMultiSelect( false )
        listview:AddColumn( datalbl .. "(rechtsklick zum löschen)" )
        listview:SetTall(100)
        if #data > 0 then
            for k,v in pairs(data) do
                listview:AddLine(v)
            end
        end
        function listview:OnRowRightClick(lineID, pnl)

            self:RemoveLine( lineID )

        end

        local entry = vgui.Create( "DTextEntry", pnl ) -- create the form as a child of frame
        entry:Dock( TOP )
        entry:SetTall(30)
        entry:SetValue("") 

        local addbtn = vgui.Create("DButton", pnl)
        addbtn:Dock(TOP)
        addbtn:SetText("Hinzufügen")
        function addbtn:DoClick()
           listview:AddLine(entry:GetValue())     
           entry:SetValue("")
        end
        return listview
    end



    function AOCRP.Gear:SendToServer(gid,datafields)

        local savedata = {}

        savedata.name = datafields.name:GetValue()
        savedata.description = datafields.description:GetValue()
        local txt, unit = datafields.unitid:GetSelected()
        savedata.unitid = tonumber(unit)
        local txt2, autlist2 = datafields.autolist:GetSelected()
        savedata.autolist = tonumber(autlist2)

        savedata.hp = tonumber(datafields.hp:GetValue())
        savedata.armor = tonumber(datafields.armor:GetValue())
        savedata.runspeed = tonumber(datafields.runspeed:GetValue())

        savedata.models = listViewToTblAndThenToJsonForSave(datafields.models)

        savedata.maxar2 = tonumber(datafields.maxar2:GetValue())
        savedata.maxrpg = tonumber(datafields.maxrpg:GetValue())
        savedata.maxgrenade = tonumber(datafields.maxgrenade:GetValue())
        savedata.maxbandages = tonumber(datafields.maxbandages:GetValue())
        savedata.spawnfunc = datafields.spawnfunc:GetValue()
        savedata.weapons = listViewToTblAndThenToJsonForSave(datafields.weapons)
        savedata.weaponbox = listViewToTblAndThenToJsonForSave(datafields.weaponbox)
        savedata.vehicles = listViewToTblAndThenToJsonForSave(datafields.vehicles)

        savedata.attachments = listViewToTblAndThenToJsonForSave(datafields.attachments)
       
        
        if gid == 0 then
            net.Start("AOCRP.Gear.CreateGear")
            net.WriteTable(savedata)
            net.SendToServer()  
        else
            net.Start("AOCRP.Gear.UpdateGear")
            net.WriteString(gid)
            net.WriteTable(savedata)
            net.SendToServer()
        end
    end

    function AOCRP.Gear:EditGear(gid, geardata)

        if !AOCRP.Perm:HasPermission(LocalPlayer(), "GearEdit") then return end

        --geardata = AOCRP.Gear:UnJSONGearData(geardata)
        if ValidPanel(self.EditFrame) then self.EditFrame:Remove() end

                local datafields = {}

        self.EditFrame = AOCDerma:DefaultFrame(geardata.name.." ("..gid..")")
        self.EditFrame:SetSize( 700, AOCH(1000) ) 
        self.EditFrame:Center()

        --self.EditFrame:SetTitle( "Gear bearbeiten: "..geardata.name.." ("..gid..")" ) 
        if gid == 0 then
            self.EditFrame:SetTitle("Neues Gear")
        end
        self.EditFrame:SetVisible( true ) 
        self.EditFrame:SetDraggable( true ) 
        --self.EditFrame:ShowCloseButton( true ) 
        self.EditFrame:MakePopup()   
        


        local deletebtn = vgui.Create("DButton", self.EditFrame)
        deletebtn:Dock(BOTTOM)
        deletebtn:SetTall(AOCH(40))
        deletebtn:SetText("LÖSCHEN")
        deletebtn:SetColor(Color(100,0,0))
        function deletebtn:DoClick()
    
            if ValidPanel(AOCRP.Gear.EditFrame) then AOCRP.Gear.EditFrame:Remove() end

            AOCDerma:Derma_RequestString( "Gear löschen", "Gebe ELIMINIEREN ein um wirklich zu löschen", "do it", function(text) 
                if text == "ELIMINIEREN" then 
                    net.Start("AOCRP.Gear.DeleteGear")
                    net.WriteString(gid)
                    net.SendToServer()
                end
            end )

        end


        local savebtn = vgui.Create("DButton", self.EditFrame)
        savebtn:Dock(BOTTOM)
        savebtn:SetTall(AOCH(40))
        savebtn:SetText("Speichern")
        function savebtn:DoClick()
            AOCRP.Gear:SendToServer(gid,datafields)
            if ValidPanel(AOCRP.Gear.EditFrame) then AOCRP.Gear.EditFrame:Remove() end

        end

        local savebtn = vgui.Create("DButton", self.EditFrame)
        savebtn:Dock(BOTTOM)
        savebtn:SetTall(AOCH(40))
        savebtn:SetText("Neues Gear mit dem hier als Vorlage erstellen")
        function savebtn:DoClick()
            AOCRP.Gear:EditGear(0, geardata)
        end
        
        local savebtn = vgui.Create("DButton", self.EditFrame)
        savebtn:Dock(BOTTOM)
        savebtn:SetText("Fuck go back")
        savebtn:SetTall(AOCH(40))
        savebtn:DockMargin(0,5,0,0)
        function savebtn:DoClick()
            AOCRP.Gear.EditFrame:Remove()
            LocalPlayer():ConCommand("aocrp_gearedit")
        end
        
        local savebtn = vgui.Create("DButton", self.EditFrame)
        savebtn:Dock(BOTTOM)
        savebtn:SetText("Attachmenttable")
        savebtn:DockMargin(0,5,0,0)
        function savebtn:DoClick()
            AOCRP.Gear:AttachmentTable()
        end
        
        local savebtn = vgui.Create("DButton", self.EditFrame)
        savebtn:Dock(BOTTOM)
        savebtn:SetText("Tastatur aktivieren / deaktivieren")
        savebtn:DockMargin(0,5,0,0)
        function savebtn:DoClick()
            --AOCRP.Gear.EditFrame:SetMouseInputEnabled(false)
            AOCRP.Gear.EditFrame:SetKeyBoardInputEnabled(!AOCRP.Gear.EditFrame:IsKeyboardInputEnabled())
        end
   
        local dataPanel = AOCDerma:ScrollBar(self.EditFrame) 
        dataPanel:Dock(FILL)


        datafields.name = textentry(dataPanel, "Name", geardata.name) 
        datafields.description = textentry(dataPanel, "Description", geardata.description) 
        datafields.hp = textentry(dataPanel, "Health", geardata.hp) 
        datafields.armor = textentry(dataPanel, "Armor", geardata.armor) 
        datafields.runspeed = textentry(dataPanel, "Runspeed", geardata.runspeed) 

        datafields.models = jsoneditor(dataPanel,"Verfügbare Models","Modelpfad",geardata.models)


        datafields.maxar2 = textentry(dataPanel, "Blastermunni", geardata.maxar2) 
        datafields.maxrpg = textentry(dataPanel, "Raketenmunni", geardata.maxrpg) 
        datafields.maxgrenade = textentry(dataPanel, "Granatenmunni", geardata.maxgrenade) 
        datafields.maxbandages = textentry(dataPanel, "Sanitätsmaterial", geardata.maxbandages) 
        datafields.spawnfunc = textentry(dataPanel, "Benutzerdefinierte Spawnfunktion", geardata.spawnfunc) 

        datafields.weapons = jsoneditor(dataPanel,"Waffen (Direktspawn)","Waffenklasse",geardata.weapons)
        datafields.weaponbox = jsoneditor(dataPanel,"Waffenkiste","Waffenklasse",geardata.weaponbox)
        datafields.vehicles = jsoneditor(dataPanel,"Fahrzeuge","Fahrzeugklasse",geardata.vehicles)

        datafields.attachments = jsoneditor(dataPanel,"Waffenattachments","Attachmentklasse",geardata.attachments)

        datafields.unitid = unitchooser(dataPanel,"Zugehörige Einheit", geardata.unitid)


        datafields.autolist = autolistgearchooser(dataPanel, "Autom. Weiterleitung (Muss aktiviert werden !autolist)", geardata.autolist) 

    end



--[[ 
    local function AddGearBtns(pnl,search)
        pnl:Clear()

        local unitCollaps = {}
        for a, b in pairs(AOCRP.Units) do
            local DCollapsible = vgui.Create( "DCollapsibleCategory", pnl )	-- Create a collapsible category
            DCollapsible:SetLabel( b.name )						-- Set the name ( label )
            DCollapsible:Dock(TOP)
            unitCollaps[a] = DCollapsible
        end

        for k, v in pairs(AOCRP.Gears) do
            if string.find(v.name, search:lower() ) then
                local btn = AOCDerma:Button(unitCollaps[v.unitid], v.name, function() AOCRP.Gear:EditGear(v.gearid, v) end, "b")
                --local btn = vgui.Create("DButton", pnl)
                btn:Dock(TOP)

            end
        end
    end
 ]]
    function AOCRP.Gear:EditMenu()

        if !AOCRP.Perm:HasPermission(LocalPlayer(), "GearEdit") then return end

        if ValidPanel(self.EditFrame) then self.EditFrame:Remove() end
        self.EditFrame = AOCDerma:DefaultFrame("Bearbeiten von Gears")
        self.EditFrame:SetSize( 700, 700 ) 
        self.EditFrame:Center()
        --elf.EditFrame:SetTitle( "Bearbeiten von Gears" ) 
        self.EditFrame:SetVisible( true ) 
        self.EditFrame:SetDraggable( true ) 
        --self.EditFrame:ShowCloseButton( true ) 
        self.EditFrame:MakePopup()   
--[[         
        local TextEntry = vgui.Create( "DTextEntry", self.EditFrame ) -- create the form as a child of frame
        TextEntry:Dock( TOP )
        TextEntry:SetTall(30)
        TextEntry:SetUpdateOnType(true)
        function TextEntry:OnValueChange(val)
            AddGearBtns(AOCRP.Gear.EditFrame.btnPnl,val)
        end    ]]
        
        self.EditFrame.btnPnl =  AOCDerma:ScrollBar(self.EditFrame) 
        self.EditFrame.btnPnl:Dock(FILL)
        self.EditFrame.btnPnl:DockMargin(5,5,5,5)
        
        local unitCollaps = {}
        for a, b in pairs(AOCRP.Units) do
            local DCollapsible = vgui.Create( "DCollapsibleCategory", self.EditFrame.btnPnl )	-- Create a collapsible category
            DCollapsible:SetLabel( "" )						-- Set the name ( label )
            DCollapsible:Dock(TOP)
            DCollapsible:SetExpanded(false)
            DCollapsible.NewLabel = b.name
            DCollapsible.Paint = function() end
            DCollapsible.Header:SetTall(AOCH(40))
            DCollapsible.Header.Paint = function(self, w,h)
                draw.SimpleText( DCollapsible.NewLabel, PIXEL.UI.RegisteredFonts["AOCRP.ScoreBoard.Unit"], w/2, h/2, AOCDerma:HexToColor(b.colorhex), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                surface.SetDrawColor(Color(255,255,255,10))
                surface.DrawRect(0, h-1, w, 1)
            end
            unitCollaps[a] = DCollapsible
        end

        for k, v in pairs(AOCRP.Gears) do
       
                local btn = AOCDerma:Button(unitCollaps[v.unitid], v.name, function() AOCRP.Gear:EditGear(v.gearid, v) end, "b")
                --local btn = vgui.Create("DButton", pnl)
                btn:Dock(TOP)
        end
    end

concommand.Add( "aocrp_gearedit", function( ply, cmd, args )
    
    if !AOCRP.Perm:HasPermission(LocalPlayer(), "GearEdit") then
        ply:ChatPrint("*** Zugriff verweigert.")
        return 
    end

    AOCRP.Gear:EditMenu()

end )


concommand.Add( "aocrp_attachm", function( ply, cmd, args )
    
    if !AOCRP.Perm:HasPermission(LocalPlayer(), "GearEdit") then
        ply:ChatPrint("*** Zugriff verweigert.")
        return 
    end

   
    AOCRP.Gear:AttachmentTable()

end )
















    function AOCRP.Gear:EditUnit(unitdata)

        if !AOCRP.Perm:HasPermission(LocalPlayer(), "GearEdit") then return end


        if ValidPanel(self.EditFrame) then self.EditFrame:Remove() end


        self.EditFrame = vgui.Create( "DFrame" )
        self.EditFrame:SetSize( 500, 700 ) 
        self.EditFrame:Center()
        self.EditFrame:SetTitle( "Einheit bearbeiten: "..unitdata.name.." ("..unitdata.unitid..")" ) 
        self.EditFrame:SetVisible( true ) 
        self.EditFrame:SetDraggable( true ) 
        self.EditFrame:ShowCloseButton( true ) 
        self.EditFrame:MakePopup()   

        local dataPanel = vgui.Create("DScrollPanel", self.EditFrame)
        dataPanel:Dock(FILL)


        local unitcount = textentry(dataPanel, "Anzahl der Einheitsmitglieder", "...")
        AOCRP.API:Request("getunitmembercount", function(data) unitcount:SetValue(data["count"]) end, {["unitid"] = unitdata.unitid})

    end







    
    local function AddUnitBtns(pnl,search)
        pnl:Clear()
        for k, v in pairs(AOCRP.Units) do
            if string.find( v.name:lower(), search:lower() ) then
                local btn = vgui.Create("DButton", pnl)
                btn:Dock(TOP)
                btn:SetText(v.name)
                function btn:DoClick()
                    AOCRP.Gear:EditUnit(v) 
                end
            end
        end
    end



    function AOCRP.Gear:ShowUnits()

            if !AOCRP.Perm:HasPermission(LocalPlayer(), "GearEdit") then return end

        if ValidPanel(self.EditFrame) then self.EditFrame:Remove() end
        self.EditFrame = vgui.Create( "DFrame" )
        self.EditFrame:SetSize( 500, 700 ) 
        self.EditFrame:Center()
        self.EditFrame:SetTitle( "Administrative Einheitsverwaltung" ) 
        self.EditFrame:SetVisible( true ) 
        self.EditFrame:SetDraggable( true ) 
        self.EditFrame:ShowCloseButton( true ) 
        self.EditFrame:MakePopup()   
        
        local TextEntry = vgui.Create( "DTextEntry", self.EditFrame ) -- create the form as a child of frame
        TextEntry:Dock( TOP )
        TextEntry:SetTall(30)
        TextEntry:SetUpdateOnType(true)
        function TextEntry:OnValueChange(val)
            AddUnitBtns(AOCRP.Gear.EditFrame.btnPnl,val)
        end   
        
        self.EditFrame.btnPnl = vgui.Create("DScrollPanel", self.EditFrame)
        self.EditFrame.btnPnl:Dock(FILL)
        self.EditFrame.btnPnl:DockMargin(5,5,5,5)
        
        AddUnitBtns(self.EditFrame.btnPnl,"")
    end

    --AOCRP.Gear:ShowUnits()



    local function AddAttachmentButtons(pnl, txt)
        pnl:Clear()
        
        for attName, attTbl in SortedPairsByMemberValue(ArcCW.AttachmentTable, "PrintName") do
 
            local name = attTbl.PrintName 

            if attTbl.AbbrevName then
                name = attTbl.AbbrevName
            end

            if string.find( name:lower(), txt:lower() ) then
                --print(attTbl.PrintName)
                local btn = vgui.Create("DButton", pnl)
                btn:Dock(TOP)
                btn:SetTall(AOCH(50))
                btn:DockMargin(5,5,5,5)
                btn:SetText("")
                function btn:Paint(w,h)
                    local img = attTbl.Icon

                    draw.RoundedBox(0,0,0,w,h,Color(0,0,0))
                    if img then
                        surface.SetDrawColor(Color(255,255,255))
                        surface.SetMaterial(img)
                        surface.DrawTexturedRect(AOCW(2), 0, h, h)
                    end

                    draw.DrawText(name, "DermaDefault", w/2, h/2-10, Color(255,255,255),TEXT_ALIGN_CENTER )

                end
                function btn:DoClick()
                   
                    SetClipboardText( attName )

                    if ValidPanel(AOCRP.Gear.DataFrame) then AOCRP.Gear.DataFrame:Remove() end
                    --AOCRP.Gear:EditUnit(v) 
                end
                function btn:DoRightClick()
                    PrintTable(attTbl)

                end
            end
        end
    end

    function AOCRP.Gear:AttachmentTable()

        if ValidPanel(self.DataFrame) then self.DataFrame:Remove() end
        self.DataFrame = vgui.Create( "DFrame" )
        self.DataFrame:SetSize( 500, 700 ) 
        self.DataFrame:Center()
        self.DataFrame:SetTitle( "Attachments" ) 
        self.DataFrame:SetVisible( true ) 
        self.DataFrame:SetDraggable( true ) 
        self.DataFrame:ShowCloseButton( true ) 
        self.DataFrame:MakePopup()   


        local TextEntry = vgui.Create( "DTextEntry", self.DataFrame ) -- create the form as a child of frame
        TextEntry:Dock( TOP )
        TextEntry:SetTall(30)
        TextEntry:SetUpdateOnType(true)
        function TextEntry:OnValueChange(val)
            AddAttachmentButtons(AOCRP.Gear.DataFrame.btnPnl, val)
        end   

        self.DataFrame.btnPnl = vgui.Create("DScrollPanel", self.DataFrame)
        self.DataFrame.btnPnl:Dock(FILL)
        self.DataFrame.btnPnl:DockMargin(5,5,5,5)

        AddAttachmentButtons(AOCRP.Gear.DataFrame.btnPnl, "")

    end

end




--gamemodes/starwarsrp/gamemode/modules/gamemec/sh_wepholsters.lua:
if not ConVarExists("sv_weapon_holsters") then
	CreateConVar("sv_weapon_holsters",1, { FCVAR_REPLICATED, FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE }, "Enable Weapon Holsters (server side)" )
end
WepHolster = WepHolster or {}
WepHolster.HL2Weps = {
	["weapon_pistol"] = "Pistol",
	["weapon_357"] = "357",
	["weapon_frag"] = "Frag Grenade",
	["weapon_slam"] = "SLAM",
	["weapon_crowbar"] = "Crowbar",
	["weapon_stunstick"] = "Stunstick",
	["weapon_shotgun"] = "Shotgun",
	["weapon_rpg"] = "RPG Launcher",
	["weapon_smg1"] = "SMG",
	["weapon_ar2"] = "AR2",
	["weapon_crossbow"] = "Crossbow",
	["weapon_physcannon"] = "Gravity Gun",
	["weapon_physgun"] = "Physics Gun"
}

-- sv_wepaonholsters
if SERVER then
    
    WepHolster.defData = {}

    WepHolster.wepInfo = WepHolster.wepInfo or {}
    util.AddNetworkString("sendWHData")
    util.AddNetworkString("sendWholeWHData")
    util.AddNetworkString("applyWepHolsterData")
    util.AddNetworkString("reloadWH")
    util.AddNetworkString("deleteWHData")
    util.AddNetworkString("reloadWholeWH")
    util.AddNetworkString("resetWHDataToDefault")
    util.AddNetworkString("resetWholeWHDataToDefault")
    util.AddNetworkString("WepHolsters_Settings")

    function WepHolster.setWHData(wep, tbl)
        file.Write("wepholster/" .. wep .. ".txt", util.TableToJSON(tbl, true))
        WepHolster.wepInfo[wep] = tbl
    end

    --[[
    local function InitOfInit()
        for k, v in pairs(WepHolster.defData) do
            WepHolster.setWHData(k, v)
        end
    end
    hook.Add("Initialize", "wepHolstersInit", function()
        if file.IsDir("wepholster", "DATA") then
            local files, dirs = file.Find("wepholster/*.txt", "DATA")

            for k, v in pairs(files) do
                WepHolster.wepInfo[string.sub(v, 1, #v - 4)] = util.JSONToTable(file.Read("wepholster/" .. v))
            end
        else
            file.CreateDir("wepholster", "DATA")
            InitOfInit()
        end
    end)
    ]]
    local function checkValidSWEP()
        if not file.IsDir("wepholster", "DATA") then
            file.CreateDir("wepholster", "DATA")

            for k, v in pairs(WepHolster.defData) do
                file.Write("wepholster/" .. k .. ".txt", util.TableToJSON(v, true))
            end
        end

        local files, dirs = file.Find("wepholster/*.txt", "DATA")

        for k, v in pairs(files) do
            local wepclass = string.sub(v, 1, #v - 4)
            local swep = weapons.Get(wepclass)

            if swep or WepHolster.HL2Weps[wepclass] or not WepHolster.defData[wepclass] then
                WepHolster.wepInfo[wepclass] = util.JSONToTable(file.Read("wepholster/" .. v))
            end
        end
    end

    hook.Add("Initialize", "Initialize Weapon Holsters", checkValidSWEP)

    function WepHolster.sendWholeWHData(ply)
        net.Start("sendWholeWHData")
        net.WriteTable(WepHolster.wepInfo)
        net.Send(ply)
    end

    hook.Add("PlayerInitialSpawn", "sendWholeWHData", WepHolster.sendWholeWHData)

    net.Receive("resetWholeWHDataToDefault", function(len, ply)
        if ply:IsSuperAdmin() then
            local files, dirs = file.Find("wepholster/*", "DATA")

            for k, v in pairs(files) do
                file.Delete("wepholster/" .. v)
                --print(v)
            end
            file.Delete("wepholster")
            WepHolster.wepInfo = {}
            checkValidSWEP()
            net.Start("sendWholeWHData")
            net.WriteTable(WepHolster.wepInfo)
            net.Broadcast()
        end
    end)

    net.Receive("resetWHDataToDefault", function(len, ply)
        if ply:IsSuperAdmin() then
            local class = net.ReadString()

            if WepHolster.defData[class] then
                net.Start("sendWHData")
                net.WriteString(class)
                net.WriteTable(WepHolster.defData[class])
                net.Send(ply)
            end
        end
    end)

    net.Receive("reloadWholeWH", function(len, ply)
        WepHolster.sendWholeWHData(ply)
    end)

    net.Receive("applyWepHolsterData", function(len, ply)
        if ply:IsSuperAdmin() then
            local class = net.ReadString()
            local weptbl = net.ReadTable()
            weptbl.notSavedYet = nil
            weptbl.isEditing = nil
            WepHolster.setWHData(class, weptbl)
            net.Start("sendWHData")
            net.WriteString(class)
            net.WriteTable(WepHolster.wepInfo[class])
            net.Broadcast()
        end
    end)

    net.Receive("reloadWH", function(len, ply)
        if ply:IsSuperAdmin() then
            local class = net.ReadString()

            if WepHolster.wepInfo[class] then
                net.Start("sendWHData")
                net.WriteString(class)
                net.WriteTable(WepHolster.wepInfo[class])
                net.Send(ply)
            end
        end
    end)

    net.Receive("deleteWHData", function(len, ply)
        if ply:IsSuperAdmin() then
            local class = net.ReadString()
            WepHolster.wepInfo[class] = nil

            if file.Exists("wepholster/" .. class .. ".txt", "DATA") then
                file.Delete("wepholster/" .. class .. ".txt")
            end

            net.Start("sendWHData")
            net.WriteString(class)
            net.WriteTable({})
            net.Broadcast()
        end
    end)

    function WepHolster.CanEditSetting(ply, con, var)
        if not ply:IsSuperAdmin() then
            ply:PrintMessage(HUD_PRINTCENTER, "You don't have access to server settings.")

            return
        end

        if not ConVarExists(con) then
            return
        end

        print("[Weapon Holsters] " .. ply:Nick() .. " (" .. ply:SteamID() .. ") changed " .. con .. " to " .. tostring(var))
        con = GetConVar(con)
        con:SetString(var)
    end

    local whitelist = {}
    whitelist["sv_weapon_holsters"] = true

    net.Receive("WepHolsters_Settings", function(len, ply)
        if not ply then
            return
        end

        if (ply.WH_LAST or 0) > SysTime() then
            return
        end

        ply.WH_LAST = SysTime() + 0.2
        local con = net.ReadString()
        local arg = net.ReadString()

        if not con then
            return
        end

        if not whitelist[con] then
            return
        end

        WepHolster.CanEditSetting(ply, con, arg or nil)
    end)
end

--cl_weaponholsters
if CLIENT then

    CreateClientConVar("cl_weapon_holsters", "1", true, false, "Enable Weapon Holsters (client side)")
    WepHolster = WepHolster or {}
    WepHolster.wepInfo = WepHolster.wepInfo or {}

    net.Receive("sendWholeWHData", function(len)
        WepHolster.wepInfo = net.ReadTable()
    end)

    net.Receive("sendWHData", function(len)
        local class = net.ReadString()
        local tbl = net.ReadTable()
        WepHolster.wepInfo[class] = tbl.Model and tbl or nil

        if not tbl.Model then
            for pl, weps in pairs(WepHolster.HolsteredWeps) do
                local ply = Entity(pl)

                for cls, wep in pairs(weps) do
                    if cls == class then
                        wep:Remove()
                        WepHolster.HolsteredWeps[pl][cls] = nil
                    end
                end
            end
        end
    end)

    WepHolster.HolsteredWeps = WepHolster.HolsteredWeps or {}

    local function CalcOffset(pos, ang, off)
        return pos + ang:Right() * off.x + ang:Forward() * off.y + ang:Up() * off.z
    end

    local function cdwh()
        return WepHolster.wepInfo and WepHolster.HolsteredWeps and GetConVar("cl_weapon_holsters"):GetBool() and GetConVar("sv_weapon_holsters"):GetBool()
    end

    hook.Add("PostPlayerDraw", "WeaponHolster", function(ply)
        if not cdwh() then
            return
        end

        if IsValid(ply) and ply:Alive() then
            for wepclass, model in pairs(WepHolster.HolsteredWeps[ply:EntIndex()] or {}) do
                if not WepHolster.wepInfo[wepclass] then
                    return
                end

                local bone = ply:LookupBone(WepHolster.wepInfo[wepclass].Bone)

                if not bone then
                    return
                end

                local matrix = ply:GetBoneMatrix(bone)

                if not matrix then
                    return
                end

                local pos = matrix:GetTranslation()
                local ang = matrix:GetAngles()
                pos = CalcOffset(pos, ang, WepHolster.wepInfo[wepclass].BoneOffset[1])
                model:SetRenderOrigin(pos)
                ang:RotateAroundAxis(ang:Forward(), WepHolster.wepInfo[wepclass].BoneOffset[2].p)
                ang:RotateAroundAxis(ang:Up(), WepHolster.wepInfo[wepclass].BoneOffset[2].y)
                ang:RotateAroundAxis(ang:Right(), WepHolster.wepInfo[wepclass].BoneOffset[2].r)
                model:SetRenderAngles(ang)
                model:DrawModel()
            end
        end
    end)

    hook.Add("Think", "WeaponHolster", function()
        if not cdwh() then
            return
        end

        for _, ply in pairs(player.GetAll()) do
            if IsValid(ply) and ply:Alive() then
                for k, v in pairs(ply:GetWeapons()) do
                    local class = v:GetClass()
                    local plyid = ply:EntIndex()
                    WepHolster.HolsteredWeps[plyid] = WepHolster.HolsteredWeps[plyid] or {}

                    if WepHolster.wepInfo[class] and ply:GetActiveWeapon() ~= v and not WepHolster.HolsteredWeps[plyid][class] then
                        WepHolster.HolsteredWeps[plyid][class] = ClientsideModel(WepHolster.wepInfo[class].Model, RENDERGROUP_OPAQUE)

                        if not IsValid(WepHolster.HolsteredWeps[plyid][class]) then
                            SafeRemoveEntity(WepHolster.HolsteredWeps[plyid][class]) -- just in case.
                            WepHolster.HolsteredWeps[plyid][class] = nil

                            return
                        end

                        WepHolster.HolsteredWeps[plyid][class]:SetNoDraw(true)

                        if WepHolster.wepInfo[class].isEditing then
                            WepHolster.HolsteredWeps[plyid][class]:SetMaterial("models/wireframe")
                            --print("wireframe화 think")
                            --print(WepHolster.wepInfo[class].isEditing)
                        end
                    end
                end
            end
        end

        -- 필요없는 CSEnt 찾아서 삭제
        for pl, weps in pairs(WepHolster.HolsteredWeps) do
            local ply = Entity(pl)

            for class, wep in pairs(weps) do
                if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() or (IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == class) or not IsValid(ply:GetWeapon(class)) then
                    wep:Remove() -- 삭제
                    WepHolster.HolsteredWeps[pl][class] = nil

                    return
                end
            end
        end
    end)
end


-- wh_gui.lua
if CLIENT then

    local Menu = {
        Main = {},
        Editor = {}
    }

    local playerBones = {"ValveBiped.Bip01_Head1", "ValveBiped.Bip01_Pelvis", "ValveBiped.Bip01_Spine", "ValveBiped.Bip01_Spine1", "ValveBiped.Bip01_Spine2", "ValveBiped.Bip01_Spine4", "ValveBiped.Anim_Attachment_RH", "ValveBiped.Bip01_R_Hand", "ValveBiped.Bip01_R_Forearm", "ValveBiped.Bip01_R_UpperArm", "ValveBiped.Bip01_R_Clavicle", "ValveBiped.Bip01_R_Foot", "ValveBiped.Bip01_R_Toe0", "ValveBiped.Bip01_R_Thigh", "ValveBiped.Bip01_R_Calf", "ValveBiped.Bip01_R_Shoulder", "ValveBiped.Bip01_R_Elbow", "ValveBiped.Bip01_Neck1", "ValveBiped.Anim_Attachment_LH", "ValveBiped.Bip01_L_Hand", "ValveBiped.Bip01_L_Forearm", "ValveBiped.Bip01_L_UpperArm", "ValveBiped.Bip01_L_Clavicle", "ValveBiped.Bip01_L_Foot", "ValveBiped.Bip01_L_Toe0", "ValveBiped.Bip01_L_Thigh", "ValveBiped.Bip01_L_Calf", "ValveBiped.Bip01_L_Shoulder", "ValveBiped.Bip01_L_Elbow"}

    local function KeyboardOn(pnl)
        if (IsValid(Menu.Main.Frame) and IsValid(pnl) and pnl:HasParent(Menu.Main.Frame)) then
            Menu.Main.Frame:SetKeyboardInputEnabled(true)
        end
    end

    hook.Add("OnTextEntryGetFocus", "lf_weapon_properties_editor_keyboard_on", KeyboardOn)

    local function KeyboardOff(pnl)
        if (IsValid(Menu.Main.Frame) and IsValid(pnl) and pnl:HasParent(Menu.Main.Frame)) then
            Menu.Main.Frame:SetKeyboardInputEnabled(false)

            if pnl.OnValueChange then
                pnl:OnValueChange()
            end
        end
    end

    hook.Add("OnTextEntryLoseFocus", "lf_weapon_properties_editor_keyboard_off", KeyboardOff)
    -- Blur Code by: https://facepunch.com/member.php?u=237675
    local blur = Material("pp/blurscreen")

    local function DrawBlur(panel, amount)
        local x, y = panel:LocalToScreen(0, 0)
        local scrW, scrH = ScrW(), ScrH()
        surface.SetDrawColor(255, 255, 255)
        surface.SetMaterial(blur)

        for i = 1, 3 do
            blur:SetFloat("$blur", (i / 3) * (amount or 6))
            blur:Recompute()
            render.UpdateScreenEffectTexture()
            surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
        end
    end

    local function removeHolstWep(class)
        for pl, weps in pairs(WepHolster.HolsteredWeps) do
            for cls, wep in pairs(weps) do
                if class == "" or cls == class then
                    wep:Remove()
                    WepHolster.HolsteredWeps[pl][cls] = nil
                end
            end
        end
    end

    local function setEditing(class, bool)
        if class ~= "" then
            if WepHolster.wepInfo[class] then
                WepHolster.wepInfo[class].isEditing = bool
            end
        else
            for k, v in pairs(WepHolster.wepInfo) do
                WepHolster.wepInfo[k].isEditing = bool
            end
        end

        for pl, weps in pairs(WepHolster.HolsteredWeps) do
            for cls, wep in pairs(weps) do
                if cls == class or class == "" then
                    if bool then
                        wep:SetMaterial("models/wireframe")
                        --print("wireframe화 gui")
                        --print(WepHolster.wepInfo[cls].isEditing)
                        --print("wireframe 해제 gui")
                        --print(WepHolster.wepInfo[cls].isEditing)
                    else
                        wep:Remove()
                        WepHolster.HolsteredWeps[pl][cls] = nil
                        WepHolster.wepInfo[cls].isEditing = nil
                    end
                end
            end
        end
    end

    function Menu.Editor:Init(class)
        local Frame = vgui.Create("DFrame", Menu.Main.Frame)
        local fw, fh = 600, 350
        local pw, ph = fw - 10, fh - 34
        Frame:SetPos(ScrW() - fw - 10, (ScrH() / 2) - (fh / 2))
        Frame:SetSize(fw, fh)
        Frame:SetTitle(class)
        Frame:SetVisible(true)
        Frame:SetDraggable(true)
        Frame:SetScreenLock(false)
        Frame:ShowCloseButton(true)
        Frame:MakePopup()
        Frame:SetKeyboardInputEnabled(false)

        function Frame:Paint(w, h)
            DrawBlur(self, 2)
            draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200))

            return true
        end

        function Frame.lblTitle:Paint(w, h)
            draw.SimpleTextOutlined(Frame.lblTitle:GetText(), "DermaDefaultBold", 1, 2, Color(255, 255, 255, 255), 0, 0, 1, Color(0, 0, 0, 255))

            return true
        end

        local pnl = Frame:Add("DPanel")
        pnl:Dock(FILL)
        pnl:DockPadding(10, 10, 10, 10)
        local prop = pnl:Add("DCategoryList")
        prop:Dock(FILL)

        local function AddLineText(list, text, val, class)
            local line = list:Add("DPanel")
            line:DockPadding(5, 2, 5, 2)
            line:SetDrawBackground(false)
            local id

            if val then
                local lbl = line:Add("DLabel")
                lbl:Dock(LEFT)
                lbl:SetWide(239)
                lbl:SetDark(true)
                lbl:SetText(text)
                id = line:Add("DTextEntry")
                id:Dock(FILL)
                id:SetText(val or "")
            else
                local lbl = line:Add("DLabel")
                lbl:Dock(FILL)
                lbl:SetText(text)
            end

            return line, id
        end

        local function AddLineInt(list, text, val, min, max)
            local line = list:Add("DPanel")
            line:DockPadding(5, 2, 5, 2)
            line:SetPaintBackground(false)
            local id

            if val then
                id = line:Add("DNumSlider")
                id:Dock(FILL)
                id:SetDark(true)
                id:SetDecimals(3)
                id:SetMinMax(min, max)
                id:SetText(text)
                id:SetValue(val or 0)
            else
                local lbl = line:Add("DLabel")
                lbl:Dock(FILL)
                lbl:SetText(text)
            end

            return line, id
        end

        local cat = prop:Add(class)
        local list = vgui.Create("DListLayout")
        cat:SetContents(list)
        local line, rModel = AddLineText(list, "Model:", WepHolster.wepInfo[class].Model, class)

        rModel.OnValueChange = function(val)
            val = rModel:GetValue()
            WepHolster.wepInfo[class].Model = val
            setEditing(class, true)
            removeHolstWep(class)
        end

        local line, rBone = AddLineText(list, "Bone:", WepHolster.wepInfo[class].Bone)
        WepHolster.lookingBone = WepHolster.wepInfo[class].Bone

        if rBone then
            rBone.OnValueChange = function(val)
                val = rBone:GetValue()

                if table.HasValue(playerBones, val) then
                    WepHolster.wepInfo[class].Bone = val
                    setEditing(class, true)
                    WepHolster.lookingBone = val
                end
            end

            local c = line:Add("DComboBox")
            c:Dock(RIGHT)
            c:SetWide(40)
            c:SetSortItems(false)
            c:SetValue("...")

            for _, v in pairs(playerBones) do
                c:AddChoice(v)
            end

            function c:OnSelect(index, value)
                rBone:SetText(value)
                rBone:OnValueChange()
                c:SetValue("...")
            end
        end

        local line, rVectorX = AddLineInt(list, "Position x:", WepHolster.wepInfo[class].BoneOffset[1].x, -20, 20, class)

        rVectorX.OnValueChanged = function(value)
            WepHolster.wepInfo[class].BoneOffset[1].x = rVectorX:GetValue()
            setEditing(class, true)
        end

        local line, rVectorY = AddLineInt(list, "Position y:", WepHolster.wepInfo[class].BoneOffset[1].y, -20, 20, class)

        rVectorY.OnValueChanged = function(value)
            WepHolster.wepInfo[class].BoneOffset[1].y = rVectorY:GetValue()
            setEditing(class, true)
        end

        local line, rVectorZ = AddLineInt(list, "Position z:", WepHolster.wepInfo[class].BoneOffset[1].z, -20, 20, class)

        rVectorZ.OnValueChanged = function(value)
            WepHolster.wepInfo[class].BoneOffset[1].z = rVectorZ:GetValue()
            setEditing(class, true)
        end

        local line, rAngleP = AddLineInt(list, "Angle pitch:", WepHolster.wepInfo[class].BoneOffset[2].p, -180, 180, class)

        rAngleP.OnValueChanged = function(value)
            WepHolster.wepInfo[class].BoneOffset[2].p = rAngleP:GetValue()
            setEditing(class, true)
        end

        local line, rAngleY = AddLineInt(list, "Angle yaw:", WepHolster.wepInfo[class].BoneOffset[2].y, -180, 180, class)

        rAngleY.OnValueChanged = function(value)
            WepHolster.wepInfo[class].BoneOffset[2].y = rAngleY:GetValue()
            setEditing(class, true)
        end

        local line, rAngleR = AddLineInt(list, "Angle roll:", WepHolster.wepInfo[class].BoneOffset[2].r, -180, 180, class)

        rAngleR.OnValueChanged = function(value)
            WepHolster.wepInfo[class].BoneOffset[2].r = rAngleR:GetValue()
            setEditing(class, true)
        end

        local subpnl = pnl:Add("DPanel")
        subpnl:Dock(BOTTOM)
        subpnl:DockMargin(0, 20, 0, 0)
        subpnl:SetHeight(20)
        subpnl:SetDrawBackground(false)
        local lw = (pw - 10) / 2 - 10
        local b = subpnl:Add("DComboBox")
        b:Dock(LEFT)
        b:SetWide(lw)
        b:SetValue("Reset")
        b:SetSortItems(false)
        b:AddChoice("to saved data if available")
        b:AddChoice("to default if available")

        b.OnSelect = function(index, value, data)
            Frame:Close()

            if value == 2 then
                local oldwhdata = WepHolster.wepInfo[class]
                net.Start("resetWHDataToDefault")
                net.WriteString(class)
                net.SendToServer()

                timer.Simple(0.1, function()
                    local different

                    for k, v in pairs(WepHolster.wepInfo[class]) do
                        if (k == "Model" or k == "Bone") and string.lower(oldwhdata[k]) ~= string.lower(v) then
                            different = true
                            print(k .. ": " .. v)
                            --	print(_..": "..vec_ang)
                        elseif k == "BoneOffset" then
                            for _, vec_ang in pairs(v) do
                                if vec_ang ~= oldwhdata[k][_] then
                                    different = true
                                end
                            end
                        end
                    end

                    -- '==' operator is not working on table.. fuck.
                    if different then
                        setEditing(class, true)
                    end
                end)
            elseif not WepHolster.wepInfo[class].notSavedYet then
                net.Start("reloadWH")
                net.WriteString(class)
                net.SendToServer()
                setEditing(class, false)
            end

            timer.Simple(0.1, function()
                Menu.Editor:Init(class)
                removeHolstWep(class)
            end)
        end

        local b = subpnl:Add("DComboBox")
        b:Dock(RIGHT)
        b:SetWide(lw)
        b:SetValue("Delete")
        b:AddChoice("Are you sure?")

        b.OnSelect = function(index, value, data)
            net.Start("deleteWHData")
            net.WriteString(class)
            net.SendToServer()

            timer.Simple(0.1, function()
                Menu.Main.Frame:Close()
                Menu.Main:Init()
            end)
        end

        local b = pnl:Add("DButton")
        b:Dock(BOTTOM)
        b:DockMargin(0, 10, 0, 0)
        b:SetHeight(30)
        b:SetText("Apply Changes")

        b.DoClick = function()
            setEditing(class, false)
            WepHolster.wepInfo[class].notSavedYet = nil
            net.Start("applyWepHolsterData")
            net.WriteString(class)
            net.WriteTable(WepHolster.wepInfo[class])
            net.SendToServer()
            Frame:Close()
        end

        Frame.OnClose = function()
            --[[
            net.Start("reloadWH")
            net.WriteString(class)
            net.SendToServer()
            Menu.Main.Frame:Close()
            timer.Simple(0.1, function()
                removeHolstWep(class)
                Menu.Main:Init()
            end)
            ]]
            WepHolster.lookingBone = nil
        end
    end

    local function addWeapon(class, model)
        WepHolster.wepInfo[class] = WepHolster.wepInfo[class] or {
            Model = model or "models/weapons/w_rif_ak47.mdl",
            Bone = "ValveBiped.Bip01_R_Clavicle",
            BoneOffset = {Vector(13, 4, 5), Angle(90, 0, 100)},
            notSavedYet = true
        }

        Menu.Main.Frame:Close()
        Menu.Main:Init()
        Menu.Editor:Init(class)
        setEditing(class, true)
    end

    function Menu.Main:Init()
        Menu.Main.Frame = vgui.Create("DFrame")
        local Frame = Menu.Main.Frame
        local fw, fh = 400, ScrH() - 20
        local pw, ph = fw - 10, fh - 34
        Frame:SetPos(10, 10)
        Frame:SetSize(fw, fh)
        Frame:SetTitle("Weapon Holsters Editor")
        Frame:SetVisible(true)
        Frame:SetDraggable(true)
        Frame:SetScreenLock(false)
        Frame:ShowCloseButton(true)
        Frame:MakePopup()
        Frame:SetKeyboardInputEnabled(false)

        function Frame:Paint(w, h)
            DrawBlur(self, 2)
            draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200))

            return true
        end

        function Frame.lblTitle:Paint(w, h)
            draw.SimpleTextOutlined(Frame.lblTitle:GetText(), "DermaDefaultBold", 1, 2, Color(255, 255, 255, 255), 0, 0, 1, Color(0, 0, 0, 255))

            return true
        end

        local pnl = Frame:Add("DPanel")
        pnl:Dock(FILL)
        pnl:DockPadding(10, 10, 10, 10)
        local b = pnl:Add("DButton")
        b:Dock(TOP)
        b:DockMargin(0, 0, 0, 1)
        b:SetHeight(25)
        b:SetText("Add weapon by class:")

        b.DoClick = function()
            local name = tostring(Menu.Main.WeaponEntry:GetValue())

            if name == "" then
                return
            end

            addWeapon(name)
        end

        Menu.Main.WeaponEntry = pnl:Add("DTextEntry")
        Menu.Main.WeaponEntry:Dock(TOP)
        Menu.Main.WeaponEntry:DockMargin(0, 0, 0, 10)
        Menu.Main.WeaponEntry:SetHeight(20)
        Menu.Main.WeaponEntry:SetTooltip("Just right-click on the weapon icon in the spawn menu, click Copy to Clipboard, and paste it here.")
        --[[
        local help = pnl:Add("DLabel") -- Fuck you, I'll use SetTooltip instead.
        help:Dock(TOP)
        help:DockMargin(0, 0, 0, 10)
        help:SetHeight(26)
        help:SetText("Just right-click on the weapon icon in the spawn menu,\nclick Copy to Clipboard, and paste it here.")
        ]]
        b = pnl:Add("DButton")
        b:Dock(TOP)
        b:DockMargin(0, 0, 0, 10)
        b:SetHeight(24)
        b:SetText("Add weapon you currently holding")

        b.DoClick = function()
            local weapon = LocalPlayer():GetActiveWeapon()

            if IsValid(weapon) then
                addWeapon(weapon:GetClass(), weapon:GetWeaponWorldModel())
            end
        end

        --[[
        local help = pnl:Add("DLabel")
        help:Dock(TOP)
        help:DockMargin(0, 0, 0, 5)
        help:SetHeight(13)
        help:SetText("Click the bar to sort the list, and double click the weapon to edit:")
    ]]
        Menu.Main.WeaponList = pnl:Add("DListView")
        Menu.Main.WeaponList:Dock(FILL)
        Menu.Main.WeaponList:SetMultiSelect(false)
        Menu.Main.WeaponList:AddColumn("Category")
        Menu.Main.WeaponList:AddColumn("Name")
        Menu.Main.WeaponList:AddColumn("Class")
        Menu.Main.WeaponList:SetTooltip("Click the bar to sort the list, and double click the weapon to edit.")

        function Menu.Main.WeaponList:DoDoubleClick(id, sel)
            local wepclass = tostring(sel:GetValue(3))

            if WepHolster.wepInfo[wepclass] then
                Menu.Editor:Init(wepclass)
            end
        end

        function Menu.Main.WeaponList:Populate()
            self:Clear()

            for k, v in pairs(WepHolster.wepInfo) do
                local swep = weapons.Get(k)
                self:AddLine(swep and swep.Category or "Other", swep and swep.PrintName or WepHolster.HL2Weps[k] or k, k)
            end

            self:SortByColumn(1)
        end

        Menu.Main.WeaponList:Populate()
        local credit = pnl:Add("DLabel")
        credit:Dock(BOTTOM)
        credit:DockMargin(0, 10, 0, 0)
        credit:SetHeight(13)
        credit:SetText("Made by Polyester Duck")
        local b = pnl:Add("DComboBox")
        b:Dock(BOTTOM)
        b:DockMargin(0, 10, 0, 0)
        b:SetHeight(20)
        b:SetValue("RESET EVERYTHING TO DEFAULT")
        b:AddChoice("ARE YOU REALLY SURE?")

        b.OnSelect = function(index, value, data)
            setEditing("", false)
            net.Start("resetWholeWHDataToDefault")
            net.SendToServer()
            Frame:Close()
            timer.Simple(0.1, Menu.Main.Init)
        end

        Frame.OnClose = function()
            --[[
            net.Start("reloadWholeWH")
            net.SendToServer()
            for pl, weps in pairs(WepHolster.HolsteredWeps) do
                for cls, wep in pairs(weps) do
                    wep:Remove()
                    WepHolster.HolsteredWeps[pl][cls] = nil
                end
            end
            ]]
            WepHolster.lookingBone = nil
        end
    end

    function Menu.Toggle()
        if LocalPlayer():IsSuperAdmin() then
            if IsValid(Menu.Main.Frame) then
                Menu.Main.Frame:Close()
            else
                Menu.Main:Init()
            end
        else
            if IsValid(Menu.Main.Frame) then
                Menu.Main.Frame:Close()
            end
        end
    end

    concommand.Add("weapon_holsters_editor", Menu.Toggle)

    local function clientTrickBox(panel, con_name, func_onchange)
        local con = GetConVar(con_name)

        if not con then
            return
        end

        local tickbox = vgui.Create("DCheckBoxLabel", panel)
        tickbox:SetText(con:GetHelpText() or "Unknown setting.")
        tickbox:SetValue(con:GetBool())
        tickbox.con_name = con_name
        tickbox:SetDark(true)

        function tickbox:OnChange(b)
            RunConsoleCommand(self.con_name, b and "1" or "0")

            if func_onchange then
                func_onchange()
            end
        end

        function tickbox:Think()
            if not self.con_name then
                return
            end

            local ucon = GetConVar(self.con_name)

            if (ucon:GetBool() or true) ~= self:GetValue() then
                self:SetChecked(ucon:GetBool())
            end
        end

        panel:AddItem(tickbox)
    end

    local function requestSetting(con, arg)
        if type(arg) == "boolean" then
            arg = arg and "1" or "0"
        end

        net.Start("WepHolsters_Settings")
        net.WriteString(con)
        net.WriteString(arg)
        net.SendToServer()
    end

    local function adminTrickBox(panel, con_name)
        local con = GetConVar(con_name)

        if not con then
            return
        end

        local tickbox = vgui.Create("DCheckBoxLabel", panel)
        tickbox:SetText(con:GetHelpText() or "Unknown setting.")
        tickbox:SetValue(con:GetBool())
        tickbox.con_name = con_name
        tickbox:SetDark(true)

        function tickbox:OnChange(b)
            requestSetting(self.con_name, b and "1" or "0")
        end

        function tickbox:Think()
            if not self.con_name then
                return
            end

            local ucon = GetConVar(self.con_name)

            if (ucon:GetBool() or true) ~= self:GetValue() then
                self:SetChecked(ucon:GetBool())
            end
        end

        panel:AddItem(tickbox)
    end

    -- Spawn Menu entry.
    local function SpawnMenu_Entry(panel)
        panel:AddControl("Label", {
            Text = "Client Settings:"
        })

        clientTrickBox(panel, "cl_weapon_holsters", function()
            removeHolstWep("")
        end)

        panel:AddControl("Label", {
            Text = "Administrator Settings:"
        })

        adminTrickBox(panel, "sv_weapon_holsters")

        local a = panel:AddControl("Button", {
            Label = "Open Editor",
            Command = "weapon_holsters_editor"
        })

        a:SetSize(0, 50)
        a:SetEnabled(LocalPlayer():IsSuperAdmin())
    end

    hook.Add("PopulateToolMenu", "weapon_holsters_editor_spawnmenu", function()
        spawnmenu.AddToolMenuOption("Options", "Player", "weapon_holsters_editor_spawnmenu_entry", "Weapon Holsters", "", "", SpawnMenu_Entry, {})
    end)

    hook.Add("HUDPaint", "whBoneIndicator", function()
        if WepHolster.lookingBone then
            for k, ply in pairs(player.GetAll()) do
                lp = LocalPlayer()
                local bone = ply:LookupBone(WepHolster.lookingBone)
                local matrix = ply:GetBoneMatrix(bone)

                if not matrix then
                    return
                end

                local pos = matrix:GetTranslation()
                pos = pos:ToScreen()
                local wihe = 6
                draw.RoundedBox(2, pos.x - wihe / 2, pos.y - wihe / 2, wihe, wihe, Color(0, 0, 0, 200))
                wihe = wihe - 2
                draw.RoundedBox(2, pos.x - wihe / 2, pos.y - wihe / 2, wihe, wihe, Color(255, 255, 255, 255))
            end
        end
    end)
end
--gamemodes/starwarsrp/gamemode/modules/comlink/sh_channels.lua:
AOCRP.Comlink = AOCRP.Comlink or {}


AOCRP.Comlink.Channels = {}

local function checkLogic(ply,logic)

    local checkTbl = {} 

    if logic["u"] then
        if istable(logic["u"]) then 
            if table.HasValue(logic["u"], ply:GetUnitID()) then
                checkTbl["u"] = true 
            else
                checkTbl["u"] = false     
            end  
        else 
            if logic["u"] == ply:GetUnitID() then
                checkTbl["u"] = true 
            else
                checkTbl["u"] = false     
            end
        end
    end

    if logic["r"] then
        if ply:GetRankID() >= logic["r"] then
            checkTbl["r"] = true 
        else
            checkTbl["r"] = false     
        end  
    end


    if logic["g"] then
        if table.HasValue(logic["g"], ply:GetGearID()) then
            checkTbl["g"] = true 
        else
            checkTbl["g"] = false     
        end          
    end

    if logic["all"] then
        return true
    end

    for k, v in pairs(checkTbl) do
        if !v then
            return false
        end
    end

    return true
end

function AOCRP.Comlink:ChannelCanSpeak(ply, chan)

    if ply:GetNetVar("AOCRP_InJail", false) then return false end
    if ply:GetCloneID() == 0 then return false end

    if AOCRP.Comlink.Channels[chan] then
        local chanData = AOCRP.Comlink.Channels[chan]

        return checkLogic(ply,chanData.talk)

    end

    return false
end




function AOCRP.Comlink:ChannelCanHear(ply, chan)

    if ply:GetNetVar("AOCRP_InJail", false) then return false end
    if ply:GetCloneID() == 0 then return false end

    if AOCRP.Comlink.Channels[chan] then
        local chanData = AOCRP.Comlink.Channels[chan]

        return checkLogic(ply,chanData.hear)

        
    end

    return false
end





function AOCRP.Comlink:CreateChannel(name, short, canmute, defmute, talktbl, heartbl)

        local chanStruct = {
            name = name,
            short = short,
            canMute = canmute,
            defMute = defmute,
            talk = talktbl,
            hear = heartbl
        }

        table.insert(AOCRP.Comlink.Channels, chanStruct)

end

    for k, v in SortedPairs(AOCRP.Config.Funks ) do
        AOCRP.Comlink:CreateChannel(v.name, v.short, v.canMute, v.defMute, v.talk, v.hear)
    end


--gamemodes/starwarsrp/gamemode/modules/admin/sh_properties.lua:






properties.Add( "adminactions", {
	MenuLabel = "AOCRP - Permanent", -- Name to display on the context menu
	Order = 999, -- The order to display this property relative to other properties
	MenuIcon = "icon16/disk.png", -- The icon to display next to the property

	Filter = function( self, ent, ply ) -- A function that determines whether an entity is valid for this property
		if ( !IsValid( ent ) ) then return false end
		if ( !ent:IsPlayer() ) then return false end
        return true
	end,
    MenuOpen = function( self, menu, ent, tr) 


            local subMenu1 = menu:AddSubMenu("Job-Aktionen")
            
            local subMenu = subMenu1:AddSubMenu("Rang")

            for k, v in pairs(AOCRP.Ranks) do
                local option = subMenu:AddOption(v.name .. "/"..v.navyprefix, function() LocalPlayer():ConCommand('sam rang "'..ent:Name()..'" "'..v.rankid..'"') end)
            end

            local subMenu = subMenu1:AddSubMenu("Einheit")

            for k, v in pairs(AOCRP.Units) do
                local option = subMenu:AddOption(v.name, function() LocalPlayer():ConCommand('sam unit "'..ent:Name()..'" "'..v.unitid..'"') end)
            end

            local subMenu = subMenu1:AddSubMenu("Gear")

            for k, v in pairs(AOCRP.Gears) do
                if v.unitid == ent:GetUnitID() then
                    local option = subMenu:AddOption(v.name, function() LocalPlayer():ConCommand('sam gear "'..ent:Name()..'" "'..v.gearid..'"') end)
                end
            end

            local subMenu = subMenu1:AddSubMenu("Platoon")

            for k, v in pairs(AOCRP.Config.SubUnits) do
                if v.unitid == ent:GetUnitID() or v.unitid == 0 then
                    local option = subMenu:AddOption(v.name, function() LocalPlayer():ConCommand('sam subunit "'..ent:Name()..'" "'..k..'"') end)
                end
            end

--[[             JR_CMENU_tempJobMenu, tempJobMenuOption = subMenu:AddSubMenu("Temp. Jobwechsel")
            tempJobMenuOption:SetIcon("icon16/time.png")

            
            JR_CMENU_permJobMenu, permJobMenuOption = subMenu:AddSubMenu("Perm. Jobwechsel")
            permJobMenuOption:SetIcon("icon16/disk.png")
      ]]

    end,
	Action = function( self, ent ) -- The action to perform upon using the property ( Clientside )

	end,
	Receive = function( self, length, ply ) -- The action to perform upon using the property ( Serverside )
		
	end 
} )


properties.Add( "adminactions_temp", {
	MenuLabel = "AOCRP - Temporär", -- Name to display on the context menu
	Order = 999, -- The order to display this property relative to other properties
	MenuIcon = "icon16/time.png", -- The icon to display next to the property

	Filter = function( self, ent, ply ) -- A function that determines whether an entity is valid for this property
		if ( !IsValid( ent ) ) then return false end
		if ( !ent:IsPlayer() ) then return false end
        return true
	end,
    MenuOpen = function( self, menu, ent, tr) 


            local subMenu1 = menu:AddSubMenu("Job-Aktionen")
            
            local subMenu = subMenu1:AddSubMenu("Rang")

            for k, v in pairs(AOCRP.Ranks) do
                local option = subMenu:AddOption(v.name.."/"..v.navyprefix, function() LocalPlayer():ConCommand('sam temprang "'..ent:Name()..'" "'..v.rankid..'"') end)
            end

            local subMenu = subMenu1:AddSubMenu("Einheit")

            for k, v in pairs(AOCRP.Units) do
                local option = subMenu:AddOption(v.name, function() LocalPlayer():ConCommand('sam tempunit "'..ent:Name()..'" "'..v.unitid..'"') end)
            end

            local subMenu = subMenu1:AddSubMenu("Gear")

            for k, v in pairs(AOCRP.Gears) do
                if v.unitid == ent:GetUnitID() then
                    local option = subMenu:AddOption(v.name, function() LocalPlayer():ConCommand('sam tempgear "'..ent:Name()..'" "'..v.gearid..'"') end)
                end
            end

            local subMenu = subMenu1:AddSubMenu("Platoon")

            for k, v in pairs(AOCRP.Config.SubUnits) do
                if v.unitid == ent:GetUnitID() or v.unitid == 0 then
                    local option = subMenu:AddOption(v.name, function() LocalPlayer():ConCommand('sam tempsubunit "'..ent:Name()..'" "'..k..'"') end)
                end
            end

            local option = subMenu1:AddOption("Zurücksetzen", function() LocalPlayer():ConCommand('sam reloadtemp "'..ent:Name()..'"') end)



    end,
	Action = function( self, ent ) -- The action to perform upon using the property ( Clientside )

	end,
	Receive = function( self, length, ply ) -- The action to perform upon using the property ( Serverside )
		
	end 
} )


local AdminCommands = {}

AdminCommands["trooper"] = "Zum CT listen"
AdminCommands["strip"] = "Waffen entziehen"
AdminCommands["slay"] = "Slayen"
AdminCommands["respawn"] = "Respawnen"

properties.Add( "adminactions_others", {
	MenuLabel = "SAM-Befehle", -- Name to display on the context menu
	Order = 999, -- The order to display this property relative to other properties
	MenuIcon = "icon16/star.png", -- The icon to display next to the property

	Filter = function( self, ent, ply ) -- A function that determines whether an entity is valid for this property
		if ( !IsValid( ent ) ) then return false end
		if ( !ent:IsPlayer() ) then return false end
        return true
	end,
    MenuOpen = function( self, menu, ent, tr) 


            local subMenu1 = menu:AddSubMenu("Job-Aktionen")
            
            for k, v in pairs(AdminCommands) do
                local option = subMenu1:AddOption(v, function() LocalPlayer():ConCommand('sam '..k..' "'..ent:Name()..'"') end)
            end


    end,
	Action = function( self, ent ) -- The action to perform upon using the property ( Clientside )

	end,
	Receive = function( self, length, ply ) -- The action to perform upon using the property ( Serverside )
		
	end 
} )





properties.Add( "adminactions_ragdoll", {
	MenuLabel = "Revive", -- Name to display on the context menu
	Order = 999, -- The order to display this property relative to other properties
	MenuIcon = "icon16/star.png", -- The icon to display next to the property

	Filter = function( self, ent, ply ) -- A function that determines whether an entity is valid for this property
		if ( !IsValid( ent ) ) then return false end
		if ( ent:GetNetVar("AOC_BodyOf", nil) == nil ) then return false end
        return true
	end,
    MenuOpen = function( self, menu, ent, tr) 
    end,
	Action = function( self, ent ) -- The action to perform upon using the property ( Clientside ) 
        LocalPlayer():ConCommand('sam revive "'..ent:GetNetVar("AOC_BodyOf", nil):Name()..'"')
	end,
	Receive = function( self, length, ply ) -- The action to perform upon using the property ( Serverside )
		
	end 
} )
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/map/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local addons = {}

wOS.PES.Modules:RegisterAddon( "map", addons )

net.Receive( "wOS.PES.Maps", function()
	addons.Maps = net.ReadTable()
end )
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/io_logic.lua:

local VAR = {}

VAR.Name = "IOLogic"
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Select the entity to pull IO functions from", key = "gui/lmb.png", },
}

VAR.IsValid = function(varTable, value)
    if not istable(value) then return false end
	if not value.Function then return false end
	
	return true
end

VAR.DermaElement = function(varTable, varData)
	
	local DermaPanel = vgui.Create("DScrollPanel")
	DermaPanel:SetTall( 100 )
	DermaPanel.varData = varData or {}

	local ioLogic = wOS.PES.Modules:Get("io_logic")

	local rebuildOptions = function( class, ent )
		local actions = ioLogic:GetIOTable( class, ent )
		for _, name in ipairs(actions) do
			local button = vgui.Create("DButton", DermaPanel)	
			button:SetText(name)
			button:SetTall(20)
			button:Dock(TOP)
			button.FName = name
			button:DockMargin(0, 0, 5, 0)
			button.DoClick = function( pan )
				if not ent and not DermaPanel.varData.Class then return end
				local class = DermaPanel.varData.Class
				if ent then class = ent:GetClass() end
				DermaPanel.varData = { Class = class, Function = pan.FName }
				if DermaPanel.ClickedButton then
					DermaPanel.ClickedButton:SetText( DermaPanel.ClickedButton.FName )
				end
				pan:SetText( "->  " .. pan.FName .. " <-" )
				DermaPanel.ClickedButton = pan
			end

			if DermaPanel.varData.Function and DermaPanel.varData.Function == name then
				button:SetText( "->  " .. button.FName .. " <-" )
				DermaPanel.ClickedButton = button
			end

		end

	end

	local rebuildBase = function(ent)
		DermaPanel:Clear()

		if !IsValid(ent) then 
			local dlabel = vgui.Create("DLabel", DermaPanel)
			dlabel:SetText("No entity selected")
			dlabel:SetTall(20)
			dlabel:Dock(TOP)
			dlabel:DockMargin(0, 0, 5, 0)
			return 
		end
		
		rebuildOptions( ent:GetClass(), ent )
	end


	if DermaPanel.varData.Class then
		rebuildOptions( DermaPanel.varData.Class )
	end

	DermaPanel.RebuildBase = rebuildBase

	return DermaPanel
end

VAR.GetValue = function(element, varData)
	return element.varData
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
	local ent = ply:GetEyeTrace().Entity

	dermaElement.varData = {}
	dermaElement.RebuildBase(ent)
	ply:ChatPrint( "Entity Class Updated: " .. ent:GetClass() )
end

return VAR
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/string.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "String"

VAR.IsValid = function(varData, value)
    if not isstring(value) then
        return false
    end

    if value == "" then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local textentry = vgui.Create("DTextEntry")

    if varTable.AllowMultiLine then
        textentry:SetMultiline(true)
        textentry:SetHeight(40)
    end

    textentry:SetText(value or varTable.Default or "")

    return textentry
end

VAR.GetValue = function(dermaElement)
    return dermaElement:GetValue()
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/core/cl_accessors.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































wOS = wOS or {}
wOS.PES = wOS.PES or {}

wOS.PES.Triggers = wOS.PES.Triggers || {}
wOS.PES.Triggers.Data = wOS.PES.Triggers.Data || {}

wOS.PES.Nodes = wOS.PES.Nodes || {}
wOS.PES.Nodes.Data = wOS.PES.Nodes.Data || {}

function wOS.PES.Triggers:GetAll()
    return self.Data
end

function wOS.PES.Triggers:Get(name)
    if not name then return end
    return self.Data[name]
end

function wOS.PES.Nodes:GetAll()
    return self.Data
end

function wOS.PES.Nodes:Get(name)
    if not name then return end
    return self.Data[name]
end
--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


--lua/weapons/antlion_sword/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Antlion sword"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Ant"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack, Special +jump"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-1.5, 0, 6), angle = Angle(45, 180, 0), size = Vector(0.2, 0.1, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(140, 255, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/dav0r/thruster.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 27), angle = Angle(180, 0, 0), size = Vector(0.1, 0.1, 3.7), color = Color(140, 255, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(1.5, 0, 6), angle = Angle(45, 0, 0), size = Vector(0.2, 0.1, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(140, 255, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/trapezium.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 16), angle = Angle(-90, 90, 0), size = Vector(0.5, 0.009, 0.1), color = Color(140, 255, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-1.5, 0, 6), angle = Angle(45, 180, 0), size = Vector(0.2, 0.1, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(140, 255, 0, 255), surpresslightning = false, material = "phoenix_storms/torpedo", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(140, 255, 0, 255), surpresslightning = false, material = "phoenix_storms/tiles2", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/triangles/trapezium.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 16), angle = Angle(-90, 90, 0), size = Vector(0.5, 0.009, 0.1), color = Color(140, 255, 0, 255), surpresslightning = false, material = "phoenix_storms/grey_chrome", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/dav0r/thruster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 27), angle = Angle(180, 0, 0), size = Vector(0.1, 0.1, 3.7), color = Color(140, 255, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(1.5, 0, 6), angle = Angle(45, 0, 0), size = Vector(0.2, 0.1, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}



SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 40
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.5
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Yellowblood"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 75
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.9
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Antlion"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0
SWEP.SetJumpPower=205

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
self.Owner:SetJumpPower(self.SetJumpPower)
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetJumpPower(self.SetJumpPower+20)
		self.SetJumpPower=self.SetJumpPower +25
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetJumpPower(self.SetJumpPower+20)
		self.SetJumpPower=self.SetJumpPower +25
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/arccw_weapons/lua/weapons/aocrp_btap5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3




SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "BT-AP5"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "BlasTech A Serie - Prototyp 5"
SWEP.IconOverride = "entities/sopsmisc/a280cfe.png"

SWEP.DefaultBodygroups  = "000102"
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_a280cfe.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/w_a280cfe.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-12, 4.5, -5),
    ang = Angle(-10, 0, 180),
    scale = 1.2,
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 35
SWEP.RangeMin = 500
SWEP.DamageMin = 10
SWEP.Range = 3500
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.78
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0.56
SWEP.Delay = 60 / 500

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 1
    },
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.06
SWEP.HipDispersion = 470
SWEP.MoveDispersion = 267

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/a280cfe.wav"
SWEP.ShootSound = "sops-v2/weapons/a280cfe.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-3.875, -12.188, 2.5),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -3, 2)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.AttachmentElements = {
    ["a280cfe_barrel_short"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        AttPosMods = {
            [2] = {
                vpos = Vector(-0.175, -1.65, 15.5   ),
            },
        }
    },
    ["a280cfe_barrel_sniper"] = {
        NameChange = "Sniper A-280CFE",
        VMBodygroups = {{ind = 1, bg = 2}},
        AttPosMods = {
            [2] = {
                vpos = Vector(-0.175, -1.65, 24),
            },
        }
    },
    ["a280cfe_powerpack"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        },
    },
    ["a280cfe_stock_assault"] = {
        VMBodygroups = {
            {ind = 5, bg = 0},
        },
    },
    ["a280cfe_stock_heavy"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        },
    },
}

SWEP.Attachments = {   
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Optic",
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a280cfe",
        Offset = {
            vpos = Vector(-0.175, -2.6, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, -0.025),
    }, 
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "a280cfe",
        Offset = {
            vpos = Vector(-0.175, -1.7, 19.2),
            vang = Angle(90, 0, -90),

        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "a280cfe",
        Offset = {
            vpos = Vector(0.4, -1.7, 11),
            vang = Angle(90, 0, 20),
        },
    },  
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "a280cfe",
        Offset = {
            vpos = Vector(-0.175, -0.6, 11),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Slot = {"cfe_stock"},
    },  
    {
        PrintName = "Powerpack", 
        DefaultAttName = "None",
        Slot = {"cfe_powerpack"},
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "a280cfe",
        VMScale = Vector(0.8, 0.8, 0.8),
        Offset = {
            vpos = Vector(0.3, -1.7, 1),
            vang = Angle(90, 0, -70),
        },
    },     
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "a280cfe",
        VMScale = Vector(0.5, 0.5, 0.5),
        Offset = {
            vpos = Vector(0.35, -0.8, 1),
            vang = Angle(90, 0, -90),
        },
    },   
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        Mult = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 5 / 30},
            {s = "weapon_hand/reload_gentle/mag_eject/023d-00001014.mp3", t = 10 / 30},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000dda.mp3", t = 60 / 30},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_04.mp3", t = 70 / 30},
        },
    },
}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 25
SWEP.DamageMin = 10
SWEP.RangeMin = 500
SWEP.Range = 3500
SWEP.Delay = 60 / 500
SWEP.Primary.ClipSize = 55
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_dual_dc17s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestellte Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual DC-17s (V1 - WIP)"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact DC15S Blaster Carbine, preffered for CQB enviroments and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_dc17s.png"

SWEP.DefaultBodygroups = "000000000000"
SWEP.NoHideLeftHandInCustomization = true
SWEP.Damage = 40
SWEP.RangeMin = 145
SWEP.DamageMin = 17
SWEP.Range = 400
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 60

SWEP.Recoil = 0.44
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.17
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 550
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },        
}

SWEP.AccuracyMOA = 0.45 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 410 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 35


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 65
SWEP.ShootPitch = 100

SWEP.DistantShootSound = "dc17/SW01_Weapons_Blasters_Shared_Corebass_Close_Tight_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17/SW02_Weapons_Blasters_DC17_Laser_Close_VAR_07 0 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.MuzzleFlashColor = Color(0, 0, 255, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)


SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"dc17s", "dc17s+"}

SWEP.AttachmentElements = {
    ["dc17s"] = {
        VMElements = {
            {
                Model = "models/arccw/fisher/dc17s/dc17s.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(9.5, 2.5, -0.7),
                    ang = Angle(85, -10, 90)
                }
            }
        },
    },
    ["dc17s+"] = {
         VMElements = {
            {
                Model = "models/arccw/fisher/dc17s/dc17s.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1, 1, 1),                
                Offset = {
                    pos = Vector(-9, -3.3, 2.2),
                    ang = Angle(85, -10, -90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/fisher/dc17s/dc17s.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(80, 20, -30),
                    ang = Angle(180, -90, 2)
                }
            },
            {
                Model = "models/arccw/fisher/dc17s/dc17s.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-10, 230, -80),
                    ang = Angle(180, -90, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/fisher/dc17s/dc17s.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-9.5, -2.3, 2),
            vang = Angle(168, 4, -90),
        },
    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [3] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [4] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}   


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 40
SWEP.DamageMin = 20
SWEP.RangeMin = 145
SWEP.Range = 400
SWEP.Delay = 60 / 550
SWEP.Primary.ClipSize = 60
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_impact_grenade.lua:
SWEP.Base = "arccw_grenade_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Eingestellte Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Impact Grenade"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "Impact explosive ordnance with a medium-sized blast radius."

SWEP.Slot = 4

SWEP.CamAttachment = 3

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/nade_frag.mdl"
SWEP.WorldModel = "models/weapons/w_nade_frag.mdl"
SWEP.HideViewmodel = true
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/impact_grenade_meeks.png"

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "fcg.nade",
    },
}

SWEP.Primary.Ammo = "grenade"

SWEP.Primary.ClipSize = 1

SWEP.MuzzleVelocity = 1300
SWEP.MuzzleVelocityAlt = 500
SWEP.ShootEntity = "arccw_thr_impact"

SWEP.PullPinTime = 0.5

SWEP.ViewModelFOV = 70

SWEP.DefaultElements = {"thermal_grenade"}

SWEP.AttachmentElements = {
    ["thermal_grenade"] = {
        VMElements = {
            {
                Model = "models/arccw/impact_grenade.mdl",
                Bone = "def_c_base",
                Scale = Vector(0.75, 0.75, 0.75),
                Offset = {
                    pos = Vector(-0.2, -.3, -0),
                    ang = Angle(-90, 0, -90)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/impact_grenade.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(35, 25, 0),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
}

WMOverride = "models/arccw/impact_grenade.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 0.9},
    ["enter_sprint"] = {Source = "sprint_in", Mult = 0.1},
    ["exit_sprint"] = {Source = "sprint_out", Mult = 0.1},
    ["ready"] = {
        Source = "draw",
        SoundTable = {
           {s = "ArcCW_ThermalDet.firstdeploy1", t = 0 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "misc/gunfoley_blaster_sheathe_var_03.mp3", t = 0 / 30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_ThermalDet.holster1", t = 0 / 30}
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
        MinProgress = 0.5,
    },
    ["fire"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
    },
    ["throw"] = {
        Source = {"toss_overhead"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
        SoundTable = {
            {s = "ArcCW_Shock.explosion1", t = 0 / 30}
        },
    },
    ["throw_alt"] = {
        Source = {"underhand"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
        SoundTable = {
            {s = "ArcCW_Shock.explosion1", t = 0 / 30}
        },
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
        LHIK = true,
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
        LHIK = true,
    },
    ["idle_inspect"] = {
        Source = "inspect",
        LHIK = true,
    },

sound.Add({
    name =          "ArcCW_ThermalDet.holster1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var21.mp3"
    }),
    
sound.Add({
    name =          "ArcCW_ThermalDet.deploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/gunfoley_blaster_sheathe_var_03.mp3"
    }),
       
sound.Add({
    name =          "ArcCW_ThermalDet.firstdeploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var19.mp3"
    }),
        
sound.Add({
    name =          "ArcCW_Shock.explosion1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/SW02_Weapons_Grenades_Shared_Beeps_10.wav"
    }),

sound.Add({
    name =          "ArcCW_primer.button",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/buttonpress.mp3"
    }),

sound.Add({
    name =          "ArcCW_Underhand.explosion2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/underhand.mp3"
    }),
}


SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_thermal_grenade.lua:
SWEP.Base = "arccw_grenade_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "REP" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Thermal Detonator"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "Standard explosive ordnance with a timed fuse and a large blast radius."

SWEP.Slot = 4

SWEP.CamAttachment = 3

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/nade_frag.mdl"
SWEP.WorldModel = "models/weapons/w_nade_frag.mdl"
SWEP.HideViewmodel = true
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/thermal_det_meek.png"


SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "fcg.nade",
    },
}

SWEP.FuseTime = 2.1

SWEP.Primary.Ammo = "grenade"

SWEP.Primary.ClipSize = 1

SWEP.MuzzleVelocity = 1300
SWEP.MuzzleVelocityAlt = 500
SWEP.ShootEntity = "arccw_thr_frag"

SWEP.PullPinTime = 0.5

SWEP.ViewModelFOV = 70

SWEP.DefaultElements = {"thermal_grenade"}

SWEP.AttachmentElements = {
    ["thermal_grenade"] = {
        VMElements = {
            {
                Model = "models/arccw/thermal_detonator.mdl",
                Bone = "def_c_base",
                Scale = Vector(0.75, 0.75, 0.75),
                Offset = {
                    pos = Vector(-0.2, -0.8, -0.15),
                    ang = Angle(-60, 180, 15)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/thermal_detonator.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(35, 25, 0),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
}

WMOverride = "models/arccw/thermal_detonator.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 0.9},
    ["enter_sprint"] = {Source = "sprint_in", Mult = 0.1},
    ["exit_sprint"] = {Source = "sprint_out", Mult = 0.1},
    ["ready"] = {
        Source = "draw",
        SoundTable = {
           {s = "ArcCW_ThermalDet.firstdeploy1", t = 0 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "misc/gunfoley_blaster_sheathe_var_03.mp3", t = 0 / 30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_ThermalDet.holster1", t = 0 / 30}
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
        MinProgress = 0.5,
    },
    ["fire"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "w/buttonpress.wav", t = 0 / 30},
        },
    },
    ["throw"] = {
        Source = {"toss_overhead"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
        SoundTable = {
            {s = "w/thermaldet.wav", t = 0 / 30}
        },
    },
    ["throw_alt"] = {
        Source = {"underhand"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
        SoundTable = {
            {s = "ArcCW_Underhand.explosion2", t = 0 / 30}
        },
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
        LHIK = true,
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
        LHIK = true,
    },
    ["idle_inspect"] = {
        Source = "inspect",
        LHIK = true,
    },
}
--addons/arccw_base_modified/lua/weapons/arccw_base/cl_holosight.lua:
function SWEP:DoHolosight()

    -- In VRMod, we draw all holosights all the time
    if vrmod and vrmod.IsPlayerInVR(self:GetOwner()) then
        for i, asight in pairs(self.SightTable) do
            local aslot = self.Attachments[asight.Slot] or {}
            local atttbl = asight.HolosightData

            if !atttbl and aslot.Installed then
                atttbl = ArcCW.AttachmentTable[aslot.Installed]

                if !atttbl.Holosight then return end
            end

            if atttbl then
                local hsp = asight.HolosightPiece or self.HSPElement
                local hsm = asight.HolosightModel

                if !hsp and !hsm then
                    self:SetupActiveSights()
                    return
                end

                self:DrawHolosight(atttbl, hsm, hsp, asight)
            end
        end

        return
    end

    local asight = self:GetActiveSights()
    if !asight then return end
    local aslot = self.Attachments[asight.Slot] or {}

    local atttbl = asight.HolosightData

    if !atttbl and aslot.Installed then
        atttbl = ArcCW.AttachmentTable[aslot.Installed]

        if !atttbl.Holosight then return end
    end

    if atttbl then
        local hsp = asight.HolosightPiece or self.HSPElement
        local hsm = asight.HolosightModel

        if !hsp and !hsm then
            self:SetupActiveSights()
            return
        end

        self:DrawHolosight(atttbl, hsm, hsp)
    end
end

function SWEP:ShouldFlatScope()
    return false -- this system was removed, but we need to keep this function
end

local rtsize = ScrH()

local rtmat = GetRenderTarget("arccw_rtmat", rtsize, rtsize, false)
local rtmat_cheap = GetRenderTarget("arccw_rtmat_cheap", ScrW(), ScrH(), false)
local rtmat_spare = GetRenderTarget("arccw_rtmat_spare", ScrW(), ScrH(), false)


local thermal = Material("models/debug/debugwhite")
local colormod = Material("pp/colour")
local coldtime = 30

local additionalFOVconvar = ArcCW.ConVars["vm_add_ads"]

local matRefract = Material("pp/arccw/refract_rt")
local matRefract_cheap = Material("pp/arccw/refract_cs") -- cheap scopes stretches square overlays so i need to make it 16x9

matRefract:SetTexture("$fbtexture", render.GetScreenEffectTexture())
matRefract_cheap:SetTexture("$fbtexture", render.GetScreenEffectTexture())

timer.Create("ihategmod", 5, 0, function() -- i really dont know what the fucking problem with cheap scopes they dont want to set texture as not cheap ones
    matRefract_cheap:SetTexture("$fbtexture", render.GetScreenEffectTexture())
    matRefract:SetTexture("$fbtexture", render.GetScreenEffectTexture()) -- not cheap scope here why not
end)

local pp_ca_base, pp_ca_r, pp_ca_g, pp_ca_b = Material("pp/arccw/ca_base"), Material("pp/arccw/ca_r"), Material("pp/arccw/ca_g"), Material("pp/arccw/ca_b")
local pp_ca_r_thermal, pp_ca_g_thermal, pp_ca_b_thermal = Material("pp/arccw/ca_r_thermal"), Material("pp/arccw/ca_g_thermal"), Material("pp/arccw/ca_b_thermal")

pp_ca_r:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_g:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_b:SetTexture("$basetexture", render.GetScreenEffectTexture())

pp_ca_r_thermal:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_g_thermal:SetTexture("$basetexture", render.GetScreenEffectTexture())
pp_ca_b_thermal:SetTexture("$basetexture", render.GetScreenEffectTexture())

local greenColor = Color(0, 255, 0)  -- optimized +10000fps
local whiteColor = Color(255, 255, 255)
local blackColor = Color(0, 0, 0)

local function DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 ) -- stolen from gmod wiki
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end


local function IsWHOT(ent)
    if !ent:IsValid() or ent:IsWorld() then return false end

    if ent:IsPlayer() then -- balling
        if ent.ArcticMedShots_ActiveEffects and ent.ArcticMedShots_ActiveEffects["coldblooded"] or ent:Health() <= 0 then return false end -- arc stims
        return true
    end

    if ent:IsNPC() or ent:IsNextBot() then -- npcs
        if ent.ArcCWCLHealth and ent.ArcCWCLHealth <= 0 or ent:Health() <= 0 then return false end
        return true
    end

    if ent:IsRagdoll() then -- ragdolling
        if !ent.ArcCW_ColdTime then ent.ArcCW_ColdTime = CurTime() + coldtime end
        return ent.ArcCW_ColdTime > CurTime()
    end

    if ent:IsVehicle() or ent:IsOnFire() or ent.ArcCW_Hot or ent:IsScripted() and !ent:GetOwner():IsValid() then -- vroom vroom + :fire: + ents but not guns (guns on ground will be fine)
        return true
    end

    return false
end

function SWEP:FormThermalImaging(tex)
    if !tex then
        tex = render.GetRenderTarget()
    end

    render.PushRenderTarget(tex)

    cam.Start3D()

    if tex then
        colormod:SetTexture("$fbtexture", tex)
    else
        colormod:SetTexture("$fbtexture", render.GetScreenEffectTexture())
    end

    local asight = self:GetActiveSights()

    local nvsc = asight.ThermalScopeColor or whiteColor
    local tvsc = asight.ThermalHighlightColor or whiteColor

    local tab = ents.GetAll()

    -- table.Add(tab, player.GetAll())
    -- table.Add(tab, ents.FindByClass("npc_*"))

    render.SetStencilEnable(true)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)
    render.ClearStencil()

    local sw = ScrH()
    local sh = sw

    local sx = (ScrW() - sw) / 2
    local sy = (ScrH() - sh) / 2

    render.SetScissorRect( sx, sy, sx + sw, sy + sh, true )

    render.SetStencilReferenceValue(64)

    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)

    for _, v in pairs(tab) do

        if !IsWHOT(v) then continue end

        if !asight.ThermalScopeSimple then
            render.SetBlend(0.5)
            render.SuppressEngineLighting(true)

            render.SetColorModulation(250, 250, 250)

            v:DrawModel()
        end
    end

    render.SetColorModulation(1, 1, 1)

    render.SuppressEngineLighting(false)

    render.MaterialOverride()

    render.SetBlend(1)

    render.SetStencilCompareFunction(STENCIL_EQUAL)

    if asight.ThermalScopeSimple then
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(0, 0, ScrW(), ScrH())
    end

    DrawColorModify({
        ["$pp_colour_addr"] = 0,
        ["$pp_colour_addg"] = 0,
        ["$pp_colour_addb"] = 0,
        ["$pp_colour_brightness"] = 0,
        ["$pp_colour_contrast"] = 1,
        ["$pp_colour_colour"] = 0,
        ["$pp_colour_mulr"] = 0,
        ["$pp_colour_mulg"] = 0,
        ["$pp_colour_mulb"] = 0
    })

    DrawColorModify({
        ["$pp_colour_addr"] = tvsc.r - 255,
        ["$pp_colour_addg"] = tvsc.g - 255,
        ["$pp_colour_addb"] = tvsc.b - 255,
        ["$pp_colour_addr"] = 0,
        ["$pp_colour_addg"] = 0,
        ["$pp_colour_addb"] = 0,
        ["$pp_colour_brightness"] = 0,
        ["$pp_colour_contrast"] = 1,
        ["$pp_colour_colour"] = 1,
        ["$pp_colour_mulr"] = 0,
        ["$pp_colour_mulg"] = 0,
        ["$pp_colour_mulb"] = 0
    })

    if !asight.ThermalNoCC then
        render.SetStencilCompareFunction(STENCIL_NOTEQUAL)
        render.SetStencilPassOperation(STENCIL_KEEP)

        if !asight.ThermalFullColor then
            DrawColorModify({
                ["$pp_colour_addr"] = 0,
                ["$pp_colour_addg"] = 0,
                ["$pp_colour_addb"] = 0,
                ["$pp_colour_brightness"] = 0,
                ["$pp_colour_contrast"] = 1,
                ["$pp_colour_colour"] = 0,
                ["$pp_colour_mulr"] = 0,
                ["$pp_colour_mulg"] = 0,
                ["$pp_colour_mulb"] = 0
            })
        end

        if ArcCW.ConVars["thermalpp"]:GetBool() and ArcCW.ConVars["scopepp"]:GetBool() then
            -- chromatic abberation

            render.CopyRenderTargetToTexture(render.GetScreenEffectTexture())

            render.SetMaterial( pp_ca_base )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_r_thermal )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_g_thermal )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_b_thermal )
            render.DrawScreenQuad()
            -- pasted here cause otherwise either target colors will get fucked either pp either motion blur
        end

        DrawColorModify({
            ["$pp_colour_addr"] = nvsc.r - 255,
            ["$pp_colour_addg"] = nvsc.g - 255,
            ["$pp_colour_addb"] = nvsc.b - 255,
            -- ["$pp_colour_addr"] = 0,
            -- ["$pp_colour_addg"] = 0,
            -- ["$pp_colour_addb"] = 0,
            ["$pp_colour_brightness"] = asight.Brightness or 0.1,
            ["$pp_colour_contrast"] = asight.Contrast or 0.5,
            ["$pp_colour_colour"] = asight.Colormult or 1,
            ["$pp_colour_mulr"] = 0,
            ["$pp_colour_mulg"] = 0,
            ["$pp_colour_mulb"] = 0
        })
    end

    render.SetScissorRect( sx, sy, sx + sw, sy + sh, false )

    render.SetStencilEnable(false)

    colormod:SetTexture("$fbtexture", render.GetScreenEffectTexture())

    cam.End3D()

    if ArcCW.ConVars["thermalpp"]:GetBool() then
        if !render.SupportsPixelShaders_2_0() then return end

        DrawSharpen(0.3,0.9)
        DrawBloom(0,0.3,5,5,3,0.5,1,1,1)
        -- DrawMotionBlur(0.7,1,1/(asight.FPSLock or 45)) -- upd i changed order and it fucking worked lmao     //////i cant fucking understand why motionblur fucks render target
    end

    render.PopRenderTarget()
end

function SWEP:FormNightVision(tex)
    local asight = self:GetActiveSights()

    local orig = colormod:GetTexture("$fbtexture")

    colormod:SetTexture("$fbtexture", tex)

    render.PushRenderTarget(tex)

    local nvsc = asight.NVScopeColor or greenColor

    if !asight.NVFullColor then
        DrawColorModify({
            ["$pp_colour_addr"] = 0,
            ["$pp_colour_addg"] = 0,
            ["$pp_colour_addb"] = 0,
            ["$pp_colour_brightness"] = 0,
            ["$pp_colour_contrast"] = 1,
            ["$pp_colour_colour"] = 0,
            ["$pp_colour_mulr"] = 0,
            ["$pp_colour_mulg"] = 0,
            ["$pp_colour_mulb"] = 0
        })
    end

    DrawColorModify({
        ["$pp_colour_addr"] = nvsc.r - 255,
        ["$pp_colour_addg"] = nvsc.g - 255,
        ["$pp_colour_addb"] = nvsc.b - 255,
        ["$pp_colour_brightness"] = asight.Brightness or -0.05,
        ["$pp_colour_contrast"] = asight.Contrast or 4,
        ["$pp_colour_colour"] = 1,
        ["$pp_colour_mulr"] = 0,
        ["$pp_colour_mulg"] = 0,
        ["$pp_colour_mulb"] = 0
    })

    render.PopRenderTarget()

    colormod:SetTexture("$fbtexture", orig)
end

local pp_cc_tab = {
    ["$pp_colour_addr"] = 0,
    ["$pp_colour_addg"] = 0,
    ["$pp_colour_addb"] = 0,
    ["$pp_colour_brightness"] = 0, -- why nothing works hh
    ["$pp_colour_contrast"] = 0.9,  -- but same time chroma dont work without calling it
    ["$pp_colour_colour"] = 1,
    ["$pp_colour_mulr"] = 0,
    ["$pp_colour_mulg"] = 0,
    ["$pp_colour_mulb"] = 0
}

function SWEP:FormPP(tex)
    if !render.SupportsPixelShaders_2_0() then return end

    local asight = self:GetActiveSights()

    if asight.Thermal then return end -- eyah

    local cs = ArcCW.ConVars["cheapscopes"]:GetBool()
    local refract = ArcCW.ConVars["scopepp_refract"]:GetBool()
    local pp = ArcCW.ConVars["scopepp"]:GetBool()


    if refract or pp then
        if !cs then render.PushRenderTarget(tex) end
        render.CopyRenderTargetToTexture(render.GetScreenEffectTexture())

        if pp then
            render.SetMaterial( pp_ca_base )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_r )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_g )
            render.DrawScreenQuad()
            render.SetMaterial( pp_ca_b )
            render.DrawScreenQuad()
                -- Color modify

            DrawColorModify( pp_cc_tab )
                -- Sharpen
            DrawSharpen(-0.1, 5) -- dont work for some reason
        end

        if refract then
            local addads = math.Clamp(additionalFOVconvar:GetFloat(), -2, 14)
            local refractratio = ArcCW.ConVars["scopepp_refract_ratio"]:GetFloat() or 0
            local refractamount = (-0.6 + addads / 30) * refractratio
            local refractmat = cs and matRefract_cheap or matRefract

            refractmat:SetFloat( "$refractamount", refractamount )

            render.SetMaterial(refractmat)
            render.DrawScreenQuad()
        end

        if !cs then render.PopRenderTarget() end
    end
end

function SWEP:FormCheapScope()
    local screen = render.GetRenderTarget()

    render.CopyTexture( screen, rtmat_spare )

    render.PushRenderTarget(screen)
    cam.Start3D(EyePos(), EyeAngles(), nil, nil, nil, nil, nil, 0, nil)
        ArcCW.LaserBehavior = true
        self:DoLaser(false)
        ArcCW.LaserBehavior = false
    cam.End3D()

    self:FormPP(screen)

    render.PopRenderTarget()

    -- so, in order to avoid the fact that copying RTs doesn't transfer depth buffer data, we just take the screen texture and...
    -- redraw it to cover up the thermal scope stuff. Don't think too hard about this. You have plenty of VRAM.

    local asight = self:GetActiveSights()

    if asight.Thermal then
        self:FormThermalImaging(screen)
    end

    if asight.SpecialScopeFunction then
        asight.SpecialScopeFunction(screen)
    end

    -- integrated render delay for better optimization
    if asight.FPSLock then
        asight.fpsdelay = CurTime() + 1 / (asight.FPSLock or 45)
    end

    render.CopyTexture( screen, rtmat_cheap )

    render.DrawTextureToScreen(rtmat_spare)

    render.UpdateFullScreenDepthTexture()
end

function SWEP:FormRTScope()
    local asight = self:GetActiveSights()

    if !asight then return end

    if !asight.MagnifiedOptic then return end

    local mag = asight.ScopeMagnification

    cam.Start3D()

    ArcCW.Overdraw = true
    ArcCW.LaserBehavior = true
    ArcCW.VMInRT = true

    local rtangles, rtpos, rtdrawvm

    if self:GetState() == ArcCW.STATE_SIGHTS then
        if ArcCW.ConVars["drawbarrel"]:GetBool() and ArcCW.ConVars["vm_coolsway"]:GetBool() and asight.Slot and asight.Slot == 1 then -- slot check to ignore integrated
            rtangles = self.VMAng - self.VMAngOffset - (self:GetOurViewPunchAngles() * mag * 0.1)
            rtangles.x = rtangles.x - self.VMPosOffset_Lerp.z * 10
            rtangles.y = rtangles.y + self.VMPosOffset_Lerp.y * 10

            rtpos = self.VMPos + self.VMAng:Forward() * (asight.EVPos.y + 7 + (asight.ScopeMagnificationMax and asight.ScopeMagnificationMax / 3 or asight.HolosightData.HolosightMagnification / 3)) -- eh
            rtdrawvm = true
        else
            rtangles = EyeAngles()
            rtpos = EyePos()
            rtdrawvm = false

            -- HACK HACK HACK HACK HACK
            -- If we do not draw the viewmodel in RT scope, calling GetAttachment on the vm seems to break LHIK.
            -- So... just draw it! The results gets drawn over again so it doesn't affect the outcome
            render.RenderView({drawviewmodel = true}) -- ?????
        end
    end

    local addads = math.Clamp(additionalFOVconvar:GetFloat(), -2, 14)

    local rt = {
        w = rtsize,
        h = rtsize,
        angles = rtangles,
        origin = rtpos,
        drawviewmodel = rtdrawvm,
        fov = self:GetOwner():GetFOV() / mag / 1.2 - (addads or 0) / 4,
    }

    rtsize = ScrH()

    if ScrH() > ScrW() then rtsize = ScrW() end

    local rtres = asight.ForceLowRes and ScrH() * 0.6 or ScrH() -- we can emit low res lcd displays for scopes

    rtmat = GetRenderTarget("arccw_rtmat" .. rtres, rtres, rtres, false)

    render.PushRenderTarget(rtmat, 0, 0, rtsize, rtsize)

    render.ClearRenderTarget(rt, blackColor)

    if self:GetState() == ArcCW.STATE_SIGHTS then
        render.RenderView(rt)
        cam.Start3D(EyePos(), EyeAngles(), rt.fov, 0, 0, nil, nil, 0, nil)
            self:DoLaser(false)
        cam.End3D()
    end

    ArcCW.Overdraw = false
    ArcCW.LaserBehavior = false
    ArcCW.VMInRT = false

    self:FormPP(rtmat)

    render.PopRenderTarget()

    cam.End3D()

    if asight.Thermal then
        self:FormThermalImaging(rtmat)
    end

    if asight.SpecialScopeFunction then
        asight.SpecialScopeFunction(rtmat)
    end

    -- integrated render delay for better optimization
    if asight.FPSLock then
        asight.fpsdelay = CurTime() + 1 / (asight.FPSLock or 45)
    end

end

-- local fpsdelay = CurTime()

hook.Add("RenderScene", "ArcCW", function()
    if ArcCW.ConVars["cheapscopes"]:GetBool() then return end

    local wpn = LocalPlayer():GetActiveWeapon()

    if !wpn.ArcCW then return end
    if wpn:GetActiveSights() and wpn:GetActiveSights().FPSLock
            and (wpn:GetActiveSights().fpsdelay or 0) > CurTime() then
        return
    end
    wpn:FormRTScope()
end)

local black = Material("arccw/hud/black.png")
local defaultdot = Material("arccw/hud/hit_dot.png")

function SWEP:DrawHolosight(hs, hsm, hsp, asight)
    -- holosight structure
    -- holosight model

    local ref = 32

    asight = asight or self:GetActiveSights()
    local delta = self:GetSightDelta()

    if asight.HolosightData then
        hs = asight.HolosightData
    end

    if self:GetState() != ArcCW.STATE_SIGHTS and delta > 0.5 or self:GetBarrelNearWall() > 0 then return end

    if !hs then return end

    if delta != 0 and ArcCW.ConVars["scopepp"]:GetBool() then
        pp_ca_r:SetVector("$color2", Vector(1-delta, 0, 0))
        pp_ca_g:SetVector("$color2", Vector(0, 1-delta, 0))
        pp_ca_b:SetVector("$color2", Vector(0, 0, 1-delta))
        pp_ca_base:SetFloat("$alpha", 1-delta)
    end

    local hsc = Color(255, 255, 255) -- putting here global or white local SOMEHOW FUCKS IT EVEN GLOBAL BEING FUCKED WTF I HATE

    if hs.Colorable then
        hsc.r = ArcCW.ConVars["scope_r"]:GetInt()
        hsc.g = ArcCW.ConVars["scope_g"]:GetInt()
        hsc.b = ArcCW.ConVars["scope_b"]:GetInt()
    else
        hsc = hs.HolosightColor or hsc
    end

    local attid = 0

    if hsm then

        attid = hsm:LookupAttachment(asight.HolosightBone or hs.HolosightBone or "holosight")

        if attid == 0 then
            attid = hsm:LookupAttachment("holosight")
        end

    end

    local ret, pos, ang

    if attid != 0 then

        ret = hsm:GetAttachment(attid)
        pos = ret.Pos
        ang = ret.Ang

    else

        pos = EyePos()
        ang = EyeAngles()

    end

    local hsmag = asight.ScopeMagnification or 1

    local size = hs.HolosightSize or 1

    local addads = math.Clamp(additionalFOVconvar:GetFloat(), -2, 14)

    local addconvar = asight.MagnifiedOptic and (addads or 0) or 0

    size = size + addconvar + (addconvar > 5.5 and (addconvar-5.5) * 2 or 0)


    -- if asight.NightVision then

    if hsmag and hsmag > 1 and delta < 1 and asight.NVScope then
        local screen = rtmat

        if ArcCW.ConVars["cheapscopes"]:GetBool() then
            screen = rtmat_cheap
        end

        if asight.NVScope then
            self:FormNightVision(screen)
        end
    end

    render.UpdateScreenEffectTexture()
    render.ClearStencil()
    render.SetStencilEnable(true)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_REPLACE)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)

    render.SetBlend(0)

        render.SetStencilReferenceValue(ref)

        ArcCW.Overdraw = true

        render.OverrideDepthEnable( true, true )

        if !hsm then
            hsp:DrawModel()
        else

            hsm:SetBodygroup(1, 0)

            if !hsp or hs.HolosightNoHSP then
                hsm:DrawModel()
            end

            -- render.MaterialOverride()

            render.SetStencilReferenceValue(0)

            hsm:SetBodygroup(1, 1)
            -- hsm:SetSubMaterial(0, "dev/no_pixel_write")
            hsm:DrawModel()
            -- hsm:SetSubMaterial()
            hsm:SetBodygroup(1, 0)

            -- local vm = self:GetOwner():GetViewModel()

            -- ArcCW.Overdraw = true
            -- vm:DrawModel()

            -- ArcCW.Overdraw = false

            render.SetStencilReferenceValue(ref)

            if hsp then
                hsp:DrawModel()
            end
        end

        -- render.MaterialOverride()

        render.OverrideDepthEnable( false, true )

        ArcCW.Overdraw = false

    render.SetBlend(1)

    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilCompareFunction(STENCIL_EQUAL)

    -- local pos = EyePos()
    -- local ang = EyeAngles()

    ang:RotateAroundAxis(ang:Forward(), -90)

    local dir = ang:Up()

    local pdiff = (pos - EyePos()):Length()

    pos = LerpVector(delta, EyePos(), pos)

    local eyeangs = self:GetOwner():EyeAngles() - self:GetOurViewPunchAngles() * hsmag * 0.1

    -- local vm = hsm or hsp

    -- eyeangs = eyeangs + (eyeangs - vm:GetAngles())

    dir = LerpVector(delta, eyeangs:Forward(), dir:GetNormalized())

    pdiff = Lerp(delta, pdiff, 0)

    local d = (8 + pdiff)

    d = hs.HolosightConstDist or d

    local vmscale = (self.Attachments[asight.Slot] or {}).VMScale or Vector(1, 1, 1)

    if hs.HolosightConstDist then
        vmscale = Vector(1, 1, 1)
    end

    local hsx = vmscale[2] or 1
    local hsy = vmscale[3] or 1

    pos = pos + (dir * d)

    local pos2 = pos + (dir * -8)

    local a = self:GetOwner():InVehicle() and {x = ScrW() / 2, y = ScrH() / 2} or pos:ToScreen()
    local x = a.x - (self.VMAngOffset.y - self.VMPosOffset_Lerp.y * 10) * (hsmag * 1.5) ^ 2
    local y = a.y + (self.VMAngOffset.x * 5 + self.VMPosOffset_Lerp.z * 10) * (hsmag * 1.5) ^ 2

    local a2 = self:GetOwner():InVehicle() and {x = ScrW() / 2, y = ScrH() / 2} or pos2:ToScreen()

    local off_x = a2.x - (ScrW() / 2)
    local off_y = a2.y - (ScrH() / 2)

    --pos = pos + Vector(ArcCW.StrafeTilt(self), 0, 0)

    -- local corner1, corner2, corner3, corner4

    -- corner2 = pos + (ang:Right() * (-0.5 * size)) + (ang:Forward() * (0.5 * size))
    -- corner1 = pos + (ang:Right() * (-0.5 * size)) + (ang:Forward() * (-0.5 * size))
    -- corner4 = pos + (ang:Right() * (0.5 * size)) + (ang:Forward() * (-0.5 * size))
    -- corner3 = pos + (ang:Right() * (0.5 * size)) + (ang:Forward() * (0.5 * size))

    -- render.SetColorMaterialIgnoreZ()
    -- render.DrawScreenQuad()

    -- render.SetStencilEnable( false )
    -- local fovmag = asight.Magnification or 1

    if hsmag and hsmag > 1 and delta < 1 then
        local screen = rtmat

        -- local sw2 = ScrH()
        -- local sh2 = sw2

        -- local sx2 = (ScrW() - sw2) / 2
        -- local sy2 = (ScrH() - sh2) / 2

        -- render.SetScissorRect( sx2, sy2, sx2 + sw2, sy2 + sh2, true )

        if render.GetHDREnabled() and delta < 0.07 then
            render.SetToneMappingScaleLinear(Vector(1,1,1)) -- hdr fix
        end

        if ArcCW.ConVars["cheapscopes"]:GetBool() then

            screen = rtmat_cheap

            local addads = math.Clamp(additionalFOVconvar:GetFloat(), -2, 14)
            local csratio = math.Clamp(GetConVar("arccw_cheapscopesv2_ratio"):GetFloat(), 0, 1)

            local ssmag = 1 + csratio * hsmag + (addads or 0) / 20 -- idk why 20
            local sw = ScrW() * ssmag
            local sh = ScrH() * ssmag

            -- local sx = -(sw - ScrW()) / 2
            -- local sy = -(sh - ScrH()) / 2

            local cpos = self:GetOwner():EyePos() + ((EyeAngles() + (self:GetOurViewPunchAngles() * 0.5)):Forward() * 2048)

            --cpos:Rotate(Angle(0, -ArcCW.StrafeTilt(self), 0))

            local ts = self:GetOwner():InVehicle() and {x = ScrW() / 2, y = ScrH() / 2} or cpos:ToScreen()

            local sx = ts.x - (sw / 2) - off_x - (self.VMAngOffset.y - self.VMPosOffset_Lerp.y * 15) * (hsmag * 1) ^ 2
            local sy = ts.y - (sh / 2) - off_y + (self.VMAngOffset.x * 5 + self.VMPosOffset_Lerp.z * 15) * (hsmag * 1) ^ 2

            render.SetMaterial(black)
            render.DrawScreenQuad()

            render.DrawTextureToScreenRect(screen, sx, sy, sw, sh)

        else

            local sw = ScrH()
            local sh = sw

            local sx = ((ScrW() - sw) / 2) - off_x
            local sy = ((ScrH() - sh) / 2) - off_x

            render.SetMaterial(black)
            render.DrawScreenQuad()

            render.DrawTextureToScreenRect(screen, sx, sy, sw, sh)

        end
    end

    -- cam.Start3D()

    -- render.SetColorMaterialIgnoreZ()
    -- render.DrawScreenQuad()

    -- render.DrawQuad( corner1, corner2, corner3, corner4, hsc or hs.HolosightColor )
    cam.IgnoreZ( true )

    render.SetStencilReferenceValue(ref)

    -- render.SetMaterial(hs.HolosightReticle or defaultdot)
    -- render.DrawSprite( pos, size * hsx, size * hsy, hsc or Color(255, 255, 255) )
    -- if !hs.HolosightNoFlare then
    --     render.SetMaterial(hs.HolosightFlare or hs.HolosightReticle or defaultdot)
    --     local hss = 0.75
    --     if hs.HolosightFlare then
    --         hss = 1
    --     end
    --     render.DrawSprite( pos, size * hss * hsx, size * hss * hsy, Color(255, 255, 255, 255) )
    -- end

    cam.Start2D()

    if hs.HolosightBlackbox then
        render.SetStencilPassOperation(STENCIL_KEEP)

        surface.SetDrawColor(0, 0, 0, 255 * delta)
        surface.DrawRect(0, 0, ScrW(), ScrH())
    end

    render.SetStencilPassOperation(STENCIL_DECR)
    render.SetStencilCompareFunction(STENCIL_EQUAL)

    local hss = size * 32 * math.min(ScrW(), ScrH()) / 800

    --local thej = self.TheJ.anga + LocalPlayer():GetViewPunchAngles() + self:GetOurViewPunchAngles()
                    -- AYE, UR ACTIVE ANG BEIN TWISTED DUNT GIVE AUH SHET

    surface.SetMaterial(hs.HolosightReticle or defaultdot)
    surface.SetDrawColor(hsc or 255, 255, 255)
    -- surface.DrawTexturedRect(x - (hss / 2), y - (hss / 2), hss, hss)

    DrawTexturedRectRotatedPoint(x, y, hss, hss, -(self.VMAngOffset.r+self.VMAngOffset_Lerp.r+self:GetOurViewPunchAngles().r)*5 , 0, 0)

    if !hs.HolosightNoFlare then
        render.SetStencilPassOperation(STENCIL_KEEP)
        render.SetStencilReferenceValue(ref - 1)
        surface.SetMaterial(hs.HolosightFlare or hs.HolosightReticle or defaultdot)
        surface.SetDrawColor(255, 255, 255, 150)

        local hss2 = hss

        if !hs.HolosightFlare then
            hss2 = hss - 2
        end

        surface.DrawTexturedRect(x - (hss2 / 2), y - (hss2 / 2), hss2, hss2)
        --surface.DrawTexturedRectRotated(x, y, hss2, hss2, -thej.r or 0)

        render.SetStencilReferenceValue(ref)
    end

    if hs.HolosightBlackbox then
        -- render.SetColorMaterialIgnoreZ()
        -- render.DrawScreenQuad()

        surface.SetDrawColor(0, 0, 0)
        surface.DrawRect(0, 0, ScrW(), ScrH())
        -- surface.DrawRect(0, (ScrH() - hss) / 2, ScrW(), (ScrH() - hss) / 2)
    end

    cam.End2D()

    render.SetStencilEnable( false )

    cam.IgnoreZ( false )

    -- cam.End3D()

    if hsp then

        cam.IgnoreZ(true)

        if ArcCW.ConVars["glare"]:GetBool() then
            render.SetBlend(delta + 0.1)
        else
            render.SetBlend(delta)
        end
        hsp:DrawModel()
        render.SetBlend(1)

        cam.IgnoreZ( false )

    end
end


--           I wanted to make here procedural normal map for refract using rt but steamsnooze


-- local TEX_SIZE = 512

-- local tex = GetRenderTarget( "ExampleRT", TEX_SIZE, TEX_SIZE )

-- local txBackground = surface.GetTextureID( "pp/arccw/lense_nrm2" )
-- local myMat = CreateMaterial( "ExampleRTMat3", "UnlitGeneric", {
-- 	["$basetexture"] = tex:GetName() -- Make the material use our render target texture
-- } )

-- hook.Add( "HUDPaint", "DrawExampleMat", function()
    -- render.PushRenderTarget( tex )
    -- cam.Start2D()

    --     surface.SetDrawColor( 128,128,255 )
    --     surface.DrawRect(0,0,TEX_SIZE, TEX_SIZE)
    --     surface.SetDrawColor( color_white )
    --     surface.SetTexture( txBackground )
        -- local joke = math.sin(CurTime()*5)/4

    --     surface.DrawTexturedRect( TEX_SIZE/4-joke/2, TEX_SIZE/4-joke/2, TEX_SIZE/2+joke, TEX_SIZE/2+joke )

    -- cam.End2D()
    -- render.PopRenderTarget()
    -- surface.SetDrawColor( color_white )
    -- surface.SetMaterial( myMat )
    -- surface.DrawTexturedRect( 25, 25, TEX_SIZE, TEX_SIZE )
    -- print()
    -- DrawTexturedRectRotatedPoint(250+250/2,250+250/2,250,250,(CurTime()%360)*50,0,0)
    -- surface.DrawRect(250,250,250,250)

-- end )

--addons/arccw_weapons/lua/weapons/arccw_blaster_e11.lua:
AddCSLuaFile()
SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "E-11"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "High tech verstile modular blaster base, suited for allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"

SWEP.ViewModel = "models/arccw/ser/starwars/v_e11.mdl"
SWEP.WorldModel = "models/arccw/ser/starwars/w_e11.mdl"
SWEP.IconOverride = ""
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.Slot = 3

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 27
SWEP.DamageMin = 14 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 100 -- how far bullets will retain their maximum damage for
SWEP.Range = 300 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3 -- color for phys tracer.

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "tfa_tracer_red" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(255, 0, 0)
SWEP.HullSize = 2 -- HullSize used by FireBullets

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 20 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.15
SWEP.RecoilRise = 0.53
SWEP.VisualRecoilMult = 2
SWEP.RecoilPunch = 1.4
SWEP.RecoilPunchBackMax = 0.9

SWEP.RecoilDirection = Angle(1.1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 330 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 2 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
	{
		Mode = 2,
   	},
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 410 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 65 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 130 -- dispersion that remains even in sights
SWEP.JumpDispersion = 200 -- dispersion penalty when in the air

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "w/e11/e11_a.wav"
--SWEP.ShootSoundSilenced = "w/e11/e11supp.wav"
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(255, 0, 0)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-3.38, -0, 2.65),
    Ang = Angle(0, 0, 1),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0
-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.SprintPos = Vector(6, -4, 0)
SWEP.SprintAng = Angle(-16.524, 60, -11.046)

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(10.824, -12, 5.897)
SWEP.CustomizeAng = Angle(12.149, 45.547, 45)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = true

SWEP.DefaultElements = {}

SWEP.AttachmentElements = {
    ["e11prongs"] = {
        VMElements = {
            {
                Model = "models/sw_battlefront/props/powerprongs/power_prongs.mdl",
                Bone = "optic",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(1.5, -0.2, 0.65),
                    ang = Angle(90, 0, -90)
                }
            }
        },
        WMElements = { -- Purely handles muzzle effect on the world model
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(18, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}



SWEP.Attachments = {
	[1] = {
		PrintName = "Optic", -- print name
		DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
		Slot = "optic",
        DefaultEles = {"ironsight"},
		Bone = "optic", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(0.15, -0.95, -4),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.5, -5),
            wang = Angle(-10, 2, 180)
        },
        NoWM = false
	},
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(.9, 0.5, 6),
            vang = Angle(90, 0, -0),
            wpos = Vector(14, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
        NoWM = false
    },
    [3] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.8, 0.5, -4),
            vang = Angle(90, 0, -90),
            wpos = Vector(4, 1.8, -3.5),
            wang = Angle(0, 0, 180)
        },
    },
    [4] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "optic", -- relevant bone any attachments wwill be mostly referring to /
        Offset = {
            vpos = Vector(-0, 0.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, .5, 2),
            wang = Angle(-10, 0, 180)            
        },
        SlideAmount = {
        vmin = Vector(-0.3, 1.4, 2),
        vmax = Vector(-0.3, 1.4, 6),
        wmin = Vector(14, 1, -4.5), 
        wmax = Vector(14, 1, -4.5)  -- how far this attachment can slide in both directions.
        },       -- Set this to false if you want the foregrips to display on ViewModels.          
    },
    [5] = {
        PrintName = "E11 Grips", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"e11r_grip", "e11_grip"},
        Bone = "optic", -- relevant bone any attachments wwill be mostly referring to /
        Offset = {
            vpos = Vector(-0, 0.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, .5, 2),
            wang = Angle(-100, -92, 0)            
        },
        SlideAmount = {
        vmin = Vector(-0.3, 1.4, 2),
        vmax = Vector(-0.3, 1.4, 6),
        wmin = Vector(9, 0.6, -3.5), 
        wmax = Vector(9, 0.6, -3.5)  -- how far this attachment can slide in both directions.
        }, -- if the weapon has this flag, hide this slot          -- Set this to false if you want the foregrips to display on ViewModels.          
    },
    [6] = {
        PrintName = "Power pack", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"e11_powerpack"},
        InstalledEles = {"e11prongs"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0, -0, -0),
            vang = Angle(0, 0, 90),
            wpos = Vector(5.5, 1, -3.8),
            wang = Angle(-10, -89, 0) 
        },
    },
    [7] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.2, 0.7, 11),
            vang = Angle(90, 0, -90),
            wpos = Vector(16.4, 1, -5.7),
            wang = Angle(-12, 0.5, 180) 
        },
    },
    [8] = {
        PrintName = "Stock", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"e11b_stock", "e11r_stock"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.2, 0.7, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(16.4, 1, -5.7),
            wang = Angle(-12, 0.5, 180) 
        },
        NoWM = true,
    },                                
    [9] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = {"ammo", "sw_imp_ammo"},
    },
    [10] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
}
    

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sights"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["enter_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["exit_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },  
	["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {
				s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_03.mp3", -- sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 0.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
			{
				s = "w/dc15s/overheatactivecoolingsuccess_var_02.mp3", -- "everfall/weapons/miscellaneous/charge/blasters_deathray_charge_start_var_04.mp3"sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 1.41, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
		}
    },
	["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
	["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--addons/arccw_weapons/lua/weapons/arccw_blaster_firepuncher.lua:
AddCSLuaFile()
SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "'Fire-Puncher'"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "High tech verstile modular blaster base, suited for allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"

SWEP.ViewModel = "models/arccw/ser/starwars/v_crosshairrifle.mdl"
SWEP.WorldModel = "models/arccw/ser/starwars/w_crosshairrifle.mdl"
SWEP.IconOverride = ""
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 75
SWEP.DamageMin = 33 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 140 -- how far bullets will retain their maximum damage for
SWEP.Range = 419 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3 -- color for phys tracer.

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "tfa_tracer_blue" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(0, 47, 255)
SWEP.HullSize = 2 -- HullSize used by FireBullets

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 20 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.15
SWEP.RecoilRise = 0.53
SWEP.VisualRecoilMult = 2
SWEP.RecoilPunch = 1.4
SWEP.RecoilPunchBackMax = 0.9

SWEP.RecoilDirection = Angle(1.1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 440 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = -2 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    {
        Mode = -2,
        RunawayBurst = true,
        PostBurstDelay = 0.5,
    },
	{
		Mode = 0,
   	}
}
SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace

SWEP.AccuracyMOA = 2 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 410 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 65 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 100 -- dispersion that remains even in sights
SWEP.JumpDispersion = 200 -- dispersion penalty when in the air

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "w/firepuncher/blasters_st-w48_laser_close_var_09.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 102, 255)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-2, -0, 1.9),
    Ang = Angle(0, 0, 1),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0
-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.SprintPos = Vector(6, -4, 0)
SWEP.SprintAng = Angle(-16.524, 60, -11.046)

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(1.3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(10.824, -7, 4.897)
SWEP.CustomizeAng = Angle(12.149, 45.547, 45)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = true

SWEP.DefaultElements = {}

SWEP.AttachmentElements = {
    ["ironsight"] = {
        VMElements = {
            {
                Model = "models/arccw/props/e11r_scope/e11r_scope.mdl",
                Bone = "weapon",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0.05, -2.85, 0.8),
                    ang = Angle(-0.3, 0, -90)
                }
            }
        },
        WMElements = { -- Purely handles muzzle effect on the world model
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(20, 0.5, -12),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}


SWEP.Attachments = {
	[1] = {
		PrintName = "Optic", -- print name
		DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
		Slot = "optic",
        DefaultEles = {"ironsight"},
		Bone = "optic", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(0, -0, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.5, -4.4),
            wang = Angle(-10, 2, 180)
        },
        NoWM = false
	},
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.4, 1, 8),
            vang = Angle(90, 0, -0),
            wpos = Vector(14, 1.5, -5.2),
            wang = Angle(-10, 5, -90)
        },
        NoWM = false
    },
    [3] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.5, 1, 5),
            vang = Angle(90, 0, -90),
            wpos = Vector(10, 1.6, -4),
            wang = Angle(0, 0, 180)
        },
    },
    [4] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        Bone = "optic", -- relevant bone any attachments wwill be mostly referring to /
        Offset = {
            vpos = Vector(-0.5, 1.5, 10),
            vang = Angle(90, 0, -90),
            wpos = Vector(17, 0.8, -4.9),
            wang = Angle(-10, 5, 180)            
        },     -- Set this to false if you want the foregrips to display on ViewModels.          
    },
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = {"ammo", "special_ammo"},
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "Magazine", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(2, 0.7, -1.6),
            vang = Angle(180, 0, 0),
            wpos = Vector(9.5, 1.5, -3.8),
            wang = Angle(80, 90, 0) 
        },
    },
    [8] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 0.5, 26),
            vang = Angle(90, 0, -90),
            wpos = Vector(32.5, 0, -8.8),
            wang = Angle(-12, 2.5, 180) 
        },
    },                              
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sights"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["enter_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["exit_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },  
	["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {
				s = "w/firepuncher/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 0.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
			{
				s = "w/firepuncher/overheat_overheated_var_03.mp3", -- "everfall/weapons/miscellaneous/charge/blasters_deathray_charge_start_var_04.mp3"sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 1.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
		}
    },
	["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
	["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--addons/arccw_weapons/lua/weapons/arccw_cr2c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "CR-2C"
SWEP.Trivia_Class = "Naboo Security Blaster Rifle"
SWEP.Trivia_Desc = "preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "Forged Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020
SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_e11.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_cr2c.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 25
SWEP.RangeMin = 160
SWEP.DamageMin = 16
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_green"
SWEP.TracerCol = Color(0, 250, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 45

SWEP.Recoil = 0.27
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.13

SWEP.Delay = 60 / 660
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(0, 255, 21)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/cr2.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-3.13, -11, 1.8),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 50,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2.9, -4, .5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, -10, 0)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.HolsterPos = Vector(0.2, -1, 1)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -13, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"cr2c"}

SWEP.AttachmentElements = {
    ["cr2c"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/CR2c_Base.mdl",
                Bone = "v_e11_reference001",
                Scale = Vector(1.3, 1.3, 1.3),
                Offset = {
                    pos = Vector(-1.2, -1.5, 0.5),
                    ang = Angle(0, -90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/CR2c_Base.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(300, 120, -200),
                    ang = Angle(-15, 0, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}


WMOverride = "models/arccw/sw_battlefront/weapons/CR2c_Base.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -0.8, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(500, 110, -710),
            wang = Angle(-15, 0, 180)
        },
    },    
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 12),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0.2, 2.5, 8),
            vmax = Vector(-0.2, 2.5, 11),
            wmin = Vector(1200, 120, -480), 
            wmax = Vector(1200, 120, -480)  -- how far this attachment can slide in both directions.
        },                 
    },
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 1.5, 11),
            vang = Angle(90, 0, 0),
            wpos = Vector(1150, 230, -550),
            wang = Angle(-15, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        WMScale = Vector(111, 111, 111),
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.1, 2.2, 16.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(2100, 120, -820),
            wang = Angle(-15, 0, -90)
        },
    },             
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [6] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        WMScale = true,
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, 4),
            vang = Angle(0, 0, 0),
            wpos = Vector(650, 10, -300),
            wang = Angle(-15, 90, -90)
        },
    },   
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "e11_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 1.5, 0),
            vang = Angle(90, 0, -70),
            wpos = Vector(400, 200, -470),
            wang = Angle(-10 , 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15s.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dual_dc17s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual DC-17s (V1 - WIP)"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact DC15S Blaster Carbine, preffered for CQB enviroments and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_dc17s.png"

SWEP.DefaultBodygroups = "000000000000"
SWEP.NoHideLeftHandInCustomization = true
SWEP.Damage = 30
SWEP.RangeMin = 145
SWEP.DamageMin = 17
SWEP.Range = 400
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.44
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.17
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 340
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },        
}

SWEP.AccuracyMOA = 0.45 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 410 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 35


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.DistantShootSound = "dc17/SW01_Weapons_Blasters_Shared_Corebass_Close_Tight_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17/SW02_Weapons_Blasters_DC17_Laser_Close_VAR_07 0 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.MuzzleFlashColor = Color(0, 0, 255, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)


SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"dc17s", "dc17s+"}

SWEP.AttachmentElements = {
    ["dc17s"] = {
        VMElements = {
            {
                Model = "models/arccw/fisher/dc17s/dc17s.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(9.5, 2.5, -0.7),
                    ang = Angle(85, -10, 90)
                }
            }
        },
    },
    ["dc17s+"] = {
         VMElements = {
            {
                Model = "models/arccw/fisher/dc17s/dc17s.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1, 1, 1),                
                Offset = {
                    pos = Vector(-9, -3.3, 2.2),
                    ang = Angle(85, -10, -90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/fisher/dc17s/dc17s.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(80, 20, -30),
                    ang = Angle(180, -90, 2)
                }
            },
            {
                Model = "models/arccw/fisher/dc17s/dc17s.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-10, 230, -80),
                    ang = Angle(180, -90, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/fisher/dc17s/dc17s.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-9.5, -2.3, 2),
            vang = Angle(168, 4, -90),
        },
    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [3] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [4] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}   


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dual_defender_sporting.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] Dual 'Defender Sporting'"
SWEP.Trivia_Class = "Dual Blaster Pistol"
SWEP.Trivia_Desc = "Dual Blaster pistols for shooting enviroments"
SWEP.Trivia_Manufacturer = "Drearian Defense Conglomerate"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_defender.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 110
SWEP.DamageMin = 17
SWEP.Range = 310
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 1050


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 330
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/defender.wav"

SWEP.MuzzleFlashColor = Color(255, 165, 18, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"defendersporting", "defendersporting+"}

SWEP.AttachmentElements = {
    ["defendersporting"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/defender_sporting_pistol.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(3, 2, -0.7),
                    ang = Angle(-0, -2, 90)
                }
            }
        },
    },
    ["defendersporting+"] = {
         VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/defender_sporting_pistol.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-3.5, -2.2, 1.2),
                    ang = Angle(-180, -2, -90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/defender_sporting_pistol.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/sw_battlefront/weapons/defender_sporting_pistol.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/sw_battlefront/weapons/defender_sporting_pistol.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
--    [1] = {
--        PrintName = "Tactical", -- print name
--        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
--        Slot = {"tactical","tac_pistol"},
--        VMScale = Vector(0.8, 0.8, 0.8),
--        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
--        Offset = {
--            vpos = Vector(-8, -3.7, 1.3),
 --           vang = Angle(170, 0, 0),
--        },
--    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_duals_dc17ext_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual DC-17 Ext."
SWEP.Trivia_Class = "Heavy Blaster Pistol"
SWEP.Trivia_Desc = "Heavy blaster pistol for CQB enviroments"
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/viewmodels/c_dc17_ext_1_dual.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.NoHideLeftHandInCustomization = true

SWEP.IconOverride = "materials/entities/rw_sw_dual_dc17ext.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 90
SWEP.DamageMin = 23
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 46

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 240
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = true -- disable light flash
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.DistantShootSound = "dc17/SW01_Weapons_Blasters_Shared_Corebass_Close_Tight_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17/SW02_Weapons_Blasters_DC17_Laser_Close_VAR_07 0 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.IronSightStruct = {
    Pos = Vector(0, -0, 0),
    Ang = Angle(0, 0, 0),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -10,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.ReloadPos = Vector(0, -4, 2)
SWEP.ReloadAng = Angle(-10, -0, -0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.DefaultElements = {"nil", "dc17ext+"}

SWEP.AttachmentElements = {
    ["nil"] = {
        WMElements = {
            {
                Model = "models/arccw/fisher/extendeddc17/extendeddc17.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -90, 2)
                }
            },
            {
                Model = "models/arccw/fisher/extendeddc17/extendeddc17.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -90, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "",
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(-0.4, -3.1, -3),
            vang = Angle(90, 0, -90),
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.3, 0, 0),
            vang = Angle(90, 0, -90),
        },
    },
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.4, -1.4, 2),
            vang = Angle(90, 0, -90),
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.24, -2, -2),
            vang = Angle(90, 0, -90),
        },
    },          
    [7] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {""},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 0.5, 0),
            vang = Angle(90, 0, -90),
        },
    },   
    [8] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [9] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 2,
    },
    ["fire"] = {
        Source = {"fire_left", "fire_right"},
    },
    ["ready"] = {
        Source = "deploy",
    },
    ["enter_sight"] = {
        Source = "neutral",
    },
    ["draw"] = {
        Source = "idle",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        Time = 2,
        SoundTable = {
            -- {s = "dc17ext/untitled.ogg", t = 1 / 30},
            {s = "dc17ext/SCIMisc_Insert Ammo_04.ogg", t = 4 / 30},
            {s = "dc17ext/wfoly_pi_mike9_reload_fast_xmags_end.ogg", t = 30 / 30}, --s sound file
        },
    },
    ["bash"] = {
        Source = "melee",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 2,
    },
}
function SWEP:ChooseShootAnim(ifp, ...)
	if self:Clip1() == 2 then
		return self:PlayAnimation(self:GetStat("Animations.shoot1_empty"))
	elseif self:Clip1() == 1 then
		return self:PlayAnimation(self:GetStat("Animations.shoot2_empty"))
	end

	return BaseClass.ChooseShootAnim(self, ifp, ...)
end

--addons/arccw_weapons/lua/weapons/arccw_e5s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Droidenwaffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "E-5s"
SWEP.Trivia_Class = "CIS Sniper Blaster Rifle"
SWEP.Trivia_Desc = "High tech CIS E-5s Sniper Blaster Rifle"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_t21.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_t21.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_e5s.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 105
SWEP.RangeMin = 400
SWEP.DamageMin = 44
SWEP.Range = 800
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 0.44
SWEP.RecoilSide = 0.25
SWEP.RecoilPunch = 0.8
SWEP.RecoilRise = 0.34

SWEP.Delay = 60 / 130
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },        
}

SWEP.AccuracyMOA = 0.6 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50
SWEP.SightsDispersion = 0

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/e5s.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(250, 0, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-1.558, -9, 0.95),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 55,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(5, -5, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)
SWEP.CustomizePos = Vector(12.824, -8, -3.897)
SWEP.CustomizeAng = Angle(10.149, 34.547, 0)

SWEP.DefaultElements = {"e5s", "muzzle"}

SWEP.AttachmentElements = {
    ["e5s"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5s_c_blaster.mdl",
                Bone = "v_t21_reference001",
                Scale = Vector(1.4, 1.4, 1.4),
                Offset = {
                    pos = Vector(0.85, 1, -2.1),
                    ang = Angle(0,-90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "t21_sight",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.5, 2, 33 ),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
       },
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5s_c_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(400, 50.5, 200),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4400, 0, -1300),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/kuro/sw_battlefront/weapons/e5s_c_blaster.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.86, -2, 12),
            vang = Angle(90, 0, -90),
            wpos = Vector(1400, 50, -800),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.5, 2.3, 16),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 2, 13),
            vmax = Vector(-0, 2, 15),
            wmin = Vector(2000, 50, -700), 
            wmax = Vector(2000, 50, -700)  -- how far this attachment can slide in both directions.
        },
    },        
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "v_t21_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 30, 4.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(2300, 50, -850),
            wang = Angle(-15, 0, 180)
        },
    },    
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        NoWM = true,
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 0.7, 23),
            vang = Angle(90, 0, -90),
        },
    },
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, 4),
            vang = Angle(0, 0, 0),
        },
    },        
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "t21_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(2, 0.8, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(600, 100, -300),
            wang = Angle(-10 , 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/overheat_manualcooling_resetfoley_generic_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}

-- AOCRP WAFFENSTATS arccw_e5s - 02.06.2024
SWEP.Damage = 150
SWEP.DamageMin = 100
SWEP.RangeMin = 600
SWEP.Range = 1544
SWEP.Delay = 60 / 120
SWEP.Primary.ClipSize = 15
SWEP.Category = 'KUS'
--addons/arccw_weapons/lua/weapons/arccw_iqa11.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "IQA-11"
SWEP.Trivia_Class = "Galactic Sniper Blaster "
SWEP.Trivia_Desc = "preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "The Bounty Hunter's Guild"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_iqa11.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 145
SWEP.RangeMin = 375
SWEP.DamageMin = 65
SWEP.Range = 800
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 9

SWEP.Recoil = 0.54
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 210
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },      
}

SWEP.AccuracyMOA = 0.52 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50
SWEP.SightsDispersion = 0

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/iqa11.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(250, 0, 0)

SWEP.IronSightStruct = {
    Pos = Vector(-3.3, -3, 1.7),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_05.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1, 0, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"iqa11"}

SWEP.AttachmentElements = {
    ["iqa11"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/IQA11_Rifle_base.mdl", -- using the model-edit i made in like 2 mins lol
                Bone = "v_dlt19_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(.3, -2, 0.5),
                    ang = Angle(0,-90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/IQA11_Rifle_base.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(3.75, 2.5, -1.5),
                    ang = Angle(-15, 0, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}
WMOverride = "models/arccw/sw_battlefront/weapons/IQA11_Rifle_base.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.15, 0, -4),
            vang = Angle(90, 0, -90),
            wpos = Vector(300, 0, -490),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.1, 2.3, 8),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
        vmin = Vector(-0.1, 2.3, 6),
        vmax = Vector(-0.1, 2.3, 10),
        wmin = Vector(1600, 0, -580), 
        wmax = Vector(1600, 0, -580) -- how far this attachment can slide in both directions.
        },         
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 2.5, 12),
            vang = Angle(90, 0, -90),
            wpos = Vector(2000, 0, -700),
            wang = Angle(-15, 0, -180)
        },
    },     
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 1.5, 29),
            vang = Angle(90, 0, -90),
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, -3),
            vang = Angle(0, 0, 0),
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.5, 1.7, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(900, 70, -470),
            wang = Angle(-10 , 0, 180)
        },
    },          
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/overheat_manualcooling_resetfoley_generic_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_k16.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "K-16 'Bryar'"
SWEP.Trivia_Class = "Galactic Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Forged Armory"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_k16.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 80
SWEP.DamageMin = 14
SWEP.Range = 310
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 1050


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_purple"
SWEP.TracerCol = Color(148, 0, 211)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 145
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(148, 0, 211)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/m57.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.94, -8, 0.85),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"k16"}

SWEP.AttachmentElements = {
    ["k16"] = {
        VMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/bryar_pistol.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.05, 1.05, 1.05),
                Offset = {
                    pos = Vector(-0, -05, -05.3),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/bryar_pistol.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(100, 20, 20.3),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/hauptmann/star wars/weapons/bryar_pistol.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -2.4, 3.1),
            vang = Angle(0, 180, 0),
            wpos = Vector(70, 20, -70),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -12, -0.5),
            vang = Angle(0, 90, 0),
            wpos = Vector(160, 20, -50),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [4] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [5] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.2, 0.9, 7),
            vang = Angle(90, 0, -90),
            wpos = Vector(100, 30, -50),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_scattershotgun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "'Scatter Shotgun'"
SWEP.Trivia_Class = "Heavy Blaster Shotgun"
SWEP.Trivia_Desc = "High tech heavy Blaster shotgun, built for piercing the enemy defenses."
SWEP.Trivia_Manufacturer = "Forged Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 70
SWEP.MirrorVMWM = false -- Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = false
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_huntershotgun.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 37
SWEP.RangeMin = 22
SWEP.DamageMin = 16
SWEP.Range = 65
SWEP.Penetration = 1
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_purple"
SWEP.TracerCol = Color(148, 0, 211)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 5

SWEP.Recoil = 1.5
SWEP.RecoilSide = 0.6
SWEP.RecoilPunch = 0.8
SWEP.RecoilRise = 1

SWEP.Delay = 90 / 150
SWEP.Num = 5
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 50 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 610 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(148, 0, 211)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/scatter.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-2.92, -12, 0.7),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 70,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, .8, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(2, -5, 1)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"sg"}

SWEP.AttachmentElements = {
    ["sg"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/bf1/scattergun.mdl",
                Bone = "v_dlt19_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0, 4, -2.5),
                    ang = Angle(0,-90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/bf1/scattergun.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(800, 2.5, -1.5),
                    ang = Angle(-15, 0, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}
WMOverride = "models/arccw/kuro/sw_battlefront/weapons/bf1/scattergun.mdl"
--SWEP.Attachments
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.49, 1.1, -3),
            vang = Angle(90, 0, -90),
            wpos = Vector(600, 90, -590),
            wang = Angle(-15, 0, 180)
        },
    }, 
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 3, 9),
            vang = Angle(90, 0, -90),
            wpos = Vector(1800, 100, -690),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.1, 3.4, 3.4),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0.2, 2.5, 2),
            vmax = Vector(-0.2, 2.5, 9),
            wmin = Vector(1200, 100, -580), 
            wmax = Vector(1200, 100, -580) -- how far this attachment can slide in both directions.
        },   
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        NoWM = true,
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.3, 2.05, 12),
            vang = Angle(90, 0, -90),
            wpos = Vector(2300, 20, -760),
            wang = Angle(-15, 0, 180)
        },
    },             
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 2.1, 0),
            vang = Angle(90, 0, -70),
            wpos = Vector(900, 100, -500),
            wang = Angle(0 , 0, 180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
    },
    ["holster"] = {
        Source = "holster",
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1, 
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_sops_blacksun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "SG-X2 'Invective'"
SWEP.Trivia_Class = "Blaster Shotgun"
SWEP.Trivia_Desc = "'I tried to talk them down. They made a grab for my Spices. After that it was a short conversation.'"
SWEP.IconOverride = "entities/sopsmisc/blacksunshotgun.png"

-- Viewmodel & Entity Properties
SWEP.HideViewmodel = false
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_invective.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/invective.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false
SWEP.WorldModelOffset = {
    pos = Vector(-13, 6, -3),
    ang = Angle(-20, 0, 180)
}

-- Special properties
SWEP.ShotgunReload = true
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 95
SWEP.ShellScale = 2

-- Damage & Tracer
SWEP.Damage = 32 * 5
SWEP.RangeMin = 28
SWEP.DamageMin = 22
SWEP.Range = 119
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 125, 255)
SWEP.TracerWidth = 10
SWEP.PhysTracerProfile = "apex_bullet_energy"
SWEP.Tracer = "arccw_apex_tracer_energy_sniper"
SWEP.HullSize = 1.5

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 8
SWEP.ExtendedClipSize = 12
SWEP.ReducedClipSize = 4

SWEP.Recoil = 1.73
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 1.2
SWEP.RecoilPunch = 2

SWEP.Delay = 60 / 76
SWEP.Num = 5
SWEP.Firemode = 1

SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 50
SWEP.HipDispersion = 460
SWEP.MoveDispersion = 100

-- Speed Mult
SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.77
SWEP.ShootSpeedMult = 1

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 120
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "sops-v2/weapons/blacksun/blacksun.wav"
SWEP.ShootSound = "sops-v2/weapons/blacksun/blacksun2.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.MuzzleEffectAttachment = 1 
SWEP.CaseEffectAttachment = 2
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.128, -10.308, 2.405),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 2, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {       
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita", "ammo_stun"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle_retracted",
    },
	["fire"] = {
        Source = "shoot",
        ShellEjectAt = 0,
        SoundTable = {
            {s = "sops-v2/weapons/blacksun/pump.wav", t = 10/30},
        },
    },
    ["fire_empty"] = {
        Source = {"shoot"},
        ShellEjectAt = 0,
        SoundTable = {
            {s = "sops-v2/weapons/blacksun/blacksunfinal.wav", t = 0.1},
            {s = "sops-v2/weapons/blacksun/pump.wav", t = 10/30},
        },
    },
    ["fire_iron"] = {
        Source = "shootiron",
        ShellEjectAt = 0,
        SoundTable = {
            {s = "sops-v2/weapons/blacksun/pump.wav", t = 10/30},
        },
    },
    ["fire_iron_empty"] = {
        Source = "shootiron",
        ShellEjectAt = 0,
        SoundTable = {
            {s = "sops-v2/weapons/blacksun/blacksunfinal.wav", t = 0.1},
            {s = "sops-v2/weapons/blacksun/pump.wav", t = 10/30},
        },
    },
    ["sgreload_start"] = {
        Source = "start reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "sops-v2/weapons/blacksun/blacksunrstart.wav", t = 0.1},
                    },
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0,
    },
    ["sgreload_insert"] = {
        Source = "insert",
        RestoreAmmo = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "sops-v2/weapons/blacksun/blacksunrshell.wav", t = 3/30},
                    },
        TPAnimStartTime = 0.3,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["sgreload_finish"] = {
        Source = "finish reload",
        SoundTable = {
                        {s = "sops-v2/weapons/blacksun/blacksunrend.wav", t = 0.01},
                    },
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.4,
    },  
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip1.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_dlt24x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "[MG] DLT-24x"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "In need of a heavy weapon capable of destroying Rebel scum, Blastech Industries designed and created a portable destruction machine. The DLT-23v was born with a single objective: that nothing and no one who is the target remains alive."
SWEP.IconOverride = "entities/sopsmisc/dlt24x.png"

-- Viewmodel & Entity Properties
SWEP.HideViewmodel = false
SWEP.UseHands = true
SWEP.WorldModel = "models/arccw/kraken/sops-v2/w_wk_stik_helg.mdl"
SWEP.ViewModel = "models/arccw/kraken/sops-v2/v_wk_stik_helg.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}


-- Damage & Tracer
SWEP.Damage = 20
SWEP.RangeMin = 250
SWEP.DamageMin = 10
SWEP.Range = 600
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 185
SWEP.ExtendedClipSize = 220
SWEP.ReducedClipSize = 125

SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.VisualRecoilMult = 1.28
SWEP.Recoil = 0.72
SWEP.RecoilSide = 0.22
SWEP.RecoilRise = 0.76

SWEP.Delay = 60 / 250
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 0
    }
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.4

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 110 
SWEP.ShootPitch = 50 
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "sops-v2/weapons/dlt24x.wav"
SWEP.ShootSound = "sops-v2/weapons/dlt24x.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.022, -10.058, 4.631),
    Ang = Angle(0, -0.274, 0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "smg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 2)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/w_wk_stik_helg.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(700, 0, -100),
                    ang = Angle(0, 0, -180),
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4700, 140, -200),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        }, 
    }
}WMOverride = "models/weapons/jackswan/krieg/w_wk_stik_helg.mdl"

SWEP.Attachments = {   
    {
        PrintName = "Optic",
        DefaultAttName = "None",
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "WeaponBone",
        Offset = {
            vpos = Vector(-4.2, -14, -0.2),
            vang = Angle(0, 90, 90),
            wpos = Vector(1200, 0, -760),
            wang = Angle(0, 0, 180)
        },
        CorrectiveAng = Angle(0, -180, -180),
        CorrectivePos = Vector(0, 0, 0),
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(111, 111, 111),
        Bone = "WeaponBone",
        Offset = {
            vpos = Vector(-6.5, -29, 0.95),
            vang = Angle(0, 90, -180),
            wpos = Vector(2600, 100, -520),
            wang = Angle(0, 0, -90)
        },
    },  
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(111, 111, 111),
        Bone = "WeaponBone",
        Offset = {
            vpos = Vector(-6.2, -48, 0.2),
            vang = Angle(0, 90, -180),
            wpos = Vector(5100, 0, -500),
            wang = Angle(0, -1, 180)
        },
    },  
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "WeaponBone",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(-6.5, -10, 1.2),
            vang = Angle(0, 90, 90),
            wpos = Vector(670, 140, -550),
            wang = Angle(0, 0, 180)
        },
    },     
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "shoot",
    },
    ["fire_iron"] = {
        Source = "shoot",
    },
    ["trigger"] = {
        Source = "fidget",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "sops-v2/weapons/z6_chain/trigger.wav", t = 0.1/30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    }, 
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "weapon_hand/reload_gentle/other/023d-000000b6.mp3", t = 0.1 / 30},
            {s = "weapon_hand/reload_gentle/other/023d-000003f5.mp3", t = 20 / 30},
            {s = "weapon_hand/reload_gentle/other/023d-000000b7.mp3", t = 30 / 30},
            {s = "weapon_hand/reload_gentle/locknload/023d-00000a92.mp3", t = 3.2},
        },
    },
}

SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end
--addons/arccw_weapons/lua/weapons/arccw_westar34.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] Westar-34"
SWEP.Trivia_Class = "Galactic Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Concordian Crescent Technologies"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_westar34.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 95
SWEP.DamageMin = 14
SWEP.Range = 295
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 1050


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(255, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 16

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 245
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/westar34.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.75, -8, 1.2),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"westar34"}

SWEP.AttachmentElements = {
    ["westar34"] = {
        VMElements = {
            {
                Model = "models/arccw/cs574/weapons/westar34.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(-0.25, -4, -0.80),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/cs574/weapons/westar34.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(70, 20, -15.3),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/cs574/weapons/westar34.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, -2.4, 2.9),
            vang = Angle(0, 180, 0),
            wpos = Vector(70, 20, -55),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.1, -9, 2),
            vang = Angle(0, 90, 0),
            wpos = Vector(115, 20, -58),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 0.3, 8.6),
            vang = Angle(90, 0, -90),
        },
    },        
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.6, 0.5, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(60, 22, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--lua/weapons/baton/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = " Baton"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Simple"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(52, 39, 0, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(52, 39, 0, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(52, 39, 0, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 5, 0), size = Vector(0.05, 0.039, 0.108), color = Color(52, 39, 0, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 15
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.98
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Impact.Sand"
SWEP.Primary.Range       = 12

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/tools/lua/weapons/gmod_tool/stools/rb655_easy_animation.lua:

TOOL.Category = "Robotboy655"
TOOL.Name = "#tool.rb655_easy_animation.name"
TOOL.AnimationArray = {}

local gLastSelecetedEntity = NULL
TOOL.SelecetedEntity = NULL

TOOL.ClientConVar[ "anim" ] = ""
TOOL.ClientConVar[ "speed" ] = "1.0"
TOOL.ClientConVar[ "delay" ] = "0"
TOOL.ClientConVar[ "nohide" ] = "0"
TOOL.ClientConVar[ "loop" ] = "0"
TOOL.ClientConVar[ "noglow" ] = "0"

TOOL.ServerConVar[ "nobbox_sv" ] = "0"
CreateConVar( "rb655_easy_animation_nobbox_sv", "0", FCVAR_ARCHIVE )

local function MakeNiceName( str )
	local newname = {}
	for _, s in pairs( string.Explode( "_", string.Replace( str, " ", "_" ) ) ) do
		if ( string.len( s ) == 0 ) then continue end
		if ( string.len( s ) == 1 ) then table.insert( newname, string.upper( s ) ) continue end
		table.insert( newname, string.upper( string.Left( s, 1 ) ) .. string.Right( s, string.len( s ) - 1 ) ) -- Ugly way to capitalize first letters.
	end

	return string.Implode( " ", newname )
end

local function IsEntValid( ent )
	if ( !IsValid( ent ) or ent:IsWorld() ) then return false end
	if ( table.Count( ent:GetSequenceList() or {} ) != 0 ) then return true end
	return false
end

local function PlayAnimationBase( ent, anim, speed )
	if ( !IsValid( ent ) ) then return end

	-- HACK: This is not perfect, but it will have to do
	if ( ent:GetClass() == "prop_dynamic" ) then
		ent:Fire( "SetAnimation", anim )
		ent:Fire( "SetPlaybackRate", math.Clamp( tonumber( speed ), 0.05, 3.05 ) )
		return
	end

	ent:ResetSequence( ent:LookupSequence( anim ) )
	ent:ResetSequenceInfo()
	ent:SetCycle( 0 )
	ent:SetPlaybackRate( math.Clamp( tonumber( speed ), 0.05, 3.05 ) )

end

local UniqueID = 0
function PlayAnimation( ply, ent, anim, speed, delay, loop, isPreview )
	if ( !IsValid( ent ) ) then return end

	delay = tonumber( delay ) or 0
	loop = tobool( loop ) or false

	UniqueID = UniqueID + 1
	local tid = "rb655_animation_loop_" .. ply:UniqueID() .. "-" .. UniqueID

	if ( isPreview ) then tid = "rb655_animation_loop_preview" .. ply:UniqueID() end

	timer.Create( tid, delay, 1, function()
		PlayAnimationBase( ent, anim, speed )
		if ( loop == true && IsValid( ent ) ) then
			timer.Adjust( tid, ent:SequenceDuration() / speed, 0, function()
				if ( !IsValid( ent ) ) then timer.Remove( tid ) return end
				PlayAnimationBase( ent, anim, speed )
			end )
		end
	end )
end

function TOOL:GetSelecetedEntity()
	return self:GetWeapon():GetNWEntity( 1, self.SelecetedEntity )
end

function TOOL:SetSelecetedEntity( ent )
	if ( IsValid( ent ) && ent:GetClass() == "prop_effect" ) then ent = ent.AttachedEntity end
	if ( !IsValid( ent ) ) then ent = NULL end

	if ( self:GetSelecetedEntity() == ent ) then return end
	self.SelecetedEntity = ent

	self:GetWeapon():SetNWEntity( 1, ent )
end

local gOldCVar1 = GetConVarNumber( "ai_disabled" )
local gOldCVar2 = GetConVarNumber( "rb655_easy_animation_nohide" )

function TOOL:Think()
	local ent = self:GetSelecetedEntity()
	if ( !IsValid( ent ) ) then self:SetSelecetedEntity( NULL ) end

	if ( CLIENT ) then
		if ( gOldCVar1 != GetConVarNumber( "ai_disabled" ) or gOldCVar2 != GetConVarNumber( "rb655_easy_animation_nohide" ) ) then
			gOldCVar1 = GetConVarNumber( "ai_disabled" )
			gOldCVar2 = GetConVarNumber( "rb655_easy_animation_nohide" )
			if ( IsEntValid( ent ) && ent:IsNPC() ) then self:UpdateControlPanel() end
		end
		if ( ent:EntIndex() == gLastSelecetedEntity ) then return end
		gLastSelecetedEntity = ent:EntIndex()
		self:UpdateControlPanel()
		RunConsoleCommand( "rb655_easy_animation_anim", "" )
	end
end

function TOOL:RightClick( trace )
	if ( SERVER ) then self:SetSelecetedEntity( trace.Entity ) end
	return true
end

function TOOL:Reload( trace )
	if ( SERVER ) then
		if ( #self.AnimationArray <= 0 && IsValid( self:GetSelecetedEntity() ) ) then
			self:GetSelecetedEntity():SetPlaybackRate( 0 )
		elseif ( #self.AnimationArray > 0 ) then
			for id, t in pairs( self.AnimationArray ) do
				if ( IsValid( t.ent ) ) then t.ent:SetPlaybackRate( 0 ) end
			end
		end

		-- Destroy all timers.
		for i = 0, UniqueID do timer.Remove( "rb655_animation_loop_" .. self:GetOwner():UniqueID() .. "-" .. i ) UniqueID = 0 end
		timer.Remove( "rb655_animation_loop_preview" .. self:GetOwner():UniqueID() )
	end
	return true
end

if ( SERVER ) then
	util.AddNetworkString( "rb655_easy_animation_array" )

	function TOOL:LeftClick( trace )
		local ent = self:GetSelecetedEntity()
		local anim = self:GetClientInfo( "anim" )

		for i = 0, UniqueID do timer.Remove( "rb655_animation_loop_" .. self:GetOwner():UniqueID() .. "-" .. i ) UniqueID = 0 end
		timer.Remove( "rb655_animation_loop_preview" .. self:GetOwner():UniqueID() )

		if ( #self.AnimationArray > 0 ) then
			for id, t in pairs( self.AnimationArray ) do
				if ( !IsEntValid( t.ent ) or string.len( string.Trim( t.anim ) ) == 0 ) then continue end
				PlayAnimation( self:GetOwner(), t.ent, t.anim, t.speed, t.delay, t.loop )
			end
		else
			if ( !IsEntValid( ent ) or string.len( string.Trim( anim ) ) == 0 ) then return end
			PlayAnimation( self:GetOwner(), ent, anim, self:GetClientInfo( "speed" ), self:GetClientInfo( "delay" ), self:GetClientInfo( "loop" ), true )
		end

		return true
	end

	concommand.Add( "rb655_easy_animation_anim_do", function( ply, cmd, args )
		local tool = ply:GetTool( "rb655_easy_animation" )
		if ( !tool ) then return end

		local ent = tool:GetSelecetedEntity()
		if ( !IsEntValid( ent ) ) then return end

		for i = 0, UniqueID do timer.Remove( "rb655_animation_loop_" .. ply:UniqueID() .. "-" .. i ) UniqueID = 0 end
		timer.Remove( "rb655_animation_loop_preview" .. ply:UniqueID() )

		PlayAnimation( ply, ent, args[ 1 ] or "", ply:GetTool( "rb655_easy_animation" ):GetClientInfo( "speed" ), 0, ply:GetTool():GetClientInfo( "loop" ), true )
	end )

	concommand.Add( "rb655_easy_animation_set_pp", function( ply, cmd, args )
		local tool = ply:GetTool( "rb655_easy_animation" )
		if ( !tool ) then return end

		local ent = tool:GetSelecetedEntity()
		if ( !IsEntValid( ent ) ) then return end

		local pp_name = ent:GetPoseParameterName( math.floor( tonumber( args[ 1 ] ) ) )
		if ( !pp_name ) then return end

		ent:SetPoseParameter( pp_name, tonumber( args[ 2 ] ) )
	end )

	concommand.Add( "rb655_easy_animation_add", function( ply, cmd, args )
		local tool = ply:GetTool( "rb655_easy_animation" )
		if ( !tool ) then return end
		local e = tool:GetSelecetedEntity()
		local a = tool:GetClientInfo( "anim" )
		local s = tool:GetClientInfo( "speed" )
		local d = tool:GetClientInfo( "delay" )
		local l = tool:GetClientInfo( "loop" )
		if ( !IsEntValid( e ) or string.len( string.Trim( a ) ) == 0 ) then return end

		table.insert( tool.AnimationArray, {ent = e, anim = a, speed = s, delay = d, loop = l, ei = e:EntIndex()} )
		net.Start( "rb655_easy_animation_array" )
			net.WriteTable( tool.AnimationArray )
		net.Send( ply )
	end )

	concommand.Add( "rb655_easy_animation_rid", function( ply, cmd, args ) -- rid is for RemoveID
		local tool = ply:GetTool( "rb655_easy_animation" )
		if ( !tool.AnimationArray[ tonumber( args[ 1 ] ) ] ) then return end
		if ( tool.AnimationArray[ tonumber( args[ 1 ] ) ].ei != tonumber( args[ 2 ] ) && tonumber( args[ 2 ] ) != 0 ) then return end

		table.remove( tool.AnimationArray, tonumber( args[ 1 ] ) )
		net.Start( "rb655_easy_animation_array" )
			net.WriteTable( tool.AnimationArray )
		net.Send( ply )
	end )
end

if ( SERVER ) then return end

TOOL.Information = {
	{ name = "info", stage = 1 },
	{ name = "left" },
	{ name = "right" },
	{ name = "reload" },
}

language.Add( "tool.rb655_easy_animation.left", "Play all animations" )
language.Add( "tool.rb655_easy_animation.right", "Select an object to play animations on" )
language.Add( "tool.rb655_easy_animation.reload", "Pause currently playing animation(s)" )

language.Add( "tool.rb655_easy_animation.name", "Easy Animation Tool" )
language.Add( "tool.rb655_easy_animation.desc", "Easy animations for everyone" )
language.Add( "tool.rb655_easy_animation.1", "Use context menu to play animations" )

language.Add( "tool.rb655_easy_animation.animations", "Animations" )
language.Add( "tool.rb655_easy_animation.add", "Add current selection" )
language.Add( "tool.rb655_easy_animation.add.help", "\nIf you want to play animations on multiple entities at one:\n1) Select entity\n2) Select animation from the list, if the entity has any.\n3) Configure sliders to your desire.\n4) Click \"Add current selection\"\n5) Do 1-4 steps as many times as you wish.\n6) Left-click\n\nYou cannot play two animations on the same entity at the same time. The last animation will cut off the first one." )
language.Add( "tool.rb655_easy_animation.speed", "Animation Speed" )
language.Add( "tool.rb655_easy_animation.speed.help", "How fast the animation will play." )
language.Add( "tool.rb655_easy_animation.delay", "Delay" )
language.Add( "tool.rb655_easy_animation.delay.help", "The time between you left-click and the animation is played." )
language.Add( "tool.rb655_easy_animation.loop", "Loop Animation" )
language.Add( "tool.rb655_easy_animation.loop.help", "Play animation again when it ends." )
language.Add( "tool.rb655_easy_animation.nohide", "Do not filter animations" )
language.Add( "tool.rb655_easy_animation.nohide.help", "Enabling this option will show you the full list of animations available for selected entity. Please note, that this list can be so long, that GMod may freeze for a few seconds. For this reason we hide a bunch of animations deemed \"useless\" by default, such as gestures and other delta animations." )
language.Add( "tool.rb655_easy_animation.poseparam.help", "The sliders above are the Pose Parameters. They affect how certain animations look, for example the direction for Team Fortress 2 run animations, etc." )
language.Add( "tool.rb655_easy_animation.poseparam.badent", "Changing Pose Parameters is only supported on Animatable props!" )

language.Add( "tool.rb655_easy_animation.ai", "NPC is selected, but NPC thinking is not disabled! Without that the NPC will reset its animations every frame." )
language.Add( "tool.rb655_easy_animation.ragdoll", "Ragdolls cannot be animated! Open context menu (Hold C) > right click on ragdoll > Make Animatable" )
language.Add( "tool.rb655_easy_animation.prop", "Props cannot be animated properly! Open context menu (Hold C) > right click on entity > Make Animatable" )
language.Add( "tool.rb655_easy_animation.badent", "This entity does not have any animations." )
language.Add( "tool.rb655_easy_animation.noent", "No entity selected." )

language.Add( "tool.rb655_easy_animation.noglow", "Don't render glow/halo around models" )
language.Add( "tool.rb655_easy_animation.noglow.help", "Don't render glow/halo around models when they are selected, and don't draw bounding boxes below animated models. Bounding boxes are a helper for when animations make the ragdolls go outside of their bounding box making them unselectable.\n" )

language.Add( "tool.rb655_easy_animation.property", "Make Animatable" )
language.Add( "tool.rb655_easy_animation.property_bodyxy", "Animate Movement Pose Parameters" )
language.Add( "tool.rb655_easy_animation.property_damageragdoll", "Ragdoll/Gib on Damage" )
language.Add( "tool.rb655_easy_animation.property_ragdoll", "Make Ragdoll" )
language.Add( "prop_animatable", "Animatable Entity" )

function TOOL:GetStage()
	if ( IsValid( self:GetSelecetedEntity() ) ) then return 1 end
	return 0
end

net.Receive( "rb655_easy_animation_array", function( len )
	local tool = LocalPlayer():GetTool( "rb655_easy_animation" )
	tool.AnimationArray = net.ReadTable()
	if ( CLIENT ) then tool:UpdateControlPanel() end
end )

function TOOL:UpdateControlPanel( index )
	local panel = controlpanel.Get( "rb655_easy_animation" )
	if ( !panel ) then MsgN( "Couldn't find rb655_easy_animation panel!" ) return end

	panel:ClearControls()
	self.BuildCPanel( panel, self:GetSelecetedEntity() )
end

local clr_err = Color( 200, 0, 0 )
function TOOL.BuildCPanel( panel, ent )

	local tool = LocalPlayer() && LocalPlayer():GetTool( "rb655_easy_animation" )
	local nohide = false

	if ( tool ) then
		if ( !IsValid( ent ) ) then ent = tool:GetSelecetedEntity() end
		nohide = tool:GetClientNumber( "nohide" ) != 0
	end

	if ( !IsValid( ent ) ) then

		panel:AddControl( "Label", { Text = "#tool.rb655_easy_animation.noent" } ):SetTextColor( clr_err )

	elseif ( IsEntValid( ent ) ) then

		local fine = true

		if ( GetConVarNumber( "ai_disabled" ) == 0 && ent:IsNPC() ) then panel:AddControl( "Label", {Text = "#tool.rb655_easy_animation.ai"} ):SetTextColor( clr_err ) fine = false end
		if ( ent:GetClass() == "prop_ragdoll" ) then panel:AddControl( "Label", { Text = "#tool.rb655_easy_animation.ragdoll" } ):SetTextColor( clr_err ) fine = false end
		if ( ent:GetClass() == "prop_physics" or ent:GetClass() == "prop_physics_multiplayer" or ent:GetClass() == "prop_physics_override" ) then panel:AddControl( "Label", { Text = "#tool.rb655_easy_animation.prop" } ):SetTextColor( clr_err ) end

		local t = {}
		local badBegginings = { "g_", "p_", "e_", "b_", "bg_", "hg_", "tc_", "aim_", "turn", "gest_", "pose_", "pose_", "auto_", "layer_", "posture", "bodyaccent", "a_" }
		local badStrings = { "gesture", "posture", "_trans_", "_rot_", "gest", "aim", "bodyflex_", "delta", "ragdoll", "spine", "arms" }
		for k, v in SortedPairsByValue( ent:GetSequenceList() ) do
			local isbad = false

			for i, s in pairs( badStrings ) do if ( string.find( string.lower( v ), s, 1, true ) != nil ) then isbad = true break end end
			if ( isbad == true && !nohide ) then continue end

			for i, s in pairs( badBegginings ) do if ( s == string.Left( string.lower( v ), string.len( s ) ) ) then isbad = true break end end
			if ( isbad == true && !nohide ) then continue end

			language.Add( "rb655_anim_" .. v, MakeNiceName( v ) )
			t[ "#rb655_anim_" .. v ] = { rb655_easy_animation_anim = v, rb655_easy_animation_anim_do = v }
		end

		if ( fine ) then
			local filter = panel:AddControl( "TextBox", { Label = "#spawnmenu.quick_filter_tool" } )
			filter:SetUpdateOnType( true )

			local animList = panel:AddControl( "ListBox", { Label = "#tool.rb655_easy_animation.animations", Options = t, Height = 225 } )

			-- patch the function to take into account visiblity
			function animList:DataLayout()
				local y = 0
				for k, Line in ipairs( self.Sorted ) do
					if ( !Line:IsVisible() ) then continue end

					Line:SetPos( 1, y )
					Line:SetSize( self:GetWide() - 2, self.m_iDataHeight )
					Line:DataLayout( self )

					Line:SetAltLine( k % 2 == 1 )

					y = y + Line:GetTall()
				end

				return y
			end

			filter.OnValueChange = function( s, txt )
				for id, pnl in pairs( animList:GetCanvas():GetChildren() ) do
					if ( !pnl:GetValue( 1 ):lower():find( txt:lower(), 1, true ) ) then
						pnl:SetVisible( false )
					else
						pnl:SetVisible( true )
					end
				end
				animList:SetDirty( true )
				animList:InvalidateLayout()
			end
		end
	
	elseif ( !IsEntValid( ent ) ) then

		panel:AddControl( "Label", { Text = "#tool.rb655_easy_animation.badent" } ):SetTextColor( clr_err )

	end

	if ( IsValid( ent ) && ent:GetClass() == "prop_animatable" ) then
		for k = 0, ent:GetNumPoseParameters() - 1 do
			local min, max = ent:GetPoseParameterRange( k )
			local name = ent:GetPoseParameterName( k )

			local ctrl = panel:NumSlider( name, nil, min, max, 2 )
			ctrl:SetHeight( 11 ) -- This makes the controls all bunched up like how we want
			ctrl:DockPadding( 0, -6, 0, -4 ) -- Try to make the lower part of the text visible
			ctrl:SetValue( math.Remap( ent:GetPoseParameter( name ), 0, 1, min, max ) )

			ctrl.OnValueChanged = function( self, value )
				RunConsoleCommand( "rb655_easy_animation_set_pp", k, value )

				--ent:SetPoseParameter( ent:GetPoseParameterName( k ), math.Remap( value, min, max, 0, 1 ) )
				ent:SetPoseParameter( ent:GetPoseParameterName( k ), value )
			end
		end

		if ( ent:GetNumPoseParameters() > 0 ) then
			panel:ControlHelp( "#tool.rb655_easy_animation.poseparam.help" ):DockMargin( 32, 8, 32, 8 )
		end
	
	elseif ( IsValid( ent ) && ent:GetClass() != "prop_animatable" && ent:GetNumPoseParameters() > 0 ) then
		local errlbl = panel:ControlHelp( "#tool.rb655_easy_animation.poseparam.badent" )
		errlbl:DockMargin( 32, 8, 32, 8 )
		errlbl:SetTextColor( clr_err )
	end

	local pnl = vgui.Create( "DPanelList" )
	pnl:SetHeight( 225 )
	pnl:EnableHorizontal( false )
	pnl:EnableVerticalScrollbar( true )
	pnl:SetSpacing( 2 )
	pnl:SetPadding( 2 )
	Derma_Hook( pnl, "Paint", "Paint", "Panel" ) -- Awesome GWEN background

	if ( tool && tool.AnimationArray ) then
		for i, d in pairs( tool.AnimationArray ) do
			local s = vgui.Create( "RAnimEntry" )
			s:SetInfo( i, d.ent, d.anim, d.speed, d.delay, d.loop )
			pnl:AddItem( s )
		end
	end

	panel:AddPanel( pnl )

	panel:AddControl( "Button", { Label = "#tool.rb655_easy_animation.add", Command = "rb655_easy_animation_add" } )
	panel:ControlHelp( "#tool.rb655_easy_animation.add.help" )
	panel:AddControl( "Slider", { Label = "#tool.rb655_easy_animation.speed", Type = "Float", Min = 0.05, Max = 3.05, Command = "rb655_easy_animation_speed", Help = true } )
	panel:AddControl( "Slider", { Label = "#tool.rb655_easy_animation.delay", Type = "Float", Min = 0, Max = 32, Command = "rb655_easy_animation_delay", Help = true } )
	panel:AddControl( "Checkbox", { Label = "#tool.rb655_easy_animation.loop", Command = "rb655_easy_animation_loop", Help = true } )
	panel:AddControl( "Checkbox", { Label = "#tool.rb655_easy_animation.nohide", Command = "rb655_easy_animation_nohide", Help = true } )
	panel:AddControl( "Checkbox", { Label = "#tool.rb655_easy_animation.noglow", Command = "rb655_easy_animation_noglow", Help = true } )
end

function TOOL:DrawHUD()
	local ent = self:GetSelecetedEntity()
	if ( !IsValid( ent ) or tobool( self:GetClientNumber( "noglow" ) ) ) then return end

	local t = { ent }
	if ( ent.GetActiveWeapon ) then table.insert( t, ent:GetActiveWeapon() ) end
	halo.Add( t, HSVToColor( ( CurTime() * 3 ) % 360, math.abs( math.sin( CurTime() / 2 ) ), 1 ), 2, 2, 1 )
end

local PANEL = {}

function PANEL:Init()
	self.ent = nil
	self.anim = "attack01"
	self.id = 0
	self.eid = 0
	self.speed = 1
	self.delay = 0
	self.loop = false

	self.rem = vgui.Create( "DImageButton", self )
	self.rem:SetImage( "icon16/cross.png" )
	self.rem:SetSize( 16, 16 )
	self.rem:SetPos( 4, 4 )
	self.rem.DoClick = function()
		self:RemoveFull()
	end
end

function PANEL:RemoveFull()
	self.rem:Remove()
	self:Remove()
	RunConsoleCommand( "rb655_easy_animation_rid", self.id, self.eid )
end

function PANEL:Paint( w, h )
	draw.RoundedBox( 2, 0, 0, w, h, Color( 50, 50, 50, 225 ) )
	if ( !self.ent or !IsValid( self.ent ) ) then self:RemoveFull() return end

	surface.SetFont( "DermaDefault" )
	draw.SimpleText( "#" .. self.ent:GetClass(), "DermaDefault", 24, 0, Color( 255, 255, 255, 255 ) )
	draw.SimpleText( "#rb655_anim_" .. self.anim, "DermaDefault", 24, 10, Color( 255, 255, 255, 255 ) )

	local tW = surface.GetTextSize( "#" .. self.ent:GetClass() )
	draw.SimpleText( " #" .. self.ent:EntIndex(), "DermaDefault", 24 + tW, 0, Color( 255, 255, 255, 255 ) )

	local tW2 = surface.GetTextSize( "#rb655_anim_" .. self.anim )
	local t = " [ S: " .. self.speed .. ", D: " .. self.delay
	if ( self.loop ) then t = t .. ", Looping" end
	draw.SimpleText( t .. " ]", "DermaDefault", 24 + tW2, 10, Color( 255, 255, 255, 255 ) )
end

function PANEL:SetInfo( id, e, a, s, d, l )
	self.id = id
	self.eid = e:EntIndex()
	self.ent = e
	self.anim = a
	self.speed = s
	self.delay = d
	self.loop = tobool( l )
end

vgui.Register( "RAnimEntry", PANEL, "Panel" )

--addons/tools/lua/improvedstacker/localization.lua:
--local prefix = "#tool."..debug.getinfo( 1, "S" ).source:match(".+[/?\\?](.+)%.lua").."."

local prefix = "#tool.stacker_improved."

localify.Bind( "en",    prefix.."language_en",    "English" )
localify.Bind( "bg",    prefix.."language_bg",    "Български" )
localify.Bind( "fr",    prefix.."language_fr",    "Français" )
localify.Bind( "pl",    prefix.."language_pl",    "Polski" )
localify.Bind( "ru",    prefix.."language_ru",    "Русский" )
localify.Bind( "zh-cn", prefix.."language_zh-cn", "简体中文" )
localify.Bind( "de",    prefix.."language_de",    "Deutsch" )

--[[--------------------------------------------------------------------------
-- English Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "en", prefix.."name",                     "Stacker - Improved" )
localify.Bind( "en", prefix.."desc",                     "Easily stack duplicated props in any direction" )
localify.Bind( "en", prefix.."left",                     "Create a stack" )
localify.Bind( "en", prefix.."shift_left",               "Increase stack size" )
localify.Bind( "en", prefix.."right",                    "Create a single prop" )
localify.Bind( "en", prefix.."shift_right",              "Decrease stack size" )
localify.Bind( "en", prefix.."reload",                   "Change stack direction" )
localify.Bind( "en", "Undone_stacker_improved",          "Undone stacked prop(s)" )
-- Errors
localify.Bind( "en", prefix.."error_blocked_by_server",  "The server has blocked you from changing this console variable" )
localify.Bind( "en", prefix.."error_not_admin",          "You must be in the 'admin' usergroup to change this console variable" )
localify.Bind( "en", prefix.."error_invalid_argument",   "You must enter a valid number value" )
localify.Bind( "en", prefix.."error_max_per_stack",      "The max props that can be stacked at once is limited to " )
localify.Bind( "en", prefix.."error_too_quick",          "You are using stacker too quickly" )
localify.Bind( "en", prefix.."error_max_per_player",     "Stacker prop limit reached" )
localify.Bind( "en", prefix.."error_not_in_world",       "Stacked props must be spawned within the world" )
localify.Bind( "en", prefix.."error_max_constraints",    "Failed to create constraint, most likely ran out of entity slots" )
-- Labels
localify.Bind( "en", prefix.."label_presets",            "Stacker Presets: " )
localify.Bind( "en", prefix.."label_relative",           "Stack relative to: " )
localify.Bind( "en", prefix.."label_direction",          "Stack direction: " )
localify.Bind( "en", prefix.."label_count",              "Stack size" )
localify.Bind( "en", prefix.."label_reset_offsets",      "Reset offsets" )
localify.Bind( "en", prefix.."label_reset_angles",       "Reset angles" )
localify.Bind( "en", prefix.."label_show_settings",      "Click to show settings" )
localify.Bind( "en", prefix.."label_hide_settings",      "Click to hide settings" )
localify.Bind( "en", prefix.."label_x",                  "X  (-back, +front)" )
localify.Bind( "en", prefix.."label_y",                  "Y  (-left, +right)" )
localify.Bind( "en", prefix.."label_z",                  "Z  (-down, +up)" )
localify.Bind( "en", prefix.."label_pitch",              "Pitch  (-down, +up)" )
localify.Bind( "en", prefix.."label_yaw",                "Yaw   (-left, +right)" )
localify.Bind( "en", prefix.."label_roll",               "Roll    (-left, +right)" )
localify.Bind( "en", prefix.."label_language",           "Language: " )
localify.Bind( "en", prefix.."label_credits",            "" )
localify.Bind( "en", prefix.."label_max_per_stack",      "Stack size" )
localify.Bind( "en", prefix.."label_max_per_player",     "Props per player" )
localify.Bind( "en", prefix.."label_max_offsetx",        "Maximum X offset" )
localify.Bind( "en", prefix.."label_max_offsety",        "Maximum Y offset" )
localify.Bind( "en", prefix.."label_max_offsetz",        "Maximum Z offset" )
localify.Bind( "en", prefix.."label_delay",              "Delay" )
localify.Bind( "en", prefix.."label_opacity",            "Opacity" )
-- Checkboxes
localify.Bind( "en", prefix.."checkbox_freeze",          "Freeze stacked props" )
localify.Bind( "en", prefix.."checkbox_weld",            "Weld stacked props" )
localify.Bind( "en", prefix.."checkbox_nocollide",       "No-Collide stacked props with each other" )
localify.Bind( "en", prefix.."checkbox_nocollide_all",   "No-Collide stacked props with EVERYTHING" )
localify.Bind( "en", prefix.."checkbox_use_shift_key",   "Change stack size with SHIFT + left/right-click" )
localify.Bind( "en", prefix.."checkbox_relative",        "Stack relative to new rotation" )
localify.Bind( "en", prefix.."checkbox_material",        "Apply material" )
localify.Bind( "en", prefix.."checkbox_color",           "Apply color" )
localify.Bind( "en", prefix.."checkbox_physprop",        "Apply physical properties" )
localify.Bind( "en", prefix.."checkbox_ghost",           "Ghost all props in the stack" )
localify.Bind( "en", prefix.."checkbox_halo",            "Add halos to ghosted props" )
localify.Bind( "en", prefix.."checkbox_halo_color",      "Halo color" )
localify.Bind( "en", prefix.."checkbox_axis",            "Draw XYZ axis" )
localify.Bind( "en", prefix.."checkbox_axis_labels",     "Draw XYZ axis labels" )
localify.Bind( "en", prefix.."checkbox_axis_angles",     "Draw XYZ axis angles" )
localify.Bind( "en", prefix.."checkbox_stayinworld",     "Stay in world" )
-- Comboboxes
localify.Bind( "en", prefix.."combobox_world",           "World" )
localify.Bind( "en", prefix.."combobox_prop",            "Prop" )
localify.Bind( "en", prefix.."combobox_direction_up",    "Up" )
localify.Bind( "en", prefix.."combobox_direction_down",  "Down" )
localify.Bind( "en", prefix.."combobox_direction_front", "Front" )
localify.Bind( "en", prefix.."combobox_direction_back",  "Back" )
localify.Bind( "en", prefix.."combobox_direction_right", "Right" )
localify.Bind( "en", prefix.."combobox_direction_left",  "Left" )
localify.Bind( "en", prefix.."combobox_default",         "Default" )
localify.Bind( "en", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "en", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "en", prefix.."combobox_singleplayer",    "Singleplayer" )
-- HUD
localify.Bind( "en", prefix.."hud_front",                "Front" )
localify.Bind( "en", prefix.."hud_right",                "Right" )
localify.Bind( "en", prefix.."hud_up",                   "Up" )
-- Help
localify.Bind( "en", prefix.."help_max_per_player",      "Maximum stacked props each player is limited to." )
localify.Bind( "en", prefix.."help_max_per_stack",       "Maximum props per stack (left-click)." )
localify.Bind( "en", prefix.."help_delay",               "Delay (in seconds) between each Stacker use (left/right-click)" )
localify.Bind( "en", prefix.."help_max_offsetx",         "Maximum distance between stacked props (X-axis)." )
localify.Bind( "en", prefix.."help_max_offsety",         "Maximum distance between stacked props (Y-axis)." )
localify.Bind( "en", prefix.."help_max_offsetz",         "Maximum distance between stacked props (Z-axis)." )
localify.Bind( "en", prefix.."help_freeze",              "Stacked props are frozen when spawned." )
localify.Bind( "en", prefix.."help_weld",                "Stacked props are welded to each other when spawned." )
localify.Bind( "en", prefix.."help_nocollide",           "Stacked props won't collide with other stacked props." )
localify.Bind( "en", prefix.."help_nocollide_all",       "Stacked props won't collide with anything except players, NPCs, vehicles, and the world." )
localify.Bind( "en", prefix.."help_stayinworld",         "Prevents stacked props from being created outside of the map." )
-- Warnings
localify.Bind( "en", prefix.."warning_max_per_player",   "Primarily for Roleplay gamemodes. For Sandbox gamemodes, this should generally be unlimited (-1)." )
localify.Bind( "en", prefix.."warning_max_offsetx",      "Primarily for Roleplay gamemodes. Don't modify unless you know what you're doing." )
localify.Bind( "en", prefix.."warning_max_offsety",      "Primarily for Roleplay gamemodes. Don't modify unless you know what you're doing." )
localify.Bind( "en", prefix.."warning_max_offsetz",      "Primarily for Roleplay gamemodes. Don't modify unless you know what you're doing." )
localify.Bind( "en", prefix.."warning_freeze",           "For DarkRP." )
localify.Bind( "en", prefix.."warning_weld",             "For DarkRP." )
localify.Bind( "en", prefix.."warning_nocollide",        "For DarkRP." )
localify.Bind( "en", prefix.."warning_nocollide_all",    "DO NOT CHANGE WHILE THE SERVER IS RUNNING. This uses the GM.ShouldCollide hook and is experimental. It works and is guaranteed to stop crashes from Stacker, but needs more testing." )

--[[--------------------------------------------------------------------------
-- Bulgarian Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "bg", prefix.."name",                     "Натрупвач - Подобрен" )
localify.Bind( "bg", prefix.."desc",                     "Лесно натрупва еднакви предмети във всяка посока" )
localify.Bind( "bg", prefix.."left",                     "Създай натрупване" )
localify.Bind( "bg", prefix.."shift_left",               "Увеличи размера на натрупването" )
localify.Bind( "bg", prefix.."right",                    "Създай единичен обект" )
localify.Bind( "bg", prefix.."shift_right",              "Намали размера на натрупването" )
localify.Bind( "bg", prefix.."reload",                   "Смени направлението на натрупване" )
localify.Bind( "bg", "Undone_stacker_improved",          "Премахва натрупването на предмет(и)" )
-- Errors
localify.Bind( "bg", prefix.."error_blocked_by_server",  "Сървърът ви е блокирал да променяте тази конзолна променлива" )
localify.Bind( "bg", prefix.."error_not_admin",          "Трябва да бъдете в групата 'admin' за да промените тази конзолна променлива" )
localify.Bind( "bg", prefix.."error_invalid_argument",   "Трябва да въведете валидно число за тази стойност" )
localify.Bind( "bg", prefix.."error_max_per_stack",      "Максималния брой предмети които могат да бъдат натрупани на един път е ограничен до " )
localify.Bind( "bg", prefix.."error_too_quick",          "Използвате натрупвача твърде бързо" )
localify.Bind( "bg", prefix.."error_max_per_player",     "Ограничението за натрупани предмети е достигнато" )
localify.Bind( "bg", prefix.."error_not_in_world",       "Натрупваните предмети трябва да се създават вътре в света" )
localify.Bind( "bg", prefix.."error_max_constraints",    "Не можа да се създаде връзка, най вероятно са свършили слотовете за обекти" )
-- Labels
localify.Bind( "bg", prefix.."label_presets",            "Шаблон на натрупвача: " )
localify.Bind( "bg", prefix.."label_relative",           "Натрупвай спрямо: " )
localify.Bind( "bg", prefix.."label_direction",          "Направление на натрупване: " )
localify.Bind( "bg", prefix.."label_count",              "Размер на натрупване" )
localify.Bind( "bg", prefix.."label_reset_offsets",      "Нулиране на отместването" )
localify.Bind( "bg", prefix.."label_reset_angles",       "Нулиране на ъглите" )
localify.Bind( "bg", prefix.."label_show_settings",      "Цъкнете за показване на настройки" )
localify.Bind( "bg", prefix.."label_hide_settings",      "Цъкнете за скриване на настройки" )
localify.Bind( "bg", prefix.."label_x",                  "Абсциса  (-назад, +напред)" )
localify.Bind( "bg", prefix.."label_y",                  "Ордината  (-ляво, +дясно)" )
localify.Bind( "bg", prefix.."label_z",                  "Апликата  (-долу, +горе)" )
localify.Bind( "bg", prefix.."label_pitch",              "Тангаж  (-долу, +горе)" )
localify.Bind( "bg", prefix.."label_yaw",                "Азимут  (-ляво, +дясно)" )
localify.Bind( "bg", prefix.."label_roll",               "Крен    (-ляво, +дясно)" )
localify.Bind( "bg", prefix.."label_language",           "Език: " )
localify.Bind( "bg", prefix.."label_credits",            "Преведено от: [BG][Sk&Bh]Trick or treat KID!" )
localify.Bind( "bg", prefix.."label_max_per_stack",      "Брой на натрупване" )
localify.Bind( "bg", prefix.."label_max_per_player",     "Брой предмети на играч" )
localify.Bind( "bg", prefix.."label_max_offsetx",        "Максимално отместване по абсциса" )
localify.Bind( "bg", prefix.."label_max_offsety",        "Максимално отместване по ордината" )
localify.Bind( "bg", prefix.."label_max_offsetz",        "Максимално отместване по апликата" )
localify.Bind( "bg", prefix.."label_delay",              "Закъснение" )
localify.Bind( "bg", prefix.."label_opacity",            "Тъмнота" )
-- Checkboxes
localify.Bind( "bg", prefix.."checkbox_freeze",          "Замрази натрупаните предмети" )
localify.Bind( "bg", prefix.."checkbox_weld",            "Завари натрупаните предмети" )
localify.Bind( "bg", prefix.."checkbox_nocollide",       "Не-сблъсък на натрупаните предмети един към друг" )
localify.Bind( "bg", prefix.."checkbox_nocollide_all",   "Не-сблъсък на натрупаните предмети с ВСИЧКО" )
//localify.Bind( "bg", prefix.."checkbox_use_shift_key",   "" )
localify.Bind( "bg", prefix.."checkbox_relative",        "Натрупвай спрямо новата ориентация" )
localify.Bind( "bg", prefix.."checkbox_material",        "Приложи текстура" )
localify.Bind( "bg", prefix.."checkbox_color",           "Приложи цвят" )
localify.Bind( "bg", prefix.."checkbox_physprop",        "Приложи физически свойства" )
localify.Bind( "bg", prefix.."checkbox_ghost",           "Сенки за всички предмети в стека" )
localify.Bind( "bg", prefix.."checkbox_halo",            "Добави ореоли към предметите сенки" )
localify.Bind( "bg", prefix.."checkbox_halo_color",      "Цвят на ореола" )
localify.Bind( "bg", prefix.."checkbox_axis",            "Чертай осите XYZ" )
localify.Bind( "bg", prefix.."checkbox_axis_labels",     "Чертай етикети на XYZ осите" )
localify.Bind( "bg", prefix.."checkbox_axis_angles",     "Чертай ъглите на XYZ осите" )
localify.Bind( "bg", prefix.."checkbox_stayinworld",     "Натрупвай в рамките на света" )
-- Comboboxes
localify.Bind( "bg", prefix.."combobox_world",           "Свят" )
localify.Bind( "bg", prefix.."combobox_prop",            "Предмет" )
localify.Bind( "bg", prefix.."combobox_direction_up",    "Горе" )
localify.Bind( "bg", prefix.."combobox_direction_down",  "Долу" )
localify.Bind( "bg", prefix.."combobox_direction_front", "Отпред" )
localify.Bind( "bg", prefix.."combobox_direction_back",  "Отзад" )
localify.Bind( "bg", prefix.."combobox_direction_right", "Дясно" )
localify.Bind( "bg", prefix.."combobox_direction_left",  "Ляво" )
localify.Bind( "bg", prefix.."combobox_default",         "По подразбиране" )
localify.Bind( "bg", prefix.."combobox_sandbox",         "Пясъчник" )
localify.Bind( "bg", prefix.."combobox_darkrp",          "Ролева игра" )
localify.Bind( "bg", prefix.."combobox_singleplayer",    "Самостоятелна игра" )
-- HUD
localify.Bind( "bg", prefix.."hud_front",                "Отпред" )
localify.Bind( "bg", prefix.."hud_right",                "Дясно" )
localify.Bind( "bg", prefix.."hud_up",                   "Горе" )
-- Help
localify.Bind( "bg", prefix.."help_max_per_player",      "Максимален брой натрупвани предмети до които е ограничен всеки играч" )
localify.Bind( "bg", prefix.."help_max_per_stack",       "Максимален брой предмети при всяко натрупване (ляв клик)." )
localify.Bind( "bg", prefix.."help_delay",               "Закъснение (в секунди) между всяко използване на натрупвача (ляв/десен клик)" )
localify.Bind( "bg", prefix.."help_max_offsetx",         "Максимално разстояние между натрупаните предмети (абсциса)." )
localify.Bind( "bg", prefix.."help_max_offsety",         "Максимално разстояние между натрупаните предмети (ордината)." )
localify.Bind( "bg", prefix.."help_max_offsetz",         "Максимално разстояние между натрупаните предмети (апликата)." )
localify.Bind( "bg", prefix.."help_freeze",              "Натрупваните предмети са замразени при създаване." )
localify.Bind( "bg", prefix.."help_weld",                "Натрупваните предмети са заварени по между си при създаване." )
localify.Bind( "bg", prefix.."help_nocollide",           "Натрупваните предмети няма да се сблъскват с други такива." )
localify.Bind( "bg", prefix.."help_nocollide_all",       "Натрупваните предмети няма да се сблъскват с всичко освен играчи, NPC, превозни средства, и света." )
localify.Bind( "bg", prefix.."help_stayinworld",         "Предотвратява натрупваните обекти да бъдат създавани извън света." )
-- Warnings
localify.Bind( "bg", prefix.."warning_max_per_player",   "Преди всичко за режими на Ролева игра. За режим Пясъчник, това трябва генерално да бъде неограничено (-1)." )
localify.Bind( "bg", prefix.."warning_max_offsetx",      "Преди всичко за режими на Ролева игра. Не модифицирайте ако не знаете какво правите." )
localify.Bind( "bg", prefix.."warning_max_offsety",      "Преди всичко за режими на Ролева игра. Не модифицирайте ако не знаете какво правите." )
localify.Bind( "bg", prefix.."warning_max_offsetz",      "Преди всичко за режими на Ролева игра. Не модифицирайте ако не знаете какво правите." )
localify.Bind( "bg", prefix.."warning_freeze",           "За режим на Ролева игра." )
localify.Bind( "bg", prefix.."warning_weld",             "За режим на Ролева игра." )
localify.Bind( "bg", prefix.."warning_nocollide",        "За режим на Ролева игра." )
localify.Bind( "bg", prefix.."warning_nocollide_all",    "НЕ ПРОМЕНЯЙТЕ ДОКАТО СЪРВЪРА РАБОТИ. Това използва кука /GM.ShouldCollide/ и е експериментално. Работи и с гаранция ще спре крашовете, но се нуждае от още тестване." )

--[[--------------------------------------------------------------------------
-- French Localization
--------------------------------------------------------------------------]]--

-- Paramètres de l'outil
localify.Bind( "fr", prefix.."name",                     "Stacker - Amélioré" )
localify.Bind( "fr", prefix.."desc",                     "Empilez facilement les props dupliqués dans n'importe quelle direction" )
localify.Bind( "fr", prefix.."left",                     "Créer une pile" )
localify.Bind( "fr", prefix.."shift_left",               "Augmenter la taille des piles" )
localify.Bind( "fr", prefix.."right",                    "Créer un seul prop" )
localify.Bind( "fr", prefix.."shift_right",              "Diminuer la taille de la pile" )
localify.Bind( "fr", prefix.."reload",                   "Changer la direction de la pile" )
localify.Bind( "fr", "Undone_stacker_improved",          "Annuler le(s) prop(s) empilé(s)" )
-- Erreurs
localify.Bind( "fr", prefix.."error_blocked_by_server",  "Le serveur vous a empêché de modifier cette variable de console" )
localify.Bind( "fr", prefix.."error_not_admin",          "Vous devez être dans le groupe d'utilisateurs 'admin' pour modifier cette variable de console" )
localify.Bind( "fr", prefix.."error_invalid_argument",   "Vous devez entrer une valeur numérique valide" )
localify.Bind( "fr", prefix.."error_max_per_stack",      "Les props maximum qui peuvent être empilés à la fois sont limités à " )
localify.Bind( "fr", prefix.."error_too_quick",          "Vous utilisez l'empileur trop rapidement" )
localify.Bind( "fr", prefix.."error_max_per_player",     "Limite de l'empileur atteinte" )
localify.Bind( "fr", prefix.."error_not_in_world",       "Les props empilés doivent être engendrés dans le monde" )
localify.Bind( "fr", prefix.."error_max_constraints",    "Échec de la création de la contrainte, très probablement à court d'emplacements d'entité" )
-- Etiquettes
localify.Bind( "fr", prefix.."label_presets",            "Préréglages de l'empileur " )
localify.Bind( "fr", prefix.."label_relative",           "Pile relatif au: " )
localify.Bind( "fr", prefix.."label_direction",          "Direction: " )
localify.Bind( "fr", prefix.."label_count",              "Taille" )
localify.Bind( "fr", prefix.."label_reset_offsets",      "Effacer les décalages" )
localify.Bind( "fr", prefix.."label_reset_angles",       "Effacer les angles" )
localify.Bind( "fr", prefix.."label_show_settings",      "Afficher les paramètres" )
localify.Bind( "fr", prefix.."label_hide_settings",      "Masquer les paramètres" )
localify.Bind( "fr", prefix.."label_x",                  "X  (-derrière, +devant)" )
localify.Bind( "fr", prefix.."label_y",                  "Y  (-gauche, +droite)" )
localify.Bind( "fr", prefix.."label_z",                  "Z  (-bas, +haut)" )
localify.Bind( "fr", prefix.."label_pitch",              "Pitch  (-bas, +haut)" )
localify.Bind( "fr", prefix.."label_yaw",                "Yaw   (-gauche, +droite)" )
localify.Bind( "fr", prefix.."label_roll",               "Roll    (-gauche, +droite)" )
localify.Bind( "fr", prefix.."label_language",           "Langue: " )
localify.Bind( "fr", prefix.."label_credits",            "" )
localify.Bind( "fr", prefix.."label_max_per_stack",      "Taille" )
localify.Bind( "fr", prefix.."label_max_per_player",     "Props par joueur(s)" )
localify.Bind( "fr", prefix.."label_max_offsetx",        "Décalage X maximal" )
localify.Bind( "fr", prefix.."label_max_offsety",        "Décalage Y maximal" )
localify.Bind( "fr", prefix.."label_max_offsetz",        "Décalage Z maximal" )
localify.Bind( "fr", prefix.."label_delay",              "Délai" )
localify.Bind( "fr", prefix.."label_opacity",            "Opacité" )
-- Checkboxes
localify.Bind( "fr", prefix.."checkbox_freeze",          "Geler les props empilés" )
localify.Bind( "fr", prefix.."checkbox_weld",            "Souder les props empilés" )
localify.Bind( "fr", prefix.."checkbox_nocollide",       "No-Collide les props empilés avec les autres" )
localify.Bind( "fr", prefix.."checkbox_nocollide_all",   "No-Collide les props empilés avec TOUT" )
localify.Bind( "fr", prefix.."checkbox_use_shift_key",   "Changer la taille d'empilement avec SHIFT + clic gauche/droite" )
localify.Bind( "fr", prefix.."checkbox_relative",        "Pile par rapport à la nouvelle rotation" )
localify.Bind( "fr", prefix.."checkbox_material",        "Appliquer un matériaux" )
localify.Bind( "fr", prefix.."checkbox_color",           "Appliquer une couleur" )
localify.Bind( "fr", prefix.."checkbox_physprop",        "Appliquer une propriété physique" )
localify.Bind( "fr", prefix.."checkbox_ghost",           "Traverser tout les props dans l'empilement" )
localify.Bind( "fr", prefix.."checkbox_halo",            "Ajouter des halos aux props fantômes" )
localify.Bind( "fr", prefix.."checkbox_halo_color",      "Couleur du halo" )
localify.Bind( "fr", prefix.."checkbox_axis",            "Dessiner l'axe XYZ" )
localify.Bind( "fr", prefix.."checkbox_axis_labels",     "Dessiner des étiquettes d'axe XYZ" )
localify.Bind( "fr", prefix.."checkbox_axis_angles",     "Dessiner des angles d'axe XYZ" )
localify.Bind( "fr", prefix.."checkbox_stayinworld",     "Rester dans le monde" )
-- Comboboxes
localify.Bind( "fr", prefix.."combobox_world",           "Monde" )
localify.Bind( "fr", prefix.."combobox_prop",            "Prop" )
localify.Bind( "fr", prefix.."combobox_direction_up",    "Haut" )
localify.Bind( "fr", prefix.."combobox_direction_down",  "Bas" )
localify.Bind( "fr", prefix.."combobox_direction_front", "Devant" )
localify.Bind( "fr", prefix.."combobox_direction_back",  "Derrière" )
localify.Bind( "fr", prefix.."combobox_direction_right", "Droite" )
localify.Bind( "fr", prefix.."combobox_direction_left",  "Gauche" )
localify.Bind( "fr", prefix.."combobox_default",         "Défaut" )
localify.Bind( "fr", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "fr", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "fr", prefix.."combobox_singleplayer",    "Solo" )
-- HUD
localify.Bind( "fr", prefix.."hud_front",                "Devant" )
localify.Bind( "fr", prefix.."hud_right",                "Droite" )
localify.Bind( "fr", prefix.."hud_up",                   "Haut" )
-- Aide
localify.Bind( "fr", prefix.."help_max_per_player",      "Les props empilés sont limités à chaque joueur." )
localify.Bind( "fr", prefix.."help_max_per_stack",       "Maximum de props par pile (clic gauche)." )
localify.Bind( "fr", prefix.."help_delay",               "Délai (en secondes) entre chaque utilisation de l'Empileur (clic gauche / droit)" )
localify.Bind( "fr", prefix.."help_max_offsetx",         "Distance maximale entre les props empilés (axe X)." )
localify.Bind( "fr", prefix.."help_max_offsety",         "Distance maximale entre les props empilés (axe Y)." )
localify.Bind( "fr", prefix.."help_max_offsetz",         "Distance maximale entre les props empilés (axe Z)." )
localify.Bind( "fr", prefix.."help_freeze",              "Les props empilés sont congelés lorsqu'ils sont spawn." )
localify.Bind( "fr", prefix.."help_weld",                "Les props empilés sont soudés les uns aux autres lors du spawn." )
localify.Bind( "fr", prefix.."help_nocollide",           "Les props empilés ne vont pas entrer en collision avec d'autres props empilés." )
localify.Bind( "fr", prefix.."help_nocollide_all",       "Les props empilés n'entreront en collision avec rien d'autre que les joueurs, les PNJ, les véhicules et le monde." )
localify.Bind( "fr", prefix.."help_stayinworld",         "Empêche la création de props empilés à l'extérieur de la carte." )
-- Attentions
localify.Bind( "fr", prefix.."warning_max_per_player",   "Principalement pour les modes de jeu Roleplay. Pour les modes de jeu Sandbox, cela devrait généralement être illimité (-1)." )
localify.Bind( "fr", prefix.."warning_max_offsetx",      "Principalement pour les modes de jeu Roleplay. Ne modifiez pas à moins de savoir ce que vous faites." )
localify.Bind( "fr", prefix.."warning_max_offsety",      "Principalement pour les modes de jeu Roleplay. Ne modifiez pas à moins de savoir ce que vous faites." )
localify.Bind( "fr", prefix.."warning_max_offsetz",      "Principalement pour les modes de jeu Roleplay. Ne modifiez pas à moins de savoir ce que vous faites." )
localify.Bind( "fr", prefix.."warning_freeze",           "Pour DarkRP." )
localify.Bind( "fr", prefix.."warning_weld",             "Pour DarkRP." )
localify.Bind( "fr", prefix.."warning_nocollide",        "Pour DarkRP." )
localify.Bind( "fr", prefix.."warning_nocollide_all",    "NE PAS CHANGER PENDANT QUE LE SERVEUR FONCTIONNE. Cela utilise le crochet GM.ShouldCollide et est expérimental. Cela fonctionne et est garanti pour arrêter les plantages de Stacker, mais a besoin de plus de tests." )

--[[--------------------------------------------------------------------------
-- Polish Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "pl", prefix.."name",                     "Stacker - Ulepszony" )
localify.Bind( "pl", prefix.."desc",                     "Łatwo kopiuj obiekty w dowolnym kierunku" )
localify.Bind( "pl", prefix.."left",                     "Utwórz kopię" )
localify.Bind( "pl", prefix.."shift_left",               "Zwiększ ilość kopii" )
localify.Bind( "pl", prefix.."right",                    "Utwórz pojedyńczy obiekt" )
localify.Bind( "pl", prefix.."shift_right",              "Zmniejsz ilość kopii" )
localify.Bind( "pl", prefix.."reload",                   "Zmień kierunek kopiowania" )
localify.Bind( "pl", "Undone_stacker_improved",          "Cofnięto skopiowany obiekt" )
-- Errors
localify.Bind( "pl", prefix.."error_blocked_by_server",  "Serwer zablokował twoją możliwość zmieniania wartości serwerowych" )
localify.Bind( "pl", prefix.."error_not_admin",          "Musiz być w grupie 'admin' by zmienić tę wartość konsolową" )
localify.Bind( "pl", prefix.."error_invalid_argument",   "Musisz wprowadzić poprawną wartość liczbową" )
localify.Bind( "pl", prefix.."error_max_per_stack",      "Maksymalna ilość kopii jest ograniczona do " )
localify.Bind( "pl", prefix.."error_too_quick",          "Używasz Stackera za szybko" )
localify.Bind( "pl", prefix.."error_max_per_player",     "Osiągnięto limir obiektów dla Stackera" )
localify.Bind( "pl", prefix.."error_not_in_world",       "Skopiowane obiekty nie mogą wychodzić poza mapę" )
localify.Bind( "pl", prefix.."error_max_constraints",    "Nie udało się utworzyć łaczenia, najprawdopodobniej brakuje miejsc na obiekty" )
-- Labels
localify.Bind( "pl", prefix.."label_presets",            "Ustawienia zapisane: " )
localify.Bind( "pl", prefix.."label_relative",           "Kopiowanie względem: " )
localify.Bind( "pl", prefix.."label_direction",          "Kierunek kopiowania: " )
localify.Bind( "pl", prefix.."label_count",              "Ilość kopii" )
localify.Bind( "pl", prefix.."label_reset_offsets",      "Zresetuj przesunięcia" )
localify.Bind( "pl", prefix.."label_reset_angles",       "Zresetuj kąty" )
localify.Bind( "pl", prefix.."label_show_settings",      "Pokaż ustawienia" )
localify.Bind( "pl", prefix.."label_hide_settings",      "Ukryj ustawienia" )
localify.Bind( "pl", prefix.."label_x",                  "X  (-tył, +przód)" )
localify.Bind( "pl", prefix.."label_y",                  "Y  (-lewo, +prawo)" )
localify.Bind( "pl", prefix.."label_z",                  "Z  (-dół, +góra)" )
localify.Bind( "pl", prefix.."label_pitch",              "Pochylenie  (-dół, +góra)" )
localify.Bind( "pl", prefix.."label_yaw",                "Odchylenie   (-lewo, +prawo)" )
localify.Bind( "pl", prefix.."label_roll",               "Przechylenie    (-lewo, +prawo)" )
localify.Bind( "pl", prefix.."label_language",           "Język: " )
localify.Bind( "pl", prefix.."label_credits",            "" )
localify.Bind( "pl", prefix.."label_max_per_stack",      "Ilość kopii" )
localify.Bind( "pl", prefix.."label_max_per_player",     "Ilość obiektów na gracza" )
localify.Bind( "pl", prefix.."label_max_offsetx",        "Max przesunięcie X" )
localify.Bind( "pl", prefix.."label_max_offsety",        "Max przesunięcie Y" )
localify.Bind( "pl", prefix.."label_max_offsetz",        "Max przesunięcie Z" )
localify.Bind( "pl", prefix.."label_delay",              "Opóźnienie" )
localify.Bind( "pl", prefix.."label_opacity",            "Przezroczystość" )
-- Checkboxes
localify.Bind( "pl", prefix.."checkbox_freeze",          "Zamrażaj skopiowane obiekty" )
localify.Bind( "pl", prefix.."checkbox_weld",            "Spawaj skopiowane obiekty" )
localify.Bind( "pl", prefix.."checkbox_nocollide",       "Wyłącz kolizję pomiędzy skopiowanymi obiektami" )
localify.Bind( "pl", prefix.."checkbox_nocollide_all",   "Wyłącz kolizję skopiowanych obiektamów ze WSZYSTKIM" )
localify.Bind( "pl", prefix.."checkbox_use_shift_key",   "Zmień ilość kopii za pomocą SHIFT + lewy/prawy" )
localify.Bind( "pl", prefix.."checkbox_relative",        "Kopiuj względem nowego obrotu" )
localify.Bind( "pl", prefix.."checkbox_material",        "Zastosuj materiał" )
localify.Bind( "pl", prefix.."checkbox_color",           "Zastosuj kolor" )
localify.Bind( "pl", prefix.."checkbox_physprop",        "Zastosuj właściwości fizyczne" )
localify.Bind( "pl", prefix.."checkbox_ghost",           "Dodaj duchy obiektów wszyschich kopii" )
localify.Bind( "pl", prefix.."checkbox_halo",            "Dodaj poświatę do duchów obiektów" )
localify.Bind( "pl", prefix.."checkbox_halo_color",      "Kolor poświaty" )
localify.Bind( "pl", prefix.."checkbox_axis",            "Rysuj oś XYZ" )
localify.Bind( "pl", prefix.."checkbox_axis_labels",     "Rysuj opis osi XYZ" )
localify.Bind( "pl", prefix.."checkbox_axis_angles",     "Rysuj kąty osi XYZ" )
localify.Bind( "pl", prefix.."checkbox_stayinworld",     "Zostań w środku mapy" )
-- Comboboxes
localify.Bind( "pl", prefix.."combobox_world",           "świat" )
localify.Bind( "pl", prefix.."combobox_prop",            "Obiekt" )
localify.Bind( "pl", prefix.."combobox_direction_up",    "Góra" )
localify.Bind( "pl", prefix.."combobox_direction_down",  "Dół" )
localify.Bind( "pl", prefix.."combobox_direction_front", "Przód" )
localify.Bind( "pl", prefix.."combobox_direction_back",  "Tył" )
localify.Bind( "pl", prefix.."combobox_direction_right", "Prawo" )
localify.Bind( "pl", prefix.."combobox_direction_left",  "Lewo" )
localify.Bind( "pl", prefix.."combobox_default",         "Domyślne" )
localify.Bind( "pl", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "pl", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "pl", prefix.."combobox_singleplayer",    "Singleplayer" )
-- HUD
localify.Bind( "pl", prefix.."hud_front",                "Przód" )
localify.Bind( "pl", prefix.."hud_right",                "Prawo" )
localify.Bind( "pl", prefix.."hud_up",                   "Góra" )
-- Help
localify.Bind( "pl", prefix.."help_max_per_player",      "Maksymalna ilość skopiowanych obiektó na gracza to." )
localify.Bind( "pl", prefix.."help_max_per_stack",       "Maksymalna ilość obiektów na kopię (lewy przycisk myszki)." )
localify.Bind( "pl", prefix.."help_delay",               "Opóźnienie (w sekundach) pomiędzy każdym użyciem Stackera (lewy/prawy przycisk)" )
localify.Bind( "pl", prefix.."help_max_offsetx",         "Maksymalny dystans pomiędzy skopiowanymi obiektami (oś X)." )
localify.Bind( "pl", prefix.."help_max_offsety",         "Maksymalny dystans pomiędzy skopiowanymi obiektami (oś Y)." )
localify.Bind( "pl", prefix.."help_max_offsetz",         "Maksymalny dystans pomiędzy skopiowanymi obiektami (oś Z)." )
localify.Bind( "pl", prefix.."help_freeze",              "Skopiowane obiekty są zamrożone." )
localify.Bind( "pl", prefix.."help_weld",                "Skopiowane obiekty są zespawane do siebie." )
localify.Bind( "pl", prefix.."help_nocollide",           "Skopiowane obiekty nie będą kolidowały z innymi skopiowanymi obiektami." )
localify.Bind( "pl", prefix.."help_nocollide_all",       "Skopiowane obiekty nie będą kolidowały ze wszystkim oprócz graczy, NPCs, pojazdów, i mapy." )
localify.Bind( "pl", prefix.."help_stayinworld",         "Nie pozwalaj na tworzenie kopii poza mapą." )
-- Warnings
localify.Bind( "pl", prefix.."warning_max_per_player",   "Głównie dla trybu Roleplay. Dla trybów Sandbox, zazwyczaj powinno być nieograniczone (-1)." )
localify.Bind( "pl", prefix.."warning_max_offsetx",      "Głownie dla tryby Roleplay. Nie zmieniaj, jeśli nie wiesz co robisz." )
localify.Bind( "pl", prefix.."warning_max_offsety",      "Głownie dla tryby Roleplay. Nie zmieniaj, jeśli nie wiesz co robisz." )
localify.Bind( "pl", prefix.."warning_max_offsetz",      "Głownie dla tryby Roleplay. Nie zmieniaj, jeśli nie wiesz co robisz." )
localify.Bind( "pl", prefix.."warning_freeze",           "Dla DarkRP." )
localify.Bind( "pl", prefix.."warning_weld",             "Dla DarkRP." )
localify.Bind( "pl", prefix.."warning_nocollide",        "Dla DarkRP." )
localify.Bind( "pl", prefix.."warning_nocollide_all",    "NIE ZMIENIAJ JEŚLI SERWER JEST WŁĄCZONY. To używa GM.ShouldCollide i jest eksperymentalne. Działa i zapobiega awarii serwera spowodowanymi Stackerem, ale wymaga dalszych testów." )

--[[--------------------------------------------------------------------------
-- Russian Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "ru", prefix.."name",                     "Стакер - Улучшенный" )
localify.Bind( "ru", prefix.."desc",                     "Легко дублируйте предметы в любом направлении" )
localify.Bind( "ru", prefix.."left",                     "Стакать" )
localify.Bind( "ru", prefix.."shift_left",               "Увеличить размер стака" )
localify.Bind( "ru", prefix.."right",                    "Создать одиночный предмет" )
localify.Bind( "ru", prefix.."shift_right",              "Уменьшить размер стака" )
localify.Bind( "ru", prefix.."reload",                   "Изменить напраление стака" )
localify.Bind( "ru", "Undone_stacker_improved",          "Отменить стаканные предметы" )
-- Errors
localify.Bind( "ru", prefix.."error_blocked_by_server",  "Сервер заблокировал вас от изменения этой консольной переменной" )
localify.Bind( "ru", prefix.."error_not_admin",          "Вы должны быть в группе админа, чтобы изменить эту консольную переменную" )
localify.Bind( "ru", prefix.."error_invalid_argument",   "Вы должны ввести правильное числовое значение" )
localify.Bind( "ru", prefix.."error_max_per_stack",      "Максимальное количество предметов, которые могут быть стаканы в один момент, ограничено к " )
localify.Bind( "ru", prefix.."error_too_quick",          "Вы используете стакер слишком быстро" )
localify.Bind( "ru", prefix.."error_max_per_player",     "Достигнуто максимальное количество предметов" )
localify.Bind( "ru", prefix.."error_not_in_world",       "Стаканные предметы должны появляться в мире" )
localify.Bind( "ru", prefix.."error_max_constraints",    "Не удалось создать соединение, скорее всего, закончились слоты сущностей" )
-- Labels
localify.Bind( "ru", prefix.."label_presets",            "Готовые настройки стака: " )
localify.Bind( "ru", prefix.."label_relative",           "Стак относителен к: " )
localify.Bind( "ru", prefix.."label_direction",          "Направление стака: " )
localify.Bind( "ru", prefix.."label_count",              "Размер стака" )
localify.Bind( "ru", prefix.."label_reset_offsets",      "Сбросить отклонения" )
localify.Bind( "ru", prefix.."label_reset_angles",       "Сбросить углы" )
localify.Bind( "ru", prefix.."label_show_settings",      "Показать настройки" )
localify.Bind( "ru", prefix.."label_hide_settings",      "Спрятать настройки" )
localify.Bind( "ru", prefix.."label_x",                  "X  (-сзади, +спереди)" )
localify.Bind( "ru", prefix.."label_y",                  "Y  (-слева, +справа)" )
localify.Bind( "ru", prefix.."label_z",                  "Z  (-снизу, +сверху)" )
localify.Bind( "ru", prefix.."label_pitch",              "Pitch  (-снизу, +сверху)" )
localify.Bind( "ru", prefix.."label_yaw",                "Yaw   (-слева, +справа)" )
localify.Bind( "ru", prefix.."label_roll",               "Roll    (-слева, +справа)" )
localify.Bind( "ru", prefix.."label_language",           "Язык: " )
localify.Bind( "ru", prefix.."label_credits",            "Переведено от SupinePandora43" )
localify.Bind( "ru", prefix.."label_max_per_stack",      "Размер стака" )
localify.Bind( "ru", prefix.."label_max_per_player",     "Количество предметов игрока" )
localify.Bind( "ru", prefix.."label_max_offsetx",        "Максимальное X отклонение" )
localify.Bind( "ru", prefix.."label_max_offsety",        "Максимальное Y отклонение" )
localify.Bind( "ru", prefix.."label_max_offsetz",        "Максимальное Z отклонение" )
localify.Bind( "ru", prefix.."label_delay",              "Задержка" )
localify.Bind( "ru", prefix.."label_opacity",            "Непрозрачность" )
-- Checkboxes
localify.Bind( "ru", prefix.."checkbox_freeze",          "Заморозить стаканные предметы" )
localify.Bind( "ru", prefix.."checkbox_weld",            "Сварить стаканные предметы" )
localify.Bind( "ru", prefix.."checkbox_nocollide",       "Отключить столкновения стаканных предметов друг с другом" )
localify.Bind( "ru", prefix.."checkbox_nocollide_all",   "Отключить столкновения стаканных предметов со ВСЕМ" )
localify.Bind( "ru", prefix.."checkbox_use_shift_key",   "Изменить размер стака с SHIFT + ЛКМ/ПКМ" )
localify.Bind( "ru", prefix.."checkbox_relative",        "Стак относителен нового поворота" )
localify.Bind( "ru", prefix.."checkbox_material",        "Применить материал" )
localify.Bind( "ru", prefix.."checkbox_color",           "Применить цвет" )
localify.Bind( "ru", prefix.."checkbox_physprop",        "Применить физические свойства" )
localify.Bind( "ru", prefix.."checkbox_ghost",           "Призрачные все предметы в стаке" )
localify.Bind( "ru", prefix.."checkbox_halo",            "Добавить обводку к призрачным предметам" )
localify.Bind( "ru", prefix.."checkbox_halo_color",      "Цвет обводки" )
localify.Bind( "ru", prefix.."checkbox_axis",            "Отрисовывать XYZ ось" )
localify.Bind( "ru", prefix.."checkbox_axis_labels",     "Отрисовывать XYZ названия осей " )
localify.Bind( "ru", prefix.."checkbox_axis_angles",     "Отрисовывать XYZ углы оси" )
localify.Bind( "ru", prefix.."checkbox_stayinworld",     "Оставаться в мире" )
-- Comboboxes
localify.Bind( "ru", prefix.."combobox_world",           "Мир" )
localify.Bind( "ru", prefix.."combobox_prop",            "Предмет" )
localify.Bind( "ru", prefix.."combobox_direction_up",    "Верх" )
localify.Bind( "ru", prefix.."combobox_direction_down",  "Низ" )
localify.Bind( "ru", prefix.."combobox_direction_front", "Перед" )
localify.Bind( "ru", prefix.."combobox_direction_back",  "Зад" )
localify.Bind( "ru", prefix.."combobox_direction_right", "Право" )
localify.Bind( "ru", prefix.."combobox_direction_left",  "Лево" )
localify.Bind( "ru", prefix.."combobox_default",         "По умолчанию" )
localify.Bind( "ru", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "ru", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "ru", prefix.."combobox_singleplayer",    "Одиночная игра" )
-- HUD
localify.Bind( "ru", prefix.."hud_front",                "Перед" )
localify.Bind( "ru", prefix.."hud_right",                "Право" )
localify.Bind( "ru", prefix.."hud_up",                   "Верх" )
-- Help
localify.Bind( "ru", prefix.."help_max_per_player",      "Максимальное количество предметов, которые могут быть стаканы в один момент." )
localify.Bind( "ru", prefix.."help_max_per_stack",       "Максимальное количество предметов в стаке (ЛКМ)." )
localify.Bind( "ru", prefix.."help_delay",               "Задержка (в секундах) между каждым использыванием стакера (ЛКМ/ПКМ)" )
localify.Bind( "ru", prefix.."help_max_offsetx",         "Максимальная дистанция между стаканными предметами (X-ось)." )
localify.Bind( "ru", prefix.."help_max_offsety",         "Максимальная дистанция между стаканными предметами (Y-ось)." )
localify.Bind( "ru", prefix.."help_max_offsetz",         "Максимальная дистанция между стаканными предметами (Z-ось)." )
localify.Bind( "ru", prefix.."help_freeze",              "Заморозить стаканные предметы при спавне." )
localify.Bind( "ru", prefix.."help_weld",                "Сварить стаканные предметы друг к другу при спавне." )
localify.Bind( "ru", prefix.."help_nocollide",           "Стаканные предметы не будут сталкиваться друг с другом." )
localify.Bind( "ru", prefix.."help_nocollide_all",       "Отключить столкновения для стаканных предметов." )
localify.Bind( "ru", prefix.."help_stayinworld",         "Предотвращает создание стака за пределами мира." )
-- Warnings
localify.Bind( "ru", prefix.."warning_max_per_player",   "В основном для RolePlay игровых режимов. Для SandBox игровых режимов, это должно быть неограничено (-1)." )
localify.Bind( "ru", prefix.."warning_max_offsetx",      "В основном для RolePlay игровых режимов. Не изменяйте, если не знаете что делаете." )
localify.Bind( "ru", prefix.."warning_max_offsety",      "В основном для RolePlay игровых режимов. Не изменяйте, если не знаете что делаете." )
localify.Bind( "ru", prefix.."warning_max_offsetz",      "В основном для RolePlay игровых режимов. Не изменяйте, если не знаете что делаете." )
localify.Bind( "ru", prefix.."warning_freeze",           "Для DarkRP." )
localify.Bind( "ru", prefix.."warning_weld",             "Для DarkRP." )
localify.Bind( "ru", prefix.."warning_nocollide",        "Для DarkRP." )
localify.Bind( "ru", prefix.."warning_nocollide_all",    "НЕ ИЗМЕНЯЙТЕ ВО ВРЕМЯ РАБОТЫ СЕРВЕРА. Это использует экспериментальный GM.ShouldCollide. Это работает и гарантированно предотвращает сбои в Stacker, но требует дополнительного тестирования." )

--[[--------------------------------------------------------------------------
-- Russian Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "zh-cn", prefix.."name",                     "叠加器 - 改进" )
localify.Bind( "zh-cn", prefix.."desc",                     "轻易在任何方向复制物品" )
localify.Bind( "zh-cn", prefix.."left",                     "进行一次叠加" )
localify.Bind( "zh-cn", prefix.."shift_left",               "增加叠加大小" )
localify.Bind( "zh-cn", prefix.."right",                    "叠加单个物品" )
localify.Bind( "zh-cn", prefix.."shift_right",              "减少叠加大小" )
localify.Bind( "zh-cn", prefix.."reload",                   "改变叠加方向" )
localify.Bind( "zh-cn", "Undone_stacker_improved",          "撤回叠加物品" )
-- Errors
localify.Bind( "zh-cn", prefix.."error_blocked_by_server",  "服务器禁止你修改这个控制台参数" )
localify.Bind( "zh-cn", prefix.."error_not_admin",          "你必须是管理员才能修改这个控制台参数" )
localify.Bind( "zh-cn", prefix.."error_invalid_argument",   "你必须输入一个合法数字" )
localify.Bind( "zh-cn", prefix.."error_max_per_stack",      "单次叠加物品的上限是 " )
localify.Bind( "zh-cn", prefix.."error_too_quick",          "你叠加器使用得太快了" )
localify.Bind( "zh-cn", prefix.."error_max_per_player",     "叠加器达到了物品上限" )
localify.Bind( "zh-cn", prefix.."error_not_in_world",       "叠加的物品必须生成在地图内部" )
localify.Bind( "zh-cn", prefix.."error_max_constraints",    "约束生成失败，很可能是达到了实体上限" )
-- Labels
localify.Bind( "zh-cn", prefix.."label_presets",            "叠加器预设：" )
localify.Bind( "zh-cn", prefix.."label_relative",           "叠加相对方向：" )
localify.Bind( "zh-cn", prefix.."label_direction",          "叠加方向：" )
localify.Bind( "zh-cn", prefix.."label_count",              "叠加大小：" )
localify.Bind( "zh-cn", prefix.."label_reset_offsets",      "重置位差" )
localify.Bind( "zh-cn", prefix.."label_reset_angles",       "重置角度" )
localify.Bind( "zh-cn", prefix.."label_show_settings",      "点击显示设置" )
localify.Bind( "zh-cn", prefix.."label_hide_settings",      "点击隐藏设置" )
localify.Bind( "zh-cn", prefix.."label_x",                  "X  (-后, +前)" )
localify.Bind( "zh-cn", prefix.."label_y",                  "Y  (-左, +右)" )
localify.Bind( "zh-cn", prefix.."label_z",                  "Z  (-下, +上)" )
localify.Bind( "zh-cn", prefix.."label_pitch",              "Pitch  (-下, +上)" )
localify.Bind( "zh-cn", prefix.."label_yaw",                "Yaw    (-左, +右)" )
localify.Bind( "zh-cn", prefix.."label_roll",               "Roll    (-左, +右)" )
localify.Bind( "zh-cn", prefix.."label_language",           "语言: " )
localify.Bind( "zh-cn", prefix.."label_credits",            "翻译： 8Z (STEAM_0:0:33380074)" )
localify.Bind( "zh-cn", prefix.."label_max_per_stack",      "单次叠加上限" )
localify.Bind( "zh-cn", prefix.."label_max_per_player",     "玩家叠加物品上限" )
localify.Bind( "zh-cn", prefix.."label_max_offsetx",        "最大 X 位差" )
localify.Bind( "zh-cn", prefix.."label_max_offsety",        "最大 Y 位差" )
localify.Bind( "zh-cn", prefix.."label_max_offsetz",        "最大 Z 位差" )
localify.Bind( "zh-cn", prefix.."label_delay",              "冷却" )
localify.Bind( "zh-cn", prefix.."label_opacity",            "透明度" )
-- Checkboxes
localify.Bind( "zh-cn", prefix.."checkbox_freeze",          "固定叠加物品" )
localify.Bind( "zh-cn", prefix.."checkbox_weld",            "焊接叠加物品" )
localify.Bind( "zh-cn", prefix.."checkbox_nocollide",       "叠加互相无碰撞" )
localify.Bind( "zh-cn", prefix.."checkbox_nocollide_all",   "叠加全部无碰撞" )
localify.Bind( "zh-cn", prefix.."checkbox_use_shift_key",   "更改叠加大小使用 SHIFT+左键/右键" )
localify.Bind( "zh-cn", prefix.."checkbox_relative",        "叠加使用新物品的相对角度" )
localify.Bind( "zh-cn", prefix.."checkbox_material",        "应用材质" )
localify.Bind( "zh-cn", prefix.."checkbox_color",           "应用颜色" )
localify.Bind( "zh-cn", prefix.."checkbox_physprop",        "应用物理特性" )
localify.Bind( "zh-cn", prefix.."checkbox_ghost",           "所有叠加物品显示预览" )
localify.Bind( "zh-cn", prefix.."checkbox_halo",            "物品预览光环效果" )
localify.Bind( "zh-cn", prefix.."checkbox_halo_color",      "光环颜色" )
localify.Bind( "zh-cn", prefix.."checkbox_axis",            "显示 XYZ 轴" )
localify.Bind( "zh-cn", prefix.."checkbox_axis_labels",     "显示 XYZ 轴标签" )
localify.Bind( "zh-cn", prefix.."checkbox_axis_angles",     "显示 XYZ 轴角度" )
localify.Bind( "zh-cn", prefix.."checkbox_stayinworld",     "叠加限定在地图内部" )
-- Comboboxes
localify.Bind( "zh-cn", prefix.."combobox_world",           "世界" )
localify.Bind( "zh-cn", prefix.."combobox_prop",            "物品" )
localify.Bind( "zh-cn", prefix.."combobox_direction_up",    "上" )
localify.Bind( "zh-cn", prefix.."combobox_direction_down",  "下" )
localify.Bind( "zh-cn", prefix.."combobox_direction_front", "前" )
localify.Bind( "zh-cn", prefix.."combobox_direction_back",  "后" )
localify.Bind( "zh-cn", prefix.."combobox_direction_right", "右" )
localify.Bind( "zh-cn", prefix.."combobox_direction_left",  "左" )
localify.Bind( "zh-cn", prefix.."combobox_default",         "默认" )
localify.Bind( "zh-cn", prefix.."combobox_sandbox",         "沙盘" )
localify.Bind( "zh-cn", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "zh-cn", prefix.."combobox_singleplayer",    "单人" )
-- HUD
localify.Bind( "zh-cn", prefix.."hud_front",                "前" )
localify.Bind( "zh-cn", prefix.."hud_right",                "右" )
localify.Bind( "zh-cn", prefix.."hud_up",                   "上" )
-- Help
localify.Bind( "zh-cn", prefix.."help_max_per_player",      "每个玩家堆叠物品的数量上限。" )
localify.Bind( "zh-cn", prefix.."help_max_per_stack",       "单次堆叠（左键）时的物品上限。" )
localify.Bind( "zh-cn", prefix.."help_delay",               "每次使用堆叠器（左键/右键）后的冷却。" )
localify.Bind( "zh-cn", prefix.."help_max_offsetx",         "叠加物品间的最大位差（X轴）。" )
localify.Bind( "zh-cn", prefix.."help_max_offsety",         "叠加物品间的最大位差（Y轴）。" )
localify.Bind( "zh-cn", prefix.."help_max_offsetz",         "叠加物品间的最大位差（Z轴）。" )
localify.Bind( "zh-cn", prefix.."help_freeze",              "叠加的物品刷出后固定。" )
localify.Bind( "zh-cn", prefix.."help_weld",                "叠加的物品刷出后互相焊接。" )
localify.Bind( "zh-cn", prefix.."help_nocollide",           "叠加的物品和其他叠加物品无碰撞。" )
localify.Bind( "zh-cn", prefix.."help_nocollide_all",       "叠加的物品只会和玩家，NPC，车辆和世界碰撞。" )
localify.Bind( "zh-cn", prefix.."help_stayinworld",         "避免叠加的物品刷出在地图外部。" )
-- Warnings
localify.Bind( "zh-cn", prefix.."warning_max_per_player",   "主要用于角色扮演模式的设置。沙盘模式下这个应该是无限的（-1）。" )
localify.Bind( "zh-cn", prefix.."warning_max_offsetx",      "主要用于角色扮演模式的设置。如果你不确定这是什么，不要修改。" )
localify.Bind( "zh-cn", prefix.."warning_max_offsety",      "主要用于角色扮演模式的设置。如果你不确定这是什么，不要修改。" )
localify.Bind( "zh-cn", prefix.."warning_max_offsetz",      "主要用于角色扮演模式的设置。如果你不确定这是什么，不要修改。" )
localify.Bind( "zh-cn", prefix.."warning_freeze",           "提供给 DarkRP 的设置。" )
localify.Bind( "zh-cn", prefix.."warning_weld",             "提供给 DarkRP 的设置。" )
localify.Bind( "zh-cn", prefix.."warning_nocollide",        "提供给 DarkRP 的设置。" )
localify.Bind( "zh-cn", prefix.."warning_nocollide_all",    "绝对不要在服务器运作时修改！这个实验性的功能调用 GM.ShouldCollide。这个设置管用且必定能够避免叠加器崩服，但需要更多的测试。" )

--[[--------------------------------------------------------------------------
-- German Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "de", prefix.."name",                     "Stapler - Verbessert" )
localify.Bind( "de", prefix.."desc",                     "Einfaches Stapeln von duplizierten Props in jede Richtung" )
localify.Bind( "de", prefix.."left",                     "Stapel erstellen" )
localify.Bind( "de", prefix.."shift_left",               "Stapelgröße erhöhen" )
localify.Bind( "de", prefix.."right",                    "Einzelnes Prop erstellen" )
localify.Bind( "de", prefix.."shift_right",              "Stapelgröße verkleinern" )
localify.Bind( "de", prefix.."reload",                   "Stapelrichtung ändern" )
localify.Bind( "de", "Undone_stacker_improved",          "Gestapelte Prop(s) rückgängig machen" )
-- Errors
localify.Bind( "de", prefix.."error_blocked_by_server",  "Der Server hat dich daran gehindert, diese Konsolenvariable zu ändern" )
localify.Bind( "de", prefix.."error_not_admin",          "Du musst dich in der Benutzergruppe 'admin' befinden, um diese Konsolenvariable zu ändern" )
localify.Bind( "de", prefix.."error_invalid_argument",   "Du musst einen gültigen Zahlenwert eingeben" )
localify.Bind( "de", prefix.."error_max_per_stack",      "Die maximale Anzahl von Props, die auf einmal gestapelt werden können, ist begrenzt auf " )
localify.Bind( "de", prefix.."error_too_quick",          "Du verwendest den Stapler zu schnell" )
localify.Bind( "de", prefix.."error_max_per_player",     "Stapler prop limit erreicht" )
localify.Bind( "de", prefix.."error_not_in_world",       "Gestapelte Props müssen innerhalb der Welt gespawnt werden" )
localify.Bind( "de", prefix.."error_max_constraints",    "Constraint konnte nicht erstellt werden ")
-- Labels
localify.Bind( "de", prefix.."label_presets",            "Stapler-Voreinstellungen: " )
localify.Bind( "de", prefix.."label_relative",           "Stapel relativ zu: " )
localify.Bind( "de", prefix.."label_direction",          "Stapelrichtung: " )
localify.Bind( "de", prefix.."label_count",              "Stapelgröße" )
localify.Bind( "de", prefix.."label_reset_offsets",      "Versätze zurücksetzen" )
localify.Bind( "de", prefix.."label_reset_angles",       "Winkel zurücksetzen" )
localify.Bind( "de", prefix.."label_show_settings",      "Zum Anzeigen der Einstellungen anklicken" )
localify.Bind( "de", prefix.."label_hide_settings",      "Zum Verstecken der Einstellungen anklicken" )
localify.Bind( "de", prefix.."label_x",                  "X  (-Hinten, +Vorne)" )
localify.Bind( "de", prefix.."label_y",                  "Y  (-Links, +Rechts)" )
localify.Bind( "de", prefix.."label_z",                  "Z  (-Runter, +Hoch)" )
localify.Bind( "de", prefix.."label_pitch",              "Nicken  (-Runter, +Hoch)" )
localify.Bind( "de", prefix.."label_yaw",                "Gieren   (-Links, +Rechts)" )
localify.Bind( "de", prefix.."label_roll",               "Roll    (-Links, +Rechts)" )
localify.Bind( "de", prefix.."label_language",           "Sprache: " )
localify.Bind( "de", prefix.."label_credits",            "" )
localify.Bind( "de", prefix.."label_max_per_stack",      "Stapelgröße" )
localify.Bind( "de", prefix.."label_max_per_player",     "Props je Spieler" )
localify.Bind( "de", prefix.."label_max_offsetx",        "Maximaler X-Offset" )
localify.Bind( "de", prefix.."label_max_offsety",        "Maximaler Y-Offset" )
localify.Bind( "de", prefix.."label_max_offsetz",        "Maximaler Z-Offset" )
localify.Bind( "de", prefix.."label_delay",              "Delay/Verzögerung" )
localify.Bind( "de", prefix.."label_opacity",            "Deckkraft" )
-- Checkboxes
localify.Bind( "de", prefix.."checkbox_freeze",          "Einfrieren gestapelter Props" )
localify.Bind( "de", prefix.."checkbox_weld",            "Verbinde gestapelte Props" )
localify.Bind( "de", prefix.."checkbox_nocollide",       "Keine-Kollision der gestapelte Props mit einander" )
localify.Bind( "de", prefix.."checkbox_nocollide_all",   "Keine-Kollision der gestapelte Props mit ALLEM" )
localify.Bind( "de", prefix.."checkbox_use_shift_key",   "Stapelgröße mit SHIFT + Links-/Rechtsklick ändern" )
localify.Bind( "de", prefix.."checkbox_relative",        "Stapel relativ zur neuen Drehung" )
localify.Bind( "de", prefix.."checkbox_material",        "Material anwenden" )
localify.Bind( "de", prefix.."checkbox_color",           "Farbe anwenden" )
localify.Bind( "de", prefix.."checkbox_physprop",        "Physikalische Eigenschaften anwenden" )
localify.Bind( "de", prefix.."checkbox_ghost",           "Ghoste alle Props im Stapel" )
localify.Bind( "de", prefix.."checkbox_halo",            "Halos zu geghosteten Props hinzufügen" )
localify.Bind( "de", prefix.."checkbox_halo_color",      "Halo-Farbe" )
localify.Bind( "de", prefix.."checkbox_axis",            "XYZ-Achse zeigen" )
localify.Bind( "de", prefix.."checkbox_axis_labels",     "XYZ-Achsenbeschriftungen zeigen" )
localify.Bind( "de", prefix.."checkbox_axis_angles",     "XYZ-Achsenwinkel zeigen" )
localify.Bind( "de", prefix.."checkbox_stayinworld",     "In der Welt bleiben" )
-- Comboboxes
localify.Bind( "de", prefix.."combobox_world",           "Welt" )
localify.Bind( "de", prefix.."combobox_prop",            "Prop" )
localify.Bind( "de", prefix.."combobox_direction_up",    "Hoch" )
localify.Bind( "de", prefix.."combobox_direction_down",  "Runter" )
localify.Bind( "de", prefix.."combobox_direction_front", "Vorne" )
localify.Bind( "de", prefix.."combobox_direction_back",  "Hinten" )
localify.Bind( "de", prefix.."combobox_direction_right", "Rechts" )
localify.Bind( "de", prefix.."combobox_direction_left",  "Links" )
localify.Bind( "de", prefix.."combobox_default",         "Standard" )
localify.Bind( "de", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "de", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "de", prefix.."combobox_singleplayer",    "Singleplayer" )
-- HUD
localify.Bind( "de", prefix.."hud_front",                "Vorne" )
localify.Bind( "de", prefix.."hud_right",                "Rechts" )
localify.Bind( "de", prefix.."hud_up",                   "Hoch" )
-- Help
localify.Bind( "de", prefix.."help_max_per_player",      "Die maximale Anzahl gestapelter Props pro Spieler ist begrenzt." )
localify.Bind( "de", prefix.."help_max_per_stack",       "Maximale Props pro Stapel (Linksklick)." )
localify.Bind( "de", prefix.."help_delay",               "Verzögerung (in Sekunden) zwischen jeder Stacker-Verwendung (Links-/Rechtsklick)" )
localify.Bind( "de", prefix.."help_max_offsetx",         "Maximaler Abstand zwischen gestapelten Props (X-Achse)." )
localify.Bind( "de", prefix.."help_max_offsety",         "Maximaler Abstand zwischen gestapelten Props (Y-Achse)." )
localify.Bind( "de", prefix.."help_max_offsetz",         "Maximaler Abstand zwischen gestapelten Props (Z-Achse)." )
localify.Bind( "de", prefix.."help_freeze",              "Gestapelte Props werden beim Spawnen eingefroren." )
localify.Bind( "de", prefix.."help_weld",                "Gestapelte Stützen werden beim Spawnen aneinander verbunden." )
localify.Bind( "de", prefix.."help_nocollide",           "Gestapelte Props kollidieren nicht mit anderen gestapelten Props." )
localify.Bind( "de", prefix.."help_nocollide_all",       "Gestapelte Props kollidieren mit nichts außer Spielern, NPCs, Fahrzeugen und der Welt." )
localify.Bind( "de", prefix.."help_stayinworld",         "Verhindert, dass gestapelte Props außerhalb der Map erstellt werden." )
-- Warnings
localify.Bind( "de", prefix.."warning_max_per_player",   "In erster Linie für Rollenspiel-Gamemodi. Für Sandbox-Gamemodes sollte dies generell unbegrenzt sein (-1)." )
localify.Bind( "de", prefix.."warning_max_offsetx",      "In erster Linie für Rollenspiel-Gamemodi. Ändern Sie nichts, wenn Sie nicht wissen, was Sie tun." )
localify.Bind( "de", prefix.."warning_max_offsety",      "In erster Linie für Rollenspiel-Gamemodi. Ändern Sie nichts, wenn Sie nicht wissen, was Sie tun." )
localify.Bind( "de", prefix.."warning_max_offsetz",      "In erster Linie für Rollenspiel-Gamemodi. Ändern Sie nichts, wenn Sie nicht wissen, was Sie tun." )
localify.Bind( "de", prefix.."warning_freeze",           "Für DarkRP." )
localify.Bind( "de", prefix.."warning_weld",             "Für DarkRP." )
localify.Bind( "de", prefix.."warning_nocollide",        "Für DarkRP." )
localify.Bind( "de", prefix.."warning_nocollide_all",    "ÄNDERE NICHTS, WÄHREND DER SERVER AUSGEFÜHRT WIRD. Dies verwendet den GM.ShouldCollide-Hook und ist experimentell. Es funktioniert und verhindert garantiert Abstürze von Stacker, muss aber noch weiter getestet werden." )


--[[--------------------------------------------------------------------------
-- <Other> Localization
--------------------------------------------------------------------------]]--
--[[
-- Tool Settings
localify.Bind( "", prefix.."name",                     "" )
localify.Bind( "", prefix.."desc",                     "" )
localify.Bind( "", prefix.."left",                     "" )
localify.Bind( "", prefix.."shift_left",               "" )
localify.Bind( "", prefix.."right",                    "" )
localify.Bind( "", prefix.."shift_right",              "" )
localify.Bind( "", prefix.."reload",                   "" )
localify.Bind( "", "Undone_stacker_improved",          "" )
-- Errors
localify.Bind( "", prefix.."error_blocked_by_server",  "" )
localify.Bind( "", prefix.."error_not_admin",          "" )
localify.Bind( "", prefix.."error_invalid_argument",   "" )
localify.Bind( "", prefix.."error_max_count",          "" )
localify.Bind( "", prefix.."error_too_quick",          "" )
localify.Bind( "", prefix.."error_max_total",          "" )
localify.Bind( "", prefix.."error_not_in_world",       "" )
localify.Bind( "", prefix.."error_max_constraints",    "" )
-- Labels
localify.Bind( "", prefix.."label_presets",            "" )
localify.Bind( "", prefix.."label_relative",           "" )
localify.Bind( "", prefix.."label_direction",          "" )
localify.Bind( "", prefix.."label_count",              "" )
localify.Bind( "", prefix.."label_reset_offsets",      "" )
localify.Bind( "", prefix.."label_reset_angles",       "" )
localify.Bind( "", prefix.."label_show_settings",      "" )
localify.Bind( "", prefix.."label_hide_settings",      "" )
localify.Bind( "", prefix.."label_x",                  "" )
localify.Bind( "", prefix.."label_y",                  "" )
localify.Bind( "", prefix.."label_z",                  "" )
localify.Bind( "", prefix.."label_pitch",              "" )
localify.Bind( "", prefix.."label_yaw",                "" )
localify.Bind( "", prefix.."label_roll",               "" )
localify.Bind( "", prefix.."label_language",           "" )
localify.Bind( "", prefix.."label_credits",            "" )
localify.Bind( "", prefix.."label_max_per_stack",      "" )
localify.Bind( "", prefix.."label_max_per_player",     "" )
localify.Bind( "", prefix.."label_max_offsetx",        "" ) 
localify.Bind( "", prefix.."label_max_offsety",        "" )
localify.Bind( "", prefix.."label_max_offsetz",        "" )
localify.Bind( "", prefix.."label_delay",              "" )
localify.Bind( "", prefix.."label_opacity",            "" )
-- Checkboxes
localify.Bind( "", prefix.."checkbox_freeze",          "" )
localify.Bind( "", prefix.."checkbox_weld",            "" )
localify.Bind( "", prefix.."checkbox_nocollide",       "" )
localify.Bind( "", prefix.."checkbox_nocollide_all",   "" )
localify.Bind( "", prefix.."checkbox_use_shift_key",   "" )
localify.Bind( "", prefix.."checkbox_relative",        "" )
localify.Bind( "", prefix.."checkbox_material",        "" )
localify.Bind( "", prefix.."checkbox_color",           "" )
localify.Bind( "", prefix.."checkbox_physprop",        "" )
localify.Bind( "", prefix.."checkbox_ghost",           "" )
localify.Bind( "", prefix.."checkbox_halo",            "" )
localify.Bind( "", prefix.."checkbox_halo_color",      "" )
localify.Bind( "", prefix.."checkbox_axis",            "" )
localify.Bind( "", prefix.."checkbox_axis_labels",     "" )
localify.Bind( "", prefix.."checkbox_axis_angles",     "" )
localify.Bind( "", prefix.."checkbox_stayinworld",     "" )
-- Comboboxes
localify.Bind( "", prefix.."combobox_world",           "" )
localify.Bind( "", prefix.."combobox_prop",            "" )
localify.Bind( "", prefix.."combobox_direction_up",    "" )
localify.Bind( "", prefix.."combobox_direction_down",  "" )
localify.Bind( "", prefix.."combobox_direction_front", "" )
localify.Bind( "", prefix.."combobox_direction_back",  "" )
localify.Bind( "", prefix.."combobox_direction_right", "" )
localify.Bind( "", prefix.."combobox_direction_left",  "" )
localify.Bind( "", prefix.."combobox_default",         "" )
localify.Bind( "", prefix.."combobox_sandbox",         "" )
localify.Bind( "", prefix.."combobox_darkrp",          "" )
localify.Bind( "", prefix.."combobox_singleplayer",    "" )
-- HUD
localify.Bind( "", prefix.."hud_front",                "" )
localify.Bind( "", prefix.."hud_right",                "" )
localify.Bind( "", prefix.."hud_up",                   "" )
-- Help
localify.Bind( "", prefix.."help_max_per_player",      "" )
localify.Bind( "", prefix.."help_max_per_stack",       "" )
localify.Bind( "", prefix.."help_delay",               "" )
localify.Bind( "", prefix.."help_max_offsetx",         "" )
localify.Bind( "", prefix.."help_max_offsety",         "" )
localify.Bind( "", prefix.."help_max_offsetz",         "" )
localify.Bind( "", prefix.."help_freeze",              "" )
localify.Bind( "", prefix.."help_weld",                "" )
localify.Bind( "", prefix.."help_nocollide",           "" )
localify.Bind( "", prefix.."help_nocollide_all",       "" )
localify.Bind( "", prefix.."help_stayinworld",         "" )
-- Warnings
localify.Bind( "", prefix.."warning_max_per_player",   "" )
localify.Bind( "", prefix.."warning_max_offsetx",      "" )
localify.Bind( "", prefix.."warning_max_offsety",      "" )
localify.Bind( "", prefix.."warning_max_offsetz",      "" )
localify.Bind( "", prefix.."warning_freeze",           "" )
localify.Bind( "", prefix.."warning_weld",             "" )
localify.Bind( "", prefix.."warning_nocollide",        "" )
localify.Bind( "", prefix.."warning_nocollide_all",    "" )
]]

-- Hopefully will add more with community/crowdsource support.

-- If you are multi/bilingual, please consider helping me translate the phrases above into other languages.
-- Create an issue on the Github page ( https://github.com/Mista-Tea/improved-weight ) or
-- add me on Steam ( http://steamcommunity.com/profiles/76561198015280374 ). Thanks!

--addons/tools/lua/weapons/gmod_tool/stools/vanilla_hyperspacetool2.lua:
TOOL.Category = "Vanilla"

TOOL.Name = "Vanilla's Hyperspace Tool 2"

if CLIENT then
    language.Add("Tool.vanilla_hyperspacetool2.name","Vanilla's Hyperspace Tool 2")
    language.Add("Tool.vanilla_hyperspacetool2.desc","Make any entity or prop emerge or jump to hyperspace")
    language.Add("Tool.vanilla_hyperspacetool2.left","Choose a location for the entity/prop to jump to")
    language.Add("Tool.vanilla_hyperspacetool2.right","Choose an entity/prop to jump into hyperspace")
end

TOOL.ClientConVar[ "height" ] = "0"
TOOL.ClientConVar[ "angle" ] = "0"
TOOL.ClientConVar[ "ship" ] = ""
TOOL.ClientConVar[ "ai" ] = "0"
TOOL.ClientConVar[ "freeze" ] = "0"
TOOL.ClientConVar[ "flip" ] = "0"
TOOL.ClientConVar[ "shake" ] = "0"
TOOL.ClientConVar[ "sound" ] = "0"
TOOL.ClientConVar[ "delay" ] = "0"
TOOL.ClientConVar[ "model" ] = ""
TOOL.ClientConVar[ "spawnmodel" ] = "0"

TOOL.Information = {
    { name = "left" },
    { name = "right" }
}

function TOOL:LeftClick( trace )
    if not trace.HitPos then return false end

    local Delay = self:GetClientInfo("delay")
    local Height = self:GetClientNumber("height")
    local vAngle = self:GetClientNumber("angle")
    local Ship = self:GetClientInfo("ship")
    local AI = self:GetClientInfo("ai")
    local Freeze = self:GetClientInfo("freeze")
    local Flip = self:GetClientInfo("flip")
    local Shake = self:GetClientInfo("shake")
    local vSound = self:GetClientInfo("sound")
    local vModel = self:GetClientInfo("model")
    local SpawnModel = self:GetClientInfo("spawnmodel")

    local Valid = false

    for k, v in pairs(scripted_ents.GetList()) do
        if Ship == v.t.ClassName then
            Valid = true
        end
    end

    if list.HasEntry("NPC",Ship) then
        Valid = true
    end

    if SpawnModel == "1" then
        Valid = true
    end

    if Valid == true && SERVER then
        timer.Simple(Delay, function()
            local ent = ents.Create("vanilla_hyperspace2_ship")
            if not IsValid(ent) then return end
            ent:SetKeyValue("AI", AI)
            ent:SetKeyValue("Freeze", Freeze)
            ent:SetKeyValue("Flip", Flip)
            ent:SetKeyValue("Shake", Shake)
            ent:SetKeyValue("Sound", vSound)
            ent:SetKeyValue("SpawnModel", SpawnModel)
            ent:SetKeyValue("ActualModel", vModel)
            ent:SetKeyValue("Entity", Ship)
            ent:SetOwner(self:GetOwner())
            ent:SetPos(trace.HitPos + Vector(0,0,Height))
            ent:SetAngles(Angle(0,0,0) + Angle(0,vAngle,0))
            ent:Spawn()
            ent:SetMoveType(MOVETYPE_NONE)

            undo.Create( "Ship" )
                undo.AddEntity( ent )
                undo.SetPlayer( self:GetOwner() )
                undo.SetCustomUndoText("Undone Ship")
            undo.Finish()
            return false
        end)
    end
end


local timerName = tostring(SysTime())

function TOOL:RightClick( trace )
    local ent = trace.Entity
    if not IsValid(ent) then return end
    if ent:IsPlayer() then return end

    if not SERVER then return end
    local sound = ents.Create("vanilla_highwake2")
    if not IsValid(sound) then return end
    sound:SetPos(ent:GetPos())
    sound:Spawn()
    sound:SetNoDraw(true)

    if IsValid(ent) then
        timer.Simple(3,function()
            if not IsValid(ent) then return end
            timer.Create(timerName,0,0.2,function()
                if not ent:IsValid() then return end
                if self:GetClientInfo("flip") == "0" then
                    ent:SetPos(ent:GetPos() + ent:GetForward() * 700)
                else
                    ent:SetPos(ent:GetPos() - ent:GetForward() * 700)
                end
            end)
        end)
        timer.Create(timerName .. "Ender",5 + 1,1,function()
            timer.Remove(timerName)
            if not IsValid(ent) then return end
            ent:Remove()
        end)
    end
end

function TOOL:Think()
    if not ( IsValid( self.GhostEntity ) ) then
        self:MakeGhostEntity( "models/xqm/jetbody3_s5.mdl", Vector( 0, 0, 0 ), Angle( 0, 0, 0 ) )
    end
    self:UpdateGhost( self.GhostEntity, self:GetOwner() )

    if not timer.Exists(timerName .. "Ender") then return end
    if timer.RepsLeft(timerName .. "Ender") == 0 then
        timer.Remove(timerName .. "Ender")
    end
end

function TOOL:UpdateGhost( ent, pl )
    if not ( IsValid( ent ) ) then return end
    local trace = pl:GetEyeTrace()
    if not trace.Hit then
        ent:SetNoDraw( true )
        return
    end
    ent:SetPos( trace.HitPos + Vector(0,0,self:GetClientNumber("height")) )
    if self:GetClientNumber("flip") == 0 then
        ent:SetAngles( (Angle(0,0,0) + Angle(0,90,0)) + Angle(0,self:GetClientNumber("angle"),0) )
    else
        ent:SetAngles( Angle(0,0,0) + Angle(0,270,0) + Angle(0,self:GetClientNumber("angle"),0))
    end
ent:SetNoDraw( false )
    ent:SetMaterial("phoenix_storms/dome",true)
    ent:SetColor(Color(0,255,0,125))
end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel( CPanel )
    if not CLIENT then return end

    CPanel:SetName( "Vanilla's Hyperspace Tool 2" )

    local header = vgui.Create("DImage", CPanel)
    header:SetSize(267, 134)
    header:SetImage("vanilla_header/hyperspacetool_header.png")
    CPanel:AddItem(header)

    CPanel:Help( "Version: 1.0" )

    CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "vanilla_hyperspacetool2", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

    CPanel:NumSlider("Height", "vanilla_hyperspacetool2_height", 0, 10000)
    CPanel:ControlHelp("Sets the height of the spawned ship.")

    CPanel:NumSlider("Angle", "vanilla_hyperspacetool2_angle", 0, 360)
    CPanel:ControlHelp("Sets the angle of the spawned ship.")

    CPanel:NumSlider("Delay", "vanilla_hyperspacetool2_delay", 0, 10, 1)
    CPanel:ControlHelp("Sets the delay (in seconds) of the spawned ship.")

    local divider1 = vgui.Create("DImage", CPanel)
    divider1:SetSize(267, 19)
    divider1:SetImage("vanilla_header/vanilla_divider.png")
    CPanel:AddItem(divider1)

    CPanel:TextEntry("Entity Name", "vanilla_hyperspacetool2_ship")
    CPanel:ControlHelp("The entity name of the desired ship.")

    CPanel:CheckBox("Model Ship", "vanilla_hyperspacetool2_spawnmodel")
    CPanel:ControlHelp("Tick this if you would like to spawn in a model instead of an entity.")

    CPanel:TextEntry("Model Name", "vanilla_hyperspacetool2_model")
    CPanel:ControlHelp("Only use if you would like to spawn in a model that is not an entity.")

    local divider2 = vgui.Create("DImage", CPanel)
    divider2:SetSize(267, 19)
    divider2:SetImage("vanilla_header/vanilla_divider.png")
    CPanel:AddItem(divider2)

    CPanel:CheckBox("Enable AI","vanilla_hyperspacetool2_ai")
    CPanel:ControlHelp("Enables AI for the spawned ship. (LFS ONLY)")

    CPanel:CheckBox("Freeze","vanilla_hyperspacetool2_freeze")
    CPanel:ControlHelp("Freezes the spawned ship.")

    CPanel:CheckBox("Flip","vanilla_hyperspacetool2_flip")
    CPanel:ControlHelp("Flips the spawned ship. (For ships with models that are backwards.) Effects the direction the ship will jump to aswell.")

    CPanel:CheckBox("Enable Screenshake","vanilla_hyperspacetool2_shake")
    CPanel:ControlHelp("Enables screenshake for people near the ship.")

    CPanel:CheckBox("Enable Sound","vanilla_hyperspacetool2_sound")
    CPanel:ControlHelp("Plays sound of the ship jumping in to all players.")

end

--lua/weapons/ls_base_mine_swep/shared.lua:
hook.Add("Initialize", "ls_add_base_mine_ammo", function()
    game.AddAmmoType( {
        name = "LS_MINE",
        dmgtype = DMG_BLAST, 
        plydmg = 0,
        npcdmg = 0,
        force = 0,
        maxcarry = 5,
        minsplash = 0,
        maxsplash = 0
    } )
end)
if CLIENT then
    language.Add("LS_MINE_ammo", "Mine")
end

SWEP.PrintName = "Base Mine SWEP"
SWEP.Author = "List-Scripts"
SWEP.Instructions = ""
SWEP.Category = "Star Wars - Mines"

SWEP.Spawnable = false
SWEP.AdminOnly = false

SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = 5
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "LS_MINE"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.Slot = 1
SWEP.SlotPos = 2
SWEP.DrawAmmo = true
SWEP.DrawCrosshair = true

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = false
SWEP.ViewModel = "models/weapons/v_grenade.mdl"
SWEP.WorldModel = "models/weapons/w_grenade.mdl"
SWEP.ViewModelBoneMods = {}


SWEP.IsMineSWEP = true
SWEP.Range = 120*120
SWEP.Mine = "ls_base_mine"
SWEP.AngleLimitation = 10
SWEP.PlaceDelay = 0.5
SWEP.CanUndo = false

SWEP.VElements = {
	["mine"] = { type = "Model", model = "models/props/starwars/weapons/ap_mine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.635, 2.596, 0.518), angle = Angle(-180, 0, 0)}
}

SWEP.WElements = {
	["mine"] = { type = "Model", model = "models/props/starwars/weapons/ap_mine.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.635, 2.596, 1.557), angle = Angle(-180, 0, 0)}
}

function SWEP:PreInitialize()
    self.MineModel = scripted_ents.Get(self.Mine).Model
end

function SWEP:Holster()
	
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end
--lua/weapons/mace/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = " Mace"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Simple"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils++++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(141.429, 90, 0), size = Vector(0.081, 0.081, 0.081), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 50), size = Vector(0.082, 0.082, 0.082), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/future_vents", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/future_vents", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 0), size = Vector(0.079, 0.079, 0.079), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(141.429, 90, 0), size = Vector(0.081, 0.081, 0.081), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 0), size = Vector(0.079, 0.079, 0.079), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 50), size = Vector(0.082, 0.082, 0.082), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/future_vents", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 5, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/future_vents", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} }
}



SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 40
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.98
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Impact.Glass"
SWEP.Primary.Range       = 12

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/arccw_weapons/lua/weapons/masita_dc15a_heavy.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Heavy DC-15a"
SWEP.Trivia_Class = "Heavy-Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15a_hvy.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000400000001"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_dc15a.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-13, 6, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.NoHideLeftHandInCustomization = true

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.8,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 1.1,
    [HITGROUP_RIGHTARM] = 1.1,
}

SWEP.Damage = 37
SWEP.RangeMin = 197
SWEP.DamageMin = 24
SWEP.Range = 480
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 413
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55
SWEP.Recoil = 0.23
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.11
SWEP.Delay = 60 / 399
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}
SWEP.AccuracyMOA = 0.59
SWEP.HipDispersion = 447
SWEP.MoveDispersion = 54

-- Speed Mult
SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootSound = "armas/disparos/dc15le.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.987, -9.924, 0.939),
    Ang = Angle(0, 0, 0),
     Magnification = 1.4,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

-- Attachments
SWEP.Attachments = {      
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Bone = "dc-15a",
        Slot = {"dc15a_magazine_75"},
        Offset = {
            vpos = Vector(-1.7, -0.6, 2.5),
            vang = Angle(0, 0, 0),
        },
    },         
    {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    }, 
    {
        PrintName = "Grenade Launcher",
        DefaultAttName = "None",
        Slot = {"rep_ubgl"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.675),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 20.7),
            vang = Angle(90, 0, 0),
        },
    },      
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -1.4, 31.2),
            vang = Angle(90, 0, 0),
        },
    },  
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0.830, -1.83, 10.273),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Idle"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2.2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },
}
--addons/arccw_weapons/lua/weapons/masita_dc17ext.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17 Extended"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17 hand blaster, also known as DC-17 blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17_ext.png"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_dc17_extended.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_dc17_extended.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-13.3, 3, -4.9),
    ang = Angle(-10, 0, 180),
    scale = 1.1,
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 34
SWEP.RangeMin = 132
SWEP.DamageMin = 23
SWEP.Range = 327
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 27

SWEP.Recoil = 1.02
SWEP.RecoilPunch = 0.8
SWEP.RecoilSide = 0.17
SWEP.RecoilRise = 0.34

SWEP.Delay = 60 / 376
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = -2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 
SWEP.HipDispersion = 530
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

---- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-1.298, -1.102, 1.84),
    Ang = Vector(1.639, -2.372, 20.429),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.Primary.Ammo = "ar2"

-- Sound & Holdtype
SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/dc17ext_2.wav"
SWEP.ShootSound = "armas/disparos/dc17ext_1.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "revolver"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(0, 6, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, 1)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {}


SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "dc17",
        Offset = {
            vpos = Vector(0.1, -2.5, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(-4, -1.2, 0),
        CorrectivePos = Vector(0, 0, 0),
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        WMScale = Vector(0.7, 0.7, 0.7),
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dc17",
        Offset = {
            vpos = Vector(0.1, 0.4, 5),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "dc17",
        Offset = {
            vpos = Vector(0.3, -0.8, 6.3),
            vang = Angle(90, 0, -90),
        },
    }, 
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },        
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7,0.7,0.7),
        Bone = "dc17",
        Offset = {
            vpos = Vector(0.7, -1, 0.184),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "dc17",
        Offset = {
            vpos = Vector(0.6, -0.848, 3),
            vang = Angle(90, 0, -90),
        },
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = "Idle",
    },
    ["bash"] = {
        Source = "Bash"
    },
    ["fire"] = {
        Source = "Shoot"
    },
    ["fire_iron"] = {
        Source = "Shoot"
    },
    ["draw"] = {
        Source = "Draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "Holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "Reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 40 / 30 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },


sound.Add({
    name =          "dc17_1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armasclasicas/wpn_wristrocket_reload.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/masita_valken38x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita/Meeks"
SWEP.PrintName = "Valken 38x"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The Valken-38x was a model of longblaster that was manufactured for high precision and power over long ranges. It was utilized by the Galactic Republic during the Clone Wars."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/valken38.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.ViewModel = "models/servius/weapons/viewmodels/c_valken38x.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_valken38x.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.3,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 290
SWEP.RangeMin = 230
SWEP.DamageMin = 73
SWEP.Range = 890
SWEP.Penetration = 1.2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 45
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25
SWEP.Recoil = 0.14
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.1
SWEP.Delay = 60 / 210
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.47
SWEP.HipDispersion = 376
SWEP.MoveDispersion = 60
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.NoFlash = nil

SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootSound = "armas/disparos/valken.wav"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.99, -4.258, 1.029),
    Ang = Vector(0, 0.127, 2.813),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
-- Attachments 
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        WMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(20, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        },
    },
}

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0.18, -6.25, 1.273),
            vang = Angle(0, -90, 0),
            wpos = Vector(6, 1.5, -5),
            wang = Angle(-10, 2, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Laser/Flashlight", 
        DefaultAttName = "None",
        Slot = {"tactical","tac_pistol"},
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0.972, 7.546, 0.651),
            vang = Angle(0, -90, 90),
            wpos = Vector(14, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
    },
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0, 1.628, 0),
            vang = Angle(0, -90, 0),
            wpos = Vector(9, .5, 2),
            wang = Angle(0, 0, 180)    
        },
        SlideAmount = {
        vmin = Vector(-0.2, 2, 0),
        vmax = Vector(-0.2, 7, 0),
        wmin = Vector(9, 0.8, -4), 
        wmax = Vector(9, 0.8, -4)
        },                  
    },     
    {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },   
    {
        PrintName = "Training/Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "Valken38x_material",
        Offset = {
            vpos = Vector(0.6, -7.752, 0.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(6, 1.8, -4.5),
            wang = Angle(0, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "Shoot"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "draw/sw01_characters_gunfoley_draw_blaster_var14.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "valken38_r1", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "valken38_r1",
    channel =       CHAN_ITEM,
    volume =        1.1,
    sound =             "armas/misc/standard_reload.ogg"
    }),
}

--addons/weapons_other/lua/weapons/massiff_swep.lua:
AddCSLuaFile()

SWEP.PrintName			= "BD1 SWEP"
SWEP.Author				= "Rino" 
SWEP.Instructions		= [[
R - /
LMB - Random Sound
RMB - Schrei Sound
	]]
SWEP.Spawnable = false
SWEP.AdminOnly = true

SWEP.Category	= "AoC - SWEPs"

SWEP.AnimPrefix = "rpg"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo		= "none"
SWEP.Primary.Distance		= 100
SWEP.Primary.Delay			= 4
SWEP.Primary.Damage			= 40

--SWEP.stunTime = 2.5;
 
SWEP.HoldType			= "normal"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"
SWEP.Secondary.Delay	= 10

SWEP.Weight			= 5
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false
SWEP.Slot			= 1
SWEP.SlotPos			= 1
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.ViewModel			= "models/weapons/c_medkit.mdl"
SWEP.WorldModel	= ""



sounds = {
    [1] = "bd1/bop1.mp3",
    [2] = "bd1/bop2.mp3",
    [3] = "bd1/bop3.mp3",
    [4] = "bd1/bop4.mp3",
    [5] = "bd1/bop5.mp3",
    [6] = "bd1/bop6.mp3",
    [7] = "bd1/bop7.mp3",
    [8] = "bd1/bop8.mp3",
    [9] = "bd1/bop9.mp3",
    [10] = "bd1/bop1.mp3",
    
    }



function SWEP:Initialize()
	self:SetWeaponHoldType( self.HoldType )
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	local rand = math.random(1,10)
          nrw = sounds[rand]
		  timer.Simple( 0.5, function() self:EmitSound(nrw) end )
          --EmitSound(nrw)
end


function SWEP:Reload()
end

function SWEP:SecondaryAttack()
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	timer.Simple( 0.5, function() self:EmitSound("astromech/scream.mp3") end )
end

function SWEP:PreDrawViewModel( vm, pl, wep )
	return true
end
--addons/star_wars_mortar/lua/weapons/mortar_range_finder/shared.lua:
AddCSLuaFile()

SWEP.PrintName = "Rangefinder"
SWEP.Base = "weapon_base"

SWEP.Author = "DolUnity"
SWEP.Purpose = "Get the Target Distance"
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Spawnable = true
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.WorldModel = "models/maxofs2d/camera.mdl"
SWEP.HoldType = "camera"
SWEP.UseHands = true
SWEP.DrawAmmo = false

SWEP.Slot = 4

SWEP.Primary.ClipSize = 0
SWEP.Primary.DefaultClipSize = 0

SWEP.Secondary.ClipSize = 0
SWEP.Secondary.DefaultClipSize = 0

if (CLIENT) then
    SWEP.PreviewModel = ClientsideModel("models/dolunity/starwars/mortar.mdl")
    SWEP.PreviewModel:SetNoDraw(true)
    SWEP.PreviewModel:SetMaterial("models/wireframe")
end

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)
end

function SWEP:PrimaryAttack() end

function SWEP:SecondaryAttack()
    if (not IsFirstTimePredicted()) then return end

    if (self.Zoom) then
        self.Owner:SetFOV(self.OldFOV, 0.5)
        self.Zoom = false
    else
        self.Zoom = true
        self.OldFOV = self.Owner:GetFOV()
        self.Owner:SetFOV(20, 0.5)
    end
end

function SWEP:ShouldDrawViewModel()
    return false
end

function SWEP:AdjustMouseSensitivity()
    if (self.Owner:GetFOV() == 20) then
        return 0.05
    end
    return 1
end

function SWEP:Deploy()
    self:SetHoldType(self.HoldType)
end

local laserPointer = Material("Sprites/light_glow02_add_noz")
hook.Add("PostDrawTranslucentRenderables", "swmRangeFinderLaser", function()
    if (LocalPlayer():Alive() and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "mortar_range_finder" and not LocalPlayer():InVehicle()) then
        local trace = LocalPlayer():GetEyeTrace()
        render.SetMaterial(laserPointer)
        render.DrawQuadEasy(trace.HitPos + trace.HitNormal, trace.HitNormal, 32, 32, Color(255,0,0),0)
    end
end)

local rangeTable = Material("models/dolunity/starwars/mortar_scale.png")
hook.Add("HUDPaint", "swmRangeFinderDistanceHUD", function ()
    if (LocalPlayer():Alive() and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "mortar_range_finder" and not LocalPlayer():InVehicle()) then
        local trace = LocalPlayer():GetEyeTrace()
        local dist = LocalPlayer():GetPos():Distance(trace.HitPos)

        surface.SetFont("swmFont")
        surface.SetTextColor(75, 255, 255)
        local mText = math.Round(dist / 40, 1) .. "m"
        local mWidth, mHeight = surface.GetTextSize(mText)
        surface.SetTextPos((ScrW() - mWidth) / 2, ScrH() / 2 + ScrH() * 0.03)
        surface.DrawText(mText)

        local rText = math.Round(math.abs((LocalPlayer():GetAngles().y + 360) % 360 - 360),2)
        local rWidth, rHeight = surface.GetTextSize(rText)
        surface.SetTextPos((ScrW() - rWidth) / 2, ScrH() / 2 + ScrH() * 0.03 + rHeight * 1.1)
        surface.DrawText(rText .. "°")

        surface.SetDrawColor(255,255,255)
        surface.SetMaterial(rangeTable)
        local height = ScrH() * 0.462
        local width = height * 0.6
        surface.DrawTexturedRect(ScrW() * 0.02, (ScrH() - height) / 2, width, height)
    end
end)
--addons/joes_stuff/lua/weapons/shield_deployer_base/shared.lua:
AddCSLuaFile()

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.UseHands = false
SWEP.Category = "AOCRP - Schilde"

SWEP.ENT_CLASS = "shield_1"

SWEP.PrintName = "Shield Deployer Base"
SWEP.Author = "Joe"
SWEP.Purpose = "Deploy Shields"

SWEP.ViewModelFOV	= 60
SWEP.ViewModelFlip	= false
SWEP.ViewModel = "models/jackjack/props/shieldgen.mdl"
SWEP.WorldModel = "models/jackjack/props/shieldgen.mdl"
SWEP.Primary.Ammo = "none"
SWEP.Secondary.Ammo = "none"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1

SWEP.Spawnable			= false
SWEP.AdminSpawnable		= false

SWEP.cooldown = 0

function SWEP:Initialize()
  self:SetWeaponHoldType( "slam" )
  self.Owner.placingdown = false
end

function SWEP:PrimaryAttack()
 

  if self.cooldown > CurTime() then return end
    self.Owner.placingdown = true
    if SERVER then
     
      local owner = self.Owner
      local hitpos = owner:GetEyeTrace().HitPos
      if owner:GetPos():DistToSqr(hitpos) > 20000 then return end

      if not owner.personalshield or not IsValid(owner.personalshield) then
        owner.personalshield = ents.Create(self.ENT_CLASS)
        if ( not owner.personalshield:IsValid() ) then return end
        owner.personalshield:SetPos( hitpos )

        local ang = owner:GetAngles()
        ang.p = 0

        owner.personalshield:SetAngles(ang)
        owner.personalshield:Spawn()
        owner:EmitSound("plats/train_use1.wav")

      end
      
    end
    self.cooldown = CurTime() + 10
end 
  

function SWEP:SecondaryAttack()
  self.Owner.placingdown = false
 
  if SERVER then
    local owner = self.Owner
    if owner.personalshield and IsValid(owner.personalshield) then
        SafeRemoveEntity(owner.personalshield)
        owner.personalshield = nil
    end
  end

end

if CLIENT then
  function SWEP:Think()
    local ply = self.Owner

    if IsValid(self.PreviewEnt) then
        if (self.Owner:GetPos():DistToSqr(ply:GetEyeTrace().HitPos) > 30000) or (ply.placingdown) then 
            self.PreviewEnt:SetNoDraw(true) 
        else
            self.PreviewEnt:SetNoDraw(false)
        end
    end

	if not IsValid(self.PreviewEnt) then
      	self.PreviewEnt = ents.CreateClientProp("models/jackjack/props/shieldgen.mdl")
     
      	if not IsValid(self.PreviewEnt) then
       		self.PreviewEnt = nil
            return
      	end
      	self.PreviewEnt:SetModel("models/jackjack/props/shieldgen.mdl")
      	self.PreviewEnt:SetPos(ply:GetEyeTrace().HitPos)
      	self.PreviewEnt:PhysicsInit(SOLID_VPHYSICS)
      	self.PreviewEnt:SetNotSolid(true)
      	self.PreviewEnt:SetRenderMode(RENDERMODE_TRANSALPHA)
     	self.PreviewEnt:SetMoveType(MOVETYPE_NONE)
      	self.PreviewEnt:Spawn()
      	self.PreviewEnt:SetColor(Color(8,68,124,200))
     	self.PreviewEnt:SetMaterial("models/debug/debugwhite")
    else
		if IsValid(self.PreviewEnt) then
            self.PreviewEnt:SetPos(ply:GetEyeTrace().HitPos)

            local ang = ply:GetAngles()
            ang.p = 0

            self.PreviewEnt:SetAngles(ang)
      	end
    end
  end
  
  function SWEP:Holster()
    timer.Simple(0.1, function()
        if IsValid(self.PreviewEnt) then self.PreviewEnt:Remove() end
    end)
  end

  function SWEP:OnRemove()
    if IsValid(self.PreviewEnt) then self.PreviewEnt:Remove() end
  end

  SWEP.ViewModelPos  = Vector(30.49, 80, -42.371)
  SWEP.ViewModelAng  = Vector(0,0,0)
  
  function SWEP:GetViewModelPosition(EyePos, EyeAng)
		local Mul = 0.8

		local Offset = self.ViewModelPos

		if (self.ViewModelAng) then
    	    EyeAng = EyeAng * 1
			EyeAng:RotateAroundAxis(EyeAng:Right(), 	self.ViewModelAng.x * Mul)
			EyeAng:RotateAroundAxis(EyeAng:Up(), 		self.ViewModelAng.y * Mul)
			EyeAng:RotateAroundAxis(EyeAng:Forward(),   self.ViewModelAng.z * Mul)
		end

		local Right 	= EyeAng:Right()
		local Up 		= EyeAng:Up()
		local Forward 	= EyeAng:Forward()

		EyePos = EyePos + Offset.x * Right * Mul
		EyePos = EyePos + Offset.y * Forward * Mul
		EyePos = EyePos + Offset.z * Up * Mul
	
		return EyePos, EyeAng
	end

    local WorldModel = ClientsideModel(SWEP.WorldModel)
	-- Settings...
	WorldModel:SetSkin(1)
    WorldModel:SetModelScale(0.25)
	WorldModel:SetNoDraw(true)
	function SWEP:DrawWorldModel()
        local _Owner = self:GetOwner()
		if (IsValid(_Owner)) then
            -- Specify a good position
			local offsetVec = Vector(5, -7, -1)
            local offsetAng = Angle(10, 0, 200)
			local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
			if !boneid then return end
			local matrix = _Owner:GetBoneMatrix(boneid)
			if !matrix then return end
			local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())
			WorldModel:SetPos(newPos)
			WorldModel:SetAngles(newAng)
            WorldModel:SetupBones()
		else
			WorldModel:SetPos(self:GetPos())
			WorldModel:SetAngles(self:GetAngles())
		end
		WorldModel:DrawModel()
    end
end
--lua/weapons/spanish_sword/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = " Spanish sword"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Simple"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(15, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/shell2x2a.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.5), angle = Angle(0, 0, 0), size = Vector(0.048, 0.048, 0.048), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/tube1x1x1c.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 3), angle = Angle(0, -90, -90), size = Vector(0.09, 0.15, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, -2, 4.9), angle = Angle(0, 0, -90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 2, 4.9), angle = Angle(0, 0, 90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -1), angle = Angle(0, 90, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 13.6), angle = Angle(0, 0, 0), size = Vector(0.014, 0.014, 0.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, -2, 4.9), angle = Angle(0, 0, -90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 14), angle = Angle(0, 0, 0), size = Vector(0.014, 0.014, 0.6), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/tube1x1x1c.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 3), angle = Angle(0, -90, -90), size = Vector(0.09, 0.15, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 2, 4.9), angle = Angle(0, 0, 90), size = Vector(0.025, 0.025, 0.07), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 0, 5), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/shell2x2a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.5), angle = Angle(0, 0, 0), size = Vector(0.048, 0.048, 0.048), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metal_plate", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 28
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.28
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--lua/weapons/tesla_dagger/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Tesla dagger"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Tesla"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
["v_weapon.Knife_Handle"] = { scale = Vector(0.07, 0.07, 0.07), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_Spine4", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 255), surpresslightning = false, material = "effects/tvscreen_noise002a", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/blocks/cube025x125x025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0.3, -1, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.059, 0.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bluemetal", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bluemetal", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bluemetal", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 5, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bluemetal", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/blocks/cube025x125x025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0.3, -1, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.059, 0.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bluemetal", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 255), surpresslightning = false, material = "effects/tvscreen_noise002a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bluemetal", skin = 0, bodygroup = {} }
}

SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 14
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 10

SWEP.Secondary.Damage 	   = 52
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 12

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
dmg:SetDamageType(DMG_DISSOLVE)
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"
bullet.Callback = function(attacker, trace, dmginfo)
		dmginfo:SetDamageType(DMG_DISSOLVE)
	end

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
dmg:SetDamageType(DMG_DISSOLVE)
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/aoc_fire_system/lua/weapons/weapon_extinguisher_infinite.lua:

SWEP.PrintName = "Feuerlöscher (Unbegrenzt)"
SWEP.Author = "Robotboy655"
SWEP.Category = "AOCRP - Tools"
SWEP.Contact = "http://steamcommunity.com/profiles/76561197996891752"
SWEP.Purpose = "To extinguish fire!"
SWEP.Instructions = "Shoot into a fire, to extinguish it."
SWEP.Base = "weapon_extinguisher"

SWEP.SlotPos = 36
SWEP.IsInfinite = true
SWEP.Spawnable = true

SWEP.Primary.Ammo = "none"

function SWEP:Ammo1()
	return 500
end

if ( SERVER ) then return end

SWEP.WepSelectIcon = Material( "icons/rb655_extinguisher_icon_inf.png" )

function SWEP:CustomAmmoDisplay()
	return { Draw = false }
end

--addons/aoc_nextbots/lua/weapons/weapon_npc_crab.lua:
AddCSLuaFile()

SWEP.Base   = "weapon_summes_npcbase"

SWEP.PrintName = "NPC: Crab"
SWEP.Spawnable = false
SWEP.Author = "Summe"

SWEP.WorldModel = false
SWEP.Weight = 3

SWEP.NextShoot = 0.5
SWEP.Tracer = "effect_npc_laser_red_big"
SWEP.ImpactEffect = "rw_sw_impact_red"
SWEP.Sound = "w/dp23.wav"
SWEP.ClipSize = 60
SWEP.Damage = 40
SWEP.Spread = 0.05
--addons/aoc_nextbots/lua/weapons/weapon_npc_e5c.lua:
AddCSLuaFile()

SWEP.Base   = "weapon_summes_npcbase"

SWEP.PrintName = "NPC: E5-C"
SWEP.Spawnable = false
SWEP.Author = "Summe"

SWEP.WorldModel = "models/arccw/kuro/sw_battlefront/weapons/e5c_blaster.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.025
SWEP.Damage = 15
SWEP.Tracer = "effect_npc_laser_red"
SWEP.ImpactEffect = "rw_sw_impact_red"
SWEP.Sound = "everfall/weapons/e-5c/blasters_e-5c_laser_close_var_01.mp3"
SWEP.ClipSize = 20
SWEP.Spread = 0.05


--addons/aoc_nextbots/lua/weapons/weapon_npc_scatter.lua:
AddCSLuaFile()

SWEP.Base   = "weapon_summes_npcbase"

SWEP.PrintName = "NPC: Scatter"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = "models/arccw/kuro/sw_battlefront/weapons/bf1/scattergun.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 1
SWEP.Damage = 8
SWEP.Tracer = "effect_npc_laser_red"
SWEP.ImpactEffect = "rw_sw_impact_red"
SWEP.Sound = "everfall/weapons/scatter_gun/fire/blaster_scattergun_laser_close_var_01.mp3"
SWEP.ClipSize = 64
SWEP.Spread = 0.4
SWEP.Bullets = 8


--gamemodes/starwarsrp/entities/weapons/weapon_rakghoul/cl_init.lua:
include("shared.lua")

function SWEP:PrimaryAttack()
	if self:GetNextPrimaryFire() >= CurTime() then return end

	local vm = self:GetOwner():GetViewModel()
	vm:ResetSequence( vm:LookupSequence( "fists_idle_01" ) )

	anim = self.AttackAnims[ math.random( 1, 2 ) ]

	timer.Simple( 0, function()
		if ( !IsValid( self ) || !IsValid( self:GetOwner() ) || !self:GetOwner():GetActiveWeapon() || self:GetOwner():GetActiveWeapon() != self ) then return end

		vm = self:GetOwner():GetViewModel()
		vm:ResetSequence( vm:LookupSequence( anim ) )
	end )

	self:GetOwner():DoAnimationEvent(ACT_GMOD_GESTURE_RANGE_FRENZY)
end

function SWEP:SecondaryAttack()
	return
end

function SWEP:Reload()
	return
end

--addons/wos-passiveevent-ageo/lua/weapons/wos_pes_tool/cl_init.lua:
include( "shared.lua" )

SWEP.ToolNameHeight = 0
SWEP.InfoBoxHeight = 0
SWEP.WepSelectIcon = surface.GetTextureID( "vgui/gmod_tool" )
SWEP.Gradient = surface.GetTextureID( "gui/gradient" )
SWEP.InfoIcon = surface.GetTextureID( "gui/info" )


function SWEP:Reload()
    if self.Owner:KeyPressed(IN_RELOAD) then
        if (self.firstReload || 0 ) < CurTime() then
            self.firstReload = CurTime() + 1
            wOS.PES:OpenMenu()
        end
    end
end

function SWEP:PrimaryAttack()
    if not IsFirstTimePredicted() then return end
    if not wOS.PES:IsEditingVar() then return end
    local element = wOS.PES:GetEditingVar()

    local varTable = element.varTable
    local varType = wOS.PES.Vars:Get(varTable.Type)
    if varType and varType.PrimaryAttack then
        varType.PrimaryAttack(self, self.Owner, element)
    end

    return true
end

function SWEP:SecondaryAttack()
    if not IsFirstTimePredicted() then return end
    if not wOS.PES:IsEditingVar() then return end

    local element = wOS.PES:GetEditingVar()

    local varTable = element.varTable
    local varType = wOS.PES.Vars:Get(varTable.Type)
    if varType and varType.SecondaryAttack then
        varType.SecondaryAttack(self, self.Owner, element)
    end

    return true
end

function SWEP:DrawHUD()
    if not wOS.PES:IsEditingVar() then return end

    local element = wOS.PES:GetEditingVar()
    local varTable = element.varTable
    local varType = wOS.PES.Vars:Get(varTable.Type)
    if not varType then return end

    draw.SimpleText( "Editing Variable","DermaLarge", ScrW()/2, ScrH() - 100, color_white, TEXT_ALIGN_CENTER)

    if varType.DrawHUD then
        varType.DrawHUD(self, self.Owner, element)
    end

    // Yeah, I ripped this from the TOOLGUN code. Familiar is the objective   
	local mode = varTable.Type

	local x, y = 50, 40
	local w, h = 0, 0

	local TextTable = {}
	local QuadTable = {}

	QuadTable.texture = self.Gradient
	QuadTable.color = Color( 10, 10, 10, 180 )

	QuadTable.x = 0
	QuadTable.y = y - 8
	QuadTable.w = 600
	QuadTable.h = self.ToolNameHeight - ( y - 8 )
	draw.TexturedQuad( QuadTable )

	TextTable.font = "GModToolName"
	TextTable.color = Color( 240, 240, 240, 255 )
	TextTable.pos = { x, y }
	TextTable.text = varTable.Name
	w, h = draw.TextShadow( TextTable, 2 )
	y = y + h

    if varTable.Description then
        TextTable.font = "GModToolSubtitle"
        TextTable.pos = { x, y }
        TextTable.text = varTable.Description
        w, h = draw.TextShadow( TextTable, 1 )
        y = y + h + 8
    end

	self.ToolNameHeight = y

	QuadTable.y = y
	QuadTable.h = self.InfoBoxHeight
	local alpha = 255
	QuadTable.color = Color( 10, 10, 10, 230 )
	draw.TexturedQuad( QuadTable )

	y = y + 4

	TextTable.font = "GModToolHelp"

	if ( !varType.ToolTips ) then
		TextTable.pos = { x + self.InfoBoxHeight, y }
		TextTable.text = mode
		w, h = draw.TextShadow( TextTable, 1 )

		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetTexture( self.InfoIcon )
		surface.DrawTexturedRect( x + 1, y + 1, h - 3, h - 3 )

		self.InfoBoxHeight = h + 8

		return
	end

	local h2 = 0

	for k, v in ipairs( varType.ToolTips ) do
		if ( isstring( v ) ) then v = { text = v } end
		if ( !v.text ) then continue end

		TextTable.text = v.text
		TextTable.pos = { x + 21, y + h2 }

		w, h = draw.TextShadow( TextTable, 1 )

		-- if ( !v.key ) then
		-- 	if ( v.text:StartWith( "info" ) ) then v.key = "gui/info" end
		-- 	if ( v.text:StartWith( "left" ) ) then v.key = "gui/lmb.png" end
		-- 	if ( v.text:StartWith( "right" ) ) then v.key = "gui/rmb.png" end
		-- 	if ( v.text:StartWith( "reload" ) ) then v.key = "gui/r.png" end
		-- 	if ( v.text:StartWith( "use" ) ) then v.key = "gui/e.png" end
		-- 	if ( v.text:StartWith( "speed" ) ) then v.key = "icon16/control_fastforward.png" end            
		-- end
		-- if ( !v.key2 && !v.text:StartWith( "use" ) && v.text:EndsWith( "use" ) ) then v.key2 = "gui/e.png" end

		self.Icons = self.Icons or {}
		if ( v.key && !self.Icons[ v.key ] ) then self.Icons[ v.key ] = Material( v.key ) end
		if ( v.key2 && !self.Icons[ v.key2 ] ) then self.Icons[ v.key2 ] = Material( v.key2 ) end

		if ( v.key && self.Icons[ v.key ] && !self.Icons[ v.key ]:IsError() ) then
			surface.SetDrawColor( 255, 255, 255, 255 )
			surface.SetMaterial( self.Icons[ v.key ] )
			surface.DrawTexturedRect( x, y + h2, 16, 16 )
		end

		if ( v.key2 && self.Icons[ v.key2 ] && !self.Icons[ v.key2 ]:IsError() ) then
			surface.SetDrawColor( 255, 255, 255, 255 )
			surface.SetMaterial( self.Icons[ v.key2 ] )
			surface.DrawTexturedRect( x - 25, y + h2, 16, 16 )

			draw.SimpleText( "+", "default", x - 8, y + h2 + 2, color_white )
		end

		h2 = h2 + h

	end

	self.InfoBoxHeight = h2 + 8

end


local matScreen = Material( "models/weapons/v_toolgun/screen" )
local txBackground = surface.GetTextureID( "models/weapons/v_toolgun/screen_bg" )
local TEX_SIZE = 256

-- GetRenderTarget returns the texture if it exists, or creates it if it doesn't
local RTTexture = GetRenderTarget( "GModToolgunScreen", TEX_SIZE, TEX_SIZE )

surface.CreateFont( "GModToolScreen", {
	font	= "Helvetica",
	size	= 60,
	weight	= 900
} )

local function DrawScrollingText( text, y, texwide )

	local w, h = surface.GetTextSize( text )
	w = w + 64

	y = y - h / 2 -- Center text to y position

	local x = RealTime() * 250 % w * -1

	while ( x < texwide ) do

		surface.SetTextColor( 0, 0, 0, 255 )
		surface.SetTextPos( x + 3, y + 3 )
		surface.DrawText( text )

		surface.SetTextColor( 255, 255, 255, 255 )
		surface.SetTextPos( x, y )
		surface.DrawText( text )

		x = x + w

	end

end

--[[---------------------------------------------------------
	We use this opportunity to draw to the toolmode
		screen's rendertarget texture.
-----------------------------------------------------------]]
function SWEP:RenderScreen()

    if not wOS.PES:IsEditingVar() then return end

    local element = wOS.PES:GetEditingVar()
    local varTable = element.varTable
    local varType = wOS.PES.Vars:Get(varTable.Type)
    if not varType then return end

	-- Set the material of the screen to our render target
	matScreen:SetTexture( "$basetexture", RTTexture )

	-- Set up our view for drawing to the texture
	render.PushRenderTarget( RTTexture )
	cam.Start2D()
 
		-- Background
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetTexture( txBackground )
		surface.DrawTexturedRect( 0, 0, TEX_SIZE, TEX_SIZE )

		-- -- Give our toolmode the opportunity to override the drawing
		-- if ( self:GetToolObject() && self:GetToolObject().DrawToolScreen ) then

		-- 	self:GetToolObject():DrawToolScreen( TEX_SIZE, TEX_SIZE )

		-- else

			surface.SetFont( "GModToolScreen" )
			DrawScrollingText( varTable.Name, 104, TEX_SIZE )

		-- end

	cam.End2D()
	render.PopRenderTarget()

end

function SWEP:Deploy()
    local cur_pan = wOS.PES:GetActiveMenu()
    if !IsValid(cur_pan) then return end
    if !cur_pan.menu then return end
    if not cur_pan.menu.CreationType then return end 
    if cur_pan.menu.CreationType == WOS_PES.CREATOR.EVENT then return end
    cur_pan:Remove()
end
--gamemodes/starwarsrp/entities/entities/aoc_eventspawn.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Eventspawn"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP - Spawns"
ENT.Spawnable       = true


if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/hunter/plates/plate1x1.mdl" )
        self:DrawShadow( false )
        self:SetColor(Color(255,0,0))
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

end
-- test

if CLIENT then

    function ENT:Draw()
        if LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP then
            self:DrawModel() 
        end
    end

end
--gamemodes/starwarsrp/entities/entities/aoc_waffendrop.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Sonderwaffenbox"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true
ENT.Editable = true

function ENT:SetupDataTables()

    self:NetworkVar( "String", 0, "WaffenKlasse", { KeyName = "WaffenKlasse",	Edit = { type = "Text"  } } ) 


    if SERVER then
        self:SetWaffenKlasse("weapon_crowbar")
    end

end


if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/reizer_props/srsp/sci_fi/crate_04/crate_04.mdl" )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )


            local phys = self:GetPhysicsObject()
        if (phys:IsValid()) then
            phys:Wake()
        end
    end
    
    function ENT:Use( activator, caller )
       
        if activator:HasWeapon(self:GetWaffenKlasse()) then 
            activator:StripWeapon(self:GetWaffenKlasse())
        else 
            activator:Give(self:GetWaffenKlasse())
            activator:SelectWeapon(self:GetWaffenKlasse())
        end
    end


end



if CLIENT then

    function ENT:Draw()
        self.BaseClass.Draw(self)  -- We want to override rendering, so don't call baseclass.
                                    -- Use this when you need to add to the rendering.
        --self:DrawEntityOutline( 1.0 ) -- Draw an outline of 1 world unit.
        --self:DrawModel()       -- Draw the model.


    end

end
--addons/aoc_nextbots/lua/entities/aocrp_nextbot_bx.lua:
AddCSLuaFile()

ENT.Base = "summe_nextbot"
ENT.PrintName = "BX Kommandodroide"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.Model = "models/npc/bx100_commando_droid/regular/bx100_commando_droid_regular.mdl"
ENT.Weapon = "weapon_npc_e5bx"
ENT.HP = 600
ENT.ShootingRange = 2000
ENT.LooseRadius = 4000
ENT.Proficiency = .05

ENT.Melee = true
ENT.MeleeDamage = 25
ENT.MeleeDelay = 3

ENT.ThrowGrenades = true
ENT.Grenades = {"summe_gr_impact"}

ENT.Sounds = {
    ["attacking"] = {
        "aoc/nextbot/bx/attack/ausradieren.wav",
        "aoc/nextbot/bx/attack/ich-gehe-voraus.wav",
        "aoc/nextbot/bx/attack/toetet-die-klone.wav"
    },

    ["kill"] = {
        "aoc/nextbot/bx/attack/problem-geloest.wav"
    }
}

ENT.Anims = {
    ["idle"] = {"smg1idle1"},
    ["shoot"] = {"Smg1angryidle1"},
    ["reload"] = {"reload_smg1"},
    ["walk_slow"] = {"walk_hold_smg1"},
    ["walk_fast"] = {"run_all"},
    ["melee"] = {"meleeattack01"},
}

function ENT:OnNPCSpawn()
    self:PlayAnimation("idle")
end
--addons/arccw_base_modified/lua/entities/arccw_ammo_smg1.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Carbine Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/smg_ammo.mdl"

ENT.AmmoType = "smg1"
ENT.AmmoCount = 60
if engine.ActiveGamemode() == "terrortown" then
    ENT.AmmoCount = 30
end

ENT.DetonationDamage = 30
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/smg1/npc_smg1_fire1.wav"
--lua/entities/arccw_uc_40mm_dp.lua:
AddCSLuaFile()

ENT.Base = "arccw_uc_40mm_he"
ENT.PrintName = "40mm HE Dual Purpose Grenade"

ENT.GrenadeDamage = false
ENT.GrenadeRadius = 300
ENT.ExplosionEffect = false
ENT.Scorch = false

function ENT:DoDetonation()
    local dir = self.GrenadeDir or self:GetVelocity():GetNormalized()
    local attacker = IsValid(self:GetOwner()) and self:GetOwner() or self
    local damage = self.GrenadeDamage or self.Damage or 0
    local blastpos = self:GetPos()
    local tr = util.TraceLine({
        start = self:GetPos(),
        endpos = self:GetPos() + dir * 64,
        filter = self
    })
    if IsValid(tr.Entity) then
        -- do impact damage
        local dmg = DamageInfo()
        dmg:SetAttacker(attacker)
        dmg:SetInflictor(self)
        dmg:SetDamage(damage * 10)
        dmg:SetDamageForce(dir * 3000)
        dmg:SetDamagePosition(tr.HitPos)
        tr.Entity:TakeDamageInfo(dmg)
    end
    -- attempt to penetrate entity/world and place explosion behind
    local tr2 = util.TraceLine({
        start = tr.HitPos + dir * 69,
        endpos = tr.HitPos,
        filter = self,
    })

    if tr2.Hit and !tr2.StartSolid then
        -- Produce a weaker blast on the pre-penetration side
        util.BlastDamage(self, attacker, blastpos, self.GrenadeRadius, damage * 0.5)

        blastpos = tr2.HitPos + dir * 16
        self:EmitSound("physics/concrete/concrete_break2.wav", 100, 110)
        local effectdata = EffectData()
        effectdata:SetOrigin(self:GetPos())
        effectdata:SetMagnitude(2)
        effectdata:SetScale(1)
        effectdata:SetRadius(2)
        effectdata:SetNormal(-dir)
        util.Effect("Sparks", effectdata)
        effectdata:SetOrigin(blastpos)
        effectdata:SetNormal(dir)
        util.Effect("Sparks", effectdata)
    end

    local effectdata = EffectData()
    effectdata:SetOrigin(blastpos)

    if self:WaterLevel() >= 1 then
        util.Effect("WaterSurfaceExplosion", effectdata)
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        self:EmitSound(self.ExplosionSounds[math.random(1,#self.ExplosionSounds)], 125, 100, 1, CHAN_AUTO)
        ParticleEffect("explosion_grenade_fas2", self:GetPos(), tr.HitNormal:Angle())
        if tr2.Hit and !tr2.StartSolid then
            ParticleEffect("explosion_he_m79_fas2", tr2.StartPos, tr.HitNormal:Angle() * -1)
        end
        if self.DebrisSounds then
            self:EmitSound(self.DebrisSounds[math.random(1,#self.DebrisSounds)], 85, 100, 1, CHAN_AUTO)
        end
    end

    util.ScreenShake(self:GetPos(),25,4,.75,self.GrenadeRadius * 4)
    util.BlastDamage(self, attacker, blastpos, self.GrenadeRadius, damage)
end
--addons/weapons_other/lua/entities/fly_base.lua:
AddCSLuaFile()

--[[
	An entity base that allows you to create entity that can be equipped by the player as if they were weapons or powerups, but that can still
	function when not picked up by a player

	For instance you could make a jetpack that flies off when the equipping player dies, or you can make a controllable plane but still allow
	full movement on the player

	This file is licensed under the MIT license, so go nuts.
]]

DEFINE_BASECLASS( "base_entity" )

ENT.UseNWVars = false

ENT.Spawnable = false
ENT.IsPredictedEnt = true
ENT.AttachesToPlayer = true	--whether this entity attaches to the player or not, when true this removes physics and draws the entity on the player

ENT.SaveButtonToCvar = false

if SERVER then
	ENT.DropOnDeath = false
	ENT.ShowPickupNotice = true	--plays the pickup sound and shows the pickup message on the hud
	ENT.DontTransmitToOthers = false --when true, don't transmit to anyone except the owner, this MIGHT conflict with addons that make use of SetPreventTransmit, so mind that!
	ENT.ShouldLagCompensate = true 	--automatically enables/disables lag compensation when physics are created and destroyed, might be annoying for some so disable this if you want
else
	ENT.RenderGroup = RENDERGROUP_OPAQUE
end

ENT.Editable = false

ENT.KeyAllowedKeyboard = 2 ^ 0
ENT.KeyAllowedMouse = 2 ^ 1
ENT.KeyAllowedJoystick = 2 ^ 2

ENT.KeyAllowedAll = bit.bor( ENT.KeyAllowedKeyboard , ENT.KeyAllowedMouse , ENT.KeyAllowedJoystick )

ENT.KeyAllowedFlags = ENT.KeyAllowedAll	--bitflag of the key types you want to use

ENT.HookAlways = 1 --hooks in here always run
ENT.HookEquipped = 2 --hooks in here are only added when the entity is equipped by user, and removed when unequipped
ENT.HookEquippedPrediction = 3 --like above, but on the client, only for the LocalPlayer() equipping this
ENT.HookCallback = 4 --these are callbacks handled with AddCallback, unfortunately we have no way to fully handle these

--example attachment info table, only used if AttachesToPlayer is true
--[[
ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( -90 , -5.6 , 0 ),
	OffsetAng = Angle( 180 , 90 , -90 ),
}
]]

--[[
	This is a wrapper for NetworkVars/DTVars (same thing) so we can handle their slots properly for child classes instead
	of having to modify them manually everytime something changes in order

	This could be switched to NWVars2 (vinh vars) but then I would have to hack in support for right-click editing, since that's
	based on NetworkVars and some other getters
]]
function ENT:DefineNWVar( dttype , dtname , editable , beautifulname , minval , maxval , customelement , filt )

	if not self.DefinedDTVars[dttype] then
		Error( "Wrong NWVar type " .. ( dttype or "nil" ) )
		return
	end

	local index = -1

	--only do this check for limited dtvars, once we switch to NWVars in :NetworkVar this check will go away
	if not self.UseNWVars then
		local maxindex = self.DefinedDTVars[dttype].Max

		for i = 0 , maxindex - 1 do
			--we either didn't find anything in this slot or we found the requested one again
			--in which case just override it again, someone might want to inherit and add an edit table or something
			if not self.DefinedDTVars[dttype][i] or self.DefinedDTVars[dttype][i] == dtname then
				index = i
				break
			end
		end

		if index == -1 then
			Error( "Not enough slots on "..dttype .. ",	could not add ".. dtname )
			return
		end
	else
		index = dtname:lower()
	end

	self.DefinedDTVars[dttype][index] = dtname

	local edit = nil

	--this used to check if we could actually add the edit table, so we default it to nil to override it again
	--in case of a child class

	if editable then
		edit = {
			KeyName = dtname:lower(),
			Edit = {
				title = beautifulname or dtname,	--doesn't it do this internally already?
				min = minval,
				max = maxval,
				type = customelement or self.DefinedDTVars[dttype].EditableElement,
			}
		}
	end

	self:NetworkVar( dttype , index , dtname , edit )
end

function ENT:SetupDataTables()

	--if the user is in the branch that has the NWVars change then automatically switch to this
	if self.CallNetworkProxies then
		self.UseNWVars = true
	end

	--eventually I'll create more editable elements based on garry's system

	self.DefinedDTVars = {
		Entity = {
			Max = GMOD_MAXDTVARS,
		},
		Float = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Float",
		},
		Int = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Int",
		},
		Bool = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Boolean",
		},
		Vector = {
			Max = GMOD_MAXDTVARS,
		},
		Angle = {
			Max = GMOD_MAXDTVARS,
		},
		String = {
			Max = 4,
			EditableElement = "Generic",
		},
	}

	self:DefineNWVar( "Entity" , "ControllingPlayer" )
	self:DefineNWVar( "Bool" , "BeingHeld" )
	self:DefineNWVar( "String" , "SlotName" )
	self:DefineNWVar( "Float" , "NextFire" ) --similar to primaryattack on a weapon

	--only allow the user to modify the button if the coder wants this entity to have an usable key

	self:DefineNWVar( "Int" , "Key" , true , "Button" , BUTTON_CODE_NONE + 1 , BUTTON_CODE_LAST , "EditKey" )
	self:DefineNWVar( "Bool" , "KeyPressed" )
end

function ENT:Initialize()

	self.HandledHooks = {
		[self.HookAlways] = {},
		[self.HookEquipped] = {},
		[self.HookEquippedPrediction] = {},
		[self.HookCallback] = {}
	}

	self.HookConditions = {
		[self.HookAlways] = function( ent )
			return true
		end,
		[self.HookEquipped] = function( ent )
			return ent:IsCarried()
		end,
		[self.HookEquippedPrediction] = function( ent )
			if SERVER then
				return ent:IsCarried() --self.HookConditions[self.HookEquipped]( self )
			else
				return ent:IsCarriedByLocalPlayer()
			end
		end,
		[self.HookCallback] = function( self )
			return nil --nil means don't handle me
		end,
	}

	--predicted hooks hooking with hookers and futurama memes
	self:InstallHook( "StartCommand" , self.HandlePredictedStartCommand , self.HookEquippedPrediction )
	self:InstallHook( "SetupMove" , self.HandlePredictedSetupMove , self.HookEquippedPrediction )
	self:InstallHook( "Move" , self.HandlePredictedMove , self.HookEquippedPrediction )
	self:InstallHook( "PlayerTick" , self.HandlePredictedThink , self.HookEquippedPrediction )
	self:InstallHook( "FinishMove" , self.HandlePredictedFinishMove , self.HookEquippedPrediction )
	self:InstallHook( "OnPlayerHitGround" , self.HandlePredictedHitGround , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonDown" , self.HandlePlayerButtonDown , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonUp" , self.HandlePlayerButtonUp , self.HookEquippedPrediction )


	self:InstallHook( "CalcMainActivity" , self.HandleCalcMainActivity , self.HookEquipped )
	self:InstallHook( "UpdateAnimation" , self.HandleUpdateAnimation , self.HookEquipped )
	self:InstallHook( "DoAnimationEvent" , self.HandleAnimationEvent , self.HookEquipped )


	if SERVER then
		self:InstallHook( "SetupPlayerVisibility" , self.HandleEntityVisibility , self.HookAlways )
		self:InstallHook( "EntityRemoved" , self.OnControllerRemoved , self.HookAlways )
		self:InstallHook( "PostPlayerDeath" , self.OnControllerDeath , self.HookAlways )	--using PostPlayerDeath as it's called on all kind of player deaths, even :KillSilent()
		self:InstallHook( "CanEditVariable" , self.HandleCanEditVariable , self.HookAlways )

		--just in case it has been spawned manually and the coder forgot
		if self:GetSlotName() == "" then
			ErrorNoHalt( self:GetClass() .. " was spawned without a slotname!!!!. Defaulting to classname\n" )
			self:SetSlotName( self:GetClass() )
		end

		self:SetUseType( SIMPLE_USE )
		self:SetKey( BUTTON_CODE_NONE )
	else
		self:InstallHook( "PreDrawEffects" , self.DrawFirstPersonInternal , self.HookEquipped )
		self:InstallHook( "PostDrawViewModel" , self.DrawViewModelInternal , self.HookEquipped )
		self:InstallHook( "PostPlayerDraw" , self.DrawOnPlayer , self.HookEquipped )

		self:InstallHook( "NotifyShouldTransmit" , self.HandleFullPacketUpdate , self.HookAlways )

		language.Add( self:GetClass() , self.PrintName )
		language.Add( "dropped_"..self:GetClass() , "Dropped "..self.PrintName )
	end
end

--This is needed mostly for clientside hooks, since IsValid might return false when we're out of PVS with some bad lag
--and when hook.Call tries to call on an invalid entity it removes the hook, so we need to reinstall them when that happens and the entity gets back in the PVS
--prediction and other shit like drawing on a player might fuck up since the hooks got removed
--Now this also works for adding a callback

function ENT:InstallHook( hookname , handler , hooktype )

	if self.HandledHooks[hooktype] == nil then
		hooktype = self.HookAlways
	end

	self.HandledHooks[hooktype][hookname] = handler

	if hooktype == self.HookCallback then
		self:AddCallback( hookname , handler )
	end

end

function ENT:HandleHooks( cleanup )

	--this is direct access to the hook table, but it's not slow at all
	--or at least, it shouldn't be as long as you don't have any ulib shit or some other hook overrides
	local hooktable = hook.GetTable()



	for hookindex , handledshooktab in pairs( self.HandledHooks ) do
		local condition = self.HookConditions[hookindex]( self )

		if condition ~= nil then
			for i , v in pairs( handledshooktab ) do
				if condition and not cleanup then
					if not hooktable[i] or not hooktable[i][self] then
						hook.Add( i , self , v )
					end
				else
					if hooktable[i] and hooktable[i][self] then
						hook.Remove( i , self )
					end
				end
			end
		end
	end

end

function ENT:Think()

	self:HandleHooks()

	if SERVER then

		--check if this guy is still my parent and owner, maybe something is forcibly unparenting us from him, if so, drop
		if self.AttachesToPlayer and self:IsCarried() then
			if not self:IsAttached() then
				self:Remove( true )
			end
		end

		--we have to network this ourselves since it's based on the physics object ( which is mainly serverside )
		--the reason I'm networking this is that due to the gravity gun enabling prediction, it would screw with the manual
		--predictable logic of this entity, so when we try to activate prediction, we check if we're being carried by the gravity gun
		--to prevent disabling it

		--NOTE: this is not as expensive as it looks, it just checks for the FVPHYSICS_PLAYER_HELD flag on our physobj
		self:SetBeingHeld( self:IsPlayerHolding() )
	else
		--calling this in a non-predicted hook is perfectly fine, since we need the entity to enable prediction on its own
		--even when controlling players change

		--Ideally this would be handled on the callback of SetControllingPlayer clientside, but we don't have that yet
		self:HandlePrediction()
		self:HandleButtonBind()
		self:HandleContextMenuButton()
		self:InternalHandleLoopingSounds()
	end

	--set our think rate to be in line with the server tickrate
	--this may also affect animations clientside if they're ran in this hook, considering that also happens in normal source
	--I'd say that's an accurate replication of the issue

	--default behaviour for scripted entities is to think every 200 milliseconds
	--I suppose this should be configurable by child entities

	self:NextThink( CurTime() + engine.TickInterval() )
	return true
end

if SERVER then

	--for map inputs mostly, but other addons may also be using these inputs trough ent:Input or ent:Fire
	--more inputs might come in the future
	--of course child entities are free to call the baseclass function after their own to chain stuff

	function ENT:AcceptInput( inputName, activator, called, data )

		if inputName == "Drop" then
			self:Drop( true )
			return true
		end

		if inputName == "SetSlotName" then
			if self:IsCarried() or not data or #data <= 1 or data == self:GetSlotName() then
				return false
			end

			self:SetSlotName( data )
			return true
		end

	end

	--although we should probably do validity checks on them first, but considering this would *probably* be called from maps it should be ok
	--copied from env_skypaint, allows to have the DT vars set as if they were key values

	function ENT:KeyValue( key, value )

		if self:SetNetworkKeyValue( key, value ) then
			return
		end

	end

	function ENT:ChangeSlot( newslotname )
		local oldslotname = self:GetSlotName()

		if newslotname == oldslotname then
			return false
		end

		local ply = self:GetControllingPlayer()

		--if we have a controlling player and he has an entity in the new slot, abort
		if IsValid( ply ) and IsValid( self.GetOnPlayer( ply , newslotname ) ) then
			--this slot is already occupied!!!
			return false
		end

		if IsValid( ply ) then
			self.SetOnPlayer( ply , oldslotname , NULL )
			self.SetOnPlayer( ply , newslotname , self )
		end

		self:SetSlotName( newslotname )

		return true
	end

	--useful for swapping out two slots at the same time and knowing the other entity,
	--usually in an inventory system
	function ENT:SwapSlotWith( predent )
		local ply = self:GetControllingPlayer()

		if not self:IsCarriedBy( ply ) or not IsValid( predent ) or not predent.IsPredictedEnt
		or not predent:IsCarriedBy( ply ) then
			return false
		end

		local myslot = self:GetSlotName()
		local otherslot = predent:GetSlotName()

		self.SetOnPlayer( ply , otherslot , self )
		self.SetOnPlayer( ply , myslot , predent )

		self:SetSlotName( otherslot )
		predent:SetSlotName( myslot )

		return true
	end

	--override this if you want your equip logic to be different
	function ENT:Use( activator, caller, useType, value )
		if not self:Attach( activator ) then
			self:EmitPESound( "HL2Player.UseDeny" , 150 , nil , 1 , nil , nil , activator )
		end
	end

	function ENT:InitPhysics()
		--don't actually initialize the physics if we're getting removed anyway
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end


		if self.ShouldLagCompensate then
			self:SetLagCompensated( true )
		end

		self:DoInitPhysics()
		self:OnInitPhysics( self:GetPhysicsObject() )
	end

	function ENT:DoInitPhysics()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysWake()
	end

	function ENT:RemovePhysics()

		if self.AttachesToPlayer and self.ShouldLagCompensate then
			self:SetLagCompensated( false )	--entities that are attached to players will be moved back when the player is, so don't make them lag compensate on their own
		end

		self:OnRemovePhysics( self:GetPhysicsObject() )
		self:DoRemovePhysics()
	end

	function ENT:DoRemovePhysics()
		self:PhysicsDestroy()
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
	end

	function ENT:OnAttach( ply , forced )
		--override me
	end

	function ENT:CanAttach( ply )
		--override me
	end

	function ENT:OnDrop( ply , forced )
		--override me
	end

	function ENT:CanDrop( ply )
		--override me
	end

	--these two are not necessarely duplicates of the functions above because we may want to modify the mass
	--as soon as the physobj gets created, and that also happens in initialize

	function ENT:OnInitPhysics( physobj )
		--override me
	end

	function ENT:OnRemovePhysics( physobj )
		--override me
	end

	--being attached forcibly is usually something that happens when you want to spawn the player with this item, and you
	--don't want gamemode logic to interfere with it
	function ENT:Attach( activator , forced )

		--we were forced to attach to this player, so drop first to clear out some values
		if forced then
			self:Remove( forced )
		end

		if not IsValid( activator ) or not activator:IsPlayer() then
			return false
		end

		--we're carried in general OR that guy's using that slot already
		if self:IsCarried() or IsValid( self.GetOnPlayer( activator , self:GetSlotName() ) ) then
			return false
		end

		--we can allow the coder or gamemode to only stop the pickup if it's not forced
		if not forced then
			--simulate ourselves being a normal item pickup
			--the reason we're asking this first, is that first we want to make sure the gamemode is OK with us being able to pickup this entity
			local canattach = hook.Run( "PlayerCanPickupItem" , activator , self )

			--THEN we ask the coder if he really wants us to pickup his entity, in case it's out of "ammo", or some other restrictions
			local mycanattach = self:CanAttach( activator )
			if mycanattach == false then
				canattach = mycanattach
			end

			if canattach == false then
				return canattach
			end
		end

		if self.AttachesToPlayer then
			self:RemovePhysics()
			self:SetParent( activator )
			self:SetOwner( activator )
			self:SetTransmitWithParent( true )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck of the transmission, so UpdateTransmitState() is called right away
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( true )
			end
			]]

			self:SetNoDraw( true )
			self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		self:SendItemMessage( activator , false )

		self.SetOnPlayer( activator , self:GetSlotName() , self )
		self:SetControllingPlayer( activator )

		--if the player has a customized key for this entity, use that instead
		--we do this here so that OnAttach can make use of it

		--this also allows us to prevent the key from another user to be written clientside and override ours
		if self.SaveButtonToCvar then
			local plykey = self:GetControllingPlayerConVarKey()

			if self:IsKeyAllowed( plykey ) and plykey ~= self:GetKey() then
				self:SetKey( plykey )
			end
		end

		--THIS IS VERY SUBJECTIVE
		self:SetKeyPressed( false ) --only reset the button press state when equipped

		self:OnAttach( activator , forced )
		return true
	end

	function ENT:Drop( forced )

		--we can allow the coder to only stop the drop if it's not forced
		if not forced then
			local candrop = self:CanDrop( self:GetControllingPlayer() )

			if candrop == false then
				return candrop
			end
		end

		if self.AttachesToPlayer then
			self:SetParent( NULL )
			self:SetOwner( NULL )
			self:InitPhysics()
			self:SetTransmitWithParent( false )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck during a drop
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( false )
			end
			]]

			self:SetNoDraw( false )
			self:RemoveEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		if not forced and self:IsCarried() then
			self:SendItemMessage( self:GetControllingPlayer() , true )
		end

		--only call OnDrop if we had a player controlling us, don't do it if we were just sweeping up some unclean values
		if self:IsCarried() then
			self:OnDrop( self:GetControllingPlayer() , forced )
			self.SetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() , NULL )
		end

		self:SetControllingPlayer( NULL )
		return true
	end

	function ENT:SendItemMessage( activator , dropped )
		if dropped == nil then
			dropped = false
		end
		--GetShouldPlayPickupSound is actually a Lua table value that is then checked in c++, so it starts out as nil, wow garry
		if self.ShowPickupNotice and ( self:GetShouldPlayPickupSound() == nil or self:GetShouldPlayPickupSound() ) then

			if not dropped then
				self:EmitSound( "HL2Player.PickupWeapon" )
			else
				self:EmitSound( "Weapon_Crowbar.Single" )
			end

			if not activator:IsPlayer() or not activator:IsBot() then
				net.Start( "pe_pickup" )
					net.WriteString( self:GetClass() )
					net.WriteBit( dropped )
				net.Send( activator )
			end
		end
	end

	--we want to get properly dropped when the player entity gets removed ( aka after a disconnect )
	--why not use the disconnect hook? no.

	function ENT:OnControllerRemoved( ent )
		if self:IsCarriedBy( ent ) then
			self:Remove( true )
		end
	end

	function ENT:OnControllerDeath( ply )
		if self.DropOnDeath and self:IsCarriedBy( ply ) then
			self:Remove( true )
		end
	end

	--we're redoing this even though it's hooked up in sandbox because someone might want to use this in another gamemode ( such as ttt or whatever )
	function ENT:HandleCanEditVariable( ent , ply , key , val , editor )
		if ent == self then
			local allow = self:CanPlayerEditVariable( ply , key , val , editor )

			if key == "Key" then
				local btn = tonumber( val )
				if btn and not self:IsKeyAllowed( btn ) then
					allow = false
				end
			end

			--call the editkey hook only if the other one didn't say anything in the matter for this
			if key == "Key" and allow == nil then
				allow = self:CanEditKey( ply , val , editor )
			end

			--we'll only override all the hooks if the answer is yes or no, nil keeps the default behaviour
			if allow ~= nil then
				return allow
			end
		end
	end

	--our key can only be modified by the carrying player or by anyone if it's not carried at all
	function ENT:CanEditKey( ply , val , editor )
		--you could override me if you want to, you could leave your friends behind
		return self:IsCarriedBy( ply ) or not self:IsCarried()
	end

	function ENT:CanPlayerEditVariable( ply , key , val , editor )
		--override me
	end

	--we add this entity's position to the visibility position, but only if it doesn't attach to the player
	function ENT:HandleEntityVisibility( ply , viewent )
		if self:IsCarriedBy( ply ) and not self.AttachesToPlayer and self ~= viewent then --viewents already add themselves to the pvs
			AddOriginToPVS( self:GetPos() )
		end

		--HOW CONVENIENT!!! this hook is called before the client computes what he can see
		--so we can simply use this before this entity gets recomputed for transmission

		--TODO: This will be removed and the ENT:UpdateTransmitState() below will be enabled once Willox is done with TRANSMIT_OWNERONLY
		if self.DontTransmitToOthers and not game.SinglePlayer() then

			local shouldpreventtransmit = false

			if self:IsCarried() then
				shouldpreventtransmit = not self:IsCarriedBy( ply , true )
			end

			self:SetPreventTransmit( ply , shouldpreventtransmit )
		end
	end

	--[[
	function ENT:UpdateTransmitState()


		if self.DontTransmitToOthers and self:IsCarried() then
			return TRANSMIT_OWNERONLY
		end


		--don't return anything, default behaviour
	end
	]]

else

	function ENT:GetConVar()

		--the slotname changed, so we forget this cvar to let another one with the same slot use it
		--and we let the code below create/get one with our slotname
		if self.ConfigurableConVar and self.ConfigurableConVar:GetName() ~= self:GetConVarName() then
			self.ConfigurableConVar = nil
		end

		if not self.ConfigurableConVar then
			--internally this returns the original convar if it was already created, so it's not that big of a deal, this could be done in a better way however
			self.ConfigurableConVar = CreateConVar( self:GetConVarName() , self:GetKey() , FCVAR_ARCHIVE + FCVAR_USERINFO , "Configures the key for "..self:GetSlotName().. " , created by "..self:GetClass() )
		end

		return self.ConfigurableConVar
	end

	function ENT:InternalHandleLoopingSounds( calledinprediction )
		--the calledinprediction variable makes it so HandleLoopingSounds is called from ENT:Think instead
		--and yes, this will never be set at all during singleplayer because there's no prediction

		--if this is set then there's no need to call iscarried checks below, we're always called when that happens
		if calledinprediction and not IsFirstTimePredicted() then
			return
		end

		if game.SinglePlayer() or not self:IsCarried() or not self:IsCarriedByLocalPlayer() or ( self:IsCarriedByLocalPlayer() and calledinprediction ) then
			self:HandleLoopingSounds()
		end
	end

	function ENT:HandleLoopingSounds()
		--override me
	end

	function ENT:IsCarriedByLocalPlayer( checkspectator )
		return self:IsCarriedBy( LocalPlayer() , checkspectator )
	end

	function ENT:ShouldDrawLocalPlayer( checkspectator )
		if checkspectator then
			if LocalPlayer():GetObserverMode() == OBS_MODE_IN_EYE and IsValid( LocalPlayer():GetObserverTarget() ) then
				if LocalPlayer():GetObserverTarget():IsPlayer() then
					return LocalPlayer():GetObserverTarget():ShouldDrawLocalPlayer() --assuming this even works, otherwise just return false
				end
				return false
			end
		end
		return LocalPlayer():ShouldDrawLocalPlayer()
	end

	--immediately make this entity predicted again, if it's equipped by this localplayer
	function ENT:HandleFullPacketUpdate( ent , shouldtransmit )
		if ent == self and shouldtransmit then
			self:HandlePrediction()
		end
	end

	function ENT:HandlePrediction()

		local carried = self:IsCarriedByLocalPlayer()

		--either the gravity gun or some other stuff is carrying me, don't do anything on prediction
		--because they might enable it to carry us around smoothly
		--also don't enable prediction in singleplayer

		if self:GetBeingHeld() or game.SinglePlayer() then
			return
		end

		if self:GetPredictable() ~= carried then
			self:SetPredictable( carried )
		end
	end

	function ENT:HandleButtonBind()
		--did not disable the function call from Think as someone might want to override this

		if self.SaveButtonToCvar then
			--this is a one way server to client saving, the reason I do this is because the user should usually change the value from
			--client to server with the edit system, it still goes to the server, but not to the cvar first, so we save it from the client to the cvar

			--basically we just use the cvar as a way to save the button, but it does come at the cost of not being able to update the cvar and have it update on the
			--entity, this will probably change in the future
			local mykey = self:GetKey()

			--can't use GetControllingPlayerConVarKey as I also need to SetInt on it
			local cv = self:GetConVar()

			if cv then
				if ( mykey ~= cv:GetInt() and self:IsKeyAllowed( mykey ) ) --[[or not self:IsKeyAllowed( cv:GetInt() )]] then
					cv:SetInt( mykey )
				end
			end
		end
	end



	function ENT:CreateContextMenuButton( iconlayout )
		local button = iconlayout:Add( "DPredEnt" )
		button:SetSize( 80 , 80 )
		button:SetClassName( self.PrintName , self:GetSlotName() )
		button:SetMaterial( self.Folder .. ".png" )
		button:SetPredEnt( self )
		--SetClassName
	end

	function ENT:GetContextMenuButton( iconlayout )
		local contextbutton = nil

		for i = 0 , iconlayout:ChildCount() do

			local child = iconlayout:GetChild( i )

			if IsValid( child ) and child:GetName() == "DPredEnt" and child:GetSpawnName() == self:GetSlotName() and child:GetPredEnt() == self then
				contextbutton = child
				break
			end

		end

		return contextbutton
	end

	--forcefully removes it in case it fucks up
	function ENT:RemoveContextMenuButton( iconlayout , buttonpanel )
		if IsValid( buttonpanel ) then
			buttonpanel:Remove()
		end
	end

	function ENT:GetContextMenuLayout()
		if not IsValid( g_ContextMenu ) then
			return
		end

		local iconlayout = nil

		for i = 0 , g_ContextMenu:ChildCount() do

			local child = g_ContextMenu:GetChild( i )

			if IsValid( child ) and child:GetName() == "DIconLayout" then
				iconlayout = child
				break
			end

		end

		return iconlayout
	end

	function ENT:HandleContextMenuButton( docleanup )

		local iconlayout = self:GetContextMenuLayout()

		if not IsValid( iconlayout ) then
			return
		end

		local buttonpanel = self:GetContextMenuButton( iconlayout )

		if IsValid( buttonpanel ) and ( not self:IsCarriedByLocalPlayer() or docleanup )then
			self:RemoveContextMenuButton( iconlayout , buttonpanel )
			iconlayout:InvalidateLayout()
		end

		if not IsValid( buttonpanel ) and self:IsCarriedByLocalPlayer() then
			self:CreateContextMenuButton( iconlayout )
			iconlayout:InvalidateLayout()
		end

	end



	function ENT:DrawFirstPersonInternal()
		if self.AttachesToPlayer and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
			local fov = nil	--TODO: allow changing the FOV
			cam.Start3D( nil , nil , fov , nil , nil , nil , nil , 1 , -1 )	--znear is 1 and zfar is -1
				render.DepthRange( 0 , 0.1 )	--same depth hack valve uses in source!
					self:DrawFirstPerson( self:GetControllingPlayer() )
				render.DepthRange( 0 , 1 )		--they don't even set these back to the original values
			cam.End3D()
		end
	end

	--viewmodels don't draw without an associated weapon ( this is due to garryness, they always do in source )
	function ENT:DrawViewModelInternal( vm , ply , wpn )
		if self.AttachesToPlayer and self:IsCarriedBy( ply , true ) then
			self:DrawOnViewModel( ply , vm , ply:GetHands() ) --this will stay here
		end
	end

	function ENT:DrawFirstPerson( ply )
		--override me
	end

	--mainly used to draw stuff like shields, gloves or whatever on the viewmodel hands

	function ENT:DrawOnViewModel( ply , vm , hands )
		--override me
	end

	--the flags aren't passed yet, maybe in a future update

	function ENT:DrawOnPlayer( ply , flags )
		self:DrawModel( flags )

	end

	function ENT:Draw( flags )
		local pos , ang = self:GetCustomParentOrigin()
		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )
	end

end

--these are here to "unify" our two calls to SetNWEntity and GetNWEntity
--these might be called from pe_drop and some other stuff, so we can't rely on the entity itself being present, as lame as that is
--the alternative would be to have these as global, which would be lamer
function ENT.SetOnPlayer( ply , slot , ent )
	ply:SetNW2Entity( slot , ent )
end

function ENT.GetOnPlayer( ply , slot )
	return ply:GetNW2Entity( slot )
end

function ENT:IsAttached()
	local ply = self:GetControllingPlayer()
	return self:GetOwner() == ply and self:GetParent() == ply
end

--LOOK I DON'T CARE, this check is lame as shit but I can't be arsed to add duplicated code
function ENT:IsCarried()
	return self:IsCarriedBy( self:GetControllingPlayer() )
end

function ENT:IsCarriedBy( ply , checkspectator )

	if checkspectator and ply:GetObserverMode() ~= OBS_MODE_NONE then
		return self:IsCarriedBy( ply:GetObserverTarget() )
	end

	return IsValid( ply ) and ply == self:GetControllingPlayer() and self.GetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() ) == self
end

function ENT:IsKeyDown()
	return self:GetKeyPressed()
end

--these functions should totally not be tied to this SENT, but I don't want to go out of my way to add them to an util file
function ENT:IsValidButton( btn )
	return btn > BUTTON_CODE_NONE and btn < BUTTON_CODE_COUNT
end

function ENT:IsKeyboardButton( btn )
	return btn > KEY_FIRST and btn < KEY_COUNT
end

function ENT:IsMouseButton( btn )
	return btn >= MOUSE_FIRST and btn < MOUSE_LAST
end

function ENT:IsJoystickButton( btn )
	return btn >= JOYSTICK_FIRST and btn < JOYSTICK_LAST
end

function ENT:IsKeyAllowed( btn )
	if bit.band( self.KeyAllowedFlags , self.KeyAllowedKeyboard ) == 0 and self:IsKeyboardButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedMouse ) == 0 and self:IsMouseButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedJoystick ) == 0 and self:IsJoystickButton( btn ) then
		return false
	end

	return self:IsValidButton( btn )
end

function ENT:GetConVarName()
	return "prdent_key_"..self:GetSlotName()
end

function ENT:GetControllingPlayerConVarKey()
	local defaultkey = BUTTON_CODE_NONE

	if self:IsCarried() then
		if SERVER then
			return self:GetControllingPlayer():GetInfoNum( self:GetConVarName() , defaultkey )
		else
			--the clientside implementation of GetInfoNum makes a GetConVar lookup everytime, so use the cached one instead
			local cv = self:GetConVar()

			if cv then
				return cv:GetInt()
			end
		end
	end

	return defaultkey
end

function ENT:HandleCalcMainActivity( ply , velocity )
	if self:IsCarriedBy( ply ) then
		local calcideal , calcseqovr = self:HandleMainActivityOverride( ply , velocity )
		if calcideal and calcseqovr then
			return calcideal , calcseqovr
		end
	end
end

function ENT:HandleUpdateAnimation( ply, velocity, maxseqgroundspeed )
	if self:IsCarriedBy( ply ) then
		if self:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed ) then
			return true
		end
	end
end

function ENT:HandleAnimationEvent( ply, event, data )
	if self:IsCarriedBy( ply ) then
		if self:HandleAnimationEventOverride( ply , event , data ) then
			return ACT_INVALID
		end
	end
end

function ENT:HandleMainActivityOverride( ply , velocity )
	--override me
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	--override me
end

function ENT:HandleAnimationEventOverride( ply , event , data )
	--override me
end

function ENT:HandlePredictedStartCommand( ply , cmd )
	if self:IsCarriedBy( ply ) then
		self:PredictedStartCommand( ply , cmd )
	end
end

function ENT:HandlePlayerButtonDown( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , true )
	end
end

function ENT:HandlePlayerButtonUp( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , false )
	end
end

function ENT:HandlePlayerButtonInternal( ply , btn , pressed )
	local mykey = self:GetKey()
	if self:IsKeyAllowed( mykey ) and btn == mykey then
		self:SetKeyPressed( pressed )
	end

	self:PredictedPlayerButtonPress( ply , btn , pressed )
end

function ENT:HandlePredictedSetupMove( ply , mv , cmd )
	if self:IsCarriedBy( ply ) then
		if self:PredictedSetupMove( ply , mv , cmd ) then
			return true
		end
	end
end

function ENT:HandlePredictedMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedThink( ply , mv )
	if self:IsCarriedBy( ply ) then
		if CLIENT then
			self:InternalHandleLoopingSounds( true )
		end
		self:PredictedThink( ply , mv )
	end
end

function ENT:HandlePredictedFinishMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedFinishMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedHitGround( ply , inwater , onfloater , speed )
	if self:IsCarriedBy( ply ) then
		if self:PredictedHitGround( ply , inwater , onfloater , speed ) then
			return true
		end
	end
end

function ENT:PredictedStartCommand( ply , cmd )
	--override me
end

function ENT:PredictedPlayerButtonPress( ply , btn , pressed )
	--override me
end

function ENT:PredictedSetupMove( ply , mv , cmd )
	--override me
end

function ENT:PredictedMove( ply , mv )
	--override me
end

function ENT:PredictedThink( ply , mv )
	--override me
end

function ENT:PredictedFinishMove( ply , mv )
	--override me
end

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )
	--override me
end

--Allows for predicted movement simulation on non player entities, without disrupting the player movement itself
--FinishMove should be the best place for this, since even in case of fuckups, the rest of the movement should be fine

--[[
	function ENT:PredictedFinishMove( ply , mv )

		local sv = self:BackupMoveData( mv )

		--set the data you want on the movedata, such as the entity origin, speed, angles and stuff

		--run the entity traces

		--set the final position of the entity here with the same way garry does ( see drive.End or whatever it's called )

		--restore the movedata on the player as if nothing happened

		self:RestoreMoveData( mv , sv )


	end
]]


local movedatameta = FindMetaTable( "CMoveData" )

local emptyvalues = {
	[TYPE_VECTOR] = vector_origin * 1,
	[TYPE_ANGLE] = angle_zero * 1,
	[TYPE_NUMBER] = 0,
	[TYPE_ENTITY] = NULL,
}

local methods = {}

--cache the methods we can actually use
for i , v in pairs( movedatameta ) do
	--see if this function has a pattern like "Get*" or whatever
	--then strip out "Get" and add it here
	local functionname = i
	if functionname:find( "^Get" ) then
		local functionnamestripped = functionname:gsub( "^Get" , "" )

		local setter = movedatameta["Set"..functionnamestripped]

		if setter then
			--add the stripped method to the table to reuse later
			methods[#methods + 1] = functionnamestripped
		end
	end
end

function ENT:BackupMoveData( mv )

	if not mv or not movedatameta then
		return
	end

	local sv = {}
	--save the movedata by name on the table, then go trough the metatable to get the setters and set values to empty ones

	for i , v in pairs( methods ) do
		--see if this function has a pattern like "Get*" or whatever
		--then strip out "Get" and add it here

		--we could've cached the functions as well, but just in case someone wants us to use the modified ones
		local getter = movedata["Get"..v]
		local setter = movedata["Set"..v]

		local backupvalue = getter( mv )

		sv[v] = backupvalue

		if emptyvalues[TypeID( backupvalue )] ~= nil then
			setter( mv , emptyvalues[TypeID( backupvalue )] )
		end
	end

	return sv
end

function ENT:RestoreMoveData( mv , sv )
	if not mv or not sv or not movedatameta then
		return
	end

	--restore the values from the table, prevents duplicated code by using the setters from the metatable directly
	for i , v in pairs( sv ) do
		local setter = movedatameta["Set"..i]
		if setter then
			setter( mv , v )
		end
	end
end

--attaches the entity to the player depending on the attachmentinfo table
--you can override this safely as long as you keep the part with ply:SetupBones()
--although you generally should just use the attachment info table instead

function ENT:GetCustomParentOrigin()

	if not self.AttachmentInfo then
		return
	end

	local ply = self:GetControllingPlayer()

	--duplicated check, but people might call this manually in the entity draw hook, so gotta do this
	if not self:IsCarriedBy( ply ) then
		return
	end

	--I put this here because since the entity moves to the player bone matrix, it'll only be updated on the client
	--when the player is actally drawn, or his bones are setup again ( which happens before a draw anyway )
	--this also fixes sounds on the client playing at the last location the LocalPlayer() was drawn

	if CLIENT and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
		ply:SetupBones()
	end

	local boneid = ply:LookupBone( self.AttachmentInfo.BoneName )

	if not boneid then
		return
	end

	local matrix = ply:GetBoneMatrix( boneid )

	if not matrix then
		return
	end

	return LocalToWorld( self.AttachmentInfo.OffsetVec , self.AttachmentInfo.OffsetAng , matrix:GetTranslation() , matrix:GetAngles() )
end

--if we're attached to a player, use custom origin from the function above
--this is called shared, yes it's more expensive than source's normal parenting but it's worth it

function ENT:CalcAbsolutePosition( pos , ang )
	if self.AttachesToPlayer and self:IsCarried() then
		return self:GetCustomParentOrigin()
	end
end

function ENT:EmitPESound( soundname , level , pitch , volume , chan , predicted , activator , worldpos )

	--must've been called manually by some ent:Fire or ent:Input functions
	if IsValid( activator ) and not activator:IsPlayer() then
		activator = NULL
	end

	if not level then
		level = 75
	end

	if not pitch then
		pitch = 100
	end

	if not volume then
		volume = 1
	end

	if not chan then
		chan = CHAN_AUTO
	end

	if game.SinglePlayer() then
		predicted = false
	end

	if not worldpos then
		worldpos = vector_origin
	end

	if SERVER then

		local plys = RecipientFilter()

		if IsValid( activator ) and not predicted and not activator:IsBot() then
			plys:AddPlayer( activator )
		else

			plys:AddPVS( self:GetPos() )

			if predicted and IsValid( self:GetControllingPlayer() ) then
				plys:RemovePlayer( self:GetControllingPlayer() )
			end

		end

		if plys:GetCount() == 0 then
			return
		end

		net.Start( "pe_playsound" )
			net.WriteEntity( self )
			net.WriteString( soundname )
			net.WriteFloat( level )
			net.WriteFloat( pitch )
			net.WriteFloat( volume )
			net.WriteUInt( chan , 8 )
			net.WriteVector( worldpos )
		net.Send( plys )

	else
		if ( predicted and IsFirstTimePredicted() ) or not predicted then
			if worldpos and worldpos ~= vector_origin then
				sound.Play( soundname, worldpos, level, pitch , volume )
			else
				self:EmitSound( soundname , level , pitch , volume , chan )
			end
		end
	end
end

function ENT:OnRemove()
	--if we're being forcibly removed, make sure we're also dropped properly, in case the entity needs to do
	--some stuff on the player before it expires
	if SERVER and self:IsCarried() then
		self:Remove( true )
	end

	if CLIENT then
		self:HandleContextMenuButton( true )
	end

	self:HandleHooks( true ) --remove the hooks immediately instead of relying on garry's "remove if called again"


end

--stuff that should be in an autorun file but that I can't be arsed to split up to

if SERVER then

	util.AddNetworkString( "pe_pickup" )
	util.AddNetworkString( "pe_playsound" )

	--save the function before ENT gets removed during registration
	local GetPredictedEntityOnPlayer = ENT.GetOnPlayer

	concommand.Add( "pe_drop" , function( ply , cmd , args , fullstr )

		if not IsValid( ply ) then
			return
		end

		local nwslot = args[1]

		if not nwslot then
			return
		end

		local slotent = GetPredictedEntityOnPlayer( ply , nwslot )--ply:GetNWEntity( nwslot )

		--user tried to drop an invalid or an entity which is not a predicted entity, or doesn't have a slot assigned

		if not IsValid( slotent ) or not slotent.IsPredictedEnt or slotent:GetSlotName() == "" then
			return
		end

		slotent:Remove( false )

	end)

else

	--tells the hud to show the player the entity pickup
	language.Add( "invalid_entity" , "Invalid Entity" )
	language.Add( "dropped_invalid_entity" , "Dropped Invalid Entity" )

	net.Receive( "pe_pickup" , function( len )
		local str = net.ReadString() or "invalid_entity"
		local dropped = tobool( net.ReadBit() )

		if dropped then
			str = "dropped_" .. str
		end

		gamemode.Call( "HUDItemPickedUp" , str )
	end)

	net.Receive( "pe_playsound" , function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.EmitPESound then
			return
		end

		local soundname = net.ReadString() --yes I know that I can do util.addnetworkstring to cache it but I cba

		local level = net.ReadFloat()
		local pitch = net.ReadFloat()
		local volume = net.ReadFloat()
		local chan = net.ReadUInt( 8 )
		local pos = net.ReadVector()

		ent:EmitPESound( soundname , level , pitch , volume , chan , false , NULL , pos )
	end)

	--[[
		A DProperty that allows the user to set a preferred key using the same DBinder used in sandbox's tools
	]]

	local DBinderProperty = {}

	function DBinderProperty:Init()
	end

	function DBinderProperty:Setup( vars )

		self:Clear()

		local ctrl = self:Add( "DBinder" )
		ctrl:Dock( FILL )

		self.IsEditing = function( self )
			return ctrl.Trapping
		end

		self.SetValue = function ( self , val )
			ctrl:SetSelected( tonumber( val ) )	--use this instead of setValue to possibly avoid feedback loops
		end

		--DBinder doesn't have an onchange callback, so we must do this little hack to add it
		--[[
		ctrl.SetValue = function( ctrl , val )
			ctrl:SetSelected( val )
			self:ValueChanged( val )
		end
		]]

		ctrl.OnChange = function( ctrl , val )
			self:ValueChanged( val )
		end


	end

	derma.DefineControl( "DProperty_EditKey" , "" , DBinderProperty , "DProperty_Generic" )

	local DPredEnt = {
		matOverlay_Normal = Material( "gui/ContentIcon-normal.png" ),
		matOverlay_Hovered = Material( "gui/ContentIcon-hovered.png" )
	}

	AccessorFunc( DPredEnt, "m_MaxBorder", "MaxBorder" )
	AccessorFunc( DPredEnt, "m_MaterialName", "MaterialName" )
	AccessorFunc( DPredEnt, "m_PredEnt", "PredEnt" )
	AccessorFunc( DPredEnt, "m_Border", "Border" )
	AccessorFunc( DPredEnt, "m_Color", "Color" )
	AccessorFunc( DPredEnt, "m_Type", "ContentType" )
	AccessorFunc( DPredEnt, "m_SpawnName", "SpawnName" )
	AccessorFunc( DPredEnt, "m_NPCWeapon", "NPCWeapon" )
	AccessorFunc( DPredEnt, "m_Image", "Image" )
	AccessorFunc( DPredEnt, "m_Label", "Label" )

	function DPredEnt:Init()

		local w , h = 128, 128
		self:SetSize( w , h )

		self:SetPaintBackground( false )

		self:SetText( "" )
		self:SetDoubleClickingEnabled( false )

		self:SetImage( self:Add( "DImage" ) )
		self:GetImage():SetVisible( false )

		self:SetLabel( self:Add( "DLabel" ) )
		self:GetLabel():Dock( BOTTOM )

		self:GetLabel():SetContentAlignment( 5 )

		self:GetLabel():SetTextColor( Color( 255, 255, 255, 255 ) )
		self:GetLabel():SetExpensiveShadow( 1, Color( 0, 0, 0, 200 ) )

		self:SetBorder( 0 )



	end



	function DPredEnt:PerformLayout( w , h )
		self:SetMaxBorder( w / 16 )
		self:GetImage():SetPos( w / 32 , w / 32 )
		self:GetImage():SetSize( w - w / 16 , h - w / 16 )
		self:GetLabel():SetTall( math.Round( w / 7 ) )
		self:GetLabel():DockMargin( math.Round( w / 32 ) , 0 , math.Round( w / 32 ) , math.Round( w / 21 ) )
	end


	function DPredEnt:SetClassName( name , class )

		self:SetTooltip( name )
		self:GetLabel():SetText( name )
		self:SetSpawnName( class )
	end

	function DPredEnt:SetMaterial( name )

		self:SetMaterialName( name )

		local mat = Material( name )

		-- Look for the old style material
		if not mat or mat:IsError() then

			name = name:Replace( "entities/", "VGUI/entities/" )
			name = name:Replace( ".png", "" )
			mat = Material( name )

		end

		-- Couldn't find any material.. just return
		if not mat or mat:IsError() then
			return
		end

		self:GetImage():SetMaterial( mat )

	end

	function DPredEnt:Think()
		if not IsValid( self:GetPredEnt() ) or not self:GetPredEnt().IsPredictedEnt  then
			self:Remove()
		end
	end

	function DPredEnt:DoRightClick()
		self:OpenMenu()
	end

	function DPredEnt:DoClick()
		RunConsoleCommand( "pe_drop" , self:GetSpawnName() or ""  )
	end

	function DPredEnt:OpenMenu()
		if IsValid( self:GetPredEnt() ) then
			properties.OpenEntityMenu( self:GetPredEnt() )
		end
	end

	function DPredEnt:OnDepressionChanged( b )
	end

	function DPredEnt:Paint( w, h )

		if self.Depressed and not self.Dragging then
			if self:GetBorder() ~= self:GetMaxBorder() then
				self:SetBorder( self:GetMaxBorder() )
				self:OnDepressionChanged( true )
			end
		else
			if self:GetBorder() ~= 0 then
				self:SetBorder( 0 )
				self:OnDepressionChanged( false )
			end
		end

		render.PushFilterMag( TEXFILTER.ANISOTROPIC )
		render.PushFilterMin( TEXFILTER.ANISOTROPIC )

		local bx , by , bw , bh = self:GetBorder(), self:GetBorder(), w - self:GetBorder() * 2 , h - self:GetBorder() * 2


		self:GetImage():PaintAt( bx + self:GetMaxBorder() / 2 , by + self:GetMaxBorder() / 2 , bw - self:GetMaxBorder() , bh - self:GetMaxBorder() )



		render.PopFilterMin()
		render.PopFilterMag()

		surface.SetDrawColor( 255, 255, 255, 255 )

		if not dragndrop.IsDragging() and ( self:IsHovered() or self.Depressed or self:IsChildHovered() ) then

			surface.SetMaterial( self.matOverlay_Hovered )
			self:GetLabel():Hide()

		else

			surface.SetMaterial( self.matOverlay_Normal )
			self:GetLabel():Show()

		end

		surface.DrawTexturedRect( bx , by , bw , bh )

	end

	derma.DefineControl( "DPredEnt" , "ContentIcon for Predicted entities in the context menu" , DPredEnt , "DButton" )

end

--addons/tools/lua/entities/healthified_prop.lua:
AddCSLuaFile()
-- Made for Excalibur Networks by Keegan

ENT.Base            = "base_entity"
ENT.Type            = "anim"
ENT.RenderGroup     = RENDERGROUP_BOTH
ENT.Author			= "Keegan"
ENT.Category		= "Other"
ENT.Spawnable		= false -- set to false in this base file so the empty base doesnt show up
ENT.AdminOnly		= true

ENT.ExplosionAmount = nil
ENT.ExplosionType	= nil
ENT.ExplosionFinal	= nil
ENT.ExplosionFinalType = nil 
ENT.ExplosionFinalSound = nil
ENT.RegenEnabled	= nil
ENT.RegenDelay		= nil
ENT.RegenPercent	= nil
ENT.NextRegen		= nil

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "Shields")
	self:NetworkVar("Float", 1, "MaxShields")
end

if (SERVER) then
	function ENT:Initialize()
		self:PhysicsInit(SOLID_VPHYSICS)
	end

	function ENT:Think()
		-- Shield regeneration
		if not (self.RegenEnabled) then return end
		if not (self:GetShields() < self:GetMaxShields()) then return end
		if not (self:CanRegenShield()) then return end
		self:RegenShield()
	end

	function ENT:Remove()
		if (timer.Exists(tostring(self:EntIndex() .. self:GetName()))) then
			timer.Remove(tostring(self:EntIndex() .. self:GetName()))
		end

		if (tostring(self:EntIndex() .. self:GetName() .. "Remover")) then
			timer.Remove(tostring(self:EntIndex() .. self:GetName() .. "Remover"))
		end
	end

	function ENT:DelayRegenShield(delay)
		self.NextRegen = delay + CurTime()
	end

	function ENT:CanRegenShield()
		return (self.NextRegen or 0) < CurTime()
	end

	function ENT:RegenShield()
		local shieldTarget = self:GetShields() + (self:GetMaxShields() * self.RegenPercent)
		if (shieldTarget > self:GetMaxShields()) then shieldTarget = self:GetMaxShields() end
		self:SetShields(shieldTarget)
		self:DelayRegenShield(self.RegenDelay)
	end

	function ENT:OnTakeDamage(dmginfo)
		local dmg = dmginfo:GetDamage()
		local dmgPos = dmginfo:GetDamagePosition()
		
		dmg = self:OnTakeShieldDamage(dmg, dmgPos)
		self:OnTakeDirectDamage(dmg)
		if (self:Health() > 0) then return end
		self:OnTakeFatalDamage(dmgPos)
	end

	function ENT:OnTakeShieldDamage(dmg, dmgPos) 
		if (dmg <= 0) then return 0 end

		if (self.RegenEnabled) then self:DelayRegenShield(self.RegenDelay) end

		if not (self:GetShields() > 0) then return dmg end

		-- Flash shields (Ensure LVS is installed!)
		local effectdata = EffectData()
		effectdata:SetOrigin(dmgPos)
		effectdata:SetEntity(self)
		util.Effect("lvs_shield_impact", effectdata)
			
		local remainingShields = self:GetShields() - dmg
		if (remainingShields > 0) then
			dmg = 0
			self:SetShields(remainingShields)
		else
			dmg = dmg - self:GetShields()
			self:SetShields(0)
		end

		return dmg
	end

	function ENT:OnTakeDirectDamage(dmg)
		if (dmg <= 0) then return 0 end
		
		local remainingHealth = self:Health() - dmg
		if (remainingHealth > 0) then
			self:SetHealth(remainingHealth)
		else
			self:SetHealth(0)
		end

		return
	end

	function ENT:OnTakeFatalDamage(dmgPos)
		-- 0 Explosions
		if (not self.ExplosionAmount) or (self.ExplosionAmount < 1) then
			self:Remove()
			return
		end

		-- Explode (Ensure LVS is installed!)
		local effectData = EffectData()
		effectData:SetOrigin(dmgPos)
		effectData:SetEntity(self)

		local i = 1
		timer.Create(tostring(self:EntIndex() .. self:GetName()), 1, self.ExplosionAmount, function()
			if (i == self.ExplosionAmount) then
				if (self.ExplosionFinal) then
					self:DoFinalExplosion(dmgPos)
				else
					self:DoExplosion(effectData)
				end
				return
			end
			i = i + 1
			self:DoExplosion(effectData)		
		end)

		timer.Create(tostring(self:EntIndex() .. self:GetName() .. "Remover"), self.ExplosionAmount, 1, function() self:Remove() end)
	end

	function ENT:DoExplosion(effectData)
		util.Effect(self.ExplosionType, effectData)
	end

	function ENT:DoFinalExplosion(pos)
		ParticleEffect(self.ExplosionFinalType, pos, Angle(0,0,0), nil)	
		sound.Play(self.ExplosionFinalSound, pos, 120, 100, 1)
	end
end

if (CLIENT) then
	function ENT:Draw()
		-- Actually draw the model
		self:DrawModel()
		
		if not (LocalPlayer():GetEyeTrace().Entity == self) then return end

		-- Draw tooltip
		if (LocalPlayer():GetActiveWeapon():GetClass() == "gmod_tool") then 
			AddWorldTip(self:EntIndex(), "This is a Healthified Prop", nil, self:GetPos(), self)
			return
		end

		-- Draw healthbar
		if not (self:GetShields() == 0) then return end
		if not (self:Health() > 0) then return end
		local healthPercent = self:Health()/self:GetMaxHealth()
		local width = healthPercent * ScrW()/10
		local x = ScrW()/2 - width/2
		local height = ScrH()/40
		local y = ScrH()/2 + ScrH()/20
		cam.Start2D()
			surface.SetDrawColor(255-(healthPercent*255),255*healthPercent,0,255)
			surface.DrawRect(x, y, width, height)
			surface.SetDrawColor(255,255,255,255)
			surface.DrawOutlinedRect((ScrW()/2 - ScrW()/20), ScrH()/2 + ScrH()/20, ScrW()/10, height, 1)
		cam.End2D()
	end
end

--addons/lvs_addons/lua/entities/hyena_bomb/shared.lua:
ENT.Base            = "base_gmodentity"
ENT.Type            = "anim"

ENT.PrintName       = "Bombe"
ENT.Author          = "Deltaa"
ENT.Information     = ""
ENT.Category        = "AOCRP - KUS - Flugobjekte"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

game.AddParticles("particles/gb5_100lb.pcf")
PrecacheParticleSystem("100lb_ground")
--addons/weapon_joe_fort/lua/entities/joefort_ressource_1000/shared.lua:
ENT.Type = "anim"
ENT.Base = "joefort_ressource_base"
 
ENT.PrintName = "Resource Container"
ENT.Author  = "Joe"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.Category = "JoeFort"

ENT.Ressourceamount = 1000
ENT.model = "models/props_wasteland/cargo_container01.mdl"
ENT.Destroyable = false
--addons/weapon_joe_fort/lua/entities/joefort_ressource_base/cl_init.lua:
include('shared.lua')

local col1 = Color(134, 235, 255,255)
local col2 = Color(9, 125, 168, 100)

function ENT:Draw()
	self:DrawModel()
	local maxs = self:OBBMaxs()
	local center = self:OBBCenter()
	local pos = self:LocalToWorld(Vector(maxs.x,0,center.z + 5))
	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Right(), -90)
	ang:RotateAroundAxis(ang:Up(), 90)

	cam.Start3D2D(pos, ang, 0.1)
		surface.SetFont("JoeFort50")
		local sizex = surface.GetTextSize("Name: " .. self.PrintName) + 20
		surface.SetDrawColor(col2)
		surface.DrawRect(sizex * -0.5, -20, sizex, 100)
		surface.SetDrawColor(col1)
		surface.DrawOutlinedRect(sizex * -0.5, -20, sizex, 100, 3)
		draw.SimpleText("Name: " .. self.PrintName, "JoeFort50", 0, 0, col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		draw.SimpleText("Resources: " .. self.Ressourceamount, "JoeFort50", 0, 50, col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end

--addons/weapon_joe_fort/lua/entities/joefort_ressource_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
 
ENT.PrintName = "JoeFort_Ressource_Base"
ENT.Author  = "Joe"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = "JoeFort"

ENT.Ressourceamount = 100
ENT.model = "models/props_c17/concrete_barrier001a.mdl"
ENT.Destroyable = true
--addons/lvs_addons/lua/entities/loader_new/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

ENT.EnginePos = {
	[1] = Vector(-135.68,48.29,17.38),
	[2] = Vector(-134.04,-48.59,17.03),
}


ENT.EngineColor = Color( 55, 55, 255, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )

local spotlight = Material( "effects/lvs/laat_spotlight" )
local glow_spotlight = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 30 + ((self:GetVelocity():Length() + math.random(0.5,0.8)) / 1000) * 40 * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
    local view = {}
    view.origin = pos
    view.fov = fov
    view.drawviewer = true
    view.angles = ply:EyeAngles()

    if pod:GetThirdPersonMode() then


        local radius = 550
        local radius = radius + radius * pod:GetCameraDistance()

        local TargetOrigin = view.origin - view.angles:Forward() * radius  + view.angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())
        local WallOffset = 4

        local tr = util.TraceHull( {
            start = view.origin,
            endpos = TargetOrigin,
            filter = function( e )
                local c = e:GetClass()
                local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

                return collide
            end,
            mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
            maxs = Vector( WallOffset, WallOffset, WallOffset ),
        } )

        if not pod:GetThirdPersonMode() then
            view.origin = self:LocalToWorld( Vector(-145, -25, 100) )
            view.drawviewer = false
        end

        view.origin = tr.HitPos

        if tr.Hit and not tr.StartSolid then
            view.origin = view.origin + tr.HitNormal * WallOffset
        end

        return view
    end

    if not pod:GetThirdPersonMode() then

        view.drawviewer = false

        local Driver = self:GetDriver()

        if ply == Driver then
            view.origin = self:LocalToWorld( Vector(-161.05,-22.29,91) )
        end
     
        return view
    end
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	if self:GetDriver() == ply then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	end
end

function ENT:Draw()
	self:DrawModel()

	if not self:GetLightsOn() then 
		self:RemoveLight()
		return 
	else
		if not IsValid( self.projector ) then
			local thelamp = ProjectedTexture()
			thelamp:SetBrightness( 20 ) 
			thelamp:SetTexture( "effects/flashlight/soft" )
			thelamp:SetColor( Color(255,255,255) ) 
			thelamp:SetEnableShadows( false ) 
			thelamp:SetFarZ( 1000 ) 
			thelamp:SetNearZ( 75 ) 
			thelamp:SetFOV( 50 )
			self.projector = thelamp

			local thelamp = ProjectedTexture()
			thelamp:SetBrightness( 20 ) 
			thelamp:SetTexture( "effects/flashlight/soft" )
			thelamp:SetColor( Color(255,255,255) ) 
			thelamp:SetEnableShadows( false ) 
			thelamp:SetFarZ( 1000 ) 
			thelamp:SetNearZ( 75 ) 
			thelamp:SetFOV( 50 )
			self.projector2 = thelamp
		end

		local StartPos = self:LocalToWorld( Vector(136.11,48.26,16.58) )
		local StartPos2 = self:LocalToWorld( Vector(135.62,-49.17,17.32) )

		local Dir = self:GetForward()

		render.SetMaterial( glow_spotlight )
		render.DrawSprite( StartPos , 120, 120, Color( 255, 255, 255, 255) )
		render.SetMaterial( spotlight )
		render.DrawBeam(  StartPos ,  StartPos + Dir * 800, 250, 0, 0.99, Color( 255, 255, 255, 10) )

		render.SetMaterial( glow_spotlight )
		render.DrawSprite( StartPos2 , 120, 120, Color( 255, 255, 255, 255) )
		render.SetMaterial( spotlight )
		render.DrawBeam(  StartPos2 ,  StartPos2 + Dir * 800, 250, 0, 0.99, Color( 255, 255, 255, 10) )


		
		if IsValid( self.projector ) then
			self.projector:SetPos( StartPos )
			self.projector:SetAngles( Dir:Angle() )
			self.projector:Update()
			self.projector2:SetPos( StartPos2 )
			self.projector2:SetAngles( Dir:Angle() )
			self.projector2:Update()
		end
	end
end


function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
		self.projector2:Remove()
		self.projector2 = nil
	end
end

function ENT:OnRemove()	
	self:RemoveLight()
end
--addons/lvs_addons/lua/entities/lunasflightschool_niksacokica_tx-427_imperial/sh_turret.lua:

function ENT:SetPoseParameterTurret( weapon )
	if self:GetIsCarried() then
		self:SetPoseParameter("turret_pitch", 0 )
		self:SetPoseParameter("turret_yaw",  0 )

		if self.TurretWasSet then
			self.TurretWasSet = nil

			self:SetTurretPitch( 0 )
			self:SetTurretYaw( 0 )
		end

		return
	end

	self.TurretWasSet = true

	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	local AimRate = self.TurretTurnRate * FrameTime() 

	self:SetTurretPitch( math.ApproachAngle( self:GetTurretPitch(), -AimAng.p, AimRate ) )

 	self:SetTurretYaw( LerpAngle( AimRate * 0.02, Angle( 0, self:GetTurretYaw(), 0 ), Angle(0, AimAng.y, 0 ) ).y )

	self:SetPoseParameter("turret_pitch", self:GetTurretPitch() )
	self:SetPoseParameter("turret_yaw", self:GetTurretYaw() )
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "turret_muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = -Muzzle.Ang:Right()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:InitTurret()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 2.5
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/vehicles/aat/overheat.mp3")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return true end

		local ID = base:LookupAttachment( "turret_muzzle" )
		local Muzzle = base:GetAttachment( ID )

		if not Muzzle then return end

		local Dir = Muzzle.Ang:Up()
		local bullet = {}
		bullet.Src 	= Muzzle.Pos
		bullet.Dir 	= -Muzzle.Ang:Right()
		bullet.Spread 	= Vector(0,0,0)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 1000
		bullet.HullSize 	= 30
		bullet.Damage	= 1500
		bullet.Velocity = 7000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lfs_tx-427_main_explosion_red", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		effectdata:SetScale(100)
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		local PhysObj = base:GetPhysicsObject()
		if IsValid( PhysObj ) then
			PhysObj:ApplyForceOffset( Muzzle.Ang:Right() * 500000, Muzzle.Pos )
		end

		if not IsValid( base.SNDTurret ) then return end

		base.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterTurret( ent )
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end
		local entWhitelist = {
			[base] = true,
			[ent] = true,
			[self] = true,
		}
		if not pod:GetThirdPersonMode() then
			return view
		end

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )
		local StartPos = self:LocalToWorld( Vector(-75,0,140) )
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide and not entWhitelist[e]
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.125
	weapon.HeatRateUp = 0.15
	weapon.HeatRateDown = 0.125
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/vehicles/aat/overheat.mp3")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return true end


		local ID = base:LookupAttachment( "turret_muzzle" )
		local muzzle = base:GetAttachment( ID )

		if not muzzle then return end

		self:EmitSound( "niksacokica/tx-427/cannon_small.wav" )
		local ang = muzzle.Ang
		local dir = -ang:Right()
		local tr = util.TraceLine( {
			start = muzzle.Pos,
			endpos = muzzle.Pos + dir * 100000,
			filter = { ent, base, self }
		} )
		local bullet = {}
		bullet.Src 	= muzzle.Pos
		bullet.Dir 	= ( tr.HitPos - muzzle.Pos ):GetNormalized()
		bullet.Spread 	= Vector( 0.015,  0.015, 0.01 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 100
		bullet.HullSize 	= 1
		bullet.Damage	= 16
		bullet.Velocity = 40000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
		
		ent:TakeAmmo()
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterTurret( ent )
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()
		
		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end
		local entWhitelist = {
			[base] = true,
			[ent] = true,
			[self] = true,
		}
		if not pod:GetThirdPersonMode() then
			return view
		end

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )
		local StartPos = self:LocalToWorld( Vector(-75,0,140) )
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide and not entWhitelist[e]
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

--addons/lvs_base/lua/entities/lvs_armor.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

ENT.RenderGroup = RENDERGROUP_BOTH 

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Float",0, "HP" )
	self:NetworkVar( "Float",1, "MaxHP" )
	self:NetworkVar( "Float",2, "IgnoreForce" )

	self:NetworkVar( "Vector",0, "Mins" )
	self:NetworkVar( "Vector",1, "Maxs" )

	self:NetworkVar( "Bool",0, "Destroyed" )

	self:NetworkVar( "String",0, "Label" )

	if SERVER then
		self:SetMaxHP( 100 )
		self:SetHP( 100 )
		self:SetLabel( "Armor Plate" )
	end
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
	end

	function ENT:Think()
		return false
	end

	function ENT:OnHealthChanged( dmginfo, old, new )
		if old == new then return end
	end

	function ENT:OnRepaired()
	end

	function ENT:OnDestroyed( dmginfo )
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:TakeTransmittedDamage( dmginfo )
		local Force = dmginfo:GetDamageForce()

		local Damage = dmginfo:GetDamage()
		local DamageForce = Force:Length()
		local IsBlastDamage = dmginfo:IsDamageType( DMG_BLAST )

		local CurHealth = self:GetHP()

		local pos = dmginfo:GetDamagePosition()
		local dir = Force:GetNormalized()

		local base = self:GetBase()

		-- translate force value to armor penetration value is Force * 0.1
		-- mm to inch is * 0.0393701
		-- so correct value is * 0.00393701
		local pLength = DamageForce * 0.00393701

		local TraceData = {
			start = pos - dir * pLength,
			endpos = pos + dir * pLength,
		}

		local trace = util.TraceLine( TraceData )

		-- parent stays the same
		local parent = trace.Entity
		local parentPos = trace.HitPos
		local parentDir = trace.HitNormal

		-- only one extra iteration should be enough ...
		if IsValid( trace.Entity ) and isfunction( trace.Entity.GetBase ) and trace.Entity:GetBase() == base then

			TraceData.filter = trace.Entity

			local FilteredTrace = util.TraceLine( TraceData )

			if FilteredTrace.Hit then
				trace = FilteredTrace
			end

			trace.Entity = base
		end

		local DotHitNormal = math.Clamp( trace.HitNormal:Dot( dir ) ,-1,1) 

		local Armor = self:GetIgnoreForce()
		local ArmorEffective = Armor / math.abs( DotHitNormal )

		if math.abs( DotHitNormal ) > 0.9 then
			ArmorEffective = Armor
		end

		local DisableBounce = false

		local Inflictor = dmginfo:GetInflictor()

		if IsValid( Inflictor ) then
			if Inflictor.DisableBallistics or Inflictor:IsNPC() or Inflictor:IsNextBot() then
				DisableBounce = true
			end
		end

		if DamageForce <= ArmorEffective and not IsBlastDamage then
			local T = CurTime()

			if trace.Entity ~= base then
				self._NextBounce = T + 1

				return false
			end

			local Ax = math.acos( DotHitNormal )
			local HitAngle = 90 - (180 - math.deg( Ax ))

			if HitAngle > 30 then
				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
					effectdata:SetNormal( -dir )
				util.Effect( "manhacksparks", effectdata, true, true )
	
				self._NextBounce = T + 1

				return false
			end

			local NewDir = dir - trace.HitNormal * math.cos( Ax ) * 2

			if (self._NextBounce or 0) > T or DisableBounce then
				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
					effectdata:SetNormal( NewDir:GetNormalized() * 0.25 )
				util.Effect( "manhacksparks", effectdata, true, true )

				return false
			end

			self._NextBounce = T + 1

			local hit_decal = ents.Create( "lvs_armor_bounce" )
			hit_decal:SetPos( trace.HitPos )
			hit_decal:SetAngles( NewDir:Angle() )
			hit_decal:Spawn()
			hit_decal:Activate()
			hit_decal:EmitSound("lvs/armor_rico"..math.random(1,6)..".wav", 95, 100, math.min( dmginfo:GetDamage() / 1000, 1 ) )

			local PhysObj = hit_decal:GetPhysicsObject()
			if not IsValid( PhysObj ) then return false end

			PhysObj:EnableDrag( false )
			PhysObj:SetVelocityInstantaneous( NewDir * 2000 + Vector(0,0,250) )
			PhysObj:SetAngleVelocityInstantaneous( VectorRand() * 250 )

			return false
		end

		local NewHealth = math.Clamp( CurHealth - Damage, 0, self:GetMaxHP() )

		self:OnHealthChanged( dmginfo, CurHealth, NewHealth )
		self:SetHP( NewHealth )

		if NewHealth <= 0 and not self:GetDestroyed() then
			self:SetDestroyed( true )
			self:OnDestroyed( dmginfo )
		end

		local hit_decal = ents.Create( "lvs_armor_penetrate" )
		hit_decal:SetPos( parentPos + parentDir * 0.2 )
		hit_decal:SetAngles( parentDir:Angle() + Angle(90,0,0) )
		hit_decal:Spawn()
		hit_decal:Activate()
		hit_decal:SetParent( parent )

		return true
	end

	return
end

function ENT:Initialize()
end

function ENT:OnRemove()
end

function ENT:Think()
end


function ENT:Draw()
end

local function DrawText( pos, text, col )
	cam.Start2D()
		local data2D = pos:ToScreen()

		if not data2D.visible then cam.End2D() return end

		local font = "TargetIDSmall"

		local x = data2D.x
		local y = data2D.y

		draw.DrawText( text, font, x + 1, y + 1, Color( 0, 0, 0, 120 ), TEXT_ALIGN_CENTER )
		draw.DrawText( text, font, x + 2, y + 2, Color( 0, 0, 0, 50 ), TEXT_ALIGN_CENTER )
		draw.DrawText( text, font, x, y, col or color_white, TEXT_ALIGN_CENTER )
	cam.End2D()
end

local LVS = LVS
local BoxMat = Material("models/wireframe")
local ColorSelect = Color(0,127,255,150)
local ColorNormal = Color(50,50,50,150)
local ColorTransBlack = Color(0,0,0,150)
local OutlineThickness = Vector(0.5,0.5,0.5)
local ColorText = Color(255,0,0,255)

function ENT:DrawTranslucent()
	if not LVS.DeveloperEnabled then return end

	local ply = LocalPlayer()

	if not IsValid( ply ) or ply:InVehicle() or not ply:KeyDown( IN_SPEED ) then return end

	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local HitPos, _, _ = util.IntersectRayWithOBB( ply:GetShootPos(), ply:GetAimVector() * 1000, boxOrigin, boxAngles, boxMins, boxMaxs )

	local InRange = isvector( HitPos )

	local Col = InRange and ColorSelect or ColorNormal

	render.SetColorMaterial()
	render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, Col )
	render.DrawBox( boxOrigin, boxAngles, boxMaxs + OutlineThickness, boxMins - OutlineThickness, ColorTransBlack )

	local boxCenter = (self:LocalToWorld( boxMins ) + self:LocalToWorld( boxMaxs )) * 0.5

	if not InRange then return end

	DrawText( boxCenter, "Armor: "..(self:GetIgnoreForce() / 100).."mm\nHealth:"..self:GetHP().."/"..self:GetMaxHP(), ColorText )
end

--addons/lvs_base/lua/entities/lvs_armor_penetrate.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.LifeTime = 15

if SERVER then
	local CountTotal = {}

	function ENT:Initialize()
		CountTotal[ self:EntIndex() ] = true

		local Num = table.Count( CountTotal )

		if (Num > 30 and math.random(1,2) == 1) or Num > 60 then
			self:Remove()

			return
		end

		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		self.DieTime = CurTime() + self.LifeTime
	end

	function ENT:OnRemove()
		CountTotal[ self:EntIndex() ] = nil
	end

	function ENT:Think()
		self:NextThink( CurTime() + 0.1 )

		if not IsValid( self:GetParent() ) then self:Remove() return end

		if (self.DieTime or 0) > CurTime() then return true end

		self:Remove()

		return false
	end

	return
end

ENT.GlowMat1 = Material( "particle/particle_ring_wave_8" )
ENT.GlowMat2 = Material( "sprites/light_glow02_add" )
ENT.DecalMat = Material( "particle/particle_noisesphere" )
ENT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

local CountTotal = {}

function ENT:Initialize()
	CountTotal[ self:EntIndex() ] = true

	self.RandomAng = math.random(0,360)
	self.DieTime = CurTime() + self.LifeTime

	local Pos = self:GetPos()
	local Dir = self:GetUp()

	self.emitter = ParticleEmitter( Pos, false )

	self:EmitSound( "lvs/armor_pen_"..math.random(1,3)..".wav", 95 )
end

function ENT:Smoke()
	local T = CurTime()

	if (self.DieTime or 0) < T then return end

	if not IsValid( self.emitter ) then return end

	if (self.NextFX or 0) < T then
		self.NextFX = T + 0.2 + table.Count( CountTotal ) / 50

		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], self:GetPos() )

		if particle then
			particle:SetVelocity( self:GetUp() * 60 + VectorRand() * 30 )
			particle:SetDieTime( math.Rand(1.5,2) )
			particle:SetAirResistance( 100 ) 
			particle:SetStartAlpha( 30 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 0 )
			particle:SetEndSize( 60 )
			particle:SetRollDelta( math.Rand( -1, 1 ) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 200 ) )
			particle:SetCollide( false )
		end
	end
end

function ENT:Think()
	self:Smoke()
end

function ENT:OnRemove()
	CountTotal[ self:EntIndex() ] = nil

	if not IsValid(self.emitter) then return end

	self.emitter:Finish()
end

function ENT:Draw()
	local Timed = 1 - (self.DieTime - CurTime()) / self.LifeTime
	local Scale = math.max(math.min(2 - Timed * 2,1),0)

	local Scale02 = math.max(Scale - 0.8,0) / 0.2

	cam.Start3D2D( self:GetPos() + self:GetAngles():Up(), self:GetAngles(), 1 )
		surface.SetDrawColor( 255 * Scale02, (93 + 50 * Scale) * Scale02, (50 * Scale) * Scale02, (200 * Scale) * Scale02 )

		surface.SetMaterial( self.GlowMat1 )
		surface.DrawTexturedRectRotated( 0, 0, 8 , 8 , self.RandomAng )

		surface.SetMaterial( self.GlowMat2 )
		surface.DrawTexturedRectRotated( 0, 0, 16 , 16 , self.RandomAng )

		surface.SetDrawColor( 0, 0, 0, 255 )
		surface.SetMaterial( self.DecalMat )
		surface.DrawTexturedRectRotated( 0, 0, 16 , 16 , self.RandomAng )
	cam.End3D2D()
end

function ENT:DrawTranslucent()
	self:Draw()
end

--addons/lvs_base/lua/entities/lvs_base/cl_hud.lua:

LVS:AddHudEditor( "VehicleHealth", 10, ScrH() - 85,  220, 75, 220, 75, "VEHICLE HEALTH", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintVehicleHealth then return end

		vehicle:LVSHudPaintVehicleHealth( X, Y, W, H, ScrX, ScrY, ply )
	end
)

LVS:AddHudEditor( "VehicleInfo", ScrW() - 460, ScrH() - 85,  220, 75, 220, 75, "VEHICLE INFORMATION", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintInfoText then return end

		vehicle:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	end
)

function ENT:LVSHudPaintVehicleHealth( X, Y, W, H, ScrX, ScrY, ply )
	draw.DrawText( "HEALTH ", "LVS_FONT", X + 102, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( math.Round( self:GetHP(), 0 ), "LVS_FONT_HUD_LARGE", X + 102, Y + 20, color_white, TEXT_ALIGN_LEFT )
end

ENT.VehicleIdentifierRange = 10000

function ENT:LVSHudPaintVehicleIdentifier( X, Y, In_Col )
	local HP = self:GetHP()

	surface.SetDrawColor( In_Col.r, In_Col.g, In_Col.b, In_Col.a )
	LVS:DrawDiamond( X + 1, Y + 1, 20, HP / self:GetMaxHP() )

	if self:GetMaxShield() > 0 and HP > 0 then
		surface.SetDrawColor( 200, 200, 255, In_Col.a )
		LVS:DrawDiamond( X + 1, Y + 1, 24, self:GetShield() / self:GetMaxShield() )
	end
end

function ENT:LVSHudPaint( X, Y, ply )
end

function ENT:HurtMarker( intensity )
	LocalPlayer():EmitSound( "lvs/hit_receive"..math.random(1,2)..".wav", 75, math.random(95,105), 0.25 + intensity * 0.75, CHAN_STATIC )
	util.ScreenShake( Vector(0, 0, 0), 25 * intensity, 25 * intensity, 0.5, 1 )
end

function ENT:KillMarker()
	self.LastKillMarker = CurTime() + 0.5

	LocalPlayer():EmitSound( "lvs/hit_kill.wav", 85, 100, 0.4, CHAN_VOICE )
end

local LastMarker = 0
function ENT:ArmorMarker( IsDamage )
	local T = CurTime()

	local DontHurtEars = math.Clamp( T - LastMarker, 0, 1 ) ^ 2

	LastMarker = T

	local ArmorFailed = IsDamage and "takedamage" or "pen"
	local Volume = IsDamage and (0.3 * DontHurtEars) or 1

	LocalPlayer():EmitSound( "lvs/armor_"..ArmorFailed.."_"..math.random(1,3)..".wav", 85, math.random(95,105), Volume, CHAN_ITEM2 )
end

function ENT:HitMarker()
	self.LastHitMarker = CurTime() + 0.15

	LocalPlayer():EmitSound( "lvs/hit.wav", 85, math.random(95,105), 0.4, CHAN_ITEM )
end

function ENT:CritMarker()
	self.LastCritMarker = CurTime() + 0.15

	LocalPlayer():EmitSound(  "lvs/hit_crit.wav", 85, math.random(95,105), 0.4, CHAN_ITEM2 )
end

function ENT:GetHitMarker()
	return self.LastHitMarker or 0
end

function ENT:GetCritMarker()
	return self.LastCritMarker or 0
end

function ENT:GetKillMarker()
	return self.LastKillMarker or 0
end

function ENT:LVSPaintHitMarker( scr )
	local T = CurTime()

	local aV = math.cos( math.rad( math.max(((self:GetHitMarker() - T) / 0.15) * 360,0) ) )
	if aV ~= 1 then
		local Start = 12 + (1 - aV) * 8
		local dst = 10

		surface.SetDrawColor( 255, 255, 0, 255 )

		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start, scr.y + Start - dst )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start - dst, scr.y + Start )

		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start, scr.y - Start + dst )
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start - dst, scr.y - Start )

		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start, scr.y + Start - dst )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start + dst, scr.y + Start )

		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start, scr.y - Start + dst )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start + dst, scr.y - Start )

		scr.x = scr.x + 1
		scr.y = scr.y + 1

		surface.SetDrawColor( 0, 0, 0, 80 )

		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start, scr.y + Start - dst )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + Start - dst, scr.y + Start )

		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start, scr.y - Start + dst )
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + Start - dst, scr.y - Start )

		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start, scr.y + Start - dst )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - Start + dst, scr.y + Start )

		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start, scr.y - Start + dst )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - Start + dst, scr.y - Start )
	end

	local aV = math.sin( math.rad( math.max(((self:GetCritMarker() - T) / 0.15) * 180,0) ) )
	if aV > 0.01 then
		local Start = 10 + aV * 40
		local End = 20 + aV * 45

		surface.SetDrawColor( 255, 100, 0, 255 )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + End, scr.y + End )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - End, scr.y + End ) 
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + End, scr.y - End )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - End, scr.y - End ) 

		draw.NoTexture()
		surface.DrawTexturedRectRotated( scr.x + Start, scr.y + Start, 3, 20, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y + Start, 20, 3, 45 )
		surface.DrawTexturedRectRotated(  scr.x + Start, scr.y - Start, 20, 3, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y - Start, 3, 20, 45 )
	end

	local aV = math.sin( math.rad( math.sin( math.rad( math.max(((self:GetKillMarker() - T) / 0.2) * 90,0) ) ) * 90 ) )
	if aV > 0.01 then
		surface.SetDrawColor( 255, 255, 255, 15 * (aV ^ 4) )
		surface.DrawRect( 0, 0, ScrW(), ScrH() )

		local Start = 10 + aV * 40
		local End = 20 + aV * 45
		surface.SetDrawColor( 255, 0, 0, 255 )
		surface.DrawLine( scr.x + Start, scr.y + Start, scr.x + End, scr.y + End )
		surface.DrawLine( scr.x - Start, scr.y + Start, scr.x - End, scr.y + End ) 
		surface.DrawLine( scr.x + Start, scr.y - Start, scr.x + End, scr.y - End )
		surface.DrawLine( scr.x - Start, scr.y - Start, scr.x - End, scr.y - End ) 

		draw.NoTexture()
		surface.DrawTexturedRectRotated( scr.x + Start, scr.y + Start, 5, 20, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y + Start, 20, 5, 45 )
		surface.DrawTexturedRectRotated(  scr.x + Start, scr.y - Start, 20, 5, 45 )
		surface.DrawTexturedRectRotated( scr.x - Start, scr.y - Start, 5, 20, 45 )
	end
end

function ENT:PaintCrosshairCenter( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local Alpha = Col.a / 255
	local Shadow = Color( 0, 0, 0, 80 * Alpha )

	surface.DrawCircle( Pos2D.x, Pos2D.y, 4, Shadow )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 5, Col )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 6, Shadow )
end

function ENT:PaintCrosshairOuter( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local Alpha = Col.a / 255
	local Shadow = Color( 0, 0, 0, 80 * Alpha )

	surface.DrawCircle( Pos2D.x,Pos2D.y, 17, Shadow )
	surface.DrawCircle( Pos2D.x, Pos2D.y, 18, Col )

	if LVS.AntiAliasingEnabled then
		surface.DrawCircle( Pos2D.x, Pos2D.y, 19, Color( Col.r, Col.g, Col.b, 150 * Alpha ) )
		surface.DrawCircle( Pos2D.x, Pos2D.y, 20, Shadow )
	else
		surface.DrawCircle( Pos2D.x, Pos2D.y, 19, Shadow )
	end
end

local Circles = {
	[1] = {r = -1, col = Color(0,0,0,200)},
	[2] = {r = 0, col = Color(255,255,255,200)},
	[3] = {r = 1, col = Color(255,255,255,255)},
	[4] = {r = 2, col = Color(255,255,255,200)},
	[5] = {r = 3, col = Color(0,0,0,200)},
}

function ENT:LVSDrawCircle( X, Y, target_radius, value )
	local endang = 360 * value

	if endang == 0 then return end

	for i = 1, #Circles do
		local data = Circles[ i ]
		local radius = target_radius + data.r
		local segmentdist = endang / ( math.pi * radius / 2 )

		for a = 0, endang, segmentdist do
			surface.SetDrawColor( data.col )

			surface.DrawLine( X - math.sin( math.rad( a ) ) * radius, Y + math.cos( math.rad( a ) ) * radius, X - math.sin( math.rad( a + segmentdist ) ) * radius, Y + math.cos( math.rad( a + segmentdist ) ) * radius )
		end
	end
end

function ENT:PaintCrosshairSquare( Pos2D, Col )
	if not Col then
		Col = Color( 255, 255, 255, 255 )
	end

	local X = Pos2D.x + 1
	local Y = Pos2D.y + 1

	local Size = 20

	surface.SetDrawColor( 0, 0, 0, 80 )
	surface.DrawLine( X - Size, Y + Size, X - Size * 0.5, Y + Size )
	surface.DrawLine( X + Size, Y + Size, X + Size * 0.5, Y + Size )
	surface.DrawLine( X - Size, Y + Size, X - Size, Y + Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size, Y - Size * 0.5 )
	surface.DrawLine( X + Size, Y + Size, X + Size, Y + Size * 0.5 )
	surface.DrawLine( X + Size, Y - Size, X + Size, Y - Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size * 0.5, Y - Size )
	surface.DrawLine( X + Size, Y - Size, X + Size * 0.5, Y - Size )

	if Col then
		surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
	else
		surface.SetDrawColor( 255, 255, 255, 255 )
	end

	X = Pos2D.x
	Y = Pos2D.y

	surface.DrawLine( X - Size, Y + Size, X - Size * 0.5, Y + Size )
	surface.DrawLine( X + Size, Y + Size, X + Size * 0.5, Y + Size )
	surface.DrawLine( X - Size, Y + Size, X - Size, Y + Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size, Y - Size * 0.5 )
	surface.DrawLine( X + Size, Y + Size, X + Size, Y + Size * 0.5 )
	surface.DrawLine( X + Size, Y - Size, X + Size, Y - Size * 0.5 )
	surface.DrawLine( X - Size, Y - Size, X - Size * 0.5, Y - Size )
	surface.DrawLine( X + Size, Y - Size, X + Size * 0.5, Y - Size )
end
--addons/lvs_addons/lua/entities/lvs_base_turret/cl_init.lua:
include("shared.lua")
include("cl_camera.lua")
include("sh_camera_eyetrace.lua")
include("cl_hud.lua")
include("cl_deathsound.lua")

DEFINE_BASECLASS( "lvs_base" )

function ENT:Think()
	BaseClass.Think( self )

	self.EFxScale = self.EFxScale and (self.EFxScale - self.EFxScale * RealFrameTime()) or 0

	self:CalcOnThrottle()
end

function ENT:CalcOnThrottle()--[[
	if not self:GetEngineActive() then 
		self._oldOnTHR = nil

		return
	end

	local Throttle = self:GetThrottle()

	if self._oldOnTHR ~= Throttle then
		if self._oldOnTHR == 0 and Throttle > 0 then
			self._IsAccelerating = true
		end

		if Throttle > (self._oldOnTHR or 0) then
			self._IsAccelerating = true
		else
			self._IsAccelerating = false
		end

		if self._oldOnTHR == 1 then
			self:StopBoost()
		end

		self._oldOnTHR = Throttle
	end

	if self._oldAccelerating ~= self._IsAccelerating then
		self._oldAccelerating = self._IsAccelerating

		if not self._IsAccelerating then return end

		self:StartBoost()
	end]]
end

function ENT:StartBoost()--[[
	local T = CurTime()

	if (self._NextSND or 0) > T then return end

	self._NextSND = T + 1

	self.EFxScale = 100

	self:OnStartBoost()]]
end

function ENT:StopBoost()--[[
	local T = CurTime()

	if (self._NextSND or 0) > T then return end

	self._NextSND = T + 1

	self:OnStopBoost()]]
end

function ENT:GetBoost()
	--return (self.EFxScale or 0)
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end
--addons/lvs_addons/lua/entities/lvs_fakehover_hailfire/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "IG-227 Hailfire-class"
ENT.Author = "Dec"
ENT.Information = "IG-227 Hailfire-class droid tank"
ENT.Category = "AOCRP - KUS - Fahrzeuge"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/kingpommes/starwars/hailfire/hailfire_droid.mdl"
ENT.GibModels = {
	"models/kingpommes/starwars/hailfire/gib1.mdl",
	"models/kingpommes/starwars/hailfire/gib2.mdl",
	"models/kingpommes/starwars/hailfire/gib3.mdl",
}

ENT.AITEAM = 1

ENT.MaxVelocityY = 0
ENT.BoostAddVelocityY = 0

ENT.ForceAngleMultiplier = 4
ENT.ForceAngleDampingMultiplier = 4

ENT.ForceLinearMultiplier = 2
ENT.ForceLinearRate = 0.8

ENT.MaxVelocityZ = 0
ENT.BoostAddVelocityZ = 0

ENT.MaxHealth = 4500
ENT.MaxVelocityX = 650
ENT.BoostAddVelocitX = 850
ENT.IgnoreWater = false

ENT.MaxTurnRate = 0.8

ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

function ENT:InitWeapons()

	self.FirePositions = {
		Vector(300,-32,100),
		Vector(300,-42,100),
		Vector(300,59,100), 
		Vector(300,49,100),
	}

	self.RocketPositions = {
		Vector(275,-125,250),
		Vector(275,125,250),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 300
	weapon.Delay = 0.3
	weapon.HeatRateUp = 0.
	weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.RocketPositions then ent.NumPrim = 1 end

		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local dir = ent:GetAimVector()
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 100 then return true end

		for i = 1, 1 do
			timer.Simple( (i / 2) * 0.2, function()
				if not IsValid( ent ) then return end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()

				local trace = ent:GetEyeTrace()
				local Dir = (ent:GetEyeTrace().HitPos - self:GetAttachment(self:LookupAttachment("rocket" .. self.rocketnum)).Pos + self:GetForward() * 48):GetNormalized()
				local projectile = ents.Create( "lvs_hail_missile" )
				projectile:SetPos(self:GetAttachment(self:LookupAttachment("rocket" .. self.rocketnum)).Pos + self:GetForward() * 48)
				projectile:SetAngles( Dir:Angle() )
				projectile:SetParent( )
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-10,10) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:SetDamage( 800 )
				projectile:SetRadius( 450 )
				projectile:Enable()
				projectile:EmitSound( "KingPommes/starwars/hailfire/rocket.wav" )

				self.Rocket[self.rocketnum]:Remove()
				self.rocketnum = self.rocketnum + 1
			end)
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
		self:SetBodygroup(self:FindBodygroupByName( "rockets" ), 1)
	end
	self:AddWeapon(weapon)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.18
	weapon.Ammo = 3000
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 0.7
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

        local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local dir = ent:GetAimVector()
		if ent:AngleBetweenNormal(dir, ent:GetForward()) > 25 then return true end

		local trace = ent:GetEyeTrace()
		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local canon = self:GetAttachment(self:LookupAttachment("barrel"))

		local bullet = {}
		bullet.Src = canon.Pos
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_red_short"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 100
		bullet.Velocity = 12000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,0,0) ) 
			effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		ent:TakeAmmo()
		ent:LVSFireBullet(bullet)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 25) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon )
end

ENT.EngineSounds = {
	{
		sound = "ambient/machines/train_idle.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 110,
	},
	{
		sound = "ambient/machines/train_idle.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 70,
	},
	{
		sound = "hailfire_droid/engine_on.wav",
		Pitch = 40,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 40,
	},
}

sound.Add{ {
	name = "LVS.HAIL.FIRE_MISSILE",
	channel = CHAN_WEAPON,
	volume = 6.0,
	level = 3000,
	pitch = 105,
	sound = "KingPommes/starwars/hailfire/rocket.wav"
 } }

--addons/lvs_addons/lua/entities/lvs_fakehover_iftx/sh_turret.lua:

function ENT:FireTurret( weapon )
	local T = CurTime()

	if (weapon._NextFire or 0) > T then return end

	weapon._NextFire = T + 0.1

	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local bullet = {}
	bullet.Src 	= pos
	bullet.Dir 	= dir
	bullet.Spread 	= Vector( 0.035,  0.035, 0.035 )
	bullet.TracerName = "lvs_laser_blue_short"
	bullet.Force	= 100
	bullet.HullSize 	= 10
	bullet.Damage	= 10
	bullet.Velocity = 8000
	bullet.Attacker 	= weapon:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,50,255) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_impact", effectdata )
	end
	weapon:LVSFireBullet( bullet )

	weapon:EmitSound("lvs/vehicles/iftx/fire_turret.mp3", 85, 100 + math.cos( CurTime() * 0.5 + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1, CHAN_WEAPON )

	local effectdata = EffectData()
	effectdata:SetStart( Vector(50,50,255) )
	effectdata:SetOrigin( bullet.Src )
	effectdata:SetNormal( dir )
	effectdata:SetEntity( weapon )
	util.Effect( "lvs_muzzle_colorable", effectdata )
end

function ENT:CanUseBTL()
	return self:GetBodygroup(1) == 0
end

function ENT:CanUseTurret()
	return self:GetBodygroup(1) == 1
end

function ENT:TraceBTL()
	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:SetPoseParameterBTL( weapon )
	if self:GetIsCarried() then
		self:SetPoseParameter("turret_pitch", 0 )
		self:SetPoseParameter("turret_yaw",  0 )

		return
	end

	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	self:SetPoseParameter("turret_pitch", AimAng.p )
	self:SetPoseParameter("turret_yaw",  AimAng.y )
end

function ENT:InitTurret()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.3
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return true end

		if not base:CanUseBTL() then
			if not base:CanUseTurret() then return true end

			base:FireTurret( ent )

			return
		end

		local trace = base:TraceBTL()

		base:BallturretDamage( trace.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - ent:GetPos()):GetNormalized() )
	end
	weapon.StartAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		if not base:CanUseBTL() then return end

		base:SetBTLFire( true )

		if not IsValid( self.sndBTL ) then return end

		self.sndBTL:Play()
		self.sndBTL:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
	end
	weapon.FinishAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetBTLFire( false )

		if not IsValid( self.sndBTL ) then return end

		self.sndBTL:Stop()
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterBTL( ent )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		if not base:CanUseBTL() and not base:CanUseTurret() then return end

		local Pos2D = base:TraceBTL().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship/sh_ballturret_left.lua:

function ENT:SetPosBTL()
	local BTL = self:GetBTPodL()

	if not IsValid( BTL ) then return end

	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if Muzzle then
		local PosL = self:WorldToLocal( Muzzle.Pos + Muzzle.Ang:Right() * 28 - Muzzle.Ang:Up() * 65 )
		BTL:SetLocalPos( PosL )
	end
end

function ENT:TraceBTL()
	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:SetPoseParameterBTL( weapon )
	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	self:SetPoseParameter("ballturret_left_pitch", AimAng.p )
	self:SetPoseParameter("ballturret_left_yaw", AimAng.y )
end

function ENT:InitWeaponBTL()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.3
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not base._CanUseBT then return end

		local trace = base:TraceBTL()

		base:BallturretDamage( trace.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - ent:GetPos()):GetNormalized() )
	end
	weapon.StartAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not base._CanUseBT then return end

		base:SetBTLFire( true )

		if not IsValid( self.sndBTL ) then return end

		self.sndBTL:Play()
		self.sndBTL:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
	end
	weapon.FinishAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetBTLFire( false )

		if not IsValid( self.sndBTL ) then return end

		self.sndBTL:Stop()
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterBTL( ent )
		base:SetPosBTL()

		if not ent:GetAI() then return end

		local ID = base:LookupAttachment( "muzzle_ballturret_left" )
		local Muzzle = base:GetAttachment( ID )
		if not Muzzle then return end

		if ent:AngleBetweenNormal(Muzzle.Ang:Up(),ent:GetAimVector()) > 5 then
			ent:SetHeat( 1 )
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local ID = base:LookupAttachment( "muzzle_ballturret_left" )
		local Muzzle = base:GetAttachment( ID )

		if Muzzle then
			local Pos,Ang = LocalToWorld( Vector(0,25,-45), Angle(270,0,-90), Muzzle.Pos, Muzzle.Ang )

			view.origin = Pos
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceBTL().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )
end
--addons/laat_g/lua/entities/lvs_repulsorlift_gunship_heavy/cl_lights.lua:

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:RemoveLight()
	if IsValid( self.projector_L ) then
		self.projector_L:Remove()
		self.projector_L = nil
	end

	if IsValid( self.projector_R ) then
		self.projector_R:Remove()
		self.projector_R = nil
	end
end

function ENT:PostDrawTranslucent()
	if self:GetBodygroup( 5 ) ~= 1 or not self:GetLightsActive() then 
		self:RemoveLight()

		return
	end

	if not IsValid( self.projector_L ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 5000 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 40 )
		self.projector_L = thelamp
	end

	if not IsValid( self.projector_R ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 5000 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 40 )
		self.projector_R = thelamp
	end

	if not self.SpotlightID_L then
		self.SpotlightID_L = self:LookupAttachment( "spotlight_left" )
	else
		local attachment = self:GetAttachment( self.SpotlightID_L )

		if attachment then
			local StartPos = attachment.Pos
			local Dir = attachment.Ang:Up()

			render.SetMaterial( self.GlowMaterial )
			render.DrawSprite( StartPos + Dir * 20, 400, 400, Color( 255, 255, 255, 255) )

			render.SetMaterial( self.LightMaterial )
			render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 1500, 350, 0, 0.99, Color( 255, 255, 255, 10) ) 
			
			if IsValid( self.projector_L ) then
				self.projector_L:SetPos( StartPos )
				self.projector_L:SetAngles( Dir:Angle() )
				self.projector_L:Update()
			end
		end
	end

	if not self.SpotlightID_R then
		self.SpotlightID_R = self:LookupAttachment( "spotlight_right" )
	else
		local attachment = self:GetAttachment( self.SpotlightID_R )

		if attachment then
			local StartPos = attachment.Pos
			local Dir = attachment.Ang:Up()

			render.SetMaterial( self.GlowMaterial )
			render.DrawSprite( StartPos + Dir * 20, 400, 400, Color( 255, 255, 255, 255) )

			render.SetMaterial( self.LightMaterial )
			render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 1500, 350, 0, 0.99, Color( 255, 255, 255, 10 ) ) 

			if IsValid( self.projector_R ) then
				self.projector_R:SetPos( StartPos )
				self.projector_R:SetAngles( Dir:Angle() )
				self.projector_R:Update()
			end
		end
	end
end

function ENT:AnimLights()
	if self:GetBodygroup( 5 ) ~= 1 then return end

	local TargetValue = self:HitGround() and 0 or 1
	local Rate = FrameTime() * 10

	self.smSpotLight = isnumber( self.smSpotLight ) and (self.smSpotLight + math.Clamp(TargetValue - self.smSpotLight,-Rate,Rate * 0.1)) or 0

	if not self.SpotLightID_L then
		self.SpotLightID_L = self:LookupBone( "spotlight_left" ) 
	else
		self:ManipulateBoneAngles( self.SpotLightID_L, Angle(10,-30,5) * self.smSpotLight )	
	end

	if not self.SpotLightID_R then
		self.SpotLightID_R = self:LookupBone( "spotlight_right" ) 
	else
		self:ManipulateBoneAngles( self.SpotLightID_R, Angle(-10,30,5) * self.smSpotLight )	
	end
end
--addons/lvs_addons/lua/entities/lvs_starfighter_advdroid/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Trade Federation Droid Bomber"
ENT.Author = "Luna"
ENT.Information = "Droid Bomber of the Trade Federation"
ENT.Category = "AOCRP - KUS - Flugobjekte"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.MDL = "models/sfp_droidbomber/sfp_droidbomber.mdl"
ENT.GibModels = {
	"models/salza/vd_gib1.mdl",
	"models/salza/vd_gib2.mdl",
	"models/salza/vd_gib3.mdl",
	"models/salza/vd_gib4.mdl",
	"models/salza/vd_gib5.mdl",
}

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 1250

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(64,156,54),
		Vector(64,-156,54),
		Vector(64,156,42),
		Vector(64,-156,42)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 10
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 18
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 150, (ent._swapMissile and -50 or 50), 52 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetDamage( 800 )
		projectile:SetRadius( 350 )
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

sound.Add( {
	name = "LVS.VULTURE.FLYBY",
	sound = {"lvs/vehicles/vulturedroid/flyby.wav","lvs/vehicles/vulturedroid/flyby_a.wav","lvs/vehicles/vulturedroid/flyby_b.wav","lvs/vehicles/vulturedroid/flyby_c.wav"}
} )

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vulturedroid/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/vulturedroid/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 100,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_consulcharger/cl_init.lua:
include("shared.lua")


ENT.EngineFXPos = {
	Vector(-989.56,-623.28,218.72),
	Vector(-989.56,14.05,218.64),
	Vector(-989.56,623.28,218.55),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(833.19,-307.46,232.38), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(833.19,307.46,232.38), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(833.69,-307.43,196.78), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(833.69,307.43,196.78), 0, 20, 2, 2500, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 2000 + self:GetThrottle() * 40 + self:GetBoost() * 0.8

	render.SetMaterial( self.EngineGlow )
	render.DrawSprite( self:LocalToWorld( Vector(-989.56,-623.28,218.72) ), Size, Size, Color( 255,255,0) )
	render.DrawSprite( self:LocalToWorld( Vector(-989.56,14.05,218.64) ), Size, Size, Color(255,255,0) )
	render.DrawSprite( self:LocalToWorld( Vector(-989.56,623.28,218.55) ), Size, Size, Color( 255,255,0) )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, v in pairs( self.EngineFXPos ) do
		local Sub = Mirror and 1 or -1
		local vOffset = self:LocalToWorld( v )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(20,25) )
		particle:SetEndSize( math.Rand(0,50) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		
		particle:SetColor( 255, 172, 28 )
	end
end
function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/frigates/takeoff2.mp3", 500 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 120 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_ebonhawk/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Dynamic-class Freighter"
ENT.Author = "Nashatok"
ENT.Information = "Prototype bomber by the Nubian Design Collective, stolen and modified by pirates and other unsavories"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ehawk/ehawk1.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 1900
ENT.MaxThrust = 1900

ENT.TurnRatePitch = 0.8
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 0.8

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 750
ENT.MaxShield = 250

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "GunnerSeat" )
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(-55,395,85),
		Vector(-55,-395,85),
		Vector(-55,395,110),
		Vector(-55,-395,110)
	}
	
	--Weapon 1 - Heavy Laser Cannons
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = .5
	weapon.Attack = function( ent )
		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 4 then self.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 50
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
		
		ent:LVSFireBullet( bullet )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	--Gunner Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.15
	--weapon.HeatRateUp = 0.6
	--weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 60 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )

		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(-250,15,200) or Vector(-250,-15,200) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 25
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,150,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon, 2 )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "eng_jedistarfighter_hi_lp.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_havoc/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

ENT.RED = Color(255,0,0,255)
ENT.WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	local Pod = self:GetGunnerSeat()

	if Pod ~= ply:GetVehicle() then return true end

	local weapon = Pod:lvsGetWeapon()

	if not IsValid( weapon ) then return true end

	local Pos2D = weapon:GetEyeTrace().HitPos:ToScreen() 

	self:PaintCrosshairCenter( Pos2D, Col )
	self:PaintCrosshairOuter( Pos2D, Col )
	self:LVSPaintHitMarker( Pos2D )

	return true
end

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-95,220,24), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-95,-220,24), 0, 20, 2, 1000, 150 )
	
	self:RegisterTrail( Vector(-160,48,68), 0, 20, 2, 700, 150 )
	self:RegisterTrail( Vector(-160,-48,68), 0, 20, 2, 700, 150 )
end


function ENT:OnFrame()
	self:EngineEffects()
	self:AnimGunner()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()
	local Mirror = false

	render.SetMaterial( self.EngineGlow )

	for i = -1,1,2 do
		local pos = self:LocalToWorld( Vector(-120,20 * i,35) )
		render.DrawSprite( pos, Size, Size, Color( 255, 150, 0, 255) )
	end
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for i = -1,1,2 do
		local vOffset = self:LocalToWorld( Vector(-104.75,-20 * i,30) )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
				
		particle:SetColor( 255, 100, 200 )
	end
end

function ENT:AnimGunner()
	local Pod = self:GetGunnerSeat()

	if not IsValid( Pod ) then return end

	local weapon = Pod:lvsGetWeapon()

	if not IsValid( weapon ) then return end

	local EyeAngles = self:WorldToLocalAngles( weapon:GetAimVector():Angle() )
	EyeAngles:RotateAroundAxis( EyeAngles:Up(), 180 )

	local Yaw = math.Clamp( EyeAngles.y,-180,180)
	local Pitch = math.Clamp( EyeAngles.p,-180,180 )

	self:ManipulateBoneAngles( 1, Angle(-Yaw,0,0) )
	self:ManipulateBoneAngles( 2, Angle(0,0, math.max( Pitch, -25 ) ) )
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/boost.wav", 125 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/brake.wav", 125 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_repz95/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Clone Z-95"
ENT.Author = "Luna"
ENT.Information = "Variant of the Z-95 Headhunter designed for the Republic Navy"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/repz95/rep_z95_servius.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2500
ENT.MaxThrust = 2500

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 1600
ENT.MaxShield = 600

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(-45,-342,39),
		Vector(-45,342,39),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 30
		bullet.Damage	= 120
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 4
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 98, (ent._swapMissile and -25 or 25), 48 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 0.1 or -0.1,0) ) )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/arc170/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_vulturedroid/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-151,87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,87,-15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,-15), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineFXColor = Color( 38, 0, 230, 255)
ENT.EngineFxPos = {
	Vector(-49.5,-45.31,1.9),
	Vector(-47,-48.39,1.8),
	Vector(-45,-51.55,1.7),
	Vector(-43,-54.71,1.6),
	Vector(-41,-57.97,1.5),
	Vector(-39,-60.82,1.4),
	Vector(-49.5,45.31,1.9),
	Vector(-47,48.39,1.8),
	Vector(-45,51.55,1.7),
	Vector(-43,54.71,1.6),
	Vector(-41,57.97,1.5),
	Vector(-39,60.82,1.4),
	Vector(-49.5,-45.31,-1.9),
	Vector(-47,-48.39,-1.8),
	Vector(-45,-51.55,-1.7),
	Vector(-43,-54.71,-1.6),
	Vector(-41,-57.97,-1.5),
	Vector(-39,-60.82,-1.4),
	Vector(-49.5,45.31,-1.9),
	Vector(-47,48.39,-1.8),
	Vector(-45,51.55,-1.7),
	Vector(-43,54.71,-1.6),
	Vector(-41,57.97,-1.5),
	Vector(-39,60.82,-1.4),
}

function ENT:PostDraw()
	if not self:GetEngineActive() then return end

	cam.Start3D2D( self:LocalToWorld( Vector(-36.2,-62.6,0) ), self:LocalToWorldAngles( Angle(0,299,90) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( -11, -1.5, 19.7, 6 , -3.4 )
		surface.DrawTexturedRectRotated( -11, 1.5, 19.7, 6 , 3.4 )
	cam.End3D2D()

	cam.Start3D2D( self:LocalToWorld( Vector(-36.2,62.6,0) ), self:LocalToWorldAngles( Angle(0,61,-90) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( -11, -1.5, 19.7, 6 , -3.4 )
		surface.DrawTexturedRectRotated( -11, 1.5, 19.7, 6 , 3.4 )
	cam.End3D2D()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 30 + self:GetThrottle() * 15 + self:GetBoost() * 0.4

	render.SetMaterial( self.EngineGlow )

	for _, v in pairs( self.EngineFxPos ) do
		local pos = self:LocalToWorld( v )
		render.DrawSprite( pos, Size, Size, self.EngineFXColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_ywing/cl_init.lua:
include( "shared.lua" )
include( "cl_prediction.lua" )

ENT.EngineColor = Color( 255, 0, 0 , 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
    Vector( -633.16,239.81,58.68 ),
    Vector( -633.16,-239.81,58.68 )
}

function ENT:OnSpawn()
    self:RegisterTrail( Vector(-637.74, -295.15, 60.08), 0, 20, 2, 1000, 150)
    self:RegisterTrail( Vector(-637.74, 295.15, 60.08), 0, 20, 2, 1000, 150)
end

function ENT:OnFrame()
    self:EngineEffects()
    self:PredictPoseParameters()
end

function ENT:PreDraw()
    self:DrawDriverTopGunner()

    return true
end

function ENT:EngineEffects()
    if not self:GetEngineActive() then return end

    local T = CurTime()

    if (self.nextEFX or 0) > T then return end

    self.nextEFX = T + 0.1

    local emitter = self:GetParticleEmitter( self:GetPos() )

    if not IsValid(emitter) then return end

    for _, pos in pairs(self.EnginePos) do
        local vOffset = self:LocalToWorld(pos)
        local vNormal = -self:GetForward()

        vOffset = vOffset + vNormal * 55

        local particle = emitter:Add( "effects/muzzleflash2", vOffset )

        if not particle then continue end

        particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
        particle:SetLifeTime( 0 )
        particle:SetDieTime( 0.1 )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(50,100) )
        particle:SetEndSize( math.Rand(10,25) )
        particle:SetRoll( math.Rand(-1,1) * 100 )
        particle:SetColor( 255, 50, 0 )
    end
end

function ENT:PostDraw()
    if not self:GetEngineActive() then return end

    local Opacity = math.Clamp(120 + self:GetThrottle() * 100 + self:GetBoost() * 4, 0, 255)

    cam.Start3D2D( self:LocalToWorld( Vector( -613.53,239.71,58.69 ) ), self:LocalToWorldAngles( Angle( -90, 0, 0 ) ), 1)
        draw.NoTexture()
        surface.SetDrawColor( 255, 255 , 255 , Opacity)
        surface.DrawTexturedRectRotated(0, 0, 33.8, 33, 0)
    cam.End3D2D()

    cam.Start3D2D( self:LocalToWorld( Vector( -613.53,-239.71,58.69 ) ), self:LocalToWorldAngles( Angle( -90, 0, 0 ) ), 1)
        draw.NoTexture()
        surface.SetDrawColor( 255, 255 , 255 , Opacity)
        surface.DrawTexturedRectRotated(0, 0, 33.8, 33, 0)
    cam.End3D2D()
end

function ENT:PostDrawTranslucent()
    if not self:GetEngineActive() then return end

    local Size = 300 + self:GetThrottle() * 140 + self:GetBoost() * 4

    render.SetMaterial( self.EngineGlow )

    for _, pos in pairs( self.EnginePos ) do
        render.DrawSprite( self:LocalToWorld( pos ), Size, Size, self.EngineColor)
    end
end

function ENT:DrawDriverTopGunner()
    local pod = self:GetTopGunnerSeat()

    if not IsValid( pod ) then return end

    local plyL = LocalPlayer()
    local ply = pod:GetDriver()

    if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL and not pod:GetThirdPersonMode()) then return end


    local ID = self:LookupAttachment( "turret_muzzle_L" )
    local Muzzle = self:GetAttachment( ID )

    if not Muzzle then return end

    local _,Ang = LocalToWorld( Vector(0, 0, 0), Angle(90, 0, 0), Muzzle.Pos, Muzzle.Ang)

    local LAng = self:WorldToLocalAngles( Ang )

    LAng.p = 0
    LAng.r = 0


    ply:SetSequence( "sit_rollercoaster" )
    ply:SetRenderAngles( self:LocalToWorldAngles( LAng ) )
    ply:DrawModel()
end

function ENT:OnStartBoost()
    self:EmitSound( "lvs/vehicles/arc170/boost.wav", 85 )
end

function ENT:OnStopBoost()
    self:EmitSound( "lvs/vehicles/arc170/brake.wav", 85)
end
--addons/lvs_addons/lua/entities/lvs_starfighter_ywing/cl_prediction.lua:
function ENT:PredictPoseParameters()
    local Pod = self:GetTopGunnerSeat()

    if not IsValid( Pod ) then return end

    local plyL = LocalPlayer()
    local ply = Pod:GetDriver()

    if ply ~= plyL then return end

    self:SetPoseParameterTopGun( Pod:lvsGetWeapon() )

    self:InvalidateBoneCache()
end
--addons/lvs_addons/lua/entities/lvs_turbo_laser/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:OnSpawn()
end


--addons/lvs_addons/lua/entities/lvs_v19/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "V-19 Torrent"
ENT.Author = "Durian"
ENT.Information = ""
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/DiggerThings/v19/4.mdl"
ENT.GibModels = {
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2300
ENT.MaxThrust = 2300

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1.2
ENT.TurnRateYaw = 1.2
ENT.TurnRateRoll = 1.2

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 400
ENT.MaxShield = 0

ENT.GOZANTI_PICKUPABLE = true
ENT.GOZANTI_DROP_IN_AIR = true
ENT.GOZANTI_PICKUP_POS = Vector(0, 0, 0)
ENT.GOZANTI_PICKUP_Angle = Angle(0,0,0)

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "WingsDown" )

	if SERVER or CLIENT then
		self:NetworkVarNotify( "WingsDown", self.OnWingsChanged )
	end
end

function ENT:InitWeapons()

	self.FirePositions = {
		Vector(192.86,-387.4,-221.59),
		Vector(192.86,387.4,-221.59), 
	}

	local weapon = {}
		weapon.Icon = Material("lvs/weapons/mg.png")
		weapon.Ammo = 2000
		weapon.Delay = 0.1
		weapon.HeatRateUp = 0.3
		weapon.HeatRateDown = 0.5
		weapon.Attack = function( ent )
			if not self:GetWingsDown(true) then 
				ent:SetHeat( ent:GetHeat() * 0 )
				return
			end
				ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
				if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

			local pod = ent:GetDriverSeat()

			if not IsValid( pod ) then return end

			local startpos = pod:LocalToWorld( pod:OBBCenter() )
			local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
			} )

			local bullet = {}
			bullet.Src  = ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
			bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
			bullet.TracerName = "lvs_laser_blue"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 20
			bullet.Velocity = 80000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,50,225) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end
			ent:LVSFireBullet( bullet )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,50,225) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:TakeAmmo()

			ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/tie/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
		weapon.Icon = Material("lvs/weapons/dual_mg.png")
		weapon.Ammo = 2500
		weapon.Delay = 0.25
		weapon.HeatRateUp = 0.3
		weapon.HeatRateDown = 0.5
		weapon.Attack = function( ent )
			if not self:GetWingsDown(true) then 
				ent:SetHeat( ent:GetHeat() * 0 )
				return
			end
			local pod = ent:GetDriverSeat()

			if not IsValid( pod ) then return end

			local startpos = pod:LocalToWorld( pod:OBBCenter() )
			local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
			} )
			
			local bullet = {}
			bullet.Dir 	= ent:GetForward()
			bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
			bullet.TracerName = "lvs_laser_blue"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 20
			bullet.Velocity = 80000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,50,225) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end
			
			for i = -1,1,2 do
				bullet.Src 	= ent:LocalToWorld( Vector(192.86,387.4 * i,-221.59) )
				bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()

				local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,225) )
				effectdata:SetOrigin( bullet.Src )
				effectdata:SetNormal( ent:GetForward() )
				effectdata:SetEntity( ent )
				util.Effect( "lvs_muzzle_colorable", effectdata )

				ent:LVSFireBullet( bullet )
			end

			ent:TakeAmmo()

			ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/shuttle/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
		weapon.Icon = Material("lvs/weapons/concussionmissile.png")
		weapon.Ammo = 20
		weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
		weapon.HeatRateUp = -0.25 -- cool down when attack key is held. This system fires on key-release.
		weapon.HeatRateDown = 0.25
		weapon.Attack = function( ent )
			if not self:GetWingsDown(true) then 
				ent:SetHeat( ent:GetHeat() * 0 )
				return
			end
			local T = CurTime()

			if IsValid( ent._ConcussionMissile ) then
				if (ent._nextMissleTracking or 0) > T then return end

				ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

				ent._ConcussionMissile:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

				return
			end

			if (ent._nextMissle or 0) > T then return end

			ent._nextMissle = T + 0.5

			ent._swapMissile = not ent._swapMissile

			local Pos = Vector( 192.86, (ent._swapMissile and -387.4 or 387.4), -221.59 )

			local Driver = self:GetDriver()

			local projectile = ents.Create( "lvs_protontorpedo" )
			projectile:SetPos( ent:LocalToWorld( Pos ) )
			projectile:SetAngles( ent:GetAngles() )
			projectile:SetParent( ent )
			projectile:Spawn()
			projectile:Activate()
			projectile:SetAttacker( IsValid( Driver ) and Driver or self )
			projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
			projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )
			projectile:SetDamage( 800 )
			projectile:SetRadius( 300 )

			ent._ConcussionMissile = projectile

			ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
		end
		weapon.FinishAttack = function( ent )
			if not IsValid( ent._ConcussionMissile ) then return end

			local projectile = ent._ConcussionMissile

			projectile:Enable()
			projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
			ent:TakeAmmo()

			ent._ConcussionMissile = nil

			local NewHeat = ent:GetHeat() + 0.75

			ent:SetHeat( NewHeat )
			if NewHeat >= 1 then
				ent:SetOverheated( true )
			end
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/imperial/overheat.wav") end
	self:AddWeapon( weapon )

	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/vwing/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vwing/loop.wav",
		sound_int = "lvs/vehicles/vwing/loop_interior.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
}
--addons/lvs_addons/lua/entities/lvs_walker_atte/cl_ikfunctions.lua:

function ENT:OnRemoved()
	self:LegClearAll()
end

local debugred = Color(255,0,0,255)
local debugblue = Color(0,0,255,255)
local debuggreen = Color(0,255,0,255)

function ENT:LegClearAll()
	if istable( self.IK_Joints ) then 
		for _, tab in pairs( self.IK_Joints ) do
			for _,prop in pairs( tab ) do
				if IsValid( prop ) then
					prop:Remove()
				end
			end
		end
		
		self.IK_Joints = nil
	end
end

function ENT:GetLegEnts( index, L1, L2, JOINTANG, STARTPOS, ENDPOS, ATTACHMENTS )
	if not istable( self.IK_Joints ) then self.IK_Joints = {} end

	if self.IK_Joints[ index ] then
		if IsValid( self.IK_Joints[ index ].LegBaseRot ) and IsValid( self.IK_Joints[ index ].LegRotCalc ) then
			if (self.IK_Joints[ index ].LegBaseRot:GetPos() - STARTPOS):Length() > 1 or (self.IK_Joints[ index ].LegRotCalc:GetPos() - STARTPOS):Length() > 1 then
				for k, v in pairs( self.IK_Joints[ index ] ) do
					if IsValid( v ) then
						v:Remove()
					end
				end
				self.IK_Joints[ index ] = nil
			end
		end
	end

	if not self.IK_Joints[ index ] then
		self.IK_Joints[ index ] = {}

		local BaseProp = ents.CreateClientProp()
		BaseProp:SetPos( STARTPOS )
		BaseProp:SetAngles( JOINTANG )
		BaseProp:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		BaseProp:SetParent( self )
		BaseProp:Spawn()

		local LegRotCalc = ents.CreateClientProp()
		LegRotCalc:SetPos( STARTPOS )
		LegRotCalc:SetAngles( JOINTANG )
		LegRotCalc:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		LegRotCalc:SetParent( self )
		LegRotCalc:Spawn()

		local prop1 = ents.CreateClientProp()
		prop1:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 * 0.5) ) )
		prop1:SetAngles( JOINTANG )
		prop1:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop1:SetParent( self )
		prop1:Spawn()

		local prop2 = ents.CreateClientProp()
		prop2:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1 + L2) ) )
		prop2:SetAngles( JOINTANG )
		prop2:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop2:SetParent( self )
		prop2:Spawn()

		local prop3 = ents.CreateClientProp()
		prop3:SetPos( STARTPOS )
		prop3:SetAngles( JOINTANG )
		prop3:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop3:SetParent( LegRotCalc )
		prop1:SetParent( prop3 )
		prop3:Spawn()

		local prop4 = ents.CreateClientProp()
		prop4:SetPos( BaseProp:LocalToWorld( Vector(0,0,L1) ) )
		prop4:SetAngles( JOINTANG )
		prop4:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		prop4:SetParent( prop1 )
		prop2:SetParent( prop4 )
		prop4:Spawn()
		
		self.IK_Joints[ index ].LegBaseRot = BaseProp
		self.IK_Joints[ index ].LegRotCalc = LegRotCalc
		self.IK_Joints[ index ].LegEnt1 = prop1
		self.IK_Joints[ index ].LegEnt2 = prop2
		self.IK_Joints[ index ].LegEnt3 = prop3
		self.IK_Joints[ index ].LegEnt4 = prop4

		for _, v in pairs( self.IK_Joints[ index ] ) do
			v:SetColor( Color( 0, 0, 0, 0 ) )
			v:SetRenderMode( RENDERMODE_TRANSALPHA )
		end

		if ATTACHMENTS then
			if ATTACHMENTS.Leg1 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop3:LocalToWorld( ATTACHMENTS.Leg1.Pos ) )
				prop:SetAngles( prop3:LocalToWorldAngles( ATTACHMENTS.Leg1.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg1.MDL )
				prop:SetParent( prop3 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment1 = prop
			end
			if ATTACHMENTS.Leg2 then
				local prop = ents.CreateClientProp()
				prop:SetPos( prop4:LocalToWorld( ATTACHMENTS.Leg2.Pos ) )
				prop:SetAngles( prop4:LocalToWorldAngles( ATTACHMENTS.Leg2.Ang ) )
				prop:SetModel( ATTACHMENTS.Leg2.MDL )
				prop:SetParent( prop4 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment2 = prop
			end
			if ATTACHMENTS.Foot then
				local prop = ents.CreateClientProp()
				prop:SetModel( ATTACHMENTS.Foot.MDL )
				prop:SetParent( prop2 )
				prop:Spawn()
				self.IK_Joints[ index ].Attachment3 = prop
			end
		end
	end

	if not IsValid( self.IK_Joints[ index ].LegRotCalc ) or not IsValid( self.IK_Joints[ index ].LegBaseRot ) or not IsValid( self.IK_Joints[ index ].LegEnt1 ) or not IsValid( self.IK_Joints[ index ].LegEnt2 ) or not IsValid( self.IK_Joints[ index ].LegEnt3 ) or not IsValid( self.IK_Joints[ index ].LegEnt4 ) then
		self:LegClearAll()

		return
	end

	self.IK_Joints[ index ].LegRotCalc:SetAngles(self.IK_Joints[ index ].LegBaseRot:LocalToWorldAngles( self.IK_Joints[ index ].LegBaseRot:WorldToLocal( ENDPOS ):Angle() ) )

	local LegRotCalcPos = self.IK_Joints[ index ].LegRotCalc:GetPos()

	local Dist = math.min( (LegRotCalcPos - ENDPOS ):Length(), L1 + L2)
	local Angle1 = 90 - math.deg( math.acos( (Dist ^ 2 + L1 ^ 2 - L2 ^ 2) / (2 * Dist * L1) ) )
	local Angle2 = math.deg( math.acos( (Dist ^ 2 + L2 ^ 2 - L1 ^ 2) / (2 * Dist * L2) ) ) + 90

	self.IK_Joints[ index ].LegEnt3:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle1,180,180) ) )
	self.IK_Joints[ index ].LegEnt4:SetAngles( self.IK_Joints[ index ].LegRotCalc:LocalToWorldAngles( Angle(Angle2,180,180) ) )

	if self.IK_Joints[ index ].Attachment3 then
		self.IK_Joints[ index ].Attachment3:SetAngles( self:LocalToWorldAngles( ATTACHMENTS.Foot.Ang ) )
		self.IK_Joints[ index ].Attachment3:SetPos(self.IK_Joints[ index ].LegEnt2:GetPos() + self:GetForward() * ATTACHMENTS.Foot.Pos.x  + self:GetRight() * ATTACHMENTS.Foot.Pos.y + self:GetUp() * ATTACHMENTS.Foot.Pos.z )
	end


	--debug code
	local RFT = RealFrameTime()
	debugoverlay.Cross( self.IK_Joints[ index ].LegBaseRot:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegRotCalc:GetPos(), self.IK_Joints[ index ].LegEnt4:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt4:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Line( self.IK_Joints[ index ].LegEnt4:GetPos(), self.IK_Joints[ index ].LegEnt2:GetPos(), RFT, debuggreen, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt2:GetPos(), 15, RFT, debugred, true )
	debugoverlay.Cross( self.IK_Joints[ index ].LegEnt1:GetPos(), 4, RFT, debugblue, true )
	debugoverlay.Sphere( self.IK_Joints[ index ].LegEnt3:GetPos(), 10, RFT, debugblue, true )
end

--addons/lvs_addons/lua/entities/lvs_zakheavy_swtor/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-151,87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,87,-15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,-15), 0, 20, 2, 1000, 150 )
end

ENT.EngineColor = Color( 255, 174, 0)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-299.79,244.61,103.28),
	Vector(-299.79,-244.61,103.28),
	Vector(-288.98,266.67,159.5),
	Vector(-288.98,-266.67,159.5),
}

function ENT:OnFrame()
	self:EngineEffects()
end


function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 240 - self:GetUp() * 30, angles, fov
	end

	return pos, angles, fov
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineFXColor = Color( 255,0,0, 255)
ENT.EngineFxPos = {
	Vector(-77,321,43),
	Vector(-76,-321,43),
}

function ENT:PostDraw()
	if not self:GetEngineActive() then return end
 
 
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.6)
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 187, 255, 0)
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 30 + self:GetThrottle() * 15 + self:GetBoost() * 0.4

	render.SetMaterial( self.EngineGlow )

	for _, v in pairs( self.EngineFxPos ) do
		local pos = self:LocalToWorld( v )
		render.DrawSprite( pos, Size, Size, self.EngineFXColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "ophra/ships/powerstart3.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "ophra/ships/shutdown.wav", 85 )
end


--addons/weapons_other/lua/entities/model_base.lua:
AddCSLuaFile()

--[[
	An entity base that allows you to create entity that can be equipped by the player as if they were weapons or powerups, but that can still
	function when not picked up by a player

	For instance you could make a jetpack that flies off when the equipping player dies, or you can make a controllable plane but still allow
	full movement on the player

	This file is licensed under the MIT license, so go nuts.
]]

DEFINE_BASECLASS( "base_entity" )

ENT.UseNWVars = false

ENT.Spawnable = false
ENT.IsPredictedEnt = true
ENT.AttachesToPlayer = true	--whether this entity attaches to the player or not, when true this removes physics and draws the entity on the player

ENT.SaveButtonToCvar = false

if SERVER then
	ENT.DropOnDeath = false
	ENT.ShowPickupNotice = true	--plays the pickup sound and shows the pickup message on the hud
	ENT.DontTransmitToOthers = false --when true, don't transmit to anyone except the owner, this MIGHT conflict with addons that make use of SetPreventTransmit, so mind that!
	ENT.ShouldLagCompensate = true 	--automatically enables/disables lag compensation when physics are created and destroyed, might be annoying for some so disable this if you want
else
	ENT.RenderGroup = RENDERGROUP_OPAQUE
end

ENT.Editable = false

ENT.KeyAllowedKeyboard = 2 ^ 0
ENT.KeyAllowedMouse = 2 ^ 1
ENT.KeyAllowedJoystick = 2 ^ 2

ENT.KeyAllowedAll = bit.bor( ENT.KeyAllowedKeyboard , ENT.KeyAllowedMouse , ENT.KeyAllowedJoystick )

ENT.KeyAllowedFlags = ENT.KeyAllowedAll	--bitflag of the key types you want to use

ENT.HookAlways = 1 --hooks in here always run
ENT.HookEquipped = 2 --hooks in here are only added when the entity is equipped by user, and removed when unequipped
ENT.HookEquippedPrediction = 3 --like above, but on the client, only for the LocalPlayer() equipping this
ENT.HookCallback = 4 --these are callbacks handled with AddCallback, unfortunately we have no way to fully handle these

--example attachment info table, only used if AttachesToPlayer is true
--[[
ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 3 , -5.6 , 0 ),
	OffsetAng = Angle( 180 , 90 , -90 ),
}
]]

--[[
	This is a wrapper for NetworkVars/DTVars (same thing) so we can handle their slots properly for child classes instead
	of having to modify them manually everytime something changes in order

	This could be switched to NWVars2 (vinh vars) but then I would have to hack in support for right-click editing, since that's
	based on NetworkVars and some other getters
]]
function ENT:DefineNWVar( dttype , dtname , editable , beautifulname , minval , maxval , customelement , filt )

	if not self.DefinedDTVars[dttype] then
		Error( "Wrong NWVar type " .. ( dttype or "nil" ) )
		return
	end

	local index = -1

	--only do this check for limited dtvars, once we switch to NWVars in :NetworkVar this check will go away
	if not self.UseNWVars then
		local maxindex = self.DefinedDTVars[dttype].Max

		for i = 0 , maxindex - 1 do
			--we either didn't find anything in this slot or we found the requested one again
			--in which case just override it again, someone might want to inherit and add an edit table or something
			if not self.DefinedDTVars[dttype][i] or self.DefinedDTVars[dttype][i] == dtname then
				index = i
				break
			end
		end

		if index == -1 then
			Error( "Not enough slots on "..dttype .. ",	could not add ".. dtname )
			return
		end
	else
		index = dtname:lower()
	end

	self.DefinedDTVars[dttype][index] = dtname

	local edit = nil

	--this used to check if we could actually add the edit table, so we default it to nil to override it again
	--in case of a child class

	if editable then
		edit = {
			KeyName = dtname:lower(),
			Edit = {
				title = beautifulname or dtname,	--doesn't it do this internally already?
				min = minval,
				max = maxval,
				type = customelement or self.DefinedDTVars[dttype].EditableElement,
			}
		}
	end

	self:NetworkVar( dttype , index , dtname , edit )
end

function ENT:SetupDataTables()

	--if the user is in the branch that has the NWVars change then automatically switch to this
	if self.CallNetworkProxies then
		self.UseNWVars = true
	end

	--eventually I'll create more editable elements based on garry's system

	self.DefinedDTVars = {
		Entity = {
			Max = GMOD_MAXDTVARS,
		},
		Float = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Float",
		},
		Int = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Int",
		},
		Bool = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Boolean",
		},
		Vector = {
			Max = GMOD_MAXDTVARS,
		},
		Angle = {
			Max = GMOD_MAXDTVARS,
		},
		String = {
			Max = 4,
			EditableElement = "Generic",
		},
	}

	self:DefineNWVar( "Entity" , "ControllingPlayer" )
	self:DefineNWVar( "Bool" , "BeingHeld" )
	self:DefineNWVar( "String" , "SlotName" )
	self:DefineNWVar( "Float" , "NextFire" ) --similar to primaryattack on a weapon

	--only allow the user to modify the button if the coder wants this entity to have an usable key

	self:DefineNWVar( "Int" , "Key" , true , "Button" , BUTTON_CODE_NONE + 1 , BUTTON_CODE_LAST , "EditKey" )
	self:DefineNWVar( "Bool" , "KeyPressed" )
end

function ENT:Initialize()

	self.HandledHooks = {
		[self.HookAlways] = {},
		[self.HookEquipped] = {},
		[self.HookEquippedPrediction] = {},
		[self.HookCallback] = {}
	}

	self.HookConditions = {
		[self.HookAlways] = function( ent )
			return true
		end,
		[self.HookEquipped] = function( ent )
			return ent:IsCarried()
		end,
		[self.HookEquippedPrediction] = function( ent )
			if SERVER then
				return ent:IsCarried() --self.HookConditions[self.HookEquipped]( self )
			else
				return ent:IsCarriedByLocalPlayer()
			end
		end,
		[self.HookCallback] = function( self )
			return nil --nil means don't handle me
		end,
	}

	--predicted hooks hooking with hookers and futurama memes
	self:InstallHook( "StartCommand" , self.HandlePredictedStartCommand , self.HookEquippedPrediction )
	self:InstallHook( "SetupMove" , self.HandlePredictedSetupMove , self.HookEquippedPrediction )
	self:InstallHook( "Move" , self.HandlePredictedMove , self.HookEquippedPrediction )
	self:InstallHook( "PlayerTick" , self.HandlePredictedThink , self.HookEquippedPrediction )
	self:InstallHook( "FinishMove" , self.HandlePredictedFinishMove , self.HookEquippedPrediction )
	self:InstallHook( "OnPlayerHitGround" , self.HandlePredictedHitGround , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonDown" , self.HandlePlayerButtonDown , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonUp" , self.HandlePlayerButtonUp , self.HookEquippedPrediction )


	self:InstallHook( "CalcMainActivity" , self.HandleCalcMainActivity , self.HookEquipped )
	self:InstallHook( "UpdateAnimation" , self.HandleUpdateAnimation , self.HookEquipped )
	self:InstallHook( "DoAnimationEvent" , self.HandleAnimationEvent , self.HookEquipped )


	if SERVER then
		self:InstallHook( "SetupPlayerVisibility" , self.HandleEntityVisibility , self.HookAlways )
		self:InstallHook( "EntityRemoved" , self.OnControllerRemoved , self.HookAlways )
		self:InstallHook( "PostPlayerDeath" , self.OnControllerDeath , self.HookAlways )	--using PostPlayerDeath as it's called on all kind of player deaths, even :KillSilent()
		self:InstallHook( "CanEditVariable" , self.HandleCanEditVariable , self.HookAlways )

		--just in case it has been spawned manually and the coder forgot
		if self:GetSlotName() == "" then
			ErrorNoHalt( self:GetClass() .. " was spawned without a slotname!!!!. Defaulting to classname\n" )
			self:SetSlotName( self:GetClass() )
		end

		self:SetUseType( SIMPLE_USE )
		self:SetKey( BUTTON_CODE_NONE )
	else
		self:InstallHook( "PreDrawEffects" , self.DrawFirstPersonInternal , self.HookEquipped )
		self:InstallHook( "PostDrawViewModel" , self.DrawViewModelInternal , self.HookEquipped )
		self:InstallHook( "PostPlayerDraw" , self.DrawOnPlayer , self.HookEquipped )

		self:InstallHook( "NotifyShouldTransmit" , self.HandleFullPacketUpdate , self.HookAlways )

		language.Add( self:GetClass() , self.PrintName )
		language.Add( "dropped_"..self:GetClass() , "Dropped "..self.PrintName )
	end
end

--This is needed mostly for clientside hooks, since IsValid might return false when we're out of PVS with some bad lag
--and when hook.Call tries to call on an invalid entity it removes the hook, so we need to reinstall them when that happens and the entity gets back in the PVS
--prediction and other shit like drawing on a player might fuck up since the hooks got removed
--Now this also works for adding a callback

function ENT:InstallHook( hookname , handler , hooktype )

	if self.HandledHooks[hooktype] == nil then
		hooktype = self.HookAlways
	end

	self.HandledHooks[hooktype][hookname] = handler

	if hooktype == self.HookCallback then
		self:AddCallback( hookname , handler )
	end

end

function ENT:HandleHooks( cleanup )

	--this is direct access to the hook table, but it's not slow at all
	--or at least, it shouldn't be as long as you don't have any ulib shit or some other hook overrides
	local hooktable = hook.GetTable()



	for hookindex , handledshooktab in pairs( self.HandledHooks ) do
		local condition = self.HookConditions[hookindex]( self )

		if condition ~= nil then
			for i , v in pairs( handledshooktab ) do
				if condition and not cleanup then
					if not hooktable[i] or not hooktable[i][self] then
						hook.Add( i , self , v )
					end
				else
					if hooktable[i] and hooktable[i][self] then
						hook.Remove( i , self )
					end
				end
			end
		end
	end

end

function ENT:Think()

	self:HandleHooks()

	if SERVER then

		--check if this guy is still my parent and owner, maybe something is forcibly unparenting us from him, if so, drop
		if self.AttachesToPlayer and self:IsCarried() then
			if not self:IsAttached() then
				self:Remove( true )
			end
		end

		--we have to network this ourselves since it's based on the physics object ( which is mainly serverside )
		--the reason I'm networking this is that due to the gravity gun enabling prediction, it would screw with the manual
		--predictable logic of this entity, so when we try to activate prediction, we check if we're being carried by the gravity gun
		--to prevent disabling it

		--NOTE: this is not as expensive as it looks, it just checks for the FVPHYSICS_PLAYER_HELD flag on our physobj
		self:SetBeingHeld( self:IsPlayerHolding() )
	else
		--calling this in a non-predicted hook is perfectly fine, since we need the entity to enable prediction on its own
		--even when controlling players change

		--Ideally this would be handled on the callback of SetControllingPlayer clientside, but we don't have that yet
		self:HandlePrediction()
		self:HandleButtonBind()
		self:HandleContextMenuButton()
		self:InternalHandleLoopingSounds()
	end

	--set our think rate to be in line with the server tickrate
	--this may also affect animations clientside if they're ran in this hook, considering that also happens in normal source
	--I'd say that's an accurate replication of the issue

	--default behaviour for scripted entities is to think every 200 milliseconds
	--I suppose this should be configurable by child entities

	self:NextThink( CurTime() + engine.TickInterval() )
	return true
end

if SERVER then

	--for map inputs mostly, but other addons may also be using these inputs trough ent:Input or ent:Fire
	--more inputs might come in the future
	--of course child entities are free to call the baseclass function after their own to chain stuff

	function ENT:AcceptInput( inputName, activator, called, data )

		if inputName == "Drop" then
			self:Drop( true )
			return true
		end

		if inputName == "SetSlotName" then
			if self:IsCarried() or not data or #data <= 1 or data == self:GetSlotName() then
				return false
			end

			self:SetSlotName( data )
			return true
		end

	end

	--although we should probably do validity checks on them first, but considering this would *probably* be called from maps it should be ok
	--copied from env_skypaint, allows to have the DT vars set as if they were key values

	function ENT:KeyValue( key, value )

		if self:SetNetworkKeyValue( key, value ) then
			return
		end

	end

	function ENT:ChangeSlot( newslotname )
		local oldslotname = self:GetSlotName()

		if newslotname == oldslotname then
			return false
		end

		local ply = self:GetControllingPlayer()

		--if we have a controlling player and he has an entity in the new slot, abort
		if IsValid( ply ) and IsValid( self.GetOnPlayer( ply , newslotname ) ) then
			--this slot is already occupied!!!
			return false
		end

		if IsValid( ply ) then
			self.SetOnPlayer( ply , oldslotname , NULL )
			self.SetOnPlayer( ply , newslotname , self )
		end

		self:SetSlotName( newslotname )

		return true
	end

	--useful for swapping out two slots at the same time and knowing the other entity,
	--usually in an inventory system
	function ENT:SwapSlotWith( predent )
		local ply = self:GetControllingPlayer()

		if not self:IsCarriedBy( ply ) or not IsValid( predent ) or not predent.IsPredictedEnt
		or not predent:IsCarriedBy( ply ) then
			return false
		end

		local myslot = self:GetSlotName()
		local otherslot = predent:GetSlotName()

		self.SetOnPlayer( ply , otherslot , self )
		self.SetOnPlayer( ply , myslot , predent )

		self:SetSlotName( otherslot )
		predent:SetSlotName( myslot )

		return true
	end

	--override this if you want your equip logic to be different
	function ENT:Use( activator, caller, useType, value )
		if not self:Attach( activator ) then
			self:EmitPESound( "HL2Player.UseDeny" , 150 , nil , 1 , nil , nil , activator )
		end
	end

	function ENT:InitPhysics()
		--don't actually initialize the physics if we're getting removed anyway
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end


		if self.ShouldLagCompensate then
			self:SetLagCompensated( true )
		end

		self:DoInitPhysics()
		self:OnInitPhysics( self:GetPhysicsObject() )
	end

	function ENT:DoInitPhysics()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysWake()
	end

	function ENT:RemovePhysics()

		if self.AttachesToPlayer and self.ShouldLagCompensate then
			self:SetLagCompensated( false )	--entities that are attached to players will be moved back when the player is, so don't make them lag compensate on their own
		end

		self:OnRemovePhysics( self:GetPhysicsObject() )
		self:DoRemovePhysics()
	end

	function ENT:DoRemovePhysics()
		self:PhysicsDestroy()
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
	end

	function ENT:OnAttach( ply , forced )
		--override me
	end

	function ENT:CanAttach( ply )
		--override me
	end

	function ENT:OnDrop( ply , forced )
		--override me
	end

	function ENT:CanDrop( ply )
		--override me
	end

	--these two are not necessarely duplicates of the functions above because we may want to modify the mass
	--as soon as the physobj gets created, and that also happens in initialize

	function ENT:OnInitPhysics( physobj )
		--override me
	end

	function ENT:OnRemovePhysics( physobj )
		--override me
	end

	--being attached forcibly is usually something that happens when you want to spawn the player with this item, and you
	--don't want gamemode logic to interfere with it
	function ENT:Attach( activator , forced )

		--we were forced to attach to this player, so drop first to clear out some values
		if forced then
			self:Remove( forced )
		end

		if not IsValid( activator ) or not activator:IsPlayer() then
			return false
		end

		--we're carried in general OR that guy's using that slot already
		if self:IsCarried() or IsValid( self.GetOnPlayer( activator , self:GetSlotName() ) ) then
			return false
		end

		--we can allow the coder or gamemode to only stop the pickup if it's not forced
		if not forced then
			--simulate ourselves being a normal item pickup
			--the reason we're asking this first, is that first we want to make sure the gamemode is OK with us being able to pickup this entity
			local canattach = hook.Run( "PlayerCanPickupItem" , activator , self )

			--THEN we ask the coder if he really wants us to pickup his entity, in case it's out of "ammo", or some other restrictions
			local mycanattach = self:CanAttach( activator )
			if mycanattach == false then
				canattach = mycanattach
			end

			if canattach == false then
				return canattach
			end
		end

		if self.AttachesToPlayer then
			self:RemovePhysics()
			self:SetParent( activator )
			self:SetOwner( activator )
			self:SetTransmitWithParent( true )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck of the transmission, so UpdateTransmitState() is called right away
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( true )
			end
			]]

			self:SetNoDraw( true )
			self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		self:SendItemMessage( activator , false )

		self.SetOnPlayer( activator , self:GetSlotName() , self )
		self:SetControllingPlayer( activator )

		--if the player has a customized key for this entity, use that instead
		--we do this here so that OnAttach can make use of it

		--this also allows us to prevent the key from another user to be written clientside and override ours
		if self.SaveButtonToCvar then
			local plykey = self:GetControllingPlayerConVarKey()

			if self:IsKeyAllowed( plykey ) and plykey ~= self:GetKey() then
				self:SetKey( plykey )
			end
		end

		--THIS IS VERY SUBJECTIVE
		self:SetKeyPressed( false ) --only reset the button press state when equipped

		self:OnAttach( activator , forced )
		return true
	end

	function ENT:Drop( forced )

		--we can allow the coder to only stop the drop if it's not forced
		if not forced then
			local candrop = self:CanDrop( self:GetControllingPlayer() )

			if candrop == false then
				return candrop
			end
		end

		if self.AttachesToPlayer then
			self:SetParent( NULL )
			self:SetOwner( NULL )
			self:InitPhysics()
			self:SetTransmitWithParent( false )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck during a drop
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( false )
			end
			]]

			self:SetNoDraw( false )
			self:RemoveEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		if not forced and self:IsCarried() then
			self:SendItemMessage( self:GetControllingPlayer() , true )
		end

		--only call OnDrop if we had a player controlling us, don't do it if we were just sweeping up some unclean values
		if self:IsCarried() then
			self:OnDrop( self:GetControllingPlayer() , forced )
			self.SetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() , NULL )
		end

		self:SetControllingPlayer( NULL )
		return true
	end

	function ENT:SendItemMessage( activator , dropped )
		if dropped == nil then
			dropped = false
		end
		--GetShouldPlayPickupSound is actually a Lua table value that is then checked in c++, so it starts out as nil, wow garry
		if self.ShowPickupNotice and ( self:GetShouldPlayPickupSound() == nil or self:GetShouldPlayPickupSound() ) then

			if not dropped then
				self:EmitSound( "HL2Player.PickupWeapon" )
			else
				self:EmitSound( "Weapon_Crowbar.Single" )
			end

			if not activator:IsPlayer() or not activator:IsBot() then
				net.Start( "pe_pickup" )
					net.WriteString( self:GetClass() )
					net.WriteBit( dropped )
				net.Send( activator )
			end
		end
	end

	--we want to get properly dropped when the player entity gets removed ( aka after a disconnect )
	--why not use the disconnect hook? no.

	function ENT:OnControllerRemoved( ent )
		if self:IsCarriedBy( ent ) then
			self:Remove( true )
		end
	end

	function ENT:OnControllerDeath( ply )
		if self.DropOnDeath and self:IsCarriedBy( ply ) then
			self:Remove( true )
		end
	end

	--we're redoing this even though it's hooked up in sandbox because someone might want to use this in another gamemode ( such as ttt or whatever )
	function ENT:HandleCanEditVariable( ent , ply , key , val , editor )
		if ent == self then
			local allow = self:CanPlayerEditVariable( ply , key , val , editor )

			if key == "Key" then
				local btn = tonumber( val )
				if btn and not self:IsKeyAllowed( btn ) then
					allow = false
				end
			end

			--call the editkey hook only if the other one didn't say anything in the matter for this
			if key == "Key" and allow == nil then
				allow = self:CanEditKey( ply , val , editor )
			end

			--we'll only override all the hooks if the answer is yes or no, nil keeps the default behaviour
			if allow ~= nil then
				return allow
			end
		end
	end

	--our key can only be modified by the carrying player or by anyone if it's not carried at all
	function ENT:CanEditKey( ply , val , editor )
		--you could override me if you want to, you could leave your friends behind
		return self:IsCarriedBy( ply ) or not self:IsCarried()
	end

	function ENT:CanPlayerEditVariable( ply , key , val , editor )
		--override me
	end

	--we add this entity's position to the visibility position, but only if it doesn't attach to the player
	function ENT:HandleEntityVisibility( ply , viewent )
		if self:IsCarriedBy( ply ) and not self.AttachesToPlayer and self ~= viewent then --viewents already add themselves to the pvs
			AddOriginToPVS( self:GetPos() )
		end

		--HOW CONVENIENT!!! this hook is called before the client computes what he can see
		--so we can simply use this before this entity gets recomputed for transmission

		--TODO: This will be removed and the ENT:UpdateTransmitState() below will be enabled once Willox is done with TRANSMIT_OWNERONLY
		if self.DontTransmitToOthers and not game.SinglePlayer() then

			local shouldpreventtransmit = false

			if self:IsCarried() then
				shouldpreventtransmit = not self:IsCarriedBy( ply , true )
			end

			self:SetPreventTransmit( ply , shouldpreventtransmit )
		end
	end

	--[[
	function ENT:UpdateTransmitState()


		if self.DontTransmitToOthers and self:IsCarried() then
			return TRANSMIT_OWNERONLY
		end


		--don't return anything, default behaviour
	end
	]]

else

	function ENT:GetConVar()

		--the slotname changed, so we forget this cvar to let another one with the same slot use it
		--and we let the code below create/get one with our slotname
		if self.ConfigurableConVar and self.ConfigurableConVar:GetName() ~= self:GetConVarName() then
			self.ConfigurableConVar = nil
		end

		if not self.ConfigurableConVar then
			--internally this returns the original convar if it was already created, so it's not that big of a deal, this could be done in a better way however
			self.ConfigurableConVar = CreateConVar( self:GetConVarName() , self:GetKey() , FCVAR_ARCHIVE + FCVAR_USERINFO , "Configures the key for "..self:GetSlotName().. " , created by "..self:GetClass() )
		end

		return self.ConfigurableConVar
	end

	function ENT:InternalHandleLoopingSounds( calledinprediction )
		--the calledinprediction variable makes it so HandleLoopingSounds is called from ENT:Think instead
		--and yes, this will never be set at all during singleplayer because there's no prediction

		--if this is set then there's no need to call iscarried checks below, we're always called when that happens
		if calledinprediction and not IsFirstTimePredicted() then
			return
		end

		if game.SinglePlayer() or not self:IsCarried() or not self:IsCarriedByLocalPlayer() or ( self:IsCarriedByLocalPlayer() and calledinprediction ) then
			self:HandleLoopingSounds()
		end
	end

	function ENT:HandleLoopingSounds()
		--override me
	end

	function ENT:IsCarriedByLocalPlayer( checkspectator )
		return self:IsCarriedBy( LocalPlayer() , checkspectator )
	end

	function ENT:ShouldDrawLocalPlayer( checkspectator )
		if checkspectator then
			if LocalPlayer():GetObserverMode() == OBS_MODE_IN_EYE and IsValid( LocalPlayer():GetObserverTarget() ) then
				if LocalPlayer():GetObserverTarget():IsPlayer() then
					return LocalPlayer():GetObserverTarget():ShouldDrawLocalPlayer() --assuming this even works, otherwise just return false
				end
				return false
			end
		end
		return LocalPlayer():ShouldDrawLocalPlayer()
	end

	--immediately make this entity predicted again, if it's equipped by this localplayer
	function ENT:HandleFullPacketUpdate( ent , shouldtransmit )
		if ent == self and shouldtransmit then
			self:HandlePrediction()
		end
	end

	function ENT:HandlePrediction()

		local carried = self:IsCarriedByLocalPlayer()

		--either the gravity gun or some other stuff is carrying me, don't do anything on prediction
		--because they might enable it to carry us around smoothly
		--also don't enable prediction in singleplayer

		if self:GetBeingHeld() or game.SinglePlayer() then
			return
		end

		if self:GetPredictable() ~= carried then
			self:SetPredictable( carried )
		end
	end

	function ENT:HandleButtonBind()
		--did not disable the function call from Think as someone might want to override this

		if self.SaveButtonToCvar then
			--this is a one way server to client saving, the reason I do this is because the user should usually change the value from
			--client to server with the edit system, it still goes to the server, but not to the cvar first, so we save it from the client to the cvar

			--basically we just use the cvar as a way to save the button, but it does come at the cost of not being able to update the cvar and have it update on the
			--entity, this will probably change in the future
			local mykey = self:GetKey()

			--can't use GetControllingPlayerConVarKey as I also need to SetInt on it
			local cv = self:GetConVar()

			if cv then
				if ( mykey ~= cv:GetInt() and self:IsKeyAllowed( mykey ) ) --[[or not self:IsKeyAllowed( cv:GetInt() )]] then
					cv:SetInt( mykey )
				end
			end
		end
	end



	function ENT:CreateContextMenuButton( iconlayout )
		local button = iconlayout:Add( "DPredEnt" )
		button:SetSize( 80 , 80 )
		button:SetClassName( self.PrintName , self:GetSlotName() )
		button:SetMaterial( self.Folder .. ".png" )
		button:SetPredEnt( self )
		--SetClassName
	end

	function ENT:GetContextMenuButton( iconlayout )
		local contextbutton = nil

		for i = 0 , iconlayout:ChildCount() do

			local child = iconlayout:GetChild( i )

			if IsValid( child ) and child:GetName() == "DPredEnt" and child:GetSpawnName() == self:GetSlotName() and child:GetPredEnt() == self then
				contextbutton = child
				break
			end

		end

		return contextbutton
	end

	--forcefully removes it in case it fucks up
	function ENT:RemoveContextMenuButton( iconlayout , buttonpanel )
		if IsValid( buttonpanel ) then
			buttonpanel:Remove()
		end
	end

	function ENT:GetContextMenuLayout()
		if not IsValid( g_ContextMenu ) then
			return
		end

		local iconlayout = nil

		for i = 0 , g_ContextMenu:ChildCount() do

			local child = g_ContextMenu:GetChild( i )

			if IsValid( child ) and child:GetName() == "DIconLayout" then
				iconlayout = child
				break
			end

		end

		return iconlayout
	end

	function ENT:HandleContextMenuButton( docleanup )

		local iconlayout = self:GetContextMenuLayout()

		if not IsValid( iconlayout ) then
			return
		end

		local buttonpanel = self:GetContextMenuButton( iconlayout )

		if IsValid( buttonpanel ) and ( not self:IsCarriedByLocalPlayer() or docleanup )then
			self:RemoveContextMenuButton( iconlayout , buttonpanel )
			iconlayout:InvalidateLayout()
		end

		if not IsValid( buttonpanel ) and self:IsCarriedByLocalPlayer() then
			self:CreateContextMenuButton( iconlayout )
			iconlayout:InvalidateLayout()
		end

	end



	function ENT:DrawFirstPersonInternal()
		if self.AttachesToPlayer and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
			local fov = nil	--TODO: allow changing the FOV
			cam.Start3D( nil , nil , fov , nil , nil , nil , nil , 1 , -1 )	--znear is 1 and zfar is -1
				render.DepthRange( 0 , 0.1 )	--same depth hack valve uses in source!
					self:DrawFirstPerson( self:GetControllingPlayer() )
				render.DepthRange( 0 , 1 )		--they don't even set these back to the original values
			cam.End3D()
		end
	end

	--viewmodels don't draw without an associated weapon ( this is due to garryness, they always do in source )
	function ENT:DrawViewModelInternal( vm , ply , wpn )
		if self.AttachesToPlayer and self:IsCarriedBy( ply , true ) then
			self:DrawOnViewModel( ply , vm , ply:GetHands() ) --this will stay here
		end
	end

	function ENT:DrawFirstPerson( ply )
		--override me
	end

	--mainly used to draw stuff like shields, gloves or whatever on the viewmodel hands

	function ENT:DrawOnViewModel( ply , vm , hands )
		--override me
	end

	--the flags aren't passed yet, maybe in a future update

	function ENT:DrawOnPlayer( ply , flags )
		self:DrawModel( flags )

	end

	function ENT:Draw( flags )
		local pos , ang = self:GetCustomParentOrigin()
		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )
	end

end

--these are here to "unify" our two calls to SetNWEntity and GetNWEntity
--these might be called from pe_drop and some other stuff, so we can't rely on the entity itself being present, as lame as that is
--the alternative would be to have these as global, which would be lamer
function ENT.SetOnPlayer( ply , slot , ent )
	ply:SetNW2Entity( slot , ent )
end

function ENT.GetOnPlayer( ply , slot )
	return ply:GetNW2Entity( slot )
end

function ENT:IsAttached()
	local ply = self:GetControllingPlayer()
	return self:GetOwner() == ply and self:GetParent() == ply
end

--LOOK I DON'T CARE, this check is lame as shit but I can't be arsed to add duplicated code
function ENT:IsCarried()
	return self:IsCarriedBy( self:GetControllingPlayer() )
end

function ENT:IsCarriedBy( ply , checkspectator )

	if checkspectator and ply:GetObserverMode() ~= OBS_MODE_NONE then
		return self:IsCarriedBy( ply:GetObserverTarget() )
	end

	return IsValid( ply ) and ply == self:GetControllingPlayer() and self.GetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() ) == self
end

function ENT:IsKeyDown()
	return self:GetKeyPressed()
end

--these functions should totally not be tied to this SENT, but I don't want to go out of my way to add them to an util file
function ENT:IsValidButton( btn )
	return btn > BUTTON_CODE_NONE and btn < BUTTON_CODE_COUNT
end

function ENT:IsKeyboardButton( btn )
	return btn > KEY_FIRST and btn < KEY_COUNT
end

function ENT:IsMouseButton( btn )
	return btn >= MOUSE_FIRST and btn < MOUSE_LAST
end

function ENT:IsJoystickButton( btn )
	return btn >= JOYSTICK_FIRST and btn < JOYSTICK_LAST
end

function ENT:IsKeyAllowed( btn )
	if bit.band( self.KeyAllowedFlags , self.KeyAllowedKeyboard ) == 0 and self:IsKeyboardButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedMouse ) == 0 and self:IsMouseButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedJoystick ) == 0 and self:IsJoystickButton( btn ) then
		return false
	end

	return self:IsValidButton( btn )
end

function ENT:GetConVarName()
	return "prdent_key_"..self:GetSlotName()
end

function ENT:GetControllingPlayerConVarKey()
	local defaultkey = BUTTON_CODE_NONE

	if self:IsCarried() then
		if SERVER then
			return self:GetControllingPlayer():GetInfoNum( self:GetConVarName() , defaultkey )
		else
			--the clientside implementation of GetInfoNum makes a GetConVar lookup everytime, so use the cached one instead
			local cv = self:GetConVar()

			if cv then
				return cv:GetInt()
			end
		end
	end

	return defaultkey
end

function ENT:HandleCalcMainActivity( ply , velocity )
	if self:IsCarriedBy( ply ) then
		local calcideal , calcseqovr = self:HandleMainActivityOverride( ply , velocity )
		if calcideal and calcseqovr then
			return calcideal , calcseqovr
		end
	end
end

function ENT:HandleUpdateAnimation( ply, velocity, maxseqgroundspeed )
	if self:IsCarriedBy( ply ) then
		if self:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed ) then
			return true
		end
	end
end

function ENT:HandleAnimationEvent( ply, event, data )
	if self:IsCarriedBy( ply ) then
		if self:HandleAnimationEventOverride( ply , event , data ) then
			return ACT_INVALID
		end
	end
end

function ENT:HandleMainActivityOverride( ply , velocity )
	--override me
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	--override me
end

function ENT:HandleAnimationEventOverride( ply , event , data )
	--override me
end

function ENT:HandlePredictedStartCommand( ply , cmd )
	if self:IsCarriedBy( ply ) then
		self:PredictedStartCommand( ply , cmd )
	end
end

function ENT:HandlePlayerButtonDown( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , true )
	end
end

function ENT:HandlePlayerButtonUp( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , false )
	end
end

function ENT:HandlePlayerButtonInternal( ply , btn , pressed )
	local mykey = self:GetKey()
	if self:IsKeyAllowed( mykey ) and btn == mykey then
		self:SetKeyPressed( pressed )
	end

	self:PredictedPlayerButtonPress( ply , btn , pressed )
end

function ENT:HandlePredictedSetupMove( ply , mv , cmd )
	if self:IsCarriedBy( ply ) then
		if self:PredictedSetupMove( ply , mv , cmd ) then
			return true
		end
	end
end

function ENT:HandlePredictedMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedThink( ply , mv )
	if self:IsCarriedBy( ply ) then
		if CLIENT then
			self:InternalHandleLoopingSounds( true )
		end
		self:PredictedThink( ply , mv )
	end
end

function ENT:HandlePredictedFinishMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedFinishMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedHitGround( ply , inwater , onfloater , speed )
	if self:IsCarriedBy( ply ) then
		if self:PredictedHitGround( ply , inwater , onfloater , speed ) then
			return true
		end
	end
end

function ENT:PredictedStartCommand( ply , cmd )
	--override me
end

function ENT:PredictedPlayerButtonPress( ply , btn , pressed )
	--override me
end

function ENT:PredictedSetupMove( ply , mv , cmd )
	--override me
end

function ENT:PredictedMove( ply , mv )
	--override me
end

function ENT:PredictedThink( ply , mv )
	--override me
end

function ENT:PredictedFinishMove( ply , mv )
	--override me
end

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )
	--override me
end

--Allows for predicted movement simulation on non player entities, without disrupting the player movement itself
--FinishMove should be the best place for this, since even in case of fuckups, the rest of the movement should be fine

--[[
	function ENT:PredictedFinishMove( ply , mv )

		local sv = self:BackupMoveData( mv )

		--set the data you want on the movedata, such as the entity origin, speed, angles and stuff

		--run the entity traces

		--set the final position of the entity here with the same way garry does ( see drive.End or whatever it's called )

		--restore the movedata on the player as if nothing happened

		self:RestoreMoveData( mv , sv )


	end
]]


local movedatameta = FindMetaTable( "CMoveData" )

local emptyvalues = {
	[TYPE_VECTOR] = vector_origin * 1,
	[TYPE_ANGLE] = angle_zero * 1,
	[TYPE_NUMBER] = 0,
	[TYPE_ENTITY] = NULL,
}

local methods = {}

--cache the methods we can actually use
for i , v in pairs( movedatameta ) do
	--see if this function has a pattern like "Get*" or whatever
	--then strip out "Get" and add it here
	local functionname = i
	if functionname:find( "^Get" ) then
		local functionnamestripped = functionname:gsub( "^Get" , "" )

		local setter = movedatameta["Set"..functionnamestripped]

		if setter then
			--add the stripped method to the table to reuse later
			methods[#methods + 1] = functionnamestripped
		end
	end
end

function ENT:BackupMoveData( mv )

	if not mv or not movedatameta then
		return
	end

	local sv = {}
	--save the movedata by name on the table, then go trough the metatable to get the setters and set values to empty ones

	for i , v in pairs( methods ) do
		--see if this function has a pattern like "Get*" or whatever
		--then strip out "Get" and add it here

		--we could've cached the functions as well, but just in case someone wants us to use the modified ones
		local getter = movedata["Get"..v]
		local setter = movedata["Set"..v]

		local backupvalue = getter( mv )

		sv[v] = backupvalue

		if emptyvalues[TypeID( backupvalue )] ~= nil then
			setter( mv , emptyvalues[TypeID( backupvalue )] )
		end
	end

	return sv
end

function ENT:RestoreMoveData( mv , sv )
	if not mv or not sv or not movedatameta then
		return
	end

	--restore the values from the table, prevents duplicated code by using the setters from the metatable directly
	for i , v in pairs( sv ) do
		local setter = movedatameta["Set"..i]
		if setter then
			setter( mv , v )
		end
	end
end

--attaches the entity to the player depending on the attachmentinfo table
--you can override this safely as long as you keep the part with ply:SetupBones()
--although you generally should just use the attachment info table instead

function ENT:GetCustomParentOrigin()

	if not self.AttachmentInfo then
		return
	end

	local ply = self:GetControllingPlayer()

	--duplicated check, but people might call this manually in the entity draw hook, so gotta do this
	if not self:IsCarriedBy( ply ) then
		return
	end

	--I put this here because since the entity moves to the player bone matrix, it'll only be updated on the client
	--when the player is actally drawn, or his bones are setup again ( which happens before a draw anyway )
	--this also fixes sounds on the client playing at the last location the LocalPlayer() was drawn

	if CLIENT and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
		ply:SetupBones()
	end

	local boneid = ply:LookupBone( self.AttachmentInfo.BoneName )

	if not boneid then
		return
	end

	local matrix = ply:GetBoneMatrix( boneid )

	if not matrix then
		return
	end

	return LocalToWorld( self.AttachmentInfo.OffsetVec , self.AttachmentInfo.OffsetAng , matrix:GetTranslation() , matrix:GetAngles() )
end

--if we're attached to a player, use custom origin from the function above
--this is called shared, yes it's more expensive than source's normal parenting but it's worth it

function ENT:CalcAbsolutePosition( pos , ang )
	if self.AttachesToPlayer and self:IsCarried() then
		return self:GetCustomParentOrigin()
	end
end

function ENT:EmitPESound( soundname , level , pitch , volume , chan , predicted , activator , worldpos )

	--must've been called manually by some ent:Fire or ent:Input functions
	if IsValid( activator ) and not activator:IsPlayer() then
		activator = NULL
	end

	if not level then
		level = 75
	end

	if not pitch then
		pitch = 100
	end

	if not volume then
		volume = 1
	end

	if not chan then
		chan = CHAN_AUTO
	end

	if game.SinglePlayer() then
		predicted = false
	end

	if not worldpos then
		worldpos = vector_origin
	end

	if SERVER then

		local plys = RecipientFilter()

		if IsValid( activator ) and not predicted and not activator:IsBot() then
			plys:AddPlayer( activator )
		else

			plys:AddPVS( self:GetPos() )

			if predicted and IsValid( self:GetControllingPlayer() ) then
				plys:RemovePlayer( self:GetControllingPlayer() )
			end

		end

		if plys:GetCount() == 0 then
			return
		end

		net.Start( "pe_playsound" )
			net.WriteEntity( self )
			net.WriteString( soundname )
			net.WriteFloat( level )
			net.WriteFloat( pitch )
			net.WriteFloat( volume )
			net.WriteUInt( chan , 8 )
			net.WriteVector( worldpos )
		net.Send( plys )

	else
		if ( predicted and IsFirstTimePredicted() ) or not predicted then
			if worldpos and worldpos ~= vector_origin then
				sound.Play( soundname, worldpos, level, pitch , volume )
			else
				self:EmitSound( soundname , level , pitch , volume , chan )
			end
		end
	end
end

function ENT:OnRemove()
	--if we're being forcibly removed, make sure we're also dropped properly, in case the entity needs to do
	--some stuff on the player before it expires
	if SERVER and self:IsCarried() then
		self:Remove( true )
	end

	if CLIENT then
		self:HandleContextMenuButton( true )
	end

	self:HandleHooks( true ) --remove the hooks immediately instead of relying on garry's "remove if called again"


end

--stuff that should be in an autorun file but that I can't be arsed to split up to

if SERVER then

	util.AddNetworkString( "pe_pickup" )
	util.AddNetworkString( "pe_playsound" )

	--save the function before ENT gets removed during registration
	local GetPredictedEntityOnPlayer = ENT.GetOnPlayer

	concommand.Add( "pe_drop" , function( ply , cmd , args , fullstr )

		if not IsValid( ply ) then
			return
		end

		local nwslot = args[1]

		if not nwslot then
			return
		end

		local slotent = GetPredictedEntityOnPlayer( ply , nwslot )--ply:GetNWEntity( nwslot )

		--user tried to drop an invalid or an entity which is not a predicted entity, or doesn't have a slot assigned

		if not IsValid( slotent ) or not slotent.IsPredictedEnt or slotent:GetSlotName() == "" then
			return
		end

		slotent:Remove( false )

	end)

else

	--tells the hud to show the player the entity pickup
	language.Add( "invalid_entity" , "Invalid Entity" )
	language.Add( "dropped_invalid_entity" , "Dropped Invalid Entity" )

	net.Receive( "pe_pickup" , function( len )
		local str = net.ReadString() or "invalid_entity"
		local dropped = tobool( net.ReadBit() )

		if dropped then
			str = "dropped_" .. str
		end

		gamemode.Call( "HUDItemPickedUp" , str )
	end)

	net.Receive( "pe_playsound" , function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.EmitPESound then
			return
		end

		local soundname = net.ReadString() --yes I know that I can do util.addnetworkstring to cache it but I cba

		local level = net.ReadFloat()
		local pitch = net.ReadFloat()
		local volume = net.ReadFloat()
		local chan = net.ReadUInt( 8 )
		local pos = net.ReadVector()

		ent:EmitPESound( soundname , level , pitch , volume , chan , false , NULL , pos )
	end)

	--[[
		A DProperty that allows the user to set a preferred key using the same DBinder used in sandbox's tools
	]]

	local DBinderProperty = {}

	function DBinderProperty:Init()
	end

	function DBinderProperty:Setup( vars )

		self:Clear()

		local ctrl = self:Add( "DBinder" )
		ctrl:Dock( FILL )

		self.IsEditing = function( self )
			return ctrl.Trapping
		end

		self.SetValue = function ( self , val )
			ctrl:SetSelected( tonumber( val ) )	--use this instead of setValue to possibly avoid feedback loops
		end

		--DBinder doesn't have an onchange callback, so we must do this little hack to add it
		--[[
		ctrl.SetValue = function( ctrl , val )
			ctrl:SetSelected( val )
			self:ValueChanged( val )
		end
		]]

		ctrl.OnChange = function( ctrl , val )
			self:ValueChanged( val )
		end


	end

	derma.DefineControl( "DProperty_EditKey" , "" , DBinderProperty , "DProperty_Generic" )

	local DPredEnt = {
		matOverlay_Normal = Material( "gui/ContentIcon-normal.png" ),
		matOverlay_Hovered = Material( "gui/ContentIcon-hovered.png" )
	}

	AccessorFunc( DPredEnt, "m_MaxBorder", "MaxBorder" )
	AccessorFunc( DPredEnt, "m_MaterialName", "MaterialName" )
	AccessorFunc( DPredEnt, "m_PredEnt", "PredEnt" )
	AccessorFunc( DPredEnt, "m_Border", "Border" )
	AccessorFunc( DPredEnt, "m_Color", "Color" )
	AccessorFunc( DPredEnt, "m_Type", "ContentType" )
	AccessorFunc( DPredEnt, "m_SpawnName", "SpawnName" )
	AccessorFunc( DPredEnt, "m_NPCWeapon", "NPCWeapon" )
	AccessorFunc( DPredEnt, "m_Image", "Image" )
	AccessorFunc( DPredEnt, "m_Label", "Label" )

	function DPredEnt:Init()

		local w , h = 128, 128
		self:SetSize( w , h )

		self:SetPaintBackground( false )

		self:SetText( "" )
		self:SetDoubleClickingEnabled( false )

		self:SetImage( self:Add( "DImage" ) )
		self:GetImage():SetVisible( false )

		self:SetLabel( self:Add( "DLabel" ) )
		self:GetLabel():Dock( BOTTOM )

		self:GetLabel():SetContentAlignment( 5 )

		self:GetLabel():SetTextColor( Color( 255, 255, 255, 255 ) )
		self:GetLabel():SetExpensiveShadow( 1, Color( 0, 0, 0, 200 ) )

		self:SetBorder( 0 )



	end



	function DPredEnt:PerformLayout( w , h )
		self:SetMaxBorder( w / 16 )
		self:GetImage():SetPos( w / 32 , w / 32 )
		self:GetImage():SetSize( w - w / 16 , h - w / 16 )
		self:GetLabel():SetTall( math.Round( w / 7 ) )
		self:GetLabel():DockMargin( math.Round( w / 32 ) , 0 , math.Round( w / 32 ) , math.Round( w / 21 ) )
	end


	function DPredEnt:SetClassName( name , class )

		self:SetTooltip( name )
		self:GetLabel():SetText( name )
		self:SetSpawnName( class )
	end

	function DPredEnt:SetMaterial( name )

		self:SetMaterialName( name )

		local mat = Material( name )

		-- Look for the old style material
		if not mat or mat:IsError() then

			name = name:Replace( "entities/", "VGUI/entities/" )
			name = name:Replace( ".png", "" )
			mat = Material( name )

		end

		-- Couldn't find any material.. just return
		if not mat or mat:IsError() then
			return
		end

		self:GetImage():SetMaterial( mat )

	end

	function DPredEnt:Think()
		if not IsValid( self:GetPredEnt() ) or not self:GetPredEnt().IsPredictedEnt  then
			self:Remove()
		end
	end

	function DPredEnt:DoRightClick()
		self:OpenMenu()
	end

	function DPredEnt:DoClick()
		RunConsoleCommand( "pe_drop" , self:GetSpawnName() or ""  )
	end

	function DPredEnt:OpenMenu()
		if IsValid( self:GetPredEnt() ) then
			properties.OpenEntityMenu( self:GetPredEnt() )
		end
	end

	function DPredEnt:OnDepressionChanged( b )
	end

	function DPredEnt:Paint( w, h )

		if self.Depressed and not self.Dragging then
			if self:GetBorder() ~= self:GetMaxBorder() then
				self:SetBorder( self:GetMaxBorder() )
				self:OnDepressionChanged( true )
			end
		else
			if self:GetBorder() ~= 0 then
				self:SetBorder( 0 )
				self:OnDepressionChanged( false )
			end
		end

		render.PushFilterMag( TEXFILTER.ANISOTROPIC )
		render.PushFilterMin( TEXFILTER.ANISOTROPIC )

		local bx , by , bw , bh = self:GetBorder(), self:GetBorder(), w - self:GetBorder() * 2 , h - self:GetBorder() * 2


		self:GetImage():PaintAt( bx + self:GetMaxBorder() / 2 , by + self:GetMaxBorder() / 2 , bw - self:GetMaxBorder() , bh - self:GetMaxBorder() )



		render.PopFilterMin()
		render.PopFilterMag()

		surface.SetDrawColor( 255, 255, 255, 255 )

		if not dragndrop.IsDragging() and ( self:IsHovered() or self.Depressed or self:IsChildHovered() ) then

			surface.SetMaterial( self.matOverlay_Hovered )
			self:GetLabel():Hide()

		else

			surface.SetMaterial( self.matOverlay_Normal )
			self:GetLabel():Show()

		end

		surface.DrawTexturedRect( bx , by , bw , bh )

	end

	derma.DefineControl( "DPredEnt" , "ContentIcon for Predicted entities in the context menu" , DPredEnt , "DButton" )

end

--addons/star_wars_mortar/lua/entities/mortar/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end

--addons/star_wars_mortar/lua/entities/mortar_fire_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar Fire Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"
--addons/star_wars_mortar/lua/entities/mortar_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"


--addons/star_wars_mortar/lua/entities/mortar_smoke_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--addons/aocrp_emplacements/lua/entities/rail_shell/cl_init.lua:
 include('shared.lua')     
 //[[---------------------------------------------------------     
 //Name: Draw     Purpose: Draw the model in-game.     
 //Remember, the things you render first will be underneath!  
 //-------------------------------------------------------]]  
 function ENT:Draw()      
 // self.BaseClass.Draw(self)  
 -- We want to override rendering, so don't call baseclass.                                   
 // Use this when you need to add to the rendering.        
 self.Entity:DrawModel()       // Draw the model.   
 end  
--addons/arccw_weapons/lua/entities/reb_rocket/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "HH Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 8
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
			phys:SetMass(2)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp06.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_reb_sniper", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 65 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 15 )
        smoke:SetEndSize( 140 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 225, 225, 225 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_reb_rocket", self:GetPos(), self:GetAngles() )
	sound.Play( "weapons/star_wars_battlefront/common/exp_ord_rocket_large0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 100 )
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 250, 300)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(200, 300), math.random(200, 300), Color(255, 225, 150) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--addons/joes_stuff/lua/entities/shield_bubble_personal/cl_init.lua:
include('shared.lua')

function ENT:Initialize()
	self.StartTime = CurTime()
	self.height = 0
	self.buildtime = 0.75
	self.isshield = true
end

function ENT:Draw()
	local hp = self:Health() / SWRPShield.personalshieldhp
	self:SetColor(Color(255 * (1-hp), 161 * hp, 255 * hp, 255))
	if CurTime() >= self.StartTime + self.buildtime then
		self:DrawModel()
	else
		local min,max = self:GetRenderBounds()
		local center = self:GetPos() + self:OBBCenter()
		self.height = ( max.z * 2.5 / self.buildtime ) * ( CurTime() - self.StartTime )
		local normal = Vector(0,0,-1)
		local pos = min + self:LocalToWorld(Vector(0, 0,self.height))
		local distance = normal:Dot(pos)
		
		render.EnableClipping(true)
		render.PushCustomClipPlane(normal, distance)
		self:DrawModel()
		render.PopCustomClipPlane()
	end
end

function ENT:Think()
	local ply = self:GetShieldOwner()
	if not IsValid(ply) or not ply:Alive() then return end
  	self:SetPos(ply:GetPos() + ply:OBBCenter() + Vector(0,0,10)) 
	self:SetNextClientThink(CurTime())
	return true
end

--addons/joes_stuff/lua/entities/shield_bubble_shoot/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName= "Shield Bubble Shoot"
ENT.Author= "Joe + JackJack + Nvc"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = "Joe"
ENT.AutomaticFrameAdvance = true

function ENT:TestCollision( startpos, delta, isbox, extents, mask )
	local rad = self:GetRadius()
	local dist = startpos:DistToSqr(self:GetPos())
	if rad and dist < rad ^ 2 and bit.band( mask, CONTENTS_EMPTY ) == 0 then
		return false
	else
		return true
	end
end

function ENT:SetupDataTables()

	self:NetworkVar( "Int", 0, "Radius" )

end
--addons/sse_101/lua/entities/sse_broadcast.lua:
AddCSLuaFile()


ENT.Base = "sse_base"

ENT.PrintName		= "Broadcast Console"
ENT.Spawnable       = true
ENT.ConfigName = "Broadcast"
ENT.Category        = "SSE"


if SERVER then

    function SSE_GetBroadcast(ply)
        return ply.SSE_BROADCAST or false
    end

    
    function ENT:SetBoradcastPlayer(ply, val)
        if not IsValid(ply) or not ply:IsPlayer() then return end

        if SERVER then
            if val then
                ply:ChatPrint("*** "..self:ConfigValue("Enabled"))
    
                if VoiceBox and VoiceBox.FX then
                    ply:AddVoiceFX("PASystemLoud")
                end
                
                ply.SSE_BROADCAST = true
    
                net.Start("SSE_BROADCAST_PlaySound")
                net.WriteString(self:ConfigValue("Sound"))
                net.Broadcast()
            else
                ply:ChatPrint("*** "..self:ConfigValue("Disabled"))
    
                ply.SSE_BROADCAST = false
    
                if VoiceBox and VoiceBox.FX then
                    ply:RemoveVoiceFX("PASystemLoud")
                end
    
                net.Start("SSE_BROADCAST_PlaySound")
                    net.WriteString(self:ConfigValue("Sound"))
                net.Broadcast()
            end
    
    
            
        end

    end 


    function ENT:Use( activator, caller )

        if not IsValid(activator) or not activator:IsPlayer() then return end

       
        self:SetBoradcastPlayer(activator, !SSE_GetBroadcast(activator))
    end
end



if CLIENT then

    function ENT:Draw()
        self.BaseClass.Draw(self) 
    end

    net.Receive("SSE_Broadcast_PlaySound", function(len)
        local path = net.ReadString()
        surface.PlaySound(path)
    end)

end


if SERVER then
    util.AddNetworkString("SSE_BROADCAST_PlaySound")
end


if SERVER then
    
    hook.Add("PlayerCanHearPlayersVoice", "SSE_BROADCAST_PlayerCanHearPlayersVoice", function(listener, talker)
        if SSE_GetBroadcast(talker) and listener ~= talker then
            return true
        end
    end)
end
--addons/arccw_weapons/lua/entities/tfa_exp_contact.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

AddCSLuaFile()

ENT.Base = "tfa_exp_base"
ENT.PrintName = "Contact Explosive"

function ENT:PhysicsCollide(data, phys)
	if data.Speed > 60 then
		self.killtime = -1
	end
end
--addons/arccw_weapons/lua/entities/tfbow_arrow/shared.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local vector_origin = Vector()

ENT.Type = "anim"
ENT.PrintName = "TFBow Arrow"
ENT.Author = "TheForgottenArchitect"
ENT.Contact = "Don't"
ENT.Purpose = "Arrow Entity"
ENT.Instructions = "Spawn this with a velocity, get rich"

local function GetBoneCenter(ent, bone)
	local bonechildren = ent:GetChildBones(bone)

	if #bonechildren <= 0 then
		return ent:GetBonePosition(bone)
	else
		local bonepos = ent:GetBonePosition(bone)
		local tmppos = bonepos

		if tmppos then
			for i = 1, #bonechildren do
				local childpos = ent:GetBonePosition(bonechildren[i])

				if childpos then
					tmppos = (tmppos + childpos) / 2
				end
			end
		else
			return ent:GetPos()
		end

		return tmppos
	end
end

function ENT:GetClosestBonePos(ent, pos)
	local i, count, dist, ppos, cbone
	i = 1
	count = ent:GetBoneCount()
	cbone = 0
	dist = 99999999
	ppos = ent:GetPos()

	while (i < count) do
		local bonepos = GetBoneCenter(ent, i)

		if bonepos:Distance(pos) < dist then
			dist = bonepos:Distance(pos)
			cbone = i
			ppos = bonepos
		end

		i = i + 1
	end

	return ppos, cbone
end

local cv_al = GetConVar("sv_tfa_arrow_lifetime")
local cv_ht = GetConVar("host_timescale")

function ENT:Initialize()
	if SERVER then
		if not IsValid(self.myowner) then
			self.myowner = self:GetOwner()

			if not IsValid(self.myowner) then
				self.myowner = self
			end
		end

		timer.Simple(0, function()
			if self.model then
				self:SetModel(self.model)
			end
		end)

		if cv_al:GetInt() ~= -1 then
			timer.Simple( cv_al:GetFloat() + 5, function()
				if IsValid(self) then
					self:Remove()
				end
			end)
		end

		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()

			if self.velocity then
				phys:SetVelocityInstantaneous(self.velocity)
			end

			phys:EnableCollisions(false)
			self:StartMotionController()
			self:PhysicsUpdate(phys, 0.1 * cv_ht:GetFloat() )
		end
	end

	self:SetNW2Vector("lastpos", self:GetPos())

	if not self.mydamage then
		self.mydamage = 60
	end

	if not self.gun then
		if IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
			self:UpdateGun()
		else
			timer.Simple(0, function()
				if IsValid(self) and IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
					self:UpdateGun()
				end
			end)
		end
	end
end

function ENT:UpdateGun()
	local wep = self:GetOwner():GetActiveWeapon()

	if IsValid(wep) then
		self.gun = wep:GetClass()
	end
end

local wl,tracedata,tr

local cv_fm = GetConVar("sv_tfa_force_multiplier")

function ENT:HitCB(a,b,c)
	c:SetDamageType(bit.bor(DMG_NEVERGIB, DMG_CLUB))

	if IsValid(self) and IsValid(self:GetOwner()) then
		if b.HitWorld then
			local arrowstuck = ents.Create("tfbow_arrow_stuck")
			arrowstuck:SetModel(self:GetModel())
			arrowstuck.gun = self.gun
			arrowstuck:SetPos(tr.HitPos)
			local phys = self:GetPhysicsObject()
			arrowstuck:SetAngles((phys:GetVelocity()):Angle())
			arrowstuck:Spawn()
		else
			if IsValid(b.Entity) then
				if (not b.Entity:IsWorld()) then
					local arrowstuck = ents.Create("tfbow_arrow_stuck_clientside")
					arrowstuck:SetModel(self:GetModel())
					arrowstuck:SetPos(tr.HitPos)
					local ang = self:GetAngles()
					arrowstuck.gun = self.gun
					arrowstuck:SetAngles(ang)
					arrowstuck.targent = tr.Entity
					arrowstuck.targphysbone = tr.PhysicsBone
					arrowstuck:Spawn()
				else
					local arrowstuck = ents.Create("tfbow_arrow_stuck")
					arrowstuck:SetModel(self:GetModel())
					arrowstuck.gun = self.gun
					arrowstuck:SetPos(tr.HitPos)
					arrowstuck:SetAngles(self:GetAngles())
					arrowstuck:Spawn()
				end
			end
		end

		self:Remove()
	elseif IsValid(self) then
		self:Remove()
	end
end

function ENT:Think()
	wl = self:WaterLevel()

	if not self.prevwaterlevel then
		self.prevwaterlevel = wl
	end

	if self.prevwaterlevel ~= wl and wl - self.prevwaterlevel >= 1 then
		--print(wl)
		local ef = EffectData()
		ef:SetOrigin(self:GetPos())
		util.Effect("watersplash", ef)
	end

	self.prevwaterlevel = wl

	if wl >= 2 then
		local phys = self:GetPhysicsObject()

		if IsValid(phys) then
			phys:SetVelocity(phys:GetVelocity() * math.sqrt(9 / 10))
		end
	end

	tracedata = {}
	tracedata.start = self:GetNW2Vector("lastpos", self:GetPos())
	tracedata.endpos = self:GetPos()
	tracedata.mask = MASK_SOLID
	tracedata.filter = {self.myowner, self:GetOwner(), self}
	tr = util.TraceLine(tracedata)

	--self:SetAngles((((tracedata.endpos-tracedata.start):GetNormalized()+self:GetAngles():Forward())/2):Angle())
	if (tr.Hit and tr.Fraction < 1 and tr.Fraction > 0) then
		debugoverlay.Line(tracedata.start, tr.HitPos, 10, Color(255, 0, 0, 255), true)
		debugoverlay.Cross(tr.HitPos, 5, 10, Color(255, 0, 0, 255), true)

		if SERVER then
			--[[
			local bul ={}
			bul.Attacker=self:GetOwner() and self:GetOwner() or self:GetOwner()
			bul.Spread=vector_origin
			bul.Src=tracedata.start
			bul.Force=self.mydamage*0.25*GetConVarNumber("sv_tfbow_force_multiplier",1)
			bul.Damage=self.mydamage
			bul.Tracer	= 0							-- Show a tracer on every x bullets
			bul.TracerName = "None"
			bul.Dir=((tr.HitPos-bul.Src):GetNormalized())

			bul.Attacker:FireBullets( bul )
			]]
			--
			local bul = {}
			bul.Attacker = self:GetOwner() and self:GetOwner() or self:GetOwner()
			bul.Spread = vector_origin
			bul.Src = tracedata.start
			bul.Force = self.mydamage * 0.25 * cv_fm:GetFloat()
			bul.Damage = self.mydamage
			bul.Tracer = 0 -- Show a tracer on every x bullets
			bul.TracerName = "None"
			bul.Dir = (tr.HitPos - bul.Src):GetNormalized()

			bul.Callback = function(a, b, c)
				self:HitCB(a,b,c)
			end

			bul.Attacker:FireBullets(bul)
		end

		return
	end

	self:SetNW2Vector("lastpos", self:GetPos())
end

--addons/aocrp_emplacements/lua/entities/turret_bullets/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
	self.MuzzleAttachment=self:LookupAttachment("muzzle")
	self.shootPos=self:GetDTEntity(1)
	
end
--[[
ENT.HiddenShooter=false
function ENT:Think()
	if not self.HiddenShooter and IsValid(self.shootPos) then
		self.shootPos:SetRenderMode(RENDERMODE_TRANSCOLOR)
		self.shootPos:SetColor(Color(255,255,255,1))
		self.HiddenShooter=true
	end
	
end]]

function ENT:Draw()
	
	self:DrawModel()
	
end
--addons/aocrp_emplacements/lua/entities/turret_grenade/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Category		= "Emplacements"
ENT.PrintName 		= "40MM HE Turret"
ENT.Author			= "Wolly/BOT_09"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.TurretFloatHeight=3
ENT.TurretModelOffset=Vector(0,0,44)
ENT.TurretTurnMax=0.7

ENT.LastShot=0
ENT.ShotInterval=0.7


function ENT:SetupDataTables()
	self:DTVar("Entity",0,"Shooter")
	self:DTVar("Entity",1,"ShootPos")
end

function ENT:SetShooter(plr)
	self.Shooter=plr
	self:SetDTEntity(0,plr)
end

function ENT:GetShooter(plr)
	if SERVER then
		return self.Shooter
	elseif CLIENT then
		return self:GetDTEntity(0)
	end
end


function ENT:Use(plr)
	
	if not self:ShooterStillValid() then
		self:SetShooter(plr)
		self:StartShooting()
		self.ShooterLast=plr
		
		
	else
		if plr==self.Shooter then
			self:SetShooter(nil)
			self:FinishShooting()
			
		end
	end
end


function ENT:ShooterStillValid()
	local shooter=nil
	if SERVER then
		shooter=self.Shooter
	elseif CLIENT then
		shooter=self:GetDTEntity(0)
	end
	
	return IsValid(shooter) and shooter:Alive() and ((self:GetPos()+self.TurretModelOffset):Distance(shooter:GetShootPos())<=90)
end



function ENT:DoShot()
	
	
	if self.LastShot+self.ShotInterval<CurTime() then
		if SERVER then
			
			local effectPosAng=self:GetAttachment(self.MuzzleAttachment)
			local vPoint = effectPosAng.Pos
			local effectdata = EffectData()
			effectdata:SetStart( vPoint )
			effectdata:SetOrigin( vPoint )
			effectdata:SetAngles(effectPosAng.Ang + Angle(0,-90,0))
			effectdata:SetEntity(self)
			effectdata:SetScale( 1 )
			util.Effect( "MuzzleEffect", effectdata )
			
		--elseif SERVER then
			self:EmitSound(self.ShotSound,50,100)
			
			
		end
		
		if IsValid(self.shootPos) and SERVER then

			local nade = ents.Create("turret_40mm_frag")
			local attachAng=self:GetAttachment(self.MuzzleAttachment)
			nade:SetPos(self.shootPos:GetPos())
			nade:SetAngles(self:GetAngles() + Angle(self:GetAngles().p,-90,0))
			nade:Spawn()
			nade:SetOwner(self.Shooter)
			nade.flightvector = self:GetRight() *35
			--self:GetPhysicsObject():ApplyForceCenter( self:GetRight()*-10000 )
			--[[local b = ents.Create( "info_target" )
			if (IsValid(b)) then
				b:SetPos( self.Shooter:GetEyeTrace( ).HitPos )
				b:Spawn( )
				--nade:Launch()
				nade:PointAtEntity( b )
				b:Remove( )
			end]]--
			
			
		end
		
		self.LastShot=CurTime()
	end
	
end



function ENT:Think()
	
	if not IsValid(self.turretBase) and SERVER then
		SafeRemoveEntity(self)
	else
		--[[if IsValid(self.shootPos) or self.shootPos==NULL then
			if CLIENT then
				
				self.shootPos=self:GetDTEntity(1)
			elseif SERVER then
				
				self:SetDTEntity(1,self.shootPos)
			end
		end]]
		if IsValid(self) then
			
			if SERVER then
				self.BasePos=self.turretBase:GetPos()
				self.OffsetPos=self.turretBase:GetAngles():Up()*1
			end
			
			if self:ShooterStillValid() then
			
				if SERVER then
					local offsetAng=(self:GetAttachment(self.MuzzleAttachment).Pos-self:GetDesiredShootPos()):GetNormal()
					local offsetDot=(self.turretBase:GetAngles():Right()*-1):DotProduct(offsetAng)
					local HookupPos=self:GetAttachment(self.HookupAttachment).Pos
					if offsetDot>=self.TurretTurnMax then
						local offsetAngNew=offsetAng:Angle()
						offsetAngNew:RotateAroundAxis(offsetAngNew:Up(),-90)
						
						self.OffsetAng=offsetAngNew
						
					end
				end
				
				local pressKey=IN_BULLRUSH
				if CLIENT and game.SinglePlayer() then
					pressKey=IN_ATTACK
					
				end
				
				self.Firing=self:GetShooter():KeyDown(pressKey)
				
			else
				self.Firing=false
				if SERVER then
					self.OffsetAng=self.turretBase:GetAngles()
					
					self:SetShooter(nil)
					self:FinishShooting()
				end
			end
			
			if self.Firing then
				self:DoShot()
			end
			self:NextThink(CurTime())
			return true
		end
	end
end	
--addons/tools/lua/entities/vanilla_explosion/cl_init.lua:
-- YOU CAN EDIT AND REUPLOAD THIS FILE.
-- HOWEVER MAKE SURE TO RENAME THE FOLDER TO AVOID CONFLICTS

include("shared.lua")

function ENT:LFSCalcViewFirstPerson( view, ply ) -- modify first person camera view here
	--[[
	if ply == self:GetDriver() then
		-- driver view
	elseif ply == self:GetGunner() then
		-- gunner view
	else
		-- everyone elses view
	end
	]]--

	return view
end

function ENT:LFSCalcViewThirdPerson( view, ply ) -- modify third person camera view here
	return view
end

function ENT:LFSHudPaint( X, Y, data, ply ) -- driver only
end

function ENT:LFSHudPaintPassenger( X, Y, ply ) -- all except driver
end

function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(  math.Clamp( 60 + Pitch * 40 + Doppler,0,255) )
		self.ENG:ChangeVolume( math.Clamp( Pitch, 0.5,1) )
	end
end

function ENT:EngineActiveChanged( bActive )
	if bActive then
		self.ENG = CreateSound( self, "vehicles/airboat/fan_blade_fullthrottle_loop1.wav" )
		self.ENG:PlayEx(0,0)
	else
		self:SoundStop()
	end
end

function ENT:OnRemove()
	self:SoundStop()

	if IsValid( self.TheRotor ) then -- if we have an rotor
		self.TheRotor:Remove() -- remove it
	end
end

function ENT:SoundStop()
	if self.ENG then
		self.ENG:Stop()
	end
end

function ENT:AnimFins()
	--[[ function gets called each frame by the base script. you can do whatever you want here ]]--
end


function ENT:AnimCabin()
	--[[ function gets called each frame by the base script. you can do whatever you want here ]]--
end

function ENT:AnimLandingGear()
	--[[ function gets called each frame by the base script. you can do whatever you want here ]]--
end

function ENT:ExhaustFX()
	--[[ function gets called each frame by the base script. you can do whatever you want here ]]--
end

--addons/tools/lua/entities/vanilla_hyperspace2_ship/shared.lua:
ENT.Type 		= "anim"
ENT.Base 		= "base_anim"
ENT.PrintName		= "Vanilla_Hyperspace"
ENT.Author		= "VanillaNekoNYAN"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

function ENT:SetupDataTables()
    self:NetworkVar("String","1","PlaySound")
end

--addons/tools/lua/entities/vanilla_shipdestruction/shared.lua:
ENT.Type 		= "anim"
ENT.Base 		= "base_anim"
ENT.PrintName		= "Vanilla_ShipExplosion"
ENT.Author		= "VanillaNekoNYAN"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

--addons/arccw_weapons/lua/effects/arccw_apex_muzzle_hmg/init.lua:
local ang

EFFECT.ParticleName = "tfa_apex_muzzle_hmg"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt:IsFirstPerson() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.Forward = self.Forward or data:GetNormal()
    self.Angle = self.Forward:Angle()
        
    local dlight = DynamicLight(self.WeaponEnt:EntIndex())
    if (dlight) then
        dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
        dlight.r = 255
        dlight.g = 192
        dlight.b = 64
        dlight.brightness = 5
        dlight.Size = math.Rand(32, 64)
        dlight.Decay = math.Rand(32, 64) / 0.05
        dlight.DieTime = CurTime() + 0.05
    end
    
    self.Right = self.Angle:Right()
    self.vOffset = self.Position
    dir = self.Forward

    ParticleEffectAttach( self.ParticleName, PATTACH_POINT_FOLLOW, self.WeaponEnt, self.Attachment)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end

--addons/arccw_weapons/lua/effects/arccw_apex_tracer_chargerifle/init.lua:
EFFECT.TracerName = "tfa_apex_chargerifle_beam"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment()
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT_FOLLOW, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(1,self.Position)
        pcf:SetControlPoint(2,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(0.15, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/arccw_apex_tracer_energy_sniper/init.lua:
EFFECT.TracerName = "tfa_apex_energy_tracer_rifle"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/arccw_apex_tracer_hmg/init.lua:
EFFECT.TracerName = "tfa_apex_tracer_hmg"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_base_modified/lua/effects/arccw_shelleffect.lua:

EFFECT.Sounds = {}
EFFECT.Pitch = 90
EFFECT.Scale = 1.5
EFFECT.PhysScale = 1
EFFECT.Model = "models/shells/shell_57.mdl"
EFFECT.Material = nil
EFFECT.JustOnce = true
EFFECT.AlreadyPlayedSound = false
EFFECT.ShellTime = 1

EFFECT.SpawnTime = 0

function EFFECT:Init(data)

    local att = data:GetAttachment()
    local ent = data:GetEntity()
    local mag = data:GetMagnitude()

    local mdl = LocalPlayer():GetViewModel()

    if LocalPlayer():ShouldDrawLocalPlayer() then
        mdl = ent.WMModel or ent
    end

    if !IsValid(ent) then self:Remove() return end

    local owner = ent:GetOwner()
    if owner != LocalPlayer() then
        mdl = ent.WMModel or ent
    end

    if owner != LocalPlayer() and !ArcCW.ConVars["shelleffects"]:GetBool() then self:Remove() return end
    if !IsValid(mdl) then self:Remove() return end
    if !mdl:GetAttachment(att) then self:Remove() return end

    local origin, ang = mdl:GetAttachment(att).Pos, mdl:GetAttachment(att).Ang

    ang:RotateAroundAxis(ang:Right(), -90 + ent.ShellRotate)

    ang:RotateAroundAxis(ang:Right(), (ent.ShellRotateAngle or Angle(0, 0, 0))[1])
    ang:RotateAroundAxis(ang:Up(), (ent.ShellRotateAngle or Angle(0, 0, 0))[2])
    ang:RotateAroundAxis(ang:Forward(), (ent.ShellRotateAngle or Angle(0, 0, 0))[3])

    local dir = ang:Up()

    local st = ArcCW.ConVars["shelltime"]:GetFloat()

    if ent then
        self.Model = ent:GetBuff_Override("Override_ShellModel") or ent.ShellModel
        self.Material = ent:GetBuff_Override("Override_ShellMaterial") or ent.ShellMaterial
        self.Scale = ent:GetBuff("ShellScale") or 1--ent:GetBuff_Override("Override_ShellScale") or ent.ShellScale or 1
        self.PhysScale = ent:GetBuff_Override("Override_ShellPhysScale") or ent.ShellPhysScale or 1
        self.Pitch = ent:GetBuff_Override("Override_ShellPitch") or ent.ShellPitch or 100
        self.Sounds = ent:GetBuff_Override("Override_ShellSounds") or ent.ShellSounds
        self.ShellTime = (ent.ShellTime or 0) + st

        if self.Sounds == "autocheck" and ent:GetPrimaryAmmoType() then
            local t = ent:GetPrimaryAmmoType()
            if t == game.GetAmmoID("buckshot") then
                self.Sounds = ArcCW.ShotgunShellSoundsTable
            elseif ent.Trivia_Calibre and string.find(ent.Trivia_Calibre, ".22") then
                self.Sounds = ArcCW.TinyShellSoundsTable
            elseif t == game.GetAmmoID("pistol") or t == game.GetAmmoID("357") or t == game.GetAmmoID("AlyxGun") then
                self.Sounds = ArcCW.PistolShellSoundsTable
            elseif t == game.GetAmmoID("ar2") then
                self.Sounds = ArcCW.MediumShellSoundsTable
            else
                self.Sounds = ArcCW.ShellSoundsTable
            end
        end
    end

    self:SetPos(origin)
    self:SetModel(self.Model)
    self:SetModelScale(self.Scale)
    self:DrawShadow(true)
    self:SetAngles(ang)

    if self.Material then
        self:SetMaterial(self.Material)
    end

    local pb_vert = 2 * self.Scale * self.PhysScale
    local pb_hor = 0.5 * self.Scale * self.PhysScale

    self:PhysicsInitBox(Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor))

    self:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE_DEBRIS)

    local phys = self:GetPhysicsObject()

    local plyvel = Vector(0, 0, 0)

    if IsValid(owner) then
        plyvel = owner:GetAbsVelocity()
    end


    phys:Wake()
    phys:SetDamping(0, 0)
    phys:SetMass(1)
    phys:SetMaterial("gmod_silent")

    phys:SetVelocity((dir * mag * math.Rand(1, 2)) + plyvel)

    phys:AddAngleVelocity(VectorRand() * 100)
    phys:AddAngleVelocity(ang:Up() * 2500 * math.Rand(0.75, 1.25))

    self.HitPitch = self.Pitch + math.Rand(-5,5)

    local emitter = ParticleEmitter(origin)

    for i = 1, 3 do
        local particle = emitter:Add("particles/smokey", origin + (dir * 2))

        if (particle) then
            particle:SetVelocity(VectorRand() * 10 + (dir * i * math.Rand(48, 64)) + plyvel)
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(0.05, 0.15))
            particle:SetStartAlpha(math.Rand(40, 60))
            particle:SetEndAlpha(0)
            particle:SetStartSize(0)
            particle:SetEndSize(math.Rand(18, 24))
            particle:SetRoll(math.rad(math.Rand(0, 360)))
            particle:SetRollDelta(math.Rand(-1, 1))
            particle:SetLighting(true)
            particle:SetAirResistance(96)
            particle:SetGravity(Vector(-7, 3, 20))
            particle:SetColor(150, 150, 150)
        end
    end

    self.SpawnTime = CurTime()
end

function EFFECT:PhysicsCollide()
    if self.AlreadyPlayedSound and self.JustOnce then return end

    sound.Play(self.Sounds[math.random(#self.Sounds)], self:GetPos(), 65, self.HitPitch, 1)

    self.AlreadyPlayedSound = true
end

function EFFECT:Think()
    if (self.SpawnTime + self.ShellTime) <= CurTime() then
        if !IsValid(self) then return end
        self:SetRenderFX( kRenderFxFadeFast )
        if (self.SpawnTime + self.ShellTime + 1) <= CurTime() then
            if !IsValid(self:GetPhysicsObject()) then return end
            self:GetPhysicsObject():EnableMotion(false)
            if (self.SpawnTime + self.ShellTime + 1.5) <= CurTime() then
                self:Remove()
                return
            end
        end
    end
    return true
end

function EFFECT:Render()
    if !IsValid(self) then return end
    self:DrawModel()
end
--addons/arccw_weapons/lua/effects/astw2_halo_ce_explosion_fuelrod/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 200
            light.g = 255
            light.b = 155
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo3/muzzle_fuelrod", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 255, 255, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	


	
		for i= 0,3 do
	  local particle = emitter:Add("effects/halo3/smoke_directional_large", self.Origin)

    particle:SetVelocity( Vector(0,math.Rand(75, 100),math.Rand(65, 125)) )
    particle:SetDieTime( math.Rand(0.5,1) )
    particle:SetStartAlpha( 155 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(25,75) )
    particle:SetEndSize( math.Rand(300,350) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 125, 255, 100 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-10,50) ) )
    particle:SetLighting( false )
    particle:SetCollide( false )
	end

    particle = emitter:Add( "effects/halo3/muzzle_plasmapistol", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(250,400) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,150,50 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
	
    particle = emitter:Add( "effects/halo3/electric_arcs", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.3, 0.4) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(300,325) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,225,200 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/astw2_halo_ce_explosion_plasma/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 155
            light.g = 155
            light.b = 255
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo_ce/flare_generic2a", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 215, 215, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	


	
		for i= 0,3 do
	  local particle = emitter:Add("effects/halo3/muzzle_flash_round_fiery", self.Origin)

    particle:SetVelocity( Vector(0,math.Rand(75, 100),math.Rand(65, 125)) )
    particle:SetDieTime( math.Rand(0.5,1) )
    particle:SetStartAlpha( 155 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(25,75) )
    particle:SetEndSize( math.Rand(300,350) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-0.5,0.5) )
    particle:SetColor( 155, 155, 255 )
    particle:SetAirResistance( 55 )
    particle:SetGravity( Vector( 0, 0, math.Rand(-10,50) ) )
    particle:SetLighting( false )
    particle:SetCollide( false )
	end

    particle = emitter:Add( "effects/halo_ce/flare_pr_overcharge", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(75,100) )
        particle:SetEndSize( math.Rand(300,450) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 155,155,255 )
        particle:SetAirResistance( 1500 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
	
    particle = emitter:Add( "effects/halo_ce/flare_generic2a", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.5, 0.7) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(300,325) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 185,185,255 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/effect_astw2_halo2_impact/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/swbf/sparks" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/swrc/smg_impacts", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 10 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			local smokeTexture	= "effects/swbf/thicksmoke"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(2, 5));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(20, 40));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_human/init.lua:

local Tracer = Material( "effects/halo3/trail/beam" )
local Tracer2  = Material( "effects/halo3/trail/wispy_trail" )
local Width = 1
local Width2 = 8

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.07
	self.LifeTime2 = 1.5
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( math.random(220, 255), math.random(205,215), 155, v * math.random(32,64) ) )
	
	-- render.SetMaterial( Tracer2 )
	-- render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( r, b, g, v2 * 50) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_ce_impact_pp/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 48;

local MaterialGlow		= Material( "effects/halo_ce/flare_pr_overcharge" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo_ce/flare_generic2", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 30 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(225, 255, 200);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo_ce/flare_generic2a", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.2, 0.3 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 25 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(225, 255, 200);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end

		
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo_ce/flare_pr_overcharge", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 35 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(225, 255, 200);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 225, 255, 155, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_ce_tracer_pp/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 48;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_pp_side" );
local MaterialFront			= Material( "effects/halo3/muzzle_plasmapistol" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 7, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_ce_tracer_pr/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_pr_side" );
local MaterialFront			= Material( "effects/halo_ce/flare_pr_overcharge" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 7, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_laser_hell/init.lua:

EFFECT.Mat = Material( "cable/orangelaser" )


function EFFECT:Init( data )

	self.texcoord = math.Rand( 0, 20 )/3
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	

	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self.EndPos = data:GetOrigin()
	

	self.Entity:SetCollisionBounds( self.StartPos -  self.EndPos, Vector( 110, 110, 110 ) )
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos, Vector()*8 )
	
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	
	self.Alpha = 255
	self.FlashA = 255
	
end


function EFFECT:Think( )

	self.FlashA = self.FlashA - 2050 * FrameTime()
	if (self.FlashA < 0) then self.FlashA = 0 end

	self.Alpha = self.Alpha - 1650 * FrameTime()
	if (self.Alpha < 0) then return false end
	
	return true

end


function EFFECT:Render( )
	
	self.Length = (self.StartPos - self.EndPos):Length()
	
	local texcoord = self.texcoord
	
		render.SetMaterial( self.Mat )
		render.DrawBeam( self.StartPos, 										// Start
					 self.EndPos,											// End
					 8,													// Width
					 texcoord,														// Start tex coord
					 texcoord + self.Length / 256,									// End tex coord
					 Color( 255, 255, 255, math.Clamp(self.Alpha, 0,255)) )		// Color (optional)'
					 
end

--addons/arccw_weapons/lua/effects/effect_laserhit/init.lua:
function EFFECT:Init( data )
	
	local vOffset = data:GetOrigin()
		self.Origin = data:GetOrigin()
	self.DirVec = data:GetNormal()
	self.Scale = data:GetScale()
		self.Magnitude = data:GetMagnitude()
	self.Emitter = ParticleEmitter( self.Origin )

	local emitter = ParticleEmitter( vOffset )

				for i=1,5 do 
			local Flash = self.Emitter:Add( "effects/redflare", self.Origin )
			if (Flash) then
				Flash:SetVelocity( VectorRand() )
				Flash:SetAirResistance( 200 )
				Flash:SetDieTime( 0.15 )
				Flash:SetStartAlpha( 255 )
				Flash:SetEndAlpha( 0 )
				Flash:SetStartSize( 50 )
				Flash:SetEndSize( 0 )
				Flash:SetRoll( math.Rand(180,480) )
				Flash:SetRollDelta( math.Rand(-1,1) )
				Flash:SetColor(255,255,255)	
			end
		end


		for i=1,2 do 
			local particle = emitter:Add( "effects/redflare", vOffset )

				particle:SetVelocity( 10 * data:GetNormal() )
				particle:SetAirResistance( 600 )

				particle:SetDieTime( 0.2 )

				particle:SetStartAlpha( math.Rand(0, 55) )
				particle:SetEndAlpha( 0 )

				particle:SetStartSize( 8 * i )
				particle:SetEndSize( 5 * i )

				particle:SetRoll( math.Rand(180,480) )
				particle:SetRollDelta( math.Rand(-1,1) )

				particle:SetColor(255,255,255)	
				particle:SetGravity( Vector( math.Rand(-100, 100) * self.Scale, math.Rand(-100, 100) * self.Scale, math.Rand(0, -100) ) ) 		
		end
		
	
			local particle = emitter:Add( "effects/redflare", vOffset )

				particle:SetVelocity( 80 * data:GetNormal() + 20 * VectorRand() )
				particle:SetAirResistance( 200 )

				particle:SetDieTime( math.Rand(0.2, 0.25) )

				particle:SetStartSize( math.random(15,20) )
				particle:SetEndSize( 3 )


				particle:SetRoll( math.Rand(180,480) )
				particle:SetRollDelta( math.Rand(-1,1) )

	emitter:Finish()
	
				Sound( "weapons/laserrifle/impacts/fx_laser_impact_1"..math.random(1,4)..".wav", self.Origin,75, 100)

end

function EFFECT:Think( )

	return false
end

function EFFECT:Render()

end

--addons/arccw_weapons/lua/effects/effect_lasermuzzle_hell/init.lua:
/*---------------------------------------------------------
	EFFECT:Init(data)
---------------------------------------------------------*/
function EFFECT:Init(data)
	
	self.WeaponEnt 		= data:GetEntity()
	self.Attachment 		= data:GetAttachment()
	
	self.Position 		= self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)
	self.Forward 		= data:GetNormal()
	self.Angle 			= self.Forward:Angle()
	self.Right 			= self.Angle:Right()
	self.Up 			= self.Angle:Up()
	

	
	local emitter 		= ParticleEmitter(self.Position)

					local particle = emitter:Add("sprites/ar2_muzzle"..math.random(3,4), self.Position + 8 * self.Forward)

			particle:SetVelocity(350 * self.Forward + 1.1 * self.WeaponEnt:GetOwner():GetVelocity())
			particle:SetAirResistance(160)

			particle:SetDieTime(math.Rand(0, 0.05))

			particle:SetStartAlpha(255)
			particle:SetEndAlpha(255)

			particle:SetStartSize(0)
			particle:SetEndSize(15)

			particle:SetRoll(math.Rand(180, 480))
			particle:SetRollDelta(math.Rand(-1, 1))

			particle:SetColor(255, 92, 92)	

					local particle = emitter:Add("effects/ongflare", self.Position + 8 * self.Forward)

			particle:SetVelocity(350 * self.Forward + 1.1 * self.WeaponEnt:GetOwner():GetVelocity())
			particle:SetAirResistance(160)

			particle:SetDieTime(0.04)

			particle:SetStartAlpha(255)
			particle:SetEndAlpha(255)

			particle:SetStartSize(5)
			particle:SetEndSize(20)

			particle:SetRoll(math.Rand(180, 480))
			particle:SetRollDelta(math.Rand(-1, 1))

			particle:SetColor(255, 255, 255)
			
								local particle = emitter:Add("effects/ongflare", self.Position + 8 * self.Forward)

			particle:SetVelocity(350 * self.Forward + 1.1 * self.WeaponEnt:GetOwner():GetVelocity())
			particle:SetAirResistance(160)

			particle:SetDieTime(0.04)

			particle:SetStartAlpha(255)
			particle:SetEndAlpha(255)

			particle:SetStartSize(15)
			particle:SetEndSize(20)

			particle:SetRoll(math.Rand(180, 480))
			particle:SetRollDelta(math.Rand(-1, 1))

			particle:SetColor(255, 255, 255)
			
					local particle = emitter:Add("effects/ongflare", self.Position)

			particle:SetVelocity(100 * self.Forward + 8 * VectorRand()) -- + AddVel)
			particle:SetAirResistance(400)
			particle:SetGravity(Vector(0, 0, math.Rand(25, 100)))

			particle:SetDieTime(math.Rand(0, 1))

			particle:SetStartAlpha(255)
			particle:SetEndAlpha(255)

			particle:SetStartSize(math.Rand(10, 13))
			particle:SetEndSize(0)

			particle:SetRoll(math.Rand(-25, 25))
			particle:SetRollDelta(math.Rand(-0.05, 0.05))

			particle:SetColor(255, 255, 255)

	emitter:Finish()
end

/*---------------------------------------------------------
	EFFECT:Think()
---------------------------------------------------------*/
function EFFECT:Think()

	return false
end

/*---------------------------------------------------------
	EFFECT:Render()
---------------------------------------------------------*/
function EFFECT:Render()
end

--addons/aoc_nextbots/lua/effects/effect_npc_laser_green_long.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6

EFFECT.Speed = 6500
EFFECT.Length = 512
EFFECT.WhizDistance = 72

local MaterialMain = Material("effects/sw_laser_green_main")
local MaterialFront = Material("effects/sw_laser_green_front")
local MaterialGlow = Material("sprites/light_glow02_add")
local ColorRed = Color(0, 255, 34)

function EFFECT:GetTracerOrigin(data)
    local start = data:GetStart()

    if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
        local entity = data:GetEntity()

        if (not IsValid(entity)) then
            return start
        end
        if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then
            return start
        end

        if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
            local pl = entity:GetOwner()
            if (IsValid(pl)) then
                local vm = pl:GetViewModel()
                if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
                    entity = vm
                else
                    if (entity.WorldModel) then
                        entity:SetModel(entity.WorldModel)
                    end
                end
            end
        end

        local attachment = entity:GetAttachment(data:GetAttachment())
        if (attachment) then
            start = attachment.Pos
        end
    end

    return start
end

function EFFECT:Init(data)
    self.StartPos = self:GetTracerOrigin(data)
    self.EndPos = data:GetOrigin()

    self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)

    local diff = (self.EndPos - self.StartPos)

    self.Normal = diff:GetNormal()
    self.StartTime = 0
    self.LifeTime = (diff:Length() + self.Length) / self.Speed

    local weapon = data:GetEntity()
    if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
        local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
    end
end

function EFFECT:Think()
    self.LifeTime = self.LifeTime - FrameTime()
    self.StartTime = self.StartTime + FrameTime()

    return self.LifeTime > 0
end

function EFFECT:Render()
    local endDistance = self.Speed * self.StartTime
    local startDistance = endDistance - self.Length

    startDistance = math.max(0, startDistance)
    endDistance = math.max(0, endDistance)

    local startPos = self.StartPos + self.Normal * startDistance
    local endPos = self.StartPos + self.Normal * endDistance

    render.SetMaterial(MaterialFront)
    render.DrawSprite(endPos, 8, 8, color_white)

    render.SetMaterial(MaterialMain)
    render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--addons/aoc_nextbots/lua/effects/effect_npc_laser_yellow.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6

EFFECT.Speed = 6500
EFFECT.Length = 64
EFFECT.WhizDistance = 72

local MaterialMain = Material("effects/sw_l/rw_sw_laser_m_orange")
local MaterialFront = Material("effects/sw_l/rw_sw_laser_f_orange")
local MaterialGlow = Material("sprites/light_glow02_add")
local ColorRed = Color(255, 208, 0)

function EFFECT:GetTracerOrigin(data)
    local start = data:GetStart()

    if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
        local entity = data:GetEntity()

        if (not IsValid(entity)) then
            return start
        end
        if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then
            return start
        end

        if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
            local pl = entity:GetOwner()
            if (IsValid(pl)) then
                local vm = pl:GetViewModel()
                if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
                    entity = vm
                else
                    if (entity.WorldModel) then
                        entity:SetModel(entity.WorldModel)
                    end
                end
            end
        end

        local attachment = entity:GetAttachment(data:GetAttachment())
        if (attachment) then
            start = attachment.Pos
        end
    end

    return start
end

function EFFECT:Init(data)
    self.StartPos = self:GetTracerOrigin(data)
    self.EndPos = data:GetOrigin()

    self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)

    local diff = (self.EndPos - self.StartPos)

    self.Normal = diff:GetNormal()
    self.StartTime = 0
    self.LifeTime = (diff:Length() + self.Length) / self.Speed

    local weapon = data:GetEntity()
    if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
        local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
    end
end

function EFFECT:Think()
    self.LifeTime = self.LifeTime - FrameTime()
    self.StartTime = self.StartTime + FrameTime()

    return self.LifeTime > 0
end

function EFFECT:Render()
    local endDistance = self.Speed * self.StartTime
    local startDistance = endDistance - self.Length

    startDistance = math.max(0, startDistance)
    endDistance = math.max(0, endDistance)

    local startPos = self.StartPos + self.Normal * startDistance
    local endPos = self.StartPos + self.Normal * endDistance

    render.SetMaterial(MaterialFront)
    render.DrawSprite(endPos, 8, 8, color_white)

    render.SetMaterial(MaterialMain)
    render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)

    render.SetMaterial(MaterialGlow)
    render.DrawSprite(startPos, 50, 50, ColorRed)
end

--addons/lvs_base/lua/effects/lvs_bullet_impact_explosive.lua:

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	self.Dir = data:GetNormal()
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local scale = data:GetMagnitude() * 0.5

	self.Scale = 3 * scale

	local emitter = ParticleEmitter( self.Pos, false )

	local VecCol = (render.GetLightColor( self.Pos + self.Dir ) * 0.5 + Vector(0.1,0.09,0.075)) * 255

	local DieTime = math.Rand(0.8,1.6)

	local traceSky = util.TraceLine( {
		start = self.Pos,
		endpos = self.Pos + Vector(0,0,50000),
		filter = self,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = self.Pos - Vector(0,0,100),
		filter = self,
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	end

	local Pos = self.Pos
	local Dist = (traceWater.HitPos - Pos):Length()
	local ply = LocalPlayer():GetViewEntity()

	if not IsValid( ply ) then return end

	local delay = (Pos - ply:GetPos()):Length() / 13503.9

	if traceWater.Hit and Dist > 150 then
		timer.Simple( delay, function()
			local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
			util.Effect( "WaterSurfaceExplosion", effectdata, true, true )
		end )

		if Dist > 300 then return end
	else
		timer.Simple( delay, function()
			sound.Play( "LVS.BULLET_EXPLOSION", Pos )
			sound.Play( "LVS.BULLET_EXPLOSION_DYNAMIC", Pos )
		end )

		local trace = util.TraceLine( {
			start = self.Pos + Vector(0,0,100),
			endpos = self.Pos - Vector(0,0,100),
			mask = MASK_SOLID_BRUSHONLY,
		} )

		if trace.Hit and not trace.HitNonWorld then
			util.DecalEx( self.DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), self.Scale * 2.5, self.Scale * 2.5 )
		end
	end

	if self.Dir.z > 0.8 then
		for i = 1, 10 do
			for n = 0,6 do
				local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ], self.Pos )

				if not particle then continue end

				particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 25) * self.Scale )
				particle:SetDieTime( (i / 8) * DieTime )
				particle:SetAirResistance( 10 ) 
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( 10 * self.Scale )
				particle:SetEndSize( 20 * i * self.Scale )
				particle:SetRollDelta( math.Rand(-1,1) )
				particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
				particle:SetGravity( Vector(0,0,-600) * self.Scale )
				particle:SetCollide( false )
			end
		end

		for i = 1, 10 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ], self.Pos )

			if not particle then continue end

			particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 40) * self.Scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * self.Scale )
			particle:SetEndSize( 20 * i * self.Scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) * self.Scale )
			particle:SetCollide( false )
		end
	end

	for i = 1,24 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , self.Pos )
		
		if not particle then continue end

		local ang = i * 15
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )

		local Vel = Vector(X,Y,0) * math.Rand(800,1200)
		Vel:Rotate( self.Dir:Angle() + Angle(90,0,0) )

		particle:SetVelocity( Vel * self.Scale )
		particle:SetDieTime( math.Rand(1,3) )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 40 * self.Scale )
		particle:SetEndSize( 140 * self.Scale )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,60) * self.Scale )
		particle:SetCollide( true )
	end

	for i = 0, 15 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 * scale )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( 200 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 200 * scale )
			particle:SetEndSize( 600 * scale )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector( 0, 0, -600 ) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 800 * scale )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 120 * scale )
		particle:SetEndSize( 20 * scale )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( self.Dir * 2500 )
		particle:SetRollDelta( math.Rand(-5,5) )
		particle:SetAirResistance( 300 )
	end

	for i = 0, 5 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )

		if not particle then continue end

		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( Vector(0,0,0) )

		local size = math.Rand(8, 24) * scale
		particle:SetEndSize( size )
		particle:SetStartSize( size )

		particle:SetStartLength( 400 * scale )
		particle:SetEndLength( size )

		particle:SetDieTime( math.Rand(0.1,0.2) )
		particle:SetVelocity( (self.Dir * 4000 + VectorRand() * 2000) * scale )

		particle:SetAirResistance( 0 )
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/fire_embers"..math.random(1,2), self.Pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 800 * scale )
		particle:SetDieTime( math.Rand(0.4,0.6) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 40 * scale )
		particle:SetEndSize( 0 )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( Vector(0,0,600) )
		particle:SetRollDelta( math.Rand(-8,8) )
		particle:SetAirResistance( 300 )
	end

	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0, 40 do
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	if not self.Scale then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local R1 = 800 * self.Scale
	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, R1 * Scale, R1 * Scale, Color( 255, 200, 150, 255) )
end

--addons/lvs_base/lua/effects/lvs_explosion_small.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	for i = 0, 15 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 200 )
			particle:SetStartSize( 120 )
			particle:SetEndSize( 300 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( math.Rand(0.15,0.3) )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 25 )
			particle:SetEndSize( math.Rand(70,100) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", self.Pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(20,40) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( 0 )
			particle:SetColor( 255, 255, 255 )

			particle:SetAirResistance( 0 )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 2000 * Scale, 2000 * Scale, Color( 255, 200, 150, 255) )
end

--addons/lvs_addons/lua/effects/lvs_laat_wing_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	self.StartPos = Vector(-172.97,334.04,93.25)
	self.EndPos = self.Entity:GetWingTurretTarget()
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.Entity:GetWingTurretFire() then
		return false
	end

	self.EndPosDesired = self.Entity:GetWingTurretTarget() 
	self:SetRenderBoundsWS( self.Entity:GetPos(), self.EndPosDesired )

	return true

end

function EFFECT:Render()
	if not self.EndPosDesired then return end

	self.EndPos = self.EndPos + (self.EndPosDesired - self.EndPos) * FrameTime() * 10

	for i = -1,1,2 do
		local StartPos = self.Entity:LocalToWorld( self.StartPos * Vector(1,i,1) )

		local Trace = util.TraceLine( { start = StartPos, endpos = self.EndPos} )
		local EndPos = Trace.HitPos

		if self.Entity:WorldToLocal( EndPos ).z < 0 then
			self.StartPos = Vector(-172.97,334.04,93.25)
		else
			self.StartPos = Vector(-174.79,350.05,125.98)
		end

		if Trace.Entity == self.Entity then continue end

		render.SetMaterial( self.Mat )
		render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,255,0,255) )
		render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )

		render.SetMaterial( self.HitMat )
		local A = 150 + math.random(0,20)
		local B = 70 + math.random(0,20)
		render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
		render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )

		render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
		render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

		if math.random(0,5) == 1 then
			local emitter = ParticleEmitter( EndPos, false )
			local dir = (self.Entity:GetPos() - EndPos):GetNormalized()

			for i = 0, 10 do
				local particle = emitter:Add( "sprites/rico1", EndPos )

				local vel = VectorRand()  * 100 + dir * 40

				if not particle then continue end

				particle:SetVelocity( vel )
				particle:SetAngles( vel:Angle() + Angle(0,90,0) )
				particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(1,30) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(-100,100) )
				particle:SetRollDelta( math.Rand(-100,100) )

				particle:SetAirResistance( 0 )
			end

			emitter:Finish()
		end
	end
end

--addons/lvs_base/lua/effects/lvs_muzzle.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Vel = Dir * 10

	if IsValid( Ent ) then
		Vel = Ent:GetVelocity()
	end

	local emitter = ParticleEmitter( Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0, 12 do
		local particle = emitter:Add( "effects/muzzleflash2", Pos + Dir * i * 0.7 * math.random(1,2) * 0.5 )
		local Size = 1

		if not particle then continue end

		particle:SetVelocity( Dir * 800 + Vel )
		particle:SetDieTime( 0.05 )
		particle:SetStartAlpha( 255 * Size )
		particle:SetStartSize( math.max( math.random(10,24) - i * 0.5,0.1 ) * Size )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( 255, 255, 255 )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_addons/lua/effects/lvs_proton_trail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "effects/select_ring" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 8 )
			particle:SetEndSize( 1 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,255 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 6 )
			particle:SetEndSize( 2 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,255 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity
	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )

	render.DrawSprite( pos, 100, 100, Color( 0, 127, 255, 50 ) )
end

--addons/laat_g/lua/effects/lvs_proton_trail_large.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "effects/select_ring" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 100 )
			particle:SetEndSize( 1 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,255 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 50 )
			particle:SetEndSize( 2 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,255 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity
	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )

	render.DrawSprite( pos, 500, 500, Color( 0, 127, 255, 50 ) )
end

--addons/weapon_jedi/lua/effects/saber_hit.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Dir = data:GetNormal()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	self:Spark( self.Pos, self.Dir )
	self:Smoke( self.Pos, self.Dir )
end


function EFFECT:Smoke( pos, dir )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0,10 do
		local particle = emitter:Add( Materials[ math.random(1,table.Count( Materials )) ], pos )
		
		local vel = VectorRand() * math.Rand(200,600)
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(0.5,1.5) )
			particle:SetAirResistance( 1000 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 0 )
			particle:SetEndSize( math.Rand(50,120) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40,40,40 )
			particle:SetGravity( Vector(0,0,200) )
			particle:SetCollide( false )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Spark( pos, dir )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", pos )
		
		local vel = VectorRand() * 100 + dir * 40
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(2,4) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(2,4) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 255,100,0 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end
	
	return true
end

local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos + self.Dir, 150 * Scale, 150 * Scale, Color( 255, 150, 50, 255) ) 
end

--lua/effects/swexplosion.lua:

/*---------------------------------------------------------
   Initializes the effect. The data is a table of data
   which was passed from the server.
---------------------------------------------------------*/
function EFFECT:Init( data )

	local vOffset = data:GetOrigin()
	local vNorm = data:GetStart()
	local mag = math.Clamp(data:GetMagnitude(),1,4);
	local NumParticles = 2

	local emitter = ParticleEmitter( vOffset )
        if (not emitter) then return end
		for i=0, NumParticles do

			particle = emitter:Add( "particle/particle_smokegrenade", vOffset )
			if (particle) then

				local Vec = vNorm + VectorRand()
				particle:SetVelocity( Vector(Vec.x, Vec.y, math.Rand(0.5,2)) * 1500)

				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.75 )

				particle:SetStartAlpha( 0 )
				particle:SetEndAlpha( 0 )

				particle:SetStartSize( 5 )
				particle:SetEndSize( 5 )

				particle:SetColor(0,0,0)

				//particle:SetRoll( math.Rand(0, 360) )
				//particle:SetRollDelta( math.Rand(-200, 200) )

				particle:SetAirResistance( 120 )

				particle:SetGravity( Vector( 0, 0, -1000 ) )

				particle:SetCollide( true )
				particle:SetBounce( 0.5 )
				particle:SetThinkFunction(ParticleThink)
				particle:SetNextThink(CurTime() + 0.1)

			end

			particle2 = emitter:Add( "particles/smokey", vOffset )
			if (particle2) then

				local Vec2 = VectorRand()
				particle2:SetVelocity( Vector(Vec2.x, Vec2.y, math.Rand(0.1,1.5)) * 1200 * mag)

				particle2:SetLifeTime( 0 )
				particle2:SetDieTime( 6 )

				particle2:SetStartAlpha( 250 )
				particle2:SetEndAlpha( 0 )

				particle2:SetStartSize( 150 )
				particle2:SetEndSize( 200 )

				particle2:SetColor(150,150,140)

				//particle2:SetRoll( math.Rand(0, 360) )
				//particle2:SetRollDelta( math.Rand(-200, 200) )

				particle2:SetAirResistance( 250 )

				particle2:SetGravity( Vector( 100, 100, -80 ) )

				particle2:SetLighting( true )
				particle2:SetCollide( true )
				particle2:SetBounce( 0.5 )

			end

			particle3 = emitter:Add( "particle/particle_smokegrenade", vOffset )
			if (particle3) then

				local Vec3 = VectorRand()
				particle3:SetVelocity( Vector(Vec3.x, Vec3.y, math.Rand(0.05,1.5)) * 500)

				particle3:SetLifeTime( 0 )
				particle3:SetDieTime( 3 )

				particle3:SetStartAlpha( 255 )
				particle3:SetEndAlpha( 0 )

				particle3:SetStartSize( 100 )
				particle3:SetEndSize( 120 )

				particle3:SetColor(255,80,20)
				particle3:SetRoll( math.Rand(0, 360) )
				particle3:SetRollDelta( math.Rand(-2, 2) )

				particle3:SetAirResistance( 150 )

				particle3:SetGravity( Vector( math.Rand(-200,200), math.Rand(-200,200), 400 ) )
				particle3:SetCollide( true )
				particle3:SetBounce( 1 )

			end

			particle4 = emitter:Add( "effects/fire_cloud1", vOffset )
			if (particle4) then

				local Vec4 = VectorRand()
				particle4:SetVelocity( Vector(Vec4.x, Vec4.y, math.Rand(0.05,1.5)) * 500 * mag)

				particle4:SetLifeTime( 0 )
				particle4:SetDieTime( 3 )

				particle4:SetStartAlpha( 255 )
				particle4:SetEndAlpha( 0 )

				particle4:SetStartSize( 100 )
				particle4:SetEndSize( 120 )

				particle4:SetColor(255,80,20)
				particle4:SetRoll( math.Rand(0, 360) )
				particle4:SetRollDelta( math.Rand(-2, 2) )

				particle4:SetAirResistance( 150 )

				particle4:SetGravity( Vector( math.Rand(-200,200), math.Rand(-200,200), 400 ) )
				particle4:SetCollide( true )
				particle4:SetBounce( 1 )

			end

		end

	--emitter:Finish()
end

function EFFECT:SetParticles(num)
	
	self.NumOfParticles = num;

end


/*---------------------------------------------------------
   THINK
---------------------------------------------------------*/
function EFFECT:Think( )
	return false
end

function ParticleThink( part )

	if (part.Time and part.Time==CurTime()) then part:SetNextThink( CurTime() + 0.1 ); return end
	part.Time = CurTime();

	if part:GetLifeTime() > 0.18 then
		local vOffset = part:GetPos()
		local emitter = ParticleEmitter( vOffset )

		if emitter == nil then return end
		local particle = emitter:Add( "particles/smokey", vOffset )

		if (particle) then

			particle:SetLifeTime( 0 )
			particle:SetDieTime( 3.5 - part:GetLifeTime() * 2 )

			particle:SetStartAlpha( 150 )
			particle:SetEndAlpha( 0 )

			particle:SetStartSize( (90 - (part:GetLifeTime() * 100)) / 2 )
			particle:SetEndSize( 100 - (part:GetLifeTime() * 100) )

			particle:SetColor(150,150,140)

			particle:SetRoll( math.Rand(-0.5, 0.5) )
			particle:SetRollDelta( math.Rand(-0.5, 0.5) )

			particle:SetAirResistance( 250 )

			particle:SetGravity( Vector( 200, 200, -100 ) )

			particle:SetLighting( true )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )

		end
		--emitter:Finish()
	end

	part:SetNextThink( CurTime() + 0.1 )
end

/*---------------------------------------------------------
   Draw the effect
---------------------------------------------------------*/
function EFFECT:Render()
end

--addons/arccw_weapons/lua/effects/thetalaser_min/init.lua:

EFFECT.Mat = Material( "effects/blueblacklargebeam" )


function EFFECT:Init( data )

	self.texcoord = math.Rand( 0, 20 )/3
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	

	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self.EndPos = data:GetOrigin()
	

	self.Entity:SetCollisionBounds( self.StartPos -  self.EndPos, Vector( 110, 110, 110 ) )
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos, Vector()*8 )
	
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	
	self.Alpha = 255
	self.FlashA = 255
	
	self.WeaponEnt 		= data:GetEntity()
	self.Attachment 		= data:GetAttachment()
	
	self.Position 		= self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)
	self.Forward 		= data:GetNormal()
	self.Angle 			= self.Forward:Angle()
	self.Right 			= self.Angle:Right()
	self.Up 			= self.Angle:Up()
	
			local emitter = ParticleEmitter(self.Position)
			local particle = emitter:Add("effects/yellowflare", self.Position)
			particle:SetVelocity(500 * self.Forward + 15 * VectorRand()) -- + AddVel)
			particle:SetAirResistance(0)
			particle:SetGravity(Vector(0, 0, math.Rand(25, 100)))
			particle:SetDieTime(math.Rand(1, 2))
			particle:SetStartAlpha(0)
			particle:SetEndAlpha(0)
			particle:SetStartSize(1)
			particle:SetEndSize(0)
			particle:SetRoll(math.Rand(-5, 45))
			particle:SetRollDelta(math.Rand(-0.05, 0.05))
			particle:SetColor(0, 0, 0)
			
	emitter:Finish()
	
	
end


function EFFECT:Think( )

	self.FlashA = self.FlashA - 1150 * FrameTime()
	if (self.FlashA < 0) then self.FlashA = 0 end

	self.Alpha = self.Alpha - 1150 * FrameTime()
	if (self.Alpha < 0) then return false end
	
	return true

end


function EFFECT:Render( )
	
	self.Length = (self.StartPos - self.EndPos):Length()
	
	local texcoord = self.texcoord
	
		render.SetMaterial( self.Mat )
		render.DrawBeam( self.StartPos, 										// Start
					 self.EndPos,											// End
					 7,													// Width
					 texcoord,														// Start tex coord
					 texcoord + self.Length / 256,									// End tex coord
					 Color( 222, 25, 11, math.Clamp(self.Alpha, 0,255)) )		// Color (optional)'
					 
end

--addons/arccw_weapons/lua/effects/tracer_laser_big/init.lua:
EFFECT.Thickness = 16
EFFECT.Life = 0.25
EFFECT.RotVelocity = 30
EFFECT.InValid = false
local Mat_Impact = Material("effects/combinemuzzle2")
local Mat_Beam = Material("effects/tool_tracer")
local Mat_TracePart = Material("effects/select_ring")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	self.Alpha = 255
	self.FlashA = 255
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			self.Attachment = 2 - self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = vector_origin,
			Ang = angle_zero
		}
	end
	self.texcoord = math.Rand( 0, 20 )/3

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = 0
	
end
EFFECT.Mat = Material( "effects/blueblacklargebeam" )
function EFFECT:Think()
	if self.InValid then return false end
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	self.FlashA = self.FlashA - 1150 * FrameTime()
	if (self.FlashA < 0) then self.FlashA = 0 end

	self.Alpha = self.Alpha - 1150 * FrameTime()
	if (self.Alpha < 0) then return false end
	
	return self.LifeTime > 0
end



local beamcol = Color(255, 0, 0, 255)
local beamcol2 = Color(255, 0, 0, 255)

function EFFECT:Render()
	if self.InValid then return false end
	self.StartPos = self:GetTracerShootPos(self.StartPos, self.WeaponEnt, self.Attachment)
	local startPos = self.StartPos
	local endPos = self.EndPos
	
	local tracerpos
	beamcol.a = self.LifeTime / self.Life * 255
	self.rot = self.rot + FrameTime() * self.RotVelocity
	render.SetMaterial(Mat_Impact)
	render.DrawSprite(endPos, 12, 12, ColorAlpha(color_white, beamcol.a))
	render.SetMaterial(Mat_TracePart)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life - 0.1, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot - 60)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life - 0.05, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot - 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.05, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.1, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 60)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.15, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.2, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 60)
	render.SetMaterial(Mat_Beam)
	render.DrawBeam(startPos, endPos, self.Thickness, 0 + beamcol.a / 128, endPos:Distance(startPos) / 64 + beamcol.a / 128, beamcol)
	local texcoord = self.texcoord
	render.SetMaterial( self.Mat )
		render.DrawBeam( self.StartPos, 										// Start
					 self.EndPos,											// End
					 20,													// Width
					 texcoord,														// Start tex coord
					 texcoord + 8000 / 256,									// End tex coord
					 Color( 222, 25, 11, math.Clamp(self.Alpha, 0,255)) )		// Color (optional)'
end

--addons/gm_prone/lua/prone/config.lua:
-------------------
-- General Settings
-------------------
-- What should we multiply fall damage by while prone. Set to 1 to disable.
prone.Config.FallDamageMultiplier = 1.75


-----------------------
-- Key-related settings
-----------------------
-- NOTICE:	Every setting in this section can later be changed
--			by the user with the "prone_config" command.

-- By default is the bind key enabled.
prone.Config.DefaultBindKey_Enabled = false

-- What is the default bind key set by the server.
-- See http://wiki.garrysmod.com/page/Enums/KEY
prone.Config.DefaultBindKey = KEY_LCONTROL

-- By default should the player double tap the bind key to go prone.
prone.Config.DefaultBindKey_DoubleTap = false

-- By default can the user press the jump key to get up.
prone.Config.DefaultJumpToGetUp = true

-- By default must the user double press the jump key to get up.
prone.Config.DefaultJumpToGetUp_DoubleTap = false

--------------
-- Move speeds
--------------
-- How fast they move while prone.
prone.Config.MoveSpeed = 50

-- How fast they move while getting up or going down.
-- Prefer to keep this at 0, otherwise if they move somewhere they cant fit while getting up
-- they will be forced back into prone.
prone.Config.TransitionSpeed = 0

----------------------------
-- Shooting related settings
----------------------------
-- There are no moving and shooting animations while prone so it would look like
-- players aren't shooting when they are. You probably don't want to change this to false.
prone.Config.MoveShoot_Restrict = true

-- Weapons in this list can be shot while moving
prone.Config.MoveShoot_Whitelist = {
	weapon_physgun			= true,
	weapon_physcannon		= true,		-- Gravity Gun
	gmod_tool				= true,		-- Toolgun
	gmod_camera				= true,
	weapon_medkit			= true,
	weaponchecker			= true,		-- (DarkRP)
	keys					= true,		-- (DarkRP)
	pocket					= true,		-- (DarkRP)
	weapon_keypadchecker	= true,		-- (DarkRP)
	unarrest_stick			= true,		-- (DarkRP)
	arrest_stick			= true,		-- (DarkRP)
	weapon_zm_carry			= true,		-- (TTT) Magneto Stick
	weapon_ttt_binoculars	= true,		-- (TTT)
	weapon_ttt_unarmed		= true		-- (TTT)
}


--------------------------
-- DarkRP related settings
--------------------------
-- Should we restrict prone by job.
prone.Config.Darkrp_RestrictJobs = false

-- Is the job list a whitelist? False for blacklist.
prone.Config.Darkrp_IsWhitelist = true

-- If the above setting is true this is the job whitelist. Blacklist otherwise.
prone.Config.Darkrp_Joblist = {
	TEAM_POLICE,
	TEAM_GANG
}

-- Any players of these ranks can go prone, no matter of their job.
prone.Config.Darkrp_BypassRanks = {
	"superadmin",
	"admin"
}

--------------------
-- Advanced Settings
--------------------
-- Sets the hull height while prone. What you can fit under.
prone.Config.HullHeight = 24

-- Sets how low the player's view will be while prone.
prone.Config.View = Vector(0, 0, 20)

prone.Animations.gettingdown = "pronedown_stand"
prone.Animations.gettingup = "proneup_stand"
prone.Animations.passive = "prone_walkpassive"

-- These two are not in use right now.
prone.Animations.gettingdown_crouch = "pronedown_crouch"
prone.Animations.gettingup_crouch = "proneup_crouch"

prone.Animations.WeaponAnims = {
	moving = {
		ar2			= "prone_walktwohand",
		camera		= "prone_walkonehand",
		crossbow	= "prone_walkcrossbow",
		duel		= "prone_walkcrossbow",
		fist		= "prone_walkpassive",
		grenade		= "prone_walkonehand",
		knife		= "prone_walkpassive",
		magic		= "prone_walkpassive",
		melee		= "prone_walkonehand",
		melee2		= "prone_walkonehand",
		normal		= "prone_walkpassive",
		passive		= "prone_walkpassive",
		pistol		= "prone_walkonehand",
		physgun		= "prone_walkphysgun",
		revolver	= "prone_walkonehand",
		rpg			= "prone_walkrpg",
		shotgun		= "prone_walktwohand",
		slam		= "prone_walkonehand",
		smg			= "prone_walktwohand"
	},

	idle = {
		ar2			= "prone_ar2",
		camera		= "prone_camera",
		crossbow	= "prone_crossbow",
		duel		= "prone_crossbow",
		fist		= "prone_knife",
		grenade		= "prone_grenade",
		knife		= "prone_knife",
		magic		= "prone_knife",
		melee		= "prone_melee",
		melee2		= "prone_melee2",
		normal		= "prone_passive",
		passive		= "prone_passive",
		pistol		= "prone_pistol",
		physgun		= "prone_physgun",
		revolver	= "prone_revolver",
		rpg			= "prone_rpg",
		shotgun		= "prone_shotgun",
		slam		= "prone_slam",
		smg			= "prone_smg1"
	}
}
--addons/gm_prone/lua/prone/cl_prone.lua:
hook.Add("EntityNetworkedVarChanged", "prone.DetectProneStateChanges", function(ply, nwVarName, oldVal, newVal)
	if nwVarName == "prone.AnimationState" then
		if newVal == PRONE_GETTINGDOWN or newVal == PRONE_GETTINGUP then
			ply:AnimRestartMainSequence()
			ply:SetCycle(0)
			ply:SetPlaybackRate(1)
		elseif newVal == PRONE_NOTINPRONE then
			ply:ResetHull()
		end
	end
end)

-- Called to inform the player that they can't get up.
local lastGetUpPrintTime = 0		-- Last time a print was made.
local getUpWarningPrintDelay = 2	-- Time it takes before allowing another print.
function prone.CantGetUpWarning()
	local ct = CurTime()

	if lastGetUpPrintTime < ct then
		chat.AddText(Color(210, 10, 10), "Hier ist nicht genügend Platz um aufzustehen.")
		lastGetUpPrintTime = ct + getUpWarningPrintDelay
	end
end

--------------------
-- prone.SetImpulse
--------------------
-- Desc:		This is the proper, predicted, way to toggle prone.
-- Arg One:		CUserCmd object, to set the impulse on.
function prone.SetImpulse(cmd)
	cmd:SetImpulse(PRONE_IMPULSE)
end

-----------------
-- prone.Request
-----------------
-- Desc:		Begins sending a prone impulse to the server.
local SendImpulse = false
function prone.Request()
	SendImpulse = true
end
concommand.Add("prone", function()
	prone.Request()
end)

-------------------
-- Bind key handler
-------------------
local function boolToNumString(bool)
	return bool and "1" or "0"
end
local bindkey_enabled = CreateClientConVar("prone_bindkey_enabled", boolToNumString(prone.Config.DefaultBindKey_Enabled), true, false, "Disable this to disable the prone bind key from working.")
local bindkey_key = CreateClientConVar("prone_bindkey_key", tostring(prone.Config.DefaultBindKey), true, false, "Don't directly change this convar. Use the command prone_config.")
local bindkey_doubletap = CreateClientConVar("prone_bindkey_doubletap", boolToNumString(prone.Config.DefaultBindKey_DoubleTap), true, false, "Enable to make them double tap the bind key to go prone.")
local jumptogetup = CreateClientConVar("prone_jumptogetup", "1", boolToNumString(prone.Config.DefaultJumpToGetUp), false, "If enabled you can press the jump key to get up.")
local jumptogetup_doubletap = CreateClientConVar("prone_jumptogetup_doubletap", boolToNumString(prone.Config.DefaultJumpToGetUp_DoubleTap), true, false, "If enabled you must double press jump to get up.")

local key_waspressed = false
local last_prone_request = 0
local doubletap_shouldsend = true
local doubletap_keypress_resettime = false
hook.Add("CreateMove", "prone.ReadBindKeys", function(cmd)
	local ply = LocalPlayer()
	if not IsValid(ply) then
		return
	end

	if SendImpulse then
		prone.SetImpulse(cmd)

		if cmd:TickCount() ~= 0 then
			SendImpulse = false
		end
	end

--[[ 	if (system.IsLinux() or system.HasFocus()) and bindkey_enabled:GetBool() and ply:OnGround() and not vgui.GetKeyboardFocus() and not gui.IsGameUIVisible() and not gui.IsConsoleVisible() then
		if input.IsKeyDown(bindkey_key:GetInt()) then
			key_waspressed = true

			-- If doubletap is enabled they have a second to double click the bind key.
			doubletap_keypress_resettime = CurTime() + .66
		else
			if key_waspressed then
				if last_prone_request < CurTime() then
					doubletap_shouldsend = not doubletap_shouldsend

					if not bindkey_doubletap:GetBool() or doubletap_shouldsend then
						prone.Request()

						last_prone_request = CurTime() + 1.25
					end
				end

				key_waspressed = false
			end
		end

		if doubletap_keypress_resettime ~= false and doubletap_keypress_resettime < CurTime() then
			doubletap_keypress_resettime = false
			doubletap_shouldsend = true
		end
	end ]]
end)

-- If they enable jump to get up then read that here.
local jumptogetup_presstime = 0
hook.Add("KeyPress", "Prone.JumpToGetUp", function(ply, key)
	if IsFirstTimePredicted() and ply == LocalPlayer() and ply:IsProne() and jumptogetup:GetBool() and key == IN_JUMP then
		if not jumptogetup_doubletap:GetBool() then
			prone.Request()
		else
			if jumptogetup_presstime > CurTime() then
				prone.Request()
			else
				jumptogetup_presstime = CurTime() + 1.25
			end
		end
	end
end)

-------------------
-- View Transitions
-------------------

-- Addons should use the prone.ShouldChangeCalcView and prone.ShouldChangeCalcViewModelView hooks instead of this cvar.
local enabledViewTransitions = CreateClientConVar("prone_disabletransitions", "0", true, false, "Disables the slide down and up of the get up/down animations.")

do
	local from, to, animEndTime, animLength, transitionVector
	hook.Add("CalcView", "prone.ViewTransitions", function(ply, pos)
		if ply ~= LocalPlayer() or enabledViewTransitions:GetBool() then
			return
		end

		local proneState = ply:GetProneAnimationState()

		-- Reset state and return if were not in a transition phase.
		if proneState ~= PRONE_GETTINGDOWN and proneState ~= PRONE_GETTINGUP then
			from = nil
			to = nil
			timeDiff = nil
			animLength = nil
			animEndTime = nil
			transitionVector = nil
			return
		end
		
		local result = hook.Run("prone.ShouldChangeCalcView", localply)
		if result == false then
			return
		end

		-- Get original view offset.
		local oldViewOffset = Vector(0, 0, 64)
		local plyProneStateData = prone.PlayerStateDatas[ply:SteamID()]
		if plyProneStateData then
			oldViewOffset = plyProneStateData:GetOriginalViewOffset()
			ply:SetViewOffsetDucked(plyProneStateData:GetOriginalViewOffsetDucked())
		end

		-- Set from, to, animLength, and animEndTime, at start of get down/up.
		if not from then
			animLength = ply:SequenceDuration((proneState == PRONE_GETTINGDOWN) and ply:LookupSequence("pronedown_stand") or ply:LookupSequence("proneup_stand"))
			animEndTime = SysTime() + animLength

			-- Getting down
			if proneState == PRONE_GETTINGDOWN then
				from = pos
				to = pos - (oldViewOffset - prone.Config.View)
			
			-- Getting up
			else
				from = pos
				to = pos + (oldViewOffset - prone.Config.View)
			end
		end
		
		local frac = (animEndTime - SysTime())/animLength

		-- You might by wondering: "hey, why are you to and from variables flipped from what the Wiki says?"
		-- And my response will be: "Who fucking knows why this is backwards, but it is and it works!"
		transitionVector = LerpVector(frac, to, from)
		return {origin = transitionVector}
	end)
	hook.Add("CalcViewModelView", "prone.ViewTransitions", function()
		local localply = LocalPlayer()

		if enabledViewTransitions:GetBool() then
			return
		end

		local result = hook.Run("prone.ShouldChangeCalcViewModelView", localply)
		if result == false then
			return
		end

		if transitionVector then
			return transitionVector
		end
	end)
end


--addons/billy_gas_logging/lua/gmodadminsuite/modules/logging/sh_scenes.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "logging")
	else
		return GAS:PhraseFormat(phrase, "logging", ...)
	end
end

GAS.Logging.Scenes = {}

if (SERVER) then
	GAS:netInit("logging:ViewScene")
	GAS:netReceive("logging:ViewScene", function(ply)
		local scene_id = net.ReadUInt(16)
		local beginning = net.ReadBool()
		if (not GAS.Logging.Permissions:CanAccessModule(ply, GAS.Logging.PVP_COMBAT_MODULE)) then return end
		if (GAS.Logging.PvP.CombatScenes[scene_id]) then
			GAS:netStart("logging:ViewScene")
				net.WriteUInt(scene_id, 16)
				net.WriteBool(beginning)
				local data = util.Compress(GAS:SerializeTable(GAS.Logging.PvP.CombatScenes[scene_id].Scenes))
				net.WriteData(data, #data)
			net.Send(ply)
		end
	end)
else
	surface.CreateFont("GAS_Logging_Scene_HUD_1", {
		font = "Circular Std Medium",
		size = 48
	})

	surface.CreateFont("GAS_Logging_Scene_HUD_2", {
		font = "Circular Std Medium",
		size = 28
	})

	local red = Color(255,0,0)
	local green = Color(0,255,0)
	local white = Color(255,255,255)
	local black = Color(0,0,0)

	local red_laser = Material("cable/redlaser")
	local red_laser_dot = Material("sprites/glow04_noz")

	local green_laser = CreateMaterial("gas_logging_scene_greenlaser", "UnlitGeneric", {
		["$basetexture"] = "sprites/purplelaser1",
		["$translucent"] = "1",
		["$vertexcolor"] = "1",
		["$color"] = "5 1 1"
	})
	local green_laser_dot = Material("sprites/glow04_noz")

	local function IgnoreZ_RenderOverride(self)
		cam.IgnoreZ(true) self:DrawModel() cam.IgnoreZ(false)
	end

	GAS_Logging_Scenes_Ents = GAS_Logging_Scenes_Ents or {}

	GAS.Logging.Scenes.SceneEnts = {}
	GAS.Logging.Scenes.CachedData = {}
	GAS.Logging.Scenes.Instigators = {}
	GAS.Logging.Scenes.Victims = {}
	GAS.Logging.Scenes.TraceDrawers = {}
	GAS.Logging.Scenes.OriginCallbacks = {}

	function GAS.Logging.Scenes:Clear()
		for ent in pairs(GAS_Logging_Scenes_Ents) do
			if (not IsValid(ent)) then continue end
			ent:Remove()
		end
		GAS_Logging_Scenes_Ents = {}
		GAS.Logging.Scenes.SceneEnts = {}
		GAS.Logging.Scenes.Instigators = {}
		GAS.Logging.Scenes.Victims = {}
		GAS.Logging.Scenes.TraceDraw = {}
		GAS.Logging.Scenes.HUDDraw = {}
	end
	GAS.Logging.Scenes:Clear()

	function GAS.Logging.Scenes:CreatePlayer(ply_scene_obj)
		if (ply_scene_obj == nil) then return end
		
		local ent = ClientsideModel(ply_scene_obj[GAS.Logging.PvP_SCENE_MODEL], RENDERGROUP_TRANSLUCENT)
		ent.RenderOverride = IgnoreZ_RenderOverride

		GAS_Logging_Scenes_Ents[ent] = true

		ent.bVGUI_RenderScene_ForceDraw = true
		ent:SetPos(ply_scene_obj[GAS.Logging.PvP_SCENE_POS])
		ent:SetAngles(ply_scene_obj[GAS.Logging.PvP_SCENE_ANG])

		if (ply_scene_obj[GAS.Logging.PvP_SCENE_SEQUENCE]) then
			ent:ResetSequence(ply_scene_obj[GAS.Logging.PvP_SCENE_SEQUENCE])
		end

		if (ply_scene_obj[GAS.Logging.PvP_SCENE_HEAD_ANG]) then
			local head = ent:LookupBone("ValveBiped.Bip01_Head1")
			if (head and head ~= 0) then
				local x = ent:GetBonePosition(head)
				local y = ply_scene_obj[GAS.Logging.PvP_SCENE_SHOOT_POS]
				ent:ManipulateBoneAngles(head, Angle(0, (x - y):Angle().p, 0))
			end
		end

		local wep
		if (ply_scene_obj[GAS.Logging.PvP_SCENE_WEAPON_MDL]) then
			wep = ClientsideModel(ply_scene_obj[GAS.Logging.PvP_SCENE_WEAPON_MDL], RENDERGROUP_TRANSLUCENT)
			wep.bLogs_Scene_Ent = true
			wep.RenderOverride = IgnoreZ_RenderOverride

			GAS_Logging_Scenes_Ents[wep] = true

			wep.bVGUI_RenderScene_ForceDraw = true
			wep:SetParent(ent)
			wep:SetPos(ent:GetPos())
			wep:SetAngles(ent:GetAngles())
			wep:AddEFlags(EFL_NO_PHYSCANNON_INTERACTION)
			wep:SetSolid(SOLID_NONE)
			wep:AddEffects(EF_BONEMERGE)
		end

		function ent:GetPlayerColor()
			return ply_scene_obj[GAS.Logging.PvP_SCENE_PLY_COLOR]
		end
		function ent:GetWeaponColor()
			return ply_scene_obj[GAS.Logging.PvP_SCENE_WEP_COLOR]
		end

		local vehicle
		if (ply_scene_obj[GAS.Logging.PvP_SCENE_VEHICLE_MODEL]) then
			vehicle = ClientsideModel(ply_scene_obj[GAS.Logging.PvP_SCENE_VEHICLE_MODEL], RENDERGROUP_TRANSLUCENT)
			vehicle.bLogs_Scene_Ent = true
			vehicle.RenderOverride = IgnoreZ_RenderOverride

			GAS_Logging_Scenes_Ents[vehicle] = true

			vehicle.bVGUI_RenderScene_ForceDraw = true
			vehicle:SetPos(ply_scene_obj[GAS.Logging.PvP_SCENE_VEHICLE_POS])
			vehicle:SetAngles(ply_scene_obj[GAS.Logging.PvP_SCENE_VEHICLE_ANG])
			vehicle:AddEFlags(EFL_NO_PHYSCANNON_INTERACTION)
			vehicle:SetSolid(SOLID_NONE)

			ent:SetParent(vehicle, ply_scene_obj[GAS.Logging.PvP_SCENE_VEHICLE_ATTACHMENT] or nil)
			local matrix = ent:GetParentWorldTransformMatrix()
			ent:SetPos(matrix:GetTranslation())
			ent:SetAngles(matrix:GetAngles())
		end

		return ent, wep, vehicle
	end

	function GAS.Logging.Scenes:ClearScene(scene_id, beginning)
		local k = tostring(scene_id)
		if (beginning) then k = k .. "!" end

		GAS.Logging.Scenes.TraceDraw[k] = nil
		GAS.Logging.Scenes.HUDDraw[k] = nil

		if (GAS.Logging.Scenes.SceneEnts[k]) then
			for _,ent in pairs(GAS.Logging.Scenes.SceneEnts[k]) do
				if (not IsValid(ent)) then continue end
				local f = false
				for i,ent2 in ipairs(GAS.Logging.Scenes.Victims) do
					if (ent2 == ent) then
						f = true
						table.remove(GAS.Logging.Scenes.Victims, i)
						break
					end
				end
				if (not f) then
					for i,ent2 in ipairs(GAS.Logging.Scenes.Instigators) do
						if (ent2 == ent) then
							table.remove(GAS.Logging.Scenes.Instigators, i)
							break
						end
					end
				end

				GAS_Logging_Scenes_Ents[ent] = nil
				ent:Remove()
			end
			GAS.Logging.Scenes.SceneEnts[k] = nil
		end

		if (beginning == nil) then GAS.Logging.Scenes:ClearScene(scene_id, true) end
	end
	function GAS.Logging.Scenes:SetupScene(scene_id, beginning, data, origin_callback)
		local k = tostring(scene_id)
		if (beginning) then k = k .. "!" end
		local scene_obj
		if (beginning) then
			scene_obj = data.Start
		elseif (data.End) then
			scene_obj = data.End
		else
			return
		end
		if (not scene_obj[1] or not scene_obj[2]) then return end

		if (GAS.Logging.Scenes.ViewingScene ~= nil and GAS.Logging.Scenes.ViewingScene ~= scene_id) then
			GAS.Logging.Scenes:Clear()
		end
		GAS.Logging.Scenes.ViewingScene = scene_id

		local victim, victim_wep, victim_vehicle = GAS.Logging.Scenes:CreatePlayer(scene_obj[1])
		local instigator, instigator_wep, instigator_vehicle = GAS.Logging.Scenes:CreatePlayer(scene_obj[2])

		GAS.Logging.Scenes.SceneEnts[k] = {victim, victim_wep, victim_vehicle, instigator, instigator_wep, instigator_vehicle}
		table.insert(GAS.Logging.Scenes.Victims, victim)
		if (IsValid(victim_wep)) then table.insert(GAS.Logging.Scenes.Victims, victim_wep) end
		if (IsValid(victim_vehicle)) then table.insert(GAS.Logging.Scenes.Victims, victim_vehicle) end
		table.insert(GAS.Logging.Scenes.Instigators, instigator)
		if (IsValid(instigator_wep)) then table.insert(GAS.Logging.Scenes.Instigators, instigator_wep) end
		if (IsValid(instigator_vehicle)) then table.insert(GAS.Logging.Scenes.Instigators, instigator_vehicle) end

		local victim_eyes = victim:LookupAttachment("eyes")
		local instigator_eyes = IsValid(instigator) and instigator:LookupAttachment("eyes") or nil

		local victim_wep_muzzle
		if (IsValid(victim_wep)) then
			victim_wep_muzzle = victim_wep:LookupAttachment("muzzle")
			if (victim_wep_muzzle == 0) then victim_wep_muzzle = nil end
		end

		local instigator_wep_muzzle
		if (IsValid(instigator_wep)) then
			instigator_wep_muzzle = instigator_wep:LookupAttachment("muzzle")
			if (instigator_wep_muzzle == 0) then instigator_wep_muzzle = nil end
		end

		GAS.Logging.Scenes.TraceDraw[k] = function()
			local instigator_origin = scene_obj[1][GAS.Logging.PvP_SCENE_EYE_POS]
			local victim_origin = scene_obj[1][GAS.Logging.PvP_SCENE_EYE_POS]

			if (instigator_wep_muzzle) then
				local attach = instigator_wep:GetAttachment(instigator_wep_muzzle)
				if (attach) then instigator_origin = attach.Pos end
			elseif (instigator_eyes) then
				local attach = instigator:GetAttachment(instigator_eyes)
				if (attach) then instigator_origin = attach.Pos end
			end

			if (victim_wep_muzzle) then
				local attach = victim_wep:GetAttachment(victim_wep_muzzle)
				if (attach) then victim_origin = attach.Pos end
			elseif (victim_eyes) then
				local attach = victim:GetAttachment(victim_eyes)
				if (attach) then victim_origin = attach.Pos end
			end

			cam.IgnoreZ(true)

			render.SetMaterial(red_laser)
			render.DrawBeam(instigator_origin, scene_obj[2][GAS.Logging.PvP_SCENE_SHOOT_POS], 4, 0, 12.5, white)

			render.SetMaterial(red_laser_dot)
			render.DrawSprite(scene_obj[2][GAS.Logging.PvP_SCENE_SHOOT_POS], 10, 10, red)

			render.SetMaterial(green_laser)
			render.DrawBeam(victim_origin, scene_obj[1][GAS.Logging.PvP_SCENE_SHOOT_POS], 4, 0, 12.5, green)

			render.SetMaterial(green_laser_dot)
			render.DrawSprite(scene_obj[1][GAS.Logging.PvP_SCENE_SHOOT_POS], 10, 10, green)

			cam.IgnoreZ(false)
		end

		local instigator_tag, victim_tag = "[" .. string.upper(L"instigator") .. "]", "[" .. string.upper(L"victim") .. "]"
		local instigator_head, victim_head = IsValid(instigator) and instigator:LookupBone("ValveBiped.Bip01_Head1") or nil, victim:LookupBone("ValveBiped.Bip01_Head1")

		local wep_list = list.Get("Weapon")
		local instigator_wep_printname, victim_wep_printname
		if (scene_obj[1][GAS.Logging.PvP_SCENE_WEAPON_CLASS] and wep_list[scene_obj[1][GAS.Logging.PvP_SCENE_WEAPON_CLASS]]) then
			local wep_info = wep_list[scene_obj[1][GAS.Logging.PvP_SCENE_WEAPON_CLASS]]
			if (wep_info.PrintName) then
				victim_wep_printname = wep_info.PrintName
			end
		end
		if (scene_obj[2][GAS.Logging.PvP_SCENE_WEAPON_CLASS] and wep_list[scene_obj[2][GAS.Logging.PvP_SCENE_WEAPON_CLASS]]) then
			local wep_info = wep_list[scene_obj[2][GAS.Logging.PvP_SCENE_WEAPON_CLASS]]
			if (wep_info.PrintName) then
				instigator_wep_printname = wep_info.PrintName
			end
		end

		local origin_callback = origin_callback
		GAS.Logging.Scenes.HUDDraw[k] = function()
			local instigator_origin, victim_origin
			if (not instigator_head or instigator_head == 0) then
				if (instigator_eyes ~= nil and instigator_eyes ~= 0 and instigator:GetAttachment(instigator_eyes)) then
					instigator_origin = instigator:GetAttachment(instigator_eyes).Pos + Vector(0,0,10)
				else
					instigator_origin = instigator:GetPos() + Vector(0,0,20)
				end
			else
				instigator_origin = (IsValid(instigator) and instigator:GetBonePosition(instigator_head) or instigator:GetPos()) + Vector(0,0,10)
			end
			if (origin_callback) then
				origin_callback(instigator_origin, (scene_obj[2][GAS.Logging.PvP_SCENE_SHOOT_POS] - instigator_origin):Angle())
				origin_callback = nil
			end

			if (not victim_head or victim_head == 0) then
				if (victim_eyes ~= nil and victim_eyes ~= 0 and victim:GetAttachment(victim_eyes)) then
					victim_origin = victim:GetAttachment(victim_eyes).Pos + Vector(0,0,10)
				else
					victim_origin = victim:GetPos() + Vector(0,0,20)
				end
			else
				victim_origin = victim:GetBonePosition(victim_head) + Vector(0,0,10)
			end

			local my_eye_pos = GAS.Logging.Scenes.ViewOrigin or LocalPlayer():EyePos()

			cam.IgnoreZ(true)

			local sprite_ang = (instigator_origin - my_eye_pos):Angle()
			sprite_ang.r = 90
			sprite_ang.p = 0
			sprite_ang.y = sprite_ang.y - 90

			cam.Start3D2D(instigator_origin, sprite_ang, 0.1)
				draw.SimpleTextOutlined(instigator_tag, "GAS_Logging_Scene_HUD_1", 0, -60, red, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, black)
				if (instigator_wep_printname) then
					draw.SimpleTextOutlined(instigator_wep_printname, "GAS_Logging_Scene_HUD_2", 0, -24, red, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, black)
					draw.SimpleTextOutlined("(" .. scene_obj[2][GAS.Logging.PvP_SCENE_WEAPON_CLASS] .. ")", "GAS_Logging_Scene_HUD_2", 0, 0, red, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, black)
				elseif (scene_obj[2][GAS.Logging.PvP_SCENE_WEAPON_CLASS]) then
					draw.SimpleTextOutlined(scene_obj[2][GAS.Logging.PvP_SCENE_WEAPON_CLASS], "GAS_Logging_Scene_HUD_2", 0, 0, red, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, black)
				end
			cam.End3D2D()

			local sprite_ang = (victim_origin - my_eye_pos):Angle()
			sprite_ang.r = 90
			sprite_ang.p = 0
			sprite_ang.y = sprite_ang.y - 90

			cam.Start3D2D(victim_origin, sprite_ang, 0.1)
				draw.SimpleTextOutlined(victim_tag, "GAS_Logging_Scene_HUD_1", 0, -60, green, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, black)
				if (victim_wep_printname) then
					draw.SimpleTextOutlined(victim_wep_printname, "GAS_Logging_Scene_HUD_2", 0, -24, green, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, black)
					draw.SimpleTextOutlined("(" .. scene_obj[1][GAS.Logging.PvP_SCENE_WEAPON_CLASS] .. ")", "GAS_Logging_Scene_HUD_2", 0, 0, green, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, black)
				elseif (scene_obj[1][GAS.Logging.PvP_SCENE_WEAPON_CLASS]) then
					draw.SimpleTextOutlined(scene_obj[1][GAS.Logging.PvP_SCENE_WEAPON_CLASS], "GAS_Logging_Scene_HUD_2", 0, 0, green, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, black)
				end
			cam.End3D2D()

			cam.IgnoreZ(false)
		end
	end
	function GAS.Logging.Scenes:ViewScene(id, beginning, origin_callback)
		if (GAS.Logging.Scenes.CachedData[id] and (beginning or GAS.Logging.Scenes.CachedData[id].End ~= nil)) then
			GAS.Logging.Scenes:SetupScene(id, beginning, GAS.Logging.Scenes.CachedData[id], origin_callback)
		else
			local k = tostring(scene_id)
			if (beginning) then k = k .. "!" end
			GAS.Logging.Scenes.OriginCallbacks[k] = origin_callback

			GAS:netStart("logging:ViewScene")
				net.WriteUInt(id, 16)
				net.WriteBool(beginning)
			net.SendToServer()
		end
	end

	GAS:netReceive("logging:ViewScene", function(l)
		local id = net.ReadUInt(16)
		local beginning = net.ReadBool()
		local data = GAS:DeserializeTable(util.Decompress(net.ReadData(l - 16 - 1)))
		GAS.Logging.Scenes.CachedData[id] = data
		if (beginning or data.End) then
			local k = tostring(scene_id)
			if (beginning) then k = k .. "!" end
			GAS.Logging.Scenes:SetupScene(id, beginning, data, GAS.Logging.Scenes.OriginCallbacks[k])
		end
	end)

	hook.Add("PostDrawTranslucentRenderables", "gas_logging_scene_hud", function()
		for _,f in pairs(GAS.Logging.Scenes.HUDDraw) do f() end
		for _,f in pairs(GAS.Logging.Scenes.TraceDraw) do f() end
	end)
	hook.Add("GAS_RenderView_DrawHUD", "gas_logging_scene_hud_renderview", function()
		for _,f in pairs(GAS.Logging.Scenes.HUDDraw) do f() end
		for _,f in pairs(GAS.Logging.Scenes.TraceDraw) do f() end
	end)

	hook.Add("PreDrawHalos", "gas_logging_scene_halos", function()
		if (not GAS:table_IsEmpty(GAS.Logging.Scenes.Instigators)) then
			halo.Add(GAS.Logging.Scenes.Instigators, red, 1, 1, 5, true, true)
		end
		if (not GAS:table_IsEmpty(GAS.Logging.Scenes.Victims)) then
			halo.Add(GAS.Logging.Scenes.Victims, green, 1, 1, 5, true, true)
		end
	end)
end
--addons/billy_gas/lua/gmodadminsuite/modules/commands/cl_commands.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "commands")
	else
		return GAS:PhraseFormat(phrase, "commands", ...)
	end
end

GAS:netReceive("commands:no_permission", function()
	chat.AddText(Color(255,0,0), L"no_permission")
end)

GAS:netReceive("commands:ACTION_GAS_MODULE", function()
	RunConsoleCommand("gmodadminsuite", net.ReadString())
end)

GAS:netReceive("commands:ACTION_WEBSITE", function()
	GAS:OpenURL(net.ReadString())
end)

GAS:netReceive("commands:ACTION_LUA_FUNCTION", function()
	GAS:RunLuaFunction(net.ReadString(), LocalPlayer(), net.ReadString())
end)

function GAS.Commands:OpenMenu(show_settings, ModuleFrame)
	if (IsValid(GAS.Commands.Menu)) then
		GAS.Commands.Menu:Close()
	end

	if (IsValid(ModuleFrame)) then
		GAS.Commands.Menu = ModuleFrame
	else
		GAS.Commands.Menu = vgui.Create("bVGUI.Frame")
		GAS.Commands.Menu:SetSize(650,450)
		GAS.Commands.Menu:Center()
		GAS.Commands.Menu:SetTitle(L"commands")
		GAS.Commands.Menu:MakePopup()
	end

	local main_content, main_tab, new_command_content, new_command_tab
	if (show_settings) then
		GAS.Commands.Menu.Tabs = vgui.Create("bVGUI.Tabs", GAS.Commands.Menu)
		GAS.Commands.Menu.Tabs:Dock(TOP)
		GAS.Commands.Menu.Tabs:SetTall(0)

		main_content, main_tab = GAS.Commands.Menu.Tabs:AddTab("", Color(0,0,0))
		new_command_content, new_command_tab = GAS.Commands.Menu.Tabs:AddTab("", Color(0,0,0))

		new_command_tab:SetFunction(function()
			if (IsValid(new_command_content.Content)) then new_command_content.Content:Remove() end
			if (IsValid(new_command_content.BtnContainer)) then new_command_content.BtnContainer:Remove() end

			new_command_content.BtnContainer = vgui.Create("DPanel", new_command_content)
			new_command_content.BtnContainer:Dock(BOTTOM)
			new_command_content.BtnContainer:SetTall(45)
			function new_command_content.BtnContainer:Paint(w,h)
				surface.SetDrawColor(bVGUI.COLOR_DARKER_GREY)
				surface.DrawRect(0,0,w,h)
			end
			function new_command_content.BtnContainer:PerformLayout()
				local w = (self:GetWide() - self.Cancel:GetWide() - 10 - self.Finished:GetWide() - 10 - self.Wiki:GetWide()) / 2

				self.Cancel:AlignLeft(w)
				w = w + self.Cancel:GetWide() + 10 self.Finished:AlignLeft(w)
				w = w + self.Finished:GetWide() + 10 self.Wiki:AlignLeft(w)

				self.Cancel:CenterVertical()
				self.Finished:CenterVertical()
				self.Wiki:CenterVertical()
			end

			new_command_content.BtnContainer.Finished = vgui.Create("bVGUI.Button", new_command_content.BtnContainer)
			new_command_content.BtnContainer.Finished:SetColor(bVGUI.BUTTON_COLOR_GREEN)
			new_command_content.BtnContainer.Finished:SetText(L"finished")
			new_command_content.BtnContainer.Finished:SetSize(125,25)
			new_command_content.BtnContainer.Finished:SetDisabled(true)
			function new_command_content.BtnContainer.Finished:DoVerification()
				local problem
				local command_name = new_command_content.Content.CommandName:GetValue():lower()
				if (GAS.Commands.Config.Commands[command_name] and not new_command_content.Content.Editing) then
					problem = L"error_command_exists"
				elseif (#command_name == 0) then
					problem = L"error_no_command"
				elseif (not new_command_content.Content.Action:GetSelected()) then
					problem = L"error_no_action"
				else
					local action_i = new_command_content.Content.Action:GetSelectedID() - 1
					local val_elem = new_command_content.Content.ActionValue
					if (IsValid(val_elem)) then
						if (action_i == GAS.Commands.ACTION_TELEPORT and (val_elem.TelePos == nil or val_elem.TeleAng == nil)) then
							problem = L"error_no_position_set"
						elseif ((action_i == GAS.Commands.ACTION_LUA_FUNCTION_SV or action_i == GAS.Commands.ACTION_LUA_FUNCTION_CL) and not val_elem:GetSelected()) then
							problem = L"error_no_lua_function"
						elseif (action_i == GAS.Commands.ACTION_GAS_MODULE and not val_elem:GetSelected()) then
							problem = L"error_no_gas_module"
						elseif (action_i == GAS.Commands.ACTION_WEBSITE and (#val_elem:GetValue() == 0 or not val_elem:GetValue():lower():find("^https?://.+%..+"))) then
							problem = L"error_invalid_website"
						elseif (action_i == GAS.Commands.ACTION_CHAT and #val_elem:GetValue() == 0) then
							problem = L"error_no_chat_msg"
						elseif (action_i == GAS.Commands.ACTION_COMMAND and #val_elem:GetValue() == 0) then
							problem = L"error_no_command_execute"
						end
					end
				end
				if (not problem) then
					new_command_content.BtnContainer.Finished:SetDisabled(false)
					bVGUI.UnattachTooltip(new_command_content.BtnContainer.Finished)
				else
					new_command_content.BtnContainer.Finished:SetDisabled(true)
					bVGUI.AttachTooltip(new_command_content.BtnContainer.Finished, {Text = problem})
				end
			end
			function new_command_content.BtnContainer.Finished:DoClick()
				GAS:PlaySound("success")
				GAS:netReceive("commands:NewCommand", function()
					if (not IsValid(main_tab)) then return end
					main_tab:OnMouseReleased(MOUSE_LEFT)
					net.Receivers["gmodadminsuite:commands:NewCommand"] = nil
				end)
				GAS:netStart("commands:NewCommand")
					net.WriteString(new_command_content.Content.CommandName:GetValue())
					net.WriteString(new_command_content.Content.Help:GetValue())
					net.WriteBool(new_command_content.Content.HideInChat:GetChecked())
					net.WriteUInt(new_command_content.Content.Action:GetSelectedID(), 4)
					if (IsValid(new_command_content.Content.ActionValue)) then
						if (new_command_content.Content.Action:GetSelectedID() - 1 == GAS.Commands.ACTION_TELEPORT) then
							net.WriteVector(new_command_content.Content.ActionValue.TelePos)
							net.WriteAngle(new_command_content.Content.ActionValue.TeleAng)
						else
							if (new_command_content.Content.ActionValue.GetSelectedID ~= nil) then
								net.WriteString(new_command_content.Content.ActionValue:GetOptionData(new_command_content.Content.ActionValue:GetSelectedID()) or new_command_content.Content.ActionValue:GetValue())
							else
								net.WriteString(new_command_content.Content.ActionValue:GetValue())
							end
						end
					end
					if (new_command_content.Content.CommandName.OldCommandName ~= nil) then
						net.WriteBool(true)
						net.WriteString(new_command_content.Content.CommandName.OldCommandName)
					else
						net.WriteBool(false)
					end
				net.SendToServer()
				bVGUI.MouseInfoTooltip.Create(L"saved_exclamation")
			end

			new_command_content.BtnContainer.Cancel = vgui.Create("bVGUI.Button", new_command_content.BtnContainer)
			new_command_content.BtnContainer.Cancel:SetColor(bVGUI.BUTTON_COLOR_RED)
			new_command_content.BtnContainer.Cancel:SetText(L"cancel")
			new_command_content.BtnContainer.Cancel:SetSize(125,25)
			function new_command_content.BtnContainer.Cancel:DoClick()
				GAS:PlaySound("error")
				main_tab:OnMouseReleased(MOUSE_LEFT)
			end

			new_command_content.BtnContainer.Wiki = vgui.Create("bVGUI.Button", new_command_content.BtnContainer)
			new_command_content.BtnContainer.Wiki:SetColor(bVGUI.BUTTON_COLOR_BLUE)
			new_command_content.BtnContainer.Wiki:SetText(L"wiki")
			new_command_content.BtnContainer.Wiki:SetDisabled(true)
			new_command_content.BtnContainer.Wiki:SetSize(125,25)
			function new_command_content.BtnContainer.Wiki:DoClick()
				GAS:OpenURL("https://gmodsto.re/gmodadminsuite-commands-wiki")
			end

			new_command_content.Content = vgui.Create("bVGUI.ColumnLayout", new_command_content)
			new_command_content.Content:Dock(FILL)
			new_command_content.Content:DockMargin(10,10,10,10)
			new_command_content.Content:SetPaddings(10,10)
			new_command_content.Content:SetColumns(bVGUI.COLUMN_LAYOUT_COLUMN_GROW, bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK)

			local label
			local font = bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16)

			label = vgui.Create("DLabel", new_command_content.Content)
			label:SetContentAlignment(7)
			label:SetFont(font)
			label:SetTextColor(bVGUI.COLOR_WHITE)
			label:SetText(L"command")
			label:SizeToContents()

			new_command_content.Content.CommandName = vgui.Create("bVGUI.TextEntry", new_command_content.Content)
			new_command_content.Content.CommandName:SetSize(300,25)
			new_command_content.Content.CommandName:SetPlaceholderText("!command")
			new_command_content.Content.CommandName:DockPadding(0,0,0,10)
			new_command_content.Content.CommandName:SetUpdateOnType(true)
			new_command_content.Content.CommandName.OnValueChange = new_command_content.BtnContainer.Finished.DoVerification
			bVGUI.AttachTooltip(new_command_content.Content.CommandName, {Text = L"commands_case_insensitive"})

			new_command_content.Content:AddRow(label, new_command_content.Content.CommandName)

			--=======================================================================--

			label = vgui.Create("DLabel", new_command_content.Content)
			label:SetContentAlignment(7)
			label:SetFont(font)
			label:SetTextColor(bVGUI.COLOR_WHITE)
			label:SetText(L"help")
			label:SizeToContents()

			new_command_content.Content.Help = vgui.Create("bVGUI.TextEntry", new_command_content.Content)
			new_command_content.Content.Help:SetMultiline(true)
			new_command_content.Content.Help:SetContentAlignment(7)
			new_command_content.Content.Help:SetSize(300,90)
			new_command_content.Content.Help:SetPlaceholderText(L"form_help")
			new_command_content.Content.Help:DockPadding(0,0,0,10)
			bVGUI.AttachTooltip(new_command_content.Content.Help, {Text = L"form_help_tip"})

			new_command_content.Content:AddRow(label, new_command_content.Content.Help)

			--=======================================================================--

			label = vgui.Create("DLabel", new_command_content.Content)
			label:SetContentAlignment(7)
			label:SetFont(font)
			label:SetTextColor(bVGUI.COLOR_WHITE)
			label:SetText(L"hide_in_chat")
			label:SizeToContents()

			new_command_content.Content.HideInChat = vgui.Create("bVGUI.Checkbox", new_command_content.Content)
			new_command_content.Content.HideInChat:SetChecked(true)
			bVGUI.AttachTooltip(new_command_content.Content.HideInChat, {Text = L"hide_in_chat_tip"})

			new_command_content.Content:AddRow(label, new_command_content.Content.HideInChat)

			--=======================================================================--

			label = vgui.Create("DLabel", new_command_content.Content)
			label:SetContentAlignment(7)
			label:SetFont(font)
			label:SetTextColor(bVGUI.COLOR_WHITE)
			label:SetText(L"action")
			label:SizeToContents()

			new_command_content.Content.Action = vgui.Create("DComboBox", new_command_content.Content)
			new_command_content.Content.Action:SetValue(L"select_action")
			new_command_content.Content.Action:SetTall(25)
			new_command_content.Content.Action:SetSortItems(false)
			new_command_content.Content.Action:AddChoice(L"action_open_commands_menu")
			new_command_content.Content.Action:AddChoice(L"action_command")
			new_command_content.Content.Action:AddChoice(L"action_chat")
			new_command_content.Content.Action:AddChoice(L"action_website")
			new_command_content.Content.Action:AddChoice(L"action_teleport")
			new_command_content.Content.Action:AddChoice(L"action_lua_function_sv")
			new_command_content.Content.Action:AddChoice(L"action_lua_function_cl")
			new_command_content.Content.Action:AddChoice(L"action_gas_module")

			function new_command_content.Content.Action:OnSelect(_i, v)
				if (self.ActionValueIndex) then
					new_command_content.Content:RemoveRow(self.ActionValueIndex)
					self.ActionValueIndex = nil
				end

				local i = _i - 1
				if (i == GAS.Commands.ACTION_COMMANDS_MENU) then
					new_command_content.BtnContainer.Finished:DoVerification()
					return
				end

				local label = vgui.Create("DLabel", new_command_content.Content)
				label:SetContentAlignment(7)
				label:SetFont(font)
				label:SetTextColor(bVGUI.COLOR_WHITE)

				local val_elem

				if (i == GAS.Commands.ACTION_COMMAND) then

					label:SetText(L"form_action_command")
					label:SizeToContents()

					val_elem = vgui.Create("bVGUI.TextEntry", new_command_content.Content)
					val_elem:SetSize(300,25)

				elseif (i == GAS.Commands.ACTION_CHAT) then

					label:SetText(L"form_action_chat")
					label:SizeToContents()

					val_elem = vgui.Create("bVGUI.TextEntry", new_command_content.Content)
					val_elem:SetSize(300,25)

				elseif (i == GAS.Commands.ACTION_WEBSITE) then

					label:SetText(L"form_action_website")
					label:SizeToContents()

					val_elem = vgui.Create("bVGUI.TextEntry", new_command_content.Content)
					val_elem:SetSize(300,25)

				elseif (i == GAS.Commands.ACTION_TELEPORT) then

					label:SetText(L"form_action_teleport")
					label:SizeToContents()

					val_elem = vgui.Create("bVGUI.Button", new_command_content.Content)
					val_elem:SetColor(bVGUI.BUTTON_COLOR_BLUE)
					val_elem:SetText(L"set_position")
					val_elem:SetSize(150,25)
					function val_elem:DoClick()
						GAS.Commands.Menu.bVGUI_PinButton:DoClick()
						notification.AddLegacy(L"set_position_instruction", NOTIFY_HINT, 7)
						notification.AddLegacy(L"set_position_instruction_2", NOTIFY_HINT, 7)
						function GAS.Commands.Menu:OnUnpinned()
							val_elem:SetColor(bVGUI.BUTTON_COLOR_GREEN)
							val_elem:SetText(L"position_set")
							val_elem.TelePos = LocalPlayer():GetPos()
							val_elem.TeleAng = LocalPlayer():GetAngles()
							new_command_content.BtnContainer.Finished:DoVerification()
						end
					end

				elseif (i == GAS.Commands.ACTION_GAS_MODULE) then

					label:SetText(L"form_action_gas_module")
					label:SizeToContents()

					val_elem = vgui.Create("bVGUI.ComboBox", new_command_content.Content)
					val_elem:SetSize(300,25)

				elseif (i == GAS.Commands.ACTION_LUA_FUNCTION_SV) then

					label:SetText(L"form_action_lua_function_sv")
					label:SizeToContents()

					val_elem = vgui.Create("DComboBox", new_command_content.Content)
					val_elem:SetSize(300,25)

				elseif (i == GAS.Commands.ACTION_LUA_FUNCTION_CL) then

					label:SetText(L"form_action_lua_function_cl")
					label:SizeToContents()

					val_elem = vgui.Create("DComboBox", new_command_content.Content)
					val_elem:SetSize(300,25)

				end

				if (i == GAS.Commands.ACTION_LUA_FUNCTION_SV or i == GAS.Commands.ACTION_LUA_FUNCTION_CL) then
					for lua_function_name in pairs(GAS.LuaFunctions) do
						val_elem:AddChoice(lua_function_name)
					end
					val_elem.OnSelect = new_command_content.BtnContainer.Finished.DoVerification
				elseif (i == GAS.Commands.ACTION_GAS_MODULE) then
					for module_name, info in pairs(GAS.Modules.Info) do
						val_elem:AddChoice(info.Name, module_name, false, info.Icon)
					end
					val_elem.OnSelect = new_command_content.BtnContainer.Finished.DoVerification
				elseif (i ~= GAS.Commands.ACTION_TELEPORT) then
					val_elem:SetUpdateOnType(true)
					val_elem.OnValueChange = new_command_content.BtnContainer.Finished.DoVerification
				end

				new_command_content.Content.ActionValue = val_elem
				self.ActionValueIndex = new_command_content.Content:AddRow(label, val_elem)

				new_command_content.BtnContainer.Finished:DoVerification()
			end

			new_command_content.Content:AddRow(label, new_command_content.Content.Action)
			
			new_command_content.BtnContainer.Finished:DoVerification()

			if (new_command_content.OnContentLoaded) then
				new_command_content:OnContentLoaded()
			end
		end)
	else
		main_content = GAS.Commands.Menu
	end

	GAS.Commands.Menu.Table = vgui.Create("bVGUI.Table", main_content)
	GAS.Commands.Menu.Table:Dock(FILL)
	GAS.Commands.Menu.Table:SetLoading(true)
	GAS.Commands.Menu.Table:AddColumn(L"command", bVGUI.TABLE_COLUMN_SHRINK)
	GAS.Commands.Menu.Table:AddColumn(L"action", bVGUI.TABLE_COLUMN_SHRINK)
	GAS.Commands.Menu.Table:AddColumn(L"help", bVGUI.TABLE_COLUMN_GROW)
	GAS.Commands.Menu.Table:SetRowCursor("hand")

	function GAS.Commands.Menu.Table:OnRowClicked(row)
		GAS:PlaySound("btn_heavy")
		local menu = DermaMenu()

		menu:AddOption(L"run_command", function()
			GAS:PlaySound("delete")
			RunConsoleCommand("say", row.Command)
		end):SetIcon("icon16/font_go.png")

		menu:AddOption(L"copy_command", function()
			GAS:SetClipboardText(row.Command)
		end):SetIcon("icon16/page_copy.png")

		if (show_settings) then
			menu:AddOption(L"edit_command", function()

				GAS:PlaySound("flash")

				function new_command_content:OnContentLoaded()
					self.OnContentLoaded = nil
					self.Content.Editing = true
					self.Content.CommandName:SetValue(row.Command)
					self.Content.CommandName.OldCommandName = row.Command
					local options = GAS.Commands.Config.Commands[row.Command]
					self.Content.Help:SetText(options.help or "")
					self.Content.Action:ChooseOptionID(options.action.type + 1)
					self.Content.HideInChat:SetChecked(options.hide_command)
					if (IsValid(self.Content.ActionValue)) then
						if (options.action.type == GAS.Commands.ACTION_LUA_FUNCTION_SV or options.action.type == GAS.Commands.ACTION_LUA_FUNCTION_CL) then
							if (GAS.LuaFunctions[options.action.lua_func_name]) then
								self.Content.ActionValue:ChooseOption(options.action.lua_func_name)
							end
						elseif (options.action.type == GAS.Commands.ACTION_GAS_MODULE) then
							for id, data in ipairs(self.Content.ActionValue.Data) do
								if (data == options.action.module_name) then
									self.Content.ActionValue:ChooseOptionID(id)
									break
								end
							end
						elseif (options.action.type == GAS.Commands.ACTION_COMMAND) then
							self.Content.ActionValue:SetValue(options.action.command)
						elseif (options.action.type == GAS.Commands.ACTION_CHAT) then
							self.Content.ActionValue:SetValue(options.action.chat)
						elseif (options.action.type == GAS.Commands.ACTION_WEBSITE) then
							self.Content.ActionValue:SetValue(options.action.website)
						elseif (options.action.type == GAS.Commands.ACTION_TELEPORT) then
							self.Content.ActionValue.TelePos = Vector(options.action.TelePosX, options.action.TelePosY, options.action.TelePosZ)
							self.Content.ActionValue.TeleAng = Angle(options.action.TeleAngP, options.action.TeleAngY, options.action.TeleAngR)
						end
					end
					self.BtnContainer.Finished:DoVerification()
				end
				new_command_tab:OnMouseReleased(MOUSE_LEFT)

			end):SetIcon("icon16/pencil.png")

			menu:AddOption(L"delete_command", function()
				GAS:PlaySound("delete")
				GAS:netStart("commands:DeleteCommand")
					net.WriteString(row.Command)
				net.SendToServer()
				GAS.Commands.Menu.Table:RemoveRow(row.RowIndex)
			end):SetIcon("icon16/delete.png")
		end
		menu:Open()
	end

	local function PopulateCommandsTable()
		GAS.Commands.Menu.Table:Clear()
		GAS.Commands.Menu.Table:SetLoading(true)
		GAS:GetConfig("commands", function(config)
			GAS.Commands.Config = config

			GAS.Commands.Menu.Table:SetLoading(false)
			for command, options in pairs(GAS.Commands.Config.Commands) do
				if (not OpenPermissions:HasPermission(LocalPlayer(), command)) then continue end
				local action_str = "Unknown"
				if (options.action.type == GAS.Commands.ACTION_COMMANDS_MENU) then
					action_str = L"action_open_commands_menu"
				elseif (options.action.type == GAS.Commands.ACTION_COMMAND) then
					action_str = L"action_command"
				elseif (options.action.type == GAS.Commands.ACTION_GAS_MODULE) then
					action_str = L"action_gas_module"
				elseif (options.action.type == GAS.Commands.ACTION_CHAT) then
					action_str = L"action_chat"
				elseif (options.action.type == GAS.Commands.ACTION_WEBSITE) then
					action_str = L"action_website"
				elseif (options.action.type == GAS.Commands.ACTION_TELEPORT) then
					action_str = L"action_teleport"
				elseif (options.action.type == GAS.Commands.ACTION_LUA_FUNCTION_SV) then
					action_str = L"action_lua_function_cl"
				elseif (options.action.type == GAS.Commands.ACTION_LUA_FUNCTION_CL) then
					action_str = L"action_lua_function_sv"
				end
				GAS.Commands.Menu.Table:AddRow(command, action_str, options.help or "").Command = command
			end
		end)
	end

	if (show_settings) then
		GAS.Commands.Menu.BtnContainer = vgui.Create("DPanel", main_content)
		GAS.Commands.Menu.BtnContainer:Dock(BOTTOM)
		GAS.Commands.Menu.BtnContainer:SetTall(45)
		function GAS.Commands.Menu.BtnContainer:Paint(w,h)
			surface.SetDrawColor(bVGUI.COLOR_DARKER_GREY)
			surface.DrawRect(0,0,w,h)
		end
		function GAS.Commands.Menu.BtnContainer:PerformLayout(_w, _h)
			local w,h = (_w - 125 - 10 - 125) / 2, (_h - 25) / 2
			self.Add:SetPos(w, h)
			self.Permissions:SetPos(w + 125 + 10, h)
		end

		GAS.Commands.Menu.BtnContainer.Add = vgui.Create("bVGUI.Button", GAS.Commands.Menu.BtnContainer)
		GAS.Commands.Menu.BtnContainer.Add:SetColor(bVGUI.BUTTON_COLOR_BLUE)
		GAS.Commands.Menu.BtnContainer.Add:SetText(L"new_command")
		GAS.Commands.Menu.BtnContainer.Add:SetSize(125,25)
		function GAS.Commands.Menu.BtnContainer.Add:DoClick()
			GAS:PlaySound("flash")
			new_command_tab:OnMouseReleased(MOUSE_LEFT)
		end

		GAS.Commands.Menu.BtnContainer.Permissions = vgui.Create("bVGUI.Button", GAS.Commands.Menu.BtnContainer)
		GAS.Commands.Menu.BtnContainer.Permissions:SetColor(bVGUI.BUTTON_COLOR_ORANGE)
		GAS.Commands.Menu.BtnContainer.Permissions:SetText(L"permissions")
		GAS.Commands.Menu.BtnContainer.Permissions:SetSize(125,25)
		function GAS.Commands.Menu.BtnContainer.Permissions:DoClick()
			GAS:PlaySound("popup")
			RunConsoleCommand("openpermissions", "gmodadminsuite_commands")
		end
		
		main_tab:SetFunction(PopulateCommandsTable)
		main_tab:OnMouseReleased(MOUSE_LEFT)
	else
		PopulateCommandsTable()
	end
end

GAS:netReceive("commands:ACTION_COMMANDS_MENU", function()
	GAS.Commands:OpenMenu(false)
end)

GAS:hook("gmodadminsuite:ModuleSize:commands", "commands:framesize", function()
	return 650,450
end)
GAS:hook("gmodadminsuite:ModuleFrame:commands", "commands:menu", function(ModuleFrame)
	GAS.Commands:OpenMenu(true, ModuleFrame)
end)
--addons/billy_gas/lua/gmodadminsuite/modules/playerdatabase/sh_playerdatabase.lua:
if (GAS.PlayerDatabase and IsValid(GAS.PlayerDatabase.Menu)) then
	GAS.PlayerDatabase.Menu:Close()
end

GAS.PlayerDatabase = {}

if (CLIENT) then
	local function L(phrase, ...)
		if (#({...}) == 0) then
			return GAS:Phrase(phrase, "playerdatabase")
		else
			return GAS:PhraseFormat(phrase, "playerdatabase", ...)
		end
	end

	local search_tab_mat = Material("gmodadminsuite/search_tab.vtf")
	function GAS.PlayerDatabase:OpenMenu(ModuleFrame)
		if (IsValid(GAS.PlayerDatabase.Menu)) then
			GAS.PlayerDatabase.Menu:Close()
		end
		GAS.PlayerDatabase.Menu = ModuleFrame

		local see_ip_addresses = OpenPermissions:HasPermission(LocalPlayer(), "gmodadminsuite/see_ip_addresses")

		local content = vgui.Create("bVGUI.BlankPanel", ModuleFrame)
		content:Dock(FILL)
		function content:PerformLayout()
			GAS.PlayerDatabase.Menu.SearchTab:AlignRight(10 + GAS.PlayerDatabase.Menu.SearchMenu:GetWide())
			GAS.PlayerDatabase.Menu.SearchTab:AlignBottom(30)
		end
		function content:PaintOver(w,h)
			if (GAS.PlayerDatabase.Menu.SearchMenu:GetWide() ~= 0) then
				surface.SetDrawColor(255,255,255,150)
				surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
				surface.DrawTexturedRect(w - GAS.PlayerDatabase.Menu.SearchMenu:GetWide(),0,10,h)
			end
		end

		GAS.PlayerDatabase.Menu.Table = vgui.Create("bVGUI.Table", content)
		GAS.PlayerDatabase.Menu.Table:Dock(FILL)
		GAS.PlayerDatabase.Menu.Table:AddColumn(L"last_seen", bVGUI.TABLE_COLUMN_SHRINK)
		GAS.PlayerDatabase.Menu.Table:AddColumn(L"steamid", bVGUI.TABLE_COLUMN_SHRINK)
		if (see_ip_addresses) then
			GAS.PlayerDatabase.Menu.Table:AddColumn(L"ip_address", bVGUI.TABLE_COLUMN_SHRINK)
		end
		GAS.PlayerDatabase.Menu.Table:AddColumn(L"usergroup", bVGUI.TABLE_COLUMN_SHRINK)
		GAS.PlayerDatabase.Menu.Table:AddColumn(L"country", bVGUI.TABLE_COLUMN_SHRINK)
		GAS.PlayerDatabase.Menu.Table:AddColumn(L"name", bVGUI.TABLE_COLUMN_GROW)
		GAS.PlayerDatabase.Menu.Table:SetLoading(true)
		GAS.PlayerDatabase.Menu.Table:SetRowCursor("hand")
		function GAS.PlayerDatabase.Menu.Table:OnColumnHovered(row, column_index)
			if (column_index == nil) then
				bVGUI.PlayerTooltip.Close()
			else
				bVGUI.PlayerTooltip.Create({
					account_id = tonumber(row.Data.account_id),
					creator = row,
					focustip = L"right_click_to_focus"
				})
			end
		end

		function GAS.PlayerDatabase.Menu.Table:OnRowClicked(row)
			local menu = DermaMenu()

			menu:AddOption(L"copy_steamid", function()
				GAS:SetClipboardText(GAS:AccountIDToSteamID(row.Data.account_id))
			end):SetIcon("gmodadminsuite/steam.png")

			menu:AddOption(L"copy_steamid64", function()
				GAS:SetClipboardText(GAS:AccountIDToSteamID64(row.Data.account_id))
			end):SetIcon("gmodadminsuite/steam.png")

			menu:AddOption(L"copy_steam_profile_link", function()
				GAS:SetClipboardText("https://steamcommunity.com/profiles/" .. GAS:AccountIDToSteamID64(row.Data.account_id))
			end):SetIcon("icon16/world_link.png")

			menu:AddSpacer()

			menu:AddOption(L"copy_name", function()
				GAS:SetClipboardText(row.Data.nick)
			end):SetIcon("icon16/tag_blue.png")

			menu:AddOption(L"copy_usergroup", function()
				GAS:SetClipboardText(row.Data.usergroup)
			end):SetIcon("icon16/group.png")

			if (row.Data.country_code ~= nil) then
				menu:AddOption(L"copy_country", function()
					GAS:SetClipboardText(GAS.CountryCodes[row.Data.country_code] or row.Data.country_code)
				end):SetIcon("icon16/world.png")
			end

			if (see_ip_addresses and row.Data.ip_address ~= nil) then
				menu:AddOption(L"copy_ip_address", function()
					GAS:SetClipboardText(row.Data.ip_address)
				end):SetIcon("icon16/connect.png")
			end

			menu:AddSpacer()

			menu:AddOption(L"search_name", function()
				GAS.PlayerDatabase.Menu.SearchMenu:Open(true)

				GAS.PlayerDatabase.Menu.SearchMenu.Content.NameField:SetValue(row.Data.nick)
				GAS.PlayerDatabase.Menu.SearchMenu.Content.SearchBtn:DoVerificationClick()
			end):SetIcon("icon16/magnifier.png")

			menu:AddOption(L"search_usergroup", function()
				GAS.PlayerDatabase.Menu.SearchMenu:Open(true)

				GAS.PlayerDatabase.Menu.SearchMenu.Content.UsergroupField:SetValue(row.Data.usergroup)
				GAS.PlayerDatabase.Menu.SearchMenu.Content.SearchBtn:DoVerificationClick()
			end):SetIcon("icon16/magnifier.png")

			if (row.Data.country_code ~= nil) then
				menu:AddOption(L"search_country", function()
					GAS.PlayerDatabase.Menu.SearchMenu:Open(true)

					for i,choice in pairs(GAS.PlayerDatabase.Menu.SearchMenu.Content.CountryField.Data) do
						if (choice == row.Data.country_code) then
							GAS.PlayerDatabase.Menu.SearchMenu.Content.CountryField:ChooseOptionID(i)
							break
						end
					end

					GAS.PlayerDatabase.Menu.SearchMenu.Content.SearchBtn:DoVerificationClick()
				end):SetIcon("icon16/magnifier.png")
			end

			if (see_ip_addresses and row.Data.ip_address ~= nil) then
				menu:AddOption(L"search_ip_address", function()
					GAS.PlayerDatabase.Menu.SearchMenu:Open(true)

					GAS.PlayerDatabase.Menu.SearchMenu.Content.IPAddressField:SetValue(row.Data.ip_address)
					GAS.PlayerDatabase.Menu.SearchMenu.Content.SearchBtn:DoVerificationClick()
				end):SetIcon("icon16/magnifier.png")
			end

			menu:Open()
		end
		function GAS.PlayerDatabase.Menu.Table:OnRowRightClicked(row)
			bVGUI.PlayerTooltip.Focus()
		end

		GAS.PlayerDatabase.Menu.SearchMenu = vgui.Create("bVGUI.BlankPanel", content)
		GAS.PlayerDatabase.Menu.SearchMenu:Dock(RIGHT)
		GAS.PlayerDatabase.Menu.SearchMenu:SetWide(0)
		GAS.PlayerDatabase.Menu.SearchMenu.IsOpen = false
		function GAS.PlayerDatabase.Menu.SearchMenu:Paint(w,h)
			surface.SetDrawColor(19,19,19,255)
			surface.DrawRect(0,0,w,h)
		end

		function GAS.PlayerDatabase.Menu.SearchMenu:Toggle()
			if (self.IsOpen) then
				self:Close()
			else
				self:Open()
			end
		end
		function GAS.PlayerDatabase.Menu.SearchMenu:Open(clear_content)
			GAS:PlaySound("popup")
			self.IsOpen = true
			self:Stop()
			self:SizeTo(160, self:GetTall(), 0.5)

			if (not clear_content and IsValid(self.Content)) then return end

			if (IsValid(self.Content)) then
				self.Content:Remove()
			end

			self.Content = vgui.Create("bVGUI.BlankPanel", self)
			local content = self.Content
			self.Content:Dock(FILL)
			self.Content:DockMargin(10,10,10,10)

			local form = vgui.Create("bVGUI.BlankPanel", self.Content)
			form:Dock(FILL)

			for _,v in ipairs({
				{
					Key = "NameField",
					Icon = "icon16/user.png",
					Label = L"name",
					TextEntry = true
				},

				{
					Key = "UsergroupField",
					Icon = "icon16/group.png",
					Label = L"usergroup",
					TextEntry = true
				},

				{
					Key = "CountryField",
					Icon = "icon16/world.png",
					Label = L"country",
					ComboBox = true
				},

				{
					Key = "IPAddressField",
					Icon = "icon16/connect.png",
					Label = L"ip_address",
					TextEntry = true
				},

				{
					Key = "SteamIDField",
					Icon = "gmodadminsuite/steam.png",
					Label = L"steamid",
					TextEntry = true
				},
			}) do

				local i = v.Key
				if (i == "IPAddressField" and not see_ip_addresses) then continue end

				local line = vgui.Create("bVGUI.BlankPanel", form)
				line:Dock(TOP)
				line:DockMargin(0,0,0,10)

				if (v.TextEntry) then
					local TextEntry = vgui.Create("bVGUI.TextEntry", line)
					self.Content[i] = TextEntry
					TextEntry:SetUpdateOnType(true)
					function TextEntry:OnValueChange()
						if (not IsValid(content.SearchBtn)) then return end
						content.SearchBtn:DoVerification()
					end
				elseif (v.ComboBox) then
					local ComboBox = vgui.Create("bVGUI.ComboBox", line)
					self.Content[i] = ComboBox
					function ComboBox:OnSelect(i,v,d)
						if (not IsValid(content.SearchBtn)) then return end
						GAS:PlaySound("btn_light")
						content.SearchBtn:DoVerification()
					end
				end

				self.Content[i]:Dock(BOTTOM)
				self.Content[i]:DockMargin(0,5,0,0)

				local top = vgui.Create("bVGUI.BlankPanel", line)
				top:Dock(TOP)
				top:SetTall(16)

				local icon = vgui.Create("DImage", top)
				icon:Dock(LEFT)
				icon:SetSize(16,16)
				icon:SetImage(v.Icon)
				icon:DockMargin(0,0,5,0)

				local label = vgui.Create("DLabel", top)
				label:Dock(FILL)
				label:SetContentAlignment(4)
				label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
				label:SetTextColor(bVGUI.COLOR_WHITE)
				label:SetText(v.Label)
				label:SizeToContents()

				line:SetTall(16 + 5 + self.Content[i]:GetTall())

			end

			self.Content.CountryField:SetSortItems(false)
			self.Content.CountryField:AddChoice(L"none", false, true, "icon16/cross.png")
			self.Content.CountryField:AddSpacer()
			for country_name, country_code in SortedPairs(GAS.CountryCodesReverse) do
				local icon
				if (file.Exists("materials/flags16/" .. country_code .. ".png", "GAME")) then
					icon = "flags16/" .. country_code .. ".png"
				end
				self.Content.CountryField:AddChoice(country_name, country_code, false, icon)
			end

			self.Content.SearchBtn = vgui.Create("bVGUI.Button", form)
			self.Content.SearchBtn:SetColor(bVGUI.BUTTON_COLOR_BLUE)
			self.Content.SearchBtn:SetText(L"search")
			self.Content.SearchBtn:SetDisabled(true)
			self.Content.SearchBtn:DockMargin(0,5,0,0)
			self.Content.SearchBtn:Dock(TOP)
			self.Content.SearchBtn:SetTall(25)
			function self.Content.SearchBtn:DoVerification()
				self:SetDisabled(not GAS.PlayerDatabase.Menu.Searching and (#content.SteamIDField:GetValue() == 0 or (not content.SteamIDField:GetValue():upper():find("^STEAM_%d:%d+:%d+$") and not content.SteamIDField:GetValue():find("^7656119%d+$"))) and (content.CountryField:GetSelectedID() == nil or content.CountryField:GetSelectedID() == 1) and #content.NameField:GetValue() == 0 and #content.UsergroupField:GetValue() == 0 and (not IsValid(content.IPAddressField) or not GAS:IsIPAddress(content.IPAddressField:GetValue(), true)))
			end
			function self.Content.SearchBtn:DoVerificationClick()
				self:DoVerification()
				if (not self:GetDisabled()) then
					self:DoClick()
				end
			end
			function self.Content.SearchBtn:DoClick()
				GAS.PlayerDatabase.Menu.Pagination:SetPage(1)
				GAS.PlayerDatabase.Menu.Pagination:SetPages(1)

				GAS.PlayerDatabase.Menu.Table:Clear()
				GAS.PlayerDatabase.Menu.Table:SetLoading(true)

				if (GAS.PlayerDatabase.Menu.Searching) then
					GAS:PlaySound("delete")

					GAS.PlayerDatabase.Menu.Searching = false
					self:SetColor(bVGUI.BUTTON_COLOR_BLUE)
					self:SetText(L"search")
				else
					GAS:PlaySound("success")

					GAS.PlayerDatabase.Menu.Searching = true
					self:SetColor(bVGUI.BUTTON_COLOR_RED)
					self:SetText(L"cancel")
				end

				GAS.PlayerDatabase.Menu.Pagination:OnPageSelected(1)
			end
		end
		function GAS.PlayerDatabase.Menu.SearchMenu:Close()
			if (GAS.PlayerDatabase.Menu.Searching) then
				GAS:PlaySound("error")
			else
				GAS:PlaySound("delete")
				self.IsOpen = false
				self:Stop()
				self:SizeTo(0, self:GetTall(), 0.5, 0)
			end
		end

		GAS.PlayerDatabase.Menu.SearchTab = vgui.Create("bVGUI.BlankPanel", content)
		GAS.PlayerDatabase.Menu.SearchTab:SetSize(50,25)
		GAS.PlayerDatabase.Menu.SearchTab:SetMouseInputEnabled(true)
		GAS.PlayerDatabase.Menu.SearchTab:SetCursor("hand")
		bVGUI.AttachTooltip(GAS.PlayerDatabase.Menu.SearchTab, {Text = L"search"})
		function GAS.PlayerDatabase.Menu.SearchTab:OnMouseReleased(m)
			if (m ~= MOUSE_LEFT) then return end
			GAS.PlayerDatabase.Menu.SearchMenu:Toggle()
		end
		function GAS.PlayerDatabase.Menu.SearchTab:Paint(w,h)
			surface.SetDrawColor(255,255,255,255)
			surface.SetMaterial(search_tab_mat)
			surface.DrawTexturedRect(0,0,64,64)
		end

		local pagination_container = vgui.Create("bVGUI.BlankPanel", content)
		pagination_container:Dock(BOTTOM)
		pagination_container:SetTall(30)
		function pagination_container:Paint(w,h)
			surface.SetDrawColor(19,19,19,255)
			surface.DrawRect(0,0,w,h)
		end

		GAS.PlayerDatabase.Menu.Pagination = vgui.Create("bVGUI.Pagination", pagination_container)
		GAS.PlayerDatabase.Menu.Pagination:Dock(FILL)
		GAS.PlayerDatabase.Menu.Pagination:SetPages(1)
		function GAS.PlayerDatabase.Menu.Pagination:OnPageSelected(page)
			GAS.PlayerDatabase.Menu.Table:Clear()
			GAS.PlayerDatabase.Menu.Table:SetLoading(true)

			GAS:StartNetworkTransaction("playerdatabase:GetPage", function()
				net.WriteUInt(page, 16)
				net.WriteBool(GAS.PlayerDatabase.Menu.Searching or false)
				if (GAS.PlayerDatabase.Menu.Searching) then
					local search_content = GAS.PlayerDatabase.Menu.SearchMenu.Content

					local search_name = #search_content.NameField:GetValue() > 0
					net.WriteBool(search_name)
					if (search_name) then
						net.WriteString(search_content.NameField:GetValue())
					end

					local search_usergroup = #search_content.UsergroupField:GetValue() > 0
					net.WriteBool(search_usergroup)
					if (search_usergroup) then
						net.WriteString(search_content.UsergroupField:GetValue())
					end

					local search_country = search_content.CountryField:GetSelectedID() ~= nil and search_content.CountryField:GetSelectedID() ~= 1
					net.WriteBool(search_country)
					if (search_country) then
						net.WriteString(search_content.CountryField:GetOptionData(search_content.CountryField:GetSelectedID()))
					end

					local search_ip_address = see_ip_addresses and #search_content.IPAddressField:GetValue() > 0
					net.WriteBool(search_ip_address)
					if (search_ip_address) then
						net.WriteString(search_content.IPAddressField:GetValue())
					end

					local search_steamid = #search_content.SteamIDField:GetValue() > 0
					net.WriteBool(search_steamid)
					if (search_steamid) then
						net.WriteString(search_content.SteamIDField:GetValue())
					end
				end
			end, function(has_data)
				if (not IsValid(GAS.PlayerDatabase.Menu) or not IsValid(GAS.PlayerDatabase.Menu.Table)) then return end
				GAS.PlayerDatabase.Menu.Table:SetLoading(false)
				if (has_data) then
					local pages = net.ReadUInt(16)
					local data_len = net.ReadUInt(16)
					local player_data = GAS:DeserializeTable(util.Decompress(net.ReadData(data_len)))
					for _,row in ipairs(player_data) do
						local ply = player.GetByAccountID(tonumber(row.account_id))
						local nick = row.nick
						if (IsValid(ply)) then
							nick = "<color=" .. GAS:Unvectorize(team.GetColor(ply:Team())) .. ">" .. GAS:EscapeMarkup(nick) .. "</color>"
						else
							nick = GAS:EscapeMarkup(nick)
						end
						local country
						if (row.country_code ~= nil) then
							country = GAS:EscapeMarkup(GAS.CountryCodes[row.country_code] or row.country_code)
						else
							country = ""
						end
						local row_pnl
						if (see_ip_addresses) then
							row_pnl = GAS.PlayerDatabase.Menu.Table:AddRow(GAS:SimplifyTimestamp(row.last_seen), GAS:AccountIDToSteamID(row.account_id), row.ip_address or "", GAS:EscapeMarkup(row.usergroup), country, nick)
						else
							row_pnl = GAS.PlayerDatabase.Menu.Table:AddRow(GAS:SimplifyTimestamp(row.last_seen), GAS:AccountIDToSteamID(row.account_id), GAS:EscapeMarkup(row.usergroup), country, nick)
						end
						row_pnl.Data = row
					end
				end
			end)
		end

		GAS.PlayerDatabase.Menu.Pagination:OnPageSelected(1)
	end

	GAS:hook("gmodadminsuite:ModuleSize:playerdatabase", "playerdatabase:framesize", function()
		return 900,600
	end)
	GAS:hook("gmodadminsuite:ModuleFrame:playerdatabase", "playerdatabase:menu", function(ModuleFrame)
		GAS.PlayerDatabase:OpenMenu(ModuleFrame)
	end)
else
	GAS:netInit("playerdatabase:GetPage")
	GAS:ReceiveNetworkTransaction("playerdatabase:GetPage", function(transaction_id, ply)
		if (not OpenPermissions:HasPermission(ply, "gmodadminsuite/playerdatabase")) then return end

		local page = net.ReadUInt(16)

		local searching = net.ReadBool()
		local searching_name, search_name, searching_usergroup, search_usergroup, searching_country, search_country, searching_ip_address, search_ip_address, searching_steamid, search_steamid

		if (searching) then
			searching_name = net.ReadBool()
			if (searching_name) then search_name = net.ReadString():lower() end

			searching_usergroup = net.ReadBool()
			if (searching_usergroup) then search_usergroup = net.ReadString():lower() end

			searching_country = net.ReadBool()
			if (searching_country) then search_country = net.ReadString():upper() end

			searching_ip_address = net.ReadBool()
			if (searching_ip_address) then search_ip_address = net.ReadString() end

			searching_steamid = net.ReadBool()
			if (searching_steamid) then search_steamid = net.ReadString():upper() end
		end

		local see_ip_addresses = OpenPermissions:HasPermission(ply, "gmodadminsuite/see_ip_addresses")

		if (searching and searching_ip_address and (not see_ip_addresses or not GAS:IsIPAddress(search_ip_address, true))) then return end

		local ip_address_column = ""
		if (see_ip_addresses) then
			ip_address_column = ", `ip_address`"
		end

		local pages
		local player_data
		local terminate
		local function data()
			if (terminate) then return end
			if (pages == 0 or player_data == false) then
				terminate = true
				GAS:TransactionNoData("playerdatabase:GetPage", transaction_id, ply)
				return
			end
			if (pages ~= nil and player_data ~= nil) then
				local c = util.Compress(GAS:SerializeTable(player_data))
				GAS:netStart("playerdatabase:GetPage")
					net.WriteUInt(transaction_id, 16)
					net.WriteUInt(pages, 16)
					net.WriteUInt(#c, 16)
					net.WriteData(c, #c)
				net.Send(ply)
			end
		end

		local get_pages_query, get_data_query

		if (not searching) then
			get_pages_query = "SELECT COUNT(*) AS 'count' FROM gas_offline_player_data WHERE `server_id`=" .. GAS.ServerID
			get_data_query = "SELECT `account_id`, `nick`, `usergroup`, `country_code`, UNIX_TIMESTAMP(`last_seen`) AS 'last_seen'" .. ip_address_column .. " FROM gas_offline_player_data WHERE `server_id`=" .. GAS.ServerID .. " ORDER BY `last_seen` DESC LIMIT " .. ((page - 1) * 60) .. ",60"
		else
			get_pages_query = "SELECT COUNT(*) as 'count' FROM gas_offline_player_data WHERE `server_id`=" .. GAS.ServerID .. " AND ("
			get_data_query = "SELECT `account_id`, `nick`, `usergroup`, `country_code`, UNIX_TIMESTAMP(`last_seen`) AS 'last_seen'" .. ip_address_column .. " FROM gas_offline_player_data WHERE `server_id`=" .. GAS.ServerID .. " AND ("

			local where_clause = ""
			if (searching_name) then
				where_clause = where_clause .. "LOWER(`nick`) LIKE '%" .. (GAS.Database:Escape(search_name, true):gsub("%%", "\\%%")) .. "%' AND "
			end
			if (searching_usergroup) then
				where_clause = where_clause .. "LOWER(`usergroup`) LIKE '%" .. (GAS.Database:Escape(search_usergroup, true):gsub("%%", "\\%%")) .. "%' AND "
			end
			if (searching_country) then
				where_clause = where_clause .. "`country_code`=" .. GAS.Database:Escape(search_country) .. " AND "
			end
			if (searching_ip_address) then
				where_clause = where_clause .. "`ip_address`=" .. GAS.Database:Escape(search_ip_address)
			end
			if (searching_steamid) then
				local account_id
				if (search_steamid:find("^STEAM_%d:%d+:%d+$")) then
					account_id = GAS:SteamIDToAccountID(search_steamid)
				elseif (search_steamid:find("^7656119%d+$")) then
					account_id = GAS:SteamID64ToAccountID(search_steamid)
				end
				if (account_id ~= nil) then where_clause = where_clause .. "`account_id`=" .. GAS.Database:Escape(account_id) end
			end
			where_clause = (where_clause:gsub("AND $",""))

			get_pages_query = get_pages_query .. where_clause .. ")"
			get_data_query = get_data_query .. where_clause .. ") ORDER BY `last_seen` DESC LIMIT " .. ((page - 1) * 60) .. ",60"
		end

		GAS.Database:Query(get_pages_query, function(rows)
			if (not rows or #rows == 0 or rows[1].count == nil or tonumber(rows[1].count) == nil) then
				pages = 0
				data()
			else
				pages = math.ceil(tonumber(rows[1].count) / 60)
				data()
			end
		end)
		GAS.Database:Query(get_data_query, function(rows)
			if (not rows or #rows == 0) then
				player_data = false
				data()
			else
				player_data = rows
				data()
			end
		end)
	end)
end