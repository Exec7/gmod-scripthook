--Stealed clientside server code by exechack.cc
--Hostname: Ψ UkraineRP #1 ◈ Оновлення◈ Набiр ◈ M9K - Part 10/10 - 06/04/2025


--PATH addons/dash/lua/dash/libraries/hook.lua:
local debug_info 	= debug.getinfo
local isstring 		= isstring
local isfunction 	= isfunction
local IsValid 		= IsValid

local hook_callbacks = {}
local hook_index 	 = {}
local hook_id		 = {}

local function GetTable() -- This function is now slow
	local ret = {}
	for name, callbacks in pairs(hook_callbacks) do
		ret[name] = {}
		for index, callback in pairs(callbacks) do
			ret[name][hook_id[name][index]] = callback
		end
	end
	return ret
end

local function Exists(name, id)
	return (hook_index[name] ~= nil) and (hook_index[name][id] ~= nil)
end

local function Call(name, gm, ...)
	local callbacks = hook_callbacks[name]

	if (callbacks ~= nil) then

		local i = 0

		::runhook::
		i = i + 1
		local v = callbacks[i]
		if (v ~= nil) then
			local a, b, c, d, e, f = v(...)
			if (a ~= nil) then
				return a, b, c, d, e, f
			end
			goto runhook
		end
	end

	if (not gm) then
		return
	end

	local callback = gm[name]
	if (not callback) then
		return
	end

	return callback(gm, ...)
end

local function Run(name, ...)
	return Call(name, GAMEMODE, ...)
end

local function Remove(name, id)
	local callbacks = hook_callbacks[name]

	if (not callbacks) then
		return
	end

	local indexes = hook_index[name]
	local index = indexes[id]

	if (not index) then
		return
	end

	local count = #callbacks
	if (count == index) then
		callbacks[index] = nil
		indexes[id] = nil
		hook_id[name][index] = nil
	else
		local ids = hook_id[name]

		callbacks[index] = callbacks[count]
		callbacks[count] = nil

		local lastid = ids[count]

		indexes[id] = nil
		indexes[lastid] = index

		ids[index] = lastid
		ids[count] = nil
	end
end

local function Add(name, id, callback)
	if isfunction(id) then
		callback = id
		id = debug_info(callback).short_src
	end

	if (not callback) then
		return
	end

	if (hook_callbacks[name] == nil) then
		hook_callbacks[name] = {}
		hook_index[name] 	 = {}
		hook_id[name] 	 = {}
	end

	if Exists(name, id) then
		Remove(name, id) -- properly simulate hook overwrite behavior
	end

	local callbacks = hook_callbacks[name]
	local indexes = hook_index[name]

	if (not isstring(id)) then
		local orig = callback
		callback = function(...)
			if IsValid(id) then
				return orig(id, ...)
			end

			local index = indexes[id]
			Remove(name, id)

			local nextcallback = callbacks[index]
			if (nextcallback ~= nil) then
				return nextcallback(...)
			end
		end
	end

	local index = #callbacks + 1
	callbacks[index] = callback
	indexes[id] = index
	hook_id[name][index] = id
end


hook = setmetatable({
	Remove = Remove,
	GetTable = GetTable,
	Exists = Exists,
	Add = Add,
	Call = Call,
	Run = Run
}, {
	__call = function(self, ...)
		return self.Add(...)
	end
})
--PATH addons/__main_only_1st/lua/autorun/altair_ibnlaahad.lua:
/*
	Addon by Voikanaa	
*/

player_manager.AddValidModel( "Altair Ibn-La'Ahad", 	"models/player/altair_ibnlaahad.mdl" );
player_manager.AddValidHands( "Altair Ibn-La'Ahad", 	"models/player/altair_ibnlaahad_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Altair Ibn-La'Ahad", 	"models/player/altair_ibnlaahad.mdl" );
--PATH addons/shaccessorysystem/lua/accessory/cl_notify.lua:
function SH_ACC:Notify(acc, text, duration)
	if (IsValid(_SH_ACC_NOTIFY)) then
		_SH_ACC_NOTIFY:Remove()
	end

	local scale = math.Clamp(ScrH() / 1080, 0.7, 1)
	local wi, he = 400 * scale, 64 * scale

	local th = 48 * scale
	local m = th * 0.25
	local m5 = m * 0.5
	he = he + m5 * 2

	local pnl = vgui.Create("DButton")
	pnl:SetText("")
	pnl:MoveToFront()
	pnl:SetSize(wi, he)
	pnl:SetPos(ScrW(), ScrH() * 0.7)
	pnl:MoveTo(ScrW() - wi, pnl.y, 0.2, 0, 0.99)
	pnl:DockPadding(m5, m5, m5, m5)
	pnl.DoClick = function(me)
		me.DoClick = function() end
		me:Stop()
		me:AlphaTo(0, 0.2, 0, function()
			me:Remove()
		end)
	end
	pnl.Paint = function(me, w, h)
		draw.RoundedBoxEx(4, 0, 0, w, h, self.Style.header, true, false, true, false)
	end
	_SH_ACC_NOTIFY = pnl

	pnl:AlphaTo(0, 0.2, duration > 0 and duration or 5, function()
		pnl:Remove()
	end)

		if (acc) then
			local bg = vgui.Create("DPanel", pnl)
			bg:Dock(LEFT)
			bg:DockMargin(0, 0, m5, 0)
			bg.Paint = function(me, w, h)
				draw.RoundedBox(4, 0, 0, w, h, self.Style.inbg)
			end

				local mdl = self:CreateAccIcon(acc, bg)
				mdl:SetMouseInputEnabled(false)
		end

		local lbl = self:Label(text, "SH_ACC.Large", self.Style.text, pnl)
		lbl:SetContentAlignment(7)
		lbl:SetWrap(true)
		lbl:Dock(FILL)

		if (duration > 0) then
			local start = CurTime()
			local endtime = start + duration

			local timebar = vgui.Create("DPanel", pnl)
			timebar:SetTall(m5)
			timebar:Dock(BOTTOM)
			timebar:DockMargin(0, m5, 0, 0)
			timebar.Paint = function(me, w, h)
				local tl = (endtime - CurTime()) / (endtime - start)

				draw.RoundedBox(4, 0, 0, w, h, self.Style.bg)
				draw.RoundedBox(4, 0, 0, w * tl, h, self.Style.menu)
			end
		end
end

net.Receive("SH_ACC_NOTIFY", function()
	SH_ACC:Notify(SH_ACC:GetAccessory(net.ReadString()), net.ReadString(), net.ReadUInt(16))
end)

--PATH addons/__main/lua/autorun/blitzo_pm.lua:
player_manager.AddValidModel( "Blitzo", "models/player/blitzo_character/blitzo_pm/blitzo_pm.mdl" );
player_manager.AddValidHands( "Blitzo", "models/player/blitzo_character/blitzo_hands/c_arms_blitzo.mdl", 0, "00000000" );
list.Set( "PlayerOptionsModel", "Blitzo", "models/player/blitzo_character/blitzo_pm/blitzo_pm.mdl" );
--PATH addons/__main/lua/autorun/cl_roll.lua:
local curPitch = 0
local deg = 0
local inRoll = false

local function rollTo()

	deg = net.ReadInt(16)
	inRoll = true
	curPitch = deg-360

end
net.Receive("ClimbRoll", rollTo)

hook.Add("CalcView", "ClimbRollEffect", function(ply, pos, ang, fov)
	
	if (!inRoll) then return; end
	
	local view = GAMEMODE:CalcView(ply, pos, ang, fov)
	curPitch = math.Approach(curPitch, deg, FrameTime() * 625)
	if curPitch == deg then inRoll = false; end
	view.angles.p = curPitch
	return view
	
end)


--PATH addons/__new_main_all/lua/autorun/code_green.lua:
include( "main/totem_language.lua" )
include( "main/totem_tools.lua" )

util.PrecacheSound( "totem_sound/totem_of_undying.mp3" )

if SERVER then
    util.AddNetworkString( "DoTotemAnimation" )
end

TotemImages = {}
local img = nil

for i=1, 63 do
    img = Material( "img/totem/frame"..i..".png" )
    table.insert( TotemImages, img )
end

ChooseLanguage()
--PATH addons/ukrp_main_content/lua/autorun/detective.lua:
-- Создано KERRY 11.01.2019 --
--- Здесь ничего нет, уходите ---

-- Список моделей игроков ---
list.Set( "PlayerOptionsModel","Detective 01","models/kerry/detective/male_01.mdl" )
player_manager.AddValidModel( "Detective 01","models/kerry/detective/male_01.mdl" )

list.Set( "PlayerOptionsModel","Detective 02","models/kerry/detective/male_02.mdl" )
player_manager.AddValidModel( "Detective 02","models/kerry/detective/male_02.mdl" )

list.Set( "PlayerOptionsModel","Detective 03","models/kerry/detective/male_03.mdl" )
player_manager.AddValidModel( "Detective 03","models/kerry/detective/male_03.mdl" )

list.Set( "PlayerOptionsModel","Detective 04","models/kerry/detective/male_04.mdl" )
player_manager.AddValidModel( "Detective 04","models/kerry/detective/male_04.mdl" )

list.Set( "PlayerOptionsModel","Detective 05","models/kerry/detective/male_05.mdl" )
player_manager.AddValidModel( "Detective 05","models/kerry/detective/male_05.mdl" )

list.Set( "PlayerOptionsModel","Detective 06","models/kerry/detective/male_06.mdl" )
player_manager.AddValidModel( "Detective 06","models/kerry/detective/male_06.mdl" )

list.Set( "PlayerOptionsModel","Detective 07","models/kerry/detective/male_07.mdl" )
player_manager.AddValidModel( "Detective 07","models/kerry/detective/male_07.mdl" )

list.Set( "PlayerOptionsModel","Detective 08","models/kerry/detective/male_08.mdl" )
player_manager.AddValidModel( "Detective 08","models/kerry/detective/male_08.mdl" )

list.Set( "PlayerOptionsModel","Detective 09","models/kerry/detective/male_09.mdl" )
player_manager.AddValidModel( "Detective 09","models/kerry/detective/male_09.mdl" )

--list.Set( "PlayerOptionsModel","KERRY","models/kerry/detective/male_09_kerry.mdl" )
--player_manager.AddValidModel( "KERRY","models/kerry/detective/male_09_kerry.mdl" )

-- https://vk.com/69kerry69 --
--PATH addons/__main/lua/autorun/dishwhalerplynpc.lua:
player_manager.AddValidModel( "dish_ass", "models/predatorcz/dish/assasin_ply.mdl" )
player_manager.AddValidHands( "dish_ass", "models/predatorcz/dish/assasin_hands.mdl", 0, "00000000" )
player_manager.AddValidModel( "dish_seer", "models/predatorcz/dish/overseer_ply.mdl" )
player_manager.AddValidHands( "dish_seer", "models/predatorcz/dish/overseer_hands.mdl", 0, "00000000" )
--PATH addons/_drones/lua/dronesrewrite/ai.lua:
DRONES_REWRITE.AI = { }

DRONES_REWRITE.AI.ShouldAttackReverse = function(drone, v)
	if not IsValid(drone.Owner) then return false end
	if not IsValid(v) then return false end

	if not v:IsPlayer() and not v.IS_DRONE then return false end
	if v:Health() <= 0 then return false end
	if v:GetClass() == "npc_bullseye" then return false end
	if drone:IsWeapon(v) then return false end

	local dist = v:GetPos():Distance(drone:GetPos())
	if dist > 1500 then return false end

	if drone.Owner.dronesrewrite_friends and not table.HasValue(drone.Owner.dronesrewrite_friends, v:EntIndex()) then 
		return false 
	end

	if v.IS_DRONE then
		if v == drone then return false end

		if not v.IS_DRR then
			if v.Armor and v.Armor <= 0 then return false end
		else
			if v:IsDroneDestroyed() then return false end
		end
	end

	return true
end

DRONES_REWRITE.AI.ShouldAttack = function(drone, v)
	if not IsValid(drone.Owner) then return false end
	if not IsValid(v) then return false end

	if not v:IsPlayer() and not v.IS_DRONE then return false end
	if drone:IsWeapon(v) then return false end

	local dist = v:GetPos():Distance(drone:GetPos())
	if dist > 1500 then return false end

	if drone.Owner.dronesrewrite_friends and table.HasValue(drone.Owner.dronesrewrite_friends, v:EntIndex()) then 
		return false 
	end

	if v:IsPlayer() then
		if v:Health() <= 0 then return false end
		if v == drone.Owner then return false end
	end

	if v:IsNPC() then
		return false
	end

	if v.IS_DRONE then
		if v == drone then return false end

		if v.IS_DRR then
			if v:IsDroneDestroyed() then return false end

			if drone.Owner.dronesrewrite_friends then
				for k, p in player.Iterator() do
					if table.HasValue(drone.Owner.dronesrewrite_friends, p:EntIndex()) then
						if p == v.Owner then return false end
					end
				end
			end
		else
			if v.Armor and v.Armor <= 0 then return false end
		end
	end

	return true
end

DRONES_REWRITE.AI.CheckSide = function(drone, side, distance)
	distance = distance or 180

	local start = drone:LocalToWorld(drone:OBBCenter())

	local tr = util.TraceLine({
		start = start,
		endpos = start + side * distance,
		filter = drone
	})

	return tr.Hit
end

DRONES_REWRITE.AI.Attack = function(drone, v)
	if not drone.AI_ReverseCheck and not DRONES_REWRITE.AI.ShouldAttack(drone, v) then return end
	if drone.AI_ReverseCheck and not DRONES_REWRITE.AI.ShouldAttackReverse(drone, v) then return end

	local dir = (v:LocalToWorld(v:OBBCenter()) - drone.Camera:GetPos()):GetNormal()

	local tr = util.TraceLine({
		start = drone.Camera:GetPos(),
		endpos = drone.Camera:GetPos() + dir * 1500,
		filter = drone
	})

	local shoot = tr.Entity == v and drone.Camera:GetForward():GetNormal():Dot(dir) > 0.35

	if shoot then 
		drone.Buffer.Enemy = v

		local drpos = drone:GetPos()

		if not drone.AI_NoSkipZ then
			drpos.z = 0
			tr.HitPos.z = 0
		end

		local dist = tr.HitPos:Distance(drpos)
		if drone.AI_MaxDistance and dist > drone.AI_MaxDistance then return end
		if drone.AI_CustomEnemyChecker and not drone:AI_CustomEnemyChecker(v) then return end

		local ang = drone:WorldToLocalAngles(dir:Angle())

		if drone.AllowPitchRestrictions then
			if ang.p < drone.PitchMin then ang.p = drone.PitchMin end
			if ang.p > drone.PitchMax then ang.p = drone.PitchMax end
		end

		if drone.AllowYawRestrictions then
			if ang.y < drone.YawMin then ang.y = drone.YawMin end
			if ang.y > drone.YawMax then ang.y = drone.YawMax end
		end

		drone.CamAngles = drone:LocalToWorldAngles(ang)

		drone:ClickKey("Fire1")  

		if not timer.Exists("dronesrewrite_ai_setupcamangs" .. drone:EntIndex()) then
			timer.Create("dronesrewrite_ai_setupcamangs" .. drone:EntIndex(), 3, 1, function()
				if not IsValid(drone) then return end
				drone.Buffer.Enemy = nil
				drone.Camera:SetAngles(drone:GetAngles())
				drone.CamAngles = drone:GetAngles()
			end)
		end
	end
end

DRONES_REWRITE.AI.MovingCore = function(drone)
	local len = drone:GetPhysicsObject():GetVelocity():Length() * 0.01
	local num = 1.5 + len

	local dist = drone:OBBMaxs().x * num

	if not drone.Buffer.CheckEnabled then drone.Buffer.CheckEnabled = 0 end
	if not drone:IsDroneEnabled() and CurTime() > drone.Buffer.CheckEnabled then
		drone:SetEnabled(true)
		drone.Buffer.CheckEnabled = CurTime() + 2
	end

	if DRONES_REWRITE.AI.CheckSide(drone, -drone:GetForward(), dist) then
		drone:ClickKey("Forward")
		drone.Buffer.RandomBack = 0
	end

	if DRONES_REWRITE.AI.CheckSide(drone, drone:GetForward(), dist) then
		drone:ClickKey("Back")

		local val = math.random(0, 1)
		if val == 0 then val = -1 end -- ??????

		drone.Buffer.RandomAngle = math.random(95, 130) * val
		drone.Buffer.RandomForward = 0
	end

	if drone.Buffer.RandomForward and drone.Buffer.RandomForward > 0 and DRONES_REWRITE.AI.CheckSide(drone, drone:GetForward(), drone.Buffer.RandomForward) then
		drone.Buffer.RandomAngle = 90 * math.Clamp(math.random(-1, 1), -1, 1)
	end

	local dist = drone:OBBMaxs().z * 1.5

	if drone.AI_AllowUp and DRONES_REWRITE.AI.CheckSide(drone, -drone:GetUp(), dist) then
		drone:ClickKey("Up")
		drone.Buffer.RandomDown = 0
	end

	if drone.AI_AllowDown and DRONES_REWRITE.AI.CheckSide(drone, drone:GetUp(), dist) then
		drone:ClickKey("Down")
		drone.Buffer.RandomUp = 0
	end

	local dist = drone:OBBMaxs().y * num

	if DRONES_REWRITE.AI.CheckSide(drone, -drone:GetRight(), dist) then
		drone:ClickKey("StrafeRight")
	end

	if DRONES_REWRITE.AI.CheckSide(drone, drone:GetRight(), dist) then
		drone:ClickKey("StrafeLeft")
	end
end
--PATH addons/_drones/lua/dronesrewrite/client/cam.lua:
local oldAngles

DRONES_REWRITE.UpdateCamera = function()
	hook.Add("CalcView", "dronesrewrite_view_camera", function(ply)
		local drone = ply:GetNWEntity("DronesRewriteDrone")

		if drone:IsValid() then
			if not oldAngles then 
				oldAngles = ply:EyeAngles() 
				ply:SetEyeAngles(Angle(0, 0, 0))
			end
			
			-- Calculating angles CLIENT-SIDE
			-- Without net
			local eang = ply:EyeAngles()

			if drone.AllowPitchRestrictions then
				if eang.p < drone.PitchMin then eang.p = drone.PitchMin end
				if eang.p > drone.PitchMax then eang.p = drone.PitchMax end
			end

			if drone.AllowYawRestrictions then
				if eang.y < drone.YawMin then eang.y = drone.YawMin end
				if eang.y > drone.YawMax then eang.y = drone.YawMax end
			end

			if drone:SupportAngles() and eang != ply:EyeAngles() then ply:SetEyeAngles(eang) end

			local ang

			if drone.SimplestCamera then
				ang = eang
			else
				ang = drone:LocalToWorldAngles(eang)
			end
			
			drone.CamAngles = ang

			local view = { }

			if not drone:GetNWBool("ThirdPerson") then
				view.origin = drone:GetCamera():IsValid() and drone:GetCamera():LocalToWorld(drone:GetLocalCamPos()) or drone:GetPos()
				if drone:SupportAngles() then 
					view.angles = drone:LocalToWorldAngles(ply:EyeAngles())
				end 
			else
				local pang = ply:EyeAngles()
		
				local ang

				if drone.SimplestCamera then
					ang = pang
				else
					ang = drone:LocalToWorldAngles(pang)
				end

				local pos = drone:LocalToWorld(drone.ThirdPersonCam_pos)

				local tr = util.TraceLine({
					start = drone:LocalToWorld(drone:OBBCenter()), --pos,-- drone:GetPos(),
					endpos = pos - ang:Forward() * drone.ThirdPersonCam_distance,
					mask = MASK_SOLID_BRUSHONLY
				})

				view.origin = tr.HitPos + tr.HitNormal * 2
				view.angles = ang
			end

			return view 
		else
			if oldAngles then
				ply:SetEyeAngles(oldAngles)
				oldAngles = nil
			end
		end
	end)

	hook.Add("ShouldDrawLocalPlayer", "dronesrewrite_fixmodel", function(ply)
		local drone = ply:GetNWEntity("DronesRewriteDrone")
		if drone:IsValid() then return true end
	end)
end

-- Preventing other addons override your camera
DRONES_REWRITE.UpdateCamera()
--PATH addons/_drones/lua/dronesrewrite/client/overlay/red.lua:
DRONES_REWRITE.Overlay["Red"] = function(drone)
	local eff_tab = {
		["$pp_colour_addr"] = 0.5,
		["$pp_colour_addg"] = 0,
		["$pp_colour_addb"] = 0,
		["$pp_colour_brightness"] = -0.5,
		["$pp_colour_contrast"] = 1,
		["$pp_colour_colour"] = 0.7,
		["$pp_colour_mulr"] = 0,
		["$pp_colour_mulg"] = 0,
		["$pp_colour_mulb"] = 0
	}

	DrawSharpen(0.65, 4)
	--DrawMotionBlur(0.3, 1, 0.01)

	DrawColorModify(eff_tab)
end
--PATH addons/_drones/lua/dronesrewrite/weapons/bite.lua:
DRONES_REWRITE.Weapons["Spider Bite"] = {
	Initialize = function(self, pos)
		local ent = DRONES_REWRITE.Weapons["Template"].InitializeNoDraw(self)
		ent.BitePos = pos -- Not useable stuff
		return ent
	end,

	Attack = function(self, gun)
		if self:WasKeyPressed("Fire1") and CurTime() > gun.NextShoot then
			local ent = self:GetCameraTraceLine(32).Entity

			if ent:IsValid() then
				local driver = self:GetDriver()
				ent:TakeDamage(1, driver, driver)

				if not ent.DRR_Poisoned then
					local next = 0
					local freq = 5
					local times = 0

					if ent:IsPlayer() then
						net.Start("dronesrewrite_playsound")
							net.WriteString("vo/npc/male01/moan01.wav")
						net.Send(ent)
					end

					hook.Add("Think", "dronesrewrite_bite_poison" .. ent:EntIndex(), function()
						if CurTime() > next then
							if not IsValid(ent) or ((ent:IsNPC() and ent:Health() <= 0) or (ent:IsPlayer() and not ent:Alive())) then
								if IsValid(ent) then ent.DRR_Poisoned = false end

								hook.Remove("Think", "dronesrewrite_bite_poison" .. ent:EntIndex())
								return
							end

							if ent:IsPlayer() then
								net.Start("dronesrewrite_playsound")
									net.WriteString("vo/npc/male01/ow0" .. math.random(1, 2) .. ".wav")
								net.Send(ent)
							end

							ent:TakeDamage((6 - freq), driver, driver)

							next = CurTime() + freq
							freq = math.Approach(freq, 1, 1)
							times = times + 1

							if times >= 17 then
								if ent:IsPlayer() then
									net.Start("dronesrewrite_playsound")
										net.WriteString("vo/npc/male01/moan04.wav")
									net.Send(ent)
								end

								ent.DRR_Poisoned = false
								hook.Remove("Think", "dronesrewrite_bite_poison" .. ent:EntIndex())
							end
						end
					end)

					ent.DRR_Poisoned = true
				end

				gun:EmitSound("npc/barnacle/barnacle_tongue_pull2.wav", 75, 100, 1, CHAN_WEAPON)
			end

			gun:EmitSound("npc/barnacle/neck_snap1.wav", 60, math.random(80, 110), 1, CHAN_WEAPON)
			gun.NextShoot = CurTime() + 0.2
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/grenade_launcher.lua:
DRONES_REWRITE.Weapons["Grenade Launcher"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/autogrenadelauncher/autogrenadelauncher.mdl", pos, ang, "models/dronesrewrite/attachment4/attachment4.mdl", pos)

		ent.Grenade = {
			["Explosive"] = {
				Material = "models/dronesrewrite/grenade/grenade_x_mat",
				AmmoType = "item_drr_grenades",
				AmmoCount = 30,

				Explosion = function(driver, ammo)
					ammo:EmitSound("ambient/explosions/explode_1.wav", 80, 100)

					util.BlastDamage(ammo, IsValid(driver) and driver or ammo, ammo:GetPos(), 230, math.random(60, 100))
					
					--[[local ef = EffectData()
					ef:SetOrigin(ammo:GetPos())
					util.Effect("Explosion", ef)]]--
					
					ParticleEffect("splode_fire", ammo:GetPos(), Angle(0, 0, 0))
				end
			},
			
			["EMP"] = {
				Material = "models/dronesrewrite/grenade/grenade_e_mat",
				AmmoType = "item_drr_grenadeselec",
				AmmoCount = 30,

				Explosion = function(driver, ammo)
					ammo:EmitSound("drones/nio_dissolve.wav", 80, 100)

					for k, v in ipairs(ents.FindInSphere(ammo:GetPos(), 200)) do
						if v.IS_DRR then v:TakeDamage(math.random(40, 90), driver, driver) end
					end
					
					util.BlastDamage(ammo, IsValid(driver) and driver or ammo, ammo:GetPos(), 200, math.random(5, 20))
					
					ParticleEffect("stinger_explode_drr", ammo:GetPos(), Angle(0, 0, 0))
				end
			},

			["Napalm"] = {
				Material = "models/dronesrewrite/grenade/grenade_f_mat",
				AmmoType = "item_drr_grenadesfire",
				AmmoCount = 30,

				Explosion = function(driver, ammo)
					local pos = ammo:GetPos()

					timer.Create("igniteshit" .. ammo:EntIndex(), 0.1, 8, function()
						for k, v in pairs(ents.FindInSphere(pos, 200)) do
							v:Ignite(3, 4)
						end
					end)

					ammo:EmitSound("ambient/fire/ignite.wav", 90, 100)

					util.BlastDamage(ammo, IsValid(driver) and driver or ammo, ammo:GetPos(), 150, math.random(60, 80))
					ParticleEffect("napalmgren_shockwave_drr", ammo:GetPos(), Angle(0, 0, 0))
				end
			}
		}

		ent.GetCurrentGrenade = function(ent)
			return ent.Grenade[ent.GrenadeType]
		end

		ent.HasPrimaryAmmo = function(ent)
			return ent:GetCurrentGrenade().AmmoCount > 0
		end

		ent.HasSecondaryAmmo = function(ent)
			return ent:GetCurrentGrenade().AmmoCount > 0
		end

		ent.GetPrimaryAmmo = function(e, type) 
			if ent.PrimaryAsSecondary then
				return ent:GetSecondaryAmmo()
			end

			local count = 0
			for _, v in pairs(ent.Grenade) do
				if v.AmmoType == type then
					count = v.AmmoCount
				end
			end

			return count
		end

		ent.SetPrimaryAmmo = function(ent, num, ammotype)
			if ent.PrimaryAsSecondary then
				ent:SetSecondaryAmmo(num, ammotype)

				return 
			end

			if not self.ShouldConsumeAmmo then return end

			for k, v in pairs(ent.Grenade) do
				if ammotype == v.AmmoType then
					num = v.AmmoCount + num

					if num > v.AmmoCount and ent.Tab.OnPrimaryAdded then 
						ent.Tab.OnPrimaryAdded(self, ent, num - v.AmmoCount) 
					end

					self:SetNWInt("Ammo1", num)
					self:SetNWInt("MaxAmmo1", ent:GetPrimaryMax())

					v.AmmoCount = num
				end
			end
		end

		ent.SetSecondaryAmmo = function(ent, num, ammotype)
			if not self.ShouldConsumeAmmo then return end

			for k, v in pairs(ent.Grenade) do
				if ammotype == v.AmmoType then
					num = v.AmmoCount + num

					if num > v.AmmoCount and ent.Tab.OnPrimaryAdded then 
						ent.Tab.OnPrimaryAdded(self, ent, num - v.AmmoCount) 
					end

					self:SetNWInt("Ammo2", num)
					self:SetNWInt("MaxAmmo2", ent:GetPrimaryMax())

					v.AmmoCount = num
				end
			end
		end

		ent.GrenadeType = table.GetFirstKey(ent.Grenade)
		self:SetNWString("gr_launch_type", ent.GrenadeType)

		ent.PrimaryAmmoMax = 30
		ent.PrimaryAmmoType = { 
			DRONES_REWRITE.AmmoTypes.FireGrenades,
			DRONES_REWRITE.AmmoTypes.ElectroGrenades,
			DRONES_REWRITE.AmmoTypes.Grenades
		}

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			local src = gun:GetPos() + gun:GetForward() * 60 - gun:GetUp() * 2

			local grn = gun:GetCurrentGrenade()
			local ammo = ents.Create("prop_physics")
			ammo.Grenade = grn
			ammo:SetModel("models/dronesrewrite/grenade_fired/grenade_fired.mdl")
			ammo:SetMaterial(grn.Material)
			ammo:SetPos(src)
			ammo:SetAngles(gun:GetAngles())
			ammo:Spawn()

			constraint.NoCollide(ammo, self, 0, 0)
				
			local physamm = ammo:GetPhysicsObject()	
			if physamm:IsValid() then
				physamm:SetMass(1)
				physamm:ApplyForceCenter(gun:GetForward() * 3200)
				physamm:AddAngleVelocity(VectorRand() * 50)
			end

			local ef = EffectData()
			ef:SetOrigin(src)
			ef:SetNormal(gun:GetForward())
			util.Effect("dronesrewrite_muzzleflashgrn", ef)

			timer.Simple(1.5, function()
				if IsValid(ammo) then
					ammo.Grenade.Explosion((IsValid(self) and IsValid(self:GetDriver())) and self:GetDriver() or ammo, ammo)
				end

				SafeRemoveEntity(ammo)
			end)

			gun:EmitSound("weapons/mortar/mortar_fire1.wav", 75, 110, 1, CHAN_WEAPON)

			gun:SetPrimaryAmmo(-1, grn.AmmoType)
			gun.NextShoot = CurTime() + 0.2
		end
	end,

	Attack2 = function(self, gun)
		if CurTime() > gun.NextShoot2 then
			local k, v = next(gun.Grenade, gun.GrenadeType)

			gun.GrenadeType = k or table.GetFirstKey(gun.Grenade)
			self:SetNWString("gr_launch_type", gun.GrenadeType)

			gun.NextShoot2 = CurTime() + 0.2
		end
	end,

	OnRemove = function(self, gun)
		self:RemoveHookClient("HUD", "gr_launcher_hud")
	end,

	Deploy = function(self, gun)
		self:AddHookClient("HUD", "gr_launcher_hud", [[
			local drone = LocalPlayer():GetNWEntity("DronesRewriteDrone")

			if drone:IsValid() then
				local x = 32
				local y = ScrH() * 0.5

				draw.SimpleText("Grenade type: " .. drone:GetNWString("gr_launch_type"), "DronesRewrite_font3", x, y, Color(0, 255, 255, 150))
			end
		]])
	end,

	Holster = function(self, gun)
		self:RemoveHookClient("HUD", "gr_launcher_hud")
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/minedropper.lua:
DRONES_REWRITE.Weapons["Minedropper"] = {
	Initialize = function(self, pos, ang, src)
		local ent = DRONES_REWRITE.Weapons["Template"].InitializeNoHandler(self, "models/dronesrewrite/minedropper_wep/minedropper_wep.mdl", pos, ang)
		ent.Mines = { }

		ent.RespawnMine = function()
			if IsValid(ent.Mine) then return end
			if not ent:HasPrimaryAmmo() then
				ent.WaitForAmmo = true
				return
			end

			ent:EmitSound("items/ammo_pickup.wav", 70, 140)

			local ang = ent:GetAngles()

			local e = ents.Create("prop_physics")
			e:SetModel("models/dronesrewrite/landmine/landmine.mdl")
			e:SetPos(ent:GetPos() + ang:Right() * 15 - ang:Up() * 9.3)
			ang = self:GetAngles()
			ang:RotateAroundAxis(ang:Up(), 45)
			e:SetAngles(ang)
			e:Spawn()
			e:Activate()
			e:SetParent(ent)
			e:SetNotSolid(true)
			e:PhysicsDestroy()

			ent.Mine = e
		end

		ent:RespawnMine()

		ent.PrimaryAmmo = 10
		ent.PrimaryAmmoMax = 10
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Mines }

		return ent
	end,

	Attack = function(self, gun)
		if self:WasKeyPressed("Fire1") and CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			if not IsValid(gun.Mine) then return end

			gun:EmitSound("buttons/lightswitch2.wav", 70, 200, CHAN_WEAPON)

			local mine = ents.Create("dronesrewrite_mine")
			mine:SetPos(gun.Mine:GetPos())
			mine:SetAngles(gun.Mine:GetAngles())
			
			mine.DroneOwner = self
			mine.Owner = self:GetDriver()
			
			mine:Spawn()
			mine:GetPhysicsObject():SetVelocity(self:GetVelocity())
			
			table.insert(gun.Mines, mine)

			SafeRemoveEntity(gun.Mine)

			gun:SetPrimaryAmmo(-1)
			gun.NextShoot = CurTime() + 1
		end
	end,

	Attack2 = function(self, gun)
		for k, v in pairs(gun.Mines) do
			if IsValid(v) then
				v:Boom()
			end
		end
	end,

	Think = function(self, gun)
		if gun.WaitForAmmo and gun:HasPrimaryAmmo() then
			gun:RespawnMine()
			gun.WaitForAmmo = false
		end

		if not IsValid(gun.Mine) and CurTime() > gun.NextShoot then
			gun:RespawnMine()
		end
	end,
}
--PATH addons/_drones/lua/dronesrewrite/weapons/missile_launcher.lua:
DRONES_REWRITE.Weapons["Missile Battery"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/rocket_battery/rocket_battery.mdl", pos, ang, "models/dronesrewrite/attachment3/attachment3.mdl", pos + ang:Up() * 7 + ang:Forward() * 2)
		ent.Rockets = { }

		local count = 1

		ent.AddRockets = function(ent)
			local count = 1

			for a = 0, 6 do
				for b = 0, 3 do
					SafeRemoveEntity(ent.Rockets[count])

					local h = ents.Create("prop_physics")
					h:SetModel("models/dronesrewrite/bigrocket_cl/bigrocket_cl.mdl")
					h:SetPos(ent:LocalToWorld(Vector(0, a * 4.7, b * 4.7)) + ent:GetUp() * 9.7 + ent:GetRight() * 14 + ent:GetForward() * 33)
					h:SetAngles(ent:GetAngles())
					h:Spawn()
					h:Activate()
					h:SetParent(ent)
					h:SetNotSolid(true)
					h:PhysicsDestroy()

					ent.Rockets[count] = h

					count = count + 1
				end
			end
		end

		ent:AddRockets()

		ent.PrimaryAmmo = 100
		ent.PrimaryAmmoMax = 100
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Missiles }

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	OnPrimaryAdded = function(self, gun, num)
		gun:AddRockets()
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			local rocket = table.Random(gun.Rockets)
			if not IsValid(rocket) then return end

			local ammo = ents.Create("dronesrewrite_missile")
			ammo:SetPos(rocket:GetPos())
			ammo:SetOwner(self:GetDriver())
			ammo:SetAngles(rocket:GetAngles())
			ammo:Spawn()
					
			constraint.NoCollide(ammo, self, 0, 0)

			local physamm = ammo:GetPhysicsObject()
			if IsValid(physamm) then physamm:EnableGravity(false) end 
					
			physamm:AddVelocity(gun:GetForward() * 5000)

			local pos = gun:WorldToLocal(rocket:GetPos())
			local id = table.KeyFromValue(gun.Rockets, rocket)

			rocket:EmitSound("drones/missilelaunch.wav", 86, math.random(95, 115), 1, CHAN_WEAPON)
			gun:SetPrimaryAmmo(-1)

			local ef = EffectData()
			ef:SetOrigin(rocket:GetPos())
			ef:SetNormal(gun:GetForward())
			util.Effect("dronesrewrite_missilelaunch", ef)
			
			rocket:Remove()
			gun.Rockets[id] = nil

			-- 28 is a number of rockets in the launcher
			if gun:GetPrimaryAmmo() >= 28 then
				timer.Simple(15, function()
					if not self:IsValid() then return end
					if not gun:IsValid() then return end
					if not gun:HasPrimaryAmmo() then return end
					if IsValid(gun.Rockets[id]) then return end

					local h = ents.Create("prop_physics")
					h:SetModel("models/dronesrewrite/bigrocket_cl/bigrocket_cl.mdl")
					h:SetPos(gun:LocalToWorld(pos))
					h:SetAngles(gun:GetAngles())
					h:Spawn()
					h:Activate()
					h:SetParent(gun)
					h:SetNotSolid(true)
					h:PhysicsDestroy()

					gun.Rockets[id] = h
					gun:EmitSound("items/ammocrate_close.wav")
				end)
			end

			gun.NextShoot = CurTime() + 0.35
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/rocket_launcher.lua:
DRONES_REWRITE.Weapons["Rocket Launcher"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/rocket_launcher/rocket_launcher.mdl", pos, ang, "models/dronesrewrite/attachment4/attachment4.mdl", pos)

		ent.PrimaryAmmo = 40
		ent.PrimaryAmmoMax = 40
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Rockets }

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			local src = gun:GetPos() + gun:GetForward() * -10

			local ammo = ents.Create("dronesrewrite_rocket")
			ammo:SetPos(src)
			ammo:SetOwner(self:GetDriver())
			ammo:SetAngles(gun:GetAngles())
			ammo:Spawn()
			
			constraint.NoCollide(ammo, self, 0, 0)

			local physamm = ammo:GetPhysicsObject()
			if IsValid(physamm) then physamm:EnableGravity(false) end 
			
			physamm:AddVelocity(gun:GetForward() * 2000)

			ammo:EmitSound("weapons/rpg/rocketfire1.wav", 79, 100, 1, CHAN_WEAPON)

			gun:SetPrimaryAmmo(-1)

			timer.Simple(0.3, function()
				if IsValid(gun) then gun:EmitSound("vehicles/tank_readyfire1.wav", 80, 255) end
			end)
			gun.NextShoot = CurTime() + 1.2
		end
	end
}
--PATH addons/_fpr/lua/fprofiler/prettyprint.lua:
-- Based on MDave's thing
-- https://gist.github.com/mentlerd/d56ad9e6361f4b86af84
if SERVER then AddCSLuaFile() end

local type_weight = {
    [TYPE_FUNCTION] = 1,
    [TYPE_TABLE]    = 2,
}

local type_colors = {
    [TYPE_BOOL]     = Color(175, 130, 255),
    [TYPE_NUMBER]   = Color(175, 130, 255),
    [TYPE_STRING]   = Color(230, 220, 115),
    [TYPE_FUNCTION] = Color(100, 220, 240)
}

local color_neutral   = Color(220, 220, 220)
local color_name      = Color(260, 150,  30)

local color_reference = Color(150, 230,  50)
local color_comment   = Color( 30, 210,  30)

-- 'nil' value
local NIL = {}

-- Localise for faster access
local pcall         = pcall

local string_len    = string.len
local string_sub    = string.sub
local string_find   = string.find

local table_concat  = table.concat
local table_insert  = table.insert
local table_sort    = table.sort


-- Stream interface
local gMsgF -- Print fragment
local gMsgN -- Print newline
local gMsgC -- Set print color

local PrintLocals, gBegin, gFinish, PrintTableGrep

do
    local grep_color   = Color(235, 70, 70)

    -- Grep parameters (static between gBegin/gEnd)
    local grep
    local grep_raw

    local grep_proximity


    -- Current line parameters
    local buffer
    local colors
    local markers

    local baseColor
    local currColor

    local length

    -- History
    local history
    local remain


    -- Actual printing
    local function gCheckMatch( buffer )
        local raw = table_concat(buffer)

        return raw, string_find(raw, grep, 0, grep_raw)
    end

    local function gFlushEx( raw, markers, colors, baseColor )

        -- Print entire buffer
        local len = string_len(raw)

        -- Keep track of the current line properties
        local index  = 1
        local marker = 1

        local currColor = baseColor

        -- Method to print to a preset area
        local function printToIndex( limit, color )
            local mark = markers and markers[marker]

            -- Print all marker areas until we would overshoot
            while mark and mark < limit do

                -- Catch up to the marker
                MsgC(color or currColor or color_neutral, string_sub(raw, index, mark))
                index = mark +1

                -- Set new color
                currColor = colors[marker]

                -- Select next marker
                marker = marker +1
                mark   = markers[marker]

            end

            -- Print the remaining between the last marker and the limit
            MsgC(color or currColor or color_neutral, string_sub(raw, index, limit))
            index = limit +1
        end

        -- Grep!
        local match, last = 1
        local from, to = string_find(raw, grep, 0, grep_raw)

        while from do
            printToIndex(from -1)
            printToIndex(to, grep_color)

            last     = to +1
            from, to = string_find(raw, grep, last, grep_raw)
        end

        printToIndex(len)
        MsgN()
    end


    local function gCommit()
        if grep_proximity then
            -- Check if the line has at least one match
            local raw, match = gCheckMatch(buffer)

            if match then

                -- Divide matches
                if history[grep_proximity] then
                    MsgN("...")
                end

                -- Flush history
                if grep_proximity ~= 0 then
                    local len = #history

                    for index = len -1, 1, -1 do
                        local entry = history[index]
                            history[index] = nil

                        gFlushEx( entry[1], entry[2], entry[3], entry[4] )
                    end

                    history[len] = nil
                end

                -- Flush line, allow next X lines to get printed
                gFlushEx( raw, markers, colors, baseColor )
                remain = grep_proximity -1

                history[grep_proximity +1] = nil
            elseif remain > 0 then
                -- Flush immediately
                gFlushEx( raw, markers, colors, baseColor )
                remain = remain -1
            else
                -- Store in history
                table_insert(history, 1, {raw, markers, colors, baseColor})
                history[grep_proximity +1] = nil
            end
        else
            -- Flush anyway
            gFlushEx( table_concat(buffer), markers, colors, baseColor )
        end

        -- Reset state
        length = 0
        buffer = {}

        markers = nil
        colors  = nil

        baseColor = nil
        currColor = nil
    end

    -- State machine
    function gBegin( new, prox )
        grep = isstring(new) and new

        if grep then
            grep_raw       = not pcall(string_find, ' ', grep)
            grep_proximity = isnumber(prox) and prox

            -- Reset everything
            buffer  = {}
            history = {}
        end

        length = 0
        remain = 0

        baseColor = nil
        currColor = nil
    end

    function gFinish()
        if grep_proximity and history and history[1] then
            MsgN("...")
        end

        -- Free memory
        buffer  = nil
        markers = nil
        colors  = nil

        history = nil
    end


    function gMsgC( color )
        if grep then

            -- Try to save some memory by not immediately allocating colors
            if length == 0 then
                baseColor = color
                return
            end

            -- Record color change
            if color ~= currColor then
                if not markers then
                    markers = {}
                    colors  = {}
                end

                -- Record color change
                table_insert(markers, length)
                table_insert(colors,  color)
            end
        end

        currColor = color
    end

    function gMsgF( str )
        if grep then

            -- Split multiline fragments to separate ones
            local fragColor = currColor or baseColor

            local last = 1
            local from, to = string_find(str, '\n')

            while from do
                local frag = string_sub(str, last, from -1)
                local len  = from - last

                -- Merge fragment to the line
                length = length + len
                table_insert(buffer, frag)

                -- Print finished line
                gCommit()

                -- Assign base color as previous fragColor
                baseColor = fragColor

                -- Look for more
                last     = to +1
                from, to = string_find(str, '\n', last)
            end

            -- Push last fragment
            local frag = string_sub(str, last)
            local len  = string_len(str) - last +1

            length = length + len
            table_insert(buffer, frag)
        else
            -- Push immediately
            MsgC(currColor or baseColor or color_neutral, str)
        end
    end

    function gMsgN()
        -- Print everything in the buffer
        if grep then
            gCommit()
        else
            MsgN()
        end

        baseColor = nil
        currColor = nil
    end
end


local function InternalPrintValue( value )

    -- 'nil' values can also be printed
    if value == NIL then
        gMsgC(color_comment)
        gMsgF("nil")
        return
    end

    local color = type_colors[ TypeID(value) ]

    -- For strings, place quotes
    if isstring(value) then
        if string_len(value) <= 1 then
            value = string.format([['%s']], value)
        else
            value = string.format([["%s"]], value)
        end

        gMsgC(color)
        gMsgF(value)
        return
    end

    -- Workaround for userdata not using MetaName
    if string_sub(tostring(value), 0, 8) == "userdata" then
        local meta = getmetatable(value)

        if meta and meta.MetaName then
            value = string.format("%s: %p", meta.MetaName, value)
        end
    end

    -- General print
    gMsgC(color)
    gMsgF(tostring(value))

    -- For functions append source info
    if isfunction(value) then
        local info = debug.getinfo(value, 'S')
        local aux

        if info.what == 'C' then
            aux = "\t-- [C]: -1"
        else
            if info.linedefined ~= info.lastlinedefined then
                aux = string.format("\t-- [%s]: %i-%i", info.short_src, info.linedefined, info.lastlinedefined)
            else
                aux = string.format("\t-- [%s]: %i", info.short_src, info.linedefined)
            end
        end

        gMsgC(color_comment)
        gMsgF(aux)
    end
end


-- Associated to object keys
local objID

local function isprimitive( value )
    local id = TypeID(value)

    return id <= TYPE_FUNCTION and id ~= TYPE_TABLE
end

local function InternalPrintTable( table, path, prefix, names, todo )

    -- Collect keys and some info about them
    local keyList  = {}
    local keyStr   = {}

    local keyCount = 0

    for key, value in pairs( table ) do
        -- Add to key list for later sorting
        table_insert(keyList, key)

        -- Describe key as string
        if isprimitive(key) then
            keyStr[key] = tostring(key)
        else
            -- Lookup already known name
            local name = names[key]

            -- Assign a new unique identifier
            if not name then
                objID = objID +1
                name  = string.format("%s: obj #%i", tostring(key), objID)

                names[key] = name
                todo[key]  = true
            end

            -- Substitute object with name
            keyStr[key] = name
        end

        keyCount = keyCount +1
    end


    -- Exit early for empty tables
    if keyCount == 0 then
        return
    end


    -- Determine max key length
    local keyLen = 4

    for key, str in pairs(keyStr) do
        keyLen = math.max(keyLen, string.len(str))
    end

    -- Sort table keys
    if keyCount > 1 then
        table_sort( keyList, function( A, B )

            -- Sort numbers numerically correct
            if isnumber(A) and isnumber(B) then
                return A < B
            end

            -- Weight types
            local wA = type_weight[ TypeID( table[A] ) ] or 0
            local wB = type_weight[ TypeID( table[B] ) ] or 0

            if wA ~= wB then
                return wA < wB
            end

            -- Order by string representation
            return keyStr[A] < keyStr[B]

        end )
    end

    -- Determine the next level ident
    local new_prefix = string.format( "%s║%s", prefix, string.rep(' ', keyLen) )

    -- Mark object as done
    todo[table] = nil

    -- Start describing table
    for index, key in ipairs(keyList) do
        local value = table[key]

        -- Assign names to already described keys/values
        local kName = names[key]
        local vName = names[value]

        -- Decide to either fully describe, or print the value
        local describe = not isprimitive(value) and ( not vName or todo[value] )

        -- Ident
        gMsgF(prefix)

        -- Fancy table guides
        local moreLines = (index ~= keyCount) or describe

        if index == 1 then
            gMsgF(moreLines and '╦ ' or '═ ')
        else
            gMsgF(moreLines and '╠ ' or '╚ ')
        end

        -- Print key
        local sKey = kName or keyStr[key]

        gMsgC(kName and color_reference or color_name)
        gMsgF(sKey)

        -- Describe non primitives
        describe = istable(value) and ( not names[value] or todo[value] ) and value ~= NIL

        -- Print key postfix
        local padding = keyLen - string.len(sKey)
        local postfix = string.format(describe and ":%s" or "%s = ", string.rep(' ', padding))

        gMsgC(color_neutral)
        gMsgF(postfix)

        -- Print the value
        if describe then
            gMsgN()

            -- Expand access path
            local new_path = sKey

            if isnumber(key) or kName then
                new_path = string.format("%s[%s]", path or '', key)
            elseif path then
                new_path = string.format("%s.%s", path, new_path)
            end

            -- Name the object to mark it done
            names[value] = names[value] or new_path

            -- Describe
            InternalPrintTable(value, new_path, new_prefix, names, todo)
        else
            -- Print the value (or the reference name)
            if vName and not todo[value] then
                gMsgC(color_reference)
                gMsgF(string.format("ref: %s",vName))
            else
                InternalPrintValue(value)
            end

            gMsgN()
        end
    end

end

function PrintTableGrep( table, grep, proximity )
    local base = {
        [_G]    = "_G",
        [table] = "root"
    }

    gBegin(grep, proximity)
        objID = 0
        InternalPrintTable(table, nil, "", base, {})
    gFinish()
end

function PrintLocals( level )
    local level = level or 2
    local hash  = {}

    for index = 1, 255 do
        local name, value = debug.getlocal(2, index)

        if not name then
            break
        end

        if value == nil then
            value = NIL
        end

        hash[name] = value
    end

    PrintTableGrep( hash )
end

function show(...)
    local n = select('#', ...)
    local tbl = {...}

    for i = 1, n do
        if istable(tbl[i]) then MsgN(tostring(tbl[i])) PrintTableGrep(tbl[i])
        else InternalPrintValue(tbl[i]) MsgN() end
    end
end

-- Hacky way of creating a pretty string from the above code
-- because I don't feel like refactoring the entire thing
local strResult
local toStringMsgF = function(txt)
    table.insert(strResult, txt)
end

local toStringMsgN = function()
    table.insert(strResult, "\n")
end

local toStringMsgC = function(_, txt)
    table.insert(strResult, txt)
end

function showStr(...)
    local oldF, oldN, oldMsgC, oldMsgN = gMsgF, gMsgN, MsgC, MsgN
    gMsgF, gMsgN, MsgC, MsgN = toStringMsgF, toStringMsgN, toStringMsgC, toStringMsgN

    strResult = {}
    show(...)

    gMsgF, gMsgN, MsgC, MsgN = oldF, oldN, oldMsgC, oldMsgN

    return table.concat(strResult, "")
end

--PATH addons/__main/lua/autorun/fspectate.lua:
include("sh_cami.lua")
include("fspectate/sh_init.lua")

if SERVER then
    AddCSLuaFile("sh_cami.lua")
    AddCSLuaFile("fspectate/cl_init.lua")
    AddCSLuaFile("fspectate/sh_init.lua")

    include("fspectate/sv_init.lua")
elseif CLIENT then
    include("fspectate/cl_init.lua")
end

--PATH addons/__main/lua/autorun/kaesar_baby_yoda.lua:
player_manager.AddValidModel( "Baby Yoda", "models/kaesar/baby_yoda/baby_yoda.mdl" )
list.Set( "PlayerOptionsModel",  "Baby Yoda", "models/kaesar/baby_yoda/baby_yoda.mdl" )
player_manager.AddValidHands( "Baby Yoda", "models/kaesar/baby_yoda/c_arms_baby_yoda.mdl", 0, "00000000" )

--PATH addons/igs-core/lua/igs/extensions/evolve.lua:
local ITEM = FindMetaTable("IGSItem")

function ITEM:SetEvolveRank(rank)
	return self:SetInstaller(function(pl)
		evolve.PlayerInfo[pl:UniqueID()]["Rank"] = rank
	end):SetValidator(function(pl)
		return evolve.PlayerInfo[pl:UniqueID()]["Rank"] == rank
	end):SetMeta("ev_rank", rank)
end

--PATH addons/igs-core/lua/igs/extensions/fadmin.lua:
-- Кто-то использует FAdmin, как отдельный аддон к другим гейммодам? О_о

local STORE_ITEM = FindMetaTable("IGSItem")

function STORE_ITEM:SetFAdminGroup(sGroup, iWeight)
	return self:SetInstaller(function(pl)
		FAdmin.Access.PlayerSetGroup(pl, sGroup)
		pl.IGSFAdminWeight = iWeight
	end):SetValidator(function(pl)
		if pl.IGSFAdminWeight then
			return iWeight < pl.IGSFAdminWeight
		end

		return pl:IsUserGroup(sGroup)
	end)
end

--PATH addons/igs-core/lua/igs/interface/vgui/igs_scroll.lua:
local SCROLLBAR = {}
function SCROLLBAR:Init()
	self.parent = self:GetParent()

	self.scrollButton = vgui.Create("Panel", self)
	self.scrollButton.OnMousePressed = function(s, mb)
		if (mb == MOUSE_LEFT and not self:GetParent().ShouldHideScrollbar) then
			local _, my = s:CursorPos()

			s.scrolling = true
			s.mouseOffset = my
		end
	end
	self.scrollButton.OnMouseReleased = function(s, mb)
		if (mb == MOUSE_LEFT) then
			s.scrolling = false
			s.mouseOffset = nil
		end
	end

	self.height = 0
	self.addWidth = 0
end

function SCROLLBAR:Think()
	if (self.scrollButton.scrolling) then
		if (not input.IsMouseDown(MOUSE_LEFT)) then
			self.scrollButton:OnMouseReleased(MOUSE_LEFT)
			return
		end

		local _, my = self.scrollButton:CursorPos()

		local diff = my - self.scrollButton.mouseOffset

		local maxOffset = self.parent:GetCanvas():GetTall() - self.parent:GetTall()

		local perc = (self.scrollButton.y + diff) / (self:GetTall() - self.height)
		self.parent.yOffset = math.Clamp(perc * maxOffset, 0, maxOffset)

		self.parent:InvalidateLayout()
	end

	local preSize = self.addWidth

	local mx, my = self:CursorPos()
	if ((mx > -8 and mx < self:GetWide() + 3 and my > self.scrollButton.y and my < self.scrollButton.y + self.height) or self.scrollButton.scrolling) then
		self.addWidth = math.Clamp(self.addWidth + (FrameTime() * 96), 0, 8)
	else
		self.addWidth = math.Clamp(self.addWidth - (FrameTime() * 96), 0, 8)
	end

	if (preSize ~= self.addWidth) then
		self:InvalidateLayout()
	end
end

function SCROLLBAR:PerformLayout()
	local maxOffset = self.parent:GetCanvas():GetTall() - self.parent:GetTall()

	self:SetSize(2 + self.addWidth, self.parent:GetTall())
	self:SetPos(self.parent:GetWide() - self:GetWide(), 0)

	self.heightRatio = self.parent:GetTall() / self.parent:GetCanvas():GetTall()
	self.height = math.Clamp(math.ceil(self.heightRatio * self.parent:GetTall()), 20, math.huge)

	self.scrollButton:SetSize(self:GetWide(), self.height)
	self.scrollButton:SetPos(0, math.Clamp(self.parent.yOffset / maxOffset, 0, 1) * (self:GetTall() - self.height))
end

function SCROLLBAR:Paint(w, h)
	if (self:GetParent().ShouldHideScrollbar) then return end

	draw.Box(0, self.scrollButton.y, w, self.height, IGS.col.HIGHLIGHTING)
end

function SCROLLBAR:OnMouseWheeled(delta)
	self.parent:OnMouseWheeled(delta)
end

vgui.Register("ui_scrollbar", SCROLLBAR, "Panel")






local SCROLLABLE = {}
function SCROLLABLE:Init()
	self.contentContainer = vgui.Create("Panel", self)
	self.scrollBar = vgui.Create("ui_scrollbar", self)

	self.yOffset = 0
	self.ySpeed = 0
	self.scrollSize = 4
	self.SpaceTop = 0
	self.Padding = 0

	function self.contentContainer:OnChildRemoved(child)
		self:GetParent():PerformLayout()
	end
end

function SCROLLABLE:Reset()
	self:GetCanvas():Clear(true)
	self.yOffset = 0
	self.ySpeed = 0
	self.scrollSize = 1

	self:PerformLayout()
end

function SCROLLABLE:AddItem(child)
	child:SetParent(self:GetCanvas())
	self:PerformLayout()
	return child
end

function SCROLLABLE:SetSpacing(i)
	self.SpaceTop = i
end

function SCROLLABLE:SetPadding(i)
	self.Padding = i
end

function SCROLLABLE:GetCanvas()
	return self.contentContainer
end

function SCROLLABLE:SetScrollSize(int)
	self.scrollSize = int
end

function SCROLLABLE:ScrollTo(y)
	self.yOffset = y

	self:InvalidateLayout()
end

function SCROLLABLE:OnMouseWheeled(delta)
	if ((delta > 0 and self.ySpeed < 0) or (delta < 0 and self.ySpeed > 0)) then
		self.ySpeed = 0
	else
		self.ySpeed = self.ySpeed + (delta * self.scrollSize)
	end

	self:PerformLayout()
end

function SCROLLABLE:SetOffset(offSet)
	local maxOffset = (self:GetCanvas():GetTall() - self:GetTall())
	if (maxOffset < 0) then maxOffset = 0 end

	self.yOffset = math.Clamp(offSet, 0, maxOffset)

	self:PerformLayout()

	if (self.yOffset == 0 or self.yOffset == maxOffset) then return true end
end

function SCROLLABLE:Think()
	if (self.ySpeed ~= 0) then
		if (self:SetOffset(self.yOffset - self.ySpeed)) then
			self.ySpeed = 0
		else
			if (self.ySpeed < 0) then
				self.ySpeed = math.Clamp(self.ySpeed + (FrameTime() * self.scrollSize * 4), self.ySpeed, 0)
			else
				self.ySpeed = math.Clamp(self.ySpeed - (FrameTime() * self.scrollSize * 4), 0, self.ySpeed)
			end
		end
	end
end

function SCROLLABLE:PerformLayout()
	local canvas = self:GetCanvas()

	if (canvas:GetWide() ~= self:GetWide()) then
		canvas:SetWide(self:GetWide())
	end

	local y = 0
	local lastChild
	for k, v in ipairs(canvas:GetChildren()) do
		local childY = y + self.SpaceTop
		if (v.x ~= self.Padding or v.y ~= childY) then
			v:SetPos(math.max(0, self.Padding), y + self.SpaceTop)
		end
		if (v:GetWide() ~= self:GetWide() - self.Padding * 2) then
			v:SetWide(math.min(self:GetWide(), self:GetWide() - self.Padding * 2))
		end

		y = v.y + v:GetTall() + self.SpaceTop + self.Padding
		lastChild = v
	end
	y = lastChild and lastChild.y + lastChild:GetTall() or y
	if (canvas:GetTall() ~= y) then
		canvas:SetTall(y)
	end

	if (canvas:GetTall() <= self:GetTall() and self.scrollBar:IsVisible()) then
		canvas:SetTall(self:GetTall())

		self.scrollBar:SetVisible(false)
	elseif (canvas:GetTall() > self:GetTall() and not self.scrollBar:IsVisible()) then
		self.scrollBar:SetVisible(true)
	end

	local maxOffset = self:GetCanvas():GetTall() - self:GetTall()

	if (self.yOffset > maxOffset) then
		self.yOffset = maxOffset
	end

	if (self.yOffset < 0) then
		self.yOffset = 0
	end

	if (canvas.x ~= 0 or canvas.y ~= -self.yOffset) then
		canvas:SetPos(0, -self.yOffset)
		self.scrollBar:InvalidateLayout()
	end
end

function SCROLLABLE:IsAtMaxOffset()
	local maxOffset = math.Clamp(self:GetCanvas():GetTall() - self:GetTall(), 0, math.huge)
	return self.yOffset == maxOffset
end

function SCROLLABLE:Paint(w, h)
end

function SCROLLABLE:HideScrollbar(bool)
	self.ShouldHideScrollbar = bool
end

function SCROLLABLE:DockToFrame()
	local p = self:GetParent()
	local x, y = p:GetDockPos()

	self:SetPos(x, y)
	self:SetSize(p:GetWide() - 10, p:GetTall() - (y + 5))
end

vgui.Register("igs_scroll", SCROLLABLE, "Panel")

--PATH addons/igs-core/lua/igs/interface/vgui/igs_tabbar.lua:
local PANEL = {}

local barTall = 50
local btnWide = 70

function PANEL:Init()
	self.activity = uigs.Create("igs_multipanel",self)

	self.tabBar = uigs.Create("Panel",self)
	self.tabBar:SetTall(barTall)
	self.tabBar.Paint = function(_, w, h)
		surface.SetDrawColor(IGS.col.TAB_BAR)
		surface.DrawRect(0,0,w,h) -- bg

		surface.SetDrawColor(IGS.col.HARD_LINE)
		surface.DrawLine(0,0,w,0) -- upper line
	end

	self.btnsPan = uigs.Create("DIconLayout", self.tabBar)
	self.btnsPan.Paint = function() end

	self.Buttons = {}
end

function PANEL:SetActiveTab(num)
	for i,btn in ipairs(self.Buttons) do
		btn.Active = num == i -- для подсветки
	end

	self.activity:SetActivePanel(num)
end

function PANEL:GetActiveTab()
	return self.activity:GetActivePanel()
end

function PANEL:AddTab(sTitle,panel,sIcon,bActive)
	local ID = self.activity:AddPanel(panel,bActive)

	local button = uigs.Create("DButton", function(btn)
		btn:SetSize(btnWide, 50)
		btn:SetText("")

		btn:SetFont("igs.24")

		btn.DoClick = function(s)
			self:SetActiveTab(s.ID)
		end

		--[[-------------------------------------------------------------------------
			TODO Сделать отрисовку скина через скин хук
			чтобы можно было юзать компонент не только в IGS без порчи дизайна
			В bar.Paint тоже
		---------------------------------------------------------------------------]]
		btn.mat=Material(sIcon)
		btn.Paint = function(s,w,h)
			if s.Active then
				surface.SetDrawColor(color_white)
			else
				surface.SetDrawColor(Color(244,244,244))
			end

			if sIcon then
				surface.SetMaterial( s.mat )
				surface.DrawTexturedRect(w * 0.5 - 32 * 0.5,3,32,32)
			end

			if sTitle then
				surface.SetTextColor(24,24,24)
				surface.SetFont("igs.15")

				local tw = surface.GetTextSize(sTitle)
				surface.SetTextPos(w * 0.5 - tw * 0.5,32 + 3)

				surface.DrawText( sTitle )
			end
		end

		btn.ID     = ID
		btn.Tab    = panel
		btn.Active = bActive
	end)

	function button:Name()
		return sTitle
	end

	self.btnsPan:Add(button)
	table.insert(self.Buttons, button)

	-- self:PerformLayout()
	self.btnsPan:SetSize(#self.Buttons * btnWide,barTall)
	self.btnsPan:SetPos((self:GetWide() - self.btnsPan:GetWide()) * 0.5)


	return button
end

function PANEL:PerformLayout()
	self.tabBar:SetWide(self:GetWide())
	self.tabBar:SetPos(0,self:GetTall() - self.tabBar:GetTall())

	self.activity:SetSize(self.tabBar:GetWide(),self:GetTall() - barTall)
end

function PANEL:Paint(w,h)
	draw.RoundedBox(0,0,0,w,h,IGS.col.ACTIVITY_BG)
end

vgui.Register("igs_tabbar", PANEL, "Panel")
-- IGS.UI()

--PATH addons/igs-core/lua/igs/interface/vgui/igs_wmat.lua:
--[[-------------------------------------------------------------------------
	Запрещено использовать DOCK.
	Размер должен быть указан единоразово и четко

	:SetURL указывать ПОСЛЕ :SetSize
---------------------------------------------------------------------------]]
local PANEL = {}


function PANEL:GetTexture()
	return texture.Get(self.url)
end

function PANEL:GetURL()
	return self.url
end

function PANEL:RenderTexture()
	self.Rendering = true

	-- print("Render",self:GetURL())
	-- print("Size",self:GetSize())

	texture.Delete(self:GetURL())
	texture.Create(self:GetURL())
		:SetSize(self:GetSize())
		:SetFormat(self:GetURL():sub(-3) == "jpg" and "jpg" or "png")
		:Download(self:GetURL(), function()
			if not IsValid(self) then return end

			self.Rendering 	= false
			self.LastURL 	= self:GetURL()
		end, function()
			if not IsValid(self) then return end

			self.Rendering = false
		end)
end

function PANEL:Paint(w,h)
	if (not self:GetTexture() and not self.Rendering) or (self:GetURL() ~= self.LastURL and not self.Rendering) then
		self:RenderTexture()

	elseif self:GetTexture() then
		surface.SetDrawColor(IGS.col.ICON)
		surface.SetMaterial( self:GetTexture() )
		surface.DrawTexturedRect(0,0,w,h)
	end
end

function PANEL:SetURL(sUrl)
	self.url = sUrl or IGS.C.DefaultIcon
end


vgui.Register("igs_wmat",PANEL,"Panel")
-- IGS.UI()

--PATH addons/igs-core/lua/igs/modules/inv_log/_main.lua:
IGS.sv("core_sv.lua")
IGS.sv("integrator_sv.lua")
IGS.cl("core_cl.lua")
IGS.cl("interface_cl.lua")

--PATH addons/lvs_base-main/lua/lvs_framework/autorun/lvs_bulletsystem.lua:
local LVS = LVS

LVS._ActiveBullets = {}

function LVS:RemoveBullet( index )
	LVS._ActiveBullets[ index ] = nil
end

function LVS:GetBullet( index )
	if not LVS._ActiveBullets then return end

	return LVS._ActiveBullets[ index ]
end

local NewBullet = {}
NewBullet.__index = NewBullet 

function NewBullet:SetPos( pos )
	self.curpos = pos
end

function NewBullet:GetBulletIndex()
	return self.bulletindex
end

function NewBullet:Remove()
	local index = self.bulletindex

	if SERVER then
		-- prevents ghost bullets if the client fails to detect the hit
		net.Start( "lvs_remove_bullet", true )
			net.WriteInt( index, 13 )
		net.SendPVS( self:GetPos() )
	end

	LVS:RemoveBullet( index )
end

function NewBullet:GetPos()
	if not self.curpos then return self.Src end

	return self.curpos
end

function NewBullet:SetGravity( new )
	self.Gravity = new
end

function NewBullet:GetGravity()
	return self.Gravity or vector_origin
end

function NewBullet:GetDir()
	return self.Dir or vector_origin
end

function NewBullet:SetDir( newdir )
	self.Dir = newdir
end

function NewBullet:GetTimeAlive()
	return CurTime() - self.StartTime
end

function NewBullet:GetSpawnTime()
	if SERVER then
		return self.StartTime
	else
		return math.min( self.StartTimeCL, CurTime() ) -- time when the bullet is received on client
	end
end

function NewBullet:GetLength()
	return math.min((CurTime() - self:GetSpawnTime()) * 14,1)
end

function NewBullet:HandleWaterImpact( traceStart, traceEnd, Filter )
	if self.HasHitWater then return end

	local traceWater = util.TraceLine( {
		start = traceStart,
		endpos = traceEnd,
		filter = Filter,
		mask = MASK_WATER,
	} )

	if not traceWater.Hit then return end

	self.HasHitWater = true

	local effectdata = EffectData()
	effectdata:SetOrigin( traceWater.HitPos )
	effectdata:SetScale( 10 + self.HullSize * 0.5 )
	effectdata:SetFlags( 2 )
	util.Effect( "WaterSplash", effectdata, true, true )
end

function NewBullet:HandleFlybySound( EarPos )
	if self.Muted or not LVS.EnableBulletNearmiss then return end

	local BulletPos = self:GetPos()

	local EarDist = (EarPos - BulletPos):LengthSqr()

	if self.OldEarDist and self.OldEarDist < EarDist then

		if EarDist < 250000 then
			local effectdata = EffectData()
			effectdata:SetOrigin( EarPos + (BulletPos - EarPos):GetNormalized() * 20 )
			effectdata:SetFlags( 2 )
			util.Effect( "TracerSound", effectdata )
		end

		self.Muted = true
	end

	self.OldEarDist = EarDist
end

function NewBullet:DoBulletFlight( TimeAlive )

	local StartPos = self.Src
	local StartDirection = self.StartDir

	local Velocity = self.Velocity

	local PosOffset

	-- startpos, direction and curtime of creation is networked to client. 
	-- the bullet position is simulated by doing startpos + dir * time * velocity
	if self.EnableBallistics then
		local PosTheoretical = StartDirection * TimeAlive * Velocity

		PosOffset = PosTheoretical + self:GetGravity() * (TimeAlive ^ 2)

		self:SetDir( (StartPos + PosOffset - StartPos):GetNormalized() )
	else
		PosOffset = self.Dir * TimeAlive * Velocity
	end

	if SERVER then
		self:SetPos( StartPos + PosOffset )
	else

		-- "parent" the bullet to the vehicle for a very short time on client. This will give the illusion of the bullet not lagging behind even tho it is fired later on client
		if IsValid( self.Entity ) and self.SrcEntity then
			local mul = self:GetLength()
			local inv = 1 - mul

			self:SetPos( StartPos * mul + self.Entity:LocalToWorld( self.SrcEntity ) * inv + PosOffset )

			return
		end

		-- if no parent detected, run same code as server
		self:SetPos( StartPos + PosOffset )
	end
end

function NewBullet:OnCollide( trace )
	if CLIENT then return end

	if trace.Entity == self.LastDamageTarget then return end

	local Attacker = (IsValid( self.Attacker ) and self.Attacker) or (IsValid( self.Entity ) and self.Entity) or game.GetWorld()
	local Inflictor = (IsValid( self.Entity ) and self.Entity) or (IsValid( self.Attacker ) and self.Attacker) or game.GetWorld()

	local dmginfo = DamageInfo()
	dmginfo:SetDamage( self.Damage )
	dmginfo:SetAttacker( Attacker )
	dmginfo:SetInflictor( Inflictor )
	dmginfo:SetDamageType( DMG_AIRBOAT )
	dmginfo:SetDamagePosition( trace.HitPos )

	if self.Force1km then
		local Mul = math.min( (self.Src - trace.HitPos):Length() / 39370, 1 )
		local invMul = math.max( 1 - Mul, 0 )

		dmginfo:SetDamageForce( self.Dir * (self.Force * invMul + self.Force1km * Mul) )
	else
		dmginfo:SetDamageForce( self.Dir * self.Force )
	end

	if self.Callback then
		self.Callback( Attacker, trace, dmginfo )
	end

	if trace.Entity:GetClass() == "func_breakable_surf" then
		-- this will cause the entire thing to just fall apart
		dmginfo:SetDamageType( DMG_BLAST )
	end

	trace.Entity:DispatchTraceAttack( dmginfo, trace )

	self.LastDamageTarget = trace.Entity
end

function NewBullet:DoSplashDamage( trace )
	if not self.SplashDamage or not self.SplashDamageRadius then return false end

	if self.SplashDamageEffect ~= "" then
		local effectdata = EffectData()
		effectdata:SetOrigin( trace.HitPos )
		effectdata:SetNormal( trace.HitWorld and trace.HitNormal or self.Dir )
		effectdata:SetMagnitude( self.SplashDamageRadius / 250 )
		util.Effect( self.SplashDamageEffect, effectdata )
	end

	local Attacker = (IsValid( self.Attacker ) and self.Attacker) or (IsValid( self.Entity ) and self.Entity) or game.GetWorld()
	local Inflictor = (IsValid( self.Entity ) and self.Entity) or (IsValid( self.Attacker ) and self.Attacker) or game.GetWorld()

	LVS:BlastDamage( trace.HitPos, self.Dir, Attacker, Inflictor, self.SplashDamage, self.SplashDamageType, self.SplashDamageRadius, self.SplashDamageForce )

	self.SplashDamage = nil
	self.SplashDamageRadius = nil
	self.SplashDamageEffect = nil

	return true
end

function NewBullet:HandleCollision( traceStart, traceEnd, Filter )
	local TraceMask = self.HullSize <= 1 and MASK_SHOT_PORTAL or MASK_SHOT_HULL

	local traceLine
	local traceHull

	if self.HullTraceResult then
		traceHull = self.HullTraceResult
	else
		traceLine = util.TraceLine( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mask = TraceMask
		} )

		local trace = util.TraceHull( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mins = self.Mins,
			maxs = self.Maxs,
			mask = TraceMask,
			ignoreworld = true
		} )

		if traceLine.Entity == trace.Entity and trace.Hit and traceLine.Hit then
			trace = traceLine
		end

		if trace.Hit then
			self.HullTraceResult = trace
			traceHull = trace

			self:OnCollide( trace )

			if self:DoSplashDamage( trace ) then
				self:Remove()
			end
		else
			traceHull = { Hit = false }
		end
	end

	if not traceLine then
		traceLine = util.TraceLine( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mask = TraceMask
		} )
	end

	if not traceLine.Hit then
		return
	end

	self:OnCollide( traceLine )

	self:DoSplashDamage( traceLine )

	self:Remove()

	if SERVER then return end

	if not traceLine.HitSky then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceLine.HitPos )
		effectdata:SetEntity( traceLine.Entity )
		effectdata:SetStart( traceStart )
		effectdata:SetNormal( traceLine.HitNormal )
		effectdata:SetSurfaceProp( traceLine.SurfaceProps )
		util.Effect( "Impact", effectdata )
	end
end

local function GetEarPos()
	if SERVER then return vector_origin end

	local EarPos

	local ply = LocalPlayer()
	local ViewEnt = ply:GetViewEntity()

	if ViewEnt == ply then
		if IsValid( ply:lvsGetVehicle() ) then
			EarPos = ply:lvsGetView()
		else
			EarPos = ply:GetShootPos()
		end
	else
		EarPos = ViewEnt:GetPos()
	end

	return EarPos
end

local function HandleBullets()
	local T = CurTime()
	local FT = FrameTime()

	local EarPos = GetEarPos()

	for id, bullet in pairs( LVS._ActiveBullets ) do
		if bullet:GetSpawnTime() + 5 < T then -- destroy all bullets older than 5 seconds
			bullet:Remove()

			continue
		end

		local TimeAlive = bullet:GetTimeAlive()

		if TimeAlive < 0 then continue end -- CurTime() is predicted, this can be a negative number in some cases.

		local Filter = bullet.Filter

		local traceStart = bullet:GetPos()
			bullet:DoBulletFlight( TimeAlive )
		local traceEnd = bullet:GetPos()

		if CLIENT then
			--debugoverlay.Line( traceStart, traceEnd, Color( 255, 255, 255 ), true )

			-- bullet flyby sounds
			bullet:HandleFlybySound( EarPos )

			-- bullet water impact effects
			bullet:HandleWaterImpact( traceStart, traceEnd, Filter )
		end

		bullet:HandleCollision( traceStart, traceEnd, Filter )
	end
end

local vector_one = Vector(1,1,1)

if SERVER then
	util.AddNetworkString( "lvs_fire_bullet" )
	util.AddNetworkString( "lvs_remove_bullet" )

	hook.Add( "Tick", "!!!!lvs_bullet_handler", function( ply, ent ) -- from what i understand, think can "skip" on lag, while tick still simulates all steps
		HandleBullets()
	end )

	local Index = 0
	local MaxIndex = 4094 -- this is the util.effect limit

	function LVS:FireBullet( data )

		Index = Index + 1

		if Index > MaxIndex then
			Index = 1
		end

		LVS._ActiveBullets[ Index ] = nil

		local bullet = {}

		setmetatable( bullet, NewBullet )

		bullet.TracerName = data.TracerName or "lvs_tracer_orange"
		bullet.Src = data.Src or vector_origin
		bullet.Dir = (data.Dir + VectorRand() * (data.Spread or vector_origin) * 0.5):GetNormalized()
		bullet.StartDir = bullet.Dir
		bullet.Force = data.Force or 10

		if data.Force1km then
			bullet.Force1km = data.Force1km
		end

		bullet.HullSize = data.HullSize or 5
		bullet.Mins = -vector_one * bullet.HullSize
		bullet.Maxs = vector_one * bullet.HullSize
		bullet.Velocity = data.Velocity or 2500
		bullet.Attacker = IsValid( data.Attacker ) and data.Attacker or (IsValid( data.Entity ) and data.Entity or game.GetWorld())
		bullet.Damage = data.Damage or 10
		bullet.Entity = data.Entity
		if IsValid( bullet.Entity ) and bullet.Entity.GetCrosshairFilterEnts then
			bullet.Filter = bullet.Entity:GetCrosshairFilterEnts()
		else
			bullet.Filter = bullet.Entity
		end
		bullet.SrcEntity = data.SrcEntity or vector_origin
		bullet.Callback = data.Callback
		bullet.SplashDamage = data.SplashDamage
		bullet.SplashDamageForce = data.SplashDamageForce or 500
		bullet.SplashDamageRadius = data.SplashDamageRadius
		bullet.SplashDamageEffect = data.SplashDamageEffect or "lvs_bullet_impact"
		bullet.SplashDamageType = data.SplashDamageType or DMG_SONIC
		bullet.StartTime = CurTime()
		bullet.EnableBallistics = data.EnableBallistics == true

		if bullet.EnableBallistics then
			bullet:SetGravity( physenv.GetGravity() )
		end

		if InfMap then
			for _, ply in ipairs( player.GetAll() ) do
				local NewPos = Vector( bullet.Src.x, bullet.Src.y, bullet.Src.z ) - InfMap.unlocalize_vector( Vector(), ply.CHUNK_OFFSET )

				net.Start( "lvs_fire_bullet", true )
					net.WriteInt( Index, 13 )
					net.WriteString( bullet.TracerName )
					net.WriteFloat( NewPos.x )
					net.WriteFloat( NewPos.y )
					net.WriteFloat( NewPos.z )
					net.WriteAngle( bullet.Dir:Angle() )
					net.WriteFloat( bullet.StartTime )
					net.WriteFloat( bullet.HullSize )
					net.WriteEntity( bullet.Entity )
					net.WriteFloat( bullet.SrcEntity.x )
					net.WriteFloat( bullet.SrcEntity.y )
					net.WriteFloat( bullet.SrcEntity.z )
					net.WriteFloat( bullet.Velocity )
					net.WriteBool( bullet.EnableBallistics )
				net.Send( ply )
			end
		else
			net.Start( "lvs_fire_bullet", true )
				net.WriteInt( Index, 13 )
				net.WriteString( bullet.TracerName )
				net.WriteFloat( bullet.Src.x )
				net.WriteFloat( bullet.Src.y )
				net.WriteFloat( bullet.Src.z )
				net.WriteAngle( bullet.Dir:Angle() )
				net.WriteFloat( bullet.StartTime )
				net.WriteFloat( bullet.HullSize )
				net.WriteEntity( bullet.Entity )
				net.WriteFloat( bullet.SrcEntity.x )
				net.WriteFloat( bullet.SrcEntity.y )
				net.WriteFloat( bullet.SrcEntity.z )
				net.WriteFloat( bullet.Velocity )
				net.WriteBool( bullet.EnableBallistics )
			net.SendPVS( bullet.Src )
		end

		bullet.bulletindex = Index
		LVS._ActiveBullets[ Index ] = bullet
	end
else
	net.Receive( "lvs_remove_bullet", function( length )
		LVS:RemoveBullet( net.ReadInt( 13 ) )
	end)

	net.Receive( "lvs_fire_bullet", function( length )
		local Index = net.ReadInt( 13 )

		LVS._ActiveBullets[ Index ] = nil

		local bullet = {}

		setmetatable( bullet, NewBullet )

		bullet.TracerName = net.ReadString()
		bullet.Src = Vector(net.ReadFloat(),net.ReadFloat(),net.ReadFloat())
		bullet.Dir = net.ReadAngle():Forward()
		bullet.StartDir = bullet.Dir
		bullet.StartTime = net.ReadFloat()
		bullet.HullSize = net.ReadFloat()
		bullet.Mins = -vector_one * bullet.HullSize
		bullet.Maxs = vector_one * bullet.HullSize
		bullet.Entity = net.ReadEntity()
		if IsValid( bullet.Entity ) and bullet.Entity.GetCrosshairFilterEnts then
			bullet.Filter = bullet.Entity:GetCrosshairFilterEnts()
		else
			bullet.Filter = bullet.Entity
		end
		bullet.SrcEntity = Vector(net.ReadFloat(),net.ReadFloat(),net.ReadFloat())

		if bullet.SrcEntity == vector_origin then
			bullet.SrcEntity = nil
		end

		bullet.Velocity = net.ReadFloat()

		bullet.EnableBallistics = net.ReadBool()

		if bullet.EnableBallistics then
			bullet:SetGravity( physenv.GetGravity() )
		end

		bullet.StartTimeCL = CurTime() + RealFrameTime()

		local ply = LocalPlayer()

		if IsValid( ply ) then
			bullet.Muted = bullet.Entity == ply:lvsGetVehicle() or bullet.Entity:GetOwner() == ply
		end

		bullet.bulletindex = Index
		LVS._ActiveBullets[ Index ] = bullet

		local effectdata = EffectData()
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( bullet.Dir )
		effectdata:SetMaterialIndex( Index )
		util.Effect( bullet.TracerName, effectdata )
	end )

	hook.Add( "Think", "!!!!_lvs_bullet_think_cl", function()
		HandleBullets()
	end )
end
--PATH addons/lvs_base-main/lua/lvs_framework/autorun/lvs_player.lua:
local meta = FindMetaTable( "Player" )

function meta:lvsGetAITeam()
	return self:GetNWInt( "lvsAITeam", LVS.PlayerDefaultTeam )
end

function meta:lvsGetVehicle()
	local Pod = self:GetVehicle()

	if not IsValid( Pod ) then return NULL end

	if Pod.LVSchecked then

		return Pod.LVSBaseEnt

	else
		local Parent = Pod:GetParent()
		
		if not IsValid( Parent ) then return NULL end

		if not Parent.LVS then
			Pod.LVSchecked = LVS.MapDoneLoading
			Pod.LVSBaseEnt = NULL

			return NULL
		end

		Pod.LVSchecked = LVS.MapDoneLoading
		Pod.LVSBaseEnt = Parent

		return Parent
	end
end

function meta:lvsGetWeaponHandler()
	local Pod = self:GetVehicle()

	if not IsValid( Pod ) then return NULL end

	local weapon = Pod:lvsGetWeapon()

	if IsValid( weapon ) then
		return weapon
	else
		local veh = self:lvsGetVehicle()

		if not IsValid( veh ) then return NULL end

		if veh:GetDriver() == self then
			return veh
		else
			return NULL
		end
	end
end

function meta:lvsGetControls()
	if not istable( self.LVS_BINDS ) then
		self:lvsBuildControls()
	end
	
	return self.LVS_BINDS
end

function meta:lvsMouseAim()
	if LVS:IsDirectInputForced() then
		return false
	end

	return self._lvsMouseAim
end

function meta:lvsMouseSensitivity()
	local X = self._lvsMouseX or 1
	local Y = self._lvsMouseY or 1
	local delta = self._lvsReturnDelta or 1

	return X, Y, delta
end

function meta:lvsBuildControls()
	if istable( self.LVS_BINDS ) then
		table.Empty( self.LVS_BINDS )
	end

	if SERVER then
		self._lvsMouseAim = self:GetInfoNum( "lvs_mouseaim", 0 ) == 1

		self.LVS_BINDS = table.Copy( LVS.KEYS_CATEGORIES )

		for _,v in pairs( LVS.KEYS_REGISTERED ) do
			if v.id == "~SKIP~" then continue end

			local ButtonID = self:GetInfoNum( v.cmd, 0 )

			if not self.LVS_BINDS[v.category][ ButtonID ] then
				self.LVS_BINDS[v.category][ ButtonID ] = {}
			end

			table.insert( self.LVS_BINDS[v.category][ ButtonID ], v.id )
		end

		net.Start( "lvs_buildcontrols" )
		net.Send( self )

		self._lvsMouseX = self:GetInfoNum( "lvs_sensitivity_x", 1 )
		self._lvsMouseY = self:GetInfoNum( "lvs_sensitivity_y", 1 )
		self._lvsReturnDelta = self:GetInfoNum( "lvs_return_delta", 1 )
	else
		self._lvsMouseAim = GetConVar( "lvs_mouseaim" ):GetInt() == 1
		self._lvsMouseX = GetConVar(  "lvs_sensitivity_x" ):GetFloat()
		self._lvsMouseY = GetConVar( "lvs_sensitivity_y" ):GetFloat()
		self._lvsReturnDelta = GetConVar( "lvs_return_delta" ):GetFloat()

		self.LVS_BINDS = {}

		local KeySpawnMenu = input.LookupBinding( "+menu" )
		if isstring( KeySpawnMenu ) then
			KeySpawnMenu = input.GetKeyCode( KeySpawnMenu )
		end

		local KeyContextMenu = input.LookupBinding( "+menu_context" )
		if isstring( KeyContextMenu ) then
			KeyContextMenu = input.GetKeyCode( KeyContextMenu )
		end

		self._lvsDisableSpawnMenu = nil
		self._lvsDisableContextMenu = nil

		for _,v in pairs( LVS.KEYS_REGISTERED ) do
			if v.id == "~SKIP~" then continue end

			local KeyCode = GetConVar( v.cmd ):GetInt()

			self.LVS_BINDS[ v.id ] = KeyCode

			if KeyCode == KeySpawnMenu then
				self._lvsDisableSpawnMenu = true
			end
			if KeyCode == KeyContextMenu then
				self._lvsDisableContextMenu = true
			end
		end
	end
end

local IS_MOUSE_ENUM = {
	[MOUSE_LEFT] = true,
	[MOUSE_RIGHT] = true,
	[MOUSE_MIDDLE] = true,
	[MOUSE_4] = true,
	[MOUSE_5] = true,
	[MOUSE_WHEEL_UP] = true,
	[MOUSE_WHEEL_DOWN] = true,
}

local function GetInput( ply, name )
	if SERVER then
		if not ply._lvsKeyDown then
			ply._lvsKeyDown = {}
		end

		return ply._lvsKeyDown[ name ] == true
	else
		local Key = ply:lvsGetControls()[ name ] or 0

		if IS_MOUSE_ENUM[ Key ] then
			return input.IsMouseDown( Key ) 
		else
			return input.IsKeyDown( Key ) 
		end
	end
end

function meta:lvsKeyDown( name )
	if not self:lvsGetInputEnabled() then return false end

	local Pressed = GetInput( self, name )
	local NewPressed = hook.Run( "LVS.PlayerKeyDown", self, name, Pressed )

	if isbool( NewPressed ) then
		return NewPressed
	else
		return Pressed
	end
end

function meta:lvsGetInputEnabled()
	return (self._lvsKeyDisabler or 0) < CurTime()
end

function meta:lvsSetInputDisabled( disable )
	if CLIENT then
		net.Start( "lvs_buildcontrols" )
			net.WriteBool( disable )
		net.SendToServer()
	end

	if disable then
		self._lvsKeyDisabler = CurTime() + 120
	else
		self._lvsKeyDisabler = CurTime() + 0.25
	end
end

if CLIENT then
	function meta:lvsSetView( view )
		self._lvsViewPos = view.origin or vector_origin
		self._lvsViewAngles = view.angles or angle_zero

		return view
	end

	function meta:lvsGetView()
		local pos = self._lvsViewPos or vector_origin
		local ang = self._lvsViewAngles or angle_zero

		return pos, ang
	end

	net.Receive( "lvs_buildcontrols", function( len )
		local ply = LocalPlayer()
		if not IsValid( ply ) then return end
		ply:lvsBuildControls()
	end )

	local OldVisible = false
	local function KeyBlocker()
		local Visible = gui.IsGameUIVisible() or vgui.CursorVisible()

		if Visible ~= OldVisible then
			OldVisible = Visible

			local ply = LocalPlayer()

			if not IsValid( ply ) then return end

			if Visible then
				ply:lvsSetInputDisabled( true )
			else
				ply:lvsSetInputDisabled( false )
			end
		end
	end

	hook.Add( "LVS.PlayerEnteredVehicle", "!!!!!lvs_keyblocker_enable", function( ply, veh )
		hook.Add("PostDrawHUD", "!!!lvs_keyblocker", KeyBlocker )
	end )

	hook.Add( "LVS.PlayerLeaveVehicle", "!!!!!lvs_keyblocker_disable", function( ply, veh )
		hook.Remove("PostDrawHUD", "!!!lvs_keyblocker" )
	end )

	local players_bonemanip = {}

	local function StartBoneManip( id )
		players_bonemanip[ id ] = true
	end

	local function StopBoneManip( id )
		if not players_bonemanip[ id ] then return end

		players_bonemanip[ id ] = nil

		local ply = Entity( id )

		if not IsValid( ply ) then return end

		local angle_zero = Angle(0,0,0)

		for i = 0, (ply:GetBoneCount() - 1) do
			ply:ManipulateBoneAngles( i, angle_zero )
		end
	end

	net.Receive( "lvs_bonemanip", function( len )
		local entindex = net.ReadInt( 9 )
		local enable = net.ReadBool()

		if enable then
			StartBoneManip( entindex )

			return
		end

		StopBoneManip( entindex )
	end )

	hook.Add( "Think", "!!!!!lvs_player_bonemanip", function()
		for EntID, _ in pairs( players_bonemanip ) do
			local ply = Entity( EntID )

			if not IsValid( ply ) or not ply:IsPlayer() then continue end

			local Pod = ply:GetVehicle()
			local vehicle = ply:lvsGetVehicle()

			if not IsValid( Pod ) or not IsValid( vehicle ) then return end

			local BoneManipulate = vehicle:GetPlayerBoneManipulation( ply, Pod:lvsGetPodIndex() )

			for name, ang in pairs( BoneManipulate ) do
				local bone = ply:LookupBone( name )

				if not bone then continue end

				ply:ManipulateBoneAngles( bone, ang )
			end
		end
	end )

	return
end

util.AddNetworkString( "lvs_buildcontrols" )
util.AddNetworkString( "lvs_bonemanip" )

function meta:lvsStartBoneManip()
	net.Start( "lvs_bonemanip" )
		net.WriteInt( self:EntIndex(), 9 )
		net.WriteBool( true )
	net.Broadcast()
end

function meta:lvsStopBoneManip()
	net.Start( "lvs_bonemanip" )
		net.WriteInt( self:EntIndex(), 9 )
		net.WriteBool( false )
	net.Broadcast()
end

net.Receive( "lvs_buildcontrols", function( len, ply )
	if not IsValid( ply ) then return end

	ply:lvsSetInputDisabled( net.ReadBool() )
end )

function meta:lvsSetInput( name, value )
	if not self._lvsKeyDown then
		self._lvsKeyDown = {}
	end

	self._lvsKeyDown[ name ] = value
end

LVS.TEAMS = {
	[0] = "FRIENDLY TO EVERYONE",
	[1] = "Team 1",
	[2] = "Team 2",
	[3] = "HOSTILE TO EVERYONE",
}

function meta:lvsSetAITeam( nTeam )
	nTeam = nTeam or LVS.PlayerDefaultTeam

	if self:lvsGetAITeam() ~= nTeam then
		self:PrintMessage( HUD_PRINTTALK, "[LVS] Your AI-Team has been updated to: "..(LVS.TEAMS[ nTeam ] or "") )
	end

	self:SetNWInt( "lvsAITeam", nTeam )
end

hook.Add( "PlayerButtonUp", "!!!lvsButtonUp", function( ply, button )
	for _, KeyBind in pairs( ply:lvsGetControls() ) do
		local KeyTBL = KeyBind[ button ]

		if not KeyTBL then continue end

		for _, KeyName in pairs( KeyTBL ) do
			ply:lvsSetInput( KeyName, false )
		end
	end
end )

hook.Add( "PlayerButtonDown", "!!!lvsButtonDown", function( ply, button )
	if not ply:lvsGetInputEnabled() then return end

	local vehicle = ply:lvsGetVehicle()
	local vehValid = IsValid( vehicle )

	for _, KeyBind in pairs( ply:lvsGetControls() ) do
		local KeyTBL = KeyBind[ button ]

		if not KeyTBL then continue end

		for _, KeyName in pairs( KeyTBL ) do
			ply:lvsSetInput( KeyName, true )

			if not vehValid then continue end

			if string.StartWith( KeyName, "~SELECT~" ) then
				local exp_string = string.Explode( "#", KeyName )
				local base = ply:lvsGetWeaponHandler()

				if exp_string[2] and IsValid( base ) then
					base:SelectWeapon( tonumber( exp_string[2] ) )
				end
			end

			if KeyName == "EXIT" then
				if vehicle:GetDriver() == ply and vehicle:GetlvsLockedStatus() then vehicle:UnLock() end

				if vehicle:GetlvsLockedStatus() then continue end

				ply:ExitVehicle()
			end
		end
	end
end )

hook.Add("CanExitVehicle","!!!lvsCanExitVehicle",function(vehicle,ply)
	if IsValid( ply:lvsGetVehicle() ) then return false end
end)

--PATH addons/__main/lua/autorun/lwcars_merg65.lua:
local V = {
			Name = "Mercedes G65 AMG W463", 
			Class = "prop_vehicle_jeep",
			Category = "LW Cars",
			Author = "LoneWolfie",
			Information = "Driveable G65 by LoneWolfie",
			Model = "models/LoneWolfie/mer_g65.mdl",
			VC_Lights = { 			
				{Pos = Vector(33,104,46), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.2, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(31.25,104.9,46), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.2, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(29.4,105.6,46), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.2, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(27.5,106.1,46), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.2, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(25.4,106.6,46), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.2, DynLight = true, BlinkersColor = "230 80 0"},

				{Pos = Vector(-33,104,46), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.2, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(-31.25,104.9,46), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.2, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(-29.4,105.6,46), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.2, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(-27.5,106.1,46), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.2, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(-25.4,106.6,46), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.2, DynLight = true, BlinkersColor = "230 80 0"},	

				{Pos = Vector(33.75,96,61.75), Mat = "sprites/blueflare1.vmt", Alpha = 235, Size = 0.37, DynLight = true, BlinkersColor = "230 80 0"},	
				{Pos = Vector(-33.75,96,61.75), Mat = "sprites/blueflare1.vmt", Alpha = 235, Size = 0.37, DynLight = true, BlinkersColor = "230 80 0"},	

				{Pos = Vector(29.5,104,53.5), Mat = "sprites/blueflare1.vmt", Alpha = 235, Size = 0.65, DynLight = true, NormalColor = "240 240 255"},		
				{Pos = Vector(-29.5,104,53.5), Mat = "sprites/blueflare1.vmt", Alpha = 235, Size = 0.65, DynLight = true, NormalColor = "240 240 255"},	

				{Pos = Vector(27.7,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				{Pos = Vector(29,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				{Pos = Vector(30.3,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				{Pos = Vector(31.6,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				{Pos = Vector(32.9,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},	
				{Pos = Vector(34.2,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				{Pos = Vector(35.5,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				
				{Pos = Vector(-27.7,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				{Pos = Vector(-29,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				{Pos = Vector(-30.3,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				{Pos = Vector(-31.6,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				{Pos = Vector(-32.9,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},	
				{Pos = Vector(-34.2,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				{Pos = Vector(-35.5,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, NormalColor = "255 0 0"},
				
				{Pos = Vector(-30.3,-99.3,44.6), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-31.6,-99.3,44.6), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-32.9,-99.3,44.6), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-30.3,-99.3,41.8), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-31.6,-99.3,41.8), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-32.9,-99.3,41.8), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-27.7,-99.3,44.6), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-27.7,-99.3,41.8), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-26.5,-99.3,44.3), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-26.5,-99.3,42.1), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-26,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-28.8,-99.3,44.4), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-28.8,-99.3,41.9), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},				
			
				{Pos = Vector(30.3,-99.3,44.6), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(31.6,-99.3,44.6), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(32.9,-99.3,44.6), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(30.3,-99.3,41.8), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(31.6,-99.3,41.8), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(32.9,-99.3,41.8), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(27.7,-99.3,44.6), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(27.7,-99.3,41.8), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(26.5,-99.3,44.3), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(26.5,-99.3,42.1), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(26,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(28.8,-99.3,44.4), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(28.8,-99.3,41.9), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.085, DynLight = true, BrakeColor = "255 0 0"},
				
				{Pos = Vector(36.7,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(36.4,-99.3,44.1), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.06, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(36.4,-99.3,44.35), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(35.4,-99.3,44.35), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(34.4,-99.3,44.35), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},	
				{Pos = Vector(36.4,-99.3,42.25), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(35.4,-99.3,42.25), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(34.4,-99.3,42.25), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},	
				{Pos = Vector(36.4,-99.3,42.4), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.06, DynLight = true, BlinkersColor = "230 80 0"},			

				{Pos = Vector(-36.7,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(-36.4,-99.3,44.1), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.06, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(-36.4,-99.3,44.35), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(-35.4,-99.3,44.35), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(-34.4,-99.3,44.35), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},	
				{Pos = Vector(-36.4,-99.3,42.25), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(-35.4,-99.3,42.25), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},
				{Pos = Vector(-34.4,-99.3,42.25), Mat = "sprites/blueflare1.vmt", Alpha = 225, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},	
				{Pos = Vector(-36.4,-99.3,42.4), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.06, DynLight = true, BlinkersColor = "230 80 0"},

				{Pos = Vector(34.4,-99.3,41.5), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},
				{Pos = Vector(35.4,-99.3,41.5), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(36.4,-99.3,41.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(37.25,-99.3,42.25), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(37.55,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(37.3,-99.3,44.05), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(36.55,-99.3,44.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(35.55,-99.3,44.95), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},		
				{Pos = Vector(34.55,-99.3,44.95), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	

				{Pos = Vector(-34.4,-99.3,41.5), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},
				{Pos = Vector(-35.4,-99.3,41.5), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(-36.4,-99.3,41.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(-37.25,-99.3,42.25), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(-37.55,-99.3,43.15), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(-37.3,-99.3,44.05), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(-36.55,-99.3,44.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				{Pos = Vector(-35.55,-99.3,44.95), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},		
				{Pos = Vector(-34.55,-99.3,44.95), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, ReverseColor = "245 245 245"},	
				
				{Pos = Vector(-1,-92.1,91), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-2,-92.1,91), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-3,-92.1,91), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-4,-92.1,91), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(-5,-92.1,91), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, BrakeColor = "255 0 0"},	
				{Pos = Vector(0,-92.1,91), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(1,-92.1,91), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(2,-92.1,91), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(3,-92.1,91), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(4,-92.1,91), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, BrakeColor = "255 0 0"},
				{Pos = Vector(5,-92.1,91), Mat = "sprites/blueflare1.vmt", Alpha = 215, Size = 0.1, DynLight = true, BrakeColor = "255 0 0"},

				{Pos = Vector(49,30.2,72.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},	
				{Pos = Vector(48.9,31,72.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(48.8,31.8,72.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(48.55,32.6,72.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(48.2,33.4,72.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(47.8,34.1,72.8), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},	
				{Pos = Vector(47,34.7,72.85), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(46.2,35.2,72.85), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(45.4,35.7,72.85), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		

				{Pos = Vector(49.1,30.1,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},	
				{Pos = Vector(49,31.0,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(48.85,31.8,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(48.6,32.7,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(48.3,33.6,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(47.8,34.35,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},	
				{Pos = Vector(47,35,71.6), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(46.2,35.5,71.6), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(45.4,36,71.6), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},			

				{Pos = Vector(-49,30.2,72.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},	
				{Pos = Vector(-48.9,31,72.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(-48.8,31.8,72.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(-48.55,32.6,72.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(-48.2,33.4,72.7), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(-47.8,34.1,72.8), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},	
				{Pos = Vector(-47,34.7,72.85), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(-46.2,35.2,72.85), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		
				{Pos = Vector(-45.4,35.7,72.85), Mat = "sprites/blueflare1.vmt", Alpha = 245, Size = 0.08, DynLight = true, BlinkersColor = "230 80 0"},		

				{Pos = Vector(-49.1,30.1,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},	
				{Pos = Vector(-49,31.0,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(-48.85,31.8,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(-48.6,32.7,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(-48.3,33.6,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(-47.8,34.35,71.55), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},	
				{Pos = Vector(-47,35,71.6), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(-46.2,35.5,71.6), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},		
				{Pos = Vector(-45.4,36,71.6), Mat = "sprites/blueflare1.vmt", Alpha = 200, Size = 0.07, DynLight = true, NormalColor = "200 200 255"},	

				{Pos = Vector(29.5,103,53.5), Size = 0.3, GlowSize = 0.4, HeadLightAngle = Angle(-5, 100, 0)},
				{Pos = Vector(-29.5,103,53.5), Size = 0.3, GlowSize = 0.4, HeadLightAngle = Angle(-5, 80, 0)}				
						},
						
			VC_Exhaust_Dissipate = true,
			
			VC_Exhaust = { 
				{Pos = Vector(41,-31,22.5), Ang = Angle(0,45,90), EffectIdle = "Exhaust", EffectStress = "Exhaust"},
				{Pos = Vector(41,-24,22.5), Ang = Angle(0,45,90), EffectIdle = "Exhaust", EffectStress = "Exhaust"},
				{Pos = Vector(-41,-31,22.5), Ang = Angle(0,-45,90), EffectIdle = "Exhaust", EffectStress = "Exhaust"},
				{Pos = Vector(-41,-24,22.5), Ang = Angle(0,-45,90), EffectIdle = "Exhaust", EffectStress = "Exhaust"},
						},
						
			VC_ExtraSeats = { 
				{Pos = Vector(18.1, -10, 48.1), Ang = Angle(0, 0, 0), EnterRange = 80, ExitAng = Angle(0, -90, 0), Model = "models/props_phx/carseat2.mdl", ModelOffset = Vector(0, 0, 0), Hide = true, DoorSounds = true, RadioControl = true},
				{Pos = Vector(25.1, -45, 48.1), Ang = Angle(0, 0, 0), EnterRange = 80, ExitAng = Angle(0, -90, 0), Model = "models/props_phx/carseat2.mdl", ModelOffset = Vector(0, 0, 0), Hide = true, DoorSounds = true, RadioControl = true},
				{Pos = Vector(-25.1, -45, 48.1), Ang = Angle(0, 0, 0), EnterRange = 80, ExitAng = Angle(0, -90, 0), Model = "models/props_phx/carseat2.mdl", ModelOffset = Vector(0, 0, 0), Hide = true, DoorSounds = true, RadioControl = true},
				{Pos = Vector(0, -45, 48.1), Ang = Angle(0, 0, 0), EnterRange = 80, ExitAng = Angle(0, -90, 0), Model = "models/props_phx/carseat2.mdl", ModelOffset = Vector(0, 0, 0), Hide = true, DoorSounds = true, RadioControl = true},
							
							
							},
							
			VC_Horn = {Sound = "vehicles/vc_horn_light.wav", Pitch = 110, Looping = false}, 
								
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/LWCars/mer_g65.txt"
							}
			}
list.Set("Vehicles", "mer_g65", V)
--PATH addons/_mayor_voting_systems/lua/panels/cl_playericon.lua:
--
-- Credits: TEAM GARRY
-- https://github.com/garrynewman/garrysmod/blob/master/garrysmod/lua/vgui/spawnicon.lua
-- Copy of panel with slight changes including inheritance
--

local PANEL = {}

AccessorFunc( PANEL, "m_strModelName", 		"ModelName" )
AccessorFunc( PANEL, "m_iSkin", 			"SkinID" )
AccessorFunc( PANEL, "m_strBodyGroups", 	"BodyGroup" )
AccessorFunc( PANEL, "m_strIconName", 		"IconName" )


--[[---------------------------------------------------------
   Name: Paint
-----------------------------------------------------------]]
function PANEL:Init()

	self:SetText( "" )
	
	self.Icon = vgui.Create( "ModelImage", self )
	self.Icon:SetMouseInputEnabled( false )
	self.Icon:SetKeyboardInputEnabled( false )
	
	self:SetSize( 64, 64 )	
	
	self.m_strBodyGroups = "000000000";

end

function PANEL:DoRightClick()

	local pCanvas = self:GetSelectionCanvas()
	if ( IsValid( pCanvas ) && pCanvas:NumSelectedChildren() > 0 ) then
		return hook.Run( "SpawnlistOpenGenericMenu", pCanvas )
	end

	self:OpenMenu()
end

function PANEL:Paint( w, h )

	if ( !self.Hovered ) then return end
	
	//derma.SkinHook( "Paint", "Shadow", self, w, h )

end

function PANEL:PerformLayout()
	
	self.Icon:StretchToParent( 0, 0, 0, 0 )

end

function PANEL:SetSpawnIcon( name )
	self.m_strIconName = name
	self.Icon:SetSpawnIcon( name )
end

function PANEL:SetBodyGroup( k, v )

	if ( k < 0 ) then return end
	if ( k > 9 ) then return end
	if ( v < 0 ) then return end
	if ( v > 9 ) then return end
	
	self.m_strBodyGroups = self.m_strBodyGroups:SetChar( k+1, v )

end

function PANEL:SetModel( mdl, iSkin, BodyGorups )

	if (!mdl) then debug.Trace() return end

	self:SetModelName( mdl )
	self:SetSkinID( iSkin )
	
	if ( tostring(BodyGorups):len() != 9 ) then
		BodyGorups = "000000000"
	end
	
	self.m_strBodyGroups = BodyGorups;

	self.Icon:SetModel( mdl, iSkin, BodyGorups )
	
	if ( iSkin && iSkin > 0 ) then
		self:SetToolTip( Format( "%s (Skin %i)", mdl, iSkin+1 ) )
	else
		self:SetToolTip( Format( "%s", mdl ) )
	end

end

function PANEL:RebuildSpawnIcon()

	self.Icon:RebuildSpawnIcon()

end

function PANEL:RebuildSpawnIconEx( t )

	self.Icon:RebuildSpawnIconEx( t )

end

-- Icon has been editied, they changed the skin
-- what should we do?
function PANEL:SkinChanged( i )

	-- Change the skin, and change the model
	-- this way we can edit the spawnmenu....
	self:SetSkinID( i )
	self:SetModel( self:GetModelName(), self:GetSkinID(), self:GetBodyGroup() )
	
end

function PANEL:BodyGroupChanged( k, v )

	self:SetBodyGroup( k, v )
	self:SetModel( self:GetModelName(), self:GetSkinID(), self:GetBodyGroup() )
	
end

vgui.Register( "VotingPlayerIcon", PANEL, "DLabel" )
--PATH addons/__main/lua/autorun/mcfly_iowa.lua:
--Add Playermodel
player_manager.AddValidModel( "Iowa", "models/jazzmcfly/kantai/iowa/iowa.mdl" )
player_manager.AddValidHands( "Iowa", "models/jazzmcfly/kantai/iowa/c_arms/iowa.mdl", 0, "00000000" )
--PATH addons/media_player/lua/autorun/includes/modules/spritesheet.lua:
local math = math
local surface = surface
local table = table

_G.spritesheet = {}

local icons = {}

--[[
	Icon format example:
	{
		name 	= "example-icon",  -- icon name
		mat 	= Material( "path/spritesheet.png" ), -- material for spritesheet
		w 		= 32, 	-- icon width
		h 		= 32, 	-- icon height
		xoffset = 64, 	-- x-axis offset relative to the texture (optional)
		yoffset = 128 	-- y-axis offset relative to the texture (optional)
	}
]]

local function registerIcon( icon )
	local name = icon.name
	if not name then
		MsgN( "Icon has no name" )
		return false
	end

	local mat = icon.mat
	if not mat or mat:IsError() then
		MsgN( "Icon '" .. name .. "' uses an invalid material '" .. mat:GetName() .. "'" )
		return false
	end

	-- calculate texture UV min/max coordinates
	local mw, mh = mat:Width(), mat:Height()
	local xoffset, yoffset = icon.xoffset or 0, icon.yoffset or 0
	local umin, vmin = xoffset / mw, yoffset / mh
	local umax, vmax = umin + (icon.w / mw), vmin + (icon.h / mh)

	icon.umin = umin
	icon.umax = umax
	icon.vmin = vmin
	icon.vmax = vmax

	-- remove unneeded properties
	icon.xoffset = nil
	icon.yoffset = nil

	return true
end

---
-- Registers a single or list of icons.
--
function spritesheet.Register( iconTbl )
	iconTbl = table.Copy( iconTbl or {} )

	-- passed in single icon; wrap inside table for iteration
	if #iconTbl == 0 then
		iconTbl = { iconTbl }
	end

	-- register all icons
	for _, icon in ipairs(iconTbl) do
		local valid = registerIcon( icon )
		if valid then
			icons[icon.name] = icon
		end
	end

	return true
end

---
-- Gets the icon's width and height
--
function spritesheet.GetIconSize( name )
	local icon = icons[name]
	if not icon then
		MsgN( "Invalid icon '" .. tostring(name) .. "' passed into spritesheet.GetIconSize!" )
		return
	end

	return icon.w, icon.h
end

function spritesheet.DrawIcon( name, x, y, w, h, color )
	local icon = icons[name]
	if not icon then
		MsgN( "Invalid icon '" .. tostring(name) .. "' passed into spritesheet.DrawIcon!" )
		return
	end

	if color then surface.SetDrawColor(color) end
	surface.SetMaterial(icon.mat)
	surface.DrawTexturedRectUV( x, y, w, h,
		icon.umin, icon.vmin, icon.umax, icon.vmax )
end

--PATH addons/media_player/lua/mediaplayer/cl_init.lua:
if MediaPlayer then
	-- TODO: compare versions?
	if MediaPlayer.__refresh then
		MediaPlayer.__refresh = nil
	else
		return -- MediaPlayer has already been registered
	end
end

include "controls/dmediaplayerhtml.lua"
include "controls/dhtmlcontrols.lua"
include "controls/dmediaplayerrequest.lua"
include "shared.lua"
include "cl_requests.lua"
include "cl_idlescreen.lua"
include "cl_screen.lua"

function MediaPlayer.Volume( volume )

	local cur = MediaPlayer.Cvars.Volume:GetFloat()

	if volume then

		-- Normalize volume
		volume = volume > 1 and volume/100 or volume

		-- Set volume convar
		RunConsoleCommand( "mediaplayer_volume", volume )

		-- Apply volume to all media players
		for _, mp in pairs( MediaPlayer.List ) do
			if mp:IsPlaying() then
				local media = mp:CurrentMedia()
				if media then
					media:Volume( volume )
				end
			end
		end

		hook.Run( MP.EVENTS.VOLUME_CHANGED, volume, cur )

		cur = volume

	end

	return cur

end

local muted = false
local previousVolume
function MediaPlayer.ToggleMute()
	if not muted then
		previousVolume = MediaPlayer.Volume()
	end

	local vol = muted and previousVolume or 0
	MediaPlayer.Volume( vol )
	muted = not muted
end

function MediaPlayer.Resolution( resolution )

	if resolution then
		resolution = math.Clamp( resolution, 16, 4096 )
		RunConsoleCommand( "mediaplayer_resolution", resolution )
	end

	return MediaPlayer.Cvars.Resolution:GetFloat()

end


--[[---------------------------------------------------------
	Utility functions
-----------------------------------------------------------]]

local FullscreenCvar = MediaPlayer.Cvars.Fullscreen

function MediaPlayer.SetBrowserSize( browser, w, h )

	local fullscreen = FullscreenCvar:GetBool()

	if fullscreen then
		w, h = ScrW(), ScrH()
	end

	browser:SetSize( w, h, fullscreen )

end

function MediaPlayer.OpenRequestMenu( mp )

	if ValidPanel(MediaPlayer._RequestMenu) then
		return
	end

	mp = MediaPlayer.GetByObject( mp )

	if not mp then
		Error( "MediaPlayer.OpenRequestMenu: Invalid media player.\n" )
		return
	end

	local req = vgui.Create( "MPRequestFrame" )
	req:SetMediaPlayer( mp )
	req:MakePopup()
	req:Center()

	req.OnClose = function()
		MediaPlayer._RequestMenu = nil
	end

	MediaPlayer._RequestMenu = req

end

function MediaPlayer.MenuRequest( url )

	local menu = MediaPlayer._RequestMenu

	if not ValidPanel(menu) then
		return
	end

	local mp = menu:GetMediaPlayer()

	menu:Close()

	MediaPlayer.Request( mp, url )

end


--[[---------------------------------------------------------
	Fonts
-----------------------------------------------------------]]

local common = {
	-- font		= "Open Sans Condensed",
	-- font		= "Oswald",
	font		= "Clear Sans Medium",
	antialias	= true,
	weight		= 400
}

surface.CreateFont( "MediaTitle", table.Merge(common, { size = 72 }) )
surface.CreateFont( "MediaRequestButton", table.Merge(common, { size = 26 }) )

--PATH addons/media_player/lua/mediaplayer/players/base/sh_snapshot.lua:
function MEDIAPLAYER:GetSnapshot()
	local queue = table.Copy( self:GetMediaQueue() )
	local media = self:GetMedia()

	return {
		media = media,
		currentTime = media and media:CurrentTime(),
		queue = queue,
		queueRepeat = self:GetQueueRepeat(),
		queueShuffle = self:GetQueueShuffle(),
		queueLocked = self:GetQueueLocked()
	}
end

function MEDIAPLAYER:RestoreSnapshot( snapshot )
	self._Queue = {}

	self:SetQueueRepeat( snapshot.queueRepeat )
	self:SetQueueShuffle( snapshot.queueShuffle )
	self:SetQueueLocked( snapshot.queueLocked )

	if snapshot.media then
		-- restore currently playing media from where it left off
		local mediaSnapshot = snapshot.media
		local media = MediaPlayer.GetMediaForUrl( mediaSnapshot.url )
		if media then
			table.Merge( media, mediaSnapshot )
			media:StartTime( RealTime() - snapshot.currentTime )
			self:SetMedia( media )
		end
	else
		self:SetMedia( nil )
	end

	if snapshot.queue then
		-- restore queue
		for _, mediaSnapshot in ipairs( snapshot.queue ) do
			local media = MediaPlayer.GetMediaForUrl( mediaSnapshot.url )
			if media then
				table.Merge( media, mediaSnapshot )
				self:AddMedia( media )
			end
		end

		self:QueueUpdated()
	end
end

--PATH addons/media_player/lua/mediaplayer/players/entity/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_base" )

local pcall = pcall
local print = print
local Angle = Angle
local IsValid = IsValid
local ValidPanel = ValidPanel
local Vector = Vector
local cam = cam
local Start3D = cam.Start3D
local Start3D2D = cam.Start3D2D
local End3D2D = cam.End3D2D
local draw = draw
local math = math
local string = string
local surface = surface

local FullscreenCvar = MediaPlayer.Cvars.Fullscreen

MEDIAPLAYER.Enable3DAudio = true

function MEDIAPLAYER:NetReadUpdate()
	local entIndex = net.ReadUInt(16)
	local ent = Entity(entIndex)
	local mpEnt = self.Entity

	if MediaPlayer.DEBUG then
		print("MEDIAPLAYER.NetReadUpdate[entity]: ", ent, entIndex)
	end

	if ent ~= mpEnt then
		if IsValid(ent) and ent ~= NULL then
			ent:InstallMediaPlayer( self )
		else
			-- Wait until the entity becomes valid
			self._EntIndex = entIndex
		end
	end
end

local RenderScale = 0.1
local InfoScale = 1/17

function MEDIAPLAYER:GetOrientation()
	local ent = self.Entity

	if ent then
		return ent:GetMediaPlayerPosition()
	end

	return nil
end

---
-- Draws the idlescreen; this is drawn when there is no media playing.
--
function MEDIAPLAYER:DrawIdlescreen( w, h )
	local browser = MediaPlayer.GetIdlescreen()

	if ValidPanel(browser) then
		self:DrawHTML( browser, w, h )
	end
end

local BaseInfoHeight = 60

function MEDIAPLAYER:Draw( bDrawingDepth, bDrawingSkybox )

	local ent = self.Entity

	if --bDrawingSkybox or
			FullscreenCvar:GetBool() or -- Don't draw if we're drawing fullscreen
			not IsValid(ent) or
			(ent.IsDormant and ent:IsDormant()) then
		return
	end

	local media = self:GetMedia()
	local w, h, pos, ang = self:GetOrientation()

	-- Render scale
	local rw, rh = w / RenderScale, h / RenderScale

	if IsValid(media) then

		-- Custom media draw function
		if media.Draw then
			Start3D2D( pos, ang, RenderScale )
				media:Draw( rw, rh )
			End3D2D()
		end
		-- TODO: else draw 'not yet implemented' screen?

		-- scale based off of height
		local scale = InfoScale * ( h / BaseInfoHeight )

		-- Media info
		Start3D2D( pos, ang, scale )
			local iw, ih = w / scale, h / scale
			self:DrawMediaInfo( media, iw, ih )
		End3D2D()

	else

		Start3D2D( pos, ang, RenderScale )
			self:DrawIdlescreen( rw, rh )
		End3D2D()

	end

end

function MEDIAPLAYER:SetMedia( media )
	if media then
		-- Set entity on media for 3D audio support and setting proper
		-- browser resolution
		media.Entity = self:GetEntity()
	end

	BaseClass.SetMedia( self, media )
end

---
-- Mouse click intersected with 3D2D screen.
--
function MEDIAPLAYER:OnMousePressed( x, y )
	local media = self:GetMedia()
	if media and media:IsMouseInputEnabled() then
		media:OnMousePressed( x, y )
	end
end

function MEDIAPLAYER:OnMouseWheeled( scrollDelta )
	local media = self:GetMedia()
	if media and media:IsMouseInputEnabled() then
		media:OnMouseWheeled( scrollDelta )
	end
end

--PATH addons/media_player/lua/mediaplayer/services/browser.lua:
DEFINE_BASECLASS( "mp_service_base" )

SERVICE.Name 	= "Browser Base"
SERVICE.Id 		= "browser"
SERVICE.Abstract = true

if CLIENT then

	function SERVICE:GetBrowser()
		return self.Browser
	end

	function SERVICE:OnBrowserReady( browser )
		local resolution = MediaPlayer.Resolution()
		local w = resolution * 16/9
		local h = resolution

		if IsValid(self.Entity) then
			-- normalize resolution to the entity screen size
			local config = self.Entity:GetMediaPlayerConfig()
			local entwidth = config.width or w
			local entheight = config.height or resolution
			w = resolution * (entwidth / entheight)
		end

		MediaPlayer.SetBrowserSize( browser, w, h )

		-- Implement this in a child service
	end

	function SERVICE:SetVolume( volume )
		-- Implement this in a child service
	end

	function SERVICE:Volume( volume )
		local origVolume = volume

		volume = BaseClass.Volume( self, volume )

		if origVolume and ValidPanel( self.Browser ) then
			self:SetVolume( volume )
		end

		return volume
	end

	function SERVICE:Play()

		BaseClass.Play( self )

		if self.Browser and ValidPanel(self.Browser) then
			self:OnBrowserReady( self.Browser )
		else

			self._promise = browserpool.get(function( panel )

				if not panel then
					return
				end

				if self._promise then
					self._promise = nil
				end

				self.Browser = panel
				self:OnBrowserReady( panel )

			end)
		end

	end

	function SERVICE:Stop()
		BaseClass.Stop( self )

		if self._promise then
			self._promise:Cancel('Service has been stopped')
			self._promise = nil
		end

		if self.Browser then
			browserpool.release( self.Browser )
			self.Browser = nil
		end
	end

	local StartHtml = [[
	<!DOCTYPE html>
	<html>
	<head>
		<meta charset="utf-8">
		<title>Media Player</title>
		<style type="text/css">
		html, body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;
		}

		* { box-sizing: border-box }

		body {
			background-color: #282828;
			color: #cecece;
		}
		</style>
	</head>
	<body>
	]]

	local EndHtml = [[
	</body>
	</html>
	]]

	function SERVICE.WrapHTML( html )
		return table.concat({ StartHtml, html, EndHtml })
	end

	local JS_InjectScript = [[
(function () {
	var script = document.createElement('script');
	script.type = 'text/javascript';
	script.src = '%s';
	document.getElementsByTagName('head')[0].appendChild(script);
}());]]

	function SERVICE:InjectScript( uri )
		self.Browser:QueueJavascript( JS_InjectScript:format( uri ) )
	end

	function SERVICE:OnMousePressed( x, y )
		self.Browser:InjectMouseClick( x, y )
	end

	local SCROLL_MULTIPLIER = -80
	function SERVICE:OnMouseWheeled( scrollDelta )
		self.Browser:Scroll( scrollDelta * SCROLL_MULTIPLIER )
	end

	--[[---------------------------------------------------------
		Draw 3D2D
	-----------------------------------------------------------]]

	local ValidPanel = ValidPanel
	local SetDrawColor = surface.SetDrawColor
	local DrawRect = surface.DrawRect
	local DrawHTMLPanel = MediaPlayerUtils.DrawHTMLPanel

	function SERVICE:Draw( w, h )

		if ValidPanel(self.Browser) then
			SetDrawColor( 0, 0, 0, 255 )
			DrawRect( 0, 0, w, h )
			DrawHTMLPanel( self.Browser, w, h )
		end

	end

end

--PATH addons/media_player/lua/mediaplayer/services/youtube/cl_init.lua:
include "shared.lua"

local urllib = url

local htmlBaseUrl = MediaPlayer.GetConfigValue('html.base_url')

DEFINE_BASECLASS( "mp_service_browser" )

-- https://developers.google.com/youtube/player_parameters
-- TODO: add closed caption option according to cvar
SERVICE.VideoUrlFormat = htmlBaseUrl .. "youtube.html"

local JS_SetVolume = "if(window.MediaPlayer) MediaPlayer.setVolume(%s);"
local JS_Seek = "if(window.MediaPlayer) MediaPlayer.seek(%s);"
local JS_Play = "if(window.MediaPlayer) MediaPlayer.play();"
local JS_Pause = "if(window.MediaPlayer) MediaPlayer.pause();"

local function YTSetVolume( self )
	-- if not self.playerId then return end
	local js = JS_SetVolume:format( MediaPlayer.Volume() * 100 )
	if self.Browser then
		self.Browser:RunJavascript(js)
	end
end

local function YTSeek( self, seekTime )
	-- if not self.playerId then return end
	local js = JS_Seek:format( seekTime )
	if self.Browser then
		self.Browser:RunJavascript(js)
	end
end

function SERVICE:SetVolume( volume )
	local js = JS_SetVolume:format( MediaPlayer.Volume() * 100 )
	self.Browser:RunJavascript(js)
end

function SERVICE:OnBrowserReady( browser )

	BaseClass.OnBrowserReady( self, browser )

	-- Resume paused player
	if self._YTPaused then
		self.Browser:RunJavascript( JS_Play )
		self._YTPaused = nil
		return
	end

	local videoId = self:GetYouTubeVideoId()
	local timedParam = self:IsTimed() and '1' or '0'
	local url = self.VideoUrlFormat .. '?v=' .. videoId ..
				'&timed=' .. timedParam

	local curTime = self:CurrentTime()

	-- Add start time to URL if the video didn't just begin
	if self:IsTimed() and curTime > 3 then
		url = url .. "&start=" .. math.Round(curTime)
	end

	browser:OpenURL(url)

end

function SERVICE:Pause()
	BaseClass.Pause( self )

	if ValidPanel(self.Browser) then
		self.Browser:RunJavascript(JS_Pause)
		self._YTPaused = true
	end
end

function SERVICE:Sync()
	local seekTime = self:CurrentTime()
	if self:IsPlaying() and self:IsTimed() and seekTime > 0 then
		YTSeek( self, seekTime )
	end
end

function SERVICE:IsMouseInputEnabled()
	return IsValid( self.Browser )
end

--PATH addons/media_player/lua/mediaplayer/sh_metadata.lua:
--[[---------------------------------------------------------
	Media Player Metadata

	All media metadata is cached in an SQLite table for quick
	lookup and to prevent unnecessary network requests.
-----------------------------------------------------------]]

MediaPlayer.Metadata = {}

---
-- Default metadata table name
-- @type String
--
local TableName = "mediaplayer_metadata"

---
-- SQLite table struct
-- @type String
--
local TableStruct = string.format([[
CREATE TABLE %s (
	id				VARCHAR(48) PRIMARY KEY,
	title			VARCHAR(128),
	duration		INTEGER NOT NULL DEFAULT 0,
	thumbnail		VARCHAR(512),
	extra 			VARCHAR(2048),
	request_count	INTEGER NOT NULL DEFAULT 1,
	last_request	INTEGER NOT NULL DEFAULT 0,
	last_updated	INTEGER NOT NULL DEFAULT 0,
	expired			BOOLEAN NOT NULL DEFAULT 0
)]], TableName)

---
-- Maximum cache age before it expires; currently one week in seconds.
-- @type Number
--
local MaxCacheAge = 604800

---
-- Query the metadata table for the given media object's metadata.
-- If the metadata is older than one week, it is ignored and replaced upon
-- saving.
--
-- @param media		Media service object.
-- @return table	Cached metadata results.
--
function MediaPlayer.Metadata:Query( media )
	local id = media:UniqueID()
	if not id then return end

	local query = ("SELECT * FROM `%s` WHERE id='%s'"):format(TableName, id)

	if MediaPlayer.DEBUG then
		print("MediaPlayer.Metadata.Query")
		print(query)
	end

	local results = sql.QueryRow(query)

	if results then
		local expired = ( tonumber(results.expired) == 1 )

		-- Media metadata has been marked as out-of-date
		if expired then
			return nil
		end

		local lastupdated = tonumber( results.last_updated )
		local timediff = os.time() - lastupdated

		if timediff > MaxCacheAge then

			-- Set metadata entry as expired
			query = "UPDATE `%s` SET expired=1 WHERE id='%s'"
			query = query:format( TableName, id )

			if MediaPlayer.DEBUG then
				print("MediaPlayer.Metadata.Query: Setting entry as expired")
				print(query)
			end

			sql.Query( query )

			return nil

		else
			return results
		end
	elseif results == false then
		ErrorNoHalt("MediaPlayer.Metadata.Query: There was an error executing the SQL query\n")
		print(query)
	end

	return nil
end

---
-- Save or update the given media object into the metadata table.
--
-- @param media		Media service object.
-- @return table	SQL query results.
--
function MediaPlayer.Metadata:Save( media )
	local id = media:UniqueID()
	if not id then return end

	local query = ("SELECT expired FROM `%s` WHERE id='%s'"):format(TableName, id)
	local results = sql.Query(query)

	if istable(results) then -- update

		if MediaPlayer.DEBUG then
			print("MediaPlayer.Metadata.Save Results:")
			PrintTable(results)
		end

		results = results[1]

		local expired = ( tonumber(results.expired) == 1 )

		if expired then

			-- Update possible new metadata
			query = "UPDATE `%s` SET request_count=request_count+1, title=%s, duration=%s, thumbnail=%s, extra=%s, last_request=%s, last_updated=%s, expired=0 WHERE id='%s'"
			query = query:format( TableName,
						sql.SQLStr( media:Title() ),
						media:Duration(),
						sql.SQLStr( media:Thumbnail() ),
						sql.SQLStr( util.TableToJSON(media._metadata.extra or {}) ),
						os.time(),
						os.time(),
						id )

		else

			query = "UPDATE `%s` SET request_count=request_count+1, last_request=%s WHERE id='%s'"
			query = query:format( TableName, os.time(), id )

		end

	else -- insert

		query = string.format( "INSERT INTO `%s` ", TableName ) ..
			"(id,title,duration,thumbnail,extra,last_request,last_updated) VALUES (" ..
			string.format( "'%s',", id ) ..
			string.format( "%s,", sql.SQLStr( media:Title() ) ) ..
			string.format( "%s,", media:Duration() ) ..
			string.format( "%s,", sql.SQLStr( media:Thumbnail() ) ) ..
			string.format( "%s,", sql.SQLStr( util.TableToJSON(media._metadata.extra or {}) ) ) ..
			string.format( "%d,", os.time() ) ..
			string.format( "%d)", os.time() )

	end

	if MediaPlayer.DEBUG then
		print("MediaPlayer.Metadata.Save")
		print(query)
	end

	results = sql.Query(query)

	if results == false then
		ErrorNoHalt("MediaPlayer.Metadata.Save: There was an error executing the SQL query\n")
		print(query)
	end

	return results
end

-- Create the SQLite table if it doesn't exist
if not sql.TableExists(TableName) then
	Msg("MediaPlayer.Metadata: Creating `" .. TableName .. "` table...\n")
	sql.Query(TableStruct)
end

--PATH addons/media_player/lua/mp_menu/playback.lua:
local math = math
local ceil = math.ceil
local clamp = math.Clamp

local surface = surface
local color_white = color_white

local PANEL = {}

PANEL.Height = 72

PANEL.BgColor = Color( 13, 41, 62 )
PANEL.Padding = 12
PANEL.BtnSpacing = 4

-- PANEL.TrackbarProgressColor = Color( 28, 100, 157 )
PANEL.SeekbarHeight = 8

PANEL.TitleMaxWidth = 335

PANEL.KnobSize = 8

function PANEL:Init()

	self.PlayPauseBtn = vgui.Create( "MP.PlayPauseButton", self )

	self.MediaTitle = vgui.Create( "MP.MediaTitle", self )
	self.MediaTitle:SetText( "Very Bad Video That Everyone Hates Included" )

	self.MediaTime = vgui.Create( "MP.MediaTime", self )
	self.MediaTime:SetShowCurrentTime( true )
	self.MediaTime:SetListenForSeekEvents( true )

	self.BtnList = vgui.Create( "DHorizontalList", self )
	self.BtnList:SetSpacing( self.BtnSpacing )

	self.FavBtn = vgui.Create( "MP.FavoriteButton", self )

	hook.Run( MP.EVENTS.UI.SETUP_PLAYBACK_PANEL, self )

	if hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then
		self.SkipBtn = vgui.Create( "MP.SkipButton" )
		self:AddButton( self.SkipBtn )
	end

	self.AddedByLbl = vgui.Create( "MP.AddedBy", self )

	self.Seekbar = vgui.Create( "MP.Seekbar", self )

	self.NextThink = 0

end

function PANEL:AddButton( panel )
	self.BtnList:AddItem( panel )
end

function PANEL:Think()

	local rt = RealTime()

	if rt > self.NextThink then
		-- Perform layout every second for when the media label changes width
		self:InvalidateLayout()
		self.NextThink = rt + 1
	end

end

function PANEL:OnMediaChanged( media )

	self._Media = media

	if media then
		local title = media:Title()
		self.MediaTitle:SetText( title )
		self.MediaTitle:SetToolTip( title )

		self.AddedByLbl:SetPlayer( media:GetOwner(), media:OwnerName(), media:OwnerSteamID() )

		self.AddedByLbl:Show()
		self.FavBtn:Hide()
		self.BtnList:Show()
	else
		self.MediaTitle:SetText( "No media playing" )
		self.MediaTitle:SetTooltip( "" )

		self.AddedByLbl:Hide()
		self.FavBtn:Hide()
		self.BtnList:Hide()
	end

	if media and media:IsTimed() then
		self.MediaTime:SetMedia( media )

		self.Seekbar:SetMedia( media )
		self.Seekbar:Show()
	else
		self.MediaTime:SetMedia( nil )
		self.MediaTime:Hide()

		self.Seekbar:SetMedia( nil )
		self.Seekbar:Hide()
	end

	-- apply media for all buttons
	for _, btn in pairs( self.BtnList:GetItems() ) do
		if ValidPanel(btn) and isfunction(btn.SetMedia) then
			btn:SetMedia( media )
		end
	end

	self:InvalidateLayout()

end

function PANEL:OnPlayerStateChanged( playerState )

	self.PlayPauseBtn:SetPlayerState( playerState )

end

function PANEL:Paint( w, h )

	surface.SetDrawColor( self.BgColor )
	surface.DrawRect( 0, 0, w, h - self.SeekbarHeight * 0.5 )

end

function PANEL:PerformLayout()

	local w, h = self:GetSize()

	self:SetTall( self.Height )

	self.PlayPauseBtn:CenterVertical()
	self.PlayPauseBtn:AlignLeft( self.Padding )

	self.MediaTitle:SizeToContents()
	self.MediaTitle:MoveRightOf( self.PlayPauseBtn, self.Padding )

	if self._Media then
		self.MediaTitle:AlignTop( self.Padding )
	else
		self.MediaTitle:CenterVertical()
	end

	self.MediaTime:InvalidateLayout()
	self.MediaTime:MoveRightOf( self.PlayPauseBtn, self.Padding )
	self.MediaTime:AlignBottom( self.Padding - 2 )

	self.FavBtn:AlignTop( self.Padding )
	self.FavBtn:AlignRight( self.Padding )

	self.BtnList:InvalidateLayout(true)
	self.BtnList:AlignBottom( self.Padding )
	self.BtnList:AlignRight( self.Padding )

	-- 'ADDED BY Name' needs to fit between the media time and the rightmost
	-- buttons.
	local addedByMaxWidth = ( self.BtnList:GetPos() - self.BtnSpacing ) -
		( self.MediaTime:GetPos() + self.MediaTime:GetWide() + self.Padding )

	self.AddedByLbl:SetMaxWidth( addedByMaxWidth )
	self.AddedByLbl:AlignBottom( self.Padding )
	self.AddedByLbl:MoveLeftOf( self.BtnList, self.BtnSpacing )

	local maxTitleWidth = ( self.FavBtn:GetPos() - self.BtnSpacing ) -
		( self.MediaTitle:GetPos() )

	if self.MediaTitle:GetWide() > maxTitleWidth then
		self.MediaTitle:SetWide( maxTitleWidth )
	end

	self.Seekbar:SetSize( w, self.SeekbarHeight )
	self.Seekbar:SetPos( 0, h - self.SeekbarHeight )

	self:SetTall( self.Height + self.SeekbarHeight * 0.5 )

end

derma.DefineControl( "MP.Playback", "", PANEL, "Panel" )


local PLAYPAUSE_BTN = {
	StateIcons = {
		[1] = nil, -- MP_STATE_ENDED
		[2] = "mp-pause", -- MP_STATE_PLAYING
		[3] = "mp-play" -- MP_STATE_PAUSED
	}
}

function PLAYPAUSE_BTN:Init()
	self.BaseClass.Init( self )

	self:SetSize( 22, 25 )
	self:SetHighlighted( true )
end

function PLAYPAUSE_BTN:SetPlayerState( playerState )

	self.PlayerState = playerState

	playerState = (playerState or 0) + 1 -- Lua can't index 0

	local icon = self.StateIcons[ playerState ]

	if icon then
		self:SetIcon( icon )
		self:SetIconVisible(true)
	else
		self:SetIconVisible(false)
	end

	-- Set cursor type depending on whether player is admin/owner
	if hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then
		self:SetCursor( "hand" )
	else
		self:SetCursor( "arrow" )
	end

end

function PLAYPAUSE_BTN:DoClick()

	hook.Run( MP.EVENTS.UI.TOGGLE_PAUSE )

end

derma.DefineControl( "MP.PlayPauseButton", "", PLAYPAUSE_BTN, "MP.SidebarButton" )


local SEEKBAR = {}

SEEKBAR.KnobSize = 8
SEEKBAR.BarHeight = 2

SEEKBAR.ProgressColor = Color( 28, 100, 157 )

AccessorFunc( SEEKBAR, "m_Media", "Media" )

function SEEKBAR:Init()

	self.BaseClass.Init( self )

	self.Knob:SetSize( self.KnobSize, self.KnobSize )
	self.Knob.Paint = self.PaintKnob

	self.Knob.OnMousePressed = function( panel, mousecode )
			self:OnStartEditing( self )
			DButton.OnMousePressed( panel, mousecode )
		end
	self.Knob.OnMouseReleased = function( panel, mousecode )
			self:OnStopEditing( self )
			DButton.OnMouseReleased( panel, mousecode )
		end

	-- Remove some hidden panel child from the inherited DSlider control; I have
	-- no idea where it's being created...
	for _, child in pairs( self:GetChildren() ) do
		if child ~= self.Knob then
			child:Remove()
		end
	end

end

function SEEKBAR:OnStartEditing()

	-- only allow admins/owners to control seeking
	if not hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then return end

	hook.Run( MP.EVENTS.UI.START_SEEKING, self )

end

function SEEKBAR:OnStopEditing()

	-- only allow admins/owners to control seeking
	if not hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then return end

	hook.Run( MP.EVENTS.UI.STOP_SEEKING, self )

	if self.m_Media then
		local seekTime = ceil(self.m_fSlideX * self.m_Media:Duration())
		hook.Run( MP.EVENTS.UI.SEEK, seekTime )
	end

end

function SEEKBAR:OnMousePressed( mcode )
	self:OnStartEditing()
	self.BaseClass.OnMousePressed( self, mcode )
end

function SEEKBAR:OnMouseReleased( mcode )
	self:OnStopEditing()
	self.BaseClass.OnMouseReleased( self, mcode )
end

function SEEKBAR:Think()

	local media = self.m_Media

	if media and not self:IsEditing() then
		local progress = media:CurrentTime() / media:Duration()
		progress = clamp(progress, 0, 1)

		self:SetSlideX( progress )
		self:InvalidateLayout()
	end

end

function SEEKBAR:Paint( w, h )

	local midy = ceil( h * 0.5 )
	local bary = ceil(midy - (self.BarHeight * 0.5))

	local progress = self:GetSlideX()

	surface.SetDrawColor( self.ProgressColor )
	surface.DrawRect( 0, bary, ceil(w * progress), self.BarHeight )

end

function SEEKBAR:PaintKnob( w, h )

	draw.RoundedBoxEx( ceil(w*0.5), 0, 0, w, h, color_white, true, true, true, true )

end

derma.DefineControl( "MP.Seekbar", "", SEEKBAR, "DSlider" )

--PATH addons/__main_only_1st/lua/autorun/necoarcchaos.lua:
--Add Playermodel
player_manager.AddValidModel( "Neco Arc Chaos", "models/mocha/necoarcchaos/necoarcchaos.mdl" )
player_manager.AddValidHands( "Neco Arc Chaos", "models/mocha/necoarcchaos/necoarcchaos_arms.mdl", 0, "0000000" )
--PATH addons/____onyx_framework_2/lua/onyx/util.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local zeroFn = function() end

onyx.ZeroFn = zeroFn
onyx.IncludeClient = CLIENT and include or AddCSLuaFile
onyx.IncludeServer = SERVER and include or zeroFn
onyx.IncludeShared = function(path)
    AddCSLuaFile(path)
    return include(path)
end

do
    local Explode = string.Explode
    local Left = string.Left
    onyx.Include = function(path)
        local parts = Explode('/', path)
        local prefix = Left(parts[#parts], 2)

        if prefix then
            if prefix == 'sv' then
                return onyx.IncludeServer(path)
            elseif prefix == 'cl' then
                return onyx.IncludeClient(path)
            elseif prefix == 'sh' then
                return onyx.IncludeShared(path)
            end
        end
    end
end

do
    local Find = file.Find
    local ipairs = ipairs
    local GetExtensionFromFilename = string.GetExtensionFromFilename

    local function IncludeFolder(path, recursive)
        local files, folders = Find(path .. '*', 'LUA')

        for _, name in ipairs(files) do
            if GetExtensionFromFilename(name) == 'lua' then
                onyx.Include(path .. name)
            end
        end

        if recursive then
            for _, name in ipairs(folders) do
                IncludeFolder(path .. name .. '/', recursive)
            end
        end
    end
    onyx.IncludeFolder = IncludeFolder
end

function onyx:Config(key)
    local tSequence = string.Explode('.', key)
    local iSequence = #tSequence
    local previousTbl = self.cfg

    for i = 1, iSequence do
        local keyPart = tSequence[i]
        if previousTbl[keyPart] then
            if i == iSequence then
                return previousTbl[keyPart]
            else
                previousTbl = previousTbl[keyPart]
            end
        end
    end

    return fallback
end

do
    local accent = Color(174, 0, 255)
    local white = color_white
    local red = Color(255, 73, 73)
    local green = Color(121, 255, 68)
    local orange = Color(255, 180, 68)
    local blue = Color(68, 149, 255)

    local function format(text, ...)
        for _, arg in ipairs({...}) do
            if isentity(arg) and arg:IsPlayer() then
                arg = arg:Name() .. " (" .. arg:SteamID() .. ")"
            else
                arg = tostring(arg)
            end
    
            text = string.gsub(text, "#", arg, 1)
        end
    
        return text
    end

    local function printWPrefix(color, prefix, text, ...)
        MsgC(
            white, '(', accent, 'ONYX', white, ') ',
            white, '(', color, prefix, white, ') ',
            format(text, ...),
            '\n'
        )
    end

    function onyx:Print(text, ...)
        MsgC(
            white, '(', accent, 'ONYX', white, ') ',
            format(text, ...),
            '\n'
        )
    end

    function onyx:PrintError(text, ...)
        printWPrefix(red, 'ERROR', text, ...)
    end

    function onyx:PrintWarning(text, ...)
        printWPrefix(orange, 'WARNING', text, ...)
    end

    function onyx:PrintSuccess(text, ...)
        printWPrefix(green, 'SUCCESS', text, ...)
    end
    
    do

        local cvDebug = CreateConVar('sh_onyx_debug', '0', FCVAR_REPLICATED)

        function onyx:PrintDebug(text, ...)
            if (cvDebug:GetBool()) then
                printWPrefix(blue, 'DEBUG', text, ...)
            end
        end
    end
end
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_utf8.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

onyx.utf8 = {}

local CASEMAP_LOWER = {} -- lower to upper
local CASEMAP_UPPER = {} -- upper to lower

do
    -- gmod doesn't like big lua files, so let's split them
    for index = 1, 4 do
        local data = include('data/utf8_chunk_' .. index .. '.lua')
        assert(data, 'missing UTF-8 casemap data (' .. index .. ')')
        for lowerCharCode, upperCharCode in next, data do
            CASEMAP_LOWER[lowerCharCode] = upperCharCode
            CASEMAP_UPPER[upperCharCode] = lowerCharCode
        end
    end
end

local function replace(text, mapping)
    assert(isstring(text), string.format('bad argument #1 `replace` (expected string, got %s)', type(text)))

    local newString = ''

    for _, code in utf8.codes(text) do
        newString = newString .. utf8.char(mapping[code] or code)
    end

    return newString
end

function onyx.utf8.upper(text)
    return replace(text, CASEMAP_LOWER)
end

function onyx.utf8.lower(text)
    return replace(text, CASEMAP_UPPER)
end
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_1.lua:
return {[97] = 65,[98] = 66,[99] = 67,[100] = 68,[101] = 69,[102] = 70,[103] = 71,[104] = 72,[105] = 73,[106] = 74,[107] = 75,[108] = 76,[109] = 77,[110] = 78,[111] = 79,[112] = 80,[113] = 81,[114] = 82,[115] = 83,[116] = 84,[117] = 85,[118] = 86,[119] = 87,[120] = 88,[121] = 89,[122] = 90,[181] = 924,[224] = 192,[225] = 193,[226] = 194,[227] = 195,[228] = 196,[229] = 197,[230] = 198,[231] = 199,[232] = 200,[233] = 201,[234] = 202,[235] = 203,[236] = 204,[237] = 205,[238] = 206,[239] = 207,[240] = 208,[241] = 209,[242] = 210,[243] = 211,[244] = 212,[245] = 213,[246] = 214,[248] = 216,[249] = 217,[250] = 218,[251] = 219,[252] = 220,[253] = 221,[254] = 222,[255] = 376,[257] = 256,[259] = 258,[261] = 260,[263] = 262,[265] = 264,[267] = 266,[269] = 268,[271] = 270,[273] = 272,[275] = 274,[277] = 276,[279] = 278,[281] = 280,[283] = 282,[285] = 284,[287] = 286,[289] = 288,[291] = 290,[293] = 292,[295] = 294,[297] = 296,[299] = 298,[301] = 300,[303] = 302,[305] = 73,[307] = 306,[309] = 308,[311] = 310,[314] = 313,[316] = 315,[318] = 317,[320] = 319,[322] = 321,[324] = 323,[326] = 325,[328] = 327,[331] = 330,[333] = 332,[335] = 334,[337] = 336,[339] = 338,[341] = 340,[343] = 342,[345] = 344,[347] = 346,[349] = 348,[351] = 350,[353] = 352,[355] = 354,[357] = 356,[359] = 358,[361] = 360,[363] = 362,[365] = 364,[367] = 366,[369] = 368,[371] = 370,[373] = 372,[375] = 374,[378] = 377,[380] = 379,[382] = 381,[383] = 83,[384] = 579,[387] = 386,[389] = 388,[392] = 391,[396] = 395,[402] = 401,[405] = 502,[409] = 408,[410] = 573,[414] = 544,[417] = 416,[419] = 418,[421] = 420,[424] = 423,[429] = 428,[432] = 431,[436] = 435,[438] = 437,[441] = 440,[445] = 444,[447] = 503,[453] = 452,[454] = 452,[456] = 455,[457] = 455,[459] = 458,[460] = 458,[462] = 461,[464] = 463,[466] = 465,[468] = 467,[470] = 469,[472] = 471,[474] = 473,[476] = 475,[477] = 398,[479] = 478,[481] = 480,[483] = 482,[485] = 484,[487] = 486,[489] = 488,[491] = 490,[493] = 492,[495] = 494,[498] = 497,[499] = 497,[501] = 500,[505] = 504,[507] = 506,[509] = 508,[511] = 510,[513] = 512,[515] = 514,[517] = 516,[519] = 518,[521] = 520,[523] = 522,[525] = 524,[527] = 526,[529] = 528,[531] = 530,[533] = 532,[535] = 534,[537] = 536,[539] = 538,[541] = 540,[543] = 542,[547] = 546,[549] = 548,[551] = 550,[553] = 552,[555] = 554,[557] = 556,[559] = 558,[561] = 560,[563] = 562,[572] = 571,[578] = 577,[583] = 582,[585] = 584,[587] = 586,[589] = 588,[591] = 590,[595] = 385,[596] = 390,[598] = 393,[599] = 394,[601] = 399,[603] = 400,[608] = 403,[611] = 404,[616] = 407,[617] = 406,[619] = 11362,[623] = 412,[626] = 413,[629] = 415,[637] = 11364,[640] = 422,[643] = 425,[648] = 430,[649] = 580,[650] = 433,[651] = 434,[652] = 581,[658] = 439,[837] = 921,[891] = 1021,[892] = 1022,[893] = 1023,[940] = 902,}
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_4.lua:
return {[9425] = 9399,[9426] = 9400,[9427] = 9401,[9428] = 9402,[9429] = 9403,[9430] = 9404,[9431] = 9405,[9432] = 9406,[9433] = 9407,[9434] = 9408,[9435] = 9409,[9436] = 9410,[9437] = 9411,[9438] = 9412,[9439] = 9413,[9440] = 9414,[9441] = 9415,[9442] = 9416,[9443] = 9417,[9444] = 9418,[9445] = 9419,[9446] = 9420,[9447] = 9421,[9448] = 9422,[9449] = 9423,[11312] = 11264,[11313] = 11265,[11314] = 11266,[11315] = 11267,[11316] = 11268,[11317] = 11269,[11318] = 11270,[11319] = 11271,[11320] = 11272,[11321] = 11273,[11322] = 11274,[11323] = 11275,[11324] = 11276,[11325] = 11277,[11326] = 11278,[11327] = 11279,[11328] = 11280,[11329] = 11281,[11330] = 11282,[11331] = 11283,[11332] = 11284,[11333] = 11285,[11334] = 11286,[11335] = 11287,[11336] = 11288,[11337] = 11289,[11338] = 11290,[11339] = 11291,[11340] = 11292,[11341] = 11293,[11342] = 11294,[11343] = 11295,[11344] = 11296,[11345] = 11297,[11346] = 11298,[11347] = 11299,[11348] = 11300,[11349] = 11301,[11350] = 11302,[11351] = 11303,[11352] = 11304,[11353] = 11305,[11354] = 11306,[11355] = 11307,[11356] = 11308,[11357] = 11309,[11358] = 11310,[11361] = 11360,[11365] = 570,[11366] = 574,[11368] = 11367,[11370] = 11369,[11372] = 11371,[11382] = 11381,[11393] = 11392,[11395] = 11394,[11397] = 11396,[11399] = 11398,[11401] = 11400,[11403] = 11402,[11405] = 11404,[11407] = 11406,[11409] = 11408,[11411] = 11410,[11413] = 11412,[11415] = 11414,[11417] = 11416,[11419] = 11418,[11421] = 11420,[11423] = 11422,[11425] = 11424,[11427] = 11426,[11429] = 11428,[11431] = 11430,[11433] = 11432,[11435] = 11434,[11437] = 11436,[11439] = 11438,[11441] = 11440,[11443] = 11442,[11445] = 11444,[11447] = 11446,[11449] = 11448,[11451] = 11450,[11453] = 11452,[11455] = 11454,[11457] = 11456,[11459] = 11458,[11461] = 11460,[11463] = 11462,[11465] = 11464,[11467] = 11466,[11469] = 11468,[11471] = 11470,[11473] = 11472,[11475] = 11474,[11477] = 11476,[11479] = 11478,[11481] = 11480,[11483] = 11482,[11485] = 11484,[11487] = 11486,[11489] = 11488,[11491] = 11490,[11520] = 4256,[11521] = 4257,[11522] = 4258,[11523] = 4259,[11524] = 4260,[11525] = 4261,[11526] = 4262,[11527] = 4263,[11528] = 4264,[11529] = 4265,[11530] = 4266,[11531] = 4267,[11532] = 4268,[11533] = 4269,[11534] = 4270,[11535] = 4271,[11536] = 4272,[11537] = 4273,[11538] = 4274,[11539] = 4275,[11540] = 4276,[11541] = 4277,[11542] = 4278,[11543] = 4279,[11544] = 4280,[11545] = 4281,[11546] = 4282,[11547] = 4283,[11548] = 4284,[11549] = 4285,[11550] = 4286,[11551] = 4287,[11552] = 4288,[11553] = 4289,[11554] = 4290,[11555] = 4291,[11556] = 4292,[11557] = 4293,[65345] = 65313,[65346] = 65314,[65347] = 65315,[65348] = 65316,[65349] = 65317,[65350] = 65318,[65351] = 65319,[65352] = 65320,[65353] = 65321,[65354] = 65322,[65355] = 65323,[65356] = 65324,[65357] = 65325,[65358] = 65326,[65359] = 65327,[65360] = 65328,[65361] = 65329,[65362] = 65330,[65363] = 65331,[65364] = 65332,[65365] = 65333,[65366] = 65334,[65367] = 65335,[65368] = 65336,[65369] = 65337,[65370] = 65338,[66600] = 66560,[66601] = 66561,[66602] = 66562,[66603] = 66563,[66604] = 66564,[66605] = 66565,[66606] = 66566,[66607] = 66567,[66608] = 66568,[66609] = 66569,[66610] = 66570,[66611] = 66571,[66612] = 66572,[66613] = 66573,[66614] = 66574,[66615] = 66575,[66616] = 66576,[66617] = 66577,[66618] = 66578,[66619] = 66579,[66620] = 66580,[66621] = 66581,[66622] = 66582,[66623] = 66583,[66624] = 66584,[66625] = 66585,[66626] = 66586,[66627] = 66587,[66628] = 66588,[66629] = 66589,[66630] = 66590,[66631] = 66591,[66632] = 66592,[66633] = 66593,[66634] = 66594,[66635] = 66595,[66636] = 66596,[66637] = 66597,[66638] = 66598,[66639] = 66599,}
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/sh_util.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

01/05/2023

--]]

function onyx.WaitForGamemode(id, fn)
    if (GM or GAMEMODE) then
        fn()
    else
        if (SERVER) then
            hook.Add('PostGamemodeLoaded', id, fn) -- I hate ULX lol (`InitPostEntity` doesn't get called on serverside :\\\\)
        else
            hook.Add('InitPostEntity', id, fn) -- 'PostGamemodeLoaded' ain't called on CLIENT with uLib
        end
    end
end

function onyx.AssertType(variable, expected, funcname, pos)
    local given = type(variable)
    assert(given == expected, string.format('bad argument #%i to \'%s\' (expected %s, got %s)', pos, funcname, expected, given))
end

function onyx.ColorToHex(color)
    local r = bit.tohex(color.r, 2)
    local g = bit.tohex(color.g, 2)
    local b = bit.tohex(color.b, 2)

    return ('#' .. r .. g .. b)
end

function onyx.HexToColor(color)
    color = color:gsub('#', '')

    local r = tonumber('0x' .. color:sub(1, 2))
    local g = tonumber('0x' .. color:sub(3, 4))
    local b = tonumber('0x' .. color:sub(5, 6))

    return Color(r, g, b)
end

function onyx.MultiArg(arg, amount)
    local tbl = {}
    for i = 1, amount do
        tbl[i] = arg
    end
    return unpack(tbl)
end

do
    local replacements = {
        TypeToString = {
            ['boolean'] = 'b',
            ['number'] = 'n',
            ['string'] = 's',
            ['Vector'] = 'v',
            ['Angle'] = 'a',
        },
        StringToType = {
            ['b'] = 'bool',
            ['n'] = 'int',
            ['s'] = 'string',
            ['v'] = 'vector',
            ['a'] = 'angle',
            ['f'] = 'float'
        },
    }

    function onyx.TypeToString(any)
        local name = replacements.TypeToString[type(any)]
        assert(name, 'wrong type (' .. type(any) .. ')')
        local str = util.TypeToString(any)
        if (name == 'n' and (any % 1) ~= 0) then
            name = 'f'
        end
        local full = name .. '!' .. str
        return full
    end

    function onyx.StringToType(str)
        local typeShort = str:match('%w!-')
        local value = str:gsub(typeShort .. '!', '', 1)
        local typeFull = replacements.StringToType[typeShort]
        return util.StringToType(value, typeFull)
    end
end

if (SERVER) then
    util.AddNetworkString('onyx:Notify')

    function onyx.Notify(ply, text, notificationType, length)
        assert(IsEntity(ply), Format('bad argument #1 to `onyx.Notify` (expected player, got %s)', type(ply)))
        assert(isstring(text), Format('bad argument #2 to `onyx.Notify` (expected string, got %s)', type(text)))

        net.Start('onyx:Notify')
            net.WriteString(text)
            net.WriteUInt(notificationType or 0, 3)
            net.WriteUInt(length or 3, 4)
            net.WriteBool(false)
        net.Send(ply)
    end

    function onyx.NotifyLocalized(ply, text, args, notificationType, length)
        assert(IsEntity(ply), Format('bad argument #1 to `onyx.NotifyLocalized` (expected player, got %s)', type(ply)))
        assert(isstring(text), Format('bad argument #2 to `onyx.NotifyLocalized` (expected string, got %s)', type(text)))
        assert(istable(args), Format('bad argument #3 to `onyx.NotifyLocalized` (expected table, got %s)', type(args)))

        net.Start('onyx:Notify')
            net.WriteString(text)
            net.WriteUInt(notificationType or 0, 3)
            net.WriteUInt(length or 3, 4)
            net.WriteBool(true)
            onyx.net.WriteTable(args)
        net.Send(ply)
    end
else
    net.Receive('onyx:Notify', function(len)
        local text = net.ReadString()
        local notificationType = net.ReadUInt(3)
        local length = net.ReadUInt(4)
        local bLocalized = net.ReadBool()
        local arguments = bLocalized and onyx.net.ReadTable()

        if (bLocalized) then
            text = onyx.lang:Get(text, arguments)
        end

        notification.AddLegacy(text, notificationType, length)
    end)
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/libs/thirdparty/cl_tween.lua:
-- Put your Lua here
local tween = {
    _VERSION = 'tween 2.1.1',
    _DESCRIPTION = 'tweening for lua',
    _URL = 'https://github.com/kikito/tween.lua',
    _LICENSE = [[
      MIT LICENSE

      Copyright (c) 2014 Enrique García Cota, Yuichi Tateno, Emmanuel Oga

      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this software and associated documentation files (the
      "Software"), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:

      The above copyright notice and this permission notice shall be included
      in all copies or substantial portions of the Software.

      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    ]]
}

-- easing
-- Adapted from https://github.com/EmmanuelOga/easing. See LICENSE.txt for credits.
-- For all easing functions:
-- t = time == how much time has to pass for the tweening to complete
-- b = begin == starting property value
-- c = change == ending - beginning
-- d = duration == running time. How much time has passed *right now*
local pow, sin, cos, pi, sqrt, abs, asin = math.pow, math.sin, math.cos, math.pi, math.sqrt, math.abs, math.asin

-- linear
local function linear(t, b, c, d)
    return c * t / d + b
end

-- quad
local function inQuad(t, b, c, d)
    return c * pow(t / d, 2) + b
end

local function outQuad(t, b, c, d)
    t = t / d

    return -c * t * (t - 2) + b
end

local function inOutQuad(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c * 0.5 * pow(t, 2) + b end

    return -c * 0.5 * ((t - 1) * (t - 3) - 1) + b
end

local function outInQuad(t, b, c, d)
    if t < d * 0.5 then return outQuad(t * 2, b, c * 0.5, d) end

    return inQuad((t * 2) - d, b + c * 0.5, c * 0.5, d)
end

-- cubic
local function inCubic(t, b, c, d)
    return c * pow(t / d, 3) + b
end

local function outCubic(t, b, c, d)
    return c * (pow(t / d - 1, 3) + 1) + b
end

local function inOutCubic(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c * 0.5 * t * t * t + b end
    t = t - 2

    return c * 0.5 * (t * t * t + 2) + b
end

local function outInCubic(t, b, c, d)
    if t < d * 0.5 then return outCubic(t * 2, b, c * 0.5, d) end

    return inCubic((t * 2) - d, b + c * 0.5, c * 0.5, d)
end

-- quart
local function inQuart(t, b, c, d)
    return c * pow(t / d, 4) + b
end

local function outQuart(t, b, c, d)
    return -c * (pow(t / d - 1, 4) - 1) + b
end

local function inOutQuart(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c * 0.5 * pow(t, 4) + b end

    return -c * 0.5 * (pow(t - 2, 4) - 2) + b
end

local function outInQuart(t, b, c, d)
    if t < d * 0.5 then return outQuart(t * 2, b, c * 0.5, d) end

    return inQuart((t * 2) - d, b + c * 0.5, c * 0.5, d)
end

-- quint
local function inQuint(t, b, c, d)
    return c * pow(t / d, 5) + b
end

local function outQuint(t, b, c, d)
    return c * (pow(t / d - 1, 5) + 1) + b
end

local function inOutQuint(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c * 0.5 * pow(t, 5) + b end

    return c * 0.5 * (pow(t - 2, 5) + 2) + b
end

local function outInQuint(t, b, c, d)
    if t < d * 0.5 then return outQuint(t * 2, b, c * 0.5, d) end

    return inQuint((t * 2) - d, b + c * 0.5, c * 0.5, d)
end

-- sine
local function inSine(t, b, c, d)
    return -c * cos(t / d * (pi * 0.5)) + c + b
end

local function outSine(t, b, c, d)
    return c * sin(t / d * (pi * 0.5)) + b
end

local function inOutSine(t, b, c, d)
    return -c * 0.5 * (cos(pi * t / d) - 1) + b
end

local function outInSine(t, b, c, d)
    if t < d * 0.5 then return outSine(t * 2, b, c * 0.5, d) end

    return inSine((t * 2) - d, b + c * 0.5, c * 0.5, d)
end

-- expo
local function inExpo(t, b, c, d)
    if t == 0 then return b end

    return c * pow(2, 10 * (t / d - 1)) + b - c * 0.001
end

local function outExpo(t, b, c, d)
    if t == d then return b + c end

    return c * 1.001 * (-pow(2, -10 * t / d) + 1) + b
end

local function inOutExpo(t, b, c, d)
    if t == 0 then return b end
    if t == d then return b + c end
    t = t / d * 2
    if t < 1 then return c * 0.5 * pow(2, 10 * (t - 1)) + b - c * 0.0005 end

    return c * 0.5 * 1.0005 * (-pow(2, -10 * (t - 1)) + 2) + b
end

local function outInExpo(t, b, c, d)
    if t < d * 0.5 then return outExpo(t * 2, b, c * 0.5, d) end

    return inExpo((t * 2) - d, b + c * 0.5, c * 0.5, d)
end

-- circ
local function inCirc(t, b, c, d)
    return -c * (sqrt(1 - pow(t / d, 2)) - 1) + b
end

local function outCirc(t, b, c, d)
    return c * sqrt(1 - pow(t / d - 1, 2)) + b
end

local function inOutCirc(t, b, c, d)
    t = t / d * 2
    if t < 1 then return -c * 0.5 * (sqrt(1 - t * t) - 1) + b end
    t = t - 2

    return c * 0.5 * (sqrt(1 - t * t) + 1) + b
end

local function outInCirc(t, b, c, d)
    if t < d * 0.5 then return outCirc(t * 2, b, c * 0.5, d) end

    return inCirc((t * 2) - d, b + c * 0.5, c * 0.5, d)
end

-- elastic
local function calculatePAS(p, a, c, d)
    p, a = p or d * 0.3, a or 0
    if a < abs(c) then return p, c, p / 4 end -- p, a, s
    -- p,a,s

    return p, a, p / (2 * pi) * asin(c / a)
end

local function inElastic(t, b, c, d, a, p)
    local s
    if t == 0 then return b end
    t = t / d
    if t == 1 then return b + c end
    p, a, s = calculatePAS(p, a, c, d)
    t = t - 1

    return -(a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
end

local function outElastic(t, b, c, d, a, p)
    local s
    if t == 0 then return b end
    t = t / d
    if t == 1 then return b + c end
    p, a, s = calculatePAS(p, a, c, d)

    return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) + c + b
end

local function inOutElastic(t, b, c, d, a, p)
    local s
    if t == 0 then return b end
    t = t / d * 2
    if t == 2 then return b + c end
    p, a, s = calculatePAS(p, a, c, d)
    t = t - 1
    if t < 0 then return -0.5 * (a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b end

    return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) * 0.5 + c + b
end

local function outInElastic(t, b, c, d, a, p)
    if t < d * 0.5 then return outElastic(t * 2, b, c * 0.5, d, a, p) end

    return inElastic((t * 2) - d, b + c * 0.5, c * 0.5, d, a, p)
end

-- back
local function inBack(t, b, c, d, s)
    s = s or 1.70158
    t = t / d

    return c * t * t * ((s + 1) * t - s) + b
end

local function outBack(t, b, c, d, s)
    s = s or 1.70158
    t = t / d - 1

    return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function inOutBack(t, b, c, d, s)
    s = (s or 1.70158) * 1.525
    t = t / d * 2
    if t < 1 then return c * 0.5 * (t * t * ((s + 1) * t - s)) + b end
    t = t - 2

    return c * 0.5 * (t * t * ((s + 1) * t + s) + 2) + b
end

local function outInBack(t, b, c, d, s)
    if t < d * 0.5 then return outBack(t * 2, b, c * 0.5, d, s) end

    return inBack((t * 2) - d, b + c * 0.5, c * 0.5, d, s)
end

-- bounce
local function outBounce(t, b, c, d)
    t = t / d
    if t < 1 / 2.75 then return c * (7.5625 * t * t) + b end

    if t < 2 / 2.75 then
        t = t - (1.5 / 2.75)

        return c * (7.5625 * t * t + 0.75) + b
    elseif t < 2.5 / 2.75 then
        t = t - (2.25 / 2.75)

        return c * (7.5625 * t * t + 0.9375) + b
    end

    t = t - (2.625 / 2.75)

    return c * (7.5625 * t * t + 0.984375) + b
end

local function inBounce(t, b, c, d)
    return c - outBounce(d - t, 0, c, d) + b
end

local function inOutBounce(t, b, c, d)
    if t < d * 0.5 then return inBounce(t * 2, 0, c, d) * 0.5 + b end

    return outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
end

local function outInBounce(t, b, c, d)
    if t < d * 0.5 then return outBounce(t * 2, b, c * 0.5, d) end

    return inBounce((t * 2) - d, b + c * 0.5, c * 0.5, d)
end

tween.easing = {
    linear = linear,
    inQuad = inQuad,
    outQuad = outQuad,
    inOutQuad = inOutQuad,
    outInQuad = outInQuad,
    inCubic = inCubic,
    outCubic = outCubic,
    inOutCubic = inOutCubic,
    outInCubic = outInCubic,
    inQuart = inQuart,
    outQuart = outQuart,
    inOutQuart = inOutQuart,
    outInQuart = outInQuart,
    inQuint = inQuint,
    outQuint = outQuint,
    inOutQuint = inOutQuint,
    outInQuint = outInQuint,
    inSine = inSine,
    outSine = outSine,
    inOutSine = inOutSine,
    outInSine = outInSine,
    inExpo = inExpo,
    outExpo = outExpo,
    inOutExpo = inOutExpo,
    outInExpo = outInExpo,
    inCirc = inCirc,
    outCirc = outCirc,
    inOutCirc = inOutCirc,
    outInCirc = outInCirc,
    inElastic = inElastic,
    outElastic = outElastic,
    inOutElastic = inOutElastic,
    outInElastic = outInElastic,
    inBack = inBack,
    outBack = outBack,
    inOutBack = inOutBack,
    outInBack = outInBack,
    inBounce = inBounce,
    outBounce = outBounce,
    inOutBounce = inOutBounce,
    outInBounce = outInBounce
}

-- private stuff
local function copyTables(destination, keysTable, valuesTable)
    valuesTable = valuesTable or keysTable
    local mt = getmetatable(keysTable)

    if mt and getmetatable(destination) == nil then
        setmetatable(destination, mt)
    end

    for k, v in pairs(keysTable) do
        if type(v) == 'table' then
            destination[k] = copyTables({}, v, valuesTable[k])
        else
            destination[k] = valuesTable[k]
        end
    end

    return destination
end

local function checkSubjectAndTargetRecursively(subject, target, path)
    path = path or {}
    local targetType, newPath

    for k, targetValue in pairs(target) do
        targetType, newPath = type(targetValue), copyTables({}, path)
        table.insert(newPath, tostring(k))

        if targetType == 'number' then
            assert(type(subject[k]) == 'number', "Parameter '" .. table.concat(newPath, '/') .. "' is missing from subject or isn't a number")
        elseif targetType == 'table' then
            checkSubjectAndTargetRecursively(subject[k], targetValue, newPath)
        else
            assert(targetType == 'number', "Parameter '" .. table.concat(newPath, '/') .. "' must be a number or table of numbers")
        end
    end
end

local function checkNewParams(duration, subject, target, easing)
    assert(type(duration) == 'number' and duration > 0, "duration must be a positive number. Was " .. tostring(duration))
    local tsubject = type(subject)
    assert(tsubject == 'table' or tsubject == 'userdata' or tsubject == 'Panel', "subject must be a table or userdata. Was " .. tostring(subject))
    assert(type(target) == 'table', "target must be a table. Was " .. tostring(target))
    assert(type(easing) == 'function', "easing must be a function. Was " .. tostring(easing))
    checkSubjectAndTargetRecursively(subject, target)
end

local function getEasingFunction(easing)
    easing = easing or "linear"

    if type(easing) == 'string' then
        local name = easing
        easing = tween.easing[name]

        if type(easing) ~= 'function' then
            error("The easing function name '" .. name .. "' is invalid")
        end
    end

    return easing
end

local function performEasingOnSubject(subject, target, initial, clock, duration, easing)
    local t, b, c, d

    for k, v in pairs(target) do
        if type(v) == 'table' then
            performEasingOnSubject(subject[k], v, initial[k], clock, duration, easing)
        else
            t, b, c, d = clock, initial[k], v - initial[k], duration
            subject[k] = easing(t, b, c, d)
        end
    end
end

-- Tween methods
local Tween = {}

local Tween_mt = {
    __index = Tween
}

function Tween:set(clock)
    assert(type(clock) == 'number', "clock must be a positive number or 0")
    self.initial = self.initial or copyTables({}, self.target, self.subject)
    self.clock = clock

    if self.clock <= 0 then
        self.clock = 0
        copyTables(self.subject, self.initial)
    elseif self.clock >= self.duration then
        -- the tween has expired
        self.clock = self.duration
        copyTables(self.subject, self.target)
    else
        performEasingOnSubject(self.subject, self.target, self.initial, self.clock, self.duration, self.easing)
    end

    return self.clock >= self.duration
end

function Tween:reset()
    return self:set(0)
end

function Tween:update(dt)
    assert(type(dt) == 'number', "dt must be a number")

    return self:set(self.clock + dt)
end

-- Public interface
function tween.new(duration, subject, target, easing)
    easing = getEasingFunction(easing)
    checkNewParams(duration, subject, target, easing)

    return setmetatable({
        duration = duration,
        subject = subject,
        target = target,
        easing = easing,
        clock = 0
    }, Tween_mt)
end

onyx.tween = tween
--PATH addons/____onyx_framework_2/lua/onyx/ui/libs/cl_anim.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/04/2022

--]]

onyx.anim = {}
onyx.anim.list = {}

-- Reservation
onyx.anim.ANIM_HOVER = 0x100
onyx.anim.ANIM_X = 0x101
onyx.anim.ANIM_Y = 0x102
onyx.anim.ANIM_SCALE = 0x103

local anim = onyx.anim
local tween = onyx.tween
local cv = CreateClientConVar('cl_onyx_smooth', '1', true, false, 'Enable smooth animations')

function anim.Create(panel, duration, data)
    if not panel.onyxAnims then
        anim.list[#anim.list + 1] = panel
        panel.onyxAnims = {}
    end

    local index = data.index
    local subject = data.subject or panel
    local target = data.target
    local easing = data.easing or 'linear'
    local think = data.think
    local onFinished = data.onFinished

    local instance = tween.new(duration, subject, target, easing)

    instance.index = index
    instance.think = think
    instance.onFinished = onFinished

    if (cv:GetBool() and not data.skipAnimation) then
        instance:set(0)
    else
        instance:set(duration)
    end

    panel.onyxAnims[index] = instance
end

function anim.Simple(panel, duration, target, index, think, onFinished, easing)
    anim.Create(panel, duration, {
        index = index,
        target = target,
        think = think,
        onFinished = onFinished,
        easing = easing
    })
end

function anim.Remove(panel, index)
    if panel.onyxAnims and panel.onyxAnims[index] then
        panel.onyxAnims[index] = nil
    end
end

do
    local table_remove = table.remove
    local RealFrameTime = RealFrameTime
    local pairs = pairs
    local IsValid = IsValid

    local function handle(index, instance, panel, time)
        local isFinished = instance:update(time)
        local onFinished = instance.onFinished
        local think = instance.think

        if think then
            think(instance, panel)
        end

        if isFinished then
            panel.onyxAnims[index] = nil

            if onFinished then
                onFinished(instance, panel)
            end

            return true
        end

        return false
    end

    hook.Add('Think', 'onyx.anim.Controller', function()
        local time = FrameTime() -- lol, `RealFrameTime` in some rare cases it might return 0 all the time (how is it even possible???)
        local index = 0

        while (true) do
            index = index + 1
            local panel = anim.list[index]
            if panel == nil then
                break
            end
            if IsValid(panel) then
                for animIndex, instance in pairs(panel.onyxAnims) do
                    handle(animIndex, instance, panel, time)
                end
            else
                table_remove(anim.list, index)
            end
        end
        -- for i = 1, anim.index do
        --     local panel = anim.list[i]
        --     if IsValid(panel) then
        --         for index, instance in pairs(panel.onyxAnims) do
        --             handle(index, instance, panel, time)
        --         end
        --     else
        --         anim.index = anim.index - 1
        --         table_remove(anim.list, i)
        --     end
        -- end
    end)
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/libs/cl_trait.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/04/2022

--]]

onyx.trait = onyx.trait or {}
onyx.trait.list = onyx.trait.list or {}

local trait = onyx.trait

function trait.Register(id, data)
    trait.list[id] = data
end

function trait.Get(id)
    return trait.list[id]
end

do
    local hookList = {
        ['Think'] = true,
        ['OnMousePressed'] = true,
        ['OnMouseReleased'] = true,
        ['PerformLayout'] = true,
        ['OnCursorEntered'] = true,
        ['OnCursorExited'] = true,
    }

    function trait.Import(panel, id)
        panel.onyxTraits = panel.onyxTraits or {}

        local data = trait.Get(id)

        -- Check if trait is valid
        if not data then return false end

        -- Check if already imported
        if panel.onyxTraits[id] then return false end

        local initFunc = data.Init

        for k, v in pairs(data) do
            if k == 'Init' then
                goto skip
            end

            if hookList[k] then
                onyx.gui.InjectEventHandler(panel, k)
                onyx.gui.AddEvent(panel, k, v)
            else
                panel[k] = v
            end

            ::skip::
        end

        if initFunc then
            initFunc(panel)
        end

        panel.onyxTraits[id] = true

        return true
    end
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_menu.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2023

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_bDeleteSelf', 'DeleteSelf')
AccessorFunc(PANEL, 'm_iMinimumWidth', 'MinimumWidth')

local wimgArrow = onyx.wimg.Simple('https://i.imgur.com/KGC51Ws.png', 'smooth mips')
local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')

function PANEL:Init()
    self.backgroundColor = colorPrimary
    self.outlineColor = colorSecondary
    self.options = {}
    self.submenus = {}

    self:SetDrawOnTop(true)
    self:SetDeleteSelf(true)
    self:SetVisible(false)
    self:SetMinimumWidth(onyx.ScaleWide(120))

    local padding = onyx.ScaleTall(2)

    self:DockPadding(padding, padding, padding, padding)

    self.canvas:SetSpace(0)

    RegisterDermaMenuForClose(self)
end

function PANEL:PerformLayout(_, h)
    local _, padding1, _, padding2 = self:GetDockPadding()
    local _, localY = self:LocalToScreen(0, 0)
    local width = self:GetMinimumWidth()
    local height = padding1 + padding2
    local children = self.canvas:GetPanels()
    local childrenCount = #children

    for index, child in ipairs(self.canvas:GetPanels()) do
        height = height + child:GetTall()

        if (index < childrenCount) then
            height = height + select(4, child:GetDockMargin())
        end

        width = math.max(width, child:GetContentWidth() + onyx.ScaleTall(10))
    end

    if (localY + height) > ScrH() then
        height = ScrH() - localY
    end

    self:SetWide(width)
    self:SetTall(height)

    self.BaseClass.PerformLayout(self, width, height)

    self.scroll:DockMargin(0, 0, 0, 0)
end

function PANEL:Paint(w, h)
    local x, y = self:LocalToScreen()
    local thickness = 1

    onyx.bshadows.BeginShadow()
        draw.RoundedBox(8, x, y, w, h, self.outlineColor)
        draw.RoundedBox(8, x + thickness, y + thickness, w - thickness * 2, h - thickness * 2, self.backgroundColor)
    onyx.bshadows.EndShadow(1, 3, 3)
end

function PANEL:ToCursor()
    self:SetPos(input.GetCursorPos())
end

function PANEL:AddOption(text, callback)
    local button = self:Add('onyx.Button')
    button:SetText(text)

    button.OnMousePressed = function(panel)
        onyx.menuButtonPressTime = CurTime()

        panel:Call('DoClick')

        self:Remove()
    end

    button:On('OnCursorEntered', function(panel)
        self:CloseSubMenu()
    end)

    if callback then
        button.DoClick = callback
    end

    table.insert(self.options, button)
    local color = self.backgroundColor

    button:SetColorIdle(color)
    button:SetColorHover(onyx.OffsetColor(button:GetColorIdle(), 10))
    button:SetContentAlignment(4)
    button:SetText('')
    button:InjectEventHandler('Paint')
    button:On('Paint', function(panel, w, h)
        local material = panel.wimage and panel.wimage:GetMaterial() or panel.material
        local x = onyx.ScaleWide(10)

        if (material) then
            local size = onyx.ScaleTall(12)

            surface.SetDrawColor(panel:GetTextColor())
            surface.SetMaterial(material)
            surface.DrawTexturedRect(x, h * .5 - size * .5, size, size)

            x = x + size + onyx.ScaleWide(5)
        end

        draw.SimpleText(text, panel:GetFont(), x, h * .5, panel:GetTextColor(), 0, 1)
    end)

    button.GetContentWidth = function(panel)
        surface.SetFont(panel:GetFont())
        local w = surface.GetTextSize(text)
        local material = panel.wimage and panel.wimage:GetMaterial() or panel.material

        w = w + onyx.ScaleWide(10)

        if (material) then
            w = w + onyx.ScaleTall(12) + onyx.ScaleWide(5)
        end

        if (panel.submenu) then
            w = w + onyx.ScaleTall(12) + onyx.ScaleWide(5)
        end

        return w
    end

    button.SetIcon = function(panel, path, params)
        assert(path, 'no path provided')
        assert(isstring(path), 'path should be a string! alternative method: `SetMaterial`')
        panel.material = Material(path, params)
    end

    button.SetMaterial = function(panel, material)
        assert(material, 'no material provided')
        assert(type(material) == 'IMaterial', 'provided argument should be a IMaterial!')
        panel.material = material
    end

    button.SetIconURL = function(panel, url, params)
        assert(url, 'no url provided')
        panel.wimage = onyx.wimg.Simple(url, params)
    end

    return button
end

function PANEL:CloseSubMenu()
    if IsValid(self.activeSubmenu) then
        self.activeSubmenu:Close()
        self.activeSubmenu:CloseSubMenu()
    end
end

function PANEL:AddSubMenu(text)
    local submenu = vgui.Create('onyx.Menu')
    submenu:SetDeleteSelf(false)
    submenu.backgroundColor = self.backgroundColor
    submenu.outlineColor = self.outlineColor

    local button = self:AddOption(text)
    button:On('OnCursorEntered', function(panel)
        submenu:SetPos(self:GetX() + self:GetWide(), self:GetY() + panel:GetY())
        submenu:Open()
        submenu.parent = panel

        self.activeSubmenu = submenu
    end)
    button:On('Paint', function(panel, w, h)
        local sz = math.floor(h * .33)
        wimgArrow:DrawRotated(w - h * .5, h * .5, sz, sz, 90, panel:GetTextColor())
    end)
    button.submenu = true

    table.insert(self.submenus, submenu)

    return submenu, button
end

function PANEL:Open(parent)
    self:SetVisible(true)
    self:MakePopup()
    self:SetKeyBoardInputEnabled(false)
    self:InvalidateLayout(true)

    if (IsValid(parent)) then
        onyx.gui.InjectEventHandler(parent, 'OnRemove')
        onyx.gui.AddEvent(parent, 'OnRemove', function()
            if (IsValid(self)) then
                self:Remove()
            end
        end)
    end
end

function PANEL:Close()
    if (self.m_bDeleteSelf) then
        self:Remove()
    else
        self:SetVisible(false)
    end
end

function PANEL:OnRemove()
    for _, submenu in ipairs(self.submenus) do
        if (IsValid(submenu)) then
            submenu:Remove()
        end
    end
end

onyx.gui.Register('onyx.Menu', PANEL, 'onyx.ScrollPanel')

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .3, .65, function(self)
--     self:MakePopup()

--     local content = self:Add('Panel')
--     content:Dock(FILL)
--     content:DockMargin(5, 5, 5, 5)

--     for i = 1, 10 do
--         local btn = content:Add('onyx.ComboBox')
--         btn:Dock(TOP)
--         btn:DockMargin(0, 0 ,0 ,5)
--         btn.DoClick = function(panel)
--             local x, y = panel:LocalToScreen(0, 0)

--             y = y + panel:GetTall()

--             local menu = vgui.Create('onyx.Menu')
--             menu:SetPos(x, y)
--             menu:SetMinimumWidth(panel:GetWide())
--             menu:AddOption('Drop')
--             menu:AddOption('Sell')

--             local submenu = menu:AddSubMenu('Destroy')
--             -- submenu:AddOption('Confirm'):SetIcon('icon16/tick.png')
--             -- submenu:AddOption('Cancel'):SetIcon('icon16/cross.png')
--             submenu:AddOption('Confirm'):SetIconURL('https://i.imgur.com/iK1nMwr.png', 'smooth mips')
--             submenu:AddOption('Cancel'):SetIconURL('https://i.imgur.com/TF7kX2N.png', 'smooth mips')

--             menu:Open()
--         end
--     end

-- end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/languages/cl_english.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

18/05/2023

--]]

local LANG = {}

-- TABS
LANG.store_u = 'STORE'
LANG.inventory_u = 'INVENTORY'
LANG.refunds_u = 'REFUNDS'
LANG.convert_u = 'CONVERT'
LANG.admin_u = 'ADMIN'
LANG.donate_u = 'DONATE'

-- ADMIN TABS
LANG.players_u = 'PLAYERS'
LANG.items_u = 'ITEMS'
LANG.settings_u = 'SETTINGS'
LANG.return_u = 'RETURN'

-- WORDS
LANG.active_u = 'ACTIVE'
LANG.unactive_u = 'UNACTIVE'
LANG.owned_u = 'OWNED'
LANG.credits = 'Credits'
LANG.money = 'Money'
LANG.both = 'Both'
LANG.convert = 'Convert'
LANG.single = 'Single'
LANG.half = 'Half'
LANG.all = 'All'
LANG.icon = 'Icon'
LANG.model = 'Model'

-- OPTIONS
LANG.use = 'Use'
LANG.equip = 'Equip'
LANG.unequip = 'Unequip'
LANG.spawn = 'Spawn'
LANG.confirm = 'Confirm'
LANG.cancel = 'Cancel'
LANG.delete = 'Delete'

-- PHRASES
LANG.purchaseItem = 'Purchase "{item}"'
LANG.notEnoughCredits = 'Not enough credits!'
LANG.youMustBeAlive = 'You must be alive!'
LANG.requestRefund = 'Request Refund'
LANG.refundableUntil = 'REFUNDABLE UNTIL'
LANG.currentRate = 'Current rate: 1 credit = {rate}'
LANG.youGive = 'YOU GIVE'
LANG.youReceive = 'YOU RECEIVE'
LANG.giveItem = 'GIVE ITEM'
LANG.nothingToRefund = 'NOTHING TO REFUND'
LANG.healthIsFull = 'Your health is full!'
LANG.armorIsFull = 'Your armor is full!'
LANG.youRefunded = 'You have refunded {item} for {price} credits!'
LANG.youPurchased = 'You have purchased {item}!'
LANG.youConverted = 'You have converted {A} to {B}!'
LANG.cantAfford = 'You cannot afford that!'

LANG.createCategory = 'CREATE CATEGORY'
LANG.newItem = 'NEW ITEM'
LANG.edit_u = 'EDIT'
LANG.delete_u = 'DELETE'
LANG.create_u = 'CREATE'

LANG.searchName = 'Search by Name...'
LANG.searchNameSteamID = 'Search by Name/SteamID...'

-- ERRORS
LANG.idMustBeUnique = 'The identifier must be unique!'
LANG.fieldMustNumber = 'The {field} must be a number!'
LANG.fieldMustPositive = 'The {field} must be a positive number!'
LANG.fieldMustChoose = 'You must choose {field}!'
LANG.fieldEnter = 'You must enter {field}!'
LANG.invalidModel = 'The model is invalid!'
LANG.iconMustURL = 'The icon must be URL!'
LANG.invalidIconFormat = 'The icon must be .png or .jpg format!'
LANG.notEnoughSymbols = 'The {field} must contain at least {min} symbols!'
LANG.tooManySymbols = 'The {field} cannot contain more than {max} symbols!'

-- Types extracted from cl_french.lua
-- Just for a reference
--[[
LANG['Select an option'] = 'Choisir une option'

-- Types
LANG['Vehicle'] = 'Véhicule'
LANG['Health'] = 'Santé'
LANG['Armor'] = 'Armure'
LANG['Tool'] = 'Outil'
LANG['Trail'] = 'Sentier'
LANG['Permanent Booster'] = 'Booster permanent'
LANG['Permanent Weapon'] = 'Arme permanente'
LANG['Permanent Rank'] = 'Rang permanent'
LANG['Permanent Suit'] = 'Costume permanent'
LANG['Permanent Model'] = 'Modèle permanent'
LANG['Suit'] = 'Costume'
LANG['Accessory'] = 'Accessoire'
LANG['Entity'] = 'Entité'
LANG['Experience'] = 'Expérience'
LANG['Job'] = 'Emploi'
LANG['Money'] = 'Argent'
LANG['Weapon'] = 'Arme'
LANG['Console Command'] = 'Commande de la console'
LANG['Key'] = 'Clé'
LANG['Case'] = 'Caisse'

-- Fields
LANG['IDENTIFIER'] = 'IDENTIFIER'
LANG['TYPE'] = 'TYPE'
LANG['NAME'] = 'NOM'
LANG['PRICE'] = 'PRIX'
LANG['ICON'] = 'ICON'
LANG['ORDER'] = 'COMMANDE'
LANG['CATEGORY'] = 'CATÉGORIE'

LANG['IDENTIFIER_Desc'] = 'Saisir un identifiant unique.'
LANG['TYPE_Desc'] = 'Sélectionner le type de sujet.'
LANG['NAME_Desc'] = 'Saisir le nom.'
LANG['PRICE_Desc'] = 'Saisir la valeur de l\'élément.'
LANG['ICON_Desc'] = 'Saisir l\'image.'
LANG['ORDER_Desc'] = 'Saisissez un numéro pour classer les catégories.'
LANG['CATEGORY_Desc'] = 'Sélectionner une catégorie d\'articles.'
--]]

onyx.lang:AddPhrases('english', LANG)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/core/admin/sh_admin.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com
Licensee: 76561198843434426

23/04/2023

--]]

local creditstore = onyx.creditstore

do
    local validators = {}

    local function registerField(fieldID, fnCheck)
        validators[fieldID] = fnCheck
    end

    local function stringCheck(id, value, min, max)
        if (value == '') then
            return false, onyx.lang:Get('fieldEnter', {field = id:upper()}, true)
        end

        local len = utf8.len(value)

        if (len < min) then
            return false, onyx.lang:Get('notEnoughSymbols', {field = id:upper(), min = min}, true)
        end

        if (len > max) then
            return false, onyx.lang:Get('tooManySymbols', {field = id:upper(), max = max}, true)
        end

        return true
    end
    
    registerField('id', function(value)
        if (not isstring(value)) then return false end

        local validString, reason = stringCheck('identifier', value, 1, 16)

        if (not validString) then
            return false, reason
        end

        if (creditstore.items[value]) then
            return false, onyx.lang:Get('idMustBeUnique')
        end

        return true
    end)

    registerField('name', function(value)
        if (not isstring(value)) then return false end
        return stringCheck('name', value, 1, 24)
    end)

    registerField('price', function(value)
        value = tonumber(value)

        if (not value) then
            return false, onyx.lang:Get('fieldMustNumber', {field = 'PRICE'}, true)
        end

        if (value < 1) then
            return false, onyx.lang:Get('fieldMustPositive', {field = 'PRICE'}, true)
        end

        return true
    end)

    registerField('order', function(value)
        value = tonumber(value)

        if (not value) then
            return false, onyx.lang:Get('fieldMustNumber', {field = 'ORDER'}, true)
        end

        if (value < 1) then
            return false, onyx.lang:Get('fieldMustPositive', {field = 'ORDER'}, true)
        end

        return true
    end)

    registerField('type', function(value)
        if (value == '') then
            return false, onyx.lang:Get('fieldMustChoose', {field = 'TYPE'}, true)
        end

        if (not onyx.creditstore.types[value]) then
            return false, 'Invalid item type!'
        end

        return true
    end)

    registerField('category', function(value)
        if (value == '') then
            return false, onyx.lang:Get('fieldMustChoose', {field = 'CATEGORY'}, true)
        end

        if (not onyx.creditstore.categories[value]) then
            return false, 'Invalid category!'
        end

        return true
    end)

    registerField('model', function(value)
        if (value == '') then
            return false, onyx.lang:Get('fieldEnter', {field = 'model'}, true)
        end

        if (IsUselessModel(value)) then
            return false, onyx.lang:Get('invalidModel')
        end

        return true
    end)

    do
        local urlPatterns = {
            'https?://[^%s%\'%>%<]+',
            'http?://[^%s%\'%>%<]+',
        }

        local function isURL(text)
            for _, pattern in ipairs(urlPatterns) do
                if text:find(pattern) then
                    return true
                end
            end
            return false
        end
    
        registerField('icon', function(value)
            if (value == '') then
                return false, onyx.lang:Get('fieldEnter', {field = 'icon'}, true)
            end
    
            if (not isURL(value)) then
                return false, onyx.lang:Get('iconMustURL')
            end

            local ext = string.GetExtensionFromFilename(value)

            if (ext ~= 'jpg' and ext ~= 'png') then
                return false, onyx.lang:Get('invalidIconFormat')
            end
    
            return true
        end)
    end

    function creditstore:ValidateFieldValue(fieldID, value)
        local validator = validators[fieldID]
        assert(validator, 'unknown item field id (' .. fieldID .. ')')
        local valid, reason = validator(value)
        if (not valid) then
            return false, reason
        end
        return true
    end

    function creditstore:ValidatorExists(fieldID)
        return validators[fieldID] ~= nil
    end
end
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/core/convert/sh_convert.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com
Licensee: 76561198843434426

02/05/2023

--]]

local creditstore = onyx.creditstore

creditstore:RegisterOption('converter_enabled', {
    title = 'Enabled',
    desc = '(DarkRP) Enable converter module',
    category = 'Converter',
    cami = 'onyx_creditstore_edit',
    type = 'bool',
    default = false
})

creditstore:RegisterOption('converter_rate', {
    title = 'Rate',
    desc = 'The price of 1 credit',
    category = 'Converter',
    cami = 'onyx_creditstore_edit',
    type = 'int',
    default = 100,
    min = 1
})

creditstore:RegisterOption('converter_mode', {
    title = 'Mode',
    desc = 'The mode.',
    category = 'Converter',
    cami = 'onyx_creditstore_edit',
    type = 'int',
    default = 3,
    min = 1,
    max = 3,
    combo = {
        {'Credits → Money', 1},
        {'Money → Credits', 2},
        {'Both', 3}
    }
})

function creditstore:CalculateConvertResult(bToCredits, amount)
    local rate = self:GetOptionValue('converter_rate')
    local result = bToCredits and math.floor(amount / rate) or math.floor(amount * rate)

    return result
end
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/cfg/integrations/sh_advanced_accessories.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

15/05/2023

--]]

local INTEGRATION = {}

INTEGRATION.Name = 'Advanced Accessory'
INTEGRATION.Color = Color(63, 146, 184)
INTEGRATION.Desc = 'https://www.gmodstore.com/market/view/advanced-accessory-the-most-advanced-accessory-system'

function INTEGRATION:Check()
    return (AAS ~= nil)
end

function INTEGRATION:Load()
    onyx.creditstore:RegisterType('aas_accessory', {
        name = 'Accessory',
        color = Color(156, 0, 247),
        noDuplicates = true,
        setupModelPanel = function(dmodel, item)
            local data = item.data.accessory
            local accessory

            for _, data2 in ipairs(AAS.ClientTable["ItemsTable"]) do
                if (data2.uniqueId == data) then
                    accessory = data2
                    break
                end
            end

            local ent = dmodel.Entity
            if (accessory) then
                local min, max = ent:GetRenderBounds()
                local options = accessory.options
                local size = 0

                for _, key in ipairs({'x', 'y', 'z'}) do
                    size = math.max(size, math.abs(min[key]) + math.abs(max[key]))
                end

                dmodel:SetCamPos(Vector(size, size, size))

                if istable(options) then
                    local iconFov = options["iconFov"]
                    local iconPos = options["iconPos"]

                    if isnumber(iconFov) then
                        dmodel:SetFOV(50 + iconFov)
                    end

                    if isvector(iconPos) then
                        dmodel:SetLookAt((min + max) * .5 + iconPos)
                    end
                end

                dmodel.LayoutEntity = function() end
            end
        end,
        customCheck = function(ply, item)
            local uniqueID = item.data.accessory

            if (CLIENT) then
                local inventory = AAS.ClientTable.ItemsInventory
                for _, data in pairs(inventory) do
                    if (data.uniqueId == uniqueID) then
                        return false, onyx.lang:Get('owned_u')
                    end
                end
            else
                return (not ply:AASIsBought(uniqueID)), 'You already have it!'
            end
        end,
        options = {
            ['use'] = {
                removeItem = true,
                check = function(ply, data)
                    if (not ply:Alive()) then
                        return false, onyx.lang:Get('youMustBeAlive')
                    end

                    return true
                end,
                func = function(ply, data)
                    local uniqueID = data.accessory
                    local accessory

                    for _, data in pairs(AAS.Table.items) do
                        if (data.uniqueId == uniqueID) then
                            accessory = data
                            break
                        end
                    end

                    if (not accessory) then
                        return false
                    end

                    AAS.GiveItem(ply:SteamID64(), uniqueID, 0)
                end
            }
        },
        settings = {
            {
                key = 'accessory',
                name = 'ACCESSORY',
                desc = 'The accessory.',
                icon = 'https://i.imgur.com/zgt3zea.png',
                type = 'combo',
                getOptions = function()
                    local options = {}

                    for _, data in ipairs(AAS.ClientTable["ItemsTable"]) do
                        table.insert(options, {
                            text = (data.category or 'Unknown') .. ' | ' .. data.name,
                            data = data.uniqueId
                        })
                    end

                    table.sort(options, function(a, b)
                        return a.text < b.text
                    end)

                    return options
                end,
                onChoose = function(index, text, data, fields)
                    local accessory

                    for _, data2 in ipairs(AAS.ClientTable["ItemsTable"]) do
                        if (data2.uniqueId == data) then
                            accessory = data2
                            break
                        end
                    end

                    if (accessory) then
                        local model = accessory.model or 'models/error.mdl'

                        fields.icon.picker:ChooseOptionID(2)

                        fields.icon.entry:SetValue(model)
                        fields.icon.entry:Highlight(onyx.GetOppositeAccentColor(), 3)

                        fields.name.entry:SetValue(accessory.name)
                        fields.name.entry:Highlight(onyx.GetOppositeAccentColor(), 3)
                    end
                end,
                validateOption = function(data)
                    -- do not be lazy to do this function, it is also used on the server side to validate value
                    if (not data) then return false, 'You must choose an accessory!' end

                    if (SERVER) then
                        local items = AAS.Table.items
                        local found = false

                        for _, accessory in pairs(items) do
                            if (accessory.uniqueId == data) then
                                found = true
                                break
                            end
                        end

                        if (not found) then
                            return false, 'invalid item'
                        end
                    end

                    return true
                end
            }
        }
    })
end

onyx.creditstore:RegisterIntegration('aas', INTEGRATION)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/cfg/integrations/sh_realistic_car_dealer.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

15/05/2023

--]]

local INTEGRATION = {}

INTEGRATION.Name = 'Realistic Car Dealer'
INTEGRATION.Color = Color(63, 146, 184)
INTEGRATION.Desc = 'https://www.gmodstore.com/market/view/realistic-car-dealer-the-best-car-dealer-system'

function INTEGRATION:Check()
    return (RCD ~= nil)
end

function INTEGRATION:Load()
    onyx.creditstore:RegisterType('rcd_vehicle', {
        name = 'Vehicle',
        fullName = '[RCD] Vehicle',
        color = Color(156, 0, 247),
        noDuplicates = true,
        customCheck = function(ply, item)
            local uniqueID = item.data.vehicleid

            if (CLIENT) then
                local inventory = RCD.ClientTable.vehiclesBought or {}
                for _, data in pairs(inventory) do
                    if (data.vehicleId == uniqueID) then
                        return false, onyx.lang:Get('owned_u')
                    end
                end
            else
                return (not ply:RCDGetVehicleBought(uniqueID)), 'You already have it!'
            end
        end,
        options = {
            ['use'] = {
                removeItem = true,
                check = function(ply, data)
                    if (not ply:Alive()) then
                        return false, onyx.lang:Get('youMustBeAlive')
                    end
    
                    return true
                end,
                func = function(ply, data)
                    local uniqueID = data.vehicleid
                    local vehicleTable
        
                    for _, data in ipairs(AAS.Table.items) do
                        if (data.uniqueId == uniqueID) then
                            vehicleTable = data
                            break
                        end
                    end
    
                    if (not vehicleTable) then
                        return false
                    end
    
                    RCD.GiveVehicle(ply, uniqueID)
                end
            }
        },
        settings = {
            {
                key = 'vehicleid',
                name = 'VEHICLE',
                desc = 'The vehicle.',
                icon = 'https://i.imgur.com/zgt3zea.png',
                type = 'combo',
                getOptions = function()
                    local options = {}

                    for _, data in pairs(RCD.AdvancedConfiguration["vehiclesList"] or {}) do
                        table.insert(options, {
                            text = data.name,
                            data = data.id
                        })
                    end
            
                    table.sort(options, function(a, b)
                        return a.text < b.text
                    end)
            
                    return options
                end,
                onChoose = function(index, text, data, fields)
                    local vehicle

                    for _, data2 in pairs(RCD.AdvancedConfiguration["vehiclesList"] or {}) do
                        if (data2.id == data) then
                            vehicle = data2
                            break
                        end
                    end

                    if (vehicle) then
            
                        fields.name.entry:SetValue(vehicle.name)
                        fields.name.entry:Highlight(onyx.GetOppositeAccentColor(), 3)

                        local vehData = list.Get('Vehicles')[vehicle.class]
                        if (vehData) then
                            local model = vehData.Model or 'models/error.mdl'
    
                            fields.icon.picker:ChooseOptionID(2)
                
                            fields.icon.entry:SetValue(model)
                            fields.icon.entry:Highlight(onyx.GetOppositeAccentColor(), 3)
                        end
                    end
                end,
                validateOption = function(data)
                    -- do not be lazy to do this function, it is also used on the server side to validate value
                    if (not data) then return false, 'You must choose a vehicle!' end

                    if (SERVER) then
                        local items = RCD.GetVehicles() or {}
                        local found = false

                        for _, vehicle in pairs(items) do
                            if (vehicle.id == data) then
                                found = true
                                break
                            end
                        end

                        if (not found) then
                            return false, 'invalid item'
                        end
                    end
            
                    return true
                end
            }
        }
    })
end

onyx.creditstore:RegisterIntegration('rcd', INTEGRATION)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/cfg/types/sh_command.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

01/05/2023

--]]

local blocked = {
    ['bot'] = true,
    ['lua_run'] = true,
    ['lua_run_sv'] = true,
    ['rcon'] = true,
    ['sv_password'] = true,
}

onyx.creditstore:RegisterType('runconsolecommand', {
    name = 'Console Command',
    color = Color(119, 119, 119),
    options = {
        ['use'] = {
            removeItem = true,
            func = function(ply, data)
                local command = data.command:gsub('{steamid64}', ply:SteamID64()):Trim()

                game.ConsoleCommand(command .. '\n')
            end
        }
    },
    settings = {
        {
            key = 'command',
            name = 'COMMAND',
            desc = 'The command to execute to the console.',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'string',
            validateOption = function(data)
                -- do not be lazy to do this function, it is also used on the server side to validate value
                if (not isstring(data) or data == '') then return false, 'You must fill the command field!' end

                local args = string.Explode(' ', data)
                local cmd = args[1]

                if (blocked[cmd]) then
                    return false, 'This command is blocked: \"' .. cmd .. '\"'
                end

                return true
            end
        }
    }
})
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/ui/cl_frame.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2023

--]]

local PANEL = {}

local colorAccent = onyx:Config('colors.accent')
local wimgLoading = onyx.wimg.Simple('https://i.imgur.com/VVswRpx.png', 'smooth mips')
local font0 = onyx.Font('Comfortaa Bold@20')
local font1 = onyx.Font('Comfortaa@16')
local font2 = onyx.Font('Comfortaa Bold@16')
local colorGray = Color(144, 144, 144)
local wimgCoin = onyx.wimg.Create('creditstore_currency', 'smooth mips')

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')

function PANEL:Init()
    local client = LocalPlayer()

    onyx.creditstore.frame = self

    self.container = self:Add('Panel')
    self.container.PaintOver = function(p, w, h)
        local text1 = 'LOADING INVENTORY'
        local text2 = 'PROCESSING THINGS'
        local subtext = 'Please do not disconnect'
        local bProcessing = LocalPlayer():onyx_GetNetVar('store_busy')
        local bInventoryLoaded = LocalPlayer():onyx_GetNetVar('store_loaded')
        local show = bProcessing or not bInventoryLoaded
        local text = bProcessing and text2 or text1

        if (show) then
            onyx.DrawBlurExpensive(p, 3)

            local maxSize = onyx.ScaleTall(64)
            local size = maxSize * .5 + maxSize * .5 * math.abs(math.sin(CurTime()))
            
            wimgLoading:DrawRotated(w * .5, h * .5, size, size, (CurTime() * 100) % 360)

            local textY = h * .5 + maxSize * .5 + onyx.ScaleTall(10)

            local _, texth = draw.SimpleText(text, font0, w * .5, textY, color_white, 1, 0)
            draw.SimpleText(subtext, font1, w * .5, textY + texth, colorGray, 1, 0)
        end

        p:SetMouseInputEnabled(not show)
    end

    self.sidebar = self:Add('onyx.Sidebar')
    self.sidebar:SetContainer(self.container)
    self.sidebar:SetKeepTabContent(true)

    local padding = onyx.ScaleTall(8)
    local profile = self.sidebar:Add('Panel')
    profile:Dock(TOP)
    profile:DockMargin(0, 0, 0, onyx.ScaleTall(5))
    profile:SetTall(onyx.ScaleTall(50))
    profile:DockPadding(padding, padding, padding, padding)
    profile.Paint = function(panel, w, h)
        local size = onyx.ScaleTall(14)

        -- -- 1var.
        -- nothing

        -- -- 2var.
        -- draw.RoundedBox(8, 0, 0, w, h, colorPrimary)

        -- -- 3var.
        -- draw.RoundedBox(8, 0, 0, w, h, colorPrimary)
        -- draw.RoundedBox(8, 1, 1, w - 2, h - 2, colorSecondary)

        -- 4var.
        -- draw.RoundedBox(8, 0, 0, w, h, colorTertiary)
        -- draw.RoundedBox(8, 1, 1, w - 2, h - 2, colorSecondary)

        -- 5var.
        -- draw.RoundedBox(8, 0, 0, w, h, colorTertiary)

        -- 6var.
        -- draw.RoundedBox(8, 0, 0, w, h, colorTertiary)
        -- draw.RoundedBox(8, 1, 1, w - 2, h - 2, colorPrimary)

        draw.SimpleText(client:Name(), font2, h, h * .5, color_white, 0, 4)

        local _, texth = draw.SimpleText(onyx.creditstore:GetCredits(client), font2, h + size + onyx.ScaleWide(5), h * .5, colorAccent, 0, 0)
        wimgCoin:Draw(h, h * .5 + texth * .5 - size * .5, size, size, colorAccent)
    end

    local avatar = profile:Add('onyx.RoundedAvatar')
    avatar:SetPlayer(client, 64)
    avatar:SetWide(profile:GetTall() - padding * 2)
    avatar:Dock(LEFT)
    -- avatar.PerformLayout = function(panel, w, h)
    --     panel.mask = onyx.CalculateRoundedBox(8, 0, 0, w, h)
    -- end

    self:SetTitle('Onyx Store')
    self:LoadTabs()
end

function PANEL:PerformLayout(w, h)
    self.BaseClass.PerformLayout(self, w, h)

    self.sidebar:SetWide(w * .2)
    self.sidebar:Dock(LEFT)

    local p = onyx.ScaleTall(15)
    
    self.container:Dock(FILL)
    self.container:DockPadding(p, p, p, p)
end

function PANEL:LoadTabs()
    self.sidebar:AddTab({
        name = onyx.lang:Get('store_u'),
        desc = 'Purchase fancy stuff',
        icon = 'https://i.imgur.com/agUmpea.png',
        class = 'onyx.creditstore.Shop'
    })

    self.sidebar:AddTab({
        name = onyx.lang:Get('inventory_u'),
        desc = 'Manage your items',
        icon = 'https://i.imgur.com/JnyDkrG.png',
        class = 'onyx.creditstore.Inventory',
        onSelected = function(content)
            content:MakePlayerInventory()
        end
    })

    if (onyx.creditstore:GetOptionValue('refunds_enabled')) then
        self.sidebar:AddTab({
            name = onyx.lang:Get('refunds_u'),
            desc = 'Refund your purchases',
            icon = 'https://i.imgur.com/pjwbqs2.png',
            class = 'onyx.creditstore.Refunds'
        })
    end

    if (DarkRP and onyx.creditstore:GetOptionValue('converter_enabled')) then
        self.sidebar:AddTab({
            name = onyx.lang:Get('convert_u'),
            desc = 'Convert money and credits',
            icon = 'https://i.imgur.com/nkd7Twr.png',
            class = 'onyx.creditstore.Converter'
        })
    end

    CAMI.PlayerHasAccess(LocalPlayer(), 'onyx_creditstore_see_inventory', function(bAllowed)
        if (bAllowed and IsValid(self.sidebar)) then
            self.sidebar:AddTab({
                name = onyx.lang:Get('admin_u'),
                desc = 'Configuration',
                icon = 'https://i.imgur.com/0OE893O.png',
                onClick = function()
                    self:Remove()
                    onyx.creditstore.OpenAdminSettings()
                    
                    return false
                end
            })
        end
        
    end)

    local donateStr = onyx.lang:Get('donate_u')
    local colorDonate = Color(255 ,204, 65)
    local websiteURL = onyx.creditstore:GetOptionValue('website_url')
    if (onyx.creditstore:GetOptionValue('website_ingame')) then
        self.sidebar:AddTab({
            name = donateStr,
            desc = 'Receive premium currency',
            wimg = 'creditstore_currency',
            class = 'HTML',
            donate = true,
    
            nameColor = colorDonate,
            iconColor = colorDonate,
            descColor = onyx.ColorEditHSV(colorDonate, nil, .25, .75),
    
            onSelected = function(panel)
                panel:OpenURL(websiteURL)
                panel.OnBeginLoadingDocument = function(panel)
                    if (not panel.bLoaded) then
                        panel.bLoading = true
                    end
                end
                panel.OnFinishLoadingDocument = function(panel)
                    panel.bLoading = nil
                    panel.bLoaded = true
                end
                panel.PaintOver = function(panel, w, h)
                    if (panel.bLoading) then
                        local maxSize = onyx.ScaleTall(64)
                        local size = maxSize * .5 + maxSize * .5 * math.abs(math.sin(CurTime()))
                        
                        wimgLoading:DrawRotated(w * .5, h * .5, size, size, (CurTime() * 100) % 360)
                    end
                end
            end
        })
    else
        self.sidebar:AddTab({
            name = donateStr,
            desc = 'Receive premium currency',
            wimg = 'creditstore_currency',
            donate = true,
    
            nameColor = colorDonate,
            iconColor = colorDonate,
            descColor = onyx.ColorEditHSV(colorDonate, nil, .25, .75),
    
            onClick = function(panel)
                gui.OpenURL(websiteURL)
                return false
            end
        })
    end

    self.sidebar:ChooseTab(1)
end

onyx.gui.Register('onyx.creditstore.Frame', PANEL, 'onyx.Frame')

-- ANCHOR Test

-- onyx.gui.Test('onyx.creditstore.Frame', .65, .65, function(self)
--     self:MakePopup()
-- end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/ui/cl_inventory.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

08/03/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')
local font0 = onyx.Font('Comfortaa Bold@16')
local font1 = onyx.Font('Comfortaa@16')
local colorGray = onyx:Config('colors.gray')
local colorGreen = onyx:Config('colors.positive')
local colorRed = onyx:Config('colors.negative')
local wimgCoin = onyx.wimg.Create('creditstore_currency', 'smooth mips')

AccessorFunc(PANEL, 'm_bHideDeletedItems', 'HideDeletedItems')

function PANEL:Init()
    self.toolbar = self:Add('Panel')
    self.toolbar:Dock(TOP)
    self.toolbar:SetTall(onyx.ScaleTall(35))
    self.toolbar:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    local padding = onyx.ScaleTall(5)
    self.toolbar.Paint = function(p, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    end

    self.toolbar:DockPadding(padding, padding, padding, padding)

    self.search = self.toolbar:Add('onyx.TextEntry')
    self.search:SetPlaceholderText(onyx.lang:Get('searchName'))
    self.search:SetPlaceholderIcon('https://i.imgur.com/Nk3IUJT.png', 'smooth mips')
    self.search:Dock(LEFT)
    self.search:SetWide(onyx.ScaleWide(150))
    self.search:SetUpdateOnType(true)
    self.search.OnValueChange = function(panel, value)
        value = onyx.utf8.lower(value)

        local layout = self.content
        local items = layout:GetChildren()
        local visibleItemAmount = 0

        for _, item in ipairs(items) do
            if (onyx.utf8.lower(item:GetName()):find(value, nil, true)) then
                item:SetVisible(true)
                visibleItemAmount = visibleItemAmount + 1
            else
                item:SetVisible(false)
            end
        end

        layout:InvalidateLayout()
    end

    self.list = self:Add('onyx.ScrollPanel')
    self.list:Dock(FILL)

    self.content = self.list:Add('onyx.Grid')
    self.content:Dock(TOP)
    self.content:SetTall(0)
    self.content:SetSpaceX(onyx.ScaleTall(10))
    self.content:SetSpaceY(self.content:GetSpaceX())
    self.content:SetColumnCount(5)
    self.content:SetSizeRatio(1.25)

    self:SetHideDeletedItems(false)
end

local function translateOption(key)
    return onyx.lang:Get(key)
end

function PANEL:MakePlayerInventory()
    self:SetHideDeletedItems(true)

    hook.Add('onyx.credistore.InventoryUpdated', self, function(panel)
        panel:LoadItems(onyx.creditstore:GetPlayerInventory(LocalPlayer()))
    end)

    self:LoadItems(onyx.creditstore:GetPlayerInventory(LocalPlayer()))
    self.DoSlotClick = function(self, panel, it)
        local itemTypeData = panel.itemTypeData
        if (not itemTypeData) then return end

        local options = table.Copy(itemTypeData.options or {})
    
        if (itemTypeData.equip) then
            if (panel.equipped) then
                options['unequip'] = {}
            else
                options['equip'] = {}
            end
        end

        if (table.IsEmpty(options)) then return end

        local menu = vgui.Create('onyx.Menu')
        menu:ToCursor()

        for key, option in pairs(options) do
            local name = translateOption(key)
            menu:AddOption(name, function()
                local allowed, reason
                if (option.check) then
                    allowed, reason = option.check(LocalPlayer(), panel.itemTable.data)
                else
                    allowed = true
                end

                if (allowed == false) then
                    if (reason) then
                        notification.AddLegacy(reason, 1, 4)
                    end
                else
                    net.Start('onyx.creditstore:UseOption')
                        net.WriteUInt(it.index, 16)
                        net.WriteString(key)
                    net.SendToServer()
                end
            end)
        end

        menu:Open()
    end
end

local colorShade = Color(0, 0, 0, 50)
local colorGradient = Color(0, 0, 0, 150)
function PANEL:LoadItems(items)
    for _, child in ipairs(self.content:GetChildren()) do
        child:Remove()
    end

    --[[------------------------------
    Sort items
    --------------------------------]]
    local itemsCopy = table.Copy(items)
    local sortedItems = {}
    local tStackingList = {}

    for index, it in ipairs(itemsCopy) do
        local id = it.id

        local stackingBaseItemSortedIndex = tStackingList[id]
        if stackingBaseItemSortedIndex then
            local stackingBaseItem = itemsCopy[stackingBaseItemSortedIndex]
            
            stackingBaseItem.amount = stackingBaseItem.amount + 1
            table.insert(stackingBaseItem.list, index)

            goto CONTINUE 
        end

        local invalid = false
    
        local itemTable = onyx.creditstore.items[id]
        if (not itemTable) then invalid = true end
        
        local typeData = itemTable and onyx.creditstore.types[itemTable.type]
        if (not typeData) then invalid = true end

        if (not invalid) then
            if (typeData.stacking) then
                it.amount = 1
                it.list = {}
    
                tStackingList[id] = index
            end
        elseif (self.m_bHideDeletedItems) then
            goto CONTINUE
        end

        it.index = index
        it.sortedIndex = table.insert(sortedItems, it)

        ::CONTINUE::
    end

    table.sort(sortedItems, function(a, b)
        local aData = onyx.creditstore.items[a.id]
        local bData = onyx.creditstore.items[b.id]

        local aType = aData and aData.type or ''
        local bType = bData and bData.type or ''

        if (aType == bType) then
            local aName = aData and aData.name or ''
            local bName = bData and bData.name or ''
            
            return aName < bName
        end

        return aType < bType
    end)

    local textActive = onyx.lang:Get('active_u')
    local textUnactive = onyx.lang:Get('unactive_u')
    local textOwned = onyx.lang:Get('owned_u')
    
    --[[------------------------------
    Add items
    --------------------------------]]
    for _, it in ipairs(sortedItems) do
        local id = it.id
        local data = it.data or {}
        local amount = it.amount
        local item = items[id]
            
        local slot = self.content:Add('onyx.creditstore.Item')
        slot:SetItem(id, data)
        slot:SetPriceTagVisible(false)
        slot:InjectEventHandler('Paint')
        slot:On('Paint', function(p, w, h)
            local headerHeight = h * .2

            draw.RoundedBoxEx(8, 0, h - headerHeight, w, headerHeight, colorShade, nil, nil, true, true)
            -- draw.SimpleText('OWNED' .. (amount and (' (x' .. amount .. ')') or ''), font1, w * .5, h - headerHeight * .5, colorGray, 1, 1)
            if (p.itemTypeData and p.itemTypeData.equip) then
                if (p.equipped) then
                    draw.SimpleText(textActive, font0, w * .5, h - headerHeight * .5, colorGreen, 1, 1)
                    -- onyx.DrawTextInBox('ACTIVE', font0, w * .5, h - headerHeight * .5, 8, onyx.ScaleWide(10), onyx.ScaleTall(5), color_black, colorGreen)
                else
                    draw.SimpleText(textUnactive, font0, w * .5, h - headerHeight * .5, colorGray, 1, 1)
                end
            else
                if (amount) then
                    onyx.DrawTextInBox(amount .. 'x', font0, w * .5, h - headerHeight * .5, 8, onyx.ScaleWide(10), onyx.ScaleTall(5), color_white, colorShade)
                else
                    draw.SimpleText(textOwned, font0, w * .5, h - headerHeight * .5, colorGray, 1, 1)
                end
            end

            -- if (amount) then
            --     draw.SimpleText('x' .. amount, font1, w - onyx.ScaleWide(10), headerHeight * .5, color_white, 2, 1)
            -- end
        end)
        slot.PerformLayout = function(panel, w, h)
            local button = panel.button
            local headerHeight = h * .2
            if (IsValid(button)) then
                local buttonHeight = headerHeight * .66
                
                -- button:SetWide(w * .66)
                button:SetTall(buttonHeight)
                button:SetPos(0, h - headerHeight * .5 - buttonHeight * .5)
                button:CenterHorizontal()
            end
        end

        slot.DoClick = function(panel)
            self:Call('DoSlotClick', nil, panel, it)
        end

        slot.amount = amount or 1
        
        -- local button = slot:Add('onyx.Button')
        -- button:SetText('USE')
        -- button:Font('Comfortaa Bold@16')
        -- button:SizeToContentsX(onyx.ScaleWide(30))
        slot.button = button
    end
end

onyx.gui.Register('onyx.creditstore.Inventory', PANEL)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/languages/cl_german.lua:
--[[
 
Ersteller: tochnonement
E-Mail: tochnonement@gmail.com
 
Übersetzer: thestarhd
Profil: https://www.gmodstore.com/users/76561198801156110
 
05/01/2024
 
--]]
 
local LANG = {}
 
-- REITER
LANG.f4_jobs_u = 'JOBS'
LANG.f4_jobs_desc = 'Wähle deinen Weg'
 
LANG.f4_dashboard_u = 'DASHBOARD'
LANG.f4_dashboard_desc = 'Allgemeine Informationen'
 
LANG.f4_shop_u = 'SHOP'
LANG.f4_shop_desc = 'Kaufe beliebige Waren'
 
LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Addon konfigurieren'
 
LANG.f4_donate_u = 'SPENDEN'
LANG.f4_donate_desc = 'Unterstütze den Server'
 
LANG.addon_settings_u = 'EINSTELLUNGEN'
LANG.addon_settings_desc = 'Addon konfigurieren'
 
LANG.addon_return_u = 'ZURÜCK'
LANG.addon_return_desc = 'Zurück zum Rahmen'
 
-- Sonstiges
LANG.f4_salary = 'Gehalt'
LANG.f4_price = 'Preis'
LANG.f4_loading = 'Laden'
LANG.f4_purchases = 'Einkäufe'
LANG.f4_switches = 'Schalter'
LANG.f4_unavailable = 'Nicht verfügbar'
LANG.f4_description_u = 'BESCHREIBUNG'
LANG.f4_weapons_u = 'WAFFEN'
LANG.f4_entities_u = 'ENTITÄTEN'
LANG.f4_ammo_u = 'MUNITION'
LANG.f4_food_u = 'NAHRUNG'
LANG.f4_shipments_u = 'SENDUNGEN'
LANG.f4_become_u = 'WERDE'
LANG.f4_create_vote_u = 'UMFRAGE ERSTELLEN'
LANG.f4_general_u = 'ALLGEMEIN'
LANG.f4_police_u = 'POLIZEI'
LANG.f4_mayor_u = 'BÜRGERMEISTER'
LANG.f4_confirm_u = 'BESTÄTIGEN'
LANG.f4_cancel_u = 'ABBRECHEN'
LANG.f4_mostpopular_u = 'AM BELIEBTESTEN'
LANG.f4_chart_u = 'DIAGRAMM'
LANG.f4_loading_u = 'LADEN'
LANG.f4_empty_u = 'LEER'
 
LANG.f4_playersonline_u = 'SPIELER ONLINE'
LANG.f4_totalmoney_u = 'GESAMTGELD'
LANG.f4_staffonline_u = 'TEAMMITGLIEDER ONLINE'
LANG.f4_actions_u = 'AKTIONEN'
 
-- Aktionen
LANG['f4_action_input_amount'] = 'Menge eingeben'
LANG['f4_action_input_text'] = 'Text eingeben'
LANG['f4_action_input_reason'] = 'Grund eingeben'
LANG['f4_action_choose_player'] = 'Spieler auswählen'
 
LANG['f4_action_confirm_action'] = 'Aktion bestätigen'
LANG['f4_action_drop_money'] = 'Geld fallen lassen'
LANG['f4_action_give_money'] = 'Geld geben'
LANG['f4_action_change_name'] = 'Namen ändern'
LANG['f4_action_drop_weapon'] = 'Waffe fallen lassen'
LANG['f4_action_sell_doors'] = 'Alle Türen verkaufen'
 
LANG['f4_action_warrant'] = 'Durchsuchungsbefehl erstellen'
LANG['f4_action_wanted'] = 'Gesucht'
 
LANG['f4_toggle_lockdown'] = 'Lockdown umschalten'
LANG['f4_give_license'] = 'Lizenz geben'
 
-- Phrasen
LANG['f4_search_text'] = 'Nach Name suchen...'
 
-- Einstellungen
LANG['f4.option_url_desc'] = 'URL eingeben (leer lassen, um zu deaktivieren)'
 
LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Trete unserem Discord-Server bei'
 
LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Triff die Community'
 
LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Trete unserer Steam-Gruppe bei'
 
LANG['f4.rules_url.name'] = 'Regeln'
LANG['f4.rules_url.desc'] = 'Kenne die Regeln'
 
LANG['f4.donate_url.name'] = 'Spenden'
 
LANG['f4.website_ingame.name'] = 'Browser'
LANG['f4.website_ingame.desc'] = 'Verwende den Ingame-Browser, um die Website-URL zu öffnen'
 
LANG['f4.title.name'] = 'Titel'
LANG['f4.title.desc'] = 'Der Titel für den Rahmen'
 
LANG['f4.hide_donate_tab.name'] = 'Spenden-Tab ausblenden'
LANG['f4.hide_donate_tab.desc'] = 'Blendet den Tab Spenden aus'
 
LANG['f4.edit_job_colors.name'] = 'Jobfarben bearbeiten'
LANG['f4.edit_job_colors.desc'] = 'Sollen Jobfarben heller angezeigt werden'
 
LANG['f4.hide_admins.name'] = 'Admins-Abschnitt ausblenden'
LANG['f4.hide_admins.desc'] = 'Blendet den Dashboard-Admin-List-Abschnitt aus'
 
LANG['f4.admin_on_duty.name'] = 'Admin-Job aktiviert'
LANG['f4.admin_on_duty.desc'] = 'Zeigt als Admin nur eine Person mit einem bestimmten Job an'
 
LANG['f4.admin_on_duty_job.name'] = 'Admin-Jobname'
LANG['f4.admin_on_duty_job.desc'] = 'Der Jobname des Admins*'
 
LANG['f4.colored_items.name'] = 'Farbiger Verlauf'
LANG['f4.colored_items.desc'] = 'Aktiviere leichten Farbverlauf auf Gegenständen/Jobs'
 
LANG['f4.item_columns.name'] = 'Spalten'
LANG['f4.item_columns.desc'] = 'Die Anzahl der Spalten für Gegenstände'
 
LANG['f4.job_columns.name'] = 'Spalten'
LANG['f4.job_columns.desc'] = 'Die Anzahl der Spalten für Jobs'
 
LANG['f4.model_3d.name'] = '3D-Modelle'
LANG['f4.model_3d.desc'] = 'Aktiviere Echtzeit-Rendering für Item-/Job-Symbole'
 
LANG['f4.item_show_unavailable.name'] = 'Nicht verfügbare Gegenstände'
LANG['f4.item_show_unavailable.desc'] = 'Zeige Gegenstände an, die customCheck nicht bestanden haben'
 
LANG['f4.job_show_unavailable.name'] = 'Nicht verfügbare Jobs'
LANG['f4.job_show_unavailable.desc'] = 'Zeige Jobs an, die customCheck nicht bestanden haben'
 
LANG['f4.job_show_requirejob.name'] = 'Abhängige Jobs'
LANG['f4.job_show_requirejob.desc'] = 'Zeige Jobs an, die aufgrund des falschen Jobs des Spielers nicht gewählt werden können'
 
onyx.lang:AddPhrases('german', LANG)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/core/sh_core.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

function onyx.f4.GetPlayerLevel(ply, fallback)
    if (ply.getLevel) then
        return ply:getLevel()
    elseif (LevelSystemConfiguration) then
        return ply:getDarkRPVar('level')
    end
    return fallback
end

CAMI.RegisterPrivilege({
    Name = 'onyx_f4_edit',
    MinAccess = 'superadmin',
    Description = 'Allows to configure Onyx F4'
})

onyx.f4:RegisterOption('title', {
    title = 'f4.title.name',
    desc = 'f4.title.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = 'ONYX F4'
})

onyx.f4:RegisterOption('colored_items', {
    title = 'f4.colored_items.name',
    desc = 'f4.colored_items.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('edit_job_colors', {
    title = 'f4.edit_job_colors.name',
    desc = 'f4.edit_job_colors.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('hide_admins', {
    title = 'f4.hide_admins.name',
    desc = 'f4.hide_admins.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('hide_donate_tab', {
    title = 'f4.hide_donate_tab.name',
    desc = 'f4.hide_donate_tab.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('admin_on_duty', {
    title = 'f4.admin_on_duty.name',
    desc = 'f4.admin_on_duty.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('admin_on_duty_job', {
    title = 'f4.admin_on_duty_job.name',
    desc = 'f4.admin_on_duty_job.desc',
    category = 'General',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = 'Admin on Duty'
})

onyx.f4:RegisterOption('item_columns', {
    title = 'f4.item_columns.name',
    desc = 'f4.item_columns.desc',
    category = 'Items',
    cami = 'onyx_f4_edit',
    type = 'int',
    min = 1,
    max = 3,
    default = 3
})

onyx.f4:RegisterOption('item_show_unavailable', {
    title = 'f4.item_show_unavailable.name',
    desc = 'f4.item_show_unavailable.desc',
    category = 'Items',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('job_columns', {
    title = 'f4.job_columns.name',
    desc = 'f4.job_columns.desc',
    category = 'Jobs',
    cami = 'onyx_f4_edit',
    type = 'int',
    min = 1,
    max = 3,
    default = 2
})

onyx.f4:RegisterOption('job_show_unavailable', {
    title = 'f4.job_show_unavailable.name',
    desc = 'f4.job_show_unavailable.desc',
    category = 'Jobs',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('job_show_requirejob', {
    title = 'f4.job_show_requirejob.name',
    desc = 'f4.job_show_requirejob.desc',
    category = 'Jobs',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

onyx.f4:RegisterOption('model_3d', {
    title = 'f4.model_3d.name',
    desc = 'f4.model_3d.desc',
    category = 'Performance',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = false
})

--[[------------------------------
URL
--------------------------------]]

onyx.f4:RegisterOption('website_ingame', {
    title = 'f4.website_ingame.name',
    desc = 'f4.website_ingame.desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'bool',
    default = true
})

onyx.f4:RegisterOption('discord_url', {
    title = 'f4.discord_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('forum_url', {
    title = 'f4.forum_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('steam_url', {
    title = 'f4.steam_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('rules_url', {
    title = 'f4.rules_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})

onyx.f4:RegisterOption('donate_url', {
    title = 'f4.donate_url.name',
    desc = 'f4.option_url_desc',
    category = 'Links',
    cami = 'onyx_f4_edit',
    type = 'string',
    default = ''
})
--PATH addons/____onyx_hud/lua/onyx/modules/hud/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/07/2024

--]]

onyx:Addon( 'hud', {
    color = Color( 99, 65, 211 ),
    author = 'tochnonement',
    version = '1.1.1',
    licensee = '76561198843434426'
} )

----------------------------------------------------------------

onyx.Include( 'sv_sql.lua' )
onyx.IncludeFolder( 'onyx/modules/hud/languages/' )
onyx.IncludeFolder( 'onyx/modules/hud/core/', true )
onyx.IncludeFolder( 'onyx/modules/hud/cfg/', true )
onyx.IncludeFolder( 'onyx/modules/hud/elements/' )
onyx.IncludeFolder( 'onyx/modules/hud/ui/' )

onyx.hud:Print( 'Finished loading.' )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/languages/cl_spanish.lua:
--[[

Editor: Benjaa635 | Rusherr
GmodStore Profile: https://www.gmodstore.com/users/Rusherr635

13/10/2024

--]]

local LANG = {}

--[[
    .............
    Palabras generales
]]--

LANG[ 'hud_status_wanted' ] = 'Buscado'
LANG[ 'hud_status_speaking' ] = 'Hablando'
LANG[ 'hud_status_typing' ] = 'Escribiendo'
LANG[ 'props' ] = 'Objetos'
LANG[ 'close' ] = 'Cerrar'
LANG[ 'alert' ] = 'Alerta'
LANG[ 'message' ] = 'Mensaje'
LANG[ 'unknown' ] = 'Desconocido'
LANG[ 'accept' ] = 'Aceptar'
LANG[ 'deny' ] = 'Denegar'
LANG[ 'none' ] = 'Ninguno'
LANG[ 'add' ] = 'Añadir'
LANG[ 'remove' ] = 'Eliminar'
LANG[ 'jobs' ] = 'Trabajos'
LANG[ 'door' ] = 'Puerta'
LANG[ 'vehicle' ] = 'Vehículo'
LANG[ 'door_groups' ] = 'Grupos de puertas'
LANG[ 'display' ] = 'Pantalla'
LANG[ 'general' ] = 'General'
LANG[ 'speedometer' ] = 'Velocímetro'
LANG[ 'fuel' ] = 'Combustible'
LANG[ 'vote' ] = 'Votar'
LANG[ 'question' ] = 'Pregunta'


--[[
    .......
    Timeout
]]--

LANG[ 'timeout_title' ] = 'CONEXIÓN PERDIDA'
LANG[ 'timeout_info' ] = 'El servidor no está disponible en este momento, lo sentimos'
LANG[ 'timeout_status' ] = 'Serás reconectado en %d segundos'


--[[
    ......
    Themes
]]--

LANG[ 'hud.theme.default.name' ] = 'Predeterminado'
LANG[ 'hud.theme.forest.name' ] = 'Bosque'
LANG[ 'hud.theme.violet_night.name' ] = 'Noche Violeta'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Brasa Rústica'
LANG[ 'hud.theme.green_apple.name' ] = 'Manzana Verde'
LANG[ 'hud.theme.lavender.name' ] = 'Lavanda'
LANG[ 'hud.theme.elegance.name' ] = 'Elegancia'
LANG[ 'hud.theme.mint_light.name' ] = 'Menta'
LANG[ 'hud.theme.gray.name' ] = 'Gris'
LANG[ 'hud.theme.rose_garden.name' ] = 'Jardín de Rosas'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Olas del Océano'
LANG[ 'hud.theme.sky_blue.name' ] = 'Cielo Azul'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Amanecer Dorado'

--[[
    ....
    Help
    - Frase completa: "Escribe <commando> para abrir la configuracion"
]]

LANG[ 'hud_help_type' ] = 'Escribe'
LANG[ 'hud_help_to' ] = 'para abrir la configuracion'


--[[
    .............
    Puertas 3D2D
]]--

LANG[ 'door_purchase' ] = 'Comprar {object}'
LANG[ 'door_sell' ] = 'Vender {object}'
LANG[ 'door_addowner' ] = 'Agregar propietario'
LANG[ 'door_rmowner' ] = 'Eliminar propietario'
LANG[ 'door_rmowner_help' ] = 'Elige al jugador al que deseas revocar la propiedad'
LANG[ 'door_addowner_help' ] = 'Elige al jugador al que deseas otorgar la propiedad'
LANG[ 'door_title' ] = 'Establecer título'
LANG[ 'door_title_help' ] = '¿Qué título deseas establecer?'
LANG[ 'door_admin_disallow' ] = 'Prohibir propiedad'
LANG[ 'door_admin_allow' ] = 'Permitir propiedad'
LANG[ 'door_admin_edit' ] = 'Editar acceso'
LANG[ 'door_owned' ] = 'Propiedad Privada'
LANG[ 'door_unowned' ] = 'En Venta'

LANG[ 'hud_door_help' ] = 'Presiona {bind} para comprar por {price}'
LANG[ 'hud_door_owner' ] = 'Propietario: {name}'
LANG[ 'hud_door_allowed' ] = 'Permitido poseer'
LANG[ 'hud_door_coowners' ] = 'Copropietarios'
LANG[ 'hud_and_more' ] = 'y más...'


--[[
    .........
    Uppercase
]]--

LANG[ 'reconnect_u' ] = 'RECONEXIÓN'
LANG[ 'disconnect_u' ] = 'DESCONECTAR'
LANG[ 'settings_u' ] = 'AJUSTES'
LANG[ 'configuration_u' ] = 'CONFIGURACIÓN'
LANG[ 'introduction_u' ] = 'INTRODUCCIÓN'


--[[
    .........
    Lowercase
]]--

LANG[ 'seconds_l' ] = 'segundos'
LANG[ 'minutes_l' ] = 'minutos'

--[[
    .............
    Configuration
]]--

LANG[ 'hud.timeout.name' ] = 'Duración del Tiempo de Espera'
LANG[ 'hud.timeout.desc' ] = 'Cuántos segundos antes de la reconexión automática'

LANG[ 'hud.alert_queue.name' ] = 'Cola de Alertas'
LANG[ 'hud.alert_queue.desc' ] = '¿Deben colocarse las alertas en cola?'

LANG[ 'hud.props_counter.name' ] = 'Contador de Objetos'
LANG[ 'hud.props_counter.desc' ] = 'Mostrar contador de objetos'

LANG[ 'hud.main_avatar_mode.name' ] = 'Tipo de Avatar Principal'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Elige el tipo'

LANG[ 'hud.voice_avatar_mode.name' ] = 'Tipo de Avatar de Voz'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Elige el tipo'

LANG[ 'hud.restrict_themes.name' ] = 'Restringir Temas'
LANG[ 'hud.restrict_themes.desc' ] = 'Restringir a los jugadores la elección de temas'

LANG[ 'hud.speedometer_mph.name' ] = 'Usar Millas'
LANG[ 'hud.speedometer_mph.desc' ] = 'Cambiar unidades a millas por hora'

LANG[ 'hud.speedometer_max_speed.name' ] = 'Velocidad Máxima Predeterminada'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'La velocidad máxima para el velocímetro'

LANG[ 'hud_should_draw' ] = 'Debe dibujar el elemento'
LANG[ 'hud.main.name' ] = 'HUD Principal'
LANG[ 'hud.ammo.name' ] = 'Munición'
LANG[ 'hud.agenda.name' ] = 'Agenda'
LANG[ 'hud.alerts.name' ] = 'Alertas'
LANG[ 'hud.pickup_history.name' ] = 'Historial de Recolección'
LANG[ 'hud.level.name' ] = 'Nivel'
LANG[ 'hud.voice.name' ] = 'Paneles de Voz'
LANG[ 'hud.overhead_health.name' ] = 'Salud Superior 3D2D'
LANG[ 'hud.overhead_armor.name' ] = 'Armadura Superior 3D2D'
LANG[ 'hud.vehicle.name' ] = 'HUD de Vehículo'


--[[
    ........
    Ajustes
]]--

LANG[ 'hud.theme.name' ] = 'Tema'
LANG[ 'hud.theme.desc' ] = 'Elige el tema del HUD'

LANG[ 'hud.scale.name' ] = 'Escala'
LANG[ 'hud.scale.desc' ] = 'Ajusta la escala del HUD'

LANG[ 'hud.roundness.name' ] = 'Redondez'
LANG[ 'hud.roundness.desc' ] = 'Ajusta la redondez del HUD'

LANG[ 'hud.margin.name' ] = 'Margen'
LANG[ 'hud.margin.desc' ] = 'La distancia entre el HUD y los bordes'

LANG[ 'hud.icons_3d.name' ] = 'Modelos 3D'
LANG[ 'hud.icons_3d.desc' ] = 'Renderizar íconos de modelo en 3D'

LANG[ 'hud.compact.name' ] = 'Modo Compacto'
LANG[ 'hud.compact.desc' ] = 'Habilitar el modo compacto'

LANG[ 'hud.speedometer_blur.name' ] = 'Desenfoque del Velocímetro'
LANG[ 'hud.speedometer_blur.desc' ] = 'Habilitar el desenfoque para el velocímetro'

LANG[ 'hud.3d2d_max_details.name' ] = 'Máximo de Detalles 3D2D'
LANG[ 'hud.3d2d_max_details.desc' ] = 'La cantidad máxima de información detallada que se renderiza'

--[[
    ......
    Status
]]--

LANG[ 'hud_lockdown' ] = 'TOQUE DE QUEDA'
LANG[ 'hud_lockdown_help' ] = '¡Por favor, regresen a sus hogares!'

LANG[ 'hud_wanted' ] = 'BUSCADO'
LANG[ 'hud_wanted_help' ] = 'Razón: {reason}'

LANG[ 'hud_arrested' ] = 'ARRESTADO'
LANG[ 'hud_arrested_help' ] = 'Serás liberado en {time}'


onyx.lang:AddPhrases( 'spanish', LANG )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/core/sh_config.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

19/08/2024

--]]

local function createDisplayOption( id, default )
    if ( default == nil ) then default = true end

    onyx.hud:RegisterOption( 'display_' .. id, {
        title = 'hud.' .. id .. '.name',
        desc = 'hud_should_draw',
        category = 'display',
        cami = 'onyx_hud_edit',
        type = 'bool',
        default = default
    } )
end

CAMI.RegisterPrivilege({
    Name = 'onyx_hud_edit',
    MinAccess = 'superadmin',
    Description = 'Allows to configure Onyx HUD'
})

onyx.hud:RegisterOption( 'timeout', {
    title = 'hud.timeout.name',
    desc = 'hud.timeout.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 45,
    min = 15,
    max = 180
} )

onyx.hud:RegisterOption( 'alert_queue', {
    title = 'hud.alert_queue.name',
    desc = 'hud.alert_queue.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'props_counter', {
    title = 'hud.props_counter.name',
    desc = 'hud.props_counter.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'restrict_themes', {
    title = 'hud.restrict_themes.name',
    desc = 'hud.restrict_themes.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'main_avatar_mode', {
    title = 'hud.main_avatar_mode.name',
    desc = 'hud.main_avatar_mode.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 0,
    min = 0,
    max = 1,
    combo = {
        { 'Avatar', 0 },
        { 'Model', 1 }
    }
} )

onyx.hud:RegisterOption( 'voice_avatar_mode', {
    title = 'hud.voice_avatar_mode.name',
    desc = 'hud.voice_avatar_mode.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 0,
    min = 0,
    max = 1,
    combo = {
        { 'Avatar', 0 },
        { 'Model', 1 }
    }
} )

onyx.hud:RegisterOption( 'hud_bar_type', {
    title = 'hud.hud_bar_type.name',
    desc = 'hud.hud_bar_type.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 0,
    min = 0,
    max = 2,
    combo = {
        { 'No Number', 0 },
        { 'Number', 1 },
        { 'Color Number', 2 },
    }
} )

-- Speedometer

onyx.hud:RegisterOption( 'speedometer_mph', {
    title = 'hud.speedometer_mph.name',
    desc = 'hud.speedometer_mph.desc',
    category = 'speedometer',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'speedometer_max_speed', {
    title = 'hud.speedometer_max_speed.name',
    desc = 'hud.speedometer_max_speed.desc',
    category = 'speedometer',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 260,
    min = 180,
    max = 300
} )

-- Display

createDisplayOption( 'main' )
createDisplayOption( 'ammo' )
createDisplayOption( 'agenda' )
createDisplayOption( 'pickup_history' )
createDisplayOption( 'voice' )
createDisplayOption( 'alerts' )
createDisplayOption( 'vehicle' )
createDisplayOption( 'level' )
createDisplayOption( 'notifications' )
createDisplayOption( 'overhead_health', false )
createDisplayOption( 'overhead_armor', false )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_overhead.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

11/08/2024

--]]

local hud = onyx.hud
local nearest = {}
local statuses = {}

local MAX_DISTANCE = 400 ^ 2
local MAX_GLOBAL_DRAWS = 12

local CONVAR_MAX_DETAILED = CreateClientConVar( 'cl_onyx_hud_3d2d_max_details', '3', true, false, '', 1, 5 )

local COLOR_LOW_HP = Color( 255, 59, 59)
local COLOR_MAX_HP = Color( 115, 255, 49)
local COLOR_ARMOR = Color( 52, 130, 255)
local COLOR_RED = Color( 255, 52, 52)
local COLOR_BLUE = Color( 55, 52, 255)
local COLOR_SLIGHT_SHADOW = Color( 0, 0, 0, 150 )
local ICON_SIZE = 64
local WIMG_LICENSE = onyx.wimg.Create( 'hud_license', 'smooth mips' )

local FONT_NAME = onyx.hud.CreateFont3D2D( 'OverheadName', 'Comfortaa Bold', 72 )
local FONT_JOB = onyx.hud.CreateFont3D2D( 'OverheadJob', 'Comfortaa SemiBold', 40 )
local FONT_STATUS = onyx.hud.CreateFont3D2D( 'OverheadStatus', 'Comfortaa Bold', 64 )

local drawShadowText = onyx.hud.DrawShadowText

local getStatuses, hasStatus do
    local function createStatus( data )
        data.wimg = onyx.wimg.Create( data.icon, 'smooth mips' )
        table.insert( statuses, data )
    end

    function getStatuses( ply )
        local result = {}
        for _, status in ipairs( statuses ) do
            if ( status.func( ply ) ) then
                table.insert( result, status )
            end
        end
        return result
    end

    -- Quicker than checking by amount
    function hasStatus( ply )
        for _, status in ipairs( statuses ) do
            if ( status.func( ply ) ) then
                return true
            end
        end
        return false
    end

    createStatus( {
        id = 'wanted',
        icon = 'hud_wanted',
        big = true,
        func = function( ply )
            return ply:IsWanted()
        end,
        getColor = function()
            local fraction = math.abs( math.sin( CurTime() ) )
            local color = onyx.LerpColor( fraction, COLOR_RED, COLOR_BLUE )
            return color
        end
    } )

    createStatus( {
        id = 'speaking',
        icon = 'hud_microphone',
        func = function( ply )
            return ply:IsSpeaking()
        end
    } )

    createStatus( {
        id = 'typing',
        icon = 'hud_chat',
        func = function( ply )
            return ply:IsTyping()
        end
    } )
end

local function drawStatus( ply, y )
    local halfIconSize = ICON_SIZE * .5
    local iconSpace = 10
    local statuses = getStatuses( ply )
    local amount = #statuses
    local totalW = amount * ICON_SIZE + ( amount - 1 ) * iconSpace
    local iconX = -totalW * .5
    local isSingle = amount == 1

    -- Draw microphone
    for i = 1, amount do
        local status = statuses[ i ]
        local color = status.getColor and status.getColor() or ( status.color or hud:GetColor( 'accent' ) )

        if ( isSingle and status.big ) then
            status.text = status.text or onyx.lang:Get( 'hud_status_' .. status.id )
            local text = status.text

            if ( status.dots ) then
                text = text .. string.rep( '.', CurTime() % 4 )
            end
        
            surface.SetFont( FONT_STATUS )
            local textW, textH = surface.GetTextSize( text )
            
            iconX = iconX - ( textW + iconSpace ) * .5

            drawShadowText( text, FONT_STATUS, iconX + ICON_SIZE + iconSpace, y + ICON_SIZE * .5 - textH * .5, color )
        end

        status.wimg:Draw( iconX + 2, y + 2, ICON_SIZE, ICON_SIZE, COLOR_SLIGHT_SHADOW )
        status.wimg:Draw( iconX, y, ICON_SIZE, ICON_SIZE, color )
    
        iconX = iconX + ICON_SIZE + iconSpace
    end
end

local function drawQuickInfo( ply, client )
    drawStatus( ply, 0 )
end

local function drawInfo( ply, client )
    
    local shouldDrawHealth = hud.IsElementEnabled( 'overhead_health' )

    local currentY = 0

    drawStatus( ply, -ICON_SIZE )

    if ply:onyx_GetNetVar('Disgue') then
        drawShadowText( '*Лице Приховано*', FONT_NAME, 0, currentY, color_white, 1, 0 )
        currentY = currentY + 65
    else
        local playerName = ply:Name()
        local teamName = ply:GetJob()
        local teamColor = ply:GetJobColor()
        if ply:onyx_GetNetVar('Disguise_G') then
            teamColor = sam.player.get_nwvar(ply, 'Job_Color') or color_white
        end
        local hasLicense = ply:HasLicense()

        -- Draw name
        if ( hasLicense ) then
            local iconSize = 32
            local iconSpace = 15

            surface.SetFont( FONT_NAME )
            local nameTextW, nameTextH = surface.GetTextSize( playerName )
            
            local nameX = ( nameTextW + iconSize + iconSpace ) * -.5
            local iconY = currentY + nameTextH * .5 - iconSize * .5
            
            WIMG_LICENSE:Draw( nameX + nameTextW + iconSpace + 2, iconY + 2, iconSize, iconSize, COLOR_SLIGHT_SHADOW )
            WIMG_LICENSE:Draw( nameX + nameTextW + iconSpace, iconY, iconSize, iconSize )

            drawShadowText( playerName, FONT_NAME, nameX, currentY, color_white )
            currentY = currentY + 65
        else
            drawShadowText( playerName, FONT_NAME, 0, currentY, color_white, 1, 0 )
            currentY = currentY + 65
        end

        -- Draw team
        drawShadowText( teamName, FONT_JOB, 0, currentY, teamColor, 1, 0 )
        currentY = currentY + 40
    end

    -- Draw health & armor
    if ( shouldDrawHealth ) then
        local healthInt = ply:Health()
        local healthFraction = math.Clamp( healthInt / ply:GetMaxHealth(), 0, 1 )
        local healthColor = onyx.LerpColor( healthFraction, COLOR_LOW_HP, COLOR_MAX_HP )
        
        local armorInt = ply:Armor()
        local shouldDrawArmor = armorInt > 0 and hud.IsElementEnabled( 'overhead_armor' )

        local healthText = healthInt .. ' HP'
        
        if ( shouldDrawArmor ) then
            healthText = healthText .. '  '
            local armorText = armorInt .. ' AP'

            surface.SetFont( FONT_JOB )
            local healthTextWidth = surface.GetTextSize( healthText )
            local armorTextWidth = surface.GetTextSize( armorText )
            local totalTextWidth = healthTextWidth + armorTextWidth
            local textX = -totalTextWidth * .5
        
            drawShadowText( healthText, FONT_JOB, textX, currentY, healthColor )
            drawShadowText( armorText, FONT_JOB, textX + healthTextWidth, currentY, COLOR_ARMOR )
        else
            drawShadowText( healthText, FONT_JOB, 0, currentY, healthColor, 1, 0 )
        end

        currentY = currentY + 30
    end
end

timer.Create( 'onyx.hud.CollectNearestPlayers', 1 / 10, 0, function()
    local client = LocalPlayer()
    if ( IsValid( client ) ) then
        nearest = {}

        -- Make sure that any random error (if there is any) won't break the timer
        ProtectedCall( function()
            local origin = client:GetPos()
            local aimVector = client:GetAimVector()
        
            for _, ply in ipairs( player.GetAll() ) do
                local playerPos = ply:GetPos()
                if ( ply ~= client and ply:Alive() and ply:GetColor().a > 50 and ply:Health() > 0 and not ply:GetNoDraw() and ply:GetRenderMode() ~= RENDERMODE_NONE and playerPos:DistToSqr( origin ) <= MAX_DISTANCE ) then
                    local dotProduct = aimVector:Dot( ( playerPos - origin ):GetNormalized() )
                    if ( dotProduct > .6 ) then
                        table.insert( nearest, {
                            ply = ply,
                            dot = dotProduct
                        } )
                    end
                end
            end

            table.sort( nearest, function( a, b )
                return a.dot > b.dot
            end )
        end )
    end
end )

hook.Add( 'PostDrawTranslucentRenderables', 'onyx.hud.DrawOverheadInfo', function()
    local client = LocalPlayer()
    local index = 0

    for _, object in ipairs( nearest ) do
        local ply = object.ply
        if ( IsValid( ply ) ) then
            index = index + 1
            if ( index > MAX_GLOBAL_DRAWS ) then break end

            local detailed = index <= CONVAR_MAX_DETAILED:GetInt()
            local shouldDraw = detailed or hasStatus( ply )

            if ( shouldDraw ) then
                local _, maxs = ply:GetRenderBounds()
                local jobTable = rp.Team[ply:Team()] or {}
                local heightOffset = jobTable.onyxOverheadOffset or ( maxs.z + 10 )
                local pos = ply:GetPos() + Vector( 0, 0, heightOffset )
                local ang = Angle( 0, client:EyeAngles().y - 90, 90 )
                
                cam.Start3D2D( pos, ang, 0.075 )
                    if ( detailed ) then
                        drawInfo( ply, client )
                    else
                        drawQuickInfo( ply, client )
                    end
                cam.End3D2D()
            end
        end
    end
end )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/ui/cl_choice_wheel.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local SPOLY_ID = 'onyx_hud_wheel_background_3'

do
    onyx.spoly.Generate( SPOLY_ID, function(w, h)
        local scaledThickness = h * .25

        local x = w * .5
        local y = h * .5
        local r = h * .5
        local vertices = 64

        local circleInner = onyx.CalculateCircle(x, y, r - scaledThickness, vertices)
        local circleOuter = onyx.CalculateCircle(x, y, r, vertices)

        onyx.InverseMaskFn(function()
            surface.DrawPoly(circleInner)
        end, function()
            surface.DrawPoly(circleOuter)
        end)
    end )
end

local PANEL = {}

AccessorFunc( PANEL, 'm_bShowLabel', 'ShowLabel' )

function PANEL:Init()
    local colors = onyx.hud:GetCurrentTheme().colors

    self.m_bShowLabel = false
    self.choices = {}
    self.fraction = 0
    self.colors = {
        primary = colors.primary,
        secondary = colors.secondary,
        tertiary = colors.tertiary,
        accent = colors.accent,
        textPrimary = colors.textPrimary,
        textSecondary = colors.textSecondary
    }

    self:Open()

    -- A new hook added in July patch
    -- It is going to replace gui.HideGameUI, so let's prepare to that moment
    -- https://wiki.facepunch.com/gmod/GM:OnPauseMenuShow
    hook.Add( 'OnPauseMenuShow', self, function( this )
        self:Close()
        return false
    end )
end

function PANEL:PerformLayout( w, h )
    self:UpdateSegments()
end

local choiceFont = onyx.Font( 'Comfortaa Bold@16' )
function PANEL:Paint( w, h )
    local colors = self.colors
    local x0, y0 = math.Round( w * .5 ), math.Round( h * .5 )
    local r = h * .5

    local animSpeed = FrameTime() * 8

    -- Draw segments
    for _, choice in ipairs( self.choices ) do
        if ( choice.valid ) then
            local isHovered = choice.isHovered
            local bgColor = isHovered and colors.secondary or colors.primary
            local textColor = isHovered and colors.accent or colors.textSecondary
            local outlineColor = not isHovered and colors.tertiary or colors.accent

            choice.outlineColor = onyx.LerpColor( animSpeed, choice.outlineColor or outlineColor, outlineColor )                                                                                                                                -- 9bd46d08-b472-493c-8cb7-294505375bac
            choice.bgColor = onyx.LerpColor( animSpeed, choice.bgColor or bgColor, bgColor )

            local cos, sin = choice.cos, choice.sin
            local choiceX0 = x0 + cos * r * .75
            local choiceY0 = y0 + sin * r * .75
            local name = choice.name
            local iconSize = math.Round( r * .125 )

            -- Calculate text height
            surface.SetFont( choiceFont )
            local _, textH = surface.GetTextSize( name )

            -- Draw background
            onyx.DrawWithPolyMask( choice.mask, function()
                onyx.spoly.Draw( SPOLY_ID, 0, 0, w, h, choice.bgColor )
                onyx.DrawOutlinedCircle( x0, y0, r, 1, choice.outlineColor )
            end )

            -- Draw content
            if ( choice.wimg ) then
                choice.wimg:DrawRotated( choiceX0, choiceY0, iconSize, iconSize, 0, textColor )
            else 
                draw.DrawText( name, choiceFont, choiceX0, choiceY0 - textH * .5, textColor, 1 )
            end
        end
    end

    -- Draw lines
    for _, choice in ipairs( self.choices ) do
        if ( choice.valid ) then
            local lineRad = math.rad( choice.startAng - 90 )
            local lineCos, lineSin = math.cos( lineRad ), math.sin( lineRad )

            surface.SetDrawColor( colors.tertiary )
            surface.DrawLine( 
                x0 + lineCos * r * .5,
                y0 + lineSin * r * .5,
                x0 + lineCos * r * 1,
                y0 + lineSin * r * 1
             )
        end
    end

    -- Draw label
    local hoveredChoice = self.hoveredChoice
    if ( hoveredChoice and self:GetShowLabel() ) then
        local name = hoveredChoice.name
        
        surface.SetFont( choiceFont )
        local textW, textH = surface.GetTextSize( name )
        local labelPadding = r * .05
        local labelW = textW + labelPadding * 2
        local labelH = textH + labelPadding * 2
        local labelX = x0 - labelW * .5
        local labelY = y0 - labelH * .5

        draw.RoundedBox( 8, labelX, labelY, labelW, labelH, colors.primary )
        draw.DrawText( name, choiceFont, x0, labelY + labelPadding, colors.textPrimary, 1 )
    end
end

function PANEL:Think()
    if ( not self._CLOSED ) then
        self:HandleEscape()
        self:HandleControls()
        if ( self.PostThink ) then
            self:PostThink()
        end
    end
end

function PANEL:HandleEscape()
    if ( input.IsKeyDown( KEY_ESCAPE ) ) then
        if ( gui.HideGameUI ) then gui.HideGameUI() end
        self:Close()
    end
end

function PANEL:HandleControls()
    local w, h = self:GetSize()
    local x, y = input.GetCursorPos()
    local curPos = Vector( x, y )
    local centerPos = Vector( ScrW() * .5, ScrH() * .5 )
    local relX, relY = self:ScreenToLocal( x, y )
    
    relX = relX - ( w * .5 )
    relY = relY - ( h * .5 )

    local ang = ( math.deg( math.atan2( relY, relX ) ) + 90 ) % 360
    local distance = curPos:Distance( centerPos )
    local hoveredChoice

    for _, choice in ipairs( self.choices ) do
        if ( choice.valid ) then
            local startAngle = choice.startAng
            local endAngle = choice.endAng
            local isHovered = ( 
                self:IsHovered()
                and ang > startAngle 
                and ang < endAngle
                and distance > h * .25
                and distance < h * .5
            )
    
            choice.isHovered = isHovered

            if ( isHovered ) then
                hoveredChoice = choice
            end
        end
    end

    self.hoveredChoice = hoveredChoice
end

function PANEL:OnMouseReleased( mouseCode )
    local hoveredChoice = self.hoveredChoice
    if ( mouseCode == MOUSE_LEFT and hoveredChoice ) then
        self:HandleClick( hoveredChoice )
    end
end

function PANEL:HandleClick( choice )
    local clickFn = choice.clickFn or choice.callback
    
    if ( not choice.ignoreClose ) then
        self:Close()
    end

    if ( clickFn ) then
        clickFn( self )
    end
end

function PANEL:UpdateSegments()
    local w, h = self:GetSize()
    if ( w < 1 or h < 1 ) then return end

    local x0, y0 = w * .5, h * .5
    local choices = self.choices
    local amount = #choices

    local segmentAng = ( 360 / amount )

    for index = 1, amount do
        local choice = choices[ index ]
        if ( choice ) then
            local startAng = ( index - 1 ) * segmentAng
            local endAng = startAng + segmentAng
            local betweenAng = startAng + segmentAng * .5
            local rad = math.rad( betweenAng - 90 )
    
            choice.startAng = startAng
            choice.endAng = endAng
            choice.segmentAng = segmentAng
        
            choice.cos = math.cos( rad )
            choice.sin = math.sin( rad )
            choice.mask = onyx.CalculateArc( x0, y0, startAng, segmentAng - 0, math.ceil( h * .5 ) + 1, 24, true )

            choice.valid = true
        end
    end
end

function PANEL:AddChoice( data )
    if ( data.iconURL ) then
        data.wimg = onyx.wimg.Simple( data.iconURL, 'smooth mips' )
    elseif ( data.wimg ) then
        data.wimg = wimg
    elseif ( data.wimgID ) then
        data.wimg = onyx.wimg.Create( data.wimgID, 'smooth mips' )
    end

    table.insert( self.choices, data )
    self:UpdateSegments()
end

function PANEL:Close()
    self._CLOSED = true
    self:SetMouseInputEnabled( false )
    self:SetKeyBoardInputEnabled( false )

    onyx.anim.Create( self, .2, {
        index = 1,
        easing = 'inOutQuad',
        target = { fraction = 0 },
        think = function( _, this )
            this:SetAlpha( this.fraction * 255 )
        end,
        onFinished = function( _, this )
            this:Remove()
        end
    } )
end

function PANEL:Open()
    self:SetAlpha( 0 )

    onyx.anim.Create( self, .2, {
        index = 1,
        easing = 'inOutQuad',
        target = { fraction = 1 },
        think = function( _, this )
            this:SetAlpha( this.fraction * 255 )
        end
    } )
end

onyx.gui.Register( 'onyx.hud.ChoiceWheel', PANEL )

-- DEBUG

-- onyx.gui.oldDebugPanel:Remove()
-- onyx.gui.Test( 'onyx.hud.ChoiceWheel', 1, 1, function( this )
--     this:SetSize( 512, 512 )
--     this:Center()
--     this:MakePopup()
--     for i = 1, 8 do
        
--         this:AddChoice({ name = string.format( 'Button %d', i ), wimgID = 'hud_heart' })
--     end
-- end )
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/core/integrations/cl_brick_gangs.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

12/03/2024

--]]

local stored = {}

function onyx.scoreboard.GetBricksGangName(gangID)
    return (stored[gangID] or '')
end

net.Receive('onyx.scoreboard(Bricks.Gangs):Replace', function(len)
    local id = net.ReadUInt(16)
    local name = net.ReadString()
    stored[id] = name
end)

net.Receive('onyx.scoreboard(Bricks.Gangs):Remove', function(len)
    stored[net.ReadUInt(16)] = nil
end)

netchunk.Callback('onyx.scoreboard:SyncBrickGangs', function(data, len)
    stored = data
    onyx.scoreboard:Print('Synchronized brick\'s gangs (#)', len)
end)
--PATH addons/_outfitter/lua/includes/modules/sqlext.lua:
--https://gist.github.com/Python1320/eec8cdc84828a8261b00

AddCSLuaFile()

local sql=sql

local tablevers

-- http://www.sqlite.org/lang_corefunc.html#last_insert_rowid
function sql.LastRowID()
	local ret = sql.Query("SELECT last_insert_rowid() as x")[1].x
	return ret
end

setmetatable(sql,{__call=function(self,query,...)
	local t = {...}
	for k,v in next,t do
		if isstring(v) then
			t[k] = sql.SQLStr(v)
		elseif isbool(v) then
			v=tostring(v)
		end
	end
	query = query..';'
	if #t > 0 then
		query = query:format(unpack(t))
	end
	local ret = sql.Query(query)
	
	assert(ret~=true,'uuuhoh')
	if ret == false then
		return nil,sql.LastError()..' (Query: '..query..')'
	elseif ret == nil then
		return true
	else
		return ret
	end
end})

-- http://www.tutorialspoint.com/sqlite/sqlite_date_time.htm
local escape=sql.SQLStr
local function gen_datefunc(fname)
	local beginning = "SELECT "..fname.."("
	local function func(...)
		
		local mods = {...}
		for k,v in next,mods do
			mods[k]=isnumber(v) and v or escape(v)
		end
		local q=beginning..table.concat(mods,",")..") as x;"

		local ret = sql.Query(q)
		ret = ret and ret[1]
		ret = ret and ret.x
		ret = ret and ret~="NULL" and ret
		
		return ret
		
	end
	
	sql[fname]=func
end

gen_datefunc 'date'
gen_datefunc 'time'
gen_datefunc 'datetime'
gen_datefunc 'julianday'
gen_datefunc 'strftime'
	
	
	
	


local mt = {}
function mt:create(infos,after,...)
	local name = getmetatable(self).name
	assert(name)
	if not sql.TableExists(name) then
		MsgN("Creating ",name)
		assert(sql(("CREATE TABLE %%s (%s) %s"):format(infos,after or ""),name,...))
		if tablevers then
			tablevers:update("ver = 0 WHERE name = %s",name)
		end
	end
	return self
end

function mt:coerce(kv)
	getmetatable(self).coerce = kv
	return self
end

function mt:drop()
	local name = getmetatable(self).name
	if sql.TableExists(name) then
		assert(sql(("DROP TABLE %s"):format(name)))
	end
	return self
end
function mt:insert(kv,or_replace)
	local name = getmetatable(self).name
	
	local keys,values={},{}
	local i=0
	for k,v in pairs(kv) do
		i=i+1
		keys[i] = sql.SQLStr(k)
		values[i] = (isnumber(v)) and tostring(v)
		or v==true and 1
		or v==false and 0
		or isstring(v) and sql.SQLStr(v)
		or error"Invalid input"
	end
	
	local a,b = sql(("INSERT %sINTO %s (%s) VALUES (%s)"):format(or_replace and "OR REPLACE " or "",name,table.concat(keys,", "),table.concat(values,", ")))
	if a==true then
		return tonumber(sql.LastRowID())
	end
	return a,b
end

function mt:coercer(a,...)
	local coerce = getmetatable(self).coerce
	if coerce and a and a~=true then
		for i=1,#a do
			local t = a[i]
			for k,v in next,t do
				local coercer = coerce[k]
				if coercer then
					t[k] = coercer(v)
				end
			end
		end
	end
	return a,...
end
function mt:select(vals,extra,...)
	local name = getmetatable(self).name
	
	return self:coercer(self:sql(("SELECT %s FROM %s %s"):format(vals,name,extra or ""),...))
end


local function return_changes(a,...)
	if a==true then
		local changes = tonumber(sql'SELECT changes() as changes'[1].changes)
		return changes
	end
	return a,...
end
function mt:update(extra,...)
	local name = getmetatable(self).name
	local query = ("UPDATE %s SET %s"):format(name,extra)
	return return_changes( self:sql( query ,...) )
end

function mt:alter(extra,...)
	local name = getmetatable(self).name
	local query = ("ALTER TABLE %s %s"):format(name,extra)
	return assert(return_changes( self:sql( query ,...) ))
end

function mt:delete(extra,...)
	local name = getmetatable(self).name
	local query = ("DELETE FROM %s WHERE %s"):format(name,extra)
	return return_changes( self:sql( query ,...) )
end

local function firstval(a,...)
	if a and a~=true then assert(not a[2]) return a[1] end
	return a,...
end
function mt:select1(...) return firstval(self:select(...)) end


function mt:sql(a,...)
	local t = {...}
	local name = getmetatable(self).name
	
	for k,v in next,t do
		local mt = istable(v) and getmetatable(v)
		if mt and mt.name then t[k] = mt.name end
	end
	
	return sql(a,unpack(t))
end
function mt:sql1(...) return firstval(self:sql(...)) end

local function columns(a,b)
	if a then
		return a[1].name
	end
	return a,b
end
function mt:columns()
	local name = getmetatable(self).name
	if sql.TableExists(name) then
		return columns(sql("PRAGMA table_info(%s)",name))
	end
	return nil,'no such table'
end


function sql.obj(name)
	return setmetatable({name=name},{name=name,__index=mt})
end


local ok,err = xpcall(function()
	local t = assert(sql.obj("sqlext"))
		:create([[
			`name`		TEXT NOT NULL CHECK(name <> '') UNIQUE,
			`ver`		INTEGER NOT NULL DEFAULT 0]])
		:coerce{ver=tonumber}
	tablevers = t
end,debug.traceback)
if not ok then
	ErrorNoHalt(err..'\n')
end

local function read_table_version(name)
	if not tablevers then return nil,'tablevers unavailable' end
	local ret,err = tablevers:select("*","WHERE name = %s",name)
	if ret == nil then return nil,err end
	if ret == true then return false end
	return ret and ret[1] and ret[1].ver or false
end

function mt:migrate(cb)
	local info = getmetatable(self)
	
	local name = info.name
	local _ver = (info._ver or 0) + 1
	info._ver = _ver
	
	if info._migrate_errors then return nil,'migration errors' end
	
	local table_version = read_table_version(name)
	if table_version == nil then
		return self
	elseif not table_version then
		table_version = 0
		tablevers:insert{name=name,ver=1}
	end
	if _ver <= table_version then
		return self
	end
	
	local ok,ret = xpcall(cb,debug.traceback,self,name)
	
	if not ok then
		ErrorNoHalt(ret..'\n')
		info._migrate_errors = true
		return nil,'migration errors'
	end
	
	if ret==false then
		return self
	end
	
	tablevers:update("ver = %d WHERE name = %s",_ver,name)
	MsgN("Upgraded ",name," to version ",_ver)
	
	return self
end

--PATH addons/_outfitter/lua/outfitter/gma.lua:
local Tag = 'outfitter'
module(Tag .. '.gma', package.seeall)

-- Reads binary strings
local function readInt(file_meta, count)
	local bits = file_meta:Read(count)

	local bytes = {string.byte(bits, 1, count)}

	local var = 0

	for pos = 0, count - 1 do
		local mult = 256 ^ pos
		var = var + bytes[pos + 1] * mult
	end

	if var > 2147483647 then return var - 4294967296 end

	return var
end

local function parse(gma)
	if gma:Read(4) ~= "GMAD" then return nil, 'invalid header' end

	local meta = {
		files = {},
		fd = gma
	}

	meta.gma_version = gma:ReadByte() -- TODO: GMA version
	if (meta.gma_version or math.huge) > 3 then
		return nil,'Unsupported gma version: '..(meta.gma_version or -1)
	end
	meta.steamid = {gma:ReadULong(),gma:ReadULong()} -- TODO: steamid
	meta.timestamp = {gma:ReadULong(),gma:ReadULong()} -- TODO: timestamp
	if meta.gma_version > 1 then
		meta.required_content = {}
		for i=1,2 ^ 14 do
			if i==2^14-1 then
				return nil,"corrupted file"
			end
			str = gma:ReadString()
			if str=="" then break end
			if not str then
				return nil,'corrupted file'
			end
			table.insert(meta.required_content,str)
		end
	end

	meta.name = gma:ReadString()
	meta.description = util.JSONToTable(gma:ReadString())
	meta.author = gma:ReadString()
	meta.addon_version = gma:ReadULong() -- TODO: addon version
	if not meta.addon_version then
		return nil,'corrupted file'
	end

	for n = 1, 2 ^ 14 do
		if n == 2 ^ 14 - 1 then return nil, 'too many files' end
		
		-- filenum, can ignore
		local filenum= gma:ReadULong()
		if filenum == 0 then break end
		if filenum~=n then
			return nil,'corrupted filenum'
		end
		local filename = gma:ReadString()
		local file_meta = {}
		file_meta.filename = filename
		file_meta.size = gma:ReadULong()
		if gma:ReadULong() ~= 0 then return nil, "file too large" end
		file_meta.crc = gma:ReadULong()
		--file_meta.fd = gma
		file_meta.ext = string.GetExtensionFromFilename(filename)
		if file_meta.size <= 0 then return nil, 'invalid filesize' end
		if file_meta.size >= (2 ^ 30) - 1 then return nil, 'invalid filesize' end
		table.insert(meta.files, file_meta)
	end

	for _, file_meta in pairs(meta.files) do
		file_meta.offset = gma:Tell()
		gma:Skip(file_meta.size)
	end
	--meta.unknown = gma:Read(4)

	--for k, v in pairs(meta.files) do
	--	print(string.NiceSize(v.size), v.filename)
	--end

	return meta
end

local function verify_files(meta,collect)
	if collect then
		collect(true)
	end
	for _, file_meta in pairs(meta.files) do
		local fd = file_meta.fd or meta.fd
		fd:Seek(file_meta.offset)

		local data = fd:Read(file_meta.size)
		if not data or #data ~= file_meta.size then
			return nil,'read failed'
		end
		
		if file_meta.crc and file_meta.crc~=0 and tostring(util.CRC(data))~=tostring(file_meta.crc) then return false,file_meta end
		
		if collect then
			local datalen = #data
			data = nil
			collect(datalen)
		end
	end
	return meta
end

local function build(meta, gma, collect, no_crc)
	local pos=0
	local function add(n)
		pos=pos+n
		--assert(pos==gma:Tell())
		return pos
	end
	gma:Write"GMAD" -- GMA Ident 
	add(4)
	gma:Write(string.char(meta.gma_version)) -- GMA version
	add(1)
	gma:WriteULong(meta.steamid[1]) -- SteamID
	gma:WriteULong(meta.steamid[2]) -- SteamID
	add(8)
	gma:WriteULong(meta.timestamp[1]) -- Timestamp
	gma:WriteULong(meta.timestamp[2]) -- Timestamp
	add(8)
	if meta.gma_version>1 then
		--TODO: dummy
		gma:Write('\0') -- Required content
		add(1)
	end
	local name = (meta.name or "") .. '\0'
	gma:Write(name) -- Name
	add(#name)
	local desc = (meta.description and util.TableToJSON(meta.description) or '{"type":"model","tags":["fun"],"description":"description"}') .. '\0'
	gma:Write(desc) -- Description
	add(#desc)
	local author = (meta.author or "") .. '\0'
	gma:Write(author) -- Author
	add(#author)
	gma:WriteULong(meta.addon_version) -- Addon version
	add(4)
	local idx = 0

	if collect then
		collect(true)
	end

	for i, file_meta in pairs(meta.files) do
		idx = idx + 1
	
		gma:WriteLong(idx) -- file number
		add(4)
		assert(idx == i)
	
		gma:Write(file_meta.filename .. "\0") -- filename 
		add(#file_meta.filename+1)

		assert(file_meta.size < 2 ^ 30)
	
		gma:WriteULong(file_meta.size) -- file size 1
		gma:WriteULong(0) -- file size 2
		add(8)
	
		gma:WriteULong(file_meta.crc or 0)
		add(4)
	end

	gma:WriteLong(0) -- file number 0 (ends listing)
	add(4)

	for _, file_meta in pairs(meta.files) do
		local fd = file_meta.fd or meta.fd
		fd:Seek(file_meta.offset)
		local data = fd:Read(file_meta.size)
		if not data or #data ~= file_meta.size then
			return nil,'read failed'
		end
		
		if no_crc ~= true and file_meta.crc and file_meta.crc~=0 and tostring(util.CRC(data))~=tostring(file_meta.crc) then return nil,"file corrupted" end
		file_meta.offset = gma:Tell()
		gma:Write(data)
		add(#data)

		if collect then
			local datalen = #data
			data = nil
			collect(datalen)
		end
	end

	if collect then
		collect(false)
	end

	return gma:Tell()
end

local function strip_lua(meta)
	for i, file_meta in pairs(meta.files) do
		if file_meta.ext:lower() == "lua" then
			table.remove(meta.files, i)
		end
	end

	return meta
end

local function skip_if_no_lua(meta)
	for i, file_meta in pairs(meta.files) do
		if file_meta.ext:lower() == "lua" then return end
	end

	meta.ret = true
	meta.no_lua = true

	return true
end

-- Writes in_fd|parsed_gma_metadata to out_fd while applying a list of transforming processors to it
--  - processors: { function(gma_metadata) gma_metadata.name="name changed" return gma_metadata end, ... }
--  - collect (optional): garbage collection callback (cannot be async if using DownloadUGC)
local function process(in_fd, out_fd, processors, collect)
	local meta, meta_new, ret, err, err2

	if istable(in_fd) then
		meta = in_fd
	else
		meta, err, err2 = parse(in_fd)
		if not meta then return nil, err end
	end

	meta.eof = in_fd:EndOfFile()

	for _, processor in pairs(processors) do
		meta_new, err, err2 = processor(meta)
		if not meta_new then return nil, err, err2 end
		if meta_new == true then break end
		meta = meta_new
	end

	if meta.error then return nil, meta.error, meta end
	if meta.ret then return meta end
	
	ret,err = build(meta, out_fd, collect)
	
	if not ret then
		return nil,err
	end	

	meta.write_size = ret

	return meta
end

file.CreateDir("cache")
file.CreateDir("cache/workshop")
local function rebuild_nolua_cache_purge(cb)
    local files = file.Find("cache/workshop/*.nolua.gma.dat","DATA")
    for k,v in pairs(files or {}) do
        local path = ("cache/workshop/%s"):format(v)
        if not cb or cb(path)~=true then
            file.Delete(path,'DATA')
        end
    end
end


local uid = 0

-- always_overwrite: overwrite if existing, used for high security
-- return: 
--  - true: no lua found
--  - mount_path (string), new_file  (string): path for MountGMA and whether or not file is just written or likely already mounted
local function rebuild_nolua(in_fd, id, always_overwrite, collect)
	if not id then
		uid = uid + 1
		id = os.date("%y-%m-%d_%H_%M_%S") .. '-' .. uid
		--TODO: crc?
	end

	local write_path = ("cache/workshop/%s.nolua.gma.dat"):format(id)
	local mount_path = ("data/cache/workshop/%s.nolua.gma.dat"):format(id)
	local new_file = false
	local out_fd = file.Open(write_path, 'wb', 'DATA')

	if not out_fd then
		if always_overwrite then return nil, 'not writable' end

		if file.Size(write_path, 'DATA') > 10 then
			-- likely already mounted!f
			return mount_path, new_file
		else
			return nil, 'not writable'
		end
	end

	--TODO:  {skip_if_no_lua,strip_lua}
	local ok, meta, err = xpcall(process,debug.traceback,in_fd, out_fd, {strip_lua}, collect)
	if not ok then 
		err=meta
		meta=nil
	end

	out_fd:Close()

	if not meta then 
		file.Delete(write_path)
		return nil,err
	end

	if meta.no_lua then
		-- TODO: add support back, for now we want to copy every file even if they have no lua in outfitter

		--dbgn(6,"no lua, deleting",write_path)
		--file.Delete(write_path)
		--return true
	end

	new_file = true

	return mount_path, new_file
end

_M.build = build
_M.parse = parse
_M.process = process
_M.rebuild_nolua = rebuild_nolua
_M.rebuild_nolua_cache_purge = rebuild_nolua_cache_purge

local TEST = false

if TEST then
	local process = process
	print("\n")for _,workshop_id in pairs{2570101454,1135026995} do
		
		steamworks.DownloadUGC(workshop_id, function(path, gma_fd)
			print("\n\n=========",workshop_id,"==========")--local out_fd = file.Open("test_nolua.dat", 'wb', 'DATA')

			--print("process", process(gma_fd, out_fd, {strip_lua}))
			local parsed = _M.parse(gma_fd)			
			assert(verify_files(parsed))
			local q=table.Copy(parsed)
			q.files=nil
			print("=======parsed=========\n")
			PrintTable(q)
			print("================\n")


			print("DownloadUGC pre-parse",parsed,parsed.eof,not gma_fd:EndOfFile() and "NOT END OF FILE!!!!!!!!" or "",-(gma_fd:Tell()-gma_fd:Size())) 
			print(("%q"):format(gma_fd:Read(4)))
			gma_fd:Seek(0)
			local output_id = nil -- we want a new file every time
			local nolua_path,err = _M.rebuild_nolua(gma_fd, output_id, true, function(sz)
				if sz == true then
					--print("collect start")
				end

				--local _ = isnumber(sz) and sz > 1000 * 900 and print(string.NiceSize(sz))
			end)
			print("rebuild_nolua:",path,err)
			
			--out_fd:Seek(0)
			--out_fd:Close()

			print("gma.parse",nolua_path)
			local testfd = file.Open(nolua_path,'rb','MOD')
			print("result=")
			local parsed = _M.parse(testfd)
			assert(verify_files(parsed))
			parsed.files=nil
			print("========postparsed========\n")
			PrintTable(parsed)
			print("================\n")

			print("EOF",testfd:EndOfFile())
			testfd:Seek(0)
			local parser = gmaparse.Parser(testfd)
			parser:ParseHeader()
			print("========gmaparse========\n")
			PrintTable(parser)
			print("================\n")
			for i=1,1234 do
				local fd,err = parser:EnumFiles()
				if fd==false then
				break
				end
			end
			testfd:Close()

		end)
	end
end

--PATH addons/____sam/lua/autorun/sam.lua:
if SAM_LOADED then return end

local version = tonumber("160") or 160

sam = {}
sam.config = {}
sam.language = {}
sam.player = {}
sam.ranks = {}
sam.permissions = {}
sam.author = "Srlion"
sam.version = version

function sam.print(...)
	MsgC(
		Color(236, 240, 241), "(",
		Color(244, 67, 54), "SAM",
		Color(236, 240, 241), ") ",
		Color(236, 240, 241), ...
	) Msg("\n")
end

local FAILED = false
do
	local types = {
		sv_ = SERVER and include or function() end,
		cl_ = SERVER and AddCSLuaFile or include,
		sh_ = function(name)
			if SERVER then
				AddCSLuaFile(name)
			end
			return include(name)
		end
	}

	sam.load_file = function(name, type)
		if FAILED then return end

		if type and not type:EndsWith("_") then
			type = type .. "_"
		end

		local func = types[type] or types[name:GetFileFromFilename():sub(1, 3)] or types["sh_"]
		if func then
			local rets = {func(name)}
			if rets[1] == false then
				FAILED = true
				sam.print("Failed to load!")
			end
			return unpack(rets)
		end
	end
end
local load_file = sam.load_file

sam.print("Loading...")

load_file("sam/libs/sh_types.lua")
load_file("sam/libs/sh_pon.lua")
load_file("sam/libs/sh_mp.lua")

do
	local IsValid = IsValid
	local OLD_Player = Player

	-- this is because sam sends players' ids to the client, so if a player disconnects while net message is being sent
	-- the client will not know the player's name
	if CLIENT then
		local players = {}

		local Name = function(s)
			return s.name
		end

		local not_valid = function() return false end

		Player = function(id)
			local ply = OLD_Player(id)

			if not IsValid(ply) then
				local name = players[id]
				if name then
					return {
						name = name,
						Name = Name,
						IsValid = not_valid
					}
				end
			end

			return ply
		end

		hook.Add("OnEntityCreated", "SAM.GetPlayerName", function(ent)
			if ent:IsPlayer() and ent:IsValid() then
				ent.sam_userid = ent:UserID() -- userid is -1 in EntityRemoved?????
			end
		end)

		hook.Add("EntityRemoved", "SAM.GetPlayerName", function(ent)
			if not ent:IsPlayer() then return end

			local id = ent.sam_userid
			if not id then return end

			players[id] = ent:Name()

			timer.Simple(60, function()
				if not IsValid(ent) then
					players[id] = nil
				end
			end)
		end)
	end

	local sfs = load_file("sam/libs/sh_sfs.lua")
	sam.sfs = sfs

	local Encoder = sfs.Encoder
	local chars = sfs.chars
	local write = Encoder.write

	local CONSOLE
	CONSOLE = sfs.add_encoder("console", function(buf, color)
		write(buf, chars[CONSOLE])
	end)

	sfs.add_decoder(CONSOLE, function(ctx)
		ctx[1] = ctx[1] + 1
		return sam.console
	end)

	sfs.set_type_function(sam.type)

	Player = OLD_Player
end

load_file("sam/libs/sh_netstream.lua")
load_file("sam/libs/sh_async_netstream.lua")
load_file("sam/libs/sh_globals.lua")
load_file("sam/libs/sql/sv_init.lua")
sam.Promise = load_file("sam/libs/sh_promises.lua")

load_file("sam/sh_colors.lua")

load_file("sam/sh_util.lua")
load_file("sam/sh_lang.lua")
load_file("sam/sv_sql.lua")
load_file("sam/sh_permissions.lua")

load_file("sam/ranks/sh_ranks.lua")
load_file("sam/ranks/sv_ranks.lua")

load_file("sam/config/sh_config.lua")
load_file("sam/config/sv_config.lua")
load_file("sam/config/cl_config.lua")

load_file("sam/player/sh_player.lua")
load_file("sam/player/sh_nw_vars.lua")
load_file("sam/player/sv_player.lua")
load_file("sam/player/cl_player.lua")
load_file("sam/player/sv_ranks.lua")
load_file("sam/player/sv_auth.lua")
load_file("sam/player/sv_bans.lua")

load_file("sam/command/sh_command.lua")
load_file("sam/command/sv_command.lua")
load_file("sam/command/cl_command.lua")

for _, f in ipairs(file.Find("sam/command/arguments/*.lua", "LUA")) do
	load_file("sam/command/arguments/" .. f, "sh")
end

load_file("sam/sh_restrictions.lua")

load_file("sam/menu/sh_init.lua")
load_file("sam/menu/cl_init.lua")

load_file("sam/sh_motd.lua")

local modules = file.Find("sam/modules/*.lua", "LUA")
for _, module in ipairs(modules) do
	load_file("sam/modules/" .. module)
end

load_file("sam/reports/cl_reports.lua")
load_file("sam/reports/sv_reports.lua")

do
	if SERVER then
		hook.Add("SAM.LoadedConfig", "SAM.AdvertsMain", function(config)
			if not config.Adverts or not istable(config.Adverts) then
				sam.config.set("Adverts", {})
			end
		end)
	end
	load_file("sam/cl_adverts.lua")
end

if not FAILED then
	sam.print("Loaded!")
end

if SERVER then
	local path = "sam/importers/"

	concommand.Add("sam_import", function(ply, _, args)
		if IsValid(ply) then return end

		local admin_mod = args[1]
		if not admin_mod then
			sam.print("You need to provide an admin mod to import!")
			return
		end

		if not file.Exists(path .. admin_mod, "LUA") then
			sam.print("There is no importer for '" .. admin_mod .. "'")
			return
		end

		CompileFile(path .. admin_mod .. "/main.lua")()
	end, nil, nil, FCVAR_PROTECTED)
end

SAM_LOADED = true

--PATH addons/____sam/lua/sam/sh_util.lua:
if SAM_LOADED then return end

local sam = sam

function sam.parse_args(str)
	local args = {}
	local tmp, in_quotes = "", false
	for i = 1, #str do
		local char = str:sub(i, i)
		if char == "\"" then
			-- i could use string.find to find the next double quotes but thats gonna be overkill
			in_quotes = not in_quotes
			if tmp ~= "" or not in_quotes then
				args[#args + 1], tmp = tmp, ""
			end
		elseif char ~= " " or in_quotes then
			tmp = tmp .. char
		elseif tmp ~= "" then
			args[#args + 1], tmp = tmp, ""
		end
	end
	if tmp ~= "" then
		args[#args + 1] = tmp
	end
	return args, #args
end

function sam.get_targets_list(targets)
	if sam.isstring(targets) then
		return {Color(244, 67, 54), targets}
	end

	local len = #targets

	if len == player.GetCount() and len > 1 then
		return {Color(244, 67, 54), sam.language.get("Everyone")}
	end

	local admin = targets.admin
	local result = {}
	local white = Color(236, 240, 241)
	for i = 1, len do
		local target = targets[i]

		if CLIENT and LocalPlayer() == target then
			table.insert(result, Color(255, 215, 0))
			if admin ~= LocalPlayer() then
				table.insert(result, sam.language.get("You"))
			else
				table.insert(result, sam.language.get("Yourself"))
			end
		elseif admin ~= target then
			local name
			if sam.isentity(target) and target.Name then
				name = target:Name()
			else
				name = "Unknown"
				table.insert(result, white)
				table.insert(result, "*")
			end

			table.insert(result, Color(244, 67, 54))
			table.insert(result, name)
		else
			table.insert(result, Color(255, 215, 0))
			table.insert(result, sam.language.get("Themself"))
		end

		if i ~= len then
			table.insert(result, white)
			table.insert(result, ",")
		end
	end

	return result
end

function sam.is_steamid(id, err) -- https://stackoverflow.com/questions/6724268/check-if-input-matches-steam-id-format
	if sam.isstring(id) and id:match("^STEAM_[0-5]:[0-1]:[0-9]+$") ~= nil then
		return true
	else
		return err and error("invalid steamid", 2) or false
	end
end

function sam.is_steamid64(id, err)
	if sam.isstring(id)
		and tonumber(id)
		and id:sub(1, 7) == "7656119"
		and (#id == 17 or #id == 18) then
		return true
	else
		return err and error("invalid steamid64", 2) or false
	end
end

do
	local console = {}

	do
		local return_console = function()
			return "Console"
		end
		for _, v in ipairs({"SteamID", "SteamID64", "Name", "Nick", "Name"}) do
			console[v] = return_console
		end
		setmetatable(console, {
			__tostring = return_console,
			MetaName = "console"
		})
	end

	function console.IsAdmin()
		return true
	end

	function console.IsSuperAdmin()
		return true
	end

	function console:IsUserGroup(name)
		return name == "superadmin"
	end

	function console.GetUserGroup()
		return "superadmin"
	end

	function console.HasPermission()
		return true
	end

	function console.CanTarget()
		return true
	end

	function console.CanTargetRank()
		return true
	end

	function console.GetBanLimit()
		return 0
	end

	function console.SetUserGroup()
	end

	function sam.isconsole(v)
		return v == console
	end

	sam.console = console
end

do
	local times = {
		"year"; 525600,
		"month"; 43800,
		"week"; 10080,
		"day"; 1440,
		"hour"; 60,
		"minute"; 1
	}

	for i = 1, #times, 2 do
		times[i] = " " .. times[i]
	end

	local floor = math.floor
	function sam.format_length(mins) -- Thanks to this guide https://stackoverflow.com/a/21323783
		if mins <= 0 then
			return "Indefinitely"
		elseif mins <= 1 then
			return "1 minute"
		end

		local str = ""
		for i = 1, #times, 2 do
			local n1, n2 = times[i + 1]
			n2, mins = floor(mins / n1), mins % n1

			if n2 > 0 then
				if str ~= "" then
					if mins == 0 then
						str = str .. " and "
					else
						str = str .. ", "
					end
				end
				str = str .. n2 .. times[i]
				if n2 > 1 then
					str = str .. "s"
				end
			end

			if mins == 0 then
				break
			end
		end
		return str
	end
end

do
	local times = {
		m = 1,
		h = 60,
		d = 1440,
		w = 10080,
		mo = 43800,
		y = 525600
	}

	function sam.parse_length(length)
		local time, found = tonumber(length), false
		if sam.isnumber(length) then
			time, found = length, true
		elseif time then
			found = true
		else
			time = 0
			for t, u in length:gmatch("(%d+)(%a+)") do
				u = times[u]
				if u then
					time = time + (u * t)
					found = true
				end
			end
		end
		if not found then return false end
		return math.Clamp(time, 0, 31536000)
	end

	local times2 = {}
	for k, v in SortedPairsByValue(times, true) do
		table.insert(times2, k)
		table.insert(times2, v)
	end

	local floor = math.floor
	function sam.reverse_parse_length(mins) -- Thanks to this guide https://stackoverflow.com/a/21323783
		if mins <= 0 then
			return "0"
		elseif mins <= 1 then
			return "1m"
		end

		local str = ""
		for i = 1, #times2, 2 do
			local n1, n2 = times2[i + 1]
			n2, mins = floor(mins / n1), mins % n1

			if n2 > 0 then
				if str ~= "" then
					str = str .. " "
				end
				str = str .. n2 .. times2[i]
			end

			if mins == 0 then
				break
			end
		end
		return str
	end

	local times_ = {
		m = 1,
		h = 60
	}

	local times2_ = {}
	for k, v in SortedPairsByValue(times_, true) do
		table.insert(times2_, k)
		table.insert(times2_, v)
	end

	function sam.reverse_parse_length_vasilisk(mins)
		if mins <= 0 then
			return "0"
		elseif mins <= 1 then
			return "1m"
		end

		local str = ""
		for i = 1, #times2_, 2 do
			local n1, n2 = times2_[i + 1]
			n2, mins = floor(mins / n1), mins % n1

			if n2 > 0 then
				if str ~= "" then
					str = str .. " "
				end
				str = str .. n2 .. times2_[i]
			end

			if mins == 0 then
				break
			end
		end
		return str
	end
end

do
	if SERVER then
		function sam.hook_call(event, ...)
			hook.Call(event, nil, ...)
			sam.netstream.Start(nil, "HookCall", event, ...)
		end

		function sam.client_hook_call(event, ...)
			sam.netstream.Start(nil, "HookCall", event, ...)
		end
	else
		local function hook_call(event, ...)
			hook.Call(event, nil, ...)
		end
		sam.netstream.Hook("HookCall", hook_call)
	end
end

if SERVER then
	local maps = {}

	for k, v in ipairs(file.Find("maps/*.bsp", "GAME")) do
		maps[k] = v:sub(1, -5):lower()
	end

	sam.set_global("Maps", maps)
end

function sam.is_valid_map(name)
	local maps = sam.get_global("Maps", {})
	if name:sub(-4) == ".bsp" then
		name = name:sub(1, -5)
	end
	name = name:lower()
	for i = 1, #maps do
		if maps[i] == name then
			return name
		end
	end
	return false
end

function sam.is_valid_gamemode(name)
	name = name:lower()
	local gamemodes = engine.GetGamemodes()
	for i = 1, #gamemodes do
		local gamemode = gamemodes[i]
		if sam.isstring(gamemode.name) and gamemode.name:lower() == name then
			return true
		end
	end
	return false
end

function sam.hook_first(event, name, func)
	if HOOK_HIGH then
		return hook.Add(event, name, func, HOOK_HIGH)
	end

	return hook.Add(event, name, func)
end

function sam.hook_last(event, name, func)
	if HOOK_LOW then
		return hook.Add(event, name, func, HOOK_LOW)
	end

	return hook.Add(event, name, func)
end

do
	local byte = string.byte
	local gsub = string.gsub
	local char = string.char
	local format = string.format
	local tonumber = tonumber

	local hex_encode = function(c)
		return format("%02X", byte(c))
	end

	function sam.to_hex(text)
		-- gsub returns more than one value, fucking glualint can't stop complaining about using ()
		local hex = gsub(text, ".", hex_encode)
		return hex
	end

	local hex_decode = function(d)
		return char(tonumber(d, 16))
	end

	function sam.from_hex(hex)
		local text = (gsub(hex, "%x%x", hex_decode))
		return text
	end
end

--PATH addons/____sam/lua/sam/player/sh_player.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

do
	local _player = {}
	sam.player = setmetatable(sam.player, {
		__index = _player,
		__newindex = function(_, k, v)
			_player[k] = v
			if sam.isfunction(v) and debug.getlocal(v, 1) == "ply" then
				FindMetaTable("Player")["sam_" .. k] = v
				sam.console["sam_" .. k] = v
			end
		end
	})
end

function sam.player.find_by_name(name)
	name = name:lower()
	local current, players = nil, player.GetAll()
	for i = 1, #players do
		local ply = players[i]
		local found = ply:Name():lower():find(name, 1, true)
		if found then
			if current then
				if not sam.istable(current) then
					current = {current, ply}
				else
					table.insert(current, ply)
				end
			else
				current = ply
			end
		end
	end
	return current
end

do
	if CLIENT then
		config.add_menu_setting("Chat Prefix (Leave empty for no prefix)", function()
			local entry = vgui.Create("SAM.TextEntry")
			entry:SetPlaceholder("")
			entry:SetNoBar(true)
			entry:SetConfig("ChatPrefix", "")

			return entry
		end)
	end

	function sam.player.send_message(ply, msg, tbl)
		if SERVER then
			if sam.isconsole(ply) then
				local result = sam.format_message(msg, tbl)
				sam.print(unpack(result, 1, result.__cnt))
			else
				return sam.netstream.Start(ply, "send_message", msg, tbl)
			end
		else
			local prefix_result = sam.format_message(config.get("ChatPrefix", ""))
			local prefix_n = #prefix_result

			local result = sam.format_message(msg, tbl, prefix_result, prefix_n)
			chat.AddText(unpack(result, 1, result.__cnt))
		end
	end

	if SERVER then
		function sam.player.add_text(ply, ...)
			if sam.isconsole(ply) then
				sam.print(...)
			else
				sam.netstream.Start(ply, "add_text", ...)
			end
		end
	end

	if CLIENT then
		sam.netstream.Hook("send_message", function(msg, tbl)
			sam.player.send_message(nil, msg, tbl)
		end)

		sam.netstream.Hook("add_text", function(...)
			chat.AddText(...)
		end)
	end
end

do
	local PLAYER = FindMetaTable("Player")

	timer.Simple(0, function()
		function PLAYER:GetUserGroup()
			return self:sam_get_nwvar("rank", "user")
		end
	end)

	function PLAYER:IsAdmin()
		return self:CheckGroup("admin")
	end

	function PLAYER:IsSuperAdmin()
		return self:CheckGroup("superadmin")
	end

	local inherits_from = sam.ranks.inherits_from
	function PLAYER:CheckGroup(name)
		return inherits_from(self:GetUserGroup(), name)
	end

	local has_permission = sam.ranks.has_permission
	function PLAYER:HasPermission(perm)
		return has_permission(self:GetUserGroup(), perm)
	end

	local can_target = sam.ranks.can_target
	function PLAYER:CanTarget(ply)
		return can_target(self:GetUserGroup(), ply:GetUserGroup())
	end

	function PLAYER:CanTargetRank(rank)
		return can_target(self:GetUserGroup(), rank)
	end

	local get_ban_limit = sam.ranks.get_ban_limit
	function PLAYER:GetBanLimit(ply)
		return get_ban_limit(self:GetUserGroup())
	end

	function PLAYER:sam_get_play_time()
		return self:sam_get_nwvar("play_time", 0) + self:sam_get_session_time()
	end

	function PLAYER:sam_get_session_time()
		return os.time() - self:sam_get_nwvar("join_time", 0)
	end

	if SERVER then
		function PLAYER:Ban(length)
			self:sam_ban(length)
		end

		-- if an addon like FPP loads before sam while DarkRP is installed, it will use darkrp.oldSetUserGroup which is gmod default
		-- so we add a timer to make sure sam's SetUserGroup gets called
		-- also i don't use (Set/Get)NwVar because when i send a hook that player rank changed to clients, ply:GetUserGroup won't be updated yet in clientside inside that hook
		timer.Simple(0, function()
			sam.oldSetUserGroup = sam.oldSetUserGroup or PLAYER.SetUserGroup
			function PLAYER:SetUserGroup(name)
				self:sam_set_nwvar("rank", name)
				return sam.oldSetUserGroup(self, name)
			end
		end)

		hook.Remove("PlayerInitialSpawn", "PlayerAuthSpawn")
	end
end

do
	local set_cooldown = function(ply, name, time)
		if not ply.sam_cool_downs then
			ply.sam_cool_downs = {}
		end
		ply.sam_cool_downs[name] = SysTime() + time
		return true
	end

	function sam.player.check_cooldown(ply, name, time)
		if not ply.sam_cool_downs or not ply.sam_cool_downs[name] then
			return set_cooldown(ply, name, time)
		end

		local current_time = SysTime()
		local cool_down = ply.sam_cool_downs[name]
		if cool_down > current_time then
			return false, cool_down - current_time
		else
			return set_cooldown(ply, name, time)
		end
	end
end

--PATH addons/____sam/lua/sam/command/sh_command.lua:
if SAM_LOADED then return end

local sam = sam
local istable, isstring = sam.istable, sam.isstring

local commands = {}
local arguments = {}

do
	local command = {}

	local current_category = "other"
	function command.set_category(category)
		if isstring(category) then
			current_category = category
		end
	end

	function command.get_commands()
		return commands
	end

	function command.get_command(name)
		for i = 1, #commands do
			local cmd = commands[i]
			if cmd.name == name then
				return cmd, i
			end

			local aliases = cmd.aliases
			for i2 = 1, #aliases do
				local alias = aliases[i2]
				if alias == name then
					return cmd, i
				end
			end
		end
		return false
	end

	function command.remove_command(name)
		local cmd, index = command.get_command(name)
		if index then
			table.remove(commands, index)
			hook.Call("SAM.CommandRemoved", nil, cmd.name, cmd, index)
			return index
		end
		return false
	end

	function command.get_arguments()
		return arguments
	end

	do
		local argument_methods = {
			OnExecute = function(self, func)
				if isfunction(func) and SERVER then
					self.on_execute = func
				end
				return self
			end,
			Menu = function(self, func)
				if isfunction(func) and CLIENT then
					self.menu = func
				end
				return self
			end,
			AutoComplete = function(self, func)
				if isfunction(func) and CLIENT then
					self.auto_complete = func
				end
				return self
			end,
			End = function(self)
				if SERVER then
					arguments[self.name] = self.on_execute
				else
					arguments[self.name] = self
				end
			end
		}

		local argument_meta = {__index = argument_methods}
		function command.new_argument(name)
			if isstring(name) then
				return setmetatable({name = name}, argument_meta)
			end
		end
	end

	if CLIENT then
		function command.run_commands(to_run)
			local time = 0
			for i = 1, #to_run do
				timer.Simple(time, function()
					RunConsoleCommand("sam", unpack(to_run[i]))
				end)
				time = time + 0.76
			end
		end
	end

	--
	-- Methods
	--
	local Command_Methods = {}
	local Command_meta = {__index = Command_Methods}

	function command.new(cmd)
		if not isstring(cmd) then return end

		local new_command = setmetatable({}, Command_meta)
		new_command.can_console_run = true
		new_command.args = {}
		new_command.name = cmd:lower()
		new_command.aliases = {}
		new_command.category = current_category

		return new_command
	end

	local AddMethod = function(name, func)
		Command_Methods[name] = func
	end

	AddMethod("Aliases", function(self, ...)
		for k, v in ipairs({...}) do
			table.insert(self.aliases, v)
		end
		return self
	end)

	AddMethod("AddArg", function(self, name, data)
		if not isstring(name) then return end
		if not istable(data) then
			data = {}
		end
		data.name = name
		table.insert(self.args, data)
		return self
	end)

	AddMethod("DisallowConsole", function(self, disallow)
		self.can_console_run = isbool(disallow) and disallow or false
		return self
	end)

	AddMethod("SetCategory", function(self, category)
		if isstring(category) then
			self.category = category
		end
		return self
	end)

	AddMethod("Help", function(self, help)
		if isstring(help) then
			self.help = sam.language.get(help) or help
		end
		return self
	end)

	AddMethod("OnExecute", function(self, func)
		if isfunction(func) and SERVER then
			self.on_execute = func
		end
		return self
	end)

	AddMethod("SetPermission", function(self, perm, default_rank)
		if isstring(perm) then
			self.permission = perm
			self.default_rank = default_rank
		end
		return self
	end)

	AddMethod("GetRestArgs", function(self, get)
		if not isbool(get) then
			get = true
		end
		self.get_rest_args = get
		return self
	end)

	AddMethod("MenuHide", function(self, should_hide)
		if isbool(should_hide) then
			self.menu_hide = should_hide
		else
			self.menu_hide = true
		end
		return self
	end)

	AddMethod("DisableNotify", function(self, disable)
		if isbool(disable) then
			self.disable_notify = disable
		else
			self.disable_notify = true
		end
		return self
	end)

	AddMethod("End", function(self)
		local name = self.name
		if SERVER and not self.on_execute then
			sam.print("need an OnExecute function for the command!")
			debug.Trace()
			return
		end

		if self.permission then
			sam.permissions.add(self.permission, "Commands - " .. self.category, self.default_rank)
		end

		local _, index = command.get_command(name)
		if index then
			commands[index] = self
			hook.Call("SAM.CommandModified", nil, name, self, index)
		else
			hook.Call("SAM.CommandAdded", nil, name, self, table.insert(commands, self))
		end
	end)

	AddMethod("GetRequiredArgs", function(self)
		local required_args = {}
		local args = self.args
		for i = 1, #args do
			local v = args[i]
			if not v.optional then
				table.insert(required_args, v)
			end
		end
		return required_args
	end)

	AddMethod("GetOptionalArgs", function(self)
		local optional_args = {}
		local args = self.args
		for i = 1, #args do
			local v = args[i]
			if v.optional then
				table.insert(optional_args, v)
			end
		end
		return optional_args
	end)

	AddMethod("ArgsToString", function(self, return_table)
		local str_table = {}
		local args = self.args
		for i = 1, #self.args do
			local v = args[i]
			if not v.optional then
				table.insert(str_table, "<" .. (v.hint or v.name) .. ">")
			else
				table.insert(str_table, "[" .. (v.hint or v.name) .. "]")
			end
		end
		return return_table and str_table or table.concat(str_table, " ")
	end)

	AddMethod("HasArg", function(self, arg)
		local args = self.args
		for i = 1, #self.args do
			if args[i].name == arg then
				return true
			end
		end
		return false
	end)

	command.add_method = AddMethod

	sam.command = command
end

sam.__commands = commands
sam.__arguments = arguments
--PATH addons/____sui/lua/sui/libs/bshadows.lua:
local ScrW = ScrW
local ScrH = ScrH

local sin = math.sin
local cos = math.cos
local rad = math.rad
local ceil = math.ceil

local Start2D = cam.Start2D
local End2D = cam.End2D

local PushRenderTarget = render.PushRenderTarget
local OverrideAlphaWriteEnable = render.OverrideAlphaWriteEnable
local Clear = render.Clear
local CopyRenderTargetToTexture = render.CopyRenderTargetToTexture
local BlurRenderTarget = render.BlurRenderTarget
local PopRenderTarget = render.PopRenderTarget
local SetMaterial = render.SetMaterial
local DrawScreenQuadEx = render.DrawScreenQuadEx
local DrawScreenQuad = render.DrawScreenQuad

local RenderTarget, RenderTarget2
local load_render_targets = function()
	local w, h = ScrW(), ScrH()
	RenderTarget = GetRenderTarget("sui_bshadows_original" .. w .. h, w, h)
	RenderTarget2 = GetRenderTarget("sui_bshadows_shadow" .. w .. h,  w, h)
end
load_render_targets()
hook.Add("OnScreenSizeChanged", "SUI.BShadows", load_render_targets)

local ShadowMaterial = CreateMaterial("sui_bshadows", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["alpha"] = 1
})

local ShadowMaterialGrayscale = CreateMaterial("sui_bshadows_grayscale", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["$alpha"] = 1,
	["$color"] = "0 0 0",
	["$color2"] = "0 0 0"
})

local SetTexture = ShadowMaterial.SetTexture

local BSHADOWS = {}

BSHADOWS.BeginShadow = function()
	PushRenderTarget(RenderTarget)

	OverrideAlphaWriteEnable(true, true)
	Clear(0, 0, 0, 0)
	OverrideAlphaWriteEnable(false, false)

	Start2D()
end

BSHADOWS.EndShadow = function(intensity, spread, blur, opacity, direction, distance, _shadowOnly)
	opacity = opacity or 255
	direction = direction or 0
	distance = distance or 0

	CopyRenderTargetToTexture(RenderTarget2)

	if blur > 0 then
		OverrideAlphaWriteEnable(true, true)
		BlurRenderTarget(RenderTarget2, spread, spread, blur)
		OverrideAlphaWriteEnable(false, false)
	end

	PopRenderTarget()

	SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
	SetTexture(ShadowMaterialGrayscale, "$basetexture", RenderTarget2)

	local xOffset = sin(rad(direction)) * distance
	local yOffset = cos(rad(direction)) * distance

	SetMaterial(ShadowMaterialGrayscale)
	for i = 1, ceil(intensity) do
		DrawScreenQuadEx(xOffset, yOffset, ScrW(), ScrH())
	end

	if not _shadowOnly then
		SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
		SetMaterial(ShadowMaterial)
		DrawScreenQuad()
	end

	End2D()
end

sui.BSHADOWS = BSHADOWS
--PATH addons/____sui/lua/sui/libs/types.lua:
-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function sui.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		sui["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function sui.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
sui.IsEntity = sui.isentity

local type = sui.type
function sui.istable(value)
	return type(value) == "table"
end
--PATH addons/____sui/lua/sui/cl_base.lua:
local hook = hook
local bit = bit
local math = math

local Color = Color
local ipairs = ipairs
local RealFrameTime = RealFrameTime

local color_white = color_white
local color_black = color_black

local sui = sui

local isfunction = sui.isfunction
local isstring = sui.isstring

local floor = math.floor

function sui.scale(v)
	return ScrH() * (v / 900)
end

function sui.hex_rgb(hex)
	hex = tonumber(hex:gsub("^([%w])([%w])([%w])$", "%1%1%2%2%3%3", 1), 16)

	return Color(
		bit.band(bit.rshift(hex, 16), 0xFF),
		bit.band(bit.rshift(hex, 8), 0xFF),
		bit.band(hex, 0xFF)
	)
end

function sui.rgb_hex(c)
	return bit.tohex((c.r * 0x10000) + (c.g * 0x100) + c.b, 6)
end
local rgb_hex = sui.rgb_hex

function sui.lerp_color(from, to)
	local frac = RealFrameTime() * 10
	from.r = Lerp(frac, from.r, to.r)
	from.g = Lerp(frac, from.g, to.g)
	from.b = Lerp(frac, from.b, to.b)
	from.a = Lerp(frac, from.a, to.a)
end

do
	local colors = {
		["41b9ff"] = Color(44, 62, 80),
		["00c853"] = Color(44, 62, 80),
		["181818"] = Color(242, 241, 239),
		["212121"] = Color(242, 241, 239),
	}

	function sui.contrast_color(color)
		local c = colors[rgb_hex(color)]
		if c then return c end

		local luminance = (0.299 * color.r + 0.587 * color.g + 0.114 * color.b) / 255
		return luminance > 0.5 and color_black or color_white
	end
end

do
	local SetDrawColor = surface.SetDrawColor
	local SetMaterial = surface.SetMaterial
	local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
	function sui.draw_material(mat, x, y, size, col, rot)
		SetDrawColor(col)

		if x == -1 then
			x = size * 0.5
		end

		if y == -1 then
			y = size * 0.5
		end

		if mat then
			SetMaterial(mat)
		end

		DrawTexturedRectRotated(x, y, size, size, rot or 0)
	end
end

do
	local hsv_t = {
		[0] = function(v, p, q, t)
			return v, t, p
		end,
		[1] = function(v, p, q, t)
			return q, v, p
		end,
		[2] = function(v, p, q, t)
			return p, v, t
		end,
		[3] = function(v, p, q, t)
			return p, q, v
		end,
		[4] = function(v, p, q, t)
			return t, p, v
		end,
		[5] = function(v, p, q, t)
			return v, p, q
		end
	}

	function sui.hsv_to_rgb(h, s, v)
		local i = floor(h * 6)
		local f = h * 6 - i

		return hsv_t[i % 6](
			v * 255, -- v
			(v * (1 - s)) * 255, -- p
			(v * (1 - f * s)) * 255, -- q
			(v * (1 - (1 - f) * s)) * 255 -- t
		)
	end
end

local Panel = FindMetaTable("Panel")
local SetSize = Panel.SetSize
local GetWide = Panel.GetWide
local GetTall = Panel.GetTall
function sui.scaling_functions(panel)
	local scale_changed
	local SUI = CURRENT_SUI

	local dock_top = function(s, h)
		if not h then return end

		if not scale_changed then
			s.real_h = h
		end

		if not s.no_scale then
			h = SUI.Scale(h)
		end

		if GetTall(s) == h then return end

		SetSize(s, GetWide(s), h)
	end

	local dock_right = function(s, w)
		if not w then return end

		if not scale_changed then
			s.real_w = w
		end

		if not s.no_scale then
			w = SUI.Scale(w)
		end

		if GetWide(s) == w then return end

		SetSize(s, w, GetTall(s))
	end

	local size_changed = function(s, w, h)
		if s.using_scale then return end

		s.using_scale = true

		local dock = s:GetDock()

		if dock ~= FILL then
			if dock == NODOCK then
				dock_top(s, h)
				dock_right(s, w)
			elseif dock == TOP or dock == BOTTOM then
				dock_top(s, h)
			else
				dock_right(s, w)
			end
		end

		s.using_scale = nil
	end

	local wide_changed = function(s, w)
		size_changed(s, w)
	end

	local tall_changed = function(s, h)
		size_changed(s, nil, h)
	end

	function panel:ScaleChanged()
		scale_changed = true
		size_changed(self, self.real_w, self.real_h)
		scale_changed = nil
		if self.OnScaleChange then
			self:OnScaleChange()
		end
	end

	local on_remove = function(s)
		SUI.RemoveScaleHook(s)
	end

	function panel:ScaleInit()
		self.SetSize = size_changed
		self.SetWide = wide_changed
		self.SetTall = tall_changed
		SUI.OnScaleChanged(self, self.ScaleChanged)
		self:On("OnRemove", on_remove)
	end
end

do
	local utf8 = {}

	local str_rel_to_abs = function(str, v, str_n)
		return v > 0 and v or math.max(str_n + v + 1, 1)
	end

	local utf8_decode = function(str, start_pos, str_n)
		start_pos = str_rel_to_abs(str, start_pos or 1, str_n)

		local b1 = str:byte(start_pos, start_pos)
		if not b1 then return nil end
		if b1 < 0x80 then return start_pos, start_pos, b1 end
		if b1 > 0xF4 or b1 < 0xC2 then return nil end

		local cont_byte_count = b1 >= 0xF0 and 3 or b1 >= 0xE0 and 2 or b1 >= 0xC0 and 1
		local end_pos = start_pos + cont_byte_count
		local code_point = 0

		if str_n < end_pos then return nil end

		local bytes = {str:byte(start_pos + 1, end_pos)}
		for i = 1, #bytes do
			local b_x = bytes[i]
			if bit.band(b_x, 0xC0) ~= 0x80 then return nil end
			code_point = bit.bor(bit.lshift(code_point, 6), bit.band(b_x, 0x3F))
			b1 = bit.lshift(b1, 1)
		end

		code_point = bit.bor(code_point, bit.lshift(bit.band(b1, 0x7F), cont_byte_count * 5))

		return start_pos, end_pos, code_point
	end

	local replacement = string.char(239, 191, 189)

	function utf8.force(str)
		local end_pos = #str
		if end_pos == 0 then return str, end_pos end

		local ret = ""
		local cur_pos = 1

		repeat
			local seq_start_pos, seq_end_pos = utf8_decode(str, cur_pos, end_pos)

			if not seq_start_pos then
				ret = ret .. replacement
				cur_pos = cur_pos + 1
			else
				ret = ret .. str:sub(seq_start_pos, seq_end_pos)
				cur_pos = seq_end_pos + 1
			end
		until cur_pos > end_pos

		return ret, #ret
	end

	-- https://gist.github.com/gdeglin/4128882

	local utf8_char_bytes = function(c)
		if c > 0 and c <= 127 then
			return 1
		elseif c >= 194 and c <= 223 then
			return 2
		elseif c >= 224 and c <= 239 then
			return 3
		elseif c >= 240 and c <= 244 then
			return 4
		end
	end
	utf8.char_bytes = utf8_char_bytes

	function utf8.len(str)
		local length = #str

		local len = 0

		local pos = 1
		while pos <= length do
			len = len + 1
			pos = pos + utf8_char_bytes(str:byte(pos))
		end

		return len
	end

	function utf8.sub(str, i, j)
		j = j or -1

		if i == nil then return "" end

		local l = (i >= 0 and j >= 0) or utf8.len(str)
		local start_char = (i >= 0) and i or l + i + 1
		local end_char = (j >= 0) and j or l + j + 1

		if start_char > end_char then return "" end

		local pos = 1
		local length = #str
		local len = 0

		local start_byte, end_byte = 1, length

		while pos <= length do
			len = len + 1

			if len == start_char then
				start_byte = pos
			end

			pos = pos + utf8_char_bytes(str:byte(pos))

			if len == end_char then
				end_byte = pos - 1
				break
			end
		end

		return str:sub(start_byte, end_byte)
	end

	sui.utf8 = utf8
end

--
-- thanks falco!
-- https://github.com/FPtje/DarkRP/blob/4fd2c3c315427e79bb7624702cfaefe9ad26ac7e/gamemode/modules/base/cl_util.lua#L42
--
do
	local utf8 = utf8
	local surface = surface

	local max_width, original_width, can_fix

	local fix_width = function()
		if can_fix then
			can_fix = false
			max_width = original_width
		end
	end

	local char_wrap = function(text, remaining_width)
		local total_width  = 0

		local new_text = ""
		for char in text:gmatch(utf8.charpattern) do
			total_width  = total_width  + surface.GetTextSize(char)
			if total_width >= remaining_width then
				total_width = surface.GetTextSize(char)
				fix_width()
				remaining_width = max_width

				new_text = new_text .. ("\n" .. char)
			else
				new_text = new_text .. char
			end
		end

		return new_text, total_width
	end

	function sui.wrap_text(text, font, width, first_width)
		text = sui.utf8.force(text)

		local total_width = 0
		can_fix = first_width and true or false
		max_width, original_width = first_width or width, width

		surface.SetFont(font)

		local space_width = surface.GetTextSize(" ")

		text = text:gsub("(%s?[%S]*)", function(word)
			local char = word:sub(1, 1)
			if char == "\n" then
				total_width = 0
				fix_width()
			end

			local wordlen = surface.GetTextSize(word)
			total_width = total_width + wordlen

			if wordlen >= max_width then
				local split_word
				split_word, total_width = char_wrap(word, max_width - (total_width - wordlen))
				return split_word
			elseif total_width < max_width then
				return word
			end

			fix_width()

			total_width = wordlen

			if char == " " then
				total_width = total_width - space_width
				return "\n" .. word:sub(2)
			end

			return "\n" .. word
		end)

		return text
	end
end

function sui.register(classname, panel_table, parent_class)
	sui.TDLib.Install(panel_table)

	if not panel_table.Add then
		function panel_table:Add(pnl)
			return vgui.Create(pnl, self)
		end
	end

	if not panel_table.NoOverrideClear and not panel_table.Clear then
		function panel_table:Clear()
			local children = self:GetChildren()
			for i = 1, #children do
				children[i]:Remove()
			end
		end
	end

	local SUI = CURRENT_SUI

	for k, v in pairs(SUI.panels_funcs) do
		panel_table[k] = v
	end

	panel_table.SUI_GetColor = function(name)
		return SUI.GetColor(name)
	end

	SUI.panels[classname] = panel_table

	return vgui.Register(SUI.name .. "." .. classname, panel_table, parent_class)
end

local Material; do
	local C_Material, material_str = select(2, debug.getupvalue(_G.Material, 1)), "0001010" -- [["mips smooth"]]
	Material = function(name)
		return C_Material(name, material_str)
	end
end
sui.Material = Material

local function prepare_theme(theme)
	for k, v in pairs(theme) do
		if IsColor(v) then continue end

		if istable(v) then
			prepare_theme(v)
		elseif isstring(v) and v:sub(1, 1) == "#" then
			theme[k] = sui.hex_rgb(v:sub(2))
		end
	end
end

function sui.new(addon_name, default_scaling, panels_funcs)
	local SUI = {
		name = addon_name,
		panels = {},
		panels_funcs = panels_funcs or {}
	}

	CURRENT_SUI = SUI

	do
		local themes = table.Copy(sui.themes)
		local current_theme_table

		function SUI.GetColor(color_name)
			return current_theme_table[color_name]
		end

		function SUI.SetTheme(theme_name)
			SUI.current_theme = theme_name
			current_theme_table = themes[theme_name]
			hook.Call(addon_name .. ".ThemeChanged")
		end

		function SUI.GetThemes()
			return themes
		end

		function SUI.AddToTheme(theme_name, tbl)
			local theme = themes[theme_name]
			for k, v in pairs(tbl) do
				theme[k] = v
			end
			prepare_theme(theme)
		end

		function SUI.RemoveTheme(theme_name)
			themes[theme_name] = nil
			if theme_name == SUI.current_theme then
				SUI.SetTheme(next(themes))
			end
		end

		function SUI.AddTheme(theme_name, tbl)
			prepare_theme(tbl)
			themes[theme_name] = tbl
		end

		SUI.themes = themes
	end

	local Scale
	do
		local scale = 1

		if default_scaling then
			SUI.Scale = sui.scale
		else
			function SUI.Scale(v)
				return floor((v * scale) + 0.5)
			end
		end
		Scale = SUI.Scale

		function SUI.ScaleEven(v)
			v = Scale(v)
			if v % 2 ~= 0 then
				v = v + 1
			end
			return v
		end

		function SUI.SetScale(_scale)
			if _scale == scale then return end

			scale = _scale
			SUI.scale = _scale

			for k, v in pairs(SUI.fonts) do
				SUI.CreateFont(k:sub(#addon_name + 1), v.font, v.size, v.weight)
			end

			SUI.CallScaleChanged()
		end

		local n = 0
		local keys = {}
		local hooks = {}
		_G[addon_name .. "_HOOKS"] = keys
		_G[addon_name .. "_KEYS"] = hooks
		_G[addon_name .. "_N"] = function()
			return n
		end
		function SUI.OnScaleChanged(name, func)
			if not isfunction(func) then
				error("Invalid function?")
			end

			if not name then
				error("Invalid name?")
			end

			if not isstring(name) then
				local _func = func
				func = function()
					local isvalid = name.IsValid
					if isvalid and isvalid(name) then
						_func(name)
					else
						SUI.RemoveScaleHook(name, true)
					end
				end
			end

			local pos = keys[name]
			if pos then
				hooks[pos + 1] = func
			else
				hooks[n + 1] = name
				hooks[n + 2] = func
				keys[name] = n + 1
				n = n + 2
			end
		end

		function SUI.RemoveScaleHook(name, in_hook)
			local pos = keys[name]
			if not pos then return end

			if in_hook then
				hooks[pos] = nil
				hooks[pos + 1] = nil
			else
				local new_name = hooks[n - 1]
				if new_name then
					hooks[pos], hooks[pos + 1] = new_name, hooks[n]
					hooks[n - 1], hooks[n] = nil, nil
					keys[new_name] = pos
				end
				n = n - 2
			end
			keys[name] = nil
		end

		function SUI.CallScaleChanged()
			if n == 0 then return end

			local i, c_n = 2, n
			::loop::
			local func = hooks[i]
			if func then
				func()
				i = i + 2
			else
				local _n, _i = c_n, i
				if n ~= c_n then
					_n = n
					i = i + 2
				else
					c_n = c_n - 2
				end

				local new_name = hooks[_n - 1]
				if new_name then
					hooks[_i - 1], hooks[_i] = new_name, hooks[_n]
					hooks[_n - 1], hooks[_n] = nil, nil
					keys[new_name] = _i - 1
				end

				n = n - 2
			end

			if i <= c_n then
				goto loop
			end
		end

		function SUI.GetScale()
			return scale
		end

		SUI.scale = 1
	end

	do
		local fonts = {}

		function SUI.CreateFont(font_name, font, size, weight)
			font_name = addon_name .. font_name

			fonts[font_name] = fonts[font_name] or {
				font = font,
				size = size,
				weight = weight
			}

			surface.CreateFont(font_name, {
				font = font,
				size = Scale(size),
				weight = weight,
				extended = true
			})

			return font_name
		end

		function SUI.GetFont(font_name)
			return addon_name .. font_name
		end

		function SUI.GetFontHeight(font_name)
			local font = fonts[addon_name .. font_name] or fonts[font_name]
			if not font then return 0 end

			return floor(Scale(font.size or 0))
		end

		SUI.fonts = fonts
	end

	do
		local materials = {}

		local delay = 0.008
		local next_run = UnPredictedCurTime()

		function SUI.Material(mat, allow_delay)
			local _mat = materials[mat]
			if _mat then return _mat end

			if allow_delay then
				if UnPredictedCurTime() < next_run then return end
				next_run = UnPredictedCurTime() + delay
			end

			materials[mat] = Material(mat)

			return materials[mat]
		end

		SUI.materials = materials
	end

	SUI.SetTheme("Dark")

	for _, f in ipairs(file.Find("sui/vgui/sui_*.lua", "LUA")) do
		include("sui/vgui/" .. f)
	end

	for _, f in ipairs(file.Find(string.format("sui/vgui/%s_*.lua", addon_name:lower()), "LUA")) do
		include("sui/vgui/" .. f)
	end

	return SUI
end

sui.themes = sui.themes or {}
function sui.add_theme(name, tbl)
	prepare_theme(tbl)
	sui.themes[name] = tbl
end

function sui.valid_options()
	local objs = {}
	objs.IsValid = function()
		local valid = true
		for i = 1, #objs do
			local obj = objs[i]
			if obj:IsValid() and obj.valid == false then
				valid = false
				break
			end
		end
		return valid
	end
	objs.Add = function(obj)
		table.insert(objs, obj)
	end
	return objs
end

do
	local label = vgui.Create("Label")
	label:SetVisible(false)
	label:SetMouseInputEnabled(false)
	label:SetKeyboardInputEnabled(false)

	local SetFontInternal = label.SetFontInternal
	local SetText = label.SetText
	local GetTextSize = label.GetTextSize
	function sui.get_text_size(text, font)
		SetFontInternal(label, font)
		SetText(label, text)
		return GetTextSize(label)
	end
end

do
	local SURFACE = Color(31, 31, 31)
	local PRIMARY = Color(65, 185, 255)

	local ON_SURFACE = Color(255, 255, 255)
	local ON_SURFACE_HIGH_EMPHASIS = ColorAlpha(ON_SURFACE, 221)
	local ON_SURFACE_MEDIUM_EMPHASIS = ColorAlpha(ON_SURFACE, 122)
	local ON_SURFACE_DISABLED = ColorAlpha(ON_SURFACE, 97)

	local ON_PRIMARY = Color(60, 60, 60)

	sui.add_theme("Dark", {
		frame = Color(18, 18, 18),
		frame_blur = false,

		title = ON_SURFACE,
		header = SURFACE,

		close = ON_SURFACE_MEDIUM_EMPHASIS,
		close_hover = Color(255, 60, 60),
		close_press = Color(255, 255, 255, 30),

		button = PRIMARY,
		button_text = "#050709",
		button_hover = ColorAlpha(ON_PRIMARY, 100),
		button_click = ColorAlpha(ON_PRIMARY, 240),
		button_disabled = Color(100, 100, 100),
		button_disabled_text = "#bdbdbd",

		button2_hover = ColorAlpha(PRIMARY, 5),
		button2_selected = ColorAlpha(PRIMARY, 15),

		scroll = ColorAlpha(PRIMARY, 97),
		scroll_grip = PRIMARY,

		scroll_panel = Color(29, 29, 29),
		scroll_panel_outline = false,

		text_entry_bg = Color(34, 34, 34),
		text_entry_bar_color = Color(0, 0, 0, 0),
		text_entry = ON_SURFACE_HIGH_EMPHASIS,
		text_entry_2 = ON_SURFACE_MEDIUM_EMPHASIS,
		text_entry_3 = PRIMARY,

		property_sheet_bg = Color(39, 39, 39),
		property_sheet_tab = Color(150, 150, 150),
		property_sheet_tab_click = Color(255, 255, 255, 30),
		property_sheet_tab_active = PRIMARY,

		toggle_button = ON_SURFACE_DISABLED,
		toggle_button_switch = ON_SURFACE_HIGH_EMPHASIS,

		toggle_button_active = ColorAlpha(PRIMARY, 65),
		toggle_button_switch_active = PRIMARY,

		slider_knob = PRIMARY,
		slider_track = ColorAlpha(PRIMARY, 65),
		slider_hover = ColorAlpha(PRIMARY, 5),
		slider_pressed = ColorAlpha(PRIMARY, 30),

		on_sheet = Color(43, 43, 43, 200),
		on_sheet_hover = Color(200, 200, 200, 20),

		--=--
		query_box_bg = "#181818",
		query_box_cancel = Color(244, 67, 54, 30),
		query_box_cancel_text = "#f44336",
		--=--

		--=--
		menu = "#212121",

		menu_option = "#212121",
		menu_option_text = "#bdbdbd",
		menu_option_hover = "#3b3b3b",
		menu_option_hover_text = "#fefefe",

		menu_spacer = "#303030",
		--=--

		line = "#303030",

		--=--
		column_sheet = "#263238",
		column_sheet_bar = "#202020",

		column_sheet_tab = "#202020",
		column_sheet_tab_hover = "#2e2e2e",
		column_sheet_tab_active = "#383838",

		column_sheet_tab_icon = "#909090",
		column_sheet_tab_icon_hover = "#f0f0f0",
		column_sheet_tab_icon_active = "#34a1e0",
		--=--

		--=--
		collapse_category_header = "#272727",
		collapse_category_header_hover = "#2a2a2a",
		collapse_category_header_active = "#2e2e2e",

		collapse_category_header_text = "#aaaaaa",
		collapse_category_header_text_hover = "#dcdcdc",
		collapse_category_header_text_active = "#34A1E0",

		collapse_category_item = "#343434",
		collapse_category_item_hover = "#464646",
		collapse_category_item_active = "#535353",

		collapse_category_item_text = "#aaaaaa",
		collapse_category_item_text_hover = "#dcdcdc",
		collapse_category_item_text_active = "#ffffff",
		--=--
	})
end

do
	local PRIMARY = Color(65, 185, 255)

	local ON_PRIMARY = Color(220, 220, 220)

	sui.add_theme("Blur", {
		frame = Color(30, 30, 30, 220),
		frame_blur = true,

		title = Color(255, 255, 255),
		header = Color(60, 60, 60, 200),

		close = Color(200, 200, 200),
		close_hover = Color(255, 60, 60),
		close_press = Color(255, 255, 255, 30),

		button = ColorAlpha(PRIMARY, 130),
		button_text = ON_PRIMARY,
		button_hover = Color(0, 0, 0, 30),
		button_click = PRIMARY,
		button_disabled = Color(100, 100, 100),
		button_disabled_text = "#bdbdbd",

		button2_hover = ColorAlpha(PRIMARY, 5),
		button2_selected = ColorAlpha(PRIMARY, 15),

		scroll = Color(0, 0, 0, 100),
		scroll_grip = PRIMARY,

		scroll_panel = Color(255, 255, 255, 10),
		scroll_panel_outline = false,

		text_entry_bg = Color(0, 0, 0, 0),
		text_entry_bar_color = Color(200, 200, 200, 153),
		text_entry = Color(240, 240, 240, 221),
		text_entry_2 = Color(200, 200, 200, 153),
		text_entry_3 = PRIMARY,

		property_sheet_bg = Color(60, 60, 60, 200),
		property_sheet_tab = Color(150, 150, 150),
		property_sheet_tab_click = Color(255, 255, 255, 40),
		property_sheet_tab_active = PRIMARY,

		toggle_button = Color(244, 67, 54),
		toggle_button_switch = Color(230, 230, 230),

		toggle_button_active = PRIMARY,
		toggle_button_switch_active = Color(230, 230, 230),

		slider_knob = PRIMARY,
		slider_track = ColorAlpha(PRIMARY, 100),
		slider_hover = ColorAlpha(PRIMARY, 40),
		slider_pressed = ColorAlpha(PRIMARY, 70),

		on_sheet = Color(60, 60, 60, 180),
		on_sheet_hover = Color(30, 30, 30, 70),

		--=--
		query_box_bg = Color(0, 0, 0, 100),
		query_box_cancel = Color(244, 67, 54, 30),
		query_box_cancel_text = "#f44336",
		--=--
	})
end

--PATH addons/____sui/lua/sui/vgui/sui_image.lua:
local table = table
local file = file
local coroutine = coroutine
local surface = surface

local UnPredictedCurTime = UnPredictedCurTime
local pairs = pairs

local color_white = color_white

local sui = sui
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local read_gif = include("sui/libs/gif_loader.lua")
local generate_png = include("sui/libs/png_encoder.lua")

local images_path = (NAME .. "/images/"):lower()
file.CreateDir(images_path)

local get_image_path = function(url)
	return images_path .. (url:gsub("%W", "_") .. ".png")
end

local Write = file.Write
local gif_to_png; do
	local internal_gif_to_png = function(file_path, chunk)
		local gif = read_gif(chunk)
		local frames = gif:get_frames()
		local w, h = gif.width, gif.height

		local path = file_path .. "/"
		file.CreateDir(path)

		for frame_id = 1, #frames do
			local frame = frames[frame_id]
			local data = frame.data
			local png = generate_png(w, h, data)
			Write(("%s%d_%d.png"):format(path, frame_id, frame.delay), png)
			coroutine.yield()
		end
	end

	local delay = 0.01
	local next_run = 0

	local coroutines = {}
	local callbacks = {}
	gif_to_png = function(file_path, data, callback)
		local co = coroutine.create(internal_gif_to_png)
		local i = table.insert(coroutines, co)
		callbacks[i] = callback
		coroutine.resume(co, file_path, data)
		next_run = UnPredictedCurTime()
	end

	hook.Add("Think", NAME .. "ProcessGIFs", function()
		local co = coroutines[1]
		if not co then return end
		if UnPredictedCurTime() < next_run then return end

		if coroutine.status(co) == "suspended" then
			coroutine.resume(co)
		else
			callbacks[1]()
			table.remove(coroutines, 1)
			table.remove(callbacks, 1)
		end

		next_run = UnPredictedCurTime() + delay
	end)

	hook.Add(NAME .. "ImagesCleared", "ClearCoroutines", function()
		table.Empty(coroutines)
		table.Empty(callbacks)
	end)
end

local download_image, is_downloading_image; do
	-- https://stackoverflow.com/questions/25959386/how-to-check-if-a-file-is-a-valid-image
	local valid_images = {
		["\xff\xd8\xff"] = "jpeg",
		["\x89PNG\r\n\x1a\n"] = "png",
		["GIF87a"] = "gif",
		["GIF89a"] = "gif",
	}

	local get_image_type = function(data)
		for k, v in pairs(valid_images) do
			if data:StartWith(k) then
				return v
			end
		end
		return false
	end

	local downloading_images = {}

	local process_callbacks = function(url)
		local callbacks = downloading_images[url] or {}
		downloading_images[url] = nil

		for _, func in ipairs(callbacks) do
			func()
		end
	end

	download_image = function(url, callback)
		if downloading_images[url] then
			table.insert(downloading_images[url], callback)
			return
		end

		downloading_images[url] = {callback}

		http.Fetch(url, function(data)
			local image_type = get_image_type(data)
			if not image_type then
				downloading_images[url] = nil
				return
			end

			local image_path = get_image_path(url)

			if image_type == "gif" then
				gif_to_png(image_path, data, function()
					process_callbacks(url)
				end)
			else
				file.Write(image_path, data)
				process_callbacks(url)
			end
		end, function(err)
			print("(SUI) Failed to download an image, error: " .. err)
			downloading_images[url] = nil
		end)
	end

	is_downloading_image = function(url)
		return downloading_images[url] ~= nil
	end

	hook.Add(NAME .. "ImagesCleared", "ClearDownloadingImages", function()
		table.Empty(downloading_images)
	end)
end

local images_panels = {}

local PANEL = {}

local err_mat = SUI.Material("error")

function PANEL:Init()
	self:SetMouseInputEnabled(false)

	self.minus = 0
	self.rotation = 0
	self.image = err_mat
	self.image_col = color_white

	table.insert(images_panels, self)
end

function PANEL:OnRemove()
	for k, v in ipairs(images_panels) do
		if v == self then
			table.remove(images_panels, k)
			return
		end
	end
end

function PANEL:SetMinus(minus)
	self.minus = minus
end

function PANEL:SetRotation(rotation)
	self.rotation = rotation
end

function PANEL:SetImageColor(col)
	self.image_col = col
end

local cached_files = {}
local get_files = function(image_path)
	local f = cached_files[image_path]
	if f then return f end

	cached_files[image_path] = file.Find(image_path .. "/*", "DATA")

	return cached_files[image_path]
end

function PANEL:SetImage(url)
	self.image = err_mat

	self.pos = nil
	self.delay = nil

	self.images = nil
	self.delays = nil
	self.url = url

	if url:sub(1, 4) ~= "http" then
		self.image = SUI.Material(url)
		return
	end

	local image_path = get_image_path(url)
	if not file.Exists(image_path, "DATA") or is_downloading_image(url) then
		download_image(url, function()
			if self:IsValid() then
				self:SetImage(url)
			end
		end)
		return
	end

	local is_gif = file.IsDir(image_path, "DATA")
	if is_gif then
		local images = {}
		local delays = {}

		local files = get_files(image_path)
		for i = 1, #files do
			local v = files[i]
			local id, delay = v:match("(.*)_(.*)%.png")
			id = tonumber(id)
			local img_path = "../data/" .. image_path .. "/" .. v
			images[id] = img_path
			delays[id] = delay
		end

		self.frame = 1
		self.delay = (UnPredictedCurTime() * 100) + delays[1]

		self.images = images
		self.delays = delays

		self.max_images = #files
	else
		self.image = SUI.Material("../data/" .. image_path)
	end
end

local SetMaterial = surface.SetMaterial
function PANEL:PaintGIF(w, h, images)
	local frame = self.frame

	-- SUI.Material() caches materials by default
	local mat = SUI.Material(images[frame], true)
	if not mat then
		if frame > 1 then
			mat = SUI.Material(images[frame - 1])
		else
			mat = err_mat
		end

		SetMaterial(mat)

		return
	end

	SetMaterial(mat)

	local curtime = UnPredictedCurTime() * 100
	if curtime < self.delay then return end
	frame = frame + 1
	if frame > self.max_images then
		frame = 1
	end

	self.frame = frame
	self.delay = curtime + self.delays[frame]
end

local PaintGIF = PANEL.PaintGIF
local SetDrawColor = surface.SetDrawColor
local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
function PANEL:Paint(w, h)
	SetDrawColor(self.image_col)

	local images = self.images
	if images then
		PaintGIF(self, w, h, images)
	else
		SetMaterial(self.image)
	end

	if self.Draw then
		self:Draw(w, h, true)
	else
		local minus = self.minus
		DrawTexturedRectRotated(w * 0.5, h * 0.5, w - minus, h - minus, self.rotation)
	end
end

sui.register("Image", PANEL, "PANEL")

function SUI.ClearImages()
	local files, dirs = file.Find(images_path .. "/*", "DATA")
	for _, f in ipairs(files) do
		file.Delete(images_path .. f)
	end

	for _, d in ipairs(dirs) do
		for _, f in ipairs(file.Find(images_path .. d .. "/*", "DATA")) do
			file.Delete(images_path .. (d .. "/" .. f))
		end
		file.Delete(images_path .. d)
	end

	table.Empty(SUI.materials)
	table.Empty(cached_files)

	hook.Call(NAME .. "ImagesCleared")

	for k, v in ipairs(images_panels) do
		if v.url then
			v:SetImage(v.url)
		end
	end
end
--PATH addons/____sui/lua/sui/libs/gif_loader.lua:
local byte = string.byte
local sub = string.sub
local lshift = bit.lshift
local rshift = bit.rshift
local bor = bit.bor
local band = bit.band

local GIFDecoder = {}
local GIFDecoderMethods = {}
local GIFDecoder_meta = {__index = GIFDecoderMethods}

function GIFDecoder.new(buf)
	local buf_n = #buf
	local this = setmetatable({
		p = 1,
		buf = buf
	}, GIFDecoder_meta)

	local version = this:read(6)
	assert(version == "GIF89a" or version == "GIF87a", "wrong file format")

	this.width = this:word()
	this.height = this:word()

	local pf0 = this:byte()
	local global_palette_flag = rshift(pf0, 7)
	local num_global_colors_pow2 = band(pf0, 0x7)
	local num_global_colors = lshift(1, num_global_colors_pow2 + 1)
	this:skip(2)

	local global_palette_offset = nil
	local global_palette_size = nil

	if global_palette_flag > 0 then
		global_palette_offset = this.p
		this.global_palette_offset = global_palette_offset
		global_palette_size = num_global_colors
		this:skip(num_global_colors * 3)
	end

	local no_eof = true

	local frames = {}

	local delay = 0
	local transparent_index = nil
	local disposal = 1

	while no_eof and this.p <= buf_n do
		local b = this:byte()
		if b == 0x3b then
			no_eof = false
		elseif b == 0x2c then
			local x, y, w, h = this:word(), this:word(), this:word(), this:word()
			local pf2 = this:byte()
			local local_palette_flag = rshift(pf2, 7)
			local interlace_flag = band(rshift(pf2, 6), 1)
			local num_local_colors_pow2 = band(pf2, 0x7)
			local num_local_colors = lshift(1, num_local_colors_pow2 + 1)
			local palette_offset = global_palette_offset
			local palette_size = global_palette_size
			local has_local_palette = false
			if local_palette_flag ~= 0 then
				has_local_palette = true
				palette_offset = this.p
				palette_size = num_local_colors
				this:skip(num_local_colors * 3)
			end

			local data_offset = this.p

			this:skip(1)
			this:skip_eob()

			table.insert(frames, {
				x = x,
				y = y,
				width = w,
				height = h,
				has_local_palette = has_local_palette,
				palette_offset = palette_offset,
				palette_size = palette_size,
				data_offset = data_offset,
				data_length = this.p - data_offset,
				transparent_index = transparent_index,
				interlaced = interlace_flag > 0,
				delay = delay,
				disposal = disposal
			})
		elseif b == 0x21 then
			local b2 = this:byte()
			if b2 == 0xf9 then
				local len, flags = this:bytes(2)
				delay = this:word()
				local transparent, terminator = this:bytes(2)

				assert(len == 4 and terminator == 0, "Invalid graphics extension block.")

				if flags % 2 == 1 then
					transparent_index = transparent
				else
					transparent_index = nil
				end

				disposal = math.floor(flags / 4) % 8
			elseif b2 == 0xff then
				this:read(this:byte())
				this:skip_eob()
			else
				this:skip_eob()
			end
		end
	end

	this.frames = frames

	return this
end

function GIFDecoderMethods:skip(offset)
	self.p = self.p + offset
end

-- skip to end of block
function GIFDecoderMethods:skip_eob()
	repeat
		local size = self:byte()
		self:skip(size)
	until size == 0
end

function GIFDecoderMethods:byte()
	local b = byte(self.buf, self.p)
	self:skip(1)
	return b
end

function GIFDecoderMethods:bytes(len)
	local _p = self.p
	self:skip(len)
	return byte(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:read(len)
	local _p = self.p
	self:skip(len)
	return sub(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:word()
	return bor(self:byte(), lshift(self:byte(), 8))
end

local GifReaderLZWOutputIndexStream = function(this, output, output_length)
	local min_code_size = this:byte()
	local clear_code = lshift(1, min_code_size)
	local eoi_code = clear_code + 1
	local next_code = eoi_code + 1
	local cur_code_size = min_code_size + 1

	local code_mask = lshift(1, cur_code_size) - 1
	local cur_shift = 0
	local cur = 0
	local op = 0

	local subblock_size = this:byte()

	local code_table = {}

	local prev_code = nil

	while true do
		while cur_shift < 16 do
			if subblock_size == 0 then break end

			cur = bor(cur, lshift(this:byte(), cur_shift))
			cur_shift = cur_shift + 8

			if subblock_size == 1 then
				subblock_size = this:byte()
			else
				subblock_size = subblock_size - 1
			end
		end

		if cur_shift < cur_code_size then break end

		local code = band(cur, code_mask)
		cur = rshift(cur, cur_code_size)
		cur_shift = cur_shift - cur_code_size

		if code == clear_code then
			next_code = eoi_code + 1
			cur_code_size = min_code_size + 1
			code_mask = lshift(1, cur_code_size) - 1

			prev_code = null
			continue
		elseif code == eoi_code then
			break
		end

		local chase_code = code < next_code and code or prev_code
		local chase_length = 0
		local chase = chase_code
		while chase > clear_code do
			chase = rshift(code_table[chase], 8)
			chase_length = chase_length + 1
		end

		local k = chase
		local op_end = op + chase_length + (chase_code ~= code and 1 or 0)
		if op_end > output_length then
			Error("Warning, gif stream longer than expected.")
			return
		end

		output[op] = k; op = op + 1
		op = op + chase_length

		local b = op

		if chase_code ~= code then
			output[op] = k; op = op + 1
		end
		chase = chase_code

		while chase_length > 0 do
			chase_length = chase_length - 1
			chase = code_table[chase]
			b = b - 1
			output[b] = band(chase, 0xff)

			chase = rshift(chase, 8)
		end

		if prev_code ~= nil and next_code < 4096 then
			code_table[next_code] = bor(lshift(prev_code, 8), k)
			next_code = next_code + 1

			if next_code >= code_mask + 1 and cur_code_size < 12 then
				cur_code_size = cur_code_size + 1
				code_mask = bor(lshift(code_mask, 1), 1)
			end
		end

		prev_code = code
	end

	if op ~= output_length then
		Error("Warning, gif stream shorter than expected.")
	end

	return output
end

function GIFDecoderMethods:decode_and_blit_frame_RGBA(frame_num, pixels)
	local frame = self.frames[frame_num]
	local num_pixels = frame.width * frame.height
	local index_stream = {}

	self.p = frame.data_offset
	GifReaderLZWOutputIndexStream(self, index_stream, num_pixels)
	local palette_offset = frame.palette_offset

	local trans = frame.transparent_index
	if trans == nil then
		trans = 256
	end

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local buf = self.buf
	while i < num_pixels do
		local index = index_stream[i]

		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		if index ~= trans then
			index = palette_offset + index * 3
			pixels[op + 0] = byte(buf, index)
			pixels[op + 1] = byte(buf, index + 1)
			pixels[op + 2] = byte(buf, index + 2)
			pixels[op + 3] = 255
		end

		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:clear_frame(frame_num, pixels)
	local frame = self.frames[frame_num]

	self.p = frame.data_offset

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local num_pixels = frame.width * frame.height
	while i < num_pixels do
		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		pixels[op + 0] = 0
		pixels[op + 1] = 0
		pixels[op + 2] = 0
		pixels[op + 3] = 0
		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:get_frames()
	local num_pixels = self.width * self.height * 4 + 4
	local frames = {}
	local numFrames = #self.frames
	local last_frame
	local restore_from
	for i = 1, numFrames do
		local frame = self.frames[i]

		local data = {}

		if last_frame then
			local _data = last_frame.data
			for k = 0, num_pixels do
				data[k] = _data[k]
			end
		end

		if i > 1 then
			local last_disposal = last_frame.disposal
			if last_disposal == 3 then
				if restore_from then
					for k = 0, num_pixels do
						data[k] = restore_from[k]
					end
				else
					self:clear_frame(i - 1, data)
				end
			end

			if last_disposal == 2 then
				self:clear_frame(i - 1, data)
			end
		end

		self:decode_and_blit_frame_RGBA(i, data)

		local delay = frame.delay
		if delay < 2 then
			delay = 10
		end

		local disposal = frame.disposal
		last_frame = {
			data = data,
			delay = delay,
			disposal = disposal
		}
		frames[i] = last_frame

		if disposal ~= 3 then
			restore_from = data
		end
	end

	return frames
end

return GIFDecoder.new
--PATH addons/____sui/lua/sui/vgui/sui_query_box.lua:
local ScrW, ScrH = ScrW, ScrH
local DisableClipping = DisableClipping
local SetDrawColor = surface.SetDrawColor
local DrawRect = surface.DrawRect
local BlurPanel = sui.TDLib.BlurPanel
local lerp_color = sui.lerp_color

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local PANEL = {}

function PANEL:SetCallback(callback)
	self.callback = callback
end

function PANEL:Init()
	self:SetSize(0, 0)

	local bottom = self:Add("Panel")
	bottom:Dock(BOTTOM)
	bottom:DockMargin(4, 10, 4, 4)
	bottom:SetZPos(100)

	local save = bottom:Add(NAME .. ".Button")
	save:SetText("SAVE")
	save:Dock(RIGHT)
	save:SetEnabled(false)
	self.save = save

	function save.DoClick()
		self.callback()
		self:Remove()
	end

	local cancel = bottom:Add(NAME .. ".Button")
	cancel:Dock(RIGHT)
	cancel:DockMargin(0, 0, 4, 0)
	cancel:SetContained(false)
	cancel:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))
	cancel:SetText("CANCEL")
	self.cancel = cancel

	function cancel.DoClick()
		self:Remove()
	end

	bottom:SetSize(save:GetWide() * 2 + 4, SUI.Scale(30))

	local body = self:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(4, 4, 4, 4)
	body:DockPadding(3, 3, 3, 3)
	body:InvalidateLayout(true)
	body:InvalidateParent(true)

	local added = 1
	function body.OnChildAdded(s, child)
		added = added + 1
		child:Dock(TOP)
		child:SetZPos(added)
		child:InvalidateLayout(true)
		s:InvalidateLayout(true)
	end
	self.body = body

	function self:Add(name)
		return body:Add(name)
	end

	local old_Paint = self.Paint
	local trans = Color(0, 0, 0, 0)
	local new_col = Color(70, 70, 70, 100)
	function self:Paint(w, h)
		lerp_color(trans, new_col)

		local x, y = self:LocalToScreen(0, 0)
		DisableClipping(true)
			BlurPanel(self)
			SetDrawColor(trans)
			DrawRect(x * -1, y * -1, ScrW(), ScrH())
		DisableClipping(false)

		old_Paint(self, w, h)
	end
end

function PANEL:ChildrenHeight()
	local body = self.body

	self.header:InvalidateLayout(true)
	local height = self.header:GetTall()

	body:InvalidateLayout(true)
	self:InvalidateLayout(true)
	height = height + select(2, body:ChildrenSize())

	height = height + SUI.Scale(30) + 14 + 6

	return height
end

function PANEL:Paint(w, h)
	if GetColor("frame_blur") then
		BlurPanel(self)
	end

	self:RoundedBox("Background", 8, 0, 0, w, h, GetColor("query_box_bg"))
end

function PANEL:Done()
	self:InvalidateChildren(true)

	self.size_to_children = function()
		local h = self:ChildrenHeight()
		self:RealSetSize(self:GetWide(), h)
		self.real_h = h
	end

	self:Center()
	self:MakePopup()
	self:DoModal(true)

	timer.Simple(0.08, function()
		self:AddAnimations(self:GetWide(), self:ChildrenHeight(), true)
	end)
end

sui.register("QueryBox", PANEL, NAME .. ".Frame")
--PATH addons/____sui/lua/sui/vgui/sui_threegrid.lua:
local math = math
local table = table
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local Panel = {}

AccessorFunc(Panel, "horizontalMargin", "HorizontalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "verticalMargin", "VerticalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "columns", "Columns", FORCE_NUMBER)
AccessorFunc(Panel, "Wide2", "Wide2", FORCE_NUMBER)

function Panel:Init()
	self:SetHorizontalMargin(0)
	self:SetVerticalMargin(0)
	self.Rows = {}
	self.Cells = {}
end

function Panel:AddCell(pnl)
	local cols = self:GetColumns()
	local idx = math.floor(#self.Cells / cols) + 1

	local rows = self.Rows[idx]
	if not rows then
		rows = self:CreateRow()
		self.Rows[idx] = rows
	end

	local margin = self:GetHorizontalMargin()

	local dockl, dockt, _, dockb = pnl:GetDockMargin()
	pnl:SetParent(rows)
	pnl:Dock(LEFT)
	pnl:DockMargin(dockl, dockt, #rows.Items + 1 < cols and self:GetHorizontalMargin() or 0, dockb)
	pnl:SetWide(((self:GetWide2() or self:GetWide()) - margin * (cols - 1)) / cols)

	table.insert(rows.Items, pnl)
	table.insert(self.Cells, pnl)

	self:CalculateRowHeight(rows)
end

function Panel:CreateRow()
	local row = self:Add("Panel")
	row:Dock(TOP)
	row:DockMargin(0, 0, 0, self:GetVerticalMargin())
	row.Items = {}

	return row
end

function Panel:CalculateRowHeight(row)
	local height = 0

	for k, v in ipairs(row.Items) do
		local _, t, _, b = v:GetDockMargin()
		height = math.max(height, v:GetTall() + t + b)
	end

	row:SetTall(height)
end

function Panel:Skip()
	local cell = vgui.Create("Panel")
	self:AddCell(cell)
end

function Panel:CalculateRowHeights()
	for _, row in ipairs(self.Rows) do
		self:CalculateRowHeight(row)
	end
end

function Panel:Clear()
	for _, row in ipairs(self.Rows) do
		for _, cell in ipairs(row.Items) do
			cell:Remove()
		end

		row:Remove()
	end

	self.Cells, self.Rows = {}, {}
end

Panel.OnRemove = Panel.Clear
sui.register("ThreeGrid", Panel, NAME .. ".ScrollPanel")
--PATH addons/____sam/lua/sam/menu/tabs/config.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local tabs = {}
if CLIENT then
	function config.add_tab(name, func, check, pos)
		local tab = {
			name = name,
			func = func,
			check = check,
			pos = pos
		}
		for k, v in ipairs(tabs) do
			if v.name == name then
				tabs[k] = tab
				return
			end
		end
		table.insert(tabs, tab)
	end
end

for _, f in ipairs(file.Find("sam/menu/tabs/config/*.lua", "LUA")) do
	sam.load_file("sam/menu/tabs/config/" .. f, "cl_")
end

if SERVER then return end

local SUI = sam.SUI
local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/config.png", function(column_sheet)
	local tab_body = column_sheet:Add("Panel")
	tab_body:Dock(FILL)
	tab_body:DockMargin(0, 1, 0, 0)

	do
		local title = tab_body:Add("SAM.Label")
		title:Dock(TOP)
		title:DockMargin(10, 10, 0, 0)
		title:SetFont(SAM_TAB_TITLE_FONT)
		title:SetText("Config")
		title:SetTextColor(GetColor("menu_tabs_title"))
		title:SizeToContents()

		local total = tab_body:Add("SAM.Label")
		total:Dock(TOP)
		total:DockMargin(10, 6, 0, 0)
		total:SetFont(SAM_TAB_DESC_FONT)
		total:SetText("Some settings may require a server restart")
		total:SetTextColor(GetColor("menu_tabs_title"))
		total:SetPos(10, SUI.Scale(40))
		total:SizeToContents()
	end

	local body = tab_body:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(10, 5, 10, 10)

	Line(body, nil, 0, 0, 0, 10)

	local sheet = body:Add("SAM.PropertySheet")
	sheet:Dock(FILL)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)

	local sheets = {}
	for _, v in SortedPairsByMemberValue(tabs, "pos") do
		sheets[v.name] = sheet:AddSheet(v.name, v.func)
	end

	local tab_scroller = sheet.tab_scroller:GetCanvas()
	function tab_body.Think()
		for _, v in ipairs(tabs) do
			local tab = sheets[v.name]
			if v.check and not v.check() then
				if tab:IsVisible() then
					tab:SetVisible(false)
					if sheet:GetActiveTab() == tab then
						sheet:SetActiveTab(sheet.tabs[1])
					end
					tab_scroller:InvalidateLayout()
				end
			elseif not tab:IsVisible() then
				tab:SetVisible(true)
				tab_scroller:InvalidateLayout()
			end
		end
	end

	return tab_body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 5)
--PATH addons/____sam/lua/sam/menu/tabs/config/server.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

config.add_tab("Server", function(parent)
	local server_body = parent:Add("SAM.ScrollPanel")
	server_body:Dock(FILL)
	server_body:LineMargin(0, 6, 0, 0)

	local i = 0
	server_body:GetCanvas():On("OnChildAdded", function(s, child)
		i = i + 1
		child:SetZPos(i)
	end)

	for k, v in ipairs(sam.config.get_menu_settings()) do
		local panel = v.func(server_body)
		if ispanel(panel) then
			local setting = server_body:Add("SAM.LabelPanel")
			setting:DockMargin(8, 6, 8, 0)
			setting:SetLabel(v.title)
			setting:SetPanel(panel)
		end

		server_body:Line()
	end

	return server_body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 1)
--PATH addons/____sam/lua/sam/modules/command_notify_for_ranks.lua:
--
-- Make command notifying only for ranks you select.
-- permission is command_notify. (by default admin+ has it)
-- You can NOT use this with 'command_hide_admin_name.lua'
--
if SAM_LOADED then return end

sam.permissions.add("command_notify", nil, "admin")

if SERVER then
	local get_players = function()
		local players = {}
		for _, v in ipairs(player.GetAll()) do
			if v:HasPermission("command_notify") then
				table.insert(players, v)
			end
		end
		return players
	end

	sam.player.old_send_message = sam.player.old_send_message or sam.player.send_message
	function sam.player.send_message(ply, msg, tbl)
		if ply == nil and debug.traceback():find("lua/sam/command/", 1, true) then
			sam.player.old_send_message(get_players(), msg, tbl)
		else
			sam.player.old_send_message(ply, msg, tbl)
		end
	end
end
--PATH addons/____onyx_creditstore_integrations/lua/sam/modules/onyx_store.lua:
if SAM_LOADED then return end

sam.command.set_category('Onyx Store')

sam.command.new('givecredits')
:SetPermission('givecredits', 'superadmin')
:Help('Give credits to a player.')
:AddArg('player', {
    single_target = true,
    allow_higher_target = true
})
:AddArg('number', {
    hint = 'credits',
    round = true
})
:OnExecute(function(caller, targets, number)
    local target = targets[1]

    if (target:onyx_GetNetVar('store_busy')) then
        caller:sam_send_message('({S Red}) {T} is handling operation, try again later!', {S = 'Error', T = targets})
        return
    end

    onyx.creditstore:AddCredits(target, number)

    sam.player.send_message(nil, '{A} gave {T} {V} credits.', {
        A = caller,
        T = targets,
        V = number
    })
end):End()

sam.command.new('takecredits')
:SetPermission('takecredits', 'superadmin')
:Help('Take credits from a player.')
:AddArg('player', {
    single_target = true,
    allow_higher_target = true
})
:AddArg('number', {
    hint = 'credits',
    round = true
})
:OnExecute(function(caller, targets, number)
    local target = targets[1]

    if (target:onyx_GetNetVar('store_busy')) then
        caller:sam_send_message('({S Red}) {T} is handling operation, try again later!', {S = 'Error', T = targets})
        return
    end

    onyx.creditstore:TakeCredits(target, number)

    sam.player.send_message(nil, '{A} removed {V} credits from {T}.', {
        A = caller,
        T = targets,
        V = number
    })
end):End()

sam.command.new('setcredits')
:SetPermission('setcredits', 'superadmin')
:Help('Set credits to a player')
:AddArg('player', {
    single_target = true,
    allow_higher_target = true
})
:AddArg('number', {
    hint = 'credits',
    round = true
})
:OnExecute(function(caller, targets, number)
    local target = targets[1]

    if (target:onyx_GetNetVar('store_busy')) then
        caller:sam_send_message('({S Red}) {T} is handling operation, try again later!', {S = 'Error', T = targets})
        return
    end

    onyx.creditstore:SetCredits(target, number)

    sam.player.send_message(nil, '{A} set {T} credits to {V}.', {
        A = caller,
        T = targets,
        V = number
    })
end):End()
--PATH addons/_bitminers2ex/lua/autorun/sh_bitminers2_extras.lua:
BITMINERS_2_EXTRAS_DLC = true
--PATH addons/_boombox/lua/retroboombox/client/cl_3dframe.lua:
local PANEL = {}
AccessorFunc( PANEL, "_shouldDrawCursor", "DrawCursor", FORCE_BOOL )
AccessorFunc( PANEL, "_cusorColor", "CursorColor" )
AccessorFunc( PANEL, "_cursorRad", "CursorRadius" )
function PANEL:OnChildAdded( oChild )
	self.ChildrenList = self.ChildrenList or {}
	timer.Simple( 2, function()
		if not IsValid( oChild ) then return end
		oChild.IsHovered = function() return oChild.m_isHovered end
	end )

	table.insert( self.ChildrenList, oChild )
end

local function registerChildren( oFrame, oParent )
	table.insert( oFrame.ChildrenList, oParent )
	oParent.IsHovered = function() return oParent.m_isHovered end
	local tChildren = oParent:GetChildren()
	for _, oSecondChild in pairs( tChildren ) do
		if #oSecondChild:GetChildren() > 0 then
			registerChildren( oFrame, oSecondChild )
		else
			table.insert( oFrame.ChildrenList, oSecondChild )
			oSecondChild.IsHovered = function() return oSecondChild.m_isHovered end
		end
	end
end

function PANEL:UpdateChildren()
	self.ChildrenList = {}
	registerChildren( self, self )
end

function PANEL:_CheckHover( iCursorPosX, iCursorPosY, bDoClick, bDown )
	for _, oPanel in pairs( self.ChildrenList or {} ) do
		if not oPanel or not IsValid( oPanel ) then continue end
		local x, y = self:GetChildPosition( oPanel )
		local rx, ry = oPanel:GetSize()
		rx, ry = rx + x, ry + y
		if iCursorPosX >= x and iCursorPosX <= rx and iCursorPosY >= y and iCursorPosY <= ry then
			if bDoClick and oPanel.DoClick and isfunction( oPanel.DoClick ) then oPanel:DoClick() end
			if bDown and oPanel.IsDown and isfunction( oPanel.IsDown ) then oPanel:IsDown() end
			oPanel.m_isHovered = true
		else
			oPanel.m_isHovered = false
		end
	end
end

function PANEL:PaintManual3D( vCamPosition, aCamAngles, iRatio )
	self:PaintManual()
	local iFrameWide, iFrameTall = self:GetSize()
	local iFramePosX, iFramePosY = self:GetPos()
	local vCursorPositionWorld = util.IntersectRayWithPlane( LocalPlayer():GetShootPos(), LocalPlayer():GetAimVector(), vCamPosition, aCamAngles:Up() )
	if not vCursorPositionWorld then return end
	local vCursorPositionLocal = WorldToLocal( vCursorPositionWorld, Angle(), vCamPosition, aCamAngles )
	local iCursorPosX, iCursorPosY = vCursorPositionLocal.x / iRatio, vCursorPositionLocal.y / -iRatio
	if self._shouldDrawCursor then self.CursorPosX, self.CursorPosY = math.Clamp( iCursorPosX, iFramePosX, iFramePosX + iFrameWide ), math.Clamp( iCursorPosY, iFramePosY, iFramePosY + iFrameTall ) end
	if input.IsKeyDown( KEY_E ) and not vgui.CursorVisible() or vgui.CursorVisible() and input.IsMouseDown( MOUSE_LEFT ) then
		self.lastPressUse = true
		return self:_CheckHover( iCursorPosX, iCursorPosY, false, true )
	elseif self.lastPressUse then
		self.lastPressUse = false
		return self:_CheckHover( iCursorPosX, iCursorPosY, true, false )
	end

	self:_CheckHover( iCursorPosX, iCursorPosY, false, false )
end

function PANEL:PaintOver()
	if self._shouldDrawCursor then
		local iCursorRad = self._cursorRad or 1
		draw.RoundedBox( iCursorRad * 2, ( self.CursorPosX or 0 ) - iCursorRad, ( self.CursorPosY or 0 ) - iCursorRad, iCursorRad * 2, iCursorRad * 2, self._cusorColor or Color( 255, 255, 255 ) )
	end
end

derma.DefineControl( "Boombox.3DFrame", "A DFrame, but able to be used in a 3D context", PANEL, "DFrame" )
--PATH addons/zalupa_com/lua/autorun/sh_ya_zaebalysya_eto_delat.lua:
dronemenutbl = {
    ['dronesrewrite_medic'] = true,
    ['dronesrewrite_balltur'] = true,
    ['dronesrewrite_turret'] = true,
    ['dronesrewrite_gunner'] = true,
    ['dronesrewrite_nanodr'] = true,
    ['dronesrewrite_sniper'] = true,
    ['dronesrewrite_spyspider'] = true,
    ['dronesrewrite_spy'] = true,
    ['dronesrewrite_warriordr'] = true,
    ['dronesrewrite_microwave'] = true
}

dronemenutbl2 = {
    ['weapon_drr_fuelcan'] = true,
    ['weapon_drr_remote'] = true,
    ['weapon_drr_repairtool'] = true
}

---- others ----


plogs.Register('Chat', false)

plogs.AddHook('playerAdverted', function(pl, text)
	plogs.PlayerLog(pl, 'Chat', Format('%s(%s) Написав до оголошення "%s"', pl:Name(), pl:SteamID(), text), {
		['Name']	= pl:Name(),
		['SteamID']	= pl:SteamID(),
	})
end)

plogs.AddHook('playerOOC', function(pl, text)
	plogs.PlayerLog(pl, 'Chat', Format('%s(%s) Написав в OOC чат "%s"', pl:Name(), pl:SteamID(), text), {
		['Name']	= pl:Name(),
		['SteamID']	= pl:SteamID(),
	})
end)

plogs.AddHook('playerMeeeee', function(pl, text)
	plogs.PlayerLog(pl, 'Chat', Format('%s(%s) Відіграв через /me: "%s"', pl:Name(), pl:SteamID(), text), {
		['Name']	= pl:Name(),
		['SteamID']	= pl:SteamID(),
	})
end)

plogs.AddHook('playerDooooo', function(pl, text)
	plogs.PlayerLog(pl, 'Chat', Format('%s(%s) Відіграв через /do: "%s"', pl:Name(), pl:SteamID(), text), {
		['Name']	= pl:Name(),
		['SteamID']	= pl:SteamID(),
	})
end)

plogs.AddHook('playerCrick', function(pl, text)
	plogs.PlayerLog(pl, 'Chat', Format('%s(%s) Сказав криком: "%s"', pl:Name(), pl:SteamID(), text), {
		['Name']	= pl:Name(),
		['SteamID']	= pl:SteamID(),
	})
end)

plogs.AddHook('playerShepot', function(pl, text)
	plogs.PlayerLog(pl, 'Chat', Format('%s(%s) Сказав пошепки: "%s"', pl:Name(), pl:SteamID(), text), {
		['Name']	= pl:Name(),
		['SteamID']	= pl:SteamID(),
	})
end)

plogs.AddHook('playerChatText', function(pl, text)
	plogs.PlayerLog(pl, 'Chat', Format('%s(%s) Сказав: "%s"', pl:Name(), pl:SteamID(), text), {
		['Name']	= pl:Name(),
		['SteamID']	= pl:SteamID(),
	})
end)

plogs.AddHook('playerAnonim', function(pl, text)
	plogs.PlayerLog(pl, 'Chat', Format('%s(%s) Шепіт Вітру: "%s"', pl:Name(), pl:SteamID(), text), {
		['Name']	= pl:Name(),
		['SteamID']	= pl:SteamID(),
	})
end)

plogs.AddHook('playerPM', function(pl, target, text)
	plogs.PlayerLog(pl, 'Chat', Format('%s(%s) Написав у PM гравцю  "%s"', pl:Name(), pl:SteamID(), target:Name(), target:SteamID(), text), {
		['Name']	= pl:Name(),
		['SteamID']	= pl:SteamID(),
		['Target Name']	= target:SteamID(),
		['Target SteamID']	= target:SteamID(),
	})
end)
--PATH addons/ukrp_main_content/lua/autorun/sirris_ota_bloodborne.lua:
player_manager.AddValidModel( "OTA BLOODBORNE","models/sirris/ota/OTABLOODBORNE_pm.mdl" );
player_manager.AddValidHands( "OTA BLOODBORNE","models/sirris/ota/OTABLOODBORNE_pm_arms.mdl", 0, "00000000"  );
--PATH addons/__________skeypads/lua/skeypads/main/cl_numpadshortcuts.lua:
local keys = {
    [KEY_PAD_ENTER] = 'enter',
    [KEY_PAD_MINUS] = 'clear'
}

local keyNum = 0
for i = KEY_PAD_0, KEY_PAD_9 do
    keys[i] = tostring( keyNum )
    keyNum = keyNum + 1
end

hook.Add( 'PlayerButtonDown', 'sKeypads::NumpadInputs', function( ply, btn )
    if not keys[btn] then return end
    if ply ~= LocalPlayer() then return end
    local eyePos = ply:EyePos()
    local tr = util.TraceLine( {
        start = eyePos,
        endpos = eyePos + ply:GetAimVector() * 65,
        filter = ply
    } )

    local ent = tr.Entity
    if not IsValid( ent ) or ent:GetClass() ~= 'skeypad' then return end
    net.Start( 'sKeypads::PressKey' )
    net.WriteEntity( ent )
    net.WriteString( keys[btn] )
    net.SendToServer()
end )
--PATH addons/__________skeypads/lua/skeypads/utils/sh_integrity.lua:
sKeypads.Utils = sKeypads.Utils or {}
sKeypads.Types = {
    TYPE_PLAYER = function( obj ) return isentity( obj ) and obj:IsPlayer() end,
    TYPE_ENTITY = isentity,
    TYPE_STRING = isstring,
    TYPE_NUMBER = isnumber,
    TYPE_BOOL = isbool,
    TYPE_ANGLE = isangle,
    TYPE_VECTOR = isvector,
    TYPE_FUNCTION = isfunction,
    TYPE_NIL = function( obj ) return obj == nil end,
    TYPE_TABLE = istable,
    TYPE_BASE_KEYPAD = function( obj ) return obj.imAKeypad or false end
}

function sKeypads.Utils.assert( cond, err, ... )
    assert( cond, "sKeypads:" .. err, ... )
end

function sKeypads.Utils.getTypeName( func )
    for k, v in pairs( sKeypads.Types ) do
        if v == func then return k end
    end
end

function sKeypads.Utils.checkType( param, typeCheck )
    local typ = typeCheck( param )
    sKeypads.Utils.assert( typ, "Type missmatch: Expected " .. sKeypads.Utils.getTypeName( typeCheck ) .. " Got " .. type( param ) )
end

function sKeypads.Utils.isValidSteamID( steamid64 )
    if #steamid64 ~= 17 then return false end
    -- if not tonumber(steamid64) then return false end
    if CLIENT and steamid64 == LocalPlayer():SteamID64() then return false end
    return true
end
--PATH addons/____slib/lua/slib/vgui/cl_slistpanel.lua:
local font = slib.createFont("Roboto", 14)
local textcolor, neutralcolor, successcolor, failcolor, maincolor_7, maincolor_10, maincolor_15, maincolor_25 = slib.getTheme("textcolor"), slib.getTheme("neutralcolor"), slib.getTheme("successcolor"), slib.getTheme("failcolor"), slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 10), slib.getTheme("maincolor", 15), slib.getTheme("maincolor", 25)

local PANEL = {}

function PANEL:Init()
    self:Dock(TOP)
    self:SetTall(slib.getScaledSize(250, "y"))
    self:DockMargin(slib.getTheme("margin"),0,slib.getTheme("margin"),slib.getTheme("margin"))

    self.frame = vgui.Create("SScrollPanel", self)
    self.frame:Dock(FILL)

    self.frame.Paint = function(s,w,h)
        surface.SetDrawColor(maincolor_10)
        surface.DrawRect(0, 0, w, h)
    end

    self.selected = false

    slib.wrapFunction(self, "SetZPos", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
end

function PANEL:addEntry(var, toggleable, tab)
    title = var
    if !isstring(var) and IsValid(var) and var:IsPlayer() then title = var:Nick() end

    local selectable = vgui.Create("DButton", self.frame)
    selectable:SetTall(slib.getScaledSize(25, "y"))
    selectable:Dock(TOP)
    selectable:DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),0)
    selectable:SetText("")
    selectable.name = title
    selectable.tab = tab
    selectable.toggleable = toggleable

    selectable.Paint = function(s,w,h)
        if !isstring(var) and !IsValid(var) then s:Remove() return end

        local wantedcolor
        
        if s.toggleable then
            if isfunction(s.toggleCheck) then
                wantedcolor = s.toggleCheck() and successcolor or failcolor
            end
        else
            wantedcolor = neutralcolor
        end

        wantedcolor.a = 40
        if !s.toggleable and self.selected ~= var then
            wantedcolor.a = 0
        end
        
        surface.SetDrawColor(slib.lerpColor(s, wantedcolor))
        surface.DrawRect(0, 0, w, h)

        surface.SetDrawColor(maincolor_25)
        surface.DrawOutlinedRect(0, 0, w, h)


        draw.SimpleText(selectable.name, font, 5, h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    selectable.DoClick = function()
        self.selected = (self.selected ~= var) and var or nil 
    end

    return self, selectable
end

function PANEL:setTitle(title)
    self.title = title

    if !self.topbar then
        self.topbar = vgui.Create("EditablePanel", self)
        self.topbar:SetTall(slib.getScaledSize(25, "y"))
        self.topbar:Dock(TOP)

        self.topbar.Paint = function(s,w,h)
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0, 0, w, h)

            surface.SetDrawColor(maincolor_25)
            surface.DrawRect(0,h-1,w,1)

            draw.SimpleText(self.title, font, slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end
    end

    return self
end

function PANEL:addSearchbar()
    self.search = vgui.Create("SSearchBar", self.topbar)
    self.search:Dock(RIGHT)
    :DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))

    self.search.entry.bg = maincolor_15
    self.search.entry.onValueChange = function(newval)
        for k,v in pairs(self.frame:GetCanvas():GetChildren()) do
            v:SetVisible(string.find(string.lower(v.name), string.lower(newval)))

            self.frame:GetCanvas():InvalidateLayout(true)
        end
    end

    self.topbar.OnSizeChanged = function()
        self.search:SetWide(self.topbar:GetWide() * .35)
    end

    return self
end

function PANEL:addDropdown()
    self.dropdown = vgui.Create("SDropDown", self.topbar)
    self.dropdown:Dock(RIGHT)
    :DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))

    self.dropdown.bg = maincolor_15
    
    self.dropdown.onValueChange = function(newtab)
        for k,v in pairs(self.frame:GetCanvas():GetChildren()) do
            v:SetVisible(v.tab == newtab)
            self.frame:GetCanvas():InvalidateLayout(true)
        end
    end

    self.topbar.OnSizeChanged = function()
        self.dropdown:SetWide(self.topbar:GetWide() * .35)
    end

    return self.dropdown
end

function PANEL:addButton(title, func, thnk)
    if !self.bottombar then
		self.bottombar = vgui.Create("EditablePanel", self)
		self.bottombar:Dock(BOTTOM)
		self.bottombar:SetTall(slib.getScaledSize(25,"x"))

		self.bottombar.Paint = function(s,w,h)
			surface.SetDrawColor(maincolor_25)
			surface.DrawRect(0, 0, w, 1)
		end
    end

    local bttn = vgui.Create("SButton", self.bottombar)
    bttn:Dock(LEFT)
    :setTitle(title)
    :DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),0,slib.getTheme("margin"))
    
    bttn.DoClick = function() func(self, bttn) end

    if thnk then
        bttn.Think = function() thnk(self, bttn) end
    end

    return self, bttn
end

function PANEL:Paint(w,h)
    surface.SetDrawColor(maincolor_10)
    surface.DrawRect(0, 0, w, h)
end

vgui.Register("SListPanel", PANEL, "EditablePanel")
--PATH addons/____slib/lua/slib/vgui/cl_slistview.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 15)
local textcolor, maincolor_7, linecol, neutralcolor, margin = slib.getTheme("textcolor"), slib.getTheme("maincolor", 7), Color(24,24,24,160), slib.getTheme("neutralcolor"), slib.getTheme("margin")

function PANEL:Init()
    self.Columns = self.Columns or {}
    self.Lines = self.Lines or {}

    self.columniteration = 0
    self.lineiteration = 0
    
    self.assortment = self.assortment or {}

    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "SetSize", nil, function() return self end, true)
	slib.wrapFunction(self, "Center", nil, function() return self end, true)
	slib.wrapFunction(self, "SetPos", nil, function() return self end, true)
	slib.wrapFunction(self, "MakePopup", nil, function() return self end, true)
end

function PANEL:getColumnPos(col)
    local result = self.Columns[col]:GetPos()
    return select(1, result)
end

function PANEL:getColumnWide(col)
    return self.Columns[col]:GetWide()
end

local function differenciate(a, b)
    if isfunction(a) then a = a() end
    if isfunction(b) then b = b() end
    if isnumber(tonumber(a)) and isnumber(tonumber(b)) then return tonumber(a), tonumber(b) end

    if !(isstring(a) == isstring(b)) or isbool(a) or isbool(b) then
        return tostring(a), tostring(b)
    end

    return a, b
end

function PANEL:addColumn(name)
    if !IsValid(self.topbar) then
        self.topbar = vgui.Create("EditablePanel", self)
        self.topbar:Dock(TOP)
        self.topbar:SetZPos(-32768)
        self.topbar:SetTall(slib.getScaledSize(25, "y"))

        self.topbar.Paint = function(s,w,h)
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0, 0, w, h)

            surface.SetDrawColor(linecol)
            surface.DrawRect(0, h - 1, w - 1, 1)
        end
    end

    self.columniteration = self.columniteration + 1

    local iteration = self.columniteration
    local ignoreWidth = false


    if istable(name) then
        if name[2] then
            ignoreWidth = name[2]
        end
        name = name[1]
    end

    self.Columns[iteration] = vgui.Create("DButton", self.topbar)
    self.Columns[iteration]:Dock(LEFT)
    self.Columns[iteration]:SetWide(self:GetWide() / #self.Columns)
    self.Columns[iteration].Width = self:GetWide() / #self.Columns
    self.Columns[iteration]:SetText("")
    self.Columns[iteration].name = name
    self.Columns[iteration].iteration = iteration
    self.Columns[iteration].ignoreWidth = ignoreWidth

    self.Columns[iteration].DoClick = function()
        if self.assortment.iteration == iteration then
            self.assortment.ascending = !self.assortment.ascending
        else
            self.assortment.iteration = iteration
            self.assortment.ascending = true
        end
        
        local basictable = {}
        local cleantable = {}

        for i=1,#self.Lines do
            local tbl = self.Columns[iteration]["lines"][i]
            local sortvalue = istable(tbl) and (tbl.sortvalue or tbl.text) or tbl

            table.insert(basictable, sortvalue)
        end
        
        if self.assortment.ascending then
            table.sort(basictable, function(a, b) a, b = differenciate(a, b) return a > b end)
        else
            table.sort(basictable, function(a, b) a, b = differenciate(a, b) return a < b end)
        end

        for i, z in pairs(basictable) do
            cleantable[z] = i
        end
        
        for i=1,#self.Lines do
            local tbl = self.Columns[iteration]["lines"][i]
            local final = istable(tbl) and (tbl.sortvalue or tbl.text) or tbl

            if !IsValid(self.Lines[i]) then continue end

            self.Lines[i]:SetZPos(cleantable[final])
        end
    end

    self.Columns[iteration].Paint = function(s,w,h)
        draw.SimpleText(name, font, slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    return self
end

function PANEL:addColumns(...)
    local args = {...}

    for k,v in pairs(args) do
        self:addColumn(v)
    end

    return self
end

function PANEL:addLine(...)
    local args = {...}
    if !IsValid(self.frame) then
        self.frame = vgui.Create("SScrollPanel", self)
        self.frame:Dock(FILL)
        self.frame:SetTall(slib.getScaledSize(25, "y"))
    end

    self.lineiteration = self.lineiteration + 1

    local iteration = self.lineiteration

    for k,v in ipairs(args) do
        local display = istable(v) and v[1] or v
        local sortingvalue

        if istable(v) and v[2] then
            sortingvalue = v[2]
        end

        self.Columns[k]["lines"] = self.Columns[k]["lines"] or {}
        self.Columns[k]["lines"][iteration] = self.Columns[k]["lines"][iteration] or {}
        
        self.Columns[k]["lines"][iteration]["text"] = display
        
        if sortingvalue then
            self.Columns[k]["lines"][iteration]["sortvalue"] = sortingvalue
        end
    end

    self.Lines[iteration] = vgui.Create("DButton", self)
    self.Lines[iteration]:Dock(TOP)
    self.Lines[iteration]:SetTall(slib.getScaledSize(25, "y"))
    self.Lines[iteration]:SetText("")
    self.Lines[iteration].InitDoClick = self.Lines[iteration].DoClick

    self.Lines[iteration].Think = function()
        self.Lines[iteration]:SetMouseInputEnabled(self.Lines[iteration].DoClick ~= self.Lines[iteration].InitDoClick)
    end

    self.Lines[iteration].Paint = function(s,w,h)
        local wantedcolor = neutralcolor

        if !s:IsHovered() then
            wantedcolor = table.Copy(wantedcolor)
            wantedcolor.a = 0
        end
        
        surface.SetDrawColor(slib.lerpColor(s, wantedcolor))
        surface.DrawRect(0, 0, w, h)
        
        for i = 1,#self.Columns do
            local display = self.Columns[i]["lines"][iteration].text

            if isfunction(display) then
                display = display()
            end

            local x,y = self:getColumnPos(i), h * .5
            local w = self:getColumnWide(i)

            if w < (self:getTextWidth(display, self.Columns[i].maxTxtLen) + margin * 2) then self:resizeColumns() end
            if i == 1 then
                s.name = display
            end

            if self.Columns[i].ignoreWidth or self.Columns[i].maxTxtLen then
                surface.SetFont(font)
                local txt_h = select(2, surface.GetTextSize(display))
                local screen_x, screen_y = s:LocalToScreen(0,0)

                render.SetScissorRect(screen_x + x, screen_y, screen_x + x + self.Columns[i]:GetWide() - margin, screen_y + h, true)
                draw.SimpleText(display, font, x + slib.getTheme("margin"), y, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
                render.SetScissorRect(0, 0, 0, 0, false)
            else

                if self.Columns[i].customRender and self.Columns[i].customRender(x, 0, w, h, s) == true then return end

                draw.SimpleText(display, font, x + slib.getTheme("margin"), y, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            end
        end
    end

    self:resizeColumns()

    return self, self.Lines[iteration]
end

function PANEL:getTextWidth(txt, max)
    txt = tostring(txt)

    if max then
        txt = string.sub(txt, 1, max)
    end

    surface.SetFont(font)

    return surface.GetTextSize(txt)
end

function PANEL:resizeColumns()
    local columnsizes = {}
    local fullwidth = self:GetWide()
    local spaceleft = 0

    for k, v in pairs(self.Columns) do
        local ignoreWidth = self.Columns[k].ignoreWidth
        surface.SetFont(font)

        local longest = self:getTextWidth(self.Columns[k].name)
        if ignoreWidth then columnsizes[k] = isstring(ignoreWidth) and self:getTextWidth(ignoreWidth) or longest continue end
        if !self.Columns[k]["lines"] then continue end
        for i, z in pairs(self.Columns[k]["lines"]) do
            local compare = isfunction(z.text) and z.text() or z.text
            local width = self:getTextWidth(compare, self.Columns[k].maxTxtLen) + (slib.getTheme("margin") * 10)
            if longest < width then longest = width end
        end

        columnsizes[k] = longest
    end

    local occupiedspace = 0
    for k,v in pairs(columnsizes) do
        occupiedspace = occupiedspace + v
    end

    for k,v in pairs(self.Columns) do
        local v = columnsizes[k] or 0

        local gapadd = (fullwidth - occupiedspace) / #self.Columns
        self.Columns[k]:SetWide(v + gapadd)
    end
end

function PANEL:OnSizeChanged()
    self:resizeColumns()
end

function PANEL:PaintOver(w,h)
    for k,v in pairs(self.Columns) do
        if k >= #self.Columns then break end
        local x,y = self:getColumnPos(k), h * .5
        local w = self:getColumnWide(k)
        surface.SetDrawColor(linecol)
        surface.DrawRect(x + w - 1, 0, 1, h)
    end
end

vgui.Register("SListView", PANEL, "SScrollPanel")
--PATH addons/____sprinter/lua/s_printer/languages/sh_ukraine.lua:
if CLIENT then
    slib.setLang("sprinter", "ua", "main", "Головна")
    slib.setLang("sprinter", "ua", "logs", "Логи")
    slib.setLang("sprinter", "ua", "upgrades", "Поліпшення")
    slib.setLang("sprinter", "ua", "settings", "Налаштування")
    slib.setLang("sprinter", "ua", "overclocking", "Прискорення")
    slib.setLang("sprinter", "ua", "noisereduction", "Приглушення шуму")
    slib.setLang("sprinter", "ua", "dmgresistance", "Стійкість до пошкоджень")
    slib.setLang("sprinter", "ua", "notifications", "Сповіщення")

    slib.setLang("sprinter", "ua", "notify-withdraw", "Повідомляти про виведення")
    slib.setLang("sprinter", "ua", "notify-on-damage", "Повідомляти про пошкодженя")
    slib.setLang("sprinter", "ua", "notify-low-hp", "Повідомляти про низький рівень HP")
    slib.setLang("sprinter", "ua", "notify-low-battery", "Повідомляти про низький заряд батареї")

    slib.setLang("sprinter", "ua", "withdrawn-money", "Виведені гроші")
    slib.setLang("sprinter", "ua", "received-damage", "Отримана шкода")
    slib.setLang("sprinter", "ua", "upgraded-printer", "Покращені принтери")
    slib.setLang("sprinter", "ua", "turned-on", "Увімкнені")
    slib.setLang("sprinter", "ua", "turned-off", "Вимкнені")

    slib.setLang("sprinter", "ua", "are-you-sure", "Ви впевнені?")
    slib.setLang("sprinter", "ua", "this-will-cost", "Це буде коштувати %s")

    slib.setLang("sprinter", "ua", "nothing-to-show", "Тут нема чого показувати")

    slib.setLang("sprinter", "ua", "condition", "Стан")
    slib.setLang("sprinter", "ua", "temperature", "Температура")
    slib.setLang("sprinter", "ua", "clockspeed", "Тактовая частота")
    slib.setLang("sprinter", "ua", "income", "Дохід(хв)")
    slib.setLang("sprinter", "ua", "eject", "Витягти")
    slib.setLang("sprinter", "ua", "withdraw", "Зняти")
    slib.setLang("sprinter", "ua", "repair", "Відновити")
    slib.setLang("sprinter", "ua", "recharge", "Перезарядити")

    slib.setLang("sprinter", "ua", "empty", "Пусто")

    slib.setLang("sprinter", "ua", "swep-name", "Сумка для принтера")
    slib.setLang("sprinter", "ua", "swep-instuactions", "Первинний вогонь, щоб прибрати принтер у кобуру, вторинний вогонь, щоб викинути принтер!")
else
    slib.setLang("sprinter", "ua", "upgraded", "Ви покращили принтер за %s")
    slib.setLang("sprinter", "ua", "recharged", "Ви зарядили принтер за %s")
    slib.setLang("sprinter", "ua", "repaired", "Ви відремонтували принтер за %s")
    slib.setLang("sprinter", "ua", "repaired-rack", "Ви відремонтували стійку за %s")
    slib.setLang("sprinter", "ua", "withdrawn", "Ви зняли %s")
    slib.setLang("sprinter", "ua", "recharged-all", "Ви зарядили кожен принтер у стійці за %s")
    slib.setLang("sprinter", "ua", "recharged-this-many", "Ви зарядили %s принтер(ів) у стійці за %s")
    slib.setLang("sprinter", "ua", "repaired-all", "Ви відремонтували кожен принтер у стійці за %s")
    slib.setLang("sprinter", "ua", "repaired-this-many", "Ви відремонтували %s принтер(ів) у стійці за %s")
    slib.setLang("sprinter", "ua", "no-eject-space", "Немає місця для вилучення принтера")
    slib.setLang("sprinter", "ua", "printer-was-damaged", "Ваш принтер %s отримав пошкодження!")
    slib.setLang("sprinter", "ua", "printer-low-hp", "У вашого принтера %s низький рівень HP!")
    slib.setLang("sprinter", "ua", "someone-has-withdrawn", "Хтось зняв гроші з вашого %s принтера!")
    slib.setLang("sprinter", "ua", "battery-low", "У вашого принтера %s низький заряд батареї, вам слід зарядити його!")
    slib.setLang("sprinter", "ua", "rewarded-on-destroy", "Ви отримали %s в нагороду за знищення принтера!")

    slib.setLang("sprinter", "ua", "full-printer-bag", "Сумка для принтера повна!")
end

slib.setLang("sprinter", "ua", "rack", "Стійка для принтера")
slib.setLang("sprinter", "ua", "insufficient-permissions", "У вас недостатньо прав для цього!")
--PATH addons/____sprinter/lua/s_printer/screens/cl_topscreen.lua:
local margin, accent_col, successcolor, failcolor, main_col, shade_10, shade_20, shade_min10, text_col, text_colmin40, white, orange, transparent = 8, slib.getTheme("accentcolor"), slib.getTheme("successcolor"), slib.getTheme("failcolor"), slib.getTheme("maincolor"), slib.getTheme("maincolor", 10), slib.getTheme("maincolor", 20), slib.getTheme("maincolor", -10), slib.getTheme("textcolor"), slib.getTheme("textcolor", -40), Color(255,255,255), Color(189, 75, 0), Color(0,0,0,0)

local pages = {}

local function setActivePage(parent, page)
    for pnl, name in pairs(pages[parent]) do
        if !IsValid(pnl) then pages[parent][pnl] = nil continue end
        pnl:SetVisible(page == name)
    end

    parent.page = page
end

local function createPage(ent, parent, name, topbar, disabled)
    local page = vgui.Create("EditablePanel", parent)
    page:Dock(FILL)
    page:DockPadding(margin,margin,margin,margin)

    pages[ent] = pages[ent] or {}
    pages[ent][page] = name

    return page
end

local back_ico, logs_ico, upgrades_ico, settings_ico = Material("sprinter/back.png", "smooth"), Material("sprinter/log.png", "smooth"), Material("sprinter/upgrade.png", "smooth"), Material("sprinter/settings.png", "smooth")

local function getScrollpage(parent, func)
    local w, h = 630, 271
    local scroller = vgui.Create("SScrollPanel", parent)
    scroller:SetSize(w, h)
    scroller:GetCanvas():DockPadding(margin,margin,margin,margin)

    func(scroller)

    local scroller_scrollbar = scroller:GetVBar()

    local upButtn = vgui.Create("SButton", scroller_scrollbar)
    upButtn:SetSize(scroller_scrollbar:GetWide(), h * .5)
    upButtn.Paint = function(s)
        if input.IsKeyDown(KEY_E) and s.Hovered and (!s.lastClick or (CurTime() - s.lastClick > .2)) then
            s.lastClick = CurTime()
            s.DoClick()
        end
    end

    upButtn.DoClick = function(num)
        local curScroll = scroller_scrollbar:GetScroll()
        scroller_scrollbar:SetScroll(curScroll - (40 + margin))
    end

    local downButtn = vgui.Create("SButton", scroller_scrollbar)
    downButtn:SetSize(scroller_scrollbar:GetWide(), h * .5)
    downButtn:SetPos(0, h * .5)
    downButtn.Paint = function(s)
        if input.IsKeyDown(KEY_E) and s.Hovered and (!s.lastClick or (CurTime() - s.lastClick > .2)) then
            s.lastClick = CurTime()
            s.DoClick()
        end
    end

    downButtn.DoClick = function(num)
        local curScroll = scroller_scrollbar:GetScroll()
        scroller_scrollbar:SetScroll(curScroll + (40 + margin))
    end

    return scroller
end

sPrinter.drawTopScreen = function(ent, opacity)
    if IsValid(ent:GetRack()) and sPrinter.config["disable_topscreen_in_rack"] then if IsValid(ent.topScreen) then ent.topScreen:Remove() end return end
    
    if !IsValid(ent.topScreen) then
        ent.topScreen = vgui.Create("EditablePanel")
        ent.topScreen:SetSize(630, 356)
        ent.topScreen:DockPadding(0, 45, 0, 0)
        ent.topScreen:SetPaintedManually(true)

        ent.topScreen.Paint = function(s,w,h)
            if s:IsMouseInputEnabled() == sPrinter.isMouseEnabled then s:SetMouseInputEnabled(!sPrinter.isMouseEnabled) end
            
            surface.SetDrawColor(main_col)
            surface.DrawRect(0,0,w,h)
        end

        ent.topScreen.PaintOver = function(s,w,h)
            if ent:GetLocked() then
                sPrinter.DrawLocked(w,h)
            end

            sPrinter.DrawCursor(w, h, ent, 5)
        end

        local hookName = "sP:DisableScreen_"..ent:EntIndex()
        hook.Add("sP:MouseEnabled", hookName, function(enabled)
            if !IsValid(ent) or !IsValid(ent.topScreen) then hook.Remove("sP:MouseEnabled", hookName) return end

            ent.topScreen:SetMouseInputEnabled(!enabled)
        end)

        sPrinter.addTopbar(ent.topScreen, ent)

        local topbar = vgui.Create("EditablePanel", ent.topScreen)
        topbar:SetPos(0, 45)
        topbar:SetSize(ent.topScreen:GetWide(), 40)
        topbar.Paint = function(s,w,h)
            surface.SetDrawColor(shade_10)
            surface.DrawRect(0,0,w,h)

            surface.SetDrawColor(shade_20)
            surface.DrawRect(0,h - 1,w,1)

            draw.SimpleText(ent.page or "", slib.createFont("NasalizationRg-Regular", 32, nil, true), w * .5, h * .5, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end

        local back = vgui.Create("SButton", topbar)
        back:SetPos(5,0)
        back:SetSize(40,40)
        back.Paint = function(s,w,h)
            if s.Hovered and !sPrinter.ShouldDraw(ent) then s.Hovered = false end
            surface.SetDrawColor(slib.lerpColor(s, ent.page == slib.getLang("sprinter", sPrinter.config["language"], "main") and transparent or (s.Hovered and accent_col or white)))
            surface.SetMaterial(back_ico)
            local iconsize = h * .8
            surface.DrawTexturedRect(w * .5 - iconsize * .5, h * .5 - iconsize * .5, iconsize, iconsize)
        end

        back.DoClick = function()
            if ent.page == slib.getLang("sprinter", sPrinter.config["language"], "main") then return end
            surface.PlaySound("buttons/button15.wav")
            setActivePage(ent, slib.getLang("sprinter", sPrinter.config["language"], "main"))
        end

        local canvas = vgui.Create("EditablePanel", ent.topScreen)
        canvas:SetSize(ent.topScreen:GetWide(), ent.topScreen:GetTall() - 85)
        canvas:SetPos(0,85)

        local mainpage = createPage(ent, canvas, slib.getLang("sprinter", sPrinter.config["language"], "main"), true, true)
        mainpage:DockPadding(0,0,0,0)

        local logs_bttn = sPrinter.addButton(mainpage, ent, slib.getLang("sprinter", sPrinter.config["language"], "logs"), function()
            setActivePage(ent, slib.getLang("sprinter", sPrinter.config["language"], "logs"))
            
            if !ent.addedLogs then
                ent.addedLogs = true
                net.Start("sP:Networking")
                net.WriteEntity(ent)
                net.WriteUInt(4,3)
                net.WriteUInt(2,2)
                net.SendToServer()
            end
        end, logs_ico, LEFT)
        logs_bttn.usewidth = true
        logs_bttn.fontsize = 32
        logs_bttn:DockMargin(margin,margin,0,margin)
        logs_bttn:SetWide((ent.topScreen:GetWide() - (margin * 4)) / 3)

        local upgrades_bttn = sPrinter.addButton(mainpage, ent, slib.getLang("sprinter", sPrinter.config["language"], "upgrades"), function() setActivePage(ent, slib.getLang("sprinter", sPrinter.config["language"], "upgrades")) end, upgrades_ico, LEFT)
        upgrades_bttn.usewidth = true
        upgrades_bttn.fontsize = 32
        upgrades_bttn:DockMargin(margin,margin,0,margin)
        upgrades_bttn:SetWide((ent.topScreen:GetWide() - (margin * 4)) / 3)

        local settings_bttn = sPrinter.addButton(mainpage, ent, slib.getLang("sprinter", sPrinter.config["language"], "settings"), function()
            setActivePage(ent, slib.getLang("sprinter", sPrinter.config["language"], "settings"))

            if !ent.addedSettings then
                ent.addedSettings = true
                net.Start("sP:Networking")
                net.WriteEntity(ent)
                net.WriteUInt(4,3)
                net.WriteUInt(1,2)
                net.SendToServer()
            end
        end, settings_ico, LEFT)
        settings_bttn.usewidth = true
        settings_bttn.fontsize = 32
        settings_bttn:DockMargin(margin,margin,0,margin)
        settings_bttn:SetWide((ent.topScreen:GetWide() - (margin * 4)) / 3)

        local logspage = createPage(ent, canvas, slib.getLang("sprinter", sPrinter.config["language"], "logs"), true)
        logspage:DockPadding(0,0,0,0)

        local logs_scroller = getScrollpage(logspage, function(scroller) sPrinter.addLogEntries(ent, scroller) end)


        local upgradespage = createPage(ent, canvas, slib.getLang("sprinter", sPrinter.config["language"], "upgrades"), true)
        upgradespage:DockPadding(0,0,0,0)
        
        local upgrades_scroller = getScrollpage(upgradespage, function(scroller) sPrinter.addUpgrades(ent, scroller) end)

        local settingspage = createPage(ent, canvas, slib.getLang("sprinter", sPrinter.config["language"], "settings"), true)
            
        sPrinter.addSettings(ent, settingspage)

        setActivePage(ent, slib.getLang("sprinter", sPrinter.config["language"], "main"))
        topbar:MoveToFront()
        
        return
    else
        ent.topScreen:SetAlpha(opacity)
    end

    local pos = ent:LocalToWorld(Vector(-22.85, 11.1, 4.6))
    local ang = ent:LocalToWorldAngles(Angle(0,0,0))

    vgui.Start3D2DS( pos, ang, .03 )
        ent.topScreen:SPaint3D2D(ent)
    vgui.End3D2DS()
end
--PATH addons/____plogs/lua/ui/controls/checkbox.lua:

-----------------------------------------------------
local PANEL = {}

function PANEL:SetText(txt)
	self.Label = self.Label or ui.Create('DLabel', function(self)
		self:SetFont('ui.18')
	end, self)
	
	self.Label:SetText(txt)
end

function PANEL:PerformLayout() end

function PANEL:SetConVar(var)
	self.Button.DoClick = function()
		self.Button:Toggle()
		cvar.SetValue(var, not cvar.GetValue(var))
	end
	self.Label:SetMouseInputEnabled(true)
	self.Label.OnMousePressed = self.Button.DoClick
	self:SetValue(cvar.GetValue(var) and 1 or 0)
	self:SetTextColor(rp.col.ButtonText)
end

function PANEL:SizeToContents()
	self.Button:SetSize(16, 16)
	local w, h = 16, 16
	
	if (self.Label) then
		self.Label:SizeToContents()
		w = w + 5 + self.Label:GetWide()
		h = math.max(h, self.Label:GetTall())
		
		self.Label:SetPos(21, (h - self.Label:GetTall()) * 0.5 - 1)
	end
	
	self:SetSize(w, h)
end

vgui.Register('ui_checkbox', PANEL, 'DCheckBoxLabel')
--PATH addons/____plogs/lua/ui/controls/frame.lua:

-----------------------------------------------------
local PANEL = {}

AccessorFunc( PANEL, 'm_bIsMenuComponent', 		'IsMenu', 			FORCE_BOOL )
AccessorFunc( PANEL, 'm_bDraggable', 			'Draggable', 		FORCE_BOOL )
AccessorFunc( PANEL, 'm_bSizable', 				'Sizable', 			FORCE_BOOL )
AccessorFunc( PANEL, 'm_bScreenLock', 			'ScreenLock', 		FORCE_BOOL )
AccessorFunc( PANEL, 'm_bDeleteOnClose', 		'DeleteOnClose', 	FORCE_BOOL )
AccessorFunc( PANEL, 'm_bPaintShadow', 			'PaintShadow', 		FORCE_BOOL )

AccessorFunc( PANEL, 'm_iMinWidth', 			'MinWidth' )
AccessorFunc( PANEL, 'm_iMinHeight', 			'MinHeight' )

--AccessorFunc( PANEL, 'm_bBackgroundBlur', 		'BackgroundBlur', 	FORCE_BOOL )

function PANEL:Init()
	self:SetFocusTopLevel( true )

	self.btnClose = ui.Create( 'DButton', self )
	self.btnClose:SetText( '' )
	self.btnClose.DoClick = function ( button ) surface.PlaySound('beep-21.mp3') self:Close() end
	self.btnClose.Paint = function( panel, w, h ) derma.SkinHook( 'Paint', 'WindowCloseButton', panel, w, h ) end

	self.lblTitle = ui.Create( 'DLabel', self )
	self.lblTitle:SetColor(ui.col.White)
	self.lblTitle:SetFont('ui.22')

	self:SetDraggable( true )
	self:SetSizable( false )
	self:SetScreenLock( false )
	self:SetDeleteOnClose( true )
	self:SetTitle( 'Window' )
	self:SetSkin('SUP')

	self:SetMinWidth( 50 )
	self:SetMinHeight( 50 )

	-- This turns off the engine drawing
	self:SetPaintBackgroundEnabled( false )
	self:SetPaintBorderEnabled( false )

	self.m_fCreateTime = SysTime()

	self:DockPadding( 5, 24 + 5, 5, 5 )

	self:SetAlpha(0)
	self:FadeIn(0.2)

	hook.Add('Think', self, function()
		if self.HandleMovement then
			self:HandleMovement()
		end
		if (self.animation) then
			self.animation:Run()
		end
	end)
end

function PANEL:Focus()
	local panels = {}
	--self:SetBackgroundBlur(true)
	for k, v in ipairs(vgui.GetWorldPanel():GetChildren()) do
		if v:IsVisible() and (v ~= self) then
			panels[#panels + 1] = v
			v:SetVisible(false)
		end
	end
	self._OnClose = self.OnClose
	self.OnClose = function(self)
		for k, v in ipairs(panels) do
			if IsValid(v) then
				v:SetVisible(true)
			end
		end
		self:_OnClose()
	end
end

function PANEL:ShowCloseButton( bShow )
	self.btnClose:SetVisible( bShow )
end

function PANEL:SetTitle( strTitle )
	self.lblTitle:SetText( strTitle )
end

function PANEL:GetTitleHeight()
	return 33 -- 28 + 5px padding
end

function PANEL:GetDockPos()
	return 5, self:GetTitleHeight()
end

function PANEL:Center()
	self:InvalidateLayout( true )
	self:SetPos( ScrW()*0.5 - self:GetWide()*0.5, ScrH()*0.5 - self:GetTall()*0.5 )
end 

function PANEL:Close(cback)
	if (self:GetDeleteOnClose()) then
		self.Think = function() end -- You'll break shit if you continue to run
	end

	self:FadeOut(0.2, function()
		if (self:GetDeleteOnClose()) then
			self:Remove()
		else
			self:SetVisible(false)
		end

		if cback then cback() end
	end)

	self:OnClose()
end

function PANEL:OnClose()

end

function PANEL:Think()

end

function PANEL:IsActive()
	if ( self:HasFocus() ) then return true end
	if ( vgui.FocusedHasParent( self ) ) then return true end

	return false
end

function PANEL:HandleMovement()
	local mousex = math.Clamp( gui.MouseX(), 1, ScrW()-1 )
	local mousey = math.Clamp( gui.MouseY(), 1, ScrH()-1 )

	if ( self.Dragging ) then

		local x = mousex - self.Dragging[1]
		local y = mousey - self.Dragging[2]

		-- Lock to screen bounds if screenlock is enabled
		if ( self:GetScreenLock() ) then

			x = math.Clamp( x, 0, ScrW() - self:GetWide() )
			y = math.Clamp( y, 0, ScrH() - self:GetTall() )

		end

		self:SetPos( x, y )

	end

	if ( self.Sizing ) then
		local x = mousex - self.Sizing[1]
		local y = mousey - self.Sizing[2]
		local px, py = self:GetPos()

		if ( x < self.m_iMinWidth ) then x = self.m_iMinWidth elseif ( x > ScrW() - px and self:GetScreenLock() ) then x = ScrW() - px end
		if ( y < self.m_iMinHeight ) then y = self.m_iMinHeight elseif ( y > ScrH() - py and self:GetScreenLock() ) then y = ScrH() - py end

		self:SetSize( x, y )
		self:SetCursor( 'sizenwse' )
		return
	end

	if ( self.Hovered && self.m_bSizable &&
		 mousex > ( self.x + self:GetWide() - 20 ) &&
		 mousey > ( self.y + self:GetTall() - 20 ) ) then

		self:SetCursor( 'sizenwse' )
		return
	end

	if ( self.Hovered && self:GetDraggable() && mousey < ( self.y + 24 ) ) then
		self:SetCursor( 'sizeall' )
		return
	end

	self:SetCursor( 'arrow' )

	-- Don't allow the frame to go higher than 0
	if ( self.y < 0 ) then
		self:SetPos( self.x, 0 )
	end
end

function PANEL:Paint( w, h )
	--if ( self.m_bBackgroundBlur ) then
	--	Derma_DrawBackgroundBlur( self, self.m_fCreateTime )
	--end

	derma.SkinHook( 'Paint', 'Frame', self, w, h )
	return true
end

function PANEL:OnMousePressed()
	if ( self.m_bSizable ) then
		if ( gui.MouseX() > ( self.x + self:GetWide() - 20 ) &&
			gui.MouseY() > ( self.y + self:GetTall() - 20 ) ) then

			self.Sizing = { gui.MouseX() - self:GetWide(), gui.MouseY() - self:GetTall() }
			self:MouseCapture( true )
			return
		end
	end

	if ( self:GetDraggable() && gui.MouseY() < (self.y + 24) ) then
		self.Dragging = { gui.MouseX() - self.x, gui.MouseY() - self.y }
		self:MouseCapture( true )
		return
	end
end

function PANEL:OnMouseReleased()
	self.Dragging = nil
	self.Sizing = nil
	self:MouseCapture( false )
end

function PANEL:FadeIn(speed, cback)
	self.animation = Derma_Anim('Fade Panel', self, function(panel, animation, delta, data)
		panel:SetAlpha(delta * 255)
		if (animation.Finished) then
			self.animation = nil
			if cback then cback() end
		end
	end)

	if (self.animation) then
		self.animation:Start(speed)
	end
end

function PANEL:FadeOut(speed, cback)
	self.animation = Derma_Anim('Fade Panel', self, function(panel, animation, delta, data)
		panel:SetAlpha(255 - (delta * 255))
		if (animation.Finished) then
			self.animation = nil
			if cback then cback() end
		end
	end)

	if (self.animation) then
		self.animation:Start(speed)
	end
end

function PANEL:PerformLayout()
	self.lblTitle:SizeToContents()
	self.lblTitle:SetPos(5, 3)

	self.btnClose:SetPos(self:GetWide() - 50, 0)
	self.btnClose:SetSize(50, 28)
end

derma.DefineControl('ui_frame', 'A simple window', PANEL, 'EditablePanel')


PANEL = vgui.GetControlTable('ui_frame')

local SetSize = PANEL.SetSize
PANEL.SetSize = function(self, w, h)
	if (w <= 1) then
		w = w * ScrW()
	end
	if (h <= 1) then
		h = h * ScrH()
	end
	SetSize(self, w, h)
end

local SetWide = PANEL.SetWide
PANEL.SetWide = function(self, w)
	if (w <= 1) then
		w = w * ScrH()
	end
	SetWide(self, w)
end

local SetTall = PANEL.SetTall
PANEL.SetTall = function(self, h)
	if (h <= 1) then
		h = h * ScrH()
	end
	SetTall(self, h)
end
--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/permissions.lua:
local Permissions
do
  local _class_0
  local _base_0 = {
    __name = "Permissions",
    canAccessFramework = function(self, ply)
      local dev = self:isXeninDeveloper(ply)
      if (dev and tonumber(GetConVar("xenin_easy_permissions")) == 1) then
        return true
      end

      return self:isSuperAdmin(ply)
    end,
    isAdmin = function(self, ply, level)
      if level == nil then level = 1
      end
      return ply:IsAdmin()
    end,
    isSuperAdmin = function(self, ply)
      return ply:IsSuperAdmin()
    end,
    isXeninDeveloper = function(self, ply)
      return self.xeninDevelopers[ply:SteamID64()]
    end,
    __type = function(self)
      return "XeninUI.Permissions"end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.xeninDevelopers = {
        ["76561198202328247"] = "sleeppyy",
        ["76561198058042338"] = "Hoofy"
      }
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Permissions = _class_0
end

XeninUI.Permissions = Permissions()

CreateConVar("xenin_easy_permissions", 1)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/wyvern.lua:
XeninUI.openTime = 0.15
XeninUI.closeTime = 0.15

function XeninUI:GetColorLightness(color)
    local uiColors = {
        color.r / 255,
        color.g / 255,
        color.b / 255
    }
    for i, c in ipairs(uiColors) do
        if c <= 0.03928 then
            uiColors[i] = c / 12.92
        else
            uiColors[i] = math.pow((c + 0.055) / 1.055, 2.4)
        end
    end
    return 0.2126 * uiColors[1] + 0.6152 * uiColors[2] + 0.0622 * uiColors[3]
end

function XeninUI:GetContrastColor(bgColor, colLight, colDark, darkRequirement)
    colLight = colLight or Color(255, 255, 255)
    colDark = colDark or Color(0, 0, 0)
    darkRequirement = darkRequirement or 0.21

    if XeninUI:GetColorLightness(bgColor) > darkRequirement then
        return colDark
    end

    return colLight
end

function XeninUI:GetCommonRippleColor()
    return XeninUI:GetContrastColor(XeninUI.Theme.Accent, ColorAlpha(XeninUI.Theme.Accent, 20), ColorAlpha(XeninUI.Theme.Accent, 100))
end

function XeninUI:ManipulateColor(col, deltaH, deltaS, deltaV)
    local h, s, v = ColorToHSV(col)

    return HSVToColor(math.Clamp(h + deltaH, 0, 360), math.Clamp(s + deltaS, 0, 1), math.Clamp(v + deltaV, 0, 1))
end

local surface_SetDrawColor = surface.SetDrawColor
local rad = math.rad
local sin = math.sin
local cos = math.cos

function XeninUI:CalculateCircle(sx, sy, radius, vertexCount, angle)
    local vertices = {}
    local ang = -rad(angle or 0)
    local c = cos(ang)
    local s = sin(ang)
    for i = 0, 360, 360 / vertexCount do
        local radd = rad(i)
        local x = cos(radd)
        local y = sin(radd)

        local tempx = x * radius * c - y * radius * s + sx
        y = x * radius * s + y * radius * c + sy
        x = tempx

        vertices[#vertices + 1] = {
            x = x,
            y = y,
            u = u,
            v = v
        }
    end

    return vertices
end

function XeninUI:DrawCachedCircle(vertices, color)
    if vertices and #vertices > 0 then
        draw.NoTexture()
        surface_SetDrawColor(color)
        surface.DrawPoly(vertices)
    end
end

function XeninUI:DrawCircle(sx, sy, radius, vertexCount, color)
    local vertices = {}
    local ang = -rad(0)
    local c = cos(ang)
    local s = sin(ang)
    for i = 0, 360, 360 / vertexCount do
        local radd = rad(i)
        local x = cos(radd)
        local y = sin(radd)

        local tempx = x * radius * c - y * radius * s + sx
        y = x * radius * s + y * radius * c + sy
        x = tempx

        vertices[#vertices + 1] = {
            x = x,
            y = y,
            u = u,
            v = v
        }
    end

    if vertices and #vertices > 0 then
        draw.NoTexture()
        surface_SetDrawColor(color)
        surface.DrawPoly(vertices)
    end
end

local matCorner8 = Material("materials/wyvernf4/corner_8.png")
local matCorner16 = Material("materials/wyvernf4/corner_16.png")





function XeninUI:Ease2(t, b, c, d)
    t = t / d
    local ts = t * t
    local tc = ts * t
    return b + c * (9.3475 * tc * ts + -22.6425 * ts * ts + 15.495 * tc + -1.3 * ts + 0.1 * t)
end

function XeninUI:AddRippleFunctions(pnl)
    pnl.ripples = {}

    function pnl:PaintRipples(w, h)
        draw.NoTexture()
        for i, ripple in ipairs(self.ripples) do
            local t = ripple.endTime - CurTime()
            local f = math.Clamp(1 - (t / ripple.duration), 0, 1)
            local f2 = XeninUI:Ease2(f, 0, 1, 1)

            local r = self:GetFurthestDistanceFrom(ripple.x, ripple.y) + 5
            XeninUI:DrawCircle(ripple.x, ripple.y, r * f2, ripple.vertexCount, ColorAlpha(ripple.color, math.Clamp(ripple.alpha * ripple.color.a, 0, 100)))

            if f >= 1 then
                local doFade = true
                if input.IsMouseDown(MOUSE_LEFT) and i == #self.ripples and pnl:IsHovered() then
                    doFade = false
                end

                if doFade then
                    ripple.alpha = ripple.alpha + (0 - ripple.alpha) * 10 * FrameTime()

                    if not ripple.isFading then
                        if ripple.callback then ripple.callback(false)end

                        ripple.isFading = true
                    end
                end
            end
        end

        for i = #self.ripples, 1, -1 do
            local ripple = self.ripples[i]
            if ripple.alpha < 0.01 then
                if ripple.callback then
                    ripple.callback(true)
                end

                table.remove(self.ripples, i)
            end
        end
    end

    local oldPaint = pnl.Paint
    function pnl:Paint(w, h)
        if oldPaint then oldPaint(self, w, h)end

        XeninUI:Mask(function()
            XeninUI:DrawRoundedBox(8, 0, 0, w, h, color_white)
        end, function()
            self:PaintRipples(w, h)
        end)
    end

    function pnl:AddRipple(x, y, options)
        local duration = options.duration or 0.5

        self.ripples[#self.ripples + 1] = {
            x = x,
            y = y,
            endTime = CurTime() + duration,
            alpha = 1,
            duration = duration,
            color = options.color or Color(255, 255, 255, 2),
            vertexCount = options.vertexCount or 30,
            callback = options.callback
        }
    end

    function pnl:GetFurthestDistanceFrom(x, y)
        local w, h = self:GetSize()
        local dx, dy

        if x < w * 0.5 then
            if y < h * 0.5 then
                dx = w - x
                dy = h - y
            else
                dx = w - x
                dy = 0 - y
            end
        else
            if y < h * 0.5 then
                dx = 0 - x
                dy = h - y
            else
                dx = 0 - x
                dy = 0 - y
            end
        end

        return math.sqrt(dx * dx + dy * dy)
    end
end

function XeninUI:AddRippleClickEffect(pnl, color, duration)
    self:AddRippleFunctions(pnl)

    pnl.rippleColor = color
    pnl.rippleDuration = duration

    function pnl:OnMousePressedRipple(code)
        if self.GetDisabled and self:GetDisabled() then return end

        if code == MOUSE_LEFT then
            local cx, cy = self:CursorPos()
            self:AddRipple(cx, cy, {
                color = pnl.rippleColor,
                duration = pnl.rippleDuration
            })
        end
    end

    local oldMousePressed = pnl.OnMousePressed
    function pnl:OnMousePressed(code)
        pnl:OnMousePressedRipple(code)

        if oldMousePressed then
            return oldMousePressed(self, code)
        end
    end
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/scripts/network/client.lua:
local ScriptsNetwork
do
  local _class_0
  local _parent_0 = XeninUI.Network
  local _base_0 = {
    __name = "ScriptsNetwork",
    __base = XeninUI.Network.__base,
    receiveScripts = function(self, ply)
      local scripts = self:decompress()
      XeninUI.Scripts:setAll(scripts)

      hook.Run("Xenin.Framework.ReceivedScripts", scripts)
    end,
    receiveUpdateScripts = function(self, ply)
      local tbl = self:decompress()
      for i, v in ipairs(tbl) do
        chat.AddText(unpack(v))
      end
    end,
    requestScripts = function(self)
      if self.SentScriptsRequest then
        hook.Run("Xenin.Framework.ReceivedScripts", XeninUI.Scripts:getAll())

        return
      end

      self.SentScriptsRequest = true

      self:sendRequestScripts()
    end,
    sendRequestScripts = function(self)
      self:send("Xenin.Framework.Scripts", function(self) end)
    end,
    __type = function(self)
      return "XeninUI.ScriptsNetwork"end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__index)
  _class_0 = setmetatable({
    __init = function(self)
      ScriptsNetwork.__parent.__init(self)

      self:receiver("Xenin.Framework.Scripts", self.receiveScripts)
      self:receiver("Xenin.Framework.UpdateScriptsMessage", self.receiveUpdateScripts)
    end,
    __base = _base_0,
    __parent = _parent_0
  }, {
    __index = function(cls, parent)
      local val = rawget(_base_0, parent)
      if val == nil then local _parent = rawget(cls, "__parent")
        if _parent then return _parent[parent]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0)
  end
  ScriptsNetwork = _class_0
end

XeninUI.ScriptsNetwork = ScriptsNetwork()

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs.lua:
XeninUI:CreateFont("Xenin.Configurator.Inputs.Label", 14)
XeninUI:CreateFont("Xenin.Configurator.KeyValue", 18)

XeninUI.Configurator.InputPanels = {
  ["Blank"] = {
  panel = function(self, tbl)
    return vgui.Create("Panel")
  end
  },
  ["Textentry"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("XeninUI.TextEntry")
    panel:DockMargin(0, 6, -4, 6)
    panel:SetBackgroundColor(XeninUI.Theme.Background)
    panel.SetInput = function(pnl, input)
      pnl:SetText(input)
      pnl.textentry:OnValueChange(input)
    end
    panel:SetPlaceholder(tbl.placeholder or "")
    panel.GetSettingValue = function(pnl)
      return pnl:GetText()
    end
    panel.textentry:SetNumeric(tbl.number or ((tbl and tbl.data) and tbl.data.number))
    panel.textentry.min = tbl.min
    panel.textentry.max = tbl.max
    panel.textentry:SetUpdateOnType(true)
    panel.textentry.OnValueChange = function(pnl, text)
      local currentCaret
      if (pnl:GetNumeric() and (pnl.min or pnl.max)) then
        local num = tonumber(text)
        if num then
          if (pnl.min and pnl.min > num) then
            currentCaret = pnl:GetCaretPos()
            pnl:SetText(pnl.min)
          elseif (pnl.max and pnl.max < num) then
            currentCaret = pnl:GetCaretPos()
            pnl:SetText(pnl.max)
          end
        end
      end

      if (text == "") then
        text = panel:GetPlaceholder()
      end
      surface.SetFont(pnl:GetFont())
      local tw = surface.GetTextSize(text)
      tw = tw + 24
      local width = math.Clamp(tw, 28, 600)
      panel:SetWide(width)

      if currentCaret then
        pnl:SetCaretPos(currentCaret)
      end
      if panel.onChange then
        panel:onChange(pnl:GetText())
      end
    end

    return panel
  end
  },
  ["TextentryWithLabel"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("Panel")
    panel:DockMargin(0, 6, -8, 6)
    panel.GetSettingValue = function(pnl)
      return pnl.textentry:GetText()
    end

    local label = panel:Add("DLabel")
    label:Dock(LEFT)
    label:DockMargin(12, 2, 0, 0)
    label:SetTextColor(tbl.labelColor or Color(127, 127, 127))
    label:SetFont("Xenin.Configurator.Inputs.Label")
    label:SetText(((tbl and tbl.data) and tbl.data.label) or tbl.label or "Label")

    local textentry = XeninUI.Configurator:CreateInputPanel("Textentry", self, tbl)
    textentry:SetParent(panel)
    textentry:Dock(FILL)
    textentry:DockMargin(0, 0, 0, 0)
    textentry:SetPlaceholder(tbl.placeholder or "")
    textentry.DoSizing = function(pnl, text)
      if (text == "") then
        text = pnl:GetPlaceholder()
      end
      surface.SetFont(pnl.textentry:GetFont())
      local tw = surface.GetTextSize(text)
      tw = tw + 24
      local width = math.Clamp(tw, 28, 600)

      label:SizeToContents()
      panel:SetWide(width + label:GetWide() + 16)
    end
    textentry.onChange = function(pnl, text)
      if panel.onChange then
        panel:onChange(text)
      end

      pnl:DoSizing(text)
    end

    panel.label = label
    panel.textentry = textentry

    if tbl.value then
      textentry:SetText(tbl.value)
    end
    textentry:DoSizing(textentry:GetText())

    return panel
  end
  },
  ["Selectbox"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("DButton")
    panel:SetText("")
    panel:DockMargin(0, 6, 6, 6)
    panel.Choices = {}
    panel.AddChoice = function(pnl, name, data)
      if data == nil then data = true
      end
      pnl.Choices[#pnl.Choices + 1] = {
        name = name,
        data = data
      }
    end
    panel.GetSettingValue = function(pnl)
      return pnl.Text
    end
    panel.TextColor = Color(182, 182, 182)
    XeninUI:DownloadIcon(panel, "2QGKAd6")
    panel.SetInput = function(pnl, text)
      pnl:SetChoice(text)
    end
    panel.SetChoice = function(pnl, text)
      local startText = pnl.Text
      pnl.Text = text
      local data = istable(pnl.Choices[text])
      if (data and (pnl.Choices[text] and pnl.Choices[text].__color)) then
        pnl.TextColor = pnl.Choices[text].__color
      end
      pnl:SizeToContents()

      if (startText and startText != "" and pnl.onChange) then
        pnl:onChange(text)
      end
    end
    panel.SetChoices = function(pnl, tbl)
      for i, v in pairs(tbl) do
        pnl:AddChoice(v.name, v.data)
      end
    end
    panel.SetData = function(pnl, data)
      if data.fetch then
        pnl:SetChoices(data:fetch())
      end
      if data.fetchAsync then
        data:fetchAsync():next(function(result)
          pnl:SetChoices(result)
        end, ErrorNoHalt)
      end
    end
    panel.Font = "Xenin.Configurator.Admin.Panel.Selectbox"
    panel.Outline = ((tbl and tbl.outline) and tbl.outline.standard) or XeninUI.Theme.Navbar
    panel.Rotation = 0
    panel.Paint = function(pnl, w, h)
      XeninUI:MaskInverse(function()
        XeninUI:DrawRoundedBox(6, 1, 1, w - 2, h - 2, color_white)
      end, function()
        XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Outline)
      end)

      local size = h / 3
      XeninUI:DrawIconRotated(w - size * 0.5 - 8, h * 0.5, size, size, pnl.Rotation, pnl, Color(182, 182, 182))

      draw.SimpleText(pnl.Text, pnl.Font, 8, h * 0.5, pnl.TextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end
    panel.SizeToContents = function(pnl)
      local width = 36
      surface.SetFont(pnl.Font)
      local tw = surface.GetTextSize(pnl.Text)
      width = width + tw

      pnl:SetWide(width)
    end
    panel.OnCursorEntered = function(pnl)
      pnl:LerpColor("Outline", ((tbl and tbl.outline) and tbl.outline.hover) or XeninUI.Theme.Primary)
      pnl:Lerp("Rotation", 180)
    end
    panel.OnCursorExited = function(pnl)
      if (IsValid(pnl.Popup)) then return end

      pnl:LerpColor("Outline", ((tbl and tbl.outline) and tbl.outline.standard) or XeninUI.Theme.Navbar)
      pnl:Lerp("Rotation", 0)
    end
    panel.RemovePopup = function(pnl)
      if (!IsValid(pnl.Popup)) then return end

      pnl.Popup:Remove()
    end
    panel.OnRemove = panel.RemovePopup
    panel.DoClick = function(pnl)
      pnl:RemovePopup()

      local aX, aY = pnl:LocalToScreen()

      local popup = vgui.Create("EditablePanel")
      pnl.Popup = popup
      popup:SetDrawOnTop(true)
      popup:SetZPos(125)
      popup:DockPadding(8, 8, 8, 8)
      local width = 16
      local height = 12
      surface.SetFont(pnl.Font)
      for i, v in ipairs(pnl.Choices) do
        local tw = surface.GetTextSize(v.name)
        tw = tw + 32
        if (tw > width) then
          width = tw
        end

        local btn = popup:Add("DButton")
        btn:Dock(TOP)
        btn:DockMargin(0, 0, 0, 4)
        btn:SetText(v.name)
        btn:SetFont("Xenin.Configurator.Admin.Panel.Selectbox")
        btn:SizeToContentsY(8)
        btn.BackgroundColor = Color(22, 22, 22, 0)
        local col = istable(v) and v.__color
        btn.TextColor = col and ColorAlpha(col, 150) or Color(182, 182, 182)
        btn.Paint = function(pnl, w, h)
          pnl:SetTextColor(pnl.TextColor)

          XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.BackgroundColor)
        end
        btn.OnCursorEntered = function(pnl)
          pnl:LerpColor("BackgroundColor", col or Color(22, 22, 22))
          pnl:LerpColor("TextColor", color_white)
        end
        btn.OnCursorExited = function(pnl)
          pnl:LerpColor("BackgroundColor", Color(22, 22, 22, 0))
          pnl:LerpColor("TextColor", col and ColorAlpha(col, 150) or Color(182, 182, 182))
        end
        btn.DoClick = function(pnl)
          panel:SetChoice(pnl:GetText())
          popup:Remove()
          panel:Lerp("Rotation", 0)
        end

        height = height + (btn:GetTall() + 4)
      end
      popup:SetWide(width)
      popup:SetTall(0)
      popup:LerpHeight(height, 0.3)
      popup.Alpha = 0
      popup:LerpAlpha(255, 0.3)
      popup.OnFocusChanged = function(pnl, gained)
        if (gained) then return end

        pnl:Remove()
        panel:OnCursorExited()
      end
      popup.Paint = function(pnl, w, h)
        local aX, aY = pnl:LocalToScreen()

        BSHADOWS.BeginShadow()
        XeninUI:DrawRoundedBox(6, aX, aY, w, h, XeninUI.Theme.Background)
        BSHADOWS.EndShadow(1, 1, 1, 150 * (255 / pnl:GetAlpha()))
      end
      popup:SetPos(aX + pnl:GetWide() - popup:GetWide(), aY + pnl:GetTall())
      popup:MakePopup()
    end

    return panel
  end
  },
  ["Toggle"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("XeninUI.Checkbox")
    panel:DockMargin(0, 6, 6, 6)
    local off = "OFF"
    local on = "ON"
    if tbl.data then
      if tbl.data.toggle then
        off = tbl.data.toggle[1]
        on = tbl.data.toggle[2]
      end
    end
    local width = 0
    surface.SetFont(panel.font)
    local twOff = surface.GetTextSize(off)
    local twOn = surface.GetTextSize(on)
    local increaseBy = math.max(twOn, twOff)
    width = width + (24 + increaseBy * 2)
    panel.offText = off
    panel.onText = on
    panel:SetWide(width)
    panel.SetInput = function(pnl, input)
      pnl:SetState(input, true)
    end
    panel.GetSettingValue = function(pnl)
      return tobool(pnl:GetState())
    end

    return panel
  end
  },
  ["Checkbox"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("XeninUI.CheckboxV2")
    panel:DockMargin(0, 12, 0, 12)
    panel.Background = XeninUI.Theme.Background
    panel:SetWide(32)
    panel.SetInput = function(pnl, value)
      pnl:SetState(tobool(value), true)
    end
    panel.GetSettingValue = function(pnl)
      return tobool(pnl.State)
    end

    return panel
  end
  },
  ["Color"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("DButton")
    panel:SetText("")
    panel.RemovePopup = function(pnl)
      if (!IsValid(pnl.Popup)) then return end

      pnl.Popup:Remove()
    end
    panel.OnRemove = panel.RemovePopup
    panel.DoClick = function(pnl)
      if IsValid(pnl.Popup) then return end

      local popup = vgui.Create("EditablePanel")
      pnl.Popup = popup
      pnl.Popup.OnFocusChanged = function(popup, gained)
        if (gained) then return end


        timer.Simple(0, function()
          if (!IsValid(popup)) then return end
          if (popup:HasHierarchicalFocus()) then return end

          popup:Remove()
        end)
      end
      pnl.Popup.Think = function(pnl)
        if (pnl:HasHierarchicalFocus()) then return end
        if (!pnl.SingleFramedPassed) then
          pnl.SingleFramedPassed = true

          return
        end

        pnl:Remove()
      end
      local aX, aY = pnl:LocalToScreen()
      pnl.Popup:SetSize(180, 216)
      pnl.Popup:SetPos(aX - pnl.Popup:GetWide() + 48, aY + 48)
      pnl.Popup:SetDrawOnTop(true)
      pnl.Popup:MakePopup()
      pnl.Popup.Paint = function(pnl, w, h)
        XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Primary, false, false, true, true)
      end
      pnl.Popup:DockPadding(8, 8, 8, 8)

      local top = pnl.Popup:Add("Panel")
      pnl.Popup.Top = top
      top:Dock(TOP)
      top:SetTall(36)
      top.PerformLayout = function(pnl, w, h)
        local width = w / 3 - 2

        for i, v in ipairs(pnl:GetChildren()) do
          v:SetWide(width)
        end
      end
      top.SetColor = function(pnl, color)
        local children = pnl:GetChildren()
        assert(color ~= nil, "cannot destructure nil value")
        local r, g, b = color.r, color.g, color.b

        children[1]:SetValue(r)
        children[2]:SetValue(g)
        children[3]:SetValue(b)

        panel.Color = Color(r, g, b)
      end
      top.GetColor = function(pnl)
        local children = pnl:GetChildren()

        return Color(children[1]:GetValue(), children[2]:GetValue(), children[3]:GetValue())
      end

      local function color(i, val)
        local _panel = top:Add("DPanel")
        _panel:Dock(LEFT)
        _panel:DockMargin(0, 0, 4, 0)
        _panel.Paint = function(pnl, w, h)
          local col
          if (i == 1) then
            col = XeninUI.Theme.Red
          elseif (i == 2) then
            col = XeninUI.Theme.Green
          elseif (i == 3) then
            col = XeninUI.Theme.Blue
          end

          XeninUI:DrawRoundedBox(6, 0, 0, w, h, col)
        end

        _panel.Textentry = _panel:Add("XeninUI.TextEntry")
        local textentry = _panel.Textentry
        textentry:Dock(FILL)
        textentry:DockMargin(1, 1, 1, 1)
        textentry.textentry:SetNumeric(true)
        textentry.textentry:SetUpdateOnType(true)
        textentry.textentry.OnValueChange = function(s, text)
          pnl.Popup.Picker:SetColor(top:GetColor())

          if s:HasFocus() then
            s:SetCaretPos(#s:GetText())
          end
        end
        _panel.SetValue = function(pnl, value)
          textentry:SetText(value)
        end
        _panel.GetValue = function(pnl)
          return tonumber(textentry:GetText()) or 0
        end
      end

      for i = 1, 3 do
        color(i)end

      pnl.Popup.Picker = pnl.Popup:Add("DColorMixer")
      local picker = pnl.Popup.Picker
      picker:SetPalette(false)
      picker:SetAlphaBar(false)
      picker:SetWangs(false)
      picker:Dock(FILL)
      picker:DockMargin(0, 8, 0, 0)
      picker.OnChange = function(pnl, color)
        local r = math.Round(color.r)
        local g = math.Round(color.g)
        local b = math.Round(color.b)

        top:SetColor(color)

        if panel.onChange then
          panel:onChange(color)
        end
      end
      picker.ValueChanged = picker.OnChange
      picker:SetColor(panel.Color)
    end
    panel:SetWide(48)
    panel.Color = Color(180, 180, 180)
    panel.Paint = function(pnl, w, h)
      local size = h / 4

      XeninUI:DrawCircle(h * 0.5, h * 0.5, size, 30, pnl.Color)
    end
    panel.SetInput = function(pnl, input)
      if isstring(input) then
        pnl.Color = XeninUI:HexToRGB("#" .. input)
      else
        pnl.Color = input
      end
    end
    panel.GetSettingValue = function(pnl)
      return pnl.Color
    end

    return panel
  end
  },
  ["Popup"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("DButton")
    panel:SetText("")
    panel:DockMargin(0, 8, 6, 8)
    panel:SetWide(32)
    XeninUI:DownloadIcon(panel, "CEIrmnK")
    panel.Data = {}
    panel.GetSettingValue = function(pnl)
      return pnl.Data end
    panel.SetInput = function(pnl, value) end
    panel.Color = Color(180, 180, 180)
    panel.Paint = function(pnl, w, h)
      XeninUI:DrawIcon(4, 4, w - 8, h - 8, pnl, pnl.Color)
    end
    panel.OnCursorEntered = function(pnl, w, h)
      pnl:LerpColor("Color", color_white)
    end
    panel.OnCursorExited = function(pnl, w, h)
      pnl:LerpColor("Color", Color(180, 180, 180))
    end
    panel.RemovePopup = function(pnl)
      if (!IsValid(pnl.Popup)) then return end

      pnl.Popup:Remove()
    end
    panel.OnRemove = panel.RemovePopup
    panel.DoClick = function(pnl)
      pnl:RemovePopup()
    end

    return panel
  end
  },
  ["Range"] = {
  panel = function(self)
    local panel = vgui.Create("Panel")
    panel:DockMargin(0, 6, 6, 6)
    panel.SizeToContents = function(pnl)
      local h = pnl:GetTall()
      pnl.Min:SetTall(h)
      pnl.Separator:SetTall(h)
      pnl.Max:SetTall(h)


      local tw = 0
      surface.SetFont(pnl.Min.textentry:GetFont())
      tw = surface.GetTextSize(pnl.Min:GetText())
      tw = tw + 24
      tw = math.Clamp(tw, 28, 250)
      pnl.Min:SetWide(tw)


      tw = 0
      surface.SetFont(pnl.Max.textentry:GetFont())

      tw = surface.GetTextSize(pnl.Max:GetText())
      tw = tw + 24
      tw = math.Clamp(tw, 28, 250)
      pnl.Max:SetWide(tw)

      pnl.Separator:SizeToContents()

      local width = 0
      width = width + pnl.Min:GetWide()
      width = width + (8 + pnl.Separator:GetWide() + 8)
      width = width + pnl.Max:GetWide()

      pnl:SetWide(width)

      pnl.Min:SetPos(0, 0)
      pnl.Separator:SetPos(pnl.Min:GetWide() + 8, 9)
      pnl.Max:SetPos(pnl.Separator.x + pnl.Separator:GetWide() + 8, 0)
    end
    panel.PerformLayout = panel.SizeToContents

    panel.Min = panel:Add("XeninUI.TextEntry")
    panel.Min.textentry:SetUpdateOnType(true)
    panel.Min.textentry.OnValueChange = function(pnl)
      panel:SizeToContents()end

    panel.Separator = panel:Add("DLabel")
    panel.Separator:SetText("to")
    panel.Separator:SetFont("Xenin.Configurator.Inputs.Label")
    panel.Separator:SetContentAlignment(2)

    panel.Max = panel:Add("XeninUI.TextEntry")
    panel.Max.textentry:SetUpdateOnType(true)
    panel.Max.textentry.OnValueChange = function(pnl)
      panel:SizeToContents()end

    panel:SizeToContents()

    return panel
  end
  },
  ["TextentryList"] = {
  panel = function(self, tbl, extra)
    local split = {}
    if istable(tbl.value) then
      split = tbl.value
    else

      local value = string.Trim(tbl.value or "")
      split = util.JSONToTable(value)

      if (!split) then
        split = string.Explode(",", value)
      end
      if (value == "" or !split) then
        split = {}
      end
    end

    local panel = vgui.Create("DLabel")
    panel:DockMargin(0, 0, 8, 0)
    panel:SetFont("Xenin.Configurator.Inputs.Label")
    panel.SetTableData = function(pnl, data)
      local amt = #data
      tbl.dataRows = data

      pnl:SetAmount(amt)
    end
    panel.GetSettingValue = function(pnl)
      return tbl.dataRows
    end
    panel.SetAmount = function(pnl, amt)
      local suffix = "result" .. (amt != 1 and "s" or "")
      pnl:SetText(tostring(amt) .. " " .. tostring(suffix))
      pnl:SizeToContents()
    end
    panel.OnCursorEntered = function(pnl)
      pnl:SetCursor("hand")
    end
    panel.OnCursorExited = function(pnl)
      pnl:SetCursor("blank")
    end
    panel.RemovePopup = function(pnl)
      if (!IsValid(pnl.Popup)) then return end

      pnl.Popup:Remove()
    end
    panel.OnRemove = panel.RemovePopup
    panel.DoClick = function(pnl)
      local popup = vgui.Create("XeninUI.Configurator.DataPopup")
      pnl.Popup = popup
      popup:SetData(tbl, extra)
    end
    panel:SetTableData(split)

    return panel
  end
  },
  ["Key"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("Panel")
    panel:DockMargin(0, 8, 6, 8)
    panel.Key = tbl.defaultValue
    panel.Font = "Xenin.Configurator.Inputs.Label"
    panel:SetCursor("hand")
    panel.Paint = function(pnl, w, h)
      local code = input.GetKeyName(pnl.Key) or "NONE"
      draw.SimpleText(code:upper(), pnl.Font, w * 0.5, h * 0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

      XeninUI:MaskInverse(function()
        XeninUI:DrawRoundedBox(6, 1, 1, w - 2, h - 2, color_white)
      end, function()
        XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Active and XeninUI.Theme.Accent or XeninUI.Theme.Primary)
      end)
    end
    panel.OnMousePressed = function(pnl)
      pnl.Active = true
      pnl:RequestFocus()
    end
    panel.OnFocusChanged = function(pnl, gained)
      pnl.Active = gained
    end
    panel.OnKeyCodeReleased = function(pnl, keyCode)
      if (!pnl.Active) then return end

      pnl.Key = keyCode == KEY_ESCAPE and KEY_NONE or keyCode
      pnl:SizeToContentsX()
      pnl:KillFocus()
      pnl.Active = nil
    end
    panel.GetSettingValue = function(pnl)
      return pnl.Key
    end
    panel.SizeToContentsX = function(pnl)
      local code = input.GetKeyName(pnl.Key) or "NONE"
      local font = pnl.Font
      local tw = surface.GetTextSize(code:upper())

      pnl:SetWide(tw + 16)
    end
    panel:SizeToContentsX()

    return panel
  end
  },
  ["KeyValue"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("Panel")
    XeninUI:DownloadIcon(panel, "2QGKAd6")
    panel.ArrowColor = Color(180, 180, 180)
    panel.Rotation = 0
    panel:SetCursor("hand")
    panel.Paint = function(pnl, w, h)
      local size = 48 / 3
      XeninUI:DrawIconRotated(w - size, size + size * 0.5, size, size, pnl.Rotation, pnl, pnl.ArrowColor)
    end
    panel.SetExpanded = function(pnl, state)
      pnl.Active = state
      pnl:Lerp("Rotation", state and 180 or 0, 0.4)

      if (!IsValid(pnl.SettingsDropdown) and state) then
        pnl:CreateDropdown()
      end

      pnl:SetHeight(state)
    end
    panel.SetHeight = function(pnl, state)
      local parent = pnl:GetParent()
      local height = 48
      if state then height = height + pnl.SettingsDropdown:GetHeight()
      end
      pnl.Think = function()

        parent:GetParent():GetParent():GetParent():InvalidateLayout(true)
      end
      parent:EndAnimations()
      parent:Lerp("Height", height, 0.4)
      parent:LerpHeight(height, 0.4, function()
        if (!IsValid(pnl)) then return end

        pnl.Think = function() end
      end)
    end
    panel.OnCursorEntered = function(pnl)
      pnl:LerpColor("ArrowColor", color_white)
    end
    panel.OnCursorExited = function(pnl)
      if (pnl.Active) then return end

      pnl:LerpColor("ArrowColor", Color(180, 180, 180))
    end
    panel.OnMousePressed = function(pnl)
      pnl:SetExpanded(!pnl.Active)
    end
    panel.CreateDropdown = function(pnl)
      local settings = pnl:Add("Panel")
      pnl.SettingsDropdown = settings
      settings:Dock(FILL)
      settings:DockMargin(0, 48, 0, 8)
      settings.GetHeight = function(pnl)
        local h = 48
        for i, v in ipairs(pnl.Rows) do
          h = h + (v:GetTall() + 4)
        end

        return h
      end

      settings.Content = settings:Add("Panel")
      settings.Content:Dock(FILL)
      settings.Content:DockMargin(0, 0, 0, 8)

      settings.Rows = {}

      settings.Bottom = settings:Add("Panel")
      settings.Bottom:Dock(BOTTOM)
      settings.Bottom:SetTall(32)

      settings.New = settings.Bottom:Add("XeninUI.ButtonV2")
      settings.New:Dock(RIGHT)
      settings.New:SetText("Create New")
      settings.New:SetFont("Xenin.Configurator.KeyValue")
      settings.New:SizeToContentsX(24)
      settings.New:SetRoundness(6)
      settings.New:SetSolidColor(XeninUI.Theme.Primary)
      settings.New:SetHoverColor(XeninUI.Theme.Green)
      settings.New.DoClick = function(pnl)
        settings:CreateRow(nil, tbl.data.right.default)

        settings:GetParent():SetHeight(true)
      end

      settings.SetData = function(pnl, data)
        for i, v in pairs(data) do
          pnl:CreateRow(i, v)
        end
      end

      settings.CreateRow = function(pnl, i, v)
        local col = XeninUI.Theme.Navbar
        local row = settings.Content:Add("Panel")
        row:Dock(TOP)
        row:DockMargin(0, 0, 0, 4)
        row:SetTall(40)
        row.Think = function(pnl)
          pnl.Delete:SetVisible(pnl:IsHovered() or pnl:IsChildHovered())
        end
        row.Paint = function(pnl, w, h)
          XeninUI:DrawRoundedBox(6, 0, 0, w, h, col)
        end

        local left = tbl.data.left or {}
        row.Left = XeninUI.Configurator:CreateInputPanel(left.type, self, tbl)
        row.Left:SetParent(row)
        row.Left:Dock(LEFT)
        row.Left:DockMargin(0, 0, 0, 0)
        if (left.type == "Textentry") then
          row.Left:SetPlaceholder(left.placeholder or "")
          row.Left:SetInput(i or "")
          row.Left:SetTextColor(Color(180, 180, 180))
          local paint = row.Left.Paint
          row.Left.OutlineColor = XeninUI.Theme.Primary
          row.Left.Paint = function(pnl, w, h)
            if paint then paint(pnl, w, h)end

            XeninUI:MaskInverse(function()
              XeninUI:DrawRoundedBoxEx(6, 1, 1, w - 2, h - 2, pnl.OutlineColor, true, false, true, false)
            end, function()
              XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, pnl.textentry:HasFocus() and XeninUI.Theme.Accent or pnl.OutlineColor, true, false, true, false)
            end)
          end
        end
        if row.Left.SetData then
          row.Left:SetData(tbl.data.left)
          row.Left:SetInput(i or tbl.data.left.default)
        end
        if row.Left.SetBackgroundColor then
          row.Left:SetBackgroundColor(col)
        end

        local right = tbl.data.right or {}
        row.Right = XeninUI.Configurator:CreateInputPanel(right.type, self, right)
        row.Right:SetParent(row)
        row.Right:Dock(RIGHT)
        row.Right:DockMargin(0, 0, 0, 0)
        if (right.type == "Textentry") then
          if right.placeholder then
            row.Right:SetPlaceholder(right.placeholder)
          end
          row.Right:SetInput(tostring(v))
          if right.readOnly then
            row.Right:SetEnabled(false)
            row.Right.textentry:SetEnabled(false)
            row.Right.textentry:SetCursor("no")
          end
          if right.number then
            row.Right:SetNumeric(true)
          end
        elseif (right.type == "TextentryWithLabel") then
          row.Right.textentry:SetPlaceholder(right.placeholder or "")
          row.Right.textentry:SetText(v or right.default or "")
          row.Right.textentry:DoSizing(row.Right.textentry:GetText())
        end

        if row.Right.SetBackgroundColor then
          row.Right:SetBackgroundColor(col)
        end

        row.Right:SetVisible(!right.hide)

        row.Delete = row:Add("DButton")
        row.Delete:SetVisible(false)
        row.Delete:Dock(RIGHT)
        row.Delete:SetText("")
        row.Delete.Paint = function(pnl, w, h)
          XeninUI:DrawRoundedBox(6, 4, 4, w - 8, h - 8, XeninUI.Theme.Red)

          surface.SetMaterial(XeninUI.Materials.CloseButton)
          surface.SetDrawColor(color_white)
          local size = h * 0.35
          surface.DrawTexturedRect(w * 0.5 - size * 0.5, h * 0.5 - size * 0.5, size, size)
        end
        row.Delete.DoClick = function(pnl, w, h)
          for i, v in ipairs(settings.Rows) do
            if (tobool(v != row)) then continue end

            table.remove(settings.Rows, i)
          end

          row:Remove()
          settings:GetParent():SetHeight(true)
        end
        row.Delete:SetWide(40)

        row.GetSettingValue = function(pnl)
          return {
            key = pnl.Left:GetSettingValue(),
            value = pnl.Right:GetSettingValue()
          }
        end

        table.insert(pnl.Rows, row)
      end

      settings:SetData(tbl.value)
    end
    panel:SetWide(600)
    panel.GetSettingValue = function(pnl)
      if (!IsValid(pnl.SettingsDropdown)) then
        pnl:CreateDropdown()
      end

      local tbl = {}

      for i, v in ipairs(pnl.SettingsDropdown.Rows) do
        local rowTbl = v:GetSettingValue()
        tbl[rowTbl.key] = rowTbl.value
      end

      return tbl
    end

    return panel
  end
  },
  ["SliderPad"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("XeninUI.SliderPad")
    panel:DockMargin(0, 8, 0, 8)
    panel.GetSettingValue = function(pnl)
      return pnl:GetValue()
    end
    panel.Textentry:SetWide(((tbl and tbl.data) and tbl.data.textWidth) or 40)

    panel:SetMin(((tbl and tbl.data) and tbl.data.min) or 0)
    panel:SetMax(((tbl and tbl.data) and tbl.data.max) or 10)
    panel:SetValue(tbl.value)
    panel:SetWide(((tbl and tbl.data) and tbl.data.width) or 200)
    panel:SetColor(((tbl and tbl.data) and tbl.data.color) or XeninUI.Theme.Accent)

    return panel
  end
  },
  ["ListDropdownDarkRPCategories"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("Panel")
    XeninUI:DownloadIcon(panel, "2QGKAd6")
    panel.ArrowColor = Color(180, 180, 180)
    panel.Rotation = 0
    panel:SetCursor("hand")
    panel.Paint = function(pnl, w, h)
      local size = 48 / 3
      XeninUI:DrawIconRotated(w - size, size + size * 0.5, size, size, pnl.Rotation, pnl, pnl.ArrowColor)
    end
    panel.SetExpanded = function(pnl, state)
      pnl.Active = state
      pnl:Lerp("Rotation", state and 180 or 0, 0.4)

      if (!IsValid(pnl.SettingsDropdown) and state) then
        pnl:CreateDropdown()
      end

      pnl:SetHeight(state)
    end
    panel.SetHeight = function(pnl, state)
      local parent = pnl:GetParent()
      local height = 48
      if state then height = height + pnl.SettingsDropdown:GetHeight()
      end
      pnl.Think = function()

        parent:GetParent():GetParent():GetParent():InvalidateLayout(true)
      end
      parent:EndAnimations()
      parent:Lerp("Height", height, 0.4)
      parent:LerpHeight(height, 0.4, function()
        if (!IsValid(pnl)) then return end

        pnl.Think = function() end
      end)
    end
    panel.OnCursorEntered = function(pnl)
      pnl:LerpColor("ArrowColor", color_white)
    end
    panel.OnCursorExited = function(pnl)
      if (pnl.Active) then return end

      pnl:LerpColor("ArrowColor", Color(180, 180, 180))
    end
    panel.OnMousePressed = function(pnl)
      pnl:SetExpanded(!pnl.Active)
    end
    panel.CreateDropdown = function(pnl)
      local settings = pnl:Add("Panel")
      pnl.SettingsDropdown = settings
      settings:Dock(FILL)
      settings:DockMargin(0, 48, 0, 8)
      settings.GetHeight = function(pnl)
        local h = 48
        for i, v in ipairs(pnl.Rows) do
          h = h + (v:GetTall() + 4)
        end

        return h
      end

      settings.Content = settings:Add("Panel")
      settings.Content:Dock(FILL)
      settings.Content:DockMargin(0, 0, 0, 8)

      settings.Rows = {}

      settings.Bottom = settings:Add("Panel")
      settings.Bottom:Dock(BOTTOM)
      settings.Bottom:SetTall(32)

      settings.New = settings.Bottom:Add("XeninUI.ButtonV2")
      settings.New:Dock(RIGHT)
      settings.New:SetText("Add New")
      settings.New:SetFont("Xenin.Configurator.KeyValue")
      settings.New:SizeToContentsX(24)
      settings.New:SetRoundness(6)
      settings.New:SetSolidColor(XeninUI.Theme.Primary)
      settings.New:SetHoverColor(XeninUI.Theme.Green)
      settings.New.DoClick = function(btn)
        local existingCategories = pnl:GetSettingValue()
        local allCategories = DarkRP.getCategories().jobs
        local categories = {}
        for i, v in ipairs(allCategories) do
          if (existingCategories[v.name]) then continue end

          table.insert(categories, v)
        end

        local options = XeninUI.Options(pnl)
        for i, v in ipairs(categories) do
          options:addButton({
            text = v.name,
            onClick = function()
              settings:CreateRow(v.name)
              settings:GetParent():SetHeight(true)
            end
          })
        end
        options:create()
      end

      settings.SetData = function(pnl, data)
        for i, v in pairs(data) do
          print(i, v)
          pnl:CreateRow(i)
        end
      end
      settings.CreateRow = function(pnl, name)
        local col = XeninUI.Theme.Navbar
        local row = settings.Content:Add("Panel")
        row:Dock(TOP)
        row:DockMargin(0, 0, 0, 4)
        row:SetTall(40)
        row.Think = function(pnl)
          pnl.Delete:SetVisible(pnl:IsHovered() or pnl:IsChildHovered())
        end
        row.Paint = function(pnl, w, h)
          XeninUI:DrawRoundedBox(6, 0, 0, w, h, col)
        end

        row.Left = row:Add("DLabel")
        row.Left:Dock(LEFT)
        row.Left:DockMargin(12, 0, 0, 0)
        row.Left:SetFont("XeninUI.TextEntry")
        row.Left:SetText(name)
        row.Left:SetTextColor(Color(180, 180, 180))
        row.Left:SizeToContentsX()

        row.Delete = row:Add("DButton")
        row.Delete:SetVisible(false)
        row.Delete:Dock(RIGHT)
        row.Delete:SetText("")
        row.Delete.Paint = function(pnl, w, h)
          XeninUI:DrawRoundedBox(6, 4, 4, w - 8, h - 8, XeninUI.Theme.Red)

          surface.SetMaterial(XeninUI.Materials.CloseButton)
          surface.SetDrawColor(color_white)
          local size = h * 0.35
          surface.DrawTexturedRect(w * 0.5 - size * 0.5, h * 0.5 - size * 0.5, size, size)
        end
        row.Delete.DoClick = function(pnl, w, h)
          for i, v in ipairs(settings.Rows) do
            if (tobool(v != row)) then continue end

            table.remove(settings.Rows, i)
          end

          row:Remove()
          settings:GetParent():SetHeight(true)
        end
        row.Delete:SetWide(40)

        row.GetSettingValue = function(pnl)
          return {
            key = pnl.Left:GetText(),
            value = true
          }
        end

        table.insert(pnl.Rows, row)
      end

      settings:SetData(tbl.value)
    end
    panel:SetWide(600)
    panel.GetSettingValue = function(pnl)
      if (!IsValid(pnl.SettingsDropdown)) then
        pnl:CreateDropdown()
      end

      local tbl = {}

      for i, v in ipairs(pnl.SettingsDropdown.Rows) do
        local rowTbl = v:GetSettingValue()
        tbl[rowTbl.key] = rowTbl.value
      end

      return tbl
    end

    return panel
  end
  }
}

function XeninUI.Configurator:CreateInputPanel(panel, bindTo, tbl, extra)
  if extra == nil then extra = {}
  end
  return self.InputPanels[panel].panel(bindTo, tbl, extra)
end

local PANEL = {}

XeninUI:CreateFont("Xenin.Configurator.Admin.Data.Title", 22)
XeninUI:CreateFont("Xenin.Configurator.Admin.Data.Button", 16)
XeninUI:CreateFont("Xenin.Configurator.Admin.Data.Row", 16)

function PANEL:Init()
  self:SetSize(ScrW(), ScrH())
  self:SetBackgroundWidth(500)
  self:SetBackgroundHeight(500)
  self:MakePopup()

  self.Body = self:Add("Panel")
  self.Body:Dock(FILL)
  self.Body:DockPadding(16, 16, 16, 16)

  self.Top = self.Body:Add("Panel")
  self.Top:Dock(TOP)
  self.Top:SetTall(28)

  self.Title = self.Top:Add("DLabel")
  self.Title:Dock(LEFT)
  self.Title:SetFont("Xenin.Configurator.Admin.Data.Title")

  self.Save = self.Top:Add("XeninUI.ButtonV2")
  self.Save:Dock(RIGHT)
  self.Save:SetFont("Xenin.Configurator.Admin.Data.Button")
  self.Save:SetText("Save Rows")
  self.Save:SizeToContentsX(16)
  self.Save:SetRoundness(6)
  self.Save:SetSolidColor(XeninUI.Theme.Blue)
  self.Save.DoClick = function(pnl)
    self:OnSave(self.Results)
  end

  self.Create = self.Top:Add("XeninUI.ButtonV2")
  self.Create:Dock(RIGHT)
  self.Create:DockMargin(0, 0, 8, 0)
  self.Create:SetFont("Xenin.Configurator.Admin.Data.Button")
  self.Create:SetText("Create New")
  self.Create:SizeToContentsX(16)
  self.Create:SetRoundness(6)
  self.Create:SetSolidColor(XeninUI.Theme.Primary)
  self.Create.DoClick = function(pnl)
    local newId = #self.Results + 1

    self:CreateRow(newId, "")
    self:SetResultsTitle()
  end

  self.Scroll = self.Body:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)
  self.Scroll:DockMargin(0, 16, 0, 0)
end

function PANEL:Add(pnl)
  return self.background:Add(pnl)
end

function PANEL:SetData(data, extra)
  self.Results = data.dataRows
  self.Data = data
  self.Extra = extra

  self:SetTitle(extra.name)
  self:CreateRows(self.Results)
end

function PANEL:SetResultsTitle()
  local amt = #self.Results
  local str = "row" .. (amt != 1 and "s" or "")
  self.Title:SetText(amt .. " " .. str)
  self.Title:SizeToContents()
end

function PANEL:CreateRows(data)
  for i, v in ipairs(data) do
    self:CreateRow(i, v)
  end

  self:SetResultsTitle()
end

function PANEL:CreateRow(id, val)
  local row = self.Scroll:Add("DPanel")
  row:Dock(TOP)
  row:DockMargin(0, 0, 8, 4)
  row:SetTall(36)
  row.Id = id
  row.Color = id % 2 == 0 and XeninUI.Theme.Primary or XeninUI.Theme.Navbar
  row.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Color)

    draw.SimpleText("#" .. tostring(pnl.Id), "Xenin.Configurator.Admin.Data.Row", 8, h * 0.5, Color(174, 174, 174), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    pnl.Delete:SetVisible(pnl:IsHovered() or pnl:IsChildHovered())
  end

  row.Delete = row:Add("DButton")
  row.Delete:Dock(LEFT)
  row.Delete:SetWide(40)
  row.Delete:SetText("")
  row.Delete.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Red, true, false, true, false)

    surface.SetMaterial(XeninUI.Materials.CloseButton)
    surface.SetDrawColor(color_white)
    local size = h * 0.4
    surface.DrawTexturedRect(w * 0.5 - size * 0.5, h * 0.5 - size * 0.5, size, size)
  end
  row.Delete.DoClick = function(pnl, w, h)
    table.remove(self.Results, row.Id)
    row:Remove()

    local index = 1
    for i, v in ipairs(self.Scroll:GetCanvas():GetChildren()) do
      if (!IsValid(v)) then continue end

      v.Id = index
      v.Input.textentry:OnValueChange(v.Input:GetText())

      index = index + 1
    end

    self:SetResultsTitle()
  end

  row.Input = row:Add("XeninUI.TextEntry")
  row.Input:Dock(RIGHT)
  row.Input:SetBackgroundColor(row.Color)
  row.Input:SetFont("Xenin.Configurator.Admin.Data.Row")
  row.Input:SetPlaceholder("Value")
  row.Input.textentry:SetUpdateOnType(true)
  row.Input.textentry.OnValueChange = function(pnl, text)
    surface.SetFont(pnl:GetFont())
    local text = pnl:GetText()
    self.Results[row.Id] = text
    if (text == "") then text = row.Input:GetPlaceholder()end
    local tw = surface.GetTextSize(text)
    tw = tw + 24
    local width = math.Clamp(tw, 28, 600)
    row.Input:SetWide(width)
  end
  row.Input:SetText(val)
  row.Input.textentry:OnValueChange(val)
end

function PANEL:OnSave(data)
  self.Extra.parent.Input:SetTableData(data)
end

vgui.Register("XeninUI.Configurator.DataPopup", PANEL, "XeninUI.Popup")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/entities/row_settings.lua:
local PANEL = {}

function PANEL:AddSettings(entity)
  self.Entity = entity
  self.Parent = self:GetParent()
  local columns = entity:getColumns()

  for i, v in ipairs(columns) do
    local split = string.Explode("_", v.id)
    local name = ""
    for i, v in ipairs(split) do
      local temp = v:sub(1, 1):upper() .. v:sub(2)
      name = name .. (temp .. (i == #split and "" or " "))
    end

    local funcName = v.id:sub(1, 1):upper() .. v.id:sub(2)
    local value = entity["get" .. tostring(funcName)](entity)

    local label = v.label or ""
    if (v.min or v.max) then
      if (v.min and v.max) then
        label = "Min: " .. tostring(v.min) .. ". Max: " .. tostring(v.max)
      elseif v.min then
        label = "Min: " .. tostring(v.min)
      elseif v.max then
        label = "Max: " .. tostring(v.max)
      end
    end

    local type = "Textentry"
    if (v.type == "list") then
      type = "TextentryList"
    end
    if ((v.validate or label) and type == "Textentry") then
      type = "TextentryWithLabel"
    end

    local detour = v.onChange
    v.onChange = function(row, text)
      self:OnValueChanged()
    end

    if v.isName then
      local detour = v.onChange
      if detour then
        v.onChange = function(row, text)
          local tbl = entity.transformName and entity:transformName(text) or {
          text }
          local name = tbl[1]
          local msg = tbl[2]
          local color = tbl[3]

          self.Parent.Name = name

          if (type == "TextentryWithLabel") then
            row.label:SetText(msg or "")
            row.label:SetTextColor(color or Color(127, 127, 127))
            row.label:SizeToContents()
          end

          detour(row, text)
        end
      else
        v.onChange = function(row, text)
          local tbl = entity.transformName and entity:transformName(text) or {
          text }
          local name = tbl[1]
          local msg = tbl[2]
          local color = tbl[3]

          self.Parent.Name = name

          if (type == "TextentryWithLabel") then
            row.label:SetText(msg or "")
            row.label:SetTextColor(color or Color(127, 127, 127))
            row.label:SizeToContents()
          end
        end
      end
    end

    if (!value and v.min and v.max) then
      value = v.min
    end

    local labelColor
    value = value or (isfunction(v.defaultValue) and v.defaultValue() or v.defaultValue)
    if (entity.transformName and v.isName) then
      local transform = entity:transformName(value)
      label = transform[2]
      labelColor = transform[3]
    end

    self:AddSetting(v.id, name, type, {
      value = value,
      readOnly = v.readOnly,
      onChange = v.onChange,
      number = v.type == "integer" or v.type == "float",
      min = v.min,
      max = v.max,
      hide = v.hide,
      label = label,
      labelColor = labelColor,
      placeholder = v.placeholder
    })
  end
end

function PANEL:OnValueChanged() end

vgui.Register("Xenin.Configurator.Admin.Entity.Row.Settings", PANEL, "Xenin.Configurator.Admin.SettingsBase")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/keyvalue.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/textentrylist.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/players/notification.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
local Types
do
  local _class_0
  local _base_0 = {
    __name = "Types",
    _getId = function(self, scriptId, typeId)
      return scriptId .. "_" .. typeId
    end,
    set = function(self, scriptId, typeId, data)
      self.cache[self:_getId(scriptId, typeId)] = data
    end,
    get = function(self, scriptId, typeId)
      return self.cache[self:_getId(scriptId, typeId)]
    end,
    getAll = function(self)
      return self.cache
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.cache = {}
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Types = _class_0
end
local Builder
do
  local _class_0
  local _base_0 = {
    __name = "Builder",
    setSteamID64 = function(self, sid64)
      self.sid64 = sid64

      return self
    end,
    setPlayer = function(self, ply)
      self:setSteamID64(ply:SteamID64())

      return self
    end,
    setScript = function(self, scriptId)
      self.scriptId = scriptId

      return self
    end,
    setType = function(self, typeId)
      self.type = typeId

      return self
    end,
    setContent = function(self, content)
      self.content = content

      return self
    end,
    setData = function(self, data)
      self.data = data

      return self
    end,
    send = function(self)
      self.parent:addNotification(__laux_concat_0(self))

      return self
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, parent)
      self.parent = parent
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Builder = _class_0
end
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Notification",
    builder = function(self)
      return Builder(self)
    end,
    addType = function(self, scriptId, id, data)
      if data == nil then data = {}
      end
      self.types:set(scriptId, id, data)
    end,
    getType = function(self, scriptId, id)
      return self.types:get(scriptId, id)
    end,
    addNotification = function(self, notification)
      if SERVER then
        local db = XeninUI.Players.Database
        db:insertNotification(notification.sid64, notification.scriptId, notification.type, notification.content, notification.data)

        local ply = player.GetBySteamID64(notification.sid64)
        XeninUI.Players.Network:sendNotification(ply, notification)
      else
        error("missing impl")
      end
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.types = Types()
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Notification = _class_0()
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/checkbox_v2.lua:
local PANEL = {}

local matTick = Material("xenin/tick.png", "smooth")

function PANEL:Init()
	self:SetText("")

	self.State = false
	self.AnimationController = 0
	self.Color = XeninUI.Theme.Accent
	self.Background = XeninUI.Theme.Primary
	self.Font = "XeninUI.CheckboxV2"
end

XeninUI:CreateFont("XeninUI.CheckboxV2", 18)

function PANEL:Paint(w, h)
	XeninUI:MaskInverse(function()
		surface.SetDrawColor(color_white)
		local x = h * math.Clamp((self.AnimationController - 0.5) * 2, 0, 1)
		surface.DrawRect(h - x, 0, h, h)
	end, function()
		XeninUI:DrawRoundedBoxEx(6, 0, 0, h, h * 0.5, self.Color, true, true, false, false)
	end)
	XeninUI:MaskInverse(function()
		surface.SetDrawColor(color_white)
		local width = h * math.Clamp(self.AnimationController * 2, 0, 1)
		surface.DrawRect(0, 0, width, h)
	end, function()
		XeninUI:DrawRoundedBoxEx(6, 0, h * 0.5, h, h * 0.5, self.Color, false, false, true, true)
	end)
	XeninUI:DrawRoundedBox(4, 2, 2, h - 4, h - 4, self.Background)

	XeninUI:MaskInverse(function()
		surface.SetDrawColor(color_white)
		local x = h * math.Clamp((self.AnimationController - 1) * 2, 0, 1)
		surface.DrawRect(x, 0, h, h)
	end, function()
		surface.SetMaterial(matTick)
		surface.SetDrawColor(self.Color)
		surface.DrawTexturedRect(0, 0, h, h)
	end)

	if self.Text then
		local x = h + 5
		XeninUI:DrawShadowText(self.Text, self.Font, x, h * 0.5 - 1, self.TextColor or color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, 125)
	end
end

function PANEL:SizeToContentsX()
	surface.SetFont(self.Font)
	local tw = surface.GetTextSize(self.Text)

	self:SetWide(self:GetTall() + 5 + tw)
end

function PANEL:SetState(state, instant)
	self.State = state

	if state then
		if instant then
			self:EndAnimations()
			self.AnimationController = 1.5
		else
			self:Lerp("AnimationController", 1.5, 0.4)
		end
	else
		self:EndAnimations()
		self.AnimationController = 0
	end
end

function PANEL:OnStateChanged() end

function PANEL:Toggle()
	self:SetState(!self.State)
	self:OnStateChanged(self.State)
end

vgui.Register("XeninUI.CheckboxV2", PANEL, "DButton")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/navbar.lua:
XeninUI:CreateFont("XeninUI.Navbar.Button", 25)

local function navbarEase(t, b, c, d)
	t = t / d
	local ts = t * t
	local tc = ts * t

	return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc)
end

local PANEL = {}

function PANEL:Init()
	self.buttons = {}
	self.panels = {}
	self.buttonsNum = {}

	self.font = "XeninUI.Navbar.Button"
	self.accent = XeninUI.Theme.Accent
	self.textActive = self.accent
	self.padding = 60
	self.minSize = 80
	self.dockLeft = 0
	self.lineBasedOffText = false
	self.animation = "alpha"

	self.active = 0

	self.line = self:Add("DPanel")
	self.line:SetMouseInputEnabled(false)
	self.line:SetTall(2)
	self.line.Paint = function(pnl, w, h)
		surface.SetDrawColor(self.accent)
		surface.DrawRect(0, 0, w, h)
	end
end

function PANEL:AddTab(name, panel, tbl)

	self.buttonsNum[#self.buttonsNum + 1] = name

	self.buttons[name] = vgui.Create("DButton", self)
	if (!tbl or (tbl and !tbl.dontDock)) then
		self.buttons[name]:Dock(LEFT)
		self.buttons[name]:DockMargin(self.dockLeft, 0, -self.dockLeft, 0)
	end
	self.buttons[name]:SetText(name)
	self.buttons[name]:SetFont(self.font)
	self.buttons[name].textColor = Color(120, 120, 120)
	self.buttons[name].Paint = function(pnl, w, h)
		pnl:SetTextColor(pnl.textColor)
	end
	self.buttons[name].DoClick = function(pnl)
		self:SetActive(name)
	end
	self.buttons[name].OnCursorEntered = function(pnl)
		pnl:LerpColor("textColor", self.textActive)
	end
	self.buttons[name].OnCursorExited = function(pnl)
		if (self.active == name) then return end

		pnl:LerpColor("textColor", Color(120, 120, 120))
	end

	surface.SetFont(self.font)
	local tw, th = surface.GetTextSize(name)
	self.buttons[name]:SetWide(math.max(self.minSize, tw + self.padding))

	if (!panel) then panel = "Panel"end

	self.panels[name] = vgui.Create(panel, self.body)
	self.panels[name]:Dock(FILL)
	self.panels[name]:SetVisible(false)
	self.panels[name].Data = tbl

	if self.panels[name].SetData then
		self.panels[name]:SetData(tbl)
	end

	if (tbl and tbl.PostInit) then
		tbl.PostInit(self.panels[name])
	end

	return self.panels[name]
end

function PANEL:FindIndex(name)
	for i, v in pairs(self.buttonsNum) do
		if (v != name) then continue end

		return i
	end
end

function PANEL:SetActive(name)
	if (self.active == name) then return end

	local instant = !IsValid(self.buttons[self.active])
	if self.buttons[self.active] then
		self.buttons[self.active]:LerpColor("textColor", Color(120, 120, 120))
	end

	if self.panels[self.active] then
		if (self.animation == "alpha") then
			local pnl = self.panels[self.active]
			pnl.DrawAlpha = pnl.DrawAlpha or 0
			pnl.PaintOver = function(pnl, w, h)
				draw.RoundedBoxEx(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Background, pnl.DrawAlpha), false, false, true, true)
			end
			pnl:Lerp("DrawAlpha", 255, 0.15, function()
				pnl.PaintOver = nil
				pnl:SetVisible(false)
			end)
		else
			local pnl = self.panels[self.active]
			pnl:SetVisible(false)
		end

		if self.panels[name].OnSwitchedFrom then
			self.panels[name]:OnSwitchedFrom()
		end
	end

	self.active = name

	if self.buttons[name] then
		if instant then
			self.buttons[name].textColor = self.textActive
			local id = self:FindIndex(name)
			local x = self.dockLeft
			if self.lineBasedOffText then
				x = x + self.padding * 0.5
			end
			surface.SetFont(self.font)
			for i, v in ipairs(self.buttonsNum) do
				if (i >= id) then break end

				if (self.lineBasedOffText and i == id) then
					local tw = surface.GetTextSize(self.buttons[v]:GetText())
					x = x + tw + self.padding
				else
					x = x + self.buttons[v]:GetWide()
				end
			end

			self.line:SetPos(x, (self.startHeight or 56) - self.line:GetTall())
			local width = self.buttons[name]:GetWide()
			if self.lineBasedOffText then
				surface.SetFont(self.font)
				width = surface.GetTextSize(self.buttons[name]:GetText())
			end
			self.line:SetWide(width)
		else
			self.buttons[name]:LerpColor("textColor", self.textActive)
			local id = self:FindIndex(name)
			local x = self.dockLeft
			if self.lineBasedOffText then
				x = x + self.padding * 0.5
			end
			surface.SetFont(self.font)
			for i, v in ipairs(self.buttonsNum) do
				if (i >= id) then break end

				if (self.lineBasedOffText and i == id) then
					local tw = surface.GetTextSize(self.buttons[v]:GetText())
					x = x + tw
				else
					x = x + self.buttons[v]:GetWide()
				end
			end

			self.line:LerpMoveX(x, 0.3, nil, navbarEase)
			local width = self.buttons[name]:GetWide()
			if self.lineBasedOffText then
				surface.SetFont(self.font)
				width = surface.GetTextSize(self.buttons[name]:GetText())
			end
			self.line:LerpWidth(width, 0.3, nil, navbarEase)
		end
	end

	if self.panels[name] then
		if instant then
			local pnl = self.panels[name]
			pnl:SetVisible(true)
		else
			if (self.animation == "alpha") then
				timer.Simple(0.15, function()
					if (!IsValid(self)) then return end

					local pnl = self.panels[name]
					pnl.DrawAlpha = pnl.DrawAlpha or 255
					pnl:SetVisible(true)
					pnl.PaintOver = function(pnl, w, h)
						draw.RoundedBoxEx(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Background, pnl.DrawAlpha), false, false, true, true)
					end
					pnl:Lerp("DrawAlpha", 0, 0.15, function()
						pnl.PaintOver = nil
					end)
				end)
			else
				local pnl = self.panels[name]
				pnl:SetVisible(true)
			end
		end

		if self.panels[name].OnSwitchedTo then
			self.panels[name]:OnSwitchedTo(name)
		end
	end

	self:SwitchedTab(name)
end

function PANEL:SwitchedTab(name) end

function PANEL:GetActive()
	return self.panels[self.active]
end

function PANEL:SetBody(pnl)
	self.body = pnl:Add("Panel")
	self.body:Dock(FILL)
	self.body.Offset = 0
	self.body.PerformLayout = function(pnl, w, h)
		local num = 0
		for i, v in pairs(self.panels) do
			local x = num * w - (pnl.Offset * w)

			v:SetSize(w, h)
			v:SetPos(x, 0)
		end
	end
end

function PANEL:Paint(w, h)
	surface.SetDrawColor(XeninUI.Theme.Navbar)
	surface.DrawRect(0, 0, w, h)
end

vgui.Register("XeninUI.Navbar", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/purchase_confirmation.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.PurchaseConfirmation.Name", 24)
XeninUI:CreateFont("XeninUI.PurchaseConfirmation.Sid64", 18)
XeninUI:CreateFont("XeninUI.PurchaseConfirmation.String", 24)

AccessorFunc(PANEL, "m_player", "Player")
AccessorFunc(PANEL, "m_icon", "Icon")
AccessorFunc(PANEL, "m_purchaseStr", "PurchaseString")
AccessorFunc(PANEL, "m_accept", "Accept")
AccessorFunc(PANEL, "m_decline", "Decline")
AccessorFunc(PANEL, "m_tbl", "Table")

function PANEL:Start()
  self:SetAccept(function() end)
  self:SetDecline(function() end)

  self.background.avatar = self.background:Add("XeninUI.Avatar")
  self.background.avatar:SetPlayer(self:GetPlayer(), 64)
  self.background.avatar:SetVertices(90)
  self.background.avatar:SetMouseInputEnabled(false)

  self.background.name = self.background:Add("DLabel")
  self.background.name:SetText(self:GetPlayer():Nick())
  self.background.name:SetTextColor(color_white)
  self.background.name:SetFont("XeninUI.PurchaseConfirmation.Name")

  self.background.sid64 = self.background:Add("DTextEntry")
  self.background.sid64:SetText(self:GetPlayer():SteamID())
  self.background.sid64:SetTextColor(Color(190, 190, 190))
  self.background.sid64:SetFont("XeninUI.PurchaseConfirmation.Sid64")
  self.background.sid64:SetEnabled(false)
  self.background.sid64:SetDrawLanguageID(false)
  self.background.sid64.Paint = function(pnl, w, h)
    pnl:DrawTextEntryText(pnl:GetTextColor(), pnl:GetTextColor(), pnl:GetTextColor())
  end

  self.background.string = self.background:Add("DLabel")
  self.background.string:SetText(self:GetPurchaseString())
  self.background.string:SetTextColor(Color(220, 220, 220))
  self.background.string:SetWrap(true)
  self.background.string:SetFont("XeninUI.PurchaseConfirmation.String")
  self.background.string:SetContentAlignment(5)

  if (type(self:GetIcon()) == "string") then
    self.background.display = self.background:Add("XeninUI.AnimatedTexture")
    self.background.display:SetDirectory(self:GetIcon())
    local tbl = self:GetTable()
    self.background.display:SetTimes(tbl.normal, tbl.idle)
    self.background.display:PostInit()
  else
    self.background.display = self.background:Add("DPanel")
    self.background.display.Paint = function(pnl, w, h)
      if (!self:GetIcon()) then return end

      surface.SetMaterial(self:GetIcon())
      surface.SetDrawColor(color_white)
      surface.DrawTexturedRect(0, 0, w, h)
    end
  end

  self.background.accept = self.background:Add("DButton")
  self.background.accept:SetText("Confirm purchase")
  self.background.accept:SetFont("XeninUI.Query.Button")
  self.background.accept:SetTextColor(Color(21, 21, 21))
  self.background.accept.alpha = 0
  self.background.accept.background = XeninUI.Theme.Green
  self.background.accept.Paint = function(pnl, w, h)
    local x, y = pnl:LocalToScreen()

    BSHADOWS.BeginShadow()
    draw.RoundedBox(h * 0.5, x, y, w, h, pnl.background)
    BSHADOWS.EndShadow(1, 1, 2, pnl.alpha, 0, 0)
  end
  self.background.accept.OnCursorEntered = function(pnl)
    local col = XeninUI.Theme.Green
    col = Color(col.r + 5, col.g + 50, col.b + 7)

    pnl:LerpColor("background", col)
    pnl:Lerp("alpha", 255)
  end
  self.background.accept.OnCursorExited = function(pnl)
    pnl:LerpColor("background", XeninUI.Theme.Green)
    pnl:Lerp("alpha", 0)
  end
  self.background.accept.DoClick = function(pnl)
    self:GetAccept()(pnl)
    self:Remove()
  end

  self.background.decline = self.background:Add("DButton")
  self.background.decline:SetText("Cancel")
  self.background.decline:SetFont("XeninUI.Query.Button")
  self.background.decline:SetTextColor(Color(145, 145, 145))
  self.background.decline.alpha = 0
  self.background.decline.background = XeninUI.Theme.Background
  self.background.decline.Paint = function(pnl, w, h)
    local x, y = pnl:LocalToScreen()

    BSHADOWS.BeginShadow()
    draw.RoundedBox(h * 0.5, x, y, w, h, XeninUI.Theme.Navbar)
    BSHADOWS.EndShadow(1, 1, 2, pnl.alpha, 0, 0)

    draw.RoundedBox(h * 0.5, 2, 2, w - 4, h - 4, pnl.background)
  end
  self.background.decline.OnCursorEntered = function(pnl)
    pnl:LerpColor("background", XeninUI.Theme.Navbar)
    pnl:Lerp("alpha", 200)
  end
  self.background.decline.OnCursorExited = function(pnl)
    pnl:LerpColor("background", XeninUI.Theme.Background)
    pnl:Lerp("alpha", 0)
  end
  self.background.decline.DoClick = function(pnl)
    self:GetDecline()(pnl)
    self:Remove()
  end
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)

  local y = 40
  self.background.avatar:SetPos(16, y + 16)
  self.background.avatar:SetSize(48, 48)

  self.background.name:SetPos(16 + self.background.avatar:GetWide() + 8, y + 16 + 2)
  self.background.name:SizeToContents()

  self.background.sid64:SetPos(14 + self.background.avatar:GetWide() + 8, y + 16 + 24 + 2)
  self.background.sid64:SizeToContentsY()
  self.background.sid64:SetWide(155)

  y = y + self.background.avatar:GetTall() + 40

  self.background.display:SetSize(64, 64)
  self.background.display:SetPos(16, y)

  self.background.string:SetPos(8 + 64 + 16, y)
  self.background.string:SetWide(self.background:GetWide() - 16 - 64)
  self.background.string:SizeToContentsY()

  self.background.accept:SizeToContentsY(16)
  self.background.decline:SizeToContentsY(16)
  self.background.accept:SetWide(self.background:GetWide() * 0.5 - 16 - 8)
  self.background.decline:SetWide(self.background:GetWide() * 0.5 - 16 - 8)

  local y = self.background:GetTall() - self.background.accept:GetTall() - 16

  self.background.accept:SetPos(16, y)
  self.background.decline:SetPos(self.background:GetWide() * 0.5 + 8, y)
end

vgui.Register("XeninUI.PurchaseConfirmation", PANEL, "XeninUI.Popup")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/query.lua:
local PANEL = {}

AccessorFunc(PANEL, "custom_width", "CustomWidth", FORCE_NUMBER)

XeninUI:CreateFont("XeninUI.Query.Text", 18)
XeninUI:CreateFont("XeninUI.Query.Button", 18)
XeninUI:CreateFont("XeninUI.Query.Option", 20)

function PANEL:Init()
  self.onAccept = function() end
  self.onDecline = function() end

  self.background.text = self.background:Add("DLabel")
  self.background.text:SetText("XD")
  self.background.text:SetFont("XeninUI.Query.Text")
  self.background.text:SetContentAlignment(8)
  self.background.text:SetTextColor(Color(200, 200, 200))

  self.background.input = self.background:Add("XeninUI.TextEntry")
  self.background.input:SetVisible(false)

  self.background.option = self.background:Add("DButton")
  self.background.option:SetVisible(false)
  self.background.option:SetText("")
  self.background.option.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, XeninUI.Theme.Navbar)

    local text = pnl.Text or "None Selected"
    XeninUI:DrawShadowText(text, "XeninUI.Query.Option", w * 0.5, h * 0.5, Color(184, 184, 184), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, 150)
  end
  self.background.option.DoClick = function(pnl)
    if IsValid(pnl.Dropdown) then return end

    pnl.Dropdown = vgui.Create("XeninUI.PlayerDropdown")
    pnl.Dropdown:SetParentPanel(pnl)
    pnl.Dropdown:SetData(self.optionData)
    pnl.Dropdown:SetDrawOnTop(true)
    local x, y = pnl:LocalToScreen()
    pnl.Dropdown:SetPos(x, y + pnl:GetTall())
    pnl.Dropdown:MakePopup()
    pnl.Dropdown.OnSelected = function(dropdown, sid64)

      if (!sid64) then return end
      local ply = player.GetBySteamID64(sid64)
      pnl.Text = ply:Nick()

      self.background.option.sid64 = sid64
    end
  end
  self.background.option.OnRemove = function(pnl)
    if IsValid(pnl.Dropdown) then
      pnl.Dropdown:Remove()
    end
  end

  self.background.accept = self.background:Add("DButton")
  self.background.accept:SetText("Accept")
  self.background.accept:SetFont("XeninUI.Query.Button")
  self.background.accept:SetTextColor(Color(21, 21, 21))
  self.background.accept.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, XeninUI.Theme.Green)
  end
  self.background.accept.DoClick = function(pnl)
    self:onAccept(pnl, self.background.input:GetText(), self.background.option.sid64)
    self:Remove()
  end

  self.background.decline = self.background:Add("DButton")
  self.background.decline:SetText("Decline")
  self.background.decline:SetFont("XeninUI.Query.Button")
  self.background.decline:SetTextColor(Color(145, 145, 145))
  self.background.decline.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, XeninUI.Theme.Navbar)
    draw.RoundedBox(6, 2, 2, w - 4, h - 4, XeninUI.Theme.Background)
  end
  self.background.decline.DoClick = function(pnl)
    self:onDecline(pnl, self.background.input:GetText(), self.background.option.sid64)
    self:Remove()
  end
end

function PANEL:PerformLayout(w, h)
  if (!self:GetCustomWidth()) then
    surface.SetFont(self.background.text:GetFont())
    local tw = surface.GetTextSize(self.background.text:GetText())
    self:SetBackgroundWidth(tw + 32)
  else
    self:SetBackgroundWidth(self:GetCustomWidth())
  end

  self.BaseClass.PerformLayout(self, w, h)

  self.background.text:SetWide(self.background:GetWide())
  self.background.text:SizeToContentsY()
  self.background.text:SetPos(0, 56)

  self.background.accept:SizeToContentsX(32)
  self.background.accept:SizeToContentsY(16)
  self.background.decline:SizeToContentsX(32)
  self.background.decline:SizeToContentsY(16)

  if self.background.input:IsVisible() then
    self.background.input:SetSize(math.max(self.background.accept:GetWide() + self.background.decline:GetWide() + 8, self.background:GetWide() * 0.75), 32)
    self.background.input:SetPos(0, 88)
    self.background.input:CenterHorizontal()
  end

  if self.background.option:IsVisible() then
    self.background.option:SetSize(math.max(self.background.accept:GetWide() + self.background.decline:GetWide() + 8, self.background:GetWide() * 0.75), 32)

    local inputVisible = self.background.input:IsVisible()
    self.background.option:SetPos(0, 88 + (inputVisible and 44 or 0))
    self.background.option:CenterHorizontal()
  end

  local y = self.background:GetTall() - self.background.accept:GetTall() - 16
  self.background.accept:SetPos(self.background:GetWide() * 0.5 - self.background.accept:GetWide() * 0.5 - self.background.decline:GetWide() * 0.5 - 4, y)
  self.background.decline:SetPos(self.background:GetWide() * 0.5 + self.background.accept:GetWide() * 0.5 - self.background.decline:GetWide() * 0.5 + 4, y)
end

function PANEL:SetInput(str, placeholder, numeric)
  self.background.input:SetVisible(true)
  self.background.input:SetText(str)
  self.background.input:SetPlaceholder(placeholder)
  self.background.input.textentry:SetNumeric(numeric)
end

function PANEL:SetOption(tbl)
  self.background.option:SetVisible(true)
  self.optionData = tbl
end

function PANEL:SetText(text)
  self.background.text:SetText(text)
end

function PANEL:SetAccept(text, func)
  self.background.accept:SetText(text)
  self.onAccept = func
end

function PANEL:SetDecline(text, func)
  self.background.decline:SetText(text)
  self.onDecline = func
end

vgui.Register("XeninUI.Query", PANEL, "XeninUI.Popup")

function XeninUI:SimpleQuery(title, text, yesText, yesFunc, noText, noFunc)
  local queryMenu = vgui.Create("XeninUI.Query")
  queryMenu:SetSize(ScrW(), ScrH())
  queryMenu:SetBackgroundHeight(140)

  queryMenu:SetTitle(title or "Title")
  queryMenu:SetText(text or "Text")

  queryMenu:SetAccept(yesText or "Yes", yesFunc or (function() end))
  queryMenu:SetDecline(noText or "No", noFunc or (function() end))

  queryMenu:MakePopup()

  return queryMenu
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/core/ui/tab.lua:
XeninUI:CreateFont("Xenin.Framework.Config.Container.Name", 24)
XeninUI:CreateFont("Xenin.Framework.Config.Container.Desc", 18)
XeninUI:CreateFont("Xenin.Framework.Config.Tabs", 26)

local PANEL = {}

function PANEL:Init()
  self.Name = "No Name"

  self:DockMargin(0, 0, 8, 0)

  self.Text = self:Add("DPanel")
  self.Text:Dock(TOP)
  self.Text.Offset = draw.GetFontHeight("Xenin.Framework.Config.Container.Name") + 4
  self.Text.Paint = function(pnl, w, h)
    XeninUI:DrawShadowText(self.Name, "Xenin.Framework.Config.Container.Name", 0, 0, Color(231, 232, 235), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 150)
    XeninUI:DrawShadowText(self.Desc, "Xenin.Framework.Config.Container.Desc", 0, pnl.Offset, Color(156, 156, 156), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 150)
  end
  self.Text:SetTall(50)
end

function PANEL:Paint(w, h)
  draw.RoundedBox(6, 0, 0, w, h, XeninUI.Theme.Primary)
end

function PANEL:SetName(name)
  self.Name = name
end

function PANEL:SetDesc(desc)
  self.Desc = desc
end

function PANEL:PerformLayout(w, h) end

vgui.Register("Xenin.Framework.Config.Container", PANEL, "XeninUI.Panel")

local PANEL = {}

XeninUI:CreateFont("Xenin.Framework.Category", 22)

function PANEL:SetData(data, scriptId)
  self.Data = data
  self.Panels = {}
  self.Cats = {}

  self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)

  self.Tabs = self:Add("XeninUI.NavbarBody")
  self.Tabs:Dock(TOP)
  self.Tabs:DockMargin(-6, 0, -12, 8)
  self.Tabs:SetTall(32)
  self.Tabs:SetBody(self.Scroll)
  self.Tabs.Margin = 12

  self.Save = self:Add("XeninUI.ButtonV2")
  self.Save:SetVisible(false)
  self.Save:SetText("Save")
  self.Save:SetGradient(false)
  self.Save:SetSolidColor(XeninUI.Theme.GreenDark)
  self.Save.DoClick = function(pnl)
    local config = {}
    for i, v in pairs(self.Panels) do
      config[i] = v:GetValue()
    end
    for i, v in pairs(self.Cats) do
      config[i] = {}
    end

    XeninUI.Config:save(scriptId, config)
  end

  self:PostInit()
end

function PANEL:UpdateSaveVisibility()
  local difference
  local function recursiveCheck(tbl)
    for i, v in ipairs(tbl) do
      if (!v.children) then
        if (v.value != self.Panels[v.key]:GetValue()) then
          difference = true

          break
        end

        continue
      end

      recursiveCheck(v.children)
    end
  end

  for i, v in ipairs(self.Data) do
    recursiveCheck(v.children)
  end

  self.Save:SetVisible(difference)
  if difference then
    self:InvalidateLayout()
  end
end

function PANEL:PostInit()
  self:CreateConfigRecursive(self.Data)
end

PANEL.Types = {
  cat = function(self, tbl, parent)





    self.Tabs:AddTab(tbl.name, "Panel", {
    fill = TOP })
    local panel = self.Tabs.Tabs[#self.Tabs.Tabs].Panel
    panel:DockMargin(0, 0, 0, 8)
    self.Tabs:SetActive(1)

    self:CreateConfigRecursive(tbl.children, panel)

    return panel
  end,
  textentry = function(self, tbl, parent)
    local panel = parent:Add("Xenin.Framework.Config.Container")
    panel:Dock(TOP)
    panel:DockMargin(0, 0, 8, 8)
    panel:SetName(tbl.name)
    panel:SetDesc(tbl.desc)
    panel:SetTall(104)
    panel.GetValue = function(pnl)
      return panel.Content:GetText()
    end
    panel:DockPadding(8, 6, 8, 8)

    panel.Content = panel:Add("XeninUI.TextEntry")
    panel.Content:Dock(FILL)
    panel.Content:DockMargin(0, 4, 0, 0)
    panel.Content:SetText(XeninUI.Config:get(tbl.key) or tbl.value)
    panel.Content.textentry:SetUpdateOnType(true)
    panel.Content.textentry.OnValueChange = function(pnl, w, h)
      self:UpdateSaveVisibility()
    end

    if tbl.numeric then
      panel.Content.textentry:SetNumeric(true)
    end

    return panel
  end,
  checkbox = function(self, tbl, parent)
    local panel = parent:Add("Xenin.Framework.Config.Container")
    panel:Dock(TOP)
    panel:DockMargin(0, 0, 8, 8)
    panel:SetName(tbl.name)
    panel:SetDesc(tbl.desc)
    panel:SetTall(104)
    panel.GetValue = function(pnl)
      return panel.Content:GetState()
    end
    panel:DockPadding(8, 6, 8, 8)

    panel.Content = panel:Add("XeninUI.Checkbox")
    panel.Content:Dock(LEFT)
    panel.Content:DockMargin(0, 4, 0, 0)
    panel.Content:SetWide(100)
    panel.Content:SetState(tbl.value, true)
    panel.Content.OnStateChanged = function()
      self:UpdateSaveVisibility()
    end

    return panel
  end
}

function PANEL:CreateConfigRecursive(tbl, parent)
  if parent == nil then parent = self.Scroll
  end
  for i, v in ipairs(tbl) do
    local panel = self.Types[v.type](self, v, parent)
    if (v.type == "cat") then
      self.Cats[v.key] = v

      continue
    end

    self.Panels[v.key] = panel
  end
end

function PANEL:PerformLayout(w, h)
  self.Save:AlignRight(24)
  self.Save:AlignBottom(8)
  self.Save:SizeToContentsX(24)
  self.Save:SizeToContentsY(8)
  self.Save:SetRoundness(self.Save:GetTall() * 0.5)

  for i, v in ipairs(self.Tabs.Tabs) do
    local pnl = v.Panel
    local h = 0
    for i, v in ipairs(pnl:GetChildren()) do
      h = h + v:GetTall()
      local l, t, b, r = v:GetDockMargin()
      h = h + (t + b)
    end

    pnl:SetTall(h)
  end
end

vgui.Register("Xenin.Framework.Config", PANEL, "XeninUI.Panel")

local PANEL = {}

XeninUI:CreateFont("Xenin.Framework.Title", 26)
XeninUI:CreateFont("Xenin.Framework.Subtitle", 18)

function PANEL:OnSwitchedTo()
  if self.HaveSwitchedTo then return end

  self.HaveSwitchedTo = true
  self:PostInit()
end

function PANEL:PostInit()
  self:DockPadding(16, 16, 16, 16)

  local __lauxi0 = self.Data
  assert(__lauxi0 ~= nil, "cannot destructure nil value")
  local version, author, config, id, licensee, licenseeProof = __lauxi0.version, __lauxi0.author, __lauxi0.config, __lauxi0.id, __lauxi0.licensee, __lauxi0.licenseeProof
  local titleHeight = draw.GetFontHeight("Xenin.Framework.Title")
  local versionStr = version == "{{ script_version_name }}" and "DEV BUILD" or version
  self.Info = self:Add("DPanel")
  self.Info:Dock(TOP)
  self.Info:SetTall(48)
  self.Info.Paint = function(pnl, w, h)
    XeninUI:DrawShadowText("Version " .. tostring(versionStr), "Xenin.Framework.Title", 0, 0, color_white, nil, nil, 1, 150)
    XeninUI:DrawShadowText("Author: " .. tostring(author), "Xenin.Framework.Subtitle", 0, titleHeight, Color(183, 183, 183), nil, nil, 1, 150)
  end

  self.Tabs = self:Add("XeninUI.NavbarBody")
  self.Tabs:Dock(TOP)
  self.Tabs:DockMargin(-12, 8, -12, 0)
  self.Tabs:SetTall(40)
  self.Tabs.Font = "Xenin.Framework.Config.Tabs"
  self.Tabs:SetBody(self)
  if XeninUI.Debug then
    self.Tabs:AddTab("Updates")
    self.Tabs:AddTab("Config", "Xenin.Framework.Config", config, id)
    self.Tabs:SetActive(2)
  else
    self.Tabs:AddTab("License", "Xenin.Framework.Dev", {
      licensee = licensee,
      proof = licenseeProof
    })
    self.Tabs:SetActive(1)
  end
end

vgui.Register("Xenin.Framework.Tab", PANEL)

local PANEL = {}

XeninUI:CreateFont("Xenin.Framework.Dev.Licensee", 48)
XeninUI:CreateFont("Xenin.Framework.Dev", 20)

function PANEL:Paint(w, h)
  XeninUI:DrawShadowText("Licensed to " .. tostring(self.licensee), "Xenin.Framework.Dev.Licensee", w * 0.5, 16, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, 150)
  XeninUI:DrawShadowText("Proof: " .. tostring(self.proof), "Xenin.Framework.Dev", w * 0.5, 16 + draw.GetFontHeight("Xenin.Framework.Dev.Licensee") + 4, Color(242, 242, 242), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, 150)
  XeninUI:DrawShadowText("This menu is currently in development, check back later", "Xenin.Framework.Dev", w * 0.5, h * 0.5, Color(183, 183, 183), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, 150)
end

function PANEL:SetData(data)
  self.licensee = data.licensee
  self.proof = data.proof
end

vgui.Register("Xenin.Framework.Dev", PANEL)

local PANEL = {}
XeninUI:CreateFont("XeninUI.NavbarBody", 18)
AccessorFunc(PANEL, "m_body", "Body")

function PANEL:Init()
  self.Tabs = {}
  self.Options = {}

  self.Line = self:Add("DPanel")
  self.Line:SetMouseInputEnabled(false)
  self.Line:SetTall(2)
  self.Line.x = 12
  self.Line.Paint = function(pnl, w, h)
    surface.SetDrawColor(XeninUI.Theme.Accent)
    surface.DrawRect(0, 0, w, h)
  end
end

function PANEL:PerformLayout(w, h)
  self.Line:SetPos(self.Line.x, h - 2)
end

function PANEL:SetActive(id)
  if IsValid(self.Tabs[self.Active]) then
    self.Tabs[self.Active]:LerpColor("TextColor", Color(183, 183, 183))
    self.Tabs[self.Active].Panel:SetVisible(false)
  end

  self.Active = id

  if IsValid(self.Tabs[self.Active]) then
    local margin = self.Margin or 24
    local x = margin * 0.5
    for i = 1, id - 1 do
      x = x + self.Tabs[i]:GetWide()
    end

    self.Line:LerpMoveX(x, 0.3)
    self.Line:LerpWidth(self.Tabs[id]:GetWide() - margin, 0.3)

    self.Tabs[self.Active]:LerpColor("TextColor", color_white)
    self.Tabs[self.Active].Panel:SetVisible(true)
  end
end

function PANEL:SetOptions(options)
  self.Options = options
end

function PANEL:AddTab(name, panelClass, data, scriptId)
  if data == nil then data = {}
  end
  if scriptId == nil then scriptId = "none"
  end
  local margin = self.Margin or 24
  local btn = self:Add("DButton")
  btn:Dock(LEFT)
  btn:SetText(self.Options.upper and name:upper() or name)
  btn:SetFont(self.Font or "XeninUI.NavbarBody")
  btn:SizeToContentsX(margin)
  btn:SizeToContentsY()
  btn.TextColor = Color(183, 183, 183)
  btn.Paint = function(pnl, w, h)
    pnl:SetTextColor(pnl.TextColor)
  end
  btn.DoClick = function(pnl)
    self:SetActive(pnl.Id)
  end

  local id = table.insert(self.Tabs, btn)
  self.Tabs[id].Id = id

  if (id == 1) then
    self.Line:SetWide(btn:GetWide() - margin)
  end

  local panel = self:GetBody():Add(panelClass or "XeninUI.Panel")
  panel:Dock(data.fill or FILL)
  panel:SetVisible(false)
  if panel.SetData then
    panel:SetData(data, scriptId)
  end

  btn.Panel = panel
end

vgui.Register("XeninUI.NavbarBody", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/units/classes/test.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Units.Test",
    addSpec = function(self, name, func, args)
      table.insert(self.specs, XeninUI.Units.Spec(name, func))

      return self
    end,
    runSpecFunc = function(self, spec)
      local p = XeninUI.Promises.new()

      local success, returnVal = xpcall(spec:getFunc(), debug.traceback, self)
      local result = XeninUI.Units.Result(spec:getName(), success, returnVal)

      if result:isSuccess() then
        if istable(result:getReturn()) then
          result:getReturn():next(function()
            p:resolve(result:getMessagePrint())
          end, function(err)
            result:setSuccess(false)
            result:setError(err or "Promise failedd")
            p:reject(result:getMessagePrint())
          end)
        else
          p:resolve(result:getMessagePrint())
        end
      else
        p:reject(result:getMessagePrint())
      end

      return p
    end,
    setBeforeAll = function(self, func)
      self.beforeAll = func return self end,
    setBeforeEach = function(self, func)
      self.beforeEach = func return self end,
    setAfterEach = function(self, func)
      self.afterEach = func return self end,
    setAfterAll = function(self, func)
      self.afterAll = func return self end,
    finishedTests = function(self, dontPrint)
      if (!dontPrint) then
        for i, v in ipairs(self.msgs) do
          table.insert(v, "\n")
          MsgC(unpack(v))
        end
      end
    end,
    run = function(self, dontPrint)
      self.msgs = {
      {
        Color(255, 255, 255),
        tostring(self.name) .. " should:"
      }
      }

      local p = XeninUI.Promises.new()

      local start = SysTime()
      local errors = 0
      local successes = 0
      local size = #self.specs
      local i = 1
      local function nextFunc()
        self:afterEach()
        i = i + 1
      end
      local function runTest()
        if (i > size) then
          self:afterAll()
          self:finishedTests()

          local ms = math.Round((SysTime() - start) * 1000, 2)
          p:resolve({
            msgs = self.msgs,
            executionTime = ms,
            size = size,
            errors = errors,
            successes = successes
          })
        end

        local tbl = self.specs[i]
        self:beforeEach()
        self:runSpecFunc(tbl):next(function(result)
          successes = successes + 1

          table.insert(self.msgs, result)

          nextFunc()
          runTest()
        end, function(err)
          errors = errors + 1

          table.insert(self.msgs, err)

          nextFunc()
          runTest()
        end)
      end

      local err = self:beforeAll()
      if istable(err) then

        err:next(function()
          runTest()
        end, function(err)
          p:reject(err)
        end)
      else
        if err then
          return p:reject(err)
        end
        runTest()
      end

      return p
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, name)
      self.specs = {}
      self.name = name
      self.beforeAll = function() end
      self.beforeEach = function() end
      self.afterEach = function() end
      self.afterAll = function() end
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Units.Test = _class_0
end

function XeninUI:Test(script, printOut, delay)
  if printOut == nil then printOut = true
  end
  local p = XeninUI.Promises.new()
  local tbl = XeninUI.Scripts:get(script)
  if (!tbl) then
    if printOut then MsgC(XeninUI.Theme.Red, "That script doesn't exist\n")end

    return p:reject("That script doesn't exist")
  end
  local tests = tbl.tests
  if (!istable(tests) or (istable(tests) and #tests == 0)) then
    if print then MsgC(XeninUI.Theme.Red, "There are no tests for this script\n")end

    return p:reject("There are no tests for this script")
  end

  XeninUI.IsTesting = script
  local i = 0
  local time = 0
  local passes = 0
  local fails = 0
  local size = 0
  local msgs = {}
  local function nextTest()
    i = i + 1

    local promise = tests[i]
    if (!promise) then
      local successRate = math.Round((passes / size) * 100, 2)
      if printOut then
        MsgC(XeninUI.Theme.Yellow, "Took " .. tostring(time) .. "ms to run " .. tostring(size) .. " specs with " .. tostring(passes) .. " passes, " .. tostring(fails) .. " fails, and a pass rate of " .. tostring(successRate) .. "%\n")
      end

      p:resolve({
        time = time,
        passes = passes,
        fails = fails,
        size = size,
        msgs = msgs
      })

      XeninUI.IsTesting = nil
    else
      promise:run():next(function(result)
        time = time + result.executionTime
        passes = passes + result.successes
        fails = fails + result.errors
        size = size + result.size

        table.insert(msgs, result.msgs)

        if delay then
          timer.Simple(delay, function()
            nextTest()end)
        else
          nextTest()
        end
      end, function(err)
        print("test error", err)
        p:reject(err)
      end)
    end
  end

  nextTest()

  return p
end

concommand.Add("xenin_test", function(ply, cmd, args)
  if (IsValid(ply) and !XeninUI.Permissions:canAccessFramework(ply)) then return end

  XeninUI:Test(args[1], !tobool(args[2]), tonumber(args[3])):next(function(result) end, function(err)
    ErrorNoHalt(err .. "\n")end)
end)

--PATH addons/battlepass/lua/battlepass/challenges/prodai_15_licenziy_buduchi_merom.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Продай 15 ліцензій будучи мером")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("prodai_15_licenziy_buduchi_merom")

CHALLENGE:AddHook("playerGiveLicenseBP", function(self, ply, _ply)
  if IsValid( _ply ) and ply == _ply then
    self:AddProgress(1)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/battlepass/lua/battlepass/challenges/umeret_3_raz_ot_goloda.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Померти 3 раз від голоду")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("umeret_3_raz_ot_goloda")
CHALLENGE:SetPremium(true)

CHALLENGE:AddHook("playerKillHunger", function(self, ply, _ply)
  if IsValid( _ply ) and ply == _ply and _ply.BattlePass.Owned.owned then
    self:AddProgress(1)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/battlepass/lua/battlepass/rewards/unbox.lua:
local REWARD = BATTLEPASS:CreateReward()

function REWARD:CanUnlock(ply, reward, amount)
  return true
end

function REWARD:GetTooltip(reward)
  return self:GetName(reward)
end

local materialid = BATTLEPASS.Materials

function REWARD:GetModel(reward)
  if not BUC2 then return materialid.case end
  local tbl = BUC2.ITEMS[reward]
  if not tbl then return materialid.case end
  if tbl.customicon ~= nil then
    return tbl.customicon
  end

  return materialid.case
end

function REWARD:GetName(reward, amount)
  amount = amount or 1
  if not BUC2 then return 'Unknown' end
  local tbl = BUC2.ITEMS[reward]
  if not tbl then return "Unknown name" end
  if amount > 1 then return amount .. "x " .. tbl.name1 end

  return tbl.name1
end

function REWARD:Unlock(ply, reward, amount)
  if CLIENT then return end
  amount = amount or 1

  for i = 1, amount do
    ply:ub_addItem(reward, true)
  end

  ply:ub_saveInventory()
  ply:ub_update_client()
end

REWARD:Register("unbox")
--PATH addons/battlepass/lua/battlepass/menu/battlepass.lua:
local PANEL = {}
function PANEL:GetBattlePass()
  return self.battlePass
end

local materialid = BATTLEPASS.Materials
local colorid = BATTLEPASS.Colors
local col1 = ColorAlpha(color_white, 100)
function PANEL:Init()
  local ply = LocalPlayer()
  self.BP = BATTLEPASS.Pass
  self.Tiers = BATTLEPASS.Pass.tiers
  self.AmountOfItems = 0
  self.allrecument = 0
  self.Sections = math.ceil(self.Tiers / 10)
  self.CurrentTier = 6
  self.TierRequirement = 10
  self.PageSize = self:GetParent().PageSize or 4
  self.UnlockedTiers = ply.BattlePass.Owned.tier
  self.Title = vgui.Create("DPanel", self)
  self.Title:SizeToContents()
  self.Title.Paint = function(s, w, h)
    draw.Icon(0, 0, W(64), H(248), materialid.freepropusk)
    draw.Icon(0, H(283), W(64), H(248), materialid.premiumpropusk)
  end

  self.Left = self.Title:Add("DButton")
  self.Left:SetText("")
  self.Left.alpha = 100
  self.Left.nonactive = true
  self.Left.Paint = function(pnl, w, h)
    pnl.lerp = Lerp(FrameTime() * 5, pnl.lerp or 255, pnl.alpha)
    draw.RoundedBoxEx(8, 0, 0, w, h, ColorAlpha(colorid.yellow, pnl.lerp), true, false, true, false)
    draw.SimpleText('◂', 'font_number', w * 0.5, h * 0.5 - H(1), color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  end

  self.Left.DoClick = function(pnl)
    if pnl.nonactive then return end
    if self.CurrentPage <= 1 then return end
    self.CurrentPage = self.CurrentPage - 1
    if self.Right.nonactive then
      self.Right.nonactive = false
      self.Right.alpha = 255
    end

    self:PopulatePage()
    self:InvalidateLayout()
    self.allrecument = 0
    for i = 1, self.PageSize do
      local page = self.PageSize * (self.CurrentPage - 1) + i
      self.allrecument = self.allrecument + (self.UnlockedTiers > page and 1 or self.UnlockedTiers == page and 0.5 or 0)
    end

    if self.CurrentPage <= 1 then
      pnl.nonactive = true
      pnl.alpha = 100
    end
  end

  self.Right = self.Title:Add("DButton")
  self.Right:SetText("")
  self.Right.alpha = 255
  self.Right.Paint = function(pnl, w, h)
    pnl.lerp = Lerp(FrameTime() * 5, pnl.lerp or 255, pnl.alpha)
    draw.RoundedBoxEx(8, 0, 0, w, h, ColorAlpha(colorid.yellow, pnl.lerp), false, true, false, true)
    draw.SimpleText('▸', 'font_number', w * 0.5, h * 0.5 - H(1), color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  end

  self.Right.DoClick = function(pnl)
    if pnl.nonactive then return end
    if self.CurrentPage >= self.Pages then return end
    self.CurrentPage = self.CurrentPage + 1
    if self.Left.nonactive then
      self.Left.nonactive = false
      self.Left.alpha = 255
    end

    self:PopulatePage()
    self.allrecument = 0
    for i = 1, self.PageSize do
      local page = self.PageSize * (self.CurrentPage - 1) + i
      self.allrecument = self.allrecument + (self.UnlockedTiers > page and 1 or self.UnlockedTiers == page and 0.5 or 0)
    end

    self:InvalidateLayout()
    if self.CurrentPage >= self.Pages then
      pnl.nonactive = true
      pnl.alpha = 100
    end
  end

  self.Pages = math.ceil(self.Tiers / self.PageSize)
  self.Page = vgui.Create("Panel", self.Title)
  self.Page.Paint = function(s, w, h)
    draw.RoundedBox(0, W(3), H(265), W(794), H(6), ColorAlpha(color_white, 5))
    draw.RoundedBox(0, W(3), H(265), W(198.5) * self.allrecument, H(6), colorid.salat)
    for i = 1, 3 do
      draw.RoundedBox(0, W(200) * i, H(258), W(1), H(20), colorid.salat)
    end
  end

  self.Page.Panels = {}
  self.CurrentPage = 1
  for i = 1, self.PageSize do
    local page = self.PageSize * (self.CurrentPage - 1) + i
    local panel = vgui.Create("Panel", self.Page)
    panel.Paint = function(s, w, h)
      s.Page = self.PageSize * (self.CurrentPage - 1) + i
      draw.SimpleTextOutlined( s.Page, 'font_numberslot', w * 0.5, h * 0.5 + 3, colorid.zoloto1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1.4, colorid.zoloto2 )
    end

    panel.Free = vgui.Create("Panel", panel)
    panel.Free.Dragging = 0
    panel.Free.Unlocked = self.UnlockedTiers >= page and 0 or 1
    panel.Free.colbg = ColorAlpha(color_white, 100)
    panel.Free.Paint = function(pnl, w, h)
      local itm = panel.Page
      local getitm = self.BP.rewards.free[itm]
      local page = self.PageSize * (self.CurrentPage - 1) + i
      if page > BATTLEPASS.Pass.tiers then return end
      pnl.txt = 'Отримано'
      --pnl.txt2 = 'オープン'
      pnl.col = colorid.orange
      --pnl.col2 = color_white
      local unlocked = self.UnlockedTiers >= page
      if not unlocked then
        pnl.txt = 'Закритий'
        --pnl.txt2 = 'クローズド'
        pnl.col = col1
        --pnl.col2 = col1
      end

      if getitm == nil then
        pnl.txt = ''
        --pnl.txt2 = ''
      end

      if getitm ~= nil and (not ply.BattlePass.ClaimedItems or not ply.BattlePass.ClaimedItems[itm] or not ply.BattlePass.ClaimedItems[itm].free or not isbool(ply.BattlePass.ClaimedItems[itm].free) and not ply.BattlePass.ClaimedItems[itm].free[index]) then draw.Icon(0, 0, w, h, materialid.bpoverhail, pnl.colbg) end
      draw.SimpleText(pnl.txt, 'font_bplevelmini', w * 0.5, H(214), pnl.col, 1, 1)
      --draw.DrawText(pnl.txt2, 'font_bplevelmini', W(12), H(12), pnl.col2)
    end

    panel.Free.Items = {}
    panel.Premium = vgui.Create("Panel", panel)
    panel.Premium.Dragging = 0
    panel.Premium.Unlocked = (self.UnlockedTiers >= page and self.OwnsBattlePass) and 1 or 0
    panel.Premium.colbg = ColorAlpha(color_white, 100)
    panel.Premium.Paint = function(pnl, w, h)
      local itm = panel.Page
      local getitm = self.BP.rewards.premium[itm]
      local page = self.PageSize * (self.CurrentPage - 1) + i
      if page > BATTLEPASS.Pass.tiers then return end
      pnl.txt = 'Отримати'
      --pnl.txt2 = 'オープン'
      pnl.col = colorid.orange
      --pnl.col2 = color_white
      local unlocked = self.UnlockedTiers >= page and ply.BattlePass.Owned.owned
      if not unlocked then
        pnl.txt = 'Закритий'
        --pnl.txt2 = 'クローズド'
        pnl.col = col1
        --pnl.col2 = col1
      end

      if getitm == nil then
        pnl.txt = ''
        --pnl.txt2 = ''
      end

      if getitm ~= nil and (not ply.BattlePass.ClaimedItems or not ply.BattlePass.ClaimedItems[itm] or not ply.BattlePass.ClaimedItems[itm].premium or not isbool(ply.BattlePass.ClaimedItems[itm].premium) and not ply.BattlePass.ClaimedItems[itm].premium[index]) then draw.Icon(0, 0, w, h, materialid.bpoverhail, pnl.colbg) end
      draw.SimpleText(pnl.txt, 'font_bplevelmini', w * 0.5, H(214), pnl.col, 1, 1)
      --draw.DrawText(pnl.txt2, 'font_bplevelmini', W(12), H(12), pnl.col2)
    end

    panel.Premium.Items = {}
    panel.PerformLayout = function(pnl, w, h)
      pnl.Free:SetSize(w, H(248))
      pnl.Premium:SetSize(w, H(248))
      pnl.Free:SetPos(0, 0)
      pnl.Premium:SetPos(0, h - H(248))
    end

    self.allrecument = self.allrecument + (self.UnlockedTiers > page and 1 or self.UnlockedTiers == page and 0.5 or 0)
    table.insert(self.Page.Panels, panel)
  end

  self.Page.PerformLayout = function(pnl, w, h)
    local x = 4
    local width = (w - 4 - (4 * self.PageSize)) / self.PageSize
    for i, v in ipairs(self.Page.Panels) do
      v:SetPos(x, 0)
      v:SetSize(W(192), H(531))
      x = x + width + 4
    end

    if not pnl.HasPerformedLayout then
      self:PopulatePage()
      pnl.HasPerformedLayout = true
    end
  end

  self:AddHook("BATTLEPASS.Purchased", "Menu", function(self)
    self:SetOwned(true)
    self:InvalidateLayout()
  end)

  self:AddHook("BATTLEPASS.Removed", "Menu", function(self)
    self:SetOwned(false)
    self:InvalidateLayout()
  end)

  self:Reload()
end

function PANEL:CreateItem(tbl, premium, index, passIndex)
  local ply = LocalPlayer()
  local rewardTbl = BATTLEPASS.Rewards[tbl.Type]
  if not rewardTbl then return end
  local Two = tbl.Two or false
  local reward = tbl.Reward
  local model = tbl.Display or rewardTbl:GetModel(reward)
  local color = tbl.Color or rewardTbl:GetColor(reward)
  local name = tbl.Name or rewardTbl:GetName(reward, tbl.Amount)
  local customPnl = rewardTbl:GetCustomPanel(reward)
  local postDisplayFunc = rewardTbl.GetPostDisplay
  if IsValid(customPnl) then self.OnRemove = function(pnl) customPnl:Remove() end end
  color = {
    background = color,
    outline = Color(color.r - 10, color.g - 10, color.b - 10)
  }

  local panel = vgui.Create("DPanel")
  panel:SetText("")
  panel.Background = color.background
  panel.Outline = color.outline
  panel.Hover = 0
  panel.Dragging = 0
  panel.BackgroundColor = Color(41, 41, 41, 160)
  panel.TextColor = color_white
  panel.HoverColor = color_white
  panel.DraggingColor = color_white
  panel.AmountTextColor = color_white
  panel.Two = Two
  panel.Paint = function(pnl, w, h) draw.SimpleText(name or "", 'font_bpnameD', w * 0.5, h / 1.26, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) end
  if isfunction(postDisplayFunc) then postDisplayFunc(rewardTbl, panel, reward, tbl.Amount) end
  local claimed
  if ply.BattlePass.ClaimedItems then
    if not premium then
      claimed = ply.BattlePass.ClaimedItems[passIndex].free
    else
      claimed = ply.BattlePass.ClaimedItems[passIndex].premium[index]
    end
  end

  if premium and not ply.BattlePass.Owned.owned then claimed = true end
  if not premium and claimed or claimed and (premium and ply.BattlePass.Owned.owned) then
    panel.overlay = vgui.Create("DPanel", panel)
    panel.overlay:SetText("")
    panel.overlay:SetSize(W(192), H(248))
    panel.overlay.Paint = function(s, w, h)
      draw.Icon(0, 0, w, h, materialid.bpoverhailpremium, color_white)
      draw.SimpleText(name or "", 'font_bpnameD', w * 0.5, h / 1.26, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
      draw.SimpleText("Отримано", 'font_bplevelmini', w * 0.5, H(214), colorid.orange, 1, 1)
    end
  end

  if IsValid(customPnl) then
    panel.display = customPnl
    panel.display:SetParent(panel)
    panel.display:SetSize(W(300), W(148))
    panel.display:SetPos(W(22), H(28))
    panel.display:SetMouseInputEnabled(false)
    panel.display:DockMargin(1, 1, 1, 24)
    panel.display.MaterialColor = color_white
    panel.display.MaterialBackgroundColor = XeninUI.Theme.Red
    panel.display:PostInit()
    panel.display.Index = index
  else
    local ismodel = model:find(".mdl")
    panel.display = panel:Add(ismodel and "DModelPanel" or "Panel")
    panel.display:SetMouseInputEnabled(false)
    panel.display:DockMargin(1, 1, 1, 24)
    panel.display.MaterialColor = color_white
    panel.display.MaterialBackgroundColor = XeninUI.Theme.Red
    if ismodel then
      panel.display:SetModel(model)
      panel.display.LayoutEntity = function() end
      if panel.display.Entity then
        local mn, mx = panel.display.Entity:GetRenderBounds()
        local size = 0
        size = math.max(size, math.abs(mn.x) + math.abs(mx.x))
        size = math.max(size, math.abs(mn.y) + math.abs(mx.y))
        size = math.max(size, math.abs(mn.z) + math.abs(mx.z))
        panel.display:SetFOV(33)
        panel.display:SetCamPos(Vector(size, size + 30, size - 30))
        panel.display:SetLookAt((mn + mx) * 0.5)
      end
    else
      local mat = Material(model, "smooth")
      panel.display.Paint = function(pnl, w, h)
        surface.SetDrawColor(color_white)
        surface.SetMaterial(mat)
        surface.DrawTexturedRect(0, 0, w, h)
        if index ~= 1 then return end
      end
    end

    panel.display:SetSize(W(148), W(148))
    panel.display:SetPos(W(22), H(28))
  end

  if not claimed and ply.BattlePass.Owned.tier >= passIndex then
    panel.overlay = vgui.Create("DButton", panel)
    panel.overlay:SetText("")
    panel.overlay:SetSize(W(148), W(148))
    panel.overlay:SetPos(W(22), H(28))
    panel.overlay.Paint = nil
    panel.overlay.DoClick = function(pnl)
      BATTLEPASS:ClaimItem(ply, premium, passIndex, index)
      net.Start("BATTLEPASS.ClaimItem")
      net.WriteBool(premium)
      net.WriteUInt(passIndex, 8)
      net.WriteUInt(index, 2)
      net.SendToServer()
      pnl:Remove()
      panel.overlay = vgui.Create("DPanel", panel)
      panel.overlay:SetText("")
      panel.overlay:SetSize(W(192), H(248))
      panel.overlay.Paint = function(s, w, h)
        draw.Icon(0, 0, w, h, materialid.bpoverhailfree, color_white)
        draw.SimpleText(name or "", 'font_bpnameD', w * 0.5, h / 1.26, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText("Отримано", 'font_bplevelmini', w * 0.5, H(214), pnl.col, 1, 1)
      end
    end

    if tbl.tooltip then panel.overlay:AddBPTooltip(tbl.tooltip, 0.4) end
  end

  if not premium then
    panel.PerformLayout = function(pnl, w, h)
      local width = self.Page.Panels[1].Free:GetWide()
      pnl:SetSize(width, H(248))
      pnl:SetPos(0, 0)
    end
  else
    panel.PerformLayout = function(pnl, w, h)
      local width = self.Page.Panels[1].Premium:GetWide()
      pnl:SetSize(width, H(248))
      pnl:SetPos(0, 0)
    end
  end

  return panel
end

function PANEL:PopulatePage()
  local tbl = self.Page.Panels
  local bTbl = BATTLEPASS.Pass
  if not bTbl then return end
  local startLevel = self.PageSize * (self.CurrentPage - 1) + 1
  local endLevel = startLevel + (self.PageSize - 1)
  -- Makes the last page always (tiers - 7 to tiers) which might show (50 - 7 to 50) aka (43-50)
  startLevel = math.min(startLevel, math.max(1, bTbl.tiers))
  endLevel = math.min(endLevel, math.max(1, bTbl.tiers))
  local panelIndex = 1
  -- Temporary fix for not deleting items if the next page doesn't have as many items (say page 7 got 8 items, but page 8 got 2 items)
  for i = 1, self.PageSize do
    local panel = tbl[i]
    for i, v in pairs(panel.Free.Items) do
      v:Remove()
      panel.Free.Items[i] = nil
    end

    for i, v in pairs(panel.Premium.Items) do
      v:Remove()
      panel.Premium.Items[i] = nil
    end
  end

  for i = startLevel, startLevel + 7 do
    local panel = tbl[panelIndex]
    if not panel then panel = tbl[panelIndex - 1] end
    for i, v in pairs(panel.Free.Items) do
      v:Remove()
      panel.Free.Items[i] = nil
    end

    for i, v in pairs(panel.Premium.Items) do
      v:Remove()
      panel.Premium.Items[i] = nil
    end
  end

  for i = startLevel, endLevel do
    local free = bTbl.rewards.free[i]
    local premium = bTbl.rewards.premium[i]
    local panel = tbl[panelIndex]
    if not panel then panel = tbl[panelIndex - 1] end
    if not panel:IsVisible() and i <= self.Tiers then
      panel:SetVisible(true)
    elseif panel:IsVisible() and i > self.Tiers then
      panel:SetVisible(false)
    end

    for i, v in pairs(panel.Free.Items) do
      v:Remove()
      panel.Free.Items[i] = nil
    end

    for i, v in pairs(panel.Premium.Items) do
      v:Remove()
      panel.Premium.Items[i] = nil
    end

    if free then
      for k, v in pairs(free) do
        local pnl = self:CreateItem(v, nil, k, i)
        if not IsValid(pnl) then
          ErrorNoHalt("Failed to make reward: " .. v.Type .. "\n")
          continue
        end

        pnl:SetParent(panel.Free)
        table.insert(panel.Free.Items, pnl)
      end
    end

    if premium then
      for k, v in pairs(premium) do
        local pnl = self:CreateItem(v, true, k, i)
        if not IsValid(pnl) then
          --PrintTable(v)
          ErrorNoHalt("Failed to make reward: " .. v.Type .. "\n")
          continue
        end

        pnl:SetParent(panel.Premium)
        table.insert(panel.Premium.Items, pnl)
      end
    end

    panelIndex = panelIndex + 1
  end

  self:CalculateItems()
end

function PANEL:CalculateItems()
  local tbl = BATTLEPASS.Pass
  if not tbl then return end
  local items = 0
  for i, v in pairs(tbl.rewards.free) do
    items = items + 1
  end

  for i, v in pairs(tbl.rewards.premium) do
    items = items + #v
  end

  self.AmountOfItems = items
  return self.AmountOfItems
end

function PANEL:Reload()
  local id = self:GetBattlePass()
  local tbl = BATTLEPASS.Pass
end

function PANEL:PerformLayout(w, h)
  self.Title:SetPos(0, 0)
  self.Title:SetSize(W(945), H(531))
  self.Page:SetPos(W(76), 0)
  self.Page:SetSize(W(804), H(531))
  self.Left:SetPos(W(889), H(254))
  self.Left:SetSize(W(28), H(28))
  self.Right:SetPos(W(889 + 28), H(254))
  self.Right:SetSize(W(28), H(28))
end

vgui.Register("BATTLEPASS_Pass", PANEL)
--PATH addons/battlepass/lua/battlepass/server/perm_vars.lua:
function BATTLEPASS:GetPermanentVariable(ply, key)
	BATTLEPASS:SetupPass(ply)

	return ply.BattlePass.Owned.vars[key]
end

function BATTLEPASS:SetPermanentVariable(ply, key ,value)
	self:AddVariable(ply, key, value)
end
--PATH addons/__advdupe2/lua/advdupe2/sh_codec.lua:
--[[
	Title: Adv. Dupe 2 Codec

	Desc: Dupe encoder/decoder.

	Author: emspike

	Version: 2.0
]]

local REVISION = 5
AdvDupe2.CodecRevision = REVISION
AdvDupe2.MaxDupeSize = 32e6 -- 32 MB

include( "sh_codec_legacy.lua" )
AddCSLuaFile( "sh_codec_legacy.lua" )

local pairs = pairs
local type = type
local error = error
local Vector = Vector
local Angle = Angle
local format = string.format
local char = string.char
local byte = string.byte
local sub = string.sub
local gsub = string.gsub
local find = string.find
local gmatch = string.gmatch
local match = string.match
local concat = table.concat
local compress = util.Compress
local decompress = util.Decompress

--[[
	Name:	GenerateDupeStamp
	Desc:	Generates an info table.
	Params:	<player> ply
	Return:	<table> stamp
]]
function AdvDupe2.GenerateDupeStamp(ply)
	local stamp = {}
	stamp.name = ply:GetName()
	stamp.time = os.date("%I:%M %p")
	stamp.date = os.date("%d %B %Y")
	stamp.timezone = os.date("%z")
	hook.Call("AdvDupe2_StampGenerated",GAMEMODE,stamp)
	return stamp
end

local function makeInfo(tbl)
	local info = ""
	for k, v in pairs(tbl) do
		info = concat{info,k,"\1",v,"\1"}
	end
	return info.."\2"
end

local AD2FF = "AD2F%s\n%s\n%s"

local tables, buff

local function noserializer() end

local enc = {}
for i = 1, 255 do enc[i] = noserializer end

local function isArray(tbl)
	local ret = true
	local m = 0

	for k, v in pairs(tbl) do
		m = m + 1
		if k ~= m or enc[TypeID(v)] == noserializer then
			ret = false
			break
		end
	end

	return ret
end

local function write(obj)
	enc[TypeID(obj)](obj)
end

local len, tables, tablesLookup

enc[TYPE_TABLE] = function(obj) --table
	if not tablesLookup[obj] then
		tables = tables + 1
		tablesLookup[obj] = tables
	else
		buff:WriteByte(247)
		buff:WriteShort(tablesLookup[obj])
		return
	end

	if isArray(obj) then
		buff:WriteByte(254)
		for i, v in pairs(obj) do
			write(v)
		end
	else
		buff:WriteByte(255)
		for k, v in pairs(obj) do
			if(enc[TypeID(k)] ~= noserializer and enc[TypeID(v)] ~= noserializer) then
				write(k)
				write(v)
			end
		end
	end
	buff:WriteByte(246)
end

enc[TYPE_BOOL] = function(obj) --boolean
	buff:WriteByte(obj and 253 or 252)
end

enc[TYPE_NUMBER] = function(obj) --number
	buff:WriteByte(251)
	buff:WriteDouble(obj)
end

enc[TYPE_VECTOR] = function(obj) --vector
	buff:WriteByte(250)
	buff:WriteDouble(obj.x)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.z)
end

enc[TYPE_ANGLE] = function(obj) --angle
	buff:WriteByte(249)
	buff:WriteDouble(obj.p)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.r)
end

enc[TYPE_STRING] = function(obj) --string
	len = #obj
	if len < 246 then
		buff:WriteByte(len)
		buff:Write(obj)
	else
		buff:WriteByte(248)
		buff:WriteULong(len)
		buff:Write(obj)
	end
end

local function error_nodeserializer()
	buff:Seek(buff:Tell()-1)
	error(format("Couldn't find deserializer for type {typeid:%d}!", buff:ReadByte()))
end

local reference = 0
local read4, read5

do --Version 4
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		if tt == 0 then
			return nil
		end
		return dec[tt]()
	end
	read4 = read

	dec[255] = function() --table
		local t = {}
		local k
		reference = reference + 1
		local ref = reference
		repeat
			k = read()
			if k ~= nil then
				t[k] = read()
			end
		until (k == nil)
		tables[ref] = t
		return t
	end

	dec[254] = function() --array
		local t = {}
		local k = 0
		local v
		reference = reference + 1
		local ref = reference
		repeat
			k = k + 1
			v = read()
			if(v ~= nil) then
				t[k] = v
			end

		until (v == nil)
		tables[ref] = t
		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() --null-terminated string
		local start = buff:Tell()
		local slen = 0

		while buff:ReadByte() ~= 0 do
			slen = slen + 1
		end

		buff:Seek(start)

		local retv = buff:Read(slen)
		if(not retv) then retv="" end
		buff:ReadByte()

		return retv
	end
	dec[247] = function() --table reference
		reference = reference + 1
		return tables[buff:ReadShort()]
	end

	for i = 1, 246 do dec[i] = function() return buff:Read(i) end end
end

do --Version 5
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		return dec[tt]()
	end
	read5 = read

	dec[255] = function() --table
		local t = {}
		reference = reference + 1
		tables[reference] = t

		for k in read do
			t[k] = read()
		end

		return t
	end

	dec[254] = function() --array
		local t = {}
		reference = reference + 1
		tables[reference] = t

		local k = 1
		for v in read do
			t[k] = v
			k = k + 1
		end

		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() -- Length>246 string
		local slen = buff:ReadULong()
		local retv = buff:Read(slen)
		if(not retv) then retv = "" end
		return retv
	end
	dec[247] = function() --table reference
		return tables[buff:ReadShort()]
	end
	dec[246] = function() --nil
		return
	end

	for i = 1, 245 do dec[i] = function() return buff:Read(i) end end

	dec[0] = function() return "" end
end

local function serialize(tbl)
	tables = 0
	tablesLookup = {}

	buff = file.Open("ad2temp.txt", "wb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	write(tbl)
	buff:Close()

	buff = file.Open("ad2temp.txt","rb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local ret = buff:Read(buff:Size())
	buff:Close()
	return ret
end


local function deserialize(str, read)

	if(str == nil) then
		error("File could not be decompressed!")
		return {}
	end

	tables = {}
	reference = 0
	buff = file.Open("ad2temp.txt","wb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	buff:Write(str)
	buff:Flush()
	buff:Close()

	buff = file.Open("ad2temp.txt","rb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local success, tbl = pcall(read)
	buff:Close()

	if success then
		return tbl
	else
		error(tbl)
	end
end

--[[
	Name:	Encode
	Desc:	Generates the string for a dupe file with the given data.
	Params:	<table> dupe, <table> info, <function> callback, <...> args
	Return:	runs callback(<string> encoded_dupe, <...> args)
]]
function AdvDupe2.Encode(dupe, info, callback, ...)
	local encodedTable = compress(serialize(dupe))
	info.check = "\r\n\t\n"
	info.size = #encodedTable

	callback(AD2FF:format(char(REVISION), makeInfo(info), encodedTable),...)
end

--seperates the header and body and converts the header to a table
local function getInfo(str)
	local last = str:find("\2")
	if not last then
		error("Attempt to read AD2 file with malformed info block!")
	end
	local info = {}
	local ss = str:sub(1, last - 1)
	for k, v in ss:gmatch("(.-)\1(.-)\1") do
		info[k] = v
	end

	if info.check ~= "\r\n\t\n" then
		if info.check == "\10\9\10" then
			error("Detected AD2 file corrupted in file transfer (newlines homogenized)(when using FTP, transfer AD2 files in image/binary mode, not ASCII/text mode)!")
		elseif info.check ~= nil then
			error("Detected AD2 file corrupted by newline replacements (copy/pasting the data in various editors can cause this!)")
		else
			error("Attempt to read AD2 file with malformed info block!")
		end
	end
	return info, str:sub(last+2)
end

--decoders for individual versions go here
local versions = {}

versions[1] = AdvDupe2.LegacyDecoders[1]
versions[2] = AdvDupe2.LegacyDecoders[2]

versions[3] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	return versions[4](encodedDupe)
end

versions[4] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read4), info
end

versions[5] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read5), info
end

function AdvDupe2.CheckValidDupe(dupe, info)
	if not dupe.HeadEnt then return false, "Missing HeadEnt table" end
	if not dupe.Entities then return false, "Missing Entities table" end
	if not dupe.Constraints then return false, "Missing Constraints table" end
	if not dupe.HeadEnt.Z then return false, "Missing HeadEnt.Z" end
	if not dupe.HeadEnt.Pos then return false, "Missing HeadEnt.Pos" end
	if not dupe.HeadEnt.Index then return false, "Missing HeadEnt.Index" end
	if not dupe.Entities[dupe.HeadEnt.Index] then return false, "Missing HeadEnt index ["..dupe.HeadEnt.Index.."] from Entities table" end
	for key, data in pairs(dupe.Entities) do
		if not data.PhysicsObjects then return false, "Missing PhysicsObject table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if not data.PhysicsObjects[0] then return false, "Missing PhysicsObject[0] table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if info.ad1 then -- Advanced Duplicator 1
			if not data.PhysicsObjects[0].LocalPos then return false, "Missing PhysicsObject[0].LocalPos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].LocalAngle then return false, "Missing PhysicsObject[0].LocalAngle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		else -- Advanced Duplicator 2
			if not data.PhysicsObjects[0].Pos then return false, "Missing PhysicsObject[0].Pos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].Angle then return false, "Missing PhysicsObject[0].Angle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		end
	end
	return true, dupe
end

--[[
	Name:	Decode
	Desc:	Generates the table for a dupe from the given string. Inverse of Encode
	Params:	<string> encodedDupe, <function> callback, <...> args
	Return:	runs callback(<boolean> success, <table/string> tbl, <table> info)
]]
function AdvDupe2.Decode(encodedDupe)

	local sig, rev = encodedDupe:match("^(....)(.)")

	if not rev then
		return false, "Malformed dupe (wtf <5 chars long)!"
	end

	rev = rev:byte()

	if sig ~= "AD2F" then
		if sig == "[Inf" then --legacy support, ENGAGE (AD1 dupe detected)
			local success, tbl, info, moreinfo = pcall(AdvDupe2.LegacyDecoders[0], encodedDupe)

			if success then
				info.ad1 = true
				info.size = #encodedDupe
				info.revision = 0

				local index = tonumber(moreinfo.Head) or (istable(tbl.Entities) and next(tbl.Entities))
				if not index then return false, "Missing head index" end
				local pos
				if isstring(moreinfo.StartPos) then
					local spx,spy,spz = moreinfo.StartPos:match("^(.-),(.-),(.+)$")
					pos = Vector(tonumber(spx) or 0, tonumber(spy) or 0, tonumber(spz) or 0)
				else
					pos = Vector()
				end
				local z
				if isstring(moreinfo.HoldPos) then
					z = (tonumber(moreinfo.HoldPos:match("^.-,.-,(.+)$")) or 0)*-1
				else
					z = 0
				end
				tbl.HeadEnt = {
					Index = index,
					Pos = pos,
					Z = z
				}
			else
				ErrorNoHalt(tbl)
			end

			if success then
				success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
			end

			return success, tbl, info, moreinfo
		else
			return false, "Unknown duplication format!"
		end
	elseif rev > REVISION then
		return false, format("Newer codec needed. (have rev %u, need rev %u) Update Advdupe2.",REVISION,rev)
	elseif rev < 1 then
		return false, format("Attempt to use an invalid format revision (rev %d)!", rev)
	else
		local success, tbl, info = pcall(versions[rev], encodedDupe)

		if success then
			success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
		end
		if success then
			info.revision = rev
		end

		return success, tbl, info
	end
end

if CLIENT then

	concommand.Add("advdupe2_to_json", function(_,_,arg)
		if not arg[1] then print("Need AdvDupe2 file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".json"

		writeFileName = AdvDupe2.SanitizeFilename(writeFileName)

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()
		local ok, tbl = AdvDupe2.Decode(readData)
		local writeFile = file.Open(writeFileName, "wb", "DATA")
		if not writeFile then print("File could not be written! ("..writeFileName..")") return end
		writeFile:Write(util.TableToJSON(tbl))
		writeFile:Close()
		print("File written! ("..writeFileName..")")
	end)

	concommand.Add("advdupe2_from_json", function(_,_,arg)
		if not arg[1] then print("Need json file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".txt"

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()

		AdvDupe2.Encode(util.JSONToTable(readData), {}, function(data)
			local writeFile = file.Open(writeFileName, "wb", "DATA")
			if not writeFile then print("File could not be written! ("..writeFileName..")") return end
			writeFile:Write(data)
			writeFile:Close()
			print("File written! ("..writeFileName..")")
		end)
	end)

end



--PATH addons/__advdupe2/lua/advdupe2/cl_ghost.lua:
function AdvDupe2.LoadGhosts(dupe, info, moreinfo, name, preview)
	AdvDupe2.RemoveGhosts()
	AdvDupe2.Ghosting = true
	AdvDupe2.GhostToSpawn = {}
	local count = 0
	local time, desc, date, creator

	if(info.ad1) then
		local z = dupe.HeadEnt.Z
		local Pos, Ang

		time    = moreinfo.Time    or ""
		desc    = info.Description or ""
		date    = info.Date        or ""
		creator = info.Creator     or ""

		AdvDupe2.HeadEnt = dupe.HeadEnt.Index
		AdvDupe2.HeadPos = dupe.HeadEnt.Pos
		AdvDupe2.HeadZPos = z
		AdvDupe2.HeadPos.Z = AdvDupe2.HeadPos.Z + z

		for k, v in pairs(dupe.Entities) do
			if(v.SavedParentIdx) then
				if(not v.BuildDupeInfo) then v.BuildDupeInfo = {} end
				v.BuildDupeInfo.DupeParentID = v.SavedParentIdx
				Pos = v.LocalPos
				Ang = v.LocalAngle
			else
				Pos, Ang = nil, nil
			end

			for i, p in pairs(v.PhysicsObjects) do
				p.Pos        = Pos or p.LocalPos
				p.Pos.Z      = p.Pos.Z - z
				p.Angle      = Ang or p.LocalAngle
				p.LocalPos   = nil
				p.LocalAngle = nil
			end

			v.LocalPos = nil
			v.LocalAngle = nil
			AdvDupe2.GhostToSpawn[count] =
			{
				Model          = v.Model,
				PhysicsObjects = v.PhysicsObjects
			}

			if(AdvDupe2.HeadEnt == k) then
				AdvDupe2.HeadEnt = count
			end

			count = count + 1
		end

		AdvDupe2.HeadOffset = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
		AdvDupe2.HeadAngle  = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle
	else
		time    = info.time        or ""
		desc    = dupe.Description or ""
		date    = info.date        or ""
		creator = info.name        or ""

		AdvDupe2.HeadEnt    = dupe.HeadEnt.Index
		AdvDupe2.HeadZPos   = dupe.HeadEnt.Z
		AdvDupe2.HeadPos    = dupe.HeadEnt.Pos
		AdvDupe2.HeadOffset = dupe.Entities[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
		AdvDupe2.HeadAngle  = dupe.Entities[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle

		for k, v in pairs(dupe.Entities) do
			AdvDupe2.GhostToSpawn[count] =
			{
				Model          = v.Model,
				PhysicsObjects = v.PhysicsObjects
			}

			if(AdvDupe2.HeadEnt == k) then
				AdvDupe2.HeadEnt = count
			end

			count = count + 1
		end
	end

	if(not preview) then
		AdvDupe2.Info.File:SetText("File: "..name)
		AdvDupe2.Info.Creator:SetText("Creator: "..creator)
		AdvDupe2.Info.Date:SetText("Date: "..date)
		AdvDupe2.Info.Time:SetText("Time: "..time)
		AdvDupe2.Info.Size:SetText("Size: "..string.NiceSize(tonumber(info.size) or 0))
		AdvDupe2.Info.Desc:SetText("Desc: "..(desc or ""))
		AdvDupe2.Info.Entities:SetText("Entities: "..table.Count(dupe.Entities))
		AdvDupe2.Info.Constraints:SetText("Constraints: "..table.Count(dupe.Constraints))
	end

	AdvDupe2.StartGhosting()
	AdvDupe2.Preview = preview
end

function AdvDupe2.RemoveGhosts()
	if(AdvDupe2.Ghosting) then
		hook.Remove("Tick", "AdvDupe2_SpawnGhosts")
		AdvDupe2.Ghosting = false

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.RemoveProgressBar()
		end
	end

	if(AdvDupe2.GhostEntities) then
		for k, v in pairs(AdvDupe2.GhostEntities) do
			if(IsValid(v))then
				v:Remove()
			end
		end
	end

	if(IsValid(AdvDupe2.HeadGhost))then
		AdvDupe2.HeadGhost:Remove()
	end

	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.HeadGhost     = nil
	AdvDupe2.GhostEntities = nil
	AdvDupe2.Preview       = false
end

--Creates a ghost from the given entity's table
local function MakeGhostsFromTable(EntTable)

	if(not EntTable) then return end
	if(not EntTable.Model or EntTable.Model:sub(-4,-1) ~= ".mdl") then
		EntTable.Model = "models/error.mdl"
	end

	local GhostEntity = ClientsideModel(EntTable.Model, RENDERGROUP_TRANSLUCENT)

	-- If there are too many entities we might not spawn..
	if not IsValid(GhostEntity) then
		AdvDupe2.RemoveGhosts()
		AdvDupe2.Notify("Too many entities to spawn ghosts!", NOTIFY_ERROR)
		return
	end

	GhostEntity:SetRenderMode( RENDERMODE_TRANSALPHA )	--Was broken, making ghosts invisible
	GhostEntity:SetColor( Color(255, 255, 255, 150) )
	GhostEntity.Phys = EntTable.PhysicsObjects[0]

	if util.IsValidRagdoll(EntTable.Model) then
		local ref, parents, angs = {}, {}, {}

		GhostEntity:SetupBones()
		for k, v in pairs(EntTable.PhysicsObjects) do
			local bone = GhostEntity:TranslatePhysBoneToBone(k)
			local bonp = GhostEntity:GetBoneParent(bone)
			if bonp == -1 then
				ref[bone] = GhostEntity:GetBoneMatrix(bone):GetInverseTR()
			else
				bonp = GhostEntity:TranslatePhysBoneToBone(GhostEntity:TranslateBoneToPhysBone(bonp))
				parents[bone] = bonp
				ref[bone] = GhostEntity:GetBoneMatrix(bone):GetInverseTR() * GhostEntity:GetBoneMatrix(bonp)
			end

			local m = Matrix() m:SetAngles(v.Angle)
			angs[bone] = m
		end

		for bone, ang in pairs( angs ) do
			if parents[bone] and angs[parents[bone]] then
				local localrotation = angs[parents[bone]]:GetInverseTR() * ang
				local m = ref[bone] * localrotation
				GhostEntity:ManipulateBoneAngles(bone, m:GetAngles())
			else
				local pos = GhostEntity:GetBonePosition(bone)
				GhostEntity:ManipulateBonePosition(bone, -pos)
				GhostEntity:ManipulateBoneAngles(bone, ref[bone]:GetAngles())
			end
		end
	end

	return GhostEntity
end

local function StopGhosting()
	AdvDupe2.Ghosting = false
	hook.Remove( "Tick", "AdvDupe2_SpawnGhosts" )

	if not BusyBar then AdvDupe2.RemoveProgressBar() end
end

local function SpawnGhosts()
	local ghostsPerTick = GetConVar( "advdupe2_ghost_rate" ):GetInt()
	local ghostPercentLimit = GetConVar( "advdupe2_limit_ghost" ):GetFloat()

	local finalGhost = math.min( AdvDupe2.TotalGhosts, math.max( math.Round( (ghostPercentLimit / 100) * AdvDupe2.TotalGhosts ), 0 ) )
	local finalGhostInFrame = math.min( AdvDupe2.CurrentGhost + ghostsPerTick - 1, finalGhost )

	for i = AdvDupe2.CurrentGhost, finalGhostInFrame do
		local g = AdvDupe2.GhostToSpawn[i]
		if g and i ~= AdvDupe2.HeadEnt then AdvDupe2.GhostEntities[i] = MakeGhostsFromTable( g ) end
	end
	AdvDupe2.CurrentGhost = finalGhostInFrame + 1

	AdvDupe2.UpdateGhosts( true )
	if not AdvDupe2.BusyBar then
		AdvDupe2.ProgressBar.Percent = (AdvDupe2.CurrentGhost / AdvDupe2.TotalGhosts) * 100
	end

	if AdvDupe2.CurrentGhost > finalGhost then
		StopGhosting()
	end
end

net.Receive("AdvDupe2_SendGhosts", 	function(len, ply, len2)
	AdvDupe2.RemoveGhosts()
	AdvDupe2.GhostToSpawn = {}
	AdvDupe2.HeadEnt  = net.ReadInt(16)
	AdvDupe2.HeadZPos = net.ReadFloat()
	AdvDupe2.HeadPos  = net.ReadVector()

	local cache = {}
	for i = 1, net.ReadInt(16) do
		cache[i] = net.ReadString()
	end

	for i = 1, net.ReadInt(16) do
		AdvDupe2.GhostToSpawn[i] =
		{
			Model = cache[net.ReadInt(16)],
			PhysicsObjects = {}
		}

		for k = 0, net.ReadInt(8) do
			AdvDupe2.GhostToSpawn[i].PhysicsObjects[k] =
			{
				Angle = net.ReadAngle(),
				Pos   = net.ReadVector()
			}
		end
	end

	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.GhostEntities = {}
	AdvDupe2.HeadGhost     = MakeGhostsFromTable(AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt])
	AdvDupe2.HeadOffset    = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
	AdvDupe2.HeadAngle     = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle
	AdvDupe2.GhostEntities[AdvDupe2.HeadEnt] = AdvDupe2.HeadGhost
	AdvDupe2.TotalGhosts   = #AdvDupe2.GhostToSpawn

	if(AdvDupe2.TotalGhosts > 1) then
		AdvDupe2.Ghosting = true

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
		end

		hook.Add("Tick", "AdvDupe2_SpawnGhosts", SpawnGhosts)
	else
		AdvDupe2.Ghosting = false
	end
end)

net.Receive("AdvDupe2_AddGhost", function(len, ply, len2)
	local ghost = {Model = net.ReadString(), PhysicsObjects = {}}
	for k = 0, net.ReadInt(8) do
		ghost.PhysicsObjects[k] = {Angle = net.ReadAngle(), Pos = net.ReadVector()}
	end

	AdvDupe2.GhostEntities[AdvDupe2.CurrentGhost] = MakeGhostsFromTable(ghost)
	AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1
end)

function AdvDupe2.StartGhosting()
	AdvDupe2.RemoveGhosts()
	if(not AdvDupe2.GhostToSpawn) then return end
	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.GhostEntities = {}
	AdvDupe2.Ghosting      = true
	AdvDupe2.HeadGhost     = MakeGhostsFromTable(AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt])
	if AdvDupe2.HeadEnt and AdvDupe2.GhostEntities[AdvDupe2.HeadEnt] then
		AdvDupe2.GhostEntities[AdvDupe2.HeadEnt] = AdvDupe2.HeadGhost
	end
	AdvDupe2.TotalGhosts   = #AdvDupe2.GhostToSpawn

	if AdvDupe2.TotalGhosts > 1 then
		if not AdvDupe2.BusyBar then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
		end
		hook.Add("Tick", "AdvDupe2_SpawnGhosts", SpawnGhosts)
	else
		AdvDupe2.Ghosting = false
	end
end
net.Receive("AdvDupe2_StartGhosting", function()
	AdvDupe2.StartGhosting()
end)

net.Receive("AdvDupe2_RemoveGhosts", AdvDupe2.RemoveGhosts)

--Update the ghost's postion and angles based on where the player is looking and the offsets
local Lheadpos, Lheadang = Vector(), Angle()
function AdvDupe2.UpdateGhosts(force)
	if not IsValid(AdvDupe2.HeadGhost) then
		AdvDupe2.RemoveGhosts()
		AdvDupe2.Notify("Invalid ghost parent!", NOTIFY_ERROR)
		return
	end

	local trace = LocalPlayer():GetEyeTrace()
	if (not trace.Hit) then return end

	local originpos, originang, headpos, headang
	local worigin = GetConVar("advdupe2_offset_world"):GetBool()
	if(GetConVar("advdupe2_original_origin"):GetBool())then
		originang  = Angle()
		originpos  = Vector(AdvDupe2.HeadPos)
		headpos = AdvDupe2.HeadPos + AdvDupe2.HeadOffset
		headang = AdvDupe2.HeadAngle
	else
		local hangle = worigin and Angle(0,0,0) or AdvDupe2.HeadAngle
		local pz = math.Clamp(AdvDupe2.HeadZPos + GetConVar("advdupe2_offset_z"):GetFloat() or 0, -16000, 16000)
		local ap = math.Clamp(GetConVar("advdupe2_offset_pitch"):GetFloat() or 0, -180, 180)
		local ay = math.Clamp(GetConVar("advdupe2_offset_yaw"  ):GetFloat() or 0, -180, 180)
		local ar = math.Clamp(GetConVar("advdupe2_offset_roll" ):GetFloat() or 0, -180, 180)
		originang = Angle(ap, ay, ar)
		originpos = Vector(trace.HitPos); originpos.z = originpos.z + pz
		headpos, headang = LocalToWorld(AdvDupe2.HeadOffset, hangle, originpos, originang)
	end

	if math.abs(Lheadpos.x - headpos.x) > 0.01 or
	   math.abs(Lheadpos.y - headpos.y) > 0.01 or
	   math.abs(Lheadpos.z - headpos.z) > 0.01 or
	   math.abs(Lheadang.p - headang.p) > 0.01 or
	   math.abs(Lheadang.y - headang.y) > 0.01 or
	   math.abs(Lheadang.r - headang.r) > 0.01 or force then

		Lheadpos = headpos
		Lheadang = headang

		AdvDupe2.HeadGhost:SetPos(headpos)
		AdvDupe2.HeadGhost:SetAngles(headang)

		for k, ghost in ipairs(AdvDupe2.GhostEntities) do
			local phys = ghost.Phys
			local pos, ang = LocalToWorld(phys.Pos, phys.Angle, originpos, originang)
			ghost:SetPos(pos)
			ghost:SetAngles(ang)
		end

	end
end

--PATH addons/____bricks_framework/lua/autorun/client/brs_cl_autorun.lua:
--[[ Global Variables/Tables ]]--
BRICKS_SERVER = BRICKS_SERVER or {}
BRICKS_SERVER.Func = BRICKS_SERVER.Func or {}
BRICKS_SERVER.TEMP = BRICKS_SERVER.TEMP or {}

--[[ Modules Prep ]]--
BRICKS_SERVER.Modules = {}
local moduleMeta = {
	GetFolderName = function( self )
		return self.FolderName
	end,
	AddSubModule = function( self, folderName, name )
		BRICKS_SERVER.Modules[self:GetFolderName()][3][folderName] = name
	end
}

moduleMeta.__index = moduleMeta

function BRICKS_SERVER.Func.AddModule( folderName, name, icon, version )
	BRICKS_SERVER.Modules[folderName] = { name, icon, {}, version }
	
	local module = {
		FolderName = folderName
	}
	
	setmetatable( module, moduleMeta )
	
	return module
end

--[[ Autorun files ]]--
for k, v in pairs( file.Find( "bricks_server/*.lua", "LUA" ) ) do
	if( string.StartWith( v, "bricks_server_autorun_" ) ) then
		AddCSLuaFile( "bricks_server/" .. v )
		include( "bricks_server/" .. v )
	end
end

--[[ CONFIG LOADER ]]--
for k, v in pairs( file.Find( "bricks_server/*.lua", "LUA" ) ) do
	if( string.StartWith( v, "bricks_server_luacfg_" ) ) then
		AddCSLuaFile( "bricks_server/" .. v )
		include( "bricks_server/" .. v )
	end
end

BRICKS_SERVER.BASECONFIG = {}
AddCSLuaFile( "bricks_server/bricks_server_basecfg_main.lua" )
include( "bricks_server/bricks_server_basecfg_main.lua" )
hook.Run( "BRS.Hooks.BaseConfigLoad" )

BRICKS_SERVER.CONFIG = table.Copy( BRICKS_SERVER.BASECONFIG )

function BRICKS_SERVER.Func.AddLanguageStrings( languageKey, stringTable )
	if( not BRICKS_SERVER.Languages[languageKey] ) then
		BRICKS_SERVER.Languages[languageKey] = stringTable
	else
		table.Merge( BRICKS_SERVER.Languages[languageKey], stringTable )
	end
end

function BRICKS_SERVER.Func.LoadLanguages()
	BRICKS_SERVER.Languages = {}
	local files, directories = file.Find( "bricks_server/languages/*", "LUA" )
	for k, v in pairs( directories ) do
		for key, val in pairs( file.Find( "bricks_server/languages/" .. v .. "/*", "LUA" ) ) do
			AddCSLuaFile( "bricks_server/languages/" .. v .. "/" .. val )
			include( "bricks_server/languages/" .. v .. "/" .. val )
		end
	end
end
BRICKS_SERVER.Func.LoadLanguages()

function BRICKS_SERVER.Func.L( languageKey, ... )
	local languageTable = BRICKS_SERVER.Languages[BRICKS_SERVER.CONFIG.LANGUAGE.Language or "english"] or BRICKS_SERVER.Languages["english"]

	local languageString = ((languageTable or {})[languageKey] or BRICKS_SERVER.Languages["english"][languageKey]) or "MISSING LANGUAGE"

	local configLanguageTable = (BRICKS_SERVER.CONFIG.LANGUAGE.Languages or {})[BRICKS_SERVER.CONFIG.LANGUAGE.Language or "english"]

	if( configLanguageTable and configLanguageTable[2] and configLanguageTable[2][languageKey] ) then
		languageString = configLanguageTable[2][languageKey]
	end

	return (not ... and languageString) or string.format( languageString, ... )
end

function BRICKS_SERVER.Func.GetTheme( key, alpha )
	local color = Color( 0, 0, 0 )
	if( BRICKS_SERVER.BASECONFIG.THEME[key] ) then
		if( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).THEME[key] ) then
			color = (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).THEME[key]
		else
			color = BRICKS_SERVER.BASECONFIG.THEME[key]
		end
	end

	if( alpha ) then
		color = Color( color.r, color.g, color.b, alpha )
	end

	return color
end

function BRICKS_SERVER.Func.IsModuleEnabled( moduleName )
	if( BRICKS_SERVER.Modules[moduleName] ) then
		return BRICKS_SERVER.CONFIG.MODULES[moduleName] and BRICKS_SERVER.CONFIG.MODULES[moduleName][1] == true
	end
	
	return false
end

function BRICKS_SERVER.Func.IsSubModuleEnabled( moduleName, subModuleName )
	if( BRICKS_SERVER.Modules[moduleName] ) then
		return BRICKS_SERVER.Func.IsModuleEnabled( moduleName ) and BRICKS_SERVER.CONFIG.MODULES[moduleName][2][subModuleName]
	end
	
	return false
end

local function LoadClientConfig()
	BRICKS_SERVER.BASECLIENTCONFIG = BRICKS_SERVER.BASECLIENTCONFIG or {}
	hook.Run( "BRS.Hooks.ClientConfigLoad" )
end

local function LoadDevConfig()
	BRICKS_SERVER.DEVCONFIG = BRICKS_SERVER.DEVCONFIG or {}
	AddCSLuaFile( "bricks_server/bricks_server_devcfg_main.lua" )
	include( "bricks_server/bricks_server_devcfg_main.lua" )
	hook.Run( "BRS.Hooks.DevConfigLoad" )
end

LoadClientConfig()
LoadDevConfig()

--[[ Automatic autoruns ]]--
local AutorunTable = {}
AutorunTable[1] = {
	Location = "bricks_server/core/shared/",
	Type = "Shared"
}
AutorunTable[2] = {
	Location = "bricks_server/core/client/",
	Type = "Client"
}
AutorunTable[3] = {
	Location = "bricks_server/vgui/",
	Type = "Client"
}

for key, val in ipairs( AutorunTable ) do
	for k, v in ipairs( file.Find( val.Location .. "*.lua", "LUA" ) ) do
		if( val.Type == "Shared" ) then
			include( val.Location .. v )
		elseif( val.Type == "Client" ) then	
			include( val.Location .. v )
		end
	end
end

hook.Run( "BRS.Hooks.CoreLoaded" )

--[[ MODULES AUTORUN ]]--
local function loadModuleFiles( filePath )
	local moduleFiles, moduleDirectories = file.Find( filePath .. "/*", "LUA" )

	if( not moduleDirectories ) then return end

	for key, val in pairs( moduleDirectories ) do
		for key2, val2 in pairs( file.Find( filePath .. "/" .. val .. "/*.lua", "LUA" ) ) do
			if( val == "shared" ) then
				include( filePath .. "/" .. val .. "/" .. val2 )
			elseif( val == "client" or val == "vgui" ) then
				include( filePath .. "/" .. val .. "/" .. val2 )
			end
		end
	end
end

if( not BRICKS_SERVER.CONFIG.MODULES["default"] or not BRICKS_SERVER.CONFIG.MODULES["default"][1] ) then
	BRICKS_SERVER.CONFIG.MODULES["default"] = { true, {} }
end

for k, v in pairs( BRICKS_SERVER.CONFIG.MODULES or {} ) do
	if( BRICKS_SERVER.Modules[k] and v[1] == true ) then
		loadModuleFiles( "bricks_server/modules/" .. k )
	else
		continue
	end

	if( table.Count( v[2] ) > 0 ) then
		for key, val in pairs( v[2] ) do
			if( BRICKS_SERVER.Modules[k][3][key] and val == true ) then
				loadModuleFiles( "bricks_server/modules/" .. k .. "/submodules/" .. key )
			end
		end
	end
end

hook.Add( "InitPostEntity", "BRS.InitPostEntity.Loaded", function()
	BRICKS_SERVER.INITPOSTENTITY_LOADED = true
end )

hook.Add( "Initialize", "BRS.Initialize.Loaded", function()
	BRICKS_SERVER.INITIALIZE_LOADED = true
end )

--[[ CLIENT REQUEST CONFIG ]]--
hook.Add( "BRS.Hooks.ConfigReceived", "BRS.Hooks.ConfigReceived.ConfigWait", function()
	LoadClientConfig()
	LoadDevConfig()

	hook.Remove( "BRS.Hooks.ConfigReceived", "BRS.Hooks.ConfigReceived.ConfigWait" )
end )

BRICKS_SERVER.TEMP.ReceivedConfig = false
BRICKS_SERVER.TEMP.LastConfigRequest = 0
hook.Add( "Think", "BRS.Think.RequestConfig", function()
	if( not BRICKS_SERVER.TEMP.ReceivedConfig and CurTime() >= BRICKS_SERVER.TEMP.LastConfigRequest ) then
		net.Start( "BRS.Net.RequestConfig" )
		net.SendToServer()
		BRICKS_SERVER.TEMP.LastConfigRequest = CurTime()+10
	end
end )

hook.Add( "BRS.Hooks.ConfigReceived", "BRS.Hooks.ConfigReceived.RequestConfigRemover", function()
	if( not BRICKS_SERVER.TEMP.ReceivedConfig ) then
		BRICKS_SERVER.TEMP.ReceivedConfig = true
		hook.Remove( "Think", "BRS.Think.RequestConfig" )
		hook.Remove( "BRS.Hooks.ConfigReceived", "BRS.Hooks.ConfigReceived.RequestConfigRemover" )
	end
end )
--PATH addons/____bricks_gangs/lua/bricks_server/bricks_gangs/sh_baseconfig.lua:
--[[
    !!WARNING!!
        ALL CONFIG IS DONE INGAME, DONT EDIT ANYTHING HERE
        Type !bricksserver ingame or use the f4menu
    !!WARNING!!
]]--

--[[ MODULES CONFIG ]]--
BRICKS_SERVER.BASECONFIG.MODULES = BRICKS_SERVER.BASECONFIG.MODULES or {}
BRICKS_SERVER.BASECONFIG.MODULES["gangs"] = { true, {
    ["achievements"] = true,
    ["associations"] = true,
    ["leaderboards"] = true,
    ["printers"] = true,
    ["storage"] = true,
    ["territories"] = true
} }

--[[ GANGS CONFIG ]]--
BRICKS_SERVER.BASECONFIG.GANGS = {}
BRICKS_SERVER.BASECONFIG.GANGS["Max Level"] = 100
BRICKS_SERVER.BASECONFIG.GANGS["Original EXP Required"] = 100
BRICKS_SERVER.BASECONFIG.GANGS["EXP Required Increase"] = 1.25
BRICKS_SERVER.BASECONFIG.GANGS["Creation Fee"] = 1500
BRICKS_SERVER.BASECONFIG.GANGS["Minimum Deposit"] = 1000
BRICKS_SERVER.BASECONFIG.GANGS["Minimum Withdraw"] = 1000
BRICKS_SERVER.BASECONFIG.GANGS["Max Storage Item Stack"] = 10
BRICKS_SERVER.BASECONFIG.GANGS["Territory Capture Distance"] = 20000
BRICKS_SERVER.BASECONFIG.GANGS["Territory UnCapture Time"] = 3
BRICKS_SERVER.BASECONFIG.GANGS["Territory Capture Time"] = 3
BRICKS_SERVER.BASECONFIG.GANGS["Leaderboard Refresh Time"] = 300
BRICKS_SERVER.BASECONFIG.GANGS["Gang Display Limit"] = 10
BRICKS_SERVER.BASECONFIG.GANGS["Gang Friendly Fire"] = true
BRICKS_SERVER.BASECONFIG.GANGS["Disable Gang Chat"] = false
BRICKS_SERVER.BASECONFIG.GANGS["Gang Display Distance"] = 10000
BRICKS_SERVER.BASECONFIG.GANGS.Upgrades = {
    ["MaxMembers"] = {
        Name = "Max Members", 
        Description = "Maximum allowed members.",
        Icon = "members_upgrade.png",
        Default = { 4 },
        Tiers = {
            [1] = {
                Price = 5000,
                ReqInfo = { 8 }
            },
            [2] = {
                Price = 25000,
                ReqInfo = { 16 }
            }
        }
    },
    ["MaxBalance"] = {
        Name = "Max Balance", 
        Description = "Maximum allowed balance.",
        Icon = "balance.png",
        Default = { 10000 },
        Tiers = {
            [1] = {
                Price = 5000,
                ReqInfo = { 25000 }
            },
            [2] = {
                Price = 25000,
                ReqInfo = { 100000 }
            }
        }
    },
    ["StorageSlots"] = {
        Name = "Storage Slots", 
        Description = "Amount of storage slots.",
        Icon = "storage_64.png",
        Default = { 10 },
        Tiers = {
            [1] = {
                Price = 5000,
                ReqInfo = { 20 }
            },
            [2] = {
                Price = 25000,
                ReqInfo = { 40 }
            }
        }
    },
    ["Health"] = {
        Name = "Increased Health", 
        Description = "Gives extra health on spawn.",
        Icon = "health_upgrade.png",
        Default = { 0 },
        Tiers = {
            [1] = {
                Price = 5000,
                ReqInfo = { 25 }
            },
            [2] = {
                Price = 10000,
                ReqInfo = { 50 }
            },
            [3] = {
                Price = 25000,
                ReqInfo = { 75 }
            },
            [4] = {
                Price = 50000,
                ReqInfo = { 100 }
            }
        }
    },
    ["Armor"] = {
        Name = "Increased Armor", 
        Description = "Gives extra armor on spawn.",
        Icon = "armor_upgrade.png",
        Default = { 0 },
        Tiers = {
            [1] = {
                Price = 5000,
                ReqInfo = { 10 }
            },
            [2] = {
                Price = 10000,
                ReqInfo = { 25 }
            },
            [3] = {
                Price = 25000,
                ReqInfo = { 50 }
            }
        }
    },
    ["Salary"] = {
        Name = "Increased Salary", 
        Description = "Gives a higher salary.",
        Icon = "salary_upgrade.png",
        Default = { 0 },
        Tiers = {
            [1] = {
                Price = 5000,
                ReqInfo = { 75 }
            },
            [2] = {
                Price = 10000,
                ReqInfo = { 150 }
            },
            [3] = {
                Price = 25000,
                ReqInfo = { 250 }
            }
        }
    },
    ["Weapon_1"] = {
        Name = "Permanent AK47",
        Description = "All members spawn with an AK47!",
        Icon = "https://i.imgur.com/iDezZ62.png",
        Price = 5000,
        Type = "Weapon",
        ReqInfo = { "weapon_ak472" }
    },
    ["Weapon_2"] = {
        Name = "Permanent Sniper",
        Description = "All members spawn with a sniper!",
        Icon = "https://i.imgur.com/mPSQunx.png",
        Price = 15000,
        Type = "Weapon",
        ReqInfo = { "ls_sniper" }
    }
}

BRICKS_SERVER.BASECONFIG.GANGS.Achievements = {
    [1] = {
        Name = "Members 1", 
        Description = "Reach a member count of 4.",
        Icon = "members_upgrade.png",
        Category = "Members Achievements",
        Type = "Members",
        ReqInfo = { 4 },
        Rewards = { ["GangBalance"] = { 500 }, ["GangExperience"] = { 100 } }
    },
    [2] = {
        Name = "Members 2", 
        Description = "Reach a member count of 8.",
        Icon = "members_upgrade.png",
        Category = "Members Achievements",
        Type = "Members",
        ReqInfo = { 8 },
        Rewards = { ["GangBalance"] = { 1000 }, ["GangExperience"] = { 200 } }
    },
    [3] = {
        Name = "Members 3", 
        Description = "Reach a member count of 16.",
        Icon = "members_upgrade.png",
        Category = "Members Achievements",
        Type = "Members",
        ReqInfo = { 16 },
        Rewards = { ["GangBalance"] = { 2000 }, ["GangExperience"] = { 400 } }
    },
    [4] = {
        Name = "Balance 1", 
        Description = "Reach a gang balance of $10,000.",
        Icon = "balance.png",
        Category = "Balance Achievements",
        Type = "Balance",
        ReqInfo = { 10000 },
        Rewards = { ["GangBalance"] = { 500 }, ["GangExperience"] = { 100 } }
    },
    [5] = {
        Name = "Balance 2", 
        Description = "Reach a gang balance of $25,000.",
        Icon = "balance.png",
        Category = "Balance Achievements",
        Type = "Balance",
        ReqInfo = { 25000 },
        Rewards = { ["GangBalance"] = { 1000 }, ["GangExperience"] = { 200 } }
    },
    [6] = {
        Name = "Balance 3", 
        Description = "Reach a gang balance of $100,000.",
        Icon = "balance.png",
        Category = "Balance Achievements",
        Type = "Balance",
        ReqInfo = { 100000 },
        Rewards = { ["GangBalance"] = { 2000 }, ["GangExperience"] = { 400 } }
    },
    [7] = {
        Name = "Storage 1", 
        Description = "Have at least 5 items in storage.",
        Icon = "inventory_64.png",
        Category = "Storage Achievements",
        Type = "Storage",
        ReqInfo = { 5 },
        Rewards = { ["GangBalance"] = { 500 }, ["GangExperience"] = { 100 } }
    },
    [8] = {
        Name = "Storage 2", 
        Description = "Have at least 15 items in storage.",
        Icon = "inventory_64.png",
        Category = "Storage Achievements",
        Type = "Storage",
        ReqInfo = { 15 },
        Rewards = { ["GangBalance"] = { 1000 }, ["GangExperience"] = { 200 } }
    },
    [9] = {
        Name = "Storage 3", 
        Description = "Have at least 35 items in storage.",
        Icon = "inventory_64.png",
        Category = "Storage Achievements",
        Type = "Storage",
        ReqInfo = { 35 },
        Rewards = { ["GangBalance"] = { 2000 }, ["GangExperience"] = { 400 } }
    },
    [10] = {
        Name = "Level 10", 
        Description = "Reach a gang level of 10.",
        Icon = "levelling.png",
        Category = "Level Achievements",
        Type = "Level",
        ReqInfo = { 10 },
        Rewards = { ["GangBalance"] = { 500 }, ["GangExperience"] = { 100 } }
    },
    [11] = {
        Name = "Level 25", 
        Description = "Reach a gang level of 25.",
        Icon = "levelling.png",
        Category = "Level Achievements",
        Type = "Level",
        ReqInfo = { 25 },
        Rewards = { ["GangBalance"] = { 1000 }, ["GangExperience"] = { 200 } }
    }
}

BRICKS_SERVER.BASECONFIG.GANGS.Leaderboards = {
    [1] = {
        Name = "Most Experience", 
        Type = "Experience",
        Color = Color( 22, 160, 133 )
    },
    [2] = {
        Name = "Most Members", 
        Type = "Members",
        Color = Color( 41, 128, 185 )
    },
    [3] = {
        Name = "Highest Balance", 
        Type = "Balance",
        Color = Color( 39, 174, 96 )
    },
    [4] = {
        Name = "Most Items", 
        Type = "StorageItems",
        Color = Color( 231, 76, 60 )
    }
}

BRICKS_SERVER.BASECONFIG.GANGS.Territories = {
    [1] = {
        Name = "Fountain",
        Color = Color( 52, 152, 219 ),
        RewardTime = 60,
        Rewards = { ["GangBalance"] = { 250 }, ["GangExperience"] = { 25 } }
    },
    [2] = {
        Name = "Park",
        Color = Color( 231, 76, 60 ),
        RewardTime = 120,
        Rewards = { ["GangBalance"] = { 500 }, ["GangExperience"] = { 50 } }
    }
}

--[[ GANG PRINTER CONFIG ]]--
BRICKS_SERVER.BASECONFIG.GANGPRINTERS = {}
BRICKS_SERVER.BASECONFIG.GANGPRINTERS["Income Update Time"] = 10
BRICKS_SERVER.BASECONFIG.GANGPRINTERS["Base Printer Health"] = 100
BRICKS_SERVER.BASECONFIG.GANGPRINTERS.Printers = {
    [1] = {
        Name = "Printer 1",
        Price = 5000,
        ServerPrices = { 1000, 1500, 2500, 4000, 6500, 8000 },
        ServerAmount = 100,
        ServerHeat = 8,
        MaxHeat = 60,
        BaseHeat = 20,
        ServerTime = 2
    },
    [2] = {
        Name = "Printer 2",
        Price = 15000,
        ServerPrices = { 1500, 2500, 4000, 6500, 8000, 10000 },
        ServerAmount = 100,
        ServerHeat = 8,
        MaxHeat = 60,
        BaseHeat = 20,
        ServerTime = 3
    }
}
BRICKS_SERVER.BASECONFIG.GANGPRINTERS.Upgrades = {
    ["Health"] = {
        Name = "PRINTER HEALTH",
        Tiers = {
            [1] = { 
                Price = 1000,
                ReqInfo = { 10 }
            },
            [2] = { 
                Price = 2500,
                ReqInfo = { 25 }
            },
            [3] = { 
                Price = 3500,
                ReqInfo = { 50 }
            },
            [4] = { 
                Price = 4500,
                ReqInfo = { 75 }
            },
            [5] = { 
                Price = 5000,
                ReqInfo = { 90 }
            },
            [6] = { 
                Price = 7500,
                ReqInfo = { 100 }
            },
        }
    },
    ["RGB"] = {
        Name = "RGB LEDS",
        Price = 2500
    }
}
BRICKS_SERVER.BASECONFIG.GANGPRINTERS.ServerUpgrades = {
    ["Cooling"] = {
        Name = "Cooling",
        Tiers = {
            [1] = { 
                Price = 1000,
                ReqInfo = { 10 }
            },
            [2] = { 
                Price = 2500,
                Level = 5,
                ReqInfo = { 25 }
            }
        }
    },
    ["Speed"] = {
        Name = "Speed",
        Tiers = {
            [1] = { 
                Price = 1000,
                ReqInfo = { 10 }
            },
            [2] = { 
                Price = 2500,
                Level = 5,
                ReqInfo = { 25 }
            },
            [3] = { 
                Price = 2500,
                Level = 5,
                ReqInfo = { 35 }
            },
            [4] = { 
                Price = 5000,
                Level = 5,
                ReqInfo = { 40 }
            },
            [5] = { 
                Price = 7500,
                Level = 5,
                ReqInfo = { 50 }
            },
            [6] = { 
                Price = 10000,
                Level = 5,
                ReqInfo = { 75 }
            }
        }
    },
    ["Amount"] = {
        Name = "Amount",
        Tiers = {
            [1] = { 
                Price = 1000,
                ReqInfo = { 10 }
            },
            [2] = { 
                Price = 2500,
                Level = 5,
                ReqInfo = { 25 }
            },
            [3] = { 
                Price = 5000,
                Level = 5,
                ReqInfo = { 50 }
            },
            [4] = { 
                Price = 8500,
                Level = 5,
                ReqInfo = { 75 }
            }
        }
    }
}

--[[ NPCS ]]--
BRICKS_SERVER.BASECONFIG.NPCS = BRICKS_SERVER.BASECONFIG.NPCS or {}
table.insert( BRICKS_SERVER.BASECONFIG.NPCS, {
    Name = "Gang",
    Type = "Gang"
} )
--PATH addons/____bricks_gangs/lua/bricks_server/languages/bricks_gangs/english.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "english", {
    ["gang"] = "Gang",
    ["gangNew"] = "New Gang",
    ["gangRequestCooldown"] = "Please wait before requesting more gangs!",
    ["gangRequestDataCooldown"] = "Please wait before requesting data about another gang!",
    ["gangNewUpgrade"] = "New Upgrade",
    ["gangUpgradeTierEdit"] = "%s - Tier %d",
    ["gangNewAchievement"] = "New Achievement",
    ["gangNewTerritory"] = "New Territory",
    ["gangRewardTime"] = "Reward Time",
    ["gangRewardTimeQuery"] = "How often should the occupying gang receive rewards?",
    ["gangRewards"] = "Rewards",
    ["gangNewLeaderboard"] = "New Leaderboard",
    ["gangRankQuery"] = "What rank would you like to set them to?",
    ["gangPlayerAlreadyRank"] = "The player is already this rank!",
    ["gangInvalidRank"] = "Invalid rank.",
    ["gangKick"] = "Kick",
    ["gangKickConfirm"] = "Are you sure you want to kick this member?",
    ["gangSetOwner"] = "Set owner",

    ["gangInbox"] = "GANG INBOX",
    ["gangNoNotifications"] = "You have no notifications!",
    ["gangTimeAgo"] = "%s ago",
    ["gangNotification"] = "Gang Notification",
    ["gangNotificationHeader"] = "What would you like the header of the notification to be?",
    ["gangAdminNotification"] = "Admin Notification",
    ["gangNotificationBody"] = "What would you like the main body of the notification to be?",
    ["gangAdminNotificationSent"] = "Sent an admin gang notification to %s!",

    ["gangVariables"] = "Variables",

    ["gangClaimedAchievement"] = "Successfully claimed achievement rewards!",
    ["gangAlreadyAssociation"] = "Your gang already has this type of association with the other gang!",
    ["gangAlreadySentAssociation"] = "Your gang has already sent them an association invite!",
    ["gangAssociationSent"] = "Association invite sent!",
    ["gangAssociationAccepted"] = "Association invite accepted!",
    ["gangNoAssociation"] = "Your gang does not have any association with this gang!",
    ["gangAssociationDissolved"] = "Association dissolved!",

    ["gangOwner"] = "Owner",
    ["gangOfficer"] = "Officer",
    ["gangMember"] = "Member",

    ["gangCannotDeposit"] = "You cannot deposit this weapon!",
    ["gangStorageFullError"] = "Your gang storage is full!",
    ["gangDepositedItem"] = "You have deposited an item into your gang's storage!",
    ["gangDroppedItem"] = "Dropped 1 item from your gang storage.",
    ["gangUsedItem"] = "Used 1 item from your gang storage.",
    ["gangCantUse"] = "You can't use that!",

    ["gangKicked"] = "You have been kicked from the gang %s!",
    ["gangAlreadyIn"] = "You are already in a gang!",
    ["gangNameLength"] = "The gang name cannot be longer than %d characters!",
    ["gangIconLength"] = "The gang icon URL cannot be longer than %d characters!",
    ["gangIconWhitelisted"] = "Your gang icon image URL is not whitelisted, try using imgur instead.",
    ["gangCreatedFor"] = "Your new gang has been created for %s!",
    ["gangCreated"] = "Your new gang has been created!",
    ["gangCreationNoMoney"] = "You don't have enough money, you need %s!",
    ["gangWaitBeforeSaving"] = "Please wait %d seconds before saving your changes again!",
    ["gangRolesUpdated"] = "Gang roles updated!",
    ["gangCannotTarget"] = "You cannot target this player!",
    ["gangRankNotExists"] = "This rank doesn't exist!",
    ["gangCantPromote"] = "You can't promote someone to a rank higher than or the same as yours!",
    ["gangRankSet"] = "Rank successfully set!",
    ["gangRankSetFail"] = "Failed to set rank!",
    ["gangSettingsUpdated"] = "Gang settings updated!",
    ["gangPlayerKicked"] = "Successfully kicked %s from your gang!",
    ["gangPlayerKickError"] = "Error when kicking gang member!",
    ["gangWaitBeforeInvite"] = "Please wait 5 seconds before inviting another player!",
    ["gangPlayerOffline"] = "This player is no longer online!",
    ["gangPlayerAlreadyInvited"] = "This player has already been invited!",
    ["gangPlayerInvited"] = "You have invited %s to your gang!",
    ["gangInviteReceived"] = "You have been invited to the gang %s! Type !gang to accept.",
    ["gangLeaveCurrent"] = "You must leave your current gang first!",
    ["gangReachedMemberLimit"] = "The gang has reached its member limit!",
    ["gangJoined"] = "Successfully joined %s!",
    ["gangNotEnoughMoney"] = "You don't have enough money!",
    ["gangDepositedMoney"] = "Successfully deposited %s into your gang!",
    ["gangWithdrewMoney"] = "Successfully withdrew %s from your gang!",
    ["gangDisbanded"] = "Successfully disbanded %s!",
    ["gangOwnershipTransfered"] = "Successfully transfered ownership of %s to %s!",
    ["gangLeft"] = "You have left %s!",

    ["gangTerritoryCaptured"] = "Your gang has captured the %s territory!",
    ["gangIncorrectLevel"] = "Your gang is not the right level to purchase this upgrade!",
    ["gangIncorrectGroup"] = "You are not the right group to buy this upgrade!",
    ["gangUpgradeBought"] = "Upgrade purchased for %s!",
    ["gangNotEnoughFunds"] = "Your gang doesn't have enough funds to purchase this upgrade!",

    ["gangAddAchievement"] = "Add Achievement",
    ["gangNewAchievementType"] = "What should the new achivement's type be?",
    ["gangAddLeaderboard"] = "Add Leaderboard",
    ["gangNewLeaderboardType"] = "What should the new leaderboard type be?",
    ["gangAddTerritory"] = "Add Territory",
    ["gangAddTier"] = "Add Tier",
    ["gangTierX"] = "Tier %d",
    ["gangNewUpgradeType"] = "What should the new upgrade type be?",
    ["gangNewUpgradeDesc"] = "New upgrade description.",

    ["gangDepositMenu"] = "Gang Deposit Menu",
    ["gangDepositInventoryQuery"] = "Are you want to deposit %s from your inventory?",
    ["gangDepositPlayerQuery"] = "Are you want to deposit %s from your player's loadout?",
    ["gangNoDepositItems"] = "You don't have any items that can be deposited!",

    ["gangMenu"] = "Gang Menu",
    ["gangNone"] = "No gang",
    ["gangID"] = "ID: %d",
    ["gangDashboard"] = "Dashboard",
    ["gangMembers"] = "Members",
    ["gangStorage"] = "Storage",
    ["gangUpgrades"] = "Upgrades",
    ["gangBalance"] = "Balance",
    ["gangAchievements"] = "Achievements",
    ["gangAssociations"] = "Associations",
    ["gangLeaderboards"] = "Leaderboards",
    ["gangTerritories"] = "Territories",
    ["gangRanks"] = "Ranks",
    ["gangCreate"] = "Create gang",
    ["gangProgress"] = "Progress: %s",

    ["gangNoneFound"] = "No gangs found matching your search.",
    ["gangMemberCount"] = "%d/%d Members",
    ["gangFailedToLoad"] = "Failed to load gang data!",
    ["gangSetRank"] = "Set rank",
    ["gangDissolveAssociation"] = "Would you like to dissolve this association?",
    ["gangAssociationStatus"] = "Status: %s",
    ["gangNeutral"] = "Neutral",
    ["gangCreateString"] = "Create gang for %s",
    ["gangName"] = "Gang Name:",
    ["gangIcon"] = "Icon URL:",
    
    ["gangInformation"] = "GANG STATISTICS",
    ["gangChat"] = "GANG CHAT",
    ["gangMessage"] = "Message gang",
    ["gangActions"] = "GANG ACTIONS",
    ["gangDepositMoney"] = "Deposit money",
    ["gangDepositMoneyQuery"] = "How much would you like to deposit?",
    ["gangDepositMoneyLess"] = "You cannot deposit less than %s!",
    ["gangDepositMoneyMuch"] = "Your gang balance cannot hold this much, you must upgrade your balance storage!",
    ["gangWithdrawMoney"] = "Withdraw money",
    ["gangWithdrawMoneyQuery"] = "How much would you like to withdraw?",
    ["gangWithdrawMoneyLess"] = "You cannot withdraw less than %s!",
    ["gangWithdrawMoneyMuch"] = "Your gang does not have enough funds!",
    ["gangInvitePlayer"] = "Invite player",
    ["gangInvitePlayerQuery"] = "What player would you like to invite?",
    ["gangDisband"] = "Disband gang",
    ["gangDisbandQuery"] = "Deleting your gang cannot be undone, type %s to delete it.",
    ["gangTransfer"] = "Transfer ownership",
    ["gangTransferQuery"] = "Who would you like to transfer ownership to?",
    ["gangLeave"] = "Leave gang",
    ["gangLeaveQuery"] = "Are you sure you want to leave this gang?",
    ["gangMemberUpper"] = "GANG MEMBERS",
    ["gangHighestRank"] = "Highest Rank",
    ["gangLowestRank"] = "Lowest Rank",

    ["gangUnsavedChanges"] = "You have unsaved changes.",
    ["gangSaveChanges"] = "Save changes",
    ["gangReset"] = "Reset Changes",
    ["gangRanksUpper"] = "GANG RANKS",
    ["gangNewRank"] = "New rank",
    ["gangRankName"] = "Rank Name",
    ["gangRankColor"] = "Rank Color",
    ["gangClearPerms"] = "Clear Permissions",
    ["gangDeleteRank"] = "Delete Rank",
    ["gangDeleteRankQuery"] = "Are you sure you want to delete this rank?",

    ["gangStorageUpper"] = "GANG STORAGE",
    ["gangStorageProgress"] = "Storage %d/%d",
    ["gangClaimed"] = "Claimed",
    ["gangUnclaimed"] = "Unclaimed",
    ["gangClaimedAgo"] = "Claimed %s ago",
    ["gangRewardsEvery"] = "Given every %s",
    ["gangBuyUpgrade"] = "Do you want to buy this upgrade for %s?",
    ["gangUpgradeTier"] = "Upgrade Tier %d/%d",
    ["gangCurrent"] = "Current: %s",
    ["gangNext"] = "Next Tier: %s",

    ["gangTerritoryUpper"] = "TERRITTORY",
    ["gangCaptured"] = "CAPTURED",
    ["gangTerritoryAlready"] = "Your gang has already captured this territory!",
    ["gangCaptureFail"] = "You moved too far away or died, capture failed!",
    ["gangTerritoryPlaced"] = "Territory succesfully placed.",
    ["gangInvalidTerritory"] = "Invalid territory, choose a valid one from the tool menu.",
    ["gangTerritoryRemoved"] = "Territory succesfully removed.",
    ["gangTerritoryRemoveFail"] = "You can only use this tool to remove/create an territories.",
    ["gangTerritoryDesc"] = "Places and removes Territories from Brick's Server, LeftClick - place, RightClick - remove.",
    ["gangTerritory"] = "Territory",
    ["gangTerritoryPlacer"] = "Territory Placer",
    ["gangTerritoryDescSmall"] = "Places and removes Territories from Brick's Server.",
    ["gangTerritoryInstructions"] = "LeftClick - place, RightClick - remove.",

    ["gangSettings"] = "Settings",
    ["gangManagement"] = "Management",
    ["gangChatLower"] = "Gang Chat",
    ["gangDepositItems"] = "Deposit items",
    ["gangWithdrawItems"] = "Withdraw items",
    ["gangViewStorage"] = "View storage",
    ["gangEditRoles"] = "Edit roles",
    ["gangEditSettings"] = "Edit settings",
    ["gangInvitePlayers"] = "Invite players",
    ["gangKickPlayers"] = "Kick players",
    ["gangChangeRank"] = "Change players' rank",
    ["gangPurchaseUpgrades"] = "Purchase upgrades",
    ["gangAcceptDeclineInbox"] = "Accept/decline inbox notifications",
    ["gangAssociationSend"] = "Send association requests",
    ["gangAssociationAccept"] = "Accept association requests",
    ["gangSendChatMessages"] = "Send chat messages",
    ["gangMaxMembers"] = "Max Members",
    ["gangMaxBalance"] = "Max Balance",
    ["gangStorageSlots"] = "Storage Slots",
    ["gangXSlots"] = "%d Slots",
    ["gangSlots"] = "Slots",
    ["gangIncreasedHealth"] = "Increased Health",
    ["gangExtraHealth"] = "Extra Health",
    ["gangXHP"] = "+%d HP",
    ["gangIncreasedArmor"] = "Increased Armor",
    ["gangXAP"] = "+%d AP",
    ["gangExtraArmor"] = "Extra Armor",
    ["gangIncreasedSalary"] = "Increased Salary",
    ["gangExtraSalary"] = "Extra Salary",
    ["gangPermWeapon"] = "Permanent Weapon",
    ["gangWeapon"] = "Weapon",
    ["gangBalanceFull"] = "Gang Balance",
    ["gangMembersFull"] = "Gang Members",
    ["gangStorageFull"] = "Gang Storage",
    ["gangItems"] = "Items",
    ["gangItem"] = "Item",
    ["gangLevel"] = "Gang Level",
    ["gangInvite"] = "Gang Invite",
    ["gangInviteReceivedInbox"] = "You have been invited to join the gang %s!",
    ["gangAssociationInvite"] = "Association Invite",
    ["gangAssociationInviteInbox"] = "The gang %s has requested the association '%s' with your gang!",
    ["gangAssociationCreated"] = "Association Created",
    ["gangAssociationCreatedInbox"] = "Your gang now has the association '%s' with the gang %s!",
    ["gangAssociationDissolved"] = "Association Dissolved",
    ["gangAssociationDissolvedInbox"] = "Your association with the gang %s has been dissolved!",
    ["gangInboxAchievement"] = "Gang Achievement",
    ["gangInboxAchievementCompleted"] = "Your gang has completed the '%s' achievement!",
    ["gangInboxAchievementCompletedReward"] = "Your gang has completed the '%s' achievement, rewards: %s!",
    ["gangExperienceFull"] = "Gang Experience",
    ["gangJobWhitelist"] = "Job Whitelist",
    ["gangJobs"] = "Jobs",
    ["gangJobsSelect"] = "Select the teams which the players are whitelisted as.",
    ["gangStorageItems"] = "Storage Items",
    ["gangAllyRequest"] = "Are you sure you want to request to ally with this gang?",
    ["gangWarRequest"] = "Are you sure you want to request a war with this gang?",
    ["gangSetLevel"] = "Set Level",
    ["gangSetLevelQuery"] = "What should the gang's new level be?",
    ["gangSetLevelMsg"] = "Succesfully set the level of the gang %s to %d!",
    ["gangAddExperience"] = "Add Experience",
    ["gangAddExperienceQuery"] = "How much experience would you like to add to the gang?",
    ["gangAddExperienceMsg"] = "Succesfully added %s experience to the gang %s!",
    ["gangSetBalance"] = "Set Balance",
    ["gangSetBalanceQuery"] = "What should the gang's new balance to be?",
    ["gangSetBalanceMsg"] = "Succesfully set the balance of the gang %s to %s!",
    ["gangAddBalance"] = "Add Balance",
    ["gangAddBalanceQuery"] = "How much money would you like to add to the gang's balance?",
    ["gangAddBalanceMsg"] = "Succesfully added %s balance to the gang %s!",
    ["gangViewMembers"] = "View Members",
    ["gangCantKickOwner"] = "You cannot kick the owner of the gang!",
    ["gangKickSuccessAdmin"] = "Successfully kicked member from gang!",
    ["gangKickFailAdmin"] = "Failed to kick member from gang!",
    ["gangSetRankSuccessAdmin"] = "Successfully set rank of member!",
    ["gangSetRankFailAdmin"] = "Failed to set rank of member!",
    ["gangMemberAlreadyOwner"] = "This member is already the owner of this gang!",
    ["gangNotMember"] = "This player is not a member of this gang!",
    ["gangOwnershipTransferedAdmin"] = "Successfully transfered gang ownership!",
    ["gangDeleteAdminQuery"] = "Deleting a gang cannot be undone, type %s to delete it.",
    ["gangDeleteSuccessAdmin"] = "Successfully deleted the gang %s!",
    ["gangMenuBind"] = "Gang Menu Bind",

    ["gangTerritoryBeingCaptured"] = "Your gang territory %s is being captured!",
    ["gangXMessage"] = "%d MESSAGE",
    ["gangXMessages"] = "%d MESSAGES",
    ["gangInfo"] = "GANG INFO",
    ["gangMessageDisabled"] = "The gang chat is currently disabled.",
    ["gangPrinters"] = "Printers",
    ["gangPurchasePrinters"] = "Purchase printers",
    ["gangUpgradePrinters"] = "Upgrade printers",
    ["gangPlacePrinters"] = "Place printers",
    ["gangPrinterUpgrades"] = "Printer Upgrades",

    ["gangRankLimit"] = "You have reached the rank limit of %d!",
    ["gangRankLowLimit"] = "You must have at least 1 rank!"
} )
--PATH addons/____bricks_gangs/lua/bricks_server/languages/bricks_gangs/turkish.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "turkish", {
    ["gang"] = "Çete",
    ["gangNew"] = "Yeni Çete",
    ["gangRequestCooldown"] = "Daha fazla çete için lütfen bekleyiniz!",
    ["gangRequestDataCooldown"] = "Başka bi çete hakkında veri edinmek için lütfen biraz bekleyiniz!",
    ["gangNewUpgrade"] = "Yeni Geliştirme",
    ["gangUpgradeTierEdit"] = "%s - Seviye %d",
    ["gangNewAchievement"] = "Yeni Başarı",
    ["gangNewTerritory"] = "Yeni Bölge",
    ["gangRewardTime"] = "Ödül Zamanı",
    ["gangRewardTimeQuery"] = "Ele geçiren çete ne kadar kazansın?",
    ["gangRewards"] = "Ödüller",
    ["gangNewLeaderboard"] = "Yeni Liderlik Tablosu",
    ["gangRankQuery"] = "Hangi rütbeye ayarlamak istiyorsun?",
    ["gangPlayerAlreadyRank"] = "Bu oyuncu zaten bu rütbeye sahip!",
    ["gangInvalidRank"] = "Geçersiz rütbe.",
    ["gangKick"] = "At",
    ["gangKickConfirm"] = "Bu üyeyi atmak istediğine emin misin?",
    ["gangSetOwner"] = "Sahip Ayarla",

    ["gangInbox"] = "ÇETE KUTUSU",
    ["gangNoNotifications"] = "Hiç bildiriminiz yok!",
    ["gangTimeAgo"] = "%s geçe",
    ["gangNotification"] = "Çete Bildirimleri",
    ["gangNotificationHeader"] = "Baştaki bildirim ne olsun?",
    ["gangAdminNotification"] = "Admin Bildirimi",
    ["gangNotificationBody"] = "Ana bildirimler neler olsun?",
    ["gangAdminNotificationSent"] = "Admin çete bildirimleri %s'ya gönderildi!",

    ["gangVariablesFull"] = "Çete Değişkenleri",
    ["gangUpgradesFull"] = "Çete Geliştirmeleri",
    ["gangAchievementsFull"] = "Çete Başvuruları",
    ["gangTerritoriesFull"] = "Çete Bölgeleri",
    ["gangLeaderboardsFull"] = "Çete Liderlik Tablosu",

    ["gangClaimedAchievement"] = "Başarım ödülleri alındı!",
    ["gangAlreadyAssociation"] = "Başka bir çeteyle böyle bir tür bağlantıya sahipsiniz!",
    ["gangAlreadySentAssociation"] = "Çeten zaten diğer çeteye bir bağlantı isteği attı!",
    ["gangAssociationSent"] = "Bağlantı isteği atıldı!",
    ["gangAssociationAccepted"] = "Bağlantı isteği kabul edildi!",
    ["gangNoAssociation"] = "Çeten bu çete ile bağlantı içerisinde değil!",
    ["gangAssociationDissolved"] = "Bağlantınız bitirildi!",

    ["gangOwner"] = "Sahip",
    ["gangOfficer"] = "Subay",
    ["gangMember"] = "Üye",

    ["gangCannotDeposit"] = "Bu silahı depolayamazsın!",
    ["gangStorageFullError"] = "Çetenizin deposu full!",
    ["gangDepositedItem"] = "Çetenizin deposuna bir eşya koydun!",
    ["gangDroppedItem"] = "Çetenin deposundan 1 tane eşya bıraktınız.",
    ["gangUsedItem"] = "Çetenin deposundan eşya kullandın.",
    ["gangCantUse"] = "Bunu kullanamazsın!",

    ["gangKicked"] = "%s çetesinden atıldın!",
    ["gangAlreadyIn"] = "Zaten bir çetede bulunuyorsun!",
    ["gangNameLength"] = "Çete ismi %d karakterden fazla olamaz!",
    ["gangIconLength"] = "Çete ikonunun URL'si %d karakterden fazla olamaz!",
    ["gangCreatedFor"] = "Yeni çeten %s karşılığında kuruldu!",
    ["gangCreated"] = "Yeni çeten kuruldu!",
    ["gangCreationNoMoney"] = "Yeterli paran yok, %s'a ihtiyacın var!",
    ["gangWaitBeforeSaving"] = "Ayarları kaydetmek için lütfen %d dakika bekleyin!",
    ["gangRolesUpdated"] = "Çete Rolleri Güncellendi!",
    ["gangCannotTarget"] = "Bu oyuncuyu hedef alamazsın!",
    ["gangRankNotExists"] = "Bu rütbe bulunmamakta!",
    ["gangCantPromote"] = "Başka birini kendinden daha yüksek bir rütbeye çıkartamazsın!",
    ["gangRankSet"] = "Rütbe başarıyla ayarlandı!",
    ["gangRankSetFail"] = "Rütbe ayarlanırken ahta çıktı!",
    ["gangSettingsUpdated"] = "Çete ayarları güncellendi!",
    ["gangPlayerKicked"] = "%s'yı çeteden kovdun!",
    ["gangPlayerKickError"] = "Çete üyesini atarken hata oluştu!",
    ["gangWaitBeforeInvite"] = "Diğer oyuncuları davet etmeden önce 5 saniye bekleyin!",
    ["gangPlayerOffline"] = "Bu oyuncu çevrimiçi değil!",
    ["gangPlayerAlreadyInvited"] = "Bu oyuncu zaten davet edildi!",
    ["gangPlayerInvited"] = "%s'yı çetene davet ettin!",
    ["gangInviteReceived"] = "%s çetesine davet edildin! !gang yazarak kabul et.",
    ["gangLeaveCurrent"] = "İlk başta şu anki çetenden ayrılman lazım!",
    ["gangReachedMemberLimit"] = "Çeten üye limitine ulaştı!",
    ["gangJoined"] = "%s'ya başarıyla katıldın!",
    ["gangNotEnoughMoney"] = "Yeterli paran yok!",
    ["gangDepositedMoney"] = "%s'yı çetene depoladın!",
    ["gangWithdrewMoney"] = "%s'yı çetenden çektin!",
    ["gangDisbanded"] = "%s'yı dağıttın!",
    ["gangOwnershipTransfered"] = "%s'nın sahipliğini başarıyla %s'ya aktardın!",
    ["gangLeft"] = "%s'dan ayrıldın!",

    ["gangTerritoryCaptured"] = "Çeten %s bölgesini ele geçirdi!",
    ["gangIncorrectLevel"] = "Çeten bu geliştirmeyi almak için yeterli seviyeye sahip değil!",
    ["gangIncorrectGroup"] = "Bu güncellemeyi almak için doğru grupta değilsin!",
    ["gangUpgradeBought"] = "Geliştirme %s karşılığında alındı!",
    ["gangNotEnoughFunds"] = "Çetenin bu geliştirmeye yetecek parası yok!",

    ["gangAddAchievement"] = "Başarım Ekle",
    ["gangNewAchievementType"] = "Başarımın türü ne olsun?",
    ["gangAddLeaderboard"] = "Liderlik Tahtası Ekle",
    ["gangNewLeaderboardType"] = "Liderlik Tablosunun türü ne olsun?",
    ["gangAddTerritory"] = "Bölge Ekle",
    ["gangAddTier"] = "Seviye Ekle",
    ["gangTierX"] = "Aşama %d",
    ["gangNewUpgradeType"] = "Yeni güncelleme türü ne olsun?",
    ["gangNewUpgradeDesc"] = "Yeni güncelleme açıklaması.",

    ["gangDepositMenu"] = "Çete Depolama Menüsü",
    ["gangDepositInventoryQuery"] = "%s'yı envanterinden buraya depolamak istediğine emin misin?",
    ["gangDepositPlayerQuery"] = "Oyuncunun ekipmanlarından %s'yı depolamak istediğine emin misin?",
    ["gangNoDepositItems"] = "Depolayılacak herhangi bir ekipmana sahip değilsin!",

    ["gangMenu"] = "Çete Menüsü",
    ["gangNone"] = "Çete Yok",
    ["gangID"] = "Kimlik: %d",
    ["gangDashboard"] = "Gösterge Tablosu",
    ["gangMembers"] = "Üyeler",
    ["gangStorage"] = "Depo",
    ["gangUpgrades"] = "Geliştirmeler",
    ["gangBalance"] = "Bakiye",
    ["gangAchievements"] = "Başarımlar",
    ["gangAssociations"] = "Bağlantılar",
    ["gangLeaderboards"] = "Liderlik Tabloları",
    ["gangTerritories"] = "Bölgeler",
    ["gangRanks"] = "Rütbeler",
    ["gangCreate"] = "Çete Oluştur",
    ["gangProgress"] = "İlerleme: %s",

    ["gangNoneFound"] = "Aradığın çete bulunamadı.",
    ["gangMemberCount"] = "%d/%d Üye",
    ["gangFailedToLoad"] = "Çete verisi yüklenirken hata oluştu!",
    ["gangSetRank"] = "Rütbe ayarla",
    ["gangDissolveAssociation"] = "Bu bağlantıyı bozmak istediğine emin misin?",
    ["gangAssociationStatus"] = "Durum: %s",
    ["gangNeutral"] = "Nötr",
    ["gangCreateString"] = "%s karşılığında çete kur",
    ["gangName"] = "Çete İsmi:",
    ["gangIcon"] = "Ikon URL'si:",
    
    ["gangInformation"] = "ÇETE BİLGİSİ",
    ["gangChat"] = "ÇETE SOHBETİ",
    ["gangMessage"] = "Çeteye Mesaj Gönder",
    ["gangActions"] = "ÇETE EYLEMLERİ",
    ["gangDepositMoney"] = "Para depola",
    ["gangDepositMoneyQuery"] = "Ne kadar depolamak istiyorsun?",
    ["gangDepositMoneyLess"] = "%s'nın altında bir miktar depolayamazsın!",
    ["gangDepositMoneyMuch"] = "Çete bu kadar bakiyeyi taşıyamaz, bakiyenin deposunu geliştirmen lazım!",
    ["gangWithdrawMoney"] = "Para çek",
    ["gangWithdrawMoneyQuery"] = "Ne kadar çekmek istiyorsun?",
    ["gangWithdrawMoneyLess"] = "%s'nın altında bir miktar çekemezsin!",
    ["gangWithdrawMoneyMuch"] = "Çeten yeterli paraya sahip değil!",
    ["gangInvitePlayer"] = "Oyuncu davet et",
    ["gangInvitePlayerQuery"] = "Kimi davet etmek istiyorsun?",
    ["gangDisband"] = "Çeteyi dağıt",
    ["gangDisbandQuery"] = "Çeteyi silersen birdaha geri getiremezsin, %s yazarak silebilirsin.",
    ["gangTransfer"] = "Sahipliği aktar",
    ["gangTransferQuery"] = "Sahipliği kime aktarmak istiyorsun?",
    ["gangLeave"] = "Çeteden ayrıl",
    ["gangLeaveQuery"] = "Bu çeteden ayrılmak istediğine emin misin?",
    ["gangMemberUpper"] = "ÇETE ÜYELERİ",
    ["gangHighestRank"] = "En Yüksek Rütbe",
    ["gangLowestRank"] = "En Düşük Rütbe",

    ["gangUnsavedChanges"] = "Uyarı! Kaydedilmemiş değişiklikler bulunmakta.",
    ["gangSaveChanges"] = "Değişiklikleri Kaydet",
    ["gangReset"] = "Sıfırla",
    ["gangRanksUpper"] = "ÇETE RÜTBELERİ",
    ["gangNewRank"] = "Yeni Rütbe",
    ["gangRankName"] = "Rütbe İsmi",
    ["gangRankColor"] = "Rütbe Rengi",
    ["gangClearPerms"] = "İzinleri Temizle",
    ["gangDeleteRank"] = "Rütbeyi Sil",
    ["gangDeleteRankQuery"] = "Bu rütbyi silmek istediğine emin misin?",

    ["gangStorageUpper"] = "ÇETE DEPOSU",
    ["gangStorageProgress"] = "Depo %d/%d",
    ["gangClaimed"] = "Alınmış",
    ["gangUnclaimed"] = "Alınmamış",
    ["gangClaimedAgo"] = "%s önce alınmış",
    ["gangRewardsEvery"] = "Bütün %s'lara verildi",
    ["gangBuyUpgrade"] = "Bu geliştirmeyi %s fiyatına almak istediğine emin misin?",
    ["gangUpgradeTier"] = "Gelişme Aşaması %d/%d",
    ["gangCurrent"] = "Şu Anki: %s",
    ["gangNext"] = "Sonraki Aşama: %s",

    ["gangTerritoryUpper"] = "BÖLGE",
    ["gangCaptured"] = "ELE GEÇİRİLMİŞ",
    ["gangTerritoryAlready"] = "Çeten zaten bu bölgeyi ele geçirmiş durumda!",
    ["gangCaptureFail"] = "Bölgeden çok uzaklaştın veya öldün, ele geçirme iptal!",
    ["gangTerritoryPlaced"] = "Bölge başarıyla yerleştirildi.",
    ["gangInvalidTerritory"] = "Geçersiz bölge, aletler menüsünden geçerli birini seçiniz.",
    ["gangTerritoryRemoved"] = "Bölge başarıyla kaldırıldı.",
    ["gangTerritoryRemoveFail"] = "Bu aleti sadece bölge kaldırma/oluşturma işlemlerinde kullanabilirsin.",
    ["gangTerritoryDesc"] = "Sunucuya Bölge Ekleme ve Kaldırma İşlemlerini Yapar, Sol Tık - yerleştir, Sağ Tık - kaldır.",
    ["gangTerritory"] = "Bölge",
    ["gangTerritoryPlacer"] = "Bölge yerleştiricisi",
    ["gangTerritoryDescSmall"] = "Sunucuya bölge yerleştirip kaldırtır.",
    ["gangTerritoryInstructions"] = "Sol Tık - yerleştir, Sağ Tık - kaldır.",

    ["gangSettings"] = "Ayarlar",
    ["gangManagement"] = "Yönetim",
    ["gangChatLower"] = "Çete Sohbeti",
    ["gangDepositItems"] = "Eşya depola",
    ["gangWithdrawItems"] = "Eşya çek",
    ["gangViewStorage"] = "Depoyu görüntüle",
    ["gangEditRoles"] = "Rolleri düzenle",
    ["gangEditSettings"] = "Ayarları düzenle",
    ["gangInvitePlayers"] = "Oyuncu davet et",
    ["gangKickPlayers"] = "Oyuncu at",
    ["gangChangeRank"] = "Oyuncuların' rütbesini değiştir",
    ["gangPurchaseUpgrades"] = "Geliştirme satın al",
    ["gangAcceptDeclineInbox"] = "Gelen kutusu bildirimlerini Kabul Et/Reddet",
    ["gangAssociationSend"] = "Bağlantı isteklerini gönder",
    ["gangAssociationAccept"] = "Bağlantı isteklerini kabul et",
    ["gangSendChatMessages"] = "Sohbet mesajı gönder",
    ["gangMaxMembers"] = "Maksimum Üye",
    ["gangMaxBalance"] = "Maksimum Bakiye",
    ["gangStorageSlots"] = "Depo Yuvaları",
    ["gangXSlots"] = "%d Yuva",
    ["gangSlots"] = "Yuvalar",
    ["gangIncreasedHealth"] = "Arttırılmış Sağlık",
    ["gangExtraHealth"] = "Ekstra Sağlık",
    ["gangXHP"] = "+%d SP",
    ["gangIncreasedArmor"] = "Yükseltilmiş Zırh",
    ["gangXAP"] = "+%d ZP",
    ["gangExtraArmor"] = "Ekstra Zırh",
    ["gangIncreasedSalary"] = "Arttırılmış Maaş",
    ["gangExtraSalary"] = "Ekstra Maaş",
    ["gangPermWeapon"] = "Kalıcı Silah",
    ["gangWeapon"] = "Silah",
    ["gangBalanceFull"] = "Çete Bakiyesi",
    ["gangMembersFull"] = "Çete Üyeleri",
    ["gangStorageFull"] = "Çete Deposu",
    ["gangItems"] = "Eşyalar",
    ["gangItem"] = "Eşya",
    ["gangLevel"] = "Çete Seviyesi",
    ["gangInvite"] = "Çete Daveti",
    ["gangInviteReceivedInbox"] = "%s çetesine davet edildin!",
    ["gangAssociationInvite"] = "Bağlantı Daveti",
    ["gangAssociationInviteInbox"] = "Çeten %s '%s' ile bağlantı kurmak için istek atmış bulunmakta!",
    ["gangAssociationCreated"] = "Bağlantı Kuruldu",
    ["gangAssociationCreatedInbox"] = "Çeten artık '%s' ile %s çetesiyle bağlantı içinde!",
    ["gangAssociationDissolved"] = "Bağlantı Bitirildi",
    ["gangAssociationDissolvedInbox"] = "%s çetesiyle olan bağlantın bozuldu!",
    ["gangInboxAchievement"] = "Çete Başarımları",
    ["gangInboxAchievementCompleted"] = "Çeten '%s' başarımını bitirdi!",
    ["gangInboxAchievementCompletedReward"] = "Çeten '%s' başarımını bitirdi, ödüller: %s!",
    ["gangExperienceFull"] = "Çete Tecrübesi",
    ["gangJobWhitelist"] = "Meslek Beyaz Listesi",
    ["gangJobs"] = "Meslekler",
    ["gangJobsSelect"] = "Beyaz Listeye alınacak meslekleri seçiniz.",
    ["gangStorageItems"] = "Depo Eşyaları",
    ["gangAllyRequest"] = "Bu çete ile dost olmak istiyor musun?",
    ["gangWarRequest"] = "Bu çeteyle savşa girmek istiyor musun?",
    ["gangSetLevel"] = "Seviye Ayarla",
    ["gangSetLevelQuery"] = "Çetenin yeni seviyesi ne olsun?",
    ["gangSetLevelMsg"] = "Çetenin seviyesini %s'dan %d'ya ayarladın!",
    ["gangAddExperience"] = "Tecrübe Puanı Ekle",
    ["gangAddExperienceQuery"] = "Çeteye ne kadar TP eklensin?",
    ["gangAddExperienceMsg"] = "%s tecrübe puanı başarıyla %s çetesine verildi!",
    ["gangSetBalance"] = "Bakiye ayarla",
    ["gangSetBalanceQuery"] = "Çetenin yeni bakiyesi ne olarak ayarlansın?",
    ["gangSetBalanceMsg"] = "Çetenin yeni bakiyesi %s'dan %s'ya ayarlandı!",
    ["gangAddBalance"] = "Bakiye Ekle",
    ["gangAddBalanceQuery"] = "Çetenin bakiyesine ne kadar para eklemek istiyorsun?",
    ["gangAddBalanceMsg"] = "%s miktarda para başarıyla %s çetesine eklendi!",
    ["gangViewMembers"] = "Üyeleri Göster",
    ["gangCantKickOwner"] = "Çetenin sahibin atamazsın!",
    ["gangKickSuccessAdmin"] = "Üye çeteden başarıyla kovuldu!",
    ["gangKickFailAdmin"] = "Üye çeteden atılırken hata oluşturdu!",
    ["gangSetRankSuccessAdmin"] = "Üyenin rütbesi ayarlandı!",
    ["gangSetRankFailAdmin"] = "Üyenin rütbesi ayarlanırken bir hata oluştu!",
    ["gangMemberAlreadyOwner"] = "Bu üye zaten çetenin kurucusu!",
    ["gangNotMember"] = "Bu oyuncu çetenin bir üyesi değil!",
    ["gangOwnershipTransferedAdmin"] = "Çete sahipliği başarıyla aktarıldı!",
    ["gangDeleteAdminQuery"] = "Çete silme işlemi geri alınamaz, %s yazarak sil.",
    ["gangDeleteSuccessAdmin"] = "%s çetesi başarıyla silindi!",
    ["gangMenuBind"] = "Çete Menüsü Atama",

    ["gangTerritoryBeingCaptured"] = "Çetenin bölgesi olan %s ele geçiriliyor!",
} )
--PATH addons/____bricks_gangs/lua/bricks_server/languages/bricks_gangs/ukrainian.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "ukrainian", {
    ["gang"] = "Банда",
    ["gangNew"] = "Створити банду",
    ["gangRequestCooldown"] = "Будь Ласка зачекайте, перед тим запросити другие банди!",
    ["gangRequestDataCooldown"] = "Будь Ласка зачекайте, перед тим запросити данную про банди!",
    ["gangNewUpgrade"] = "Нове улучшение",
    ["gangUpgradeTierEdit"] = "%s - Лвл %d",
    ["gangNewAchievement"] = "Нове досягненя",
    ["gangNewTerritory"] = "Нове Тереторiя",
    ["gangRewardTime"] = "Время приза",
    ["gangRewardTimeQuery"] = "Как часто банда которая одержала терреторию, должна получать награди?",
    ["gangRewards"] = "Награди",
    ["gangNewLeaderboard"] = "Нове меню лiдеров",
    ["gangRankQuery"] = "Який ранг ви хотели би установить?",
    ["gangPlayerAlreadyRank"] = "Данний игрок вже имеет данний ранг!",
    ["gangInvalidRank"] = "Неверний ранг.",
    ["gangKick"] = "Вигнать",
    ["gangKickConfirm"] = "Ви уверени что хотите вигнать данного игрока?",
    ["gangSetOwner"] = "Установить владельца",

    ["gangInbox"] = "Крiмiнальна почта",
    ["gangNoNotifications"] = "У вас нет нових уведомлений!",
    ["gangTimeAgo"] = "%s назад",
    ["gangNotification"] = "Нове уведомление",
    ["gangNotificationHeader"] = "Який будет заголовок повiдомленя?",
    ["gangAdminNotification"] = "Админское уведомление",
    ["gangNotificationBody"] = "Что ви напишите в основной части повiдомленя?",
    ["gangAdminNotificationSent"] = "Админское уведомление отправлено %s!",

    ["gangVariables"] = "Вариации Банди",
    ["gangUpgrades"] = "Оновленя банди",
    ["gangAchievements"] = "Досягненя банди",
    ["gangTerritories"] = "Тереторiя банди",
    ["gangLeaderboards"] = "Доска лiдеров",

    ["gangClaimedAchievement"] = "Успiх!, получено досягненя!",
    ["gangAlreadyAssociation"] = "Ваша банда вже имеет такой тип связи с другой бандой!",
    ["gangAlreadySentAssociation"] = "Ваша банда вже отправила им приглашение, в ассоциацию!",
    ["gangAssociationSent"] = "Приглашение ассоциации отправлено!",
    ["gangAssociationAccepted"] = "Приглашение ассоциации принято!",
    ["gangNoAssociation"] = "Ваша банда не имеет никакого отношения к этой банде!",
    ["gangAssociationDissolved"] = "Ассоциация распущена!",

    ["gangOwner"] = "Владелец",
    ["gangOfficer"] = "Офицер",
    ["gangMember"] = "Участник",

    ["gangCannotDeposit"] = "Ви не можете положить это оружие!",
    ["gangStorageFull"] = "Хранилище банди переполнено!",
    ["gangDepositedItem"] = "Ви поклали предмет в хранилище банди!",
    ["gangDroppedItem"] = "Виброшено 1 предмет из вашего хранилища банди.",
    ["gangUsedItem"] = "Использован 1 предмет из вашего хранилища банди.",
    ["gangCantUse"] = "Ви не можете использовать это!",

    ["gangKicked"] = "Вас вигнали из банди %s!",
    ["gangAlreadyIn"] = "Ви вже в банде!",
    ["gangNameLength"] = "Название банди не может бить длиннее %d символов!",
    ["gangIconLength"] = "URL значка банди не может бить длиннее %d символов!",
    ["gangCreatedFor"] = "Ваша Нове банда била создана для %s!",
    ["gangCreated"] = "Ваша банда создана!",
    ["gangCreationNoMoney"] = "Вам не хватает денег, вам нужно %s!",
    ["gangWaitBeforeSaving"] = "Будь Ласка, зачекайте %d секунд, перед тим чем сохранить изменения!",
    ["gangRolesUpdated"] = "Ранги банди обновлени!",
    ["gangCannotTarget"] = "Ви не можете трогать его!",
    ["gangRankNotExists"] = "Данний ранг не найден!",
    ["gangCantPromote"] = "Ви не можете повисить кого-либо на Лвл више, или такой же как у вас!",
    ["gangRankSet"] = "Ранг Успiх! установлен!",
    ["gangRankSetFail"] = "Не удалось установить ранг!",
    ["gangSettingsUpdated"] = "Настройки банди обновлени!",
    ["gangPlayerKicked"] = "Удачно вигнан %s с вашей банди!",
    ["gangPlayerKickError"] = "Ошибка при изгнании учасника!",
    ["gangWaitBeforeInvite"] = "Будь Ласка, зачекайте 5 секунд перед тим чем Пригласити другого игрока!",
    ["gangPlayerOffline"] = "Этот игрок больше не в сети!",
    ["gangPlayerAlreadyInvited"] = "Этот игрок вже имеет активное приглашение!",
    ["gangPlayerInvited"] = "Ви пригласили, %s в вашу банду!",
    ["gangInviteReceived"] = "Ви били приглашени в банду %s! Введите !gang даби принять.",
    ["gangLeaveCurrent"] = "Ви должни покинуть свою текущую банду в первую очередь!",
    ["gangReachedMemberLimit"] = "Банда достигла предела своих участников!",
    ["gangJoined"] = "Успiх! вступили в %s!",
    ["gangNotEnoughMoney"] = "Вам не хватает денег!",
    ["gangDepositedMoney"] = "Ви Успiх! внесли %s в вашу банду!",
    ["gangWithdrewMoney"] = "Ви Успiх! сняли %s с вашей банди!",
    ["gangDisbanded"] = "Ваша банда Успiх! распущена %s!",
    ["gangOwnershipTransfered"] = "Успiх! передано право владения банди с %s на %s!",
    ["gangLeft"] = "Ви покинули %s!",

    ["gangTerritoryCaptured"] = "Ваша банда захватила %s территорию!",
    ["gangIncorrectLevel"] = "Ваша банда не имеет нужний Лвл, чтоби купить это обновление!",
    ["gangIncorrectGroup"] = "Ви не подходящая группа, чтоби купить это обновление!",
    ["gangUpgradeBought"] = "Обновление куплено для банди %s!",
    ["gangNotEnoughFunds"] = "У вашей банди недостаточно средств для покупки этого улучшения!",

    ["gangAddAchievement"] = "Добавить досягненя",
    ["gangNewAchievementType"] = "Каким должен бить новий тип достижений?",
    ["gangAddLeaderboard"] = "Добавить таблицу лiдеров",
    ["gangNewLeaderboardType"] = "Каким должен бить новий тип таблици лiдеров??",
    ["gangAddTerritory"] = "Добавить территорию",
    ["gangAddTier"] = "Добавить Лвл",
    ["gangTierX"] = "Лвл %d",
    ["gangNewUpgradeType"] = "Каким должен бить новий тип улучшения?",
    ["gangNewUpgradeDesc"] = "Нове описание улучшения.",

    ["gangDepositMenu"] = "Меню депозита",
    ["gangDepositInventoryQuery"] = "Ви хотите внести депозит %s с вашего инвентаря?",
    ["gangDepositPlayerQuery"] = "Ви хотите внести депозит %s с вашего владения?",
    ["gangNoDepositItems"] = "У вас нет предметов, которие можно сдать на в хранилище банди!",

    ["gangMenu"] = "Меню банди",
    ["gangNone"] = "Нет банди",
    ["gangID"] = "ID: %d",
    ["gangDashboard"] = "Управление",
    ["gangMembers"] = "Участники",
    ["gangStorage"] = "Хранилище",
    ["gangUpgrades"] = "Улучшения",
    ["gangBalance"] = "Баланс",
    ["gangAchievements"] = "Досягненя",
    ["gangAssociations"] = "Ассоциации",
    ["gangLeaderboards"] = "Таблица лiдеров",
    ["gangTerritories"] = "Территории",
    ["gangRanks"] = "Ранги",
    ["gangCreate"] = "Создать банду",
    ["gangProgress"] = "Прогресс: %s",

    ["gangNoneFound"] = "По вашему запросу ничего не найдено.",
    ["gangMemberCount"] = "%d/%d Участники",
    ["gangFailedToLoad"] = "Произошла ошибка при загрузке данних!",
    ["gangSetRank"] = "Установить ранг",
    ["gangDissolveAssociation"] = "Хотели би ви расторгнуть цю ассоциацию??",
    ["gangAssociationStatus"] = "Статус: %s",
    ["gangNeutral"] = "Нейтрально",
    ["gangCreateString"] = "Создать банду для %s",
    ["gangName"] = "Название:",
    ["gangIcon"] = "URL Значка:",
    
    ["gangInformation"] = "ИНФОРМАЦИЯ О БАНДЕ",
    ["gangChat"] = "ЧАТ БАНДи",
    ["gangMessage"] = "Сообщение банди",
    ["gangActions"] = "ДЕЙСТВИЯ БАНДи",
    ["gangDepositMoney"] = "Внести грошi",
    ["gangDepositMoneyQuery"] = "Сколько би ви хотели внести на депозит?",
    ["gangDepositMoneyLess"] = "Ви не можете внести депозит меньше, чем %s!",
    ["gangDepositMoneyMuch"] = "Баланс вашей банди не может вместить так много, ви должни улучшить хранилище баланса!",
    ["gangWithdrawMoney"] = "Снять деньги",
    ["gangWithdrawMoneyQuery"] = "Сколько би ви хотели снять?",
    ["gangWithdrawMoneyLess"] = "Ви не можете снять меньше, чем %s!",
    ["gangWithdrawMoneyMuch"] = "Вашей банде не хватает средств!",
    ["gangInvitePlayer"] = "Пригласити игрока",
    ["gangInvitePlayerQuery"] = "Какого игрока ви би хотели Пригласити?",
    ["gangDisband"] = "Распустити банду",
    ["gangDisbandQuery"] = "Видаленя вашей банди не может бить отменено, введите %s даби Видалити банду.",
    ["gangTransfer"] = "Передать права на банду",
    ["gangTransferQuery"] = "Кому би ви хотели передать права банди?",
    ["gangLeave"] = "Покинуть банду",
    ["gangLeaveQuery"] = "Ви уверени, что хотите покинуть цю банду??",
    ["gangMemberUpper"] = "УЧАСТНИКИ БАНДи",
    ["gangHighestRank"] = "Наивисший ранг",
    ["gangLowestRank"] = "Самий низкий ранг",

    ["gangUnsavedChanges"] = "Внимание! У вас есть несохраненние изменения.",
    ["gangSaveChanges"] = "Сохранить изменения",
    ["gangReset"] = "Сбросить",
    ["gangRanksUpper"] = "РАНГИ БАНДи",
    ["gangNewRank"] = "Новий ранг",
    ["gangRankName"] = "Название ранга",
    ["gangRankColor"] = "Цвет ранга",
    ["gangClearPerms"] = "Очистить права",
    ["gangDeleteRank"] = "Видалити ранг",
    ["gangDeleteRankQuery"] = "Ви уверени, что хотите Видалити этот ранг?",

    ["gangStorageUpper"] = "ХРАНИЛИЩЕ БАНДи",
    ["gangStorageProgress"] = "Заполненость %d/%d",
    ["gangClaimed"] = "Создано",
    ["gangUnclaimed"] = "Не создано",
    ["gangClaimedAgo"] = "Создано %s назад",
    ["gangRewardsEvery"] = "Учитивая каждий %s",
    ["gangBuyUpgrade"] = "Ви хотите купить это обновление для %s?",
    ["gangUpgradeTier"] = "Лвл улучшения %d/%d",
    ["gangCurrent"] = "Текущий Лвл: %s",
    ["gangNext"] = "Следующий Лвл: %s",

    ["gangTerritoryUpper"] = "ТЕРРИТОРИИ",
    ["gangCaptured"] = "ЗАХВАЧЕНО",
    ["gangTerritoryAlready"] = "Ваша банда вже захватила цю территорию!",
    ["gangCaptureFail"] = "Ви отошли слишком далеко или погибли, захват не удался!",
    ["gangTerritoryPlaced"] = "Тереторiя Успiх! размещена.",
    ["gangInvalidTerritory"] = "Неверная Тереторiя, виберите действительную из меню инструментов.",
    ["gangTerritoryRemoved"] = "Тереторiя Успiх! удалена.",
    ["gangTerritoryRemoveFail"] = "Ви можете использовать этот инструмент только для удаления/создания территорий.",
    ["gangTerritoryDesc"] = "Розмiшюе и видаляе территории с Brick's Gangs. Щелкните левой кнопкой миши - поместите, щелкните правой кнопкой миши - удалите.",
    ["gangTerritory"] = "Тереторiя",
    ["gangTerritoryPlacer"] = "Место территории",
    ["gangTerritoryDescSmall"] = "Розмiшюе i видаляе территории с сервера Брик.",
    ["gangTerritoryInstructions"] = "Левий клик - розмiстити, правий клик - Видалити.",

    ["gangSettings"] = "Налаштуваня",
    ["gangManagement"] = "Керуваня",
    ["gangChatLower"] = "Чат банди",
    ["gangDepositItems"] = "Депозит предметами",
    ["gangWithdrawItems"] = "Забрать предмети",
    ["gangViewStorage"] = "Посмотреть хранилище",
    ["gangEditRoles"] = "Изменить ранги",
    ["gangEditSettings"] = "Изменить настройки",
    ["gangInvitePlayers"] = "Пригласити игроков",
    ["gangKickPlayers"] = "Вигнать игроков",
    ["gangChangeRank"] = "Изменить ранг игрока",
    ["gangPurchaseUpgrades"] = "Купить улучшение",
    ["gangAcceptDeclineInbox"] = "Принять или отклонить входящие повiдомленя",
    ["gangAssociationSend"] = "Отправить запроси на ассоциацию",
    ["gangAssociationAccept"] = "Принять запроси на ассоциацию",
    ["gangSendChatMessages"] = "Отправить сообщение в чат",
    ["gangMaxMembers"] = "Макс. Участников",
    ["gangMaxBalance"] = "Макс. Баланс",
    ["gangStorageSlots"] = "Слоти хранилища",
    ["gangXSlots"] = "%d Слотов",
    ["gangSlots"] = "Слотов",
    ["gangIncreasedHealth"] = "Увеличение здоровья",
    ["gangExtraHealth"] = "Дополнительное здоровье",
    ["gangXHP"] = "+%d ХП",
    ["gangIncreasedArmor"] = "Усиленная броня",
    ["gangXAP"] = "+%d ЗАЩИТи",
    ["gangExtraArmor"] = "Дополнительная броня",
    ["gangIncreasedSalary"] = "Увеличение зарплати",
    ["gangExtraSalary"] = "Дополнительная зарплата",
    ["gangPermWeapon"] = "Вечное оружие",
    ["gangWeapon"] = "Оружие",
    ["gangBalanceFull"] = "Баланс банди",
    ["gangMembersFull"] = "Участники банди",
    ["gangStorageFull"] = "Хранилище банди",
    ["gangItems"] = "Предмети",
    ["gangItem"] = "Предмет",
    ["gangLevel"] = "Лвл банди",
    ["gangInvite"] = "Пригласити в банду",
    ["gangInviteReceivedInbox"] = "Вас пригласили вступить в банду %s!",
    ["gangAssociationInvite"] = "Приглашение ассоциации",
    ["gangAssociationInviteInbox"] = "Банда %s запросила ассоциацию '%s' с вашей бандой!",
    ["gangAssociationCreated"] = "Ассоциация создана",
    ["gangAssociationCreatedInbox"] = "Ваша банда теперь имеет ассоциацию '%s' с бандой %s!",
    ["gangAssociationDissolved"] = "Ассоциация распущена",
    ["gangAssociationDissolvedInbox"] = "Ваша связь с бандой %s распущена!",
    ["gangInboxAchievement"] = "досягненя банди",
    ["gangInboxAchievementCompleted"] = "Ваша банда завершила '%s' досягненя!",
    ["gangInboxAchievementCompletedReward"] = "Ваша банда завершила '%s' досягненя, ваша награда: %s!",
    ["gangExperienceFull"] = "Опит банди",
    ["gangJobWhitelist"] = "Белий список профессий",
    ["gangJobs"] = "Работи",
    ["gangJobsSelect"] = "Виберите команди, в которих игроки занесени в белий список.",
    ["gangStorageItems"] = "Хранение предметов",
    ["gangAllyRequest"] = "Ви уверени, что хотите запросити союз с этой бандой?",
    ["gangWarRequest"] = "Ви уверени, что хотите запросити войну с этой бандой?",
    ["gangSetLevel"] = "Установить Лвл",
    ["gangSetLevelQuery"] = "Каким должен бить новий Лвл банди?",
    ["gangSetLevelMsg"] = "Успiх! установлен Лвл банди с %s на %d!",
    ["gangAddExperience"] = "Добавить опит",
    ["gangAddExperienceQuery"] = "Який опит ви би хотели добавить в банду?",
    ["gangAddExperienceMsg"] = "Успiх! добавил %s опита в банду %s!",
    ["gangSetBalance"] = "Установить баланс",
    ["gangSetBalanceQuery"] = "Каким должен бить новий баланс банди?",
    ["gangSetBalanceMsg"] = "Успiх! установлен баланс банди с %s на %s!",
    ["gangAddBalance"] = "Добавить баланс",
    ["gangAddBalanceQuery"] = "Сколько денег ви хотели би добавить на баланс банди?",
    ["gangAddBalanceMsg"] = "Успiх! добавлено %s баланс для банди %s!",
    ["gangViewMembers"] = "Просмотр участников",
    ["gangCantKickOwner"] = "Ви не можете вигнать владельца банди!",
    ["gangKickSuccessAdmin"] = "Успiх! вигнали участника из банди!",
    ["gangKickFailAdmin"] = "Не удалось вигнать участника из банди!",
    ["gangSetRankSuccessAdmin"] = "Успiх! установить ранг участника!",
    ["gangSetRankFailAdmin"] = "Не удалось установить ранг участника!",
    ["gangMemberAlreadyOwner"] = "Этот участник вже является владельцем этой банди!",
    ["gangNotMember"] = "Этот игрок не является участником этой банди!",
    ["gangOwnershipTransferedAdmin"] = "Успiх! передани права на банду!",
    ["gangDeleteAdminQuery"] = "Видаленя банди не может бить отменено, введите %s даби Видалити.",
    ["gangDeleteSuccessAdmin"] = "Успiх! удалили банду %s!",
    ["gangMenuBind"] = "Хоткей(Бинд) для меню банди",
} )
--PATH addons/____bricks_framework/lua/bricks_server/languages/bricks_server/polish.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "polish", {
    ["search"] = "Szukaj",
    ["invalidPlayerProfile"] = "Niewłaściwy profil gracza!",
    ["unbound"] = "ROZWIĄZANY",
    ["themes"] = "Motywy",
    ["groups"] = "Grupy",
    ["general"] = "Główne",
    ["itemWhitelisting"] = "Itemy białej listy",
    ["rarities"] = "Rarytasy",
    ["languages"] = "Języki",
    ["disabled"] = "Wyłączono",
    ["enabled"] = "Włączono",
    ["purchase"] = "Zakup",
    ["profile"] = "Profil",
    ["view"] = "Widok",
    ["admin"] = "Admin",
    ["noToolPermission"] = "Nie masz pozwolenia aby używać tego narzędzia.",
    ["settings"] = "Ustawienia",
    ["players"] = "Gracze",
    ["modules"] = "Moduły",
 
    ["userGroupEditor"] = "Edytor grup użytkowników",
    ["addNewGroup"] = "Dodaj nową grupe",
    ["newUserGroup"] = "Jaka powinna być nowa grupa?",
    ["groupName"] = "Nazwa grupy",
 
    ["custom"] = "Niestandardowe",
    ["addNew"] = "Dodaj nowe",
    ["material"] = "Materiał",
    ["directImage"] = "Wpisz URL obrazka .",
    ["default"] = "Podstawowe",
    ["selectMaterial"] = "Musisz wybrać materiał!",
 
    ["errorNoText"] = "BŁĄD: BRAK TEXTU",
    ["selectOption"] = "Wybierz opcje",
    ["selectValue"] = "Prosze wybierz wartość.",
    ["selectColor"] = "Prosze wybierz kolor.",
    ["configSaved"] = "Konfiguracja zapisana!",
    ["cmdNoPermission"] = "Nie masz uprawnień na urzycie tej komendy.",
    ["entityPosUpdated"] = "Zuaktualizowano pozycje jednostki.",
    ["noEntitiesSpawned"] = "Nie pojawiły się żadne zapisane jednostki.",
    ["xEntitiesSpawned"] = "%d zapisanych jednostek zespawnowało się.",
    ["error"] = "ERROR",
 
    ["seconds"] = "%d sekund",
    ["second"] = "%d sekunda",
    ["minutes"] = "%d minut",
    ["minute"] = "%d minuta",
    ["hours"] = "%d godzin",
    ["hour"] = "%d godzina",
 
    ["noRarity"] = "No rarity",
 
    ["config"] = "Konfiguracja",
    ["edit"] = "Edytuj",
    ["editColor"] = "Edytuj kolor",
    ["editName"] = "Edytuj nazwe",
    ["remove"] = "Usuń",
    ["name"] = "Nazwa",
    ["description"] = "Opis",
    ["model"] = "Model",
    ["icon"] = "Ikona",
    ["type"] = "Rodzaj",
    ["price"] = "Cena",
    ["group"] = "Grupa",
    ["category"] = "Kategorja",
    ["color"] = "Kolor",
    ["invalidType"] = "Nieprawidłowy rodzaj.",
    ["invalidOption"] = "Nieprawodłowa opcja.",
    ["invalidChoice"] = "Nieprawidłowy wybór.",
    ["invalidGroup"] = "Nieprawidłowa grupa.",
    ["invalidPlayer"] = "Nieprawidłowy gracz.",
    ["true"] = "PRAWDA",
    ["false"] = "FAŁSZ",
    ["noDescription"] = "Brak opisu",
    ["other"] = "inne",
    ["completed"] = "Ukończone",
    ["close"] = "Zamknij",
    ["main"] = "Menu",
 
    ["valueQuery"] = "Jak powinno wyglądać %s to?",
    ["dataValueQuery"] = "Jakim plikiem powinno to być?",
    ["newNameQuery"] = "Jakie powinno być nowe imie?",
    ["newDescriptionQuery"] = "Jaki powinien być nowy opis?",
    ["newModelQuery"] = "Jaki powinien być nowy model?",
    ["newIconQuery"] = "Jaka powinna być nowa ikona?",
    ["newColorQuery"] = "Jaki powiien być nowy kolor?",
    ["npcTypeQuery"] = "Jakiego rodzaju powinien być ten NPC?",
    ["newTypeQuery"] = "Jaki powinien być nowy rodzaj",
    ["groupRequirementQuery"] = "Jakie powinny być wymagania grupy?",
    ["levelRequirementQuery"] = "Jaki powinien być wymagany lvl?",
    ["newPriceQuery"] = "Jaka powinna być nowa cena?",
    ["newCategoryQuery"] = "Jaka powinna być now akategoria?",
 
    ["npcEditor"] = "Edytor NPC",
    ["addNPC"] = "Dodaj NPC",
    ["newNPC"] = "Nowy NPC",
 
    ["ok"] = "OK",
    ["cancel"] = "Anuluj",
    ["save"] = "Zapisz",
    ["confirm"] = "Potwierdz",
    ["nil"] = "NIL",
    ["none"] = "Żaden",
    ["selected"] = "Wybrany",
    ["unselected"] = "Nie zaznaczone",
    ["add"] = "Dodaj",
 
    ["shootyStick"] = "A shooty stick!",
    ["permanent"] = "Na stałe",
    ["tierX"] = "(Tier %d)",
    ["someDescription"] = "Opis.",
    ["invalidNPC"] = "BŁAD BRICK SERVER: Nieprawidłowy NPC",
 
    ["disconnected"] = "Rozłączono",
    ["profileView"] = "Widok profilu",
    ["loading"] = "Wczytywanie",
    ["statistics"] = "Statystyki",
    ["steamID64"] = "SteamID64",
    ["donationRank"] = "Rnga darczyńcy",
    ["staffRank"] = "Ranga personelu",
    ["currentJob"] = "Obecna praca",
    ["wallet"] = "Portfel",
    ["level"] = "Poziom",
    ["levelX"] = "Poziom %d",
    ["experience"] = "Doświadczenie",
    ["exp"] = "EXP",
    ["money"] = "Pieniądze",
    ["playerLogs"] = "Dziennik gracza",
    ["deleteLogs"] = "Usuń dziennik",
    ["xLogs"] = "%d logs",
    ["xAdminGroups"] = "%d Grup adminów",
    ["noUserGroups"] = "No Grup użytkownikó",
    ["userGroups"] = "Grupy użytkowników: %s",
    ["editUserGroups"] = "Edytuj grupy użytkowników",
    ["newGroupColor"] = "Jaki powinien być nowy kolor grupy?",
    ["newGroupName"] = "Jaka powinna być nowa nazwa grupy?",
    ["groupAlreadyExists"] = "Ta grupa już istnieje!",
    ["whitelist"] = "Biała lista",
    ["unWhitelist"] = "Usuń z białej listy",
    ["addCustom"] = "Dodaj niestandardową",
    ["entClassWhitelist"] = "Jaką klase jednostek chciałbyś wprowadzić na białą liste?",
    ["entClassAlreadyOnList"] = "Ta klasa jednostek jest już na liscie!",
    ["changesServerRestart"] = "Niektóre zmiany nie będą działały do póki nie zresetujesz serwera!",
    ["comingSoon"] = "Zaraz będzie!",
    ["features"] = "CECHY",
    ["addNewRarity"] = "Dodaj nową rzadkość",
    ["newRarity"] = "Nowa rzadkosć",
    ["needToAddRarity"] = "Musisz pierw dodać rzadkość przedmiotu!",
    ["whatRarityItem"] = "Jaką rzadkość powinien mieć ten przedmiot?",
    ["invalidRarity"] = "Niepoprawna rzadkośc.",
    ["rarityAlreadyExists"] = "Rzadkość z tym imieniem już egzystuje!",
    ["themeColorX"] = "Motyw - Kolor %d",
    ["themeTextColor"] = "Motyw - Kolor textu",
    ["presetAccents"] = "Gotowe akcenty",
    ["presetBackgrounds"] = "Gotowe tła",
    ["resetToBaseThemes"] = "Zresetuj bazowy motyw",
    ["resetToCurrentThemes"] = "Zresetuj bazowe motywy",
    ["toggle"] = "Przełącznik",
    ["menu"] = "Menu",
    ["emptyValue"] = "PUSTA WARTOSC",
    ["newValueQuery"] = "Jaka powinna być nowa wartość?",
    ["pressKey"] = "Wciśnij klawisz",
 
    ["entityPlacer"] = "Umieszczacz jednostek",
    ["invalidEntityType"] = "Nieprawidłowy rodzaj jednostki, wybierz odpowiednią z menu narzędzi.",
    ["entityPlaced"] = "Jednostka pomyśłnie umieszczona.",
    ["entityRemoved"] = "Jednostka pomyślnie usunieta.",
    ["canOnlyUseToolEntity"] = "Możesz używać tego narzędzia tylko do przesuwania/tworzenia jednostek.",
    ["entityType"] = "Rodzaj jednostki",
    ["entityPlacerDescription"] = "Umieszczaj i usuwaj jednostki z serwerów Brick i zapisuj ich pozycje. Lewyprzycisk - umieść. Prawyprzycisk - usuń.",
    ["entityPlacerDescriptionSmall"] = "Umieszczaj i usuwaj jednostki",
    ["entityPlacerInstructions"] = "Lewyprzycisk - umieść, Prawyprzycisk - usuń.",
 
    ["npcPlacer"] = "Umiezczacz NPC",
    ["npcPlaced"] = "NPC ustawiony.",
    ["invalidNPCType"] = "Nieprawidłowy rodzaj NPC, wybierz włąściwy z menu narzędzi.",
    ["npcRemoved"] = "NPC usunięty.",
    ["errorNotNPC"] = "Możesz używać tego narzędzia tylko do usuwania/tworzenia NPC.",
    ["npcPlacerDescription"] = "Umieszczaj i usuwaj NPC z serweró Brick, Lewyprzycisk - umieśc, Prawyprzycisk - usuń.",
    ["npcPlacerDescriptionSmall"] = "Umieszczaj i usuwaj NPC z serweró Brick's.",
 
    ["inventory"] = "Ekwipunek",
    ["player"] = "Gracz",
    ["drop"] = "Wyrzuć",
    ["use"] = "Użyj",
    ["dropAll"] = "Wyrzuć wszystko",
    ["delete"] = "Usuń",
} )
--PATH addons/____bricks_gangs/lua/bricks_server/bricks_gangs/sh_devconfig.lua:
--[[
    !!WARNING!!
        ALL CONFIG IS DONE INGAME, DONT EDIT ANYTHING HERE
        Type !bricksserver ingame or use the f4menu
    !!WARNING!!
]]--

BRICKS_SERVER.DEVCONFIG.GangURLWhitelist = {
    "https://i.imgur.com/",
    "https://imgur.com/"
}

BRICKS_SERVER.DEVCONFIG.GangRankLimit = 15
BRICKS_SERVER.DEVCONFIG.GangPrinterServerTime = 0.1 -- The decimal to reduce the server time by for each server, e.g. 0.1 would make the added time 10% less for server 2 and 20% less for server 3.

BRICKS_SERVER.DEVCONFIG.GangNameCharMin = 5
BRICKS_SERVER.DEVCONFIG.GangNameCharMax = 30
BRICKS_SERVER.DEVCONFIG.GangIconCharLimit = 200
BRICKS_SERVER.DEVCONFIG.GangNextEditTime = 1
BRICKS_SERVER.DEVCONFIG.GangPermissions = {
    ["DepositMoney"] = { BRICKS_SERVER.Func.L( "gangDepositMoney" ), BRICKS_SERVER.Func.L( "gangBalance" ) },
    ["WithdrawMoney"] = { BRICKS_SERVER.Func.L( "gangWithdrawMoney" ), BRICKS_SERVER.Func.L( "gangBalance" ) },
    ["EditRoles"] = { BRICKS_SERVER.Func.L( "gangEditRoles" ), BRICKS_SERVER.Func.L( "gangSettings" ) },
    ["EditSettings"] = { BRICKS_SERVER.Func.L( "gangEditSettings" ), BRICKS_SERVER.Func.L( "gangSettings" ) },
    ["InvitePlayers"] = { BRICKS_SERVER.Func.L( "gangInvitePlayers" ), BRICKS_SERVER.Func.L( "gangManagement" ) },
    ["KickPlayers"] = { BRICKS_SERVER.Func.L( "gangKickPlayers" ), BRICKS_SERVER.Func.L( "gangManagement" ) },
    ["ChangePlayerRoles"] = { BRICKS_SERVER.Func.L( "gangChangeRank" ), BRICKS_SERVER.Func.L( "gangManagement" ) },
    ["PurchaseUpgrades"] = { BRICKS_SERVER.Func.L( "gangPurchaseUpgrades" ), BRICKS_SERVER.Func.L( "gangManagement" ) },
    ["EditInbox"] = { BRICKS_SERVER.Func.L( "gangAcceptDeclineInbox" ), BRICKS_SERVER.Func.L( "gangManagement" ) },
    ["SendMessages"] = { BRICKS_SERVER.Func.L( "gangSendChatMessages" ), BRICKS_SERVER.Func.L( "gangChatLower" ) }
}

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "associations" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangPermissions["RequestAssociations"] = { BRICKS_SERVER.Func.L( "gangAssociationSend" ), BRICKS_SERVER.Func.L( "gangAssociations" ) }
    BRICKS_SERVER.DEVCONFIG.GangPermissions["AcceptAssociations"] = { BRICKS_SERVER.Func.L( "gangAssociationAccept" ), BRICKS_SERVER.Func.L( "gangAssociations" ) }
end

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangPermissions["DepositItem"] = { BRICKS_SERVER.Func.L( "gangDepositItems" ), BRICKS_SERVER.Func.L( "gangStorage" ) }
    BRICKS_SERVER.DEVCONFIG.GangPermissions["WithdrawItem"] = { BRICKS_SERVER.Func.L( "gangWithdrawItems" ), BRICKS_SERVER.Func.L( "gangStorage" ) }
    BRICKS_SERVER.DEVCONFIG.GangPermissions["ViewItem"] = { BRICKS_SERVER.Func.L( "gangViewStorage" ), BRICKS_SERVER.Func.L( "gangStorage" ) }
end

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "printers" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangPermissions["PurchasePrinters"] = { BRICKS_SERVER.Func.L( "gangPurchasePrinters" ), BRICKS_SERVER.Func.L( "gangPrinters" ) }
    BRICKS_SERVER.DEVCONFIG.GangPermissions["UpgradePrinters"] = { BRICKS_SERVER.Func.L( "gangUpgradePrinters" ), BRICKS_SERVER.Func.L( "gangPrinters" ) }
    BRICKS_SERVER.DEVCONFIG.GangPermissions["PlacePrinters"] = { BRICKS_SERVER.Func.L( "gangPlacePrinters" ), BRICKS_SERVER.Func.L( "gangPrinters" ) }

    BRICKS_SERVER.DEVCONFIG.GangPrinterSlots = 6
    BRICKS_SERVER.DEVCONFIG.GangPrinterW = 807*0.8
    BRICKS_SERVER.DEVCONFIG.GangPrinterH = 1018*0.8
end

BRICKS_SERVER.DEVCONFIG.GangUpgrades = {
    ["MaxMembers"] = {
        Name = BRICKS_SERVER.Func.L( "gangMaxMembers" ),
        Format = function( reqInfo )
            return (reqInfo[1] or 0) .. " " .. BRICKS_SERVER.Func.L( "gangMembers" )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangMembers" ), "integer" }
        }
    },
    ["MaxBalance"] = { 
        Name = BRICKS_SERVER.Func.L( "gangMaxBalance" ), 
        Format = function( reqInfo )
            return DarkRP.formatMoney( reqInfo[1] or 0 )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangBalance" ), "integer" }
        }
    },
    ["Health"] = { 
        Name = BRICKS_SERVER.Func.L( "gangIncreasedHealth" ), 
        Format = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangXHP", (reqInfo[1] or 0) )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangExtraHealth" ), "integer" }
        }
    },
    ["Armor"] = { 
        Name = BRICKS_SERVER.Func.L( "gangIncreasedArmor" ), 
        Format = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangXAP", (reqInfo[1] or 0) )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangExtraArmor" ), "integer" }
        }
    },
    ["Salary"] = { 
        Name = BRICKS_SERVER.Func.L( "gangIncreasedSalary" ), 
        Format = function( reqInfo )
            return "+" .. DarkRP.formatMoney( reqInfo[1] or 0 )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangExtraSalary" ), "integer" }
        }
    },
    ["Weapon"] = { 
        Name = BRICKS_SERVER.Func.L( "gangPermWeapon" ), 
        Unlimited = true,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangWeapon" ), "table", "weapons" }
        }
    }
}

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangUpgrades["StorageSlots"] = { 
        Name = BRICKS_SERVER.Func.L( "gangStorageSlots" ), 
        Format = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangXSlots", (reqInfo[1] or 0) )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangSlots" ), "integer" }
        }
    }
end

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "achievements" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangAchievements = {
        ["Balance"] = {
            Name = BRICKS_SERVER.Func.L( "gangBalanceFull" ),
            Format = function( progress, goal )
                return DarkRP.formatMoney( progress ) .. "/" .. DarkRP.formatMoney( goal )
            end,
            GetProgress = function( gangTable )
                return gangTable.Money or 0
            end,
            GetGoal = function( reqInfo )
                return reqInfo[1] or 0
            end,
            ReqInfo = {
                [1] = { BRICKS_SERVER.Func.L( "gangBalance" ), "integer" }
            }
        },
        ["Members"] = {
            Name = BRICKS_SERVER.Func.L( "gangMembersFull" ),
            Format = function( progress, goal )
                return progress .. "/" .. goal .. " " .. BRICKS_SERVER.Func.L( "gangMembers" )
            end,
            GetProgress = function( gangTable )
                return table.Count( gangTable.Members or {} )
            end,
            GetGoal = function( reqInfo )
                return reqInfo[1] or 0
            end,
            ReqInfo = {
                [1] = { BRICKS_SERVER.Func.L( "gangMembers" ), "integer" }
            }
        },
        ["Level"] = {
            Name = BRICKS_SERVER.Func.L( "gangLevel" ),
            Format = function( progress, goal )
                return BRICKS_SERVER.Func.L( "level" ) .. " " .. progress .. "/" .. goal
            end,
            GetProgress = function( gangTable )
                return gangTable.Level or 0
            end,
            GetGoal = function( reqInfo )
                return reqInfo[1] or 0
            end,
            ReqInfo = {
                [1] = { BRICKS_SERVER.Func.L( "level" ), "integer" }
            }
        }
    }

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
        BRICKS_SERVER.DEVCONFIG.GangAchievements["Storage"] = {
            Name = BRICKS_SERVER.Func.L( "gangStorageFull" ),
            Format = function( progress, goal )
                return progress .. "/" .. goal .. " " .. BRICKS_SERVER.Func.L( "gangItems" )
            end,
            GetProgress = function( gangTable )
                local itemCount = 0
                for k, v in pairs( gangTable.Storage or {} ) do
                    itemCount = itemCount+(v[1] or 0)
                end

                return itemCount
            end,
            GetGoal = function( reqInfo )
                return reqInfo[1] or 0
            end,
            ReqInfo = {
                [1] = { BRICKS_SERVER.Func.L( "gangItems" ), "integer" }
            }
        }
    end
end

BRICKS_SERVER.DEVCONFIG.GangNotifications = {
    ["GangInvite"] = {
        Name = BRICKS_SERVER.Func.L( "gangInvite" ),
        ReqInfo = {
            [1] = { "InviterGangID", "integer" },
            [2] = { "InviterGangName", "string" }
        },
        FormatDescription = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangInviteReceivedInbox", reqInfo[2] )
        end,
        AcceptFunc = function( reqInfo ) 
            net.Start( "BRS.Net.GangInviteAccept" )
                net.WriteUInt( reqInfo[1], 16 )
            net.SendToServer()
        end
    },
    ["AssociationInvite"] = {
        Name = BRICKS_SERVER.Func.L( "gangAssociationInvite" ),
        ReqInfo = {
            [1] = { "InviterGangID", "integer" },
            [2] = { "InviterGangName", "string" },
            [3] = { "AssociationType", "string" }
        },
        FormatDescription = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangAssociationInviteInbox", reqInfo[2], reqInfo[3] )
        end,
        AcceptFunc = function( reqInfo ) 
            net.Start( "BRS.Net.AcceptGangAssociation" )
                net.WriteUInt( reqInfo[1], 16 )
            net.SendToServer()
        end
    },
    ["AssociationCreated"] = {
        Name = BRICKS_SERVER.Func.L( "gangAssociationCreated" ),
        ReqInfo = {
            [1] = { "OtherGangID", "integer" },
            [2] = { "OtherGangName", "string" },
            [3] = { "AssociationType", "string" }
        },
        FormatDescription = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangAssociationCreatedInbox", reqInfo[3], reqInfo[2] )
        end
    },
    ["AssociationDissolved"] = {
        Name = BRICKS_SERVER.Func.L( "gangAssociationDissolved" ),
        ReqInfo = {
            [1] = { "OtherGangID", "integer" },
            [2] = { "OtherGangName", "string" }
        },
        FormatDescription = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangAssociationDissolvedInbox", reqInfo[2] )
        end
    },
    ["AdminMail"] = {
        Name = BRICKS_SERVER.Func.L( "gangAdminNotification" ),
        ReqInfo = {
            [1] = { "Header", "string" },
            [2] = { "Description", "string" }
        },
        FormatHeader = function( reqInfo )
            return reqInfo[1]
        end,
        FormatDescription = function( reqInfo )
            return reqInfo[2]
        end
    },
    ["Achievement"] = {
        Name = BRICKS_SERVER.Func.L( "gangInboxAchievement" ),
        ReqInfo = {
            [1] = { "Achievement Key", "integer" }
        },
        FormatDescription = function( reqInfo )
            local achievementConfig = BRICKS_SERVER.CONFIG.GANGS.Achievements[reqInfo[1]]

            return BRICKS_SERVER.Func.L( "gangInboxAchievementCompleted", achievementConfig.Name )
        end
    },
    ["AchievementReward"] = {
        Name = BRICKS_SERVER.Func.L( "gangInboxAchievement" ),
        ReqInfo = {
            [1] = { "Achievement Key", "integer" },
            [2] = { "Achievement Rewards", "table" }
        },
        FormatDescription = function( reqInfo )
            local rewardString = ""
            for k, v in pairs( reqInfo[2] or {} ) do
                local devConfigReward = BRICKS_SERVER.DEVCONFIG.GangRewards[k]

                if( not devConfigReward ) then continue end

                if( rewardString == "" ) then
                    rewardString =  devConfigReward.FormatDescription( v )
                else
                    rewardString = rewardString .. ", " .. devConfigReward.FormatDescription( v )
                end
            end

            local achievementConfig = BRICKS_SERVER.CONFIG.GANGS.Achievements[reqInfo[1]]

            return BRICKS_SERVER.Func.L( "gangInboxAchievementCompletedReward", achievementConfig.Name, rewardString )
        end,
        AcceptFunc = function( reqInfo, inboxKey ) 
            net.Start( "BRS.Net.GangAchievementClaim" )
                net.WriteUInt( inboxKey, 16 )
            net.SendToServer()
        end
    }
}

BRICKS_SERVER.DEVCONFIG.GangRewards = {
    ["GangExperience"] = {
        Name = BRICKS_SERVER.Func.L( "gangExperienceFull" ),
        Color = Color( 22, 160, 133 ),
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "experience" ), "integer" }
        },
        FormatDescription = function( reqInfo )
            return BRICKS_SERVER.Func.FormatGangEXP( reqInfo[1] or 0 ) .. " " .. BRICKS_SERVER.Func.L( "exp" )
        end,
        RewardFunc = function( gangID, reqInfo )
            BRICKS_SERVER.Func.AddGangExperience( gangID, reqInfo[1] )

            return true
        end
    },
    ["GangBalance"] = {
        Name = BRICKS_SERVER.Func.L( "gangBalanceFull" ),
        Color = Color( 39, 174, 96 ),
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "money" ), "integer" }
        },
        FormatDescription = function( reqInfo )
            return DarkRP.formatMoney( reqInfo[1] or 0 )
        end,
        RewardFunc = function( gangID, reqInfo )
            BRICKS_SERVER.Func.AddGangBalance( gangID, reqInfo[1] )
        end
    }
}

hook.Add("bWhitelist:Init", "BricksServerHooks_bWhitelist:Init_Gang", function()
    BRICKS_SERVER.DEVCONFIG.GangRewards["bWhitelist"] = {
        Name = BRICKS_SERVER.Func.L( "gangJobWhitelist" ),
        Temporary = true,
        Color = Color( 52, 152, 219 ),
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangJobs" ), "custom", function( rewardTable, rewardKey, reqInfoKey, currentReqInfo )
                BRICKS_SERVER.Func.CreateTeamSelector( (currentReqInfo or {}), BRICKS_SERVER.Func.L( "gangJobsSelect" ), function( teamTable ) 
                    if( table.Count( teamTable ) > 0 ) then
                        rewardTable[rewardKey] = rewardTable[rewardKey] or {}
                        rewardTable[rewardKey][reqInfoKey] = teamTable
                    else
                        rewardTable[rewardKey] = nil
                    end
                end, function() end )
            end }
        },
        FormatDescription = function( reqInfo )
            local jobString = ""
            for k, v in pairs( reqInfo[1] or {} ) do
                for key, val in pairs( RPExtraTeams ) do
                    if( val.command == k ) then
                        if( jobString == "" ) then
                            jobString = val.name
                        else
                            jobString = jobString .. ", " .. val.name
                        end
                        break
                    end
                end
            end

            return jobString
        end,
        RewardFunc = function( gangID, reqInfo )
            local teams = {}
            for k, v in pairs( reqInfo[1] or {} ) do
                for key, val in pairs( RPExtraTeams ) do
                    if( val.command == k ) then
                        table.insert( teams, k )
                        break
                    end
                end
            end

            local gangTable = (BRICKS_SERVER_GANGS or {})[gangID] or {}

            for k, v in pairs( teams ) do
                for key, val in pairs( gangTable.Members ) do
                    GAS.JobWhitelist:AddToWhitelist( v, GAS.JobWhitelist.LIST_TYPE_STEAMID, key )
                end
            end

            return true
        end,
        UnRewardFunc = function( gangID, reqInfo )
            local teams = {}
            for k, v in pairs( reqInfo[1] or {} ) do
                for key, val in pairs( RPExtraTeams ) do
                    if( val.command == k ) then
                        table.insert( teams, k )
                        break
                    end
                end
            end

            local gangTable = (BRICKS_SERVER_GANGS or {})[gangID] or {}

            for k, v in pairs( teams ) do
                for key, val in pairs( gangTable.Members ) do
                    GAS.JobWhitelist:RemoveFromWhitelist( v, GAS.JobWhitelist.LIST_TYPE_STEAMID, key )
                end
            end

            return true
        end
    }
end )

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "leaderboards" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangLeaderboards = {
        ["Experience"] = {
            Name = BRICKS_SERVER.Func.L( "experience" ),
            Color = Color( 22, 160, 133 ),
            FormatDescription = function( value )
                return BRICKS_SERVER.Func.FormatGangEXP( value or 0 ) .. " " .. BRICKS_SERVER.Func.L( "exp" )
            end,
            GetSortValue = function( gangTable )
                return gangTable.Experience or 0
            end
        },
        ["Members"] = {
            Name = BRICKS_SERVER.Func.L( "gangMembers" ),
            Color = Color( 41, 128, 185 ),
            FormatDescription = function( value )
                return (value or 0) .. " " .. (((value or 0) != 1 and BRICKS_SERVER.Func.L( "gangMembers" )) or BRICKS_SERVER.Func.L( "gangMember" ))
            end,
            GetSortValue = function( gangTable )
                return table.Count( gangTable.Members or {} )
            end
        },
        ["Balance"] = {
            Name = BRICKS_SERVER.Func.L( "gangBalance" ),
            Color = Color( 39, 174, 96 ),
            FormatDescription = function( value )
                return DarkRP.formatMoney( value or 0 )
            end,
            GetSortValue = function( gangTable )
                return gangTable.Money or 0
            end
        }
    }

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
        BRICKS_SERVER.DEVCONFIG.GangLeaderboards["StorageItems"] = {
            Name = BRICKS_SERVER.Func.L( "gangStorageItems" ),
            Color = Color( 231, 76, 60 ),
            FormatDescription = function( value )
                return (value or 0) .. " " .. (((value or 0) != 1 and BRICKS_SERVER.Func.L( "gangItems" )) or BRICKS_SERVER.Func.L( "gangItem" ))
            end,
            GetSortValue = function( gangTable )
                return table.Count( gangTable.Storage or {} )
            end
        }
    end
end

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "associations" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangAssociationTypes = {
        ["Allies"] = {
            Icon = "flag.png",
            Color = Color( 52, 152, 219 ),
            Query = BRICKS_SERVER.Func.L( "gangAllyRequest" )
        },
        ["War"] = {
            Icon = "gang_war.png",
            Color = Color( 231, 76, 60 ),
            Query = BRICKS_SERVER.Func.L( "gangWarRequest" )
        },
    }
end

BRICKS_SERVER.DEVCONFIG.GangAdminCmds = {
    [1] = {
        Name = BRICKS_SERVER.Func.L( "gangSetLevel" ),
        Icon = "levelling.png",
        ReqInfo = {
            [1] = { "Level", "integer", false, BRICKS_SERVER.Func.L( "gangSetLevelQuery" ) }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            local newLevel = math.Clamp( reqInfo[1] or (gangTable.Level or 0), 0, BRICKS_SERVER.CONFIG.GANGS["Max Level"] )
            BRICKS_SERVER.Func.SetGangLevel( gangID, newLevel )
            BRICKS_SERVER.Func.SetGangExperience( gangID, BRICKS_SERVER.Func.GetGangExpToLevel( 0, newLevel ) )
            return BRICKS_SERVER.Func.L( "gangSetLevelMsg", (gangTable.Name or "NIL"), newLevel )
        end
    },
    [2] = {
        Name = BRICKS_SERVER.Func.L( "gangAddExperience" ),
        Icon = "gang_experience.png",
        ReqInfo = {
            [1] = { "Experience", "integer", false, BRICKS_SERVER.Func.L( "gangAddExperienceQuery" ) }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            local experience = reqInfo[1] or (gangTable.Experience or 0)
            BRICKS_SERVER.Func.AddGangExperience( gangID, experience )
            return BRICKS_SERVER.Func.L( "gangAddExperienceMsg", BRICKS_SERVER.Func.FormatGangEXP( experience ), (gangTable.Name or "NIL") )
        end
    },
    [3] = {
        Name = BRICKS_SERVER.Func.L( "gangSetBalance" ),
        Icon = "balance.png",
        ReqInfo = {
            [1] = { "Money", "integer", false, BRICKS_SERVER.Func.L( "gangSetBalanceQuery" ) }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            local newBalance = reqInfo[1] or (gangTable.Money or 0)
            BRICKS_SERVER.Func.SetGangBalance( gangID, newBalance )
            return BRICKS_SERVER.Func.L( "gangSetBalanceMsg", (gangTable.Name or "NIL"), DarkRP.formatMoney( newBalance ) )
        end
    },
    [4] = {
        Name = BRICKS_SERVER.Func.L( "gangAddBalance" ),
        Icon = "gang_add_money.png",
        ReqInfo = {
            [1] = { "Money", "integer", false, BRICKS_SERVER.Func.L( "gangAddBalanceQuery" ) }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            local addBalance = reqInfo[1] or 0
            BRICKS_SERVER.Func.AddGangBalance( gangID, addBalance )
            return BRICKS_SERVER.Func.L( "gangAddBalanceMsg", DarkRP.formatMoney( addBalance ), (gangTable.Name or "NIL") )
        end
    },
    [5] = {
        Name = BRICKS_SERVER.Func.L( "gangViewMembers" ),
        Icon = "gang_viewmembers.png",
        ClientFunc = function( gangTable, gangID, panel )
            panel:ViewMembers()
        end
    },
    [6] = { -- Kick member
        ReqInfo = {
            [1] = { "MemberSteamID", "string" }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            if( gangTable.Owner == reqInfo[1] ) then
                return BRICKS_SERVER.Func.L( "gangCantKickOwner" )
            end

            local success = BRICKS_SERVER.Func.GangKickMember( gangID, reqInfo[1] )

            return (success and BRICKS_SERVER.Func.L( "gangKickSuccessAdmin" )) or BRICKS_SERVER.Func.L( "gangKickFailAdmin" )
        end
    },
    [7] = { -- Set member rank
        ReqInfo = {
            [1] = { "MemberSteamID", "string" },
            [2] = { "NewRank", "integer" }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            local success = BRICKS_SERVER.Func.GangMemberSetRank( gangID, reqInfo[1], reqInfo[2] )

            return (success and BRICKS_SERVER.Func.L( "gangSetRankSuccessAdmin" )) or BRICKS_SERVER.Func.L( "gangSetRankFailAdmin" )
        end
    },
    [8] = { -- Transfer ownership
        ReqInfo = {
            [1] = { "MemberSteamID", "string" }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            if( gangTable.Owner == reqInfo[1] ) then
                return BRICKS_SERVER.Func.L( "gangMemberAlreadyOwner" )
            end

            if( not gangTable.Members or not gangTable.Members[reqInfo[1]] ) then 
                return BRICKS_SERVER.Func.L( "gangNotMember" )
            end
        
            BRICKS_SERVER.Func.UpdateGangTable( gangID, "Owner", reqInfo[1] )

            return BRICKS_SERVER.Func.L( "gangOwnershipTransferedAdmin" )
        end
    },
    [9] = {
        Name = BRICKS_SERVER.Func.L( "delete" ),
        Icon = "gang_delete.png",
        ClientFunc = function( gangTable, gangID, panel )
            BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangDeleteAdminQuery", string.upper( gangTable.Name or "" ) ), "", function( text ) 
                if( text == string.upper( gangTable.Name ) ) then
                    net.Start( "BRS.Net.AdminGangCMD" )
                        net.WriteUInt( 9, 8 )
                        net.WriteUInt( gangID, 16 )
                        net.WriteTable( {} )
                    net.SendToServer()
                end
            end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
        end,
        ServerFunc = function( gangTable, gangID, reqInfo )
            BRICKS_SERVER.Func.DeleteGangTable( gangID )

            return BRICKS_SERVER.Func.L( "gangDeleteSuccessAdmin", gangTable.Name )
        end
    }
}

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "printers" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangServerUpgradeTypes = {
        ["Cooling"] = {
            Name = "Cooling",
            Icon = Material( "bricks_server/gangprinter_upgrade_cooling.png" ),
            Tiered = true,
            ReqInfo = {
                [1] = { "Temperature Decrease", "integer" }
            },
            SetFunc = function( ent, server, tier, upgradeConfig )
                ent:SetNW2Int( "CoolingServer" .. server, tier )

                if( tier >= #upgradeConfig.Tiers*0.5 ) then
                    ent:SetBodygroup( 8+((server-1)*2), 1 )

                    if( tier >= #upgradeConfig.Tiers ) then
                        ent:SetBodygroup( 8+((server-1)*2)+1, 1 )
                    end
                end
            end,
            GetFunc = function( ent, server )
                return ent:GetNW2Int( "CoolingServer" .. server, 0 )
            end
        },
        ["Speed"] = {
            Name = "Speed",
            Icon = Material( "bricks_server/gangprinter_upgrade_speed.png" ),
            Tiered = true,
            ReqInfo = {
                [1] = { "Speed Increase", "integer" }
            },
            SetFunc = function( ent, server, tier, upgradeConfig )
                ent:SetNW2Int( "SpeedServer" .. server, tier )
            end,
            GetFunc = function( ent, server )
                return ent:GetNW2Int( "SpeedServer" .. server, 0 )
            end
        },
        ["Amount"] = {
            Name = "Amount",
            Icon = Material( "bricks_server/gangprinter_upgrade_amount.png" ),
            Tiered = true,
            ReqInfo = {
                [1] = { "Amount Increase", "integer" }
            },
            SetFunc = function( ent, server, tier, upgradeConfig )
                ent:SetNW2Int( "AmountServer" .. server, tier )
            end,
            GetFunc = function( ent, server )
                return ent:GetNW2Int( "AmountServer" .. server, 0 )
            end
        }
    }

    BRICKS_SERVER.DEVCONFIG.GangPrinterUpgradeTypes = {
        ["Health"] = {
            Name = "Health",
            Icon = Material( "bricks_server/gangprinter_upgrade_health.png" ),
            Tiered = true,
            ReqInfo = {
                [1] = { "Health Increase", "integer" }
            },
            SetFunc = function( ent, value )
                ent:SetNW2Int( "HealthUpgrade", value )
            end,
            GetFunc = function( ent )
                return ent:GetNW2Int( "HealthUpgrade", 0 )
            end
        },
        ["RGB"] = {
            Name = "RGB",
            SetFunc = function( ent, value )
                ent:SetNW2Bool( "RGBUpgrade", true )

                ent:SetBodygroup( 7, 1 )
            end,
            GetFunc = function( ent )
                return ent:GetNW2Bool( "RGBUpgrade", false )
            end
        }
    }
end

BRICKS_SERVER.DEVCONFIG.PresetGangIcons = {
    "bricks_server/gang_viewmembers.png",
    "bricks_server/gang_add_money.png",
    "bricks_server/storage_64.png"
}

-- 1: sql key (set to false to not save to DB), 2: data type
BRICKS_SERVER.DEVCONFIG.GangTableKeys = {
    ["Name"] = { "gangName", "string" },
    ["Icon"] = { "gangIcon", "string" },
    ["Owner"] = { "owner", "string" },
    ["Level"] = { "level", "integer" },
    ["Experience"] = { "experience", "integer" },
    ["Money"] = { "money", "integer" },
    ["Storage"] = { "storage", "table" },
    ["Members"] = { "members", "table" },
    ["Roles"] = { "roles", "table" },
    ["Upgrades"] = { "upgrades", "table" },
    ["Achievements"] = { "achievements", "table" },
    ["Printers"] = { false, "table" },
}

BRICKS_SERVER.DEVCONFIG.NPCTypes = BRICKS_SERVER.DEVCONFIG.NPCTypes or {}
BRICKS_SERVER.DEVCONFIG.NPCTypes["Gang"] = {
    UseFunction = function( ply, ent, NPCKey )
        BRICKS_SERVER.Func.OpenGangMenu( ply )
    end
}

BRICKS_SERVER.DEVCONFIG.EntityTypes = BRICKS_SERVER.DEVCONFIG.EntityTypes or {}
BRICKS_SERVER.DEVCONFIG.EntityTypes["bricks_server_territory"] = { 
    GetDataFunc = function( entity ) 
        return entity:GetTerritoryKey() or 0
    end,
    SetDataFunc = function( entity, data ) 
        return entity:SetTerritoryKeyFunc( data or 0 )
    end
}
--PATH addons/____bricks_framework/lua/bricks_server/core/client/cl_bshadows.lua:
local function createShadows()
    BRICKS_SERVER.BSHADOWS = {}
    
    --The original drawing layer
    BRICKS_SERVER.BSHADOWS.RenderTarget = GetRenderTarget("bshadows_original_" .. ScrW(), ScrW(), ScrH())
    
    --The shadow layer
    BRICKS_SERVER.BSHADOWS.RenderTarget2 = GetRenderTarget("bshadows_shadow_" .. ScrW(),  ScrW(), ScrH())
    
    --The matarial to draw the render targets on
    BRICKS_SERVER.BSHADOWS.ShadowMaterial = CreateMaterial("bshadows_" .. ScrW(),"UnlitGeneric",{
        ["$translucent"] = 1,
        ["$vertexalpha"] = 1,
        ["alpha"] = 1
    })
    
    --When we copy the rendertarget it retains color, using this allows up to force any drawing to be black
    --Then we can blur it to create the shadow effect
    BRICKS_SERVER.BSHADOWS.ShadowMaterialGrayscale = CreateMaterial("bshadows_grayscale_" .. ScrW(),"UnlitGeneric",{
        ["$translucent"] = 1,
        ["$vertexalpha"] = 1,
        ["$alpha"] = 1,
        ["$color"] = "0 0 0",
        ["$color2"] = "0 0 0"
    })
    
    --Call this to begin drawing a shadow
    BRICKS_SERVER.BSHADOWS.BeginShadow = function( AreaX, AreaY, AreaEndX, AreaEndY )
        --Set the render target so all draw calls draw onto the render target instead of the screen
        render.PushRenderTarget(BRICKS_SERVER.BSHADOWS.RenderTarget)
    
        --Clear is so that theres no color or alpha
        render.OverrideAlphaWriteEnable(true, true)
        render.Clear(0,0,0,0)
        render.OverrideAlphaWriteEnable(false, false)
    
        if( AreaX and AreaY and AreaEndX and AreaEndY ) then
            render.SetScissorRect( AreaX, AreaY, AreaEndX, AreaEndY, true )
        end

        --Start Cam2D as where drawing on a flat surface 
        cam.Start2D()
    
        --Now leave the rest to the user to draw onto the surface
    end
    
    --This will draw the shadow, and mirror any other draw calls the happened during drawing the shadow
    BRICKS_SERVER.BSHADOWS.EndShadow = function(intensity, spread, blur, opacity, direction, distance, _shadowOnly)
        
        --Set default opcaity
        opacity = opacity or 255
        direction = direction or 0
        distance = distance or 0
        _shadowOnly = _shadowOnly or false
    
        --Copy this render target to the other
        render.CopyRenderTargetToTexture(BRICKS_SERVER.BSHADOWS.RenderTarget2)
    
        --Blur the second render target
        if blur > 0 then
            render.OverrideAlphaWriteEnable(true, true)
            render.BlurRenderTarget(BRICKS_SERVER.BSHADOWS.RenderTarget2, spread, spread, blur)
            render.OverrideAlphaWriteEnable(false, false) 
        end
    
        --First remove the render target that the user drew
        render.PopRenderTarget()
    
        --Now update the material to what was drawn
        BRICKS_SERVER.BSHADOWS.ShadowMaterial:SetTexture('$basetexture', BRICKS_SERVER.BSHADOWS.RenderTarget)
    
        --Now update the material to the shadow render target
        BRICKS_SERVER.BSHADOWS.ShadowMaterialGrayscale:SetTexture('$basetexture', BRICKS_SERVER.BSHADOWS.RenderTarget2)
    
        --Work out shadow offsets
        local xOffset = math.sin(math.rad(direction)) * distance 
        local yOffset = math.cos(math.rad(direction)) * distance
    
        --Now draw the shadow
        BRICKS_SERVER.BSHADOWS.ShadowMaterialGrayscale:SetFloat("$alpha", opacity/255) --set the alpha of the shadow
        render.SetMaterial(BRICKS_SERVER.BSHADOWS.ShadowMaterialGrayscale)
        for i = 1 , math.ceil(intensity) do
            render.DrawScreenQuadEx(xOffset, yOffset, ScrW(), ScrH())
        end
    
        if not _shadowOnly then
            --Now draw the original
            BRICKS_SERVER.BSHADOWS.ShadowMaterial:SetTexture('$basetexture', BRICKS_SERVER.BSHADOWS.RenderTarget)
            render.SetMaterial(BRICKS_SERVER.BSHADOWS.ShadowMaterial)
            render.DrawScreenQuad()
        end
    
        cam.End2D()

        render.SetScissorRect( 0, 0, 0, 0, false )
    end
    
    --This will draw a shadow based on the texture you passed it.
    BRICKS_SERVER.BSHADOWS.DrawShadowTexture = function(texture, intensity, spread, blur, opacity, direction, distance, shadowOnly)
    
        --Set default opcaity
        opacity = opacity or 255
        direction = direction or 0
        distance = distance or 0
        shadowOnly = shadowOnly or false
    
        --Copy the texture we wish to create a shadow for to the shadow render target
        render.CopyTexture(texture, BRICKS_SERVER.BSHADOWS.RenderTarget2)
    
        --Blur the second render target
        if blur > 0 then
            render.PushRenderTarget(BRICKS_SERVER.BSHADOWS.RenderTarget2)
            render.OverrideAlphaWriteEnable(true, true)
            render.BlurRenderTarget(BRICKS_SERVER.BSHADOWS.RenderTarget2, spread, spread, blur)
            render.OverrideAlphaWriteEnable(false, false) 
            render.PopRenderTarget()
        end
    
        --Now update the material to the shadow render target
        BRICKS_SERVER.BSHADOWS.ShadowMaterialGrayscale:SetTexture('$basetexture', BRICKS_SERVER.BSHADOWS.RenderTarget2)
    
        --Work out shadow offsets
        local xOffset = math.sin(math.rad(direction)) * distance 
        local yOffset = math.cos(math.rad(direction)) * distance
    
        --Now draw the shadow 
        BRICKS_SERVER.BSHADOWS.ShadowMaterialGrayscale:SetFloat("$alpha", opacity/255) --Set the alpha
        render.SetMaterial(BRICKS_SERVER.BSHADOWS.ShadowMaterialGrayscale)
        for i = 1 , math.ceil(intensity) do
            render.DrawScreenQuadEx(xOffset, yOffset, ScrW(), ScrH())
        end
        if not shadowOnly then
            --Now draw the original
            BRICKS_SERVER.BSHADOWS.ShadowMaterial:SetTexture('$basetexture', texture)
            render.SetMaterial(BRICKS_SERVER.BSHADOWS.ShadowMaterial)
            render.DrawScreenQuad()
        end
    end
end
createShadows()

hook.Add( "OnScreenSizeChanged", "BRS.OnScreenSizeChanged.Shadows", createShadows )
--PATH addons/____bricks_framework/lua/bricks_server/core/client/cl_main.lua:
net.Receive( "BRS.Net.SendConfig", function( len, ply )
    if( not BRICKS_SERVER.TEMP.Configs ) then
        BRICKS_SERVER.TEMP.Configs = {}
    end

    local uniqueStr = net.ReadString()
    local currentPart = net.ReadUInt( 5 )
    local totalParts = net.ReadUInt( 5 )
    local dataLen = net.ReadUInt( 16 )
    local partData = net.ReadData( dataLen )

    if( currentPart > 1 ) then
        if( BRICKS_SERVER.TEMP.Configs[uniqueStr] ) then
            BRICKS_SERVER.TEMP.Configs[uniqueStr] = BRICKS_SERVER.TEMP.Configs[uniqueStr] .. partData
        end
    else
        BRICKS_SERVER.TEMP.Configs[uniqueStr] = partData
    end

    if( currentPart == totalParts and BRICKS_SERVER.TEMP.Configs[uniqueStr] ) then
        if( totalParts > 1 and not BRICKS_SERVER.TEMP.Configs[uniqueStr] ) then return end

        local configUnCompressed = util.JSONToTable( util.Decompress( BRICKS_SERVER.TEMP.Configs[uniqueStr] ) ) or BRICKS_SERVER.BASECONFIG

        if( not BRICKS_SERVER.CONFIG ) then
            BRICKS_SERVER.CONFIG = table.Copy( configUnCompressed ) or {}
        else
            for k, v in pairs( configUnCompressed ) do
                BRICKS_SERVER.CONFIG[k] = v
            end
        end
    
        if( BRICKS_SERVER.Func.HasAdminAccess and BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then
            BS_ConfigCopyTable = table.Copy( BRICKS_SERVER.CONFIG )
        end
    
        hook.Run( "BRS.Hooks.ConfigReceived", configUnCompressed )
    
        RunConsoleCommand( "spawnmenu_reload" )
    end
end )

local function GetImageFromURL( url, failFunc )
    local CRC = util.CRC( url )
    local Extension = string.Split( url, "." )
    Extension = Extension[#Extension] or "png"

    if( not file.Exists( "bricks_server/images", "DATA" ) ) then
        file.CreateDir( "bricks_server/images" )
    end
    
    if( file.Exists( "bricks_server/images/" .. CRC .. "." .. Extension, "DATA" ) ) then
        BRICKS_SERVER.CachedMaterials[url] = Material( "data/bricks_server/images/" .. CRC .. "." .. Extension )

        if( failFunc ) then
            failFunc( BRICKS_SERVER.CachedMaterials[url], key )
        end

        return BRICKS_SERVER.CachedMaterials[url], key
    else
        http.Fetch( url, function( body )
            file.Write( "bricks_server/images/" .. CRC .. "." .. Extension, body )
            BRICKS_SERVER.CachedMaterials[url] = Material( "data/bricks_server/images/" .. CRC .. "." .. Extension )

            if( failFunc ) then
                failFunc( BRICKS_SERVER.CachedMaterials[url], key )
            end
        end )
    end
end

BRICKS_SERVER.CachedMaterials = {}

function BRICKS_SERVER.Func.CacheImageFromURL( url, failFunc )
    BRICKS_SERVER.CachedMaterials[url] = false

    if( not BRICKS_SERVER.CachedMaterials[url] ) then
        BRICKS_SERVER.CachedMaterials[url] = GetImageFromURL( url, failFunc )
    end
end

function BRICKS_SERVER.Func.CacheImageFromFile( filePath, fileName )
    BRICKS_SERVER.CachedMaterials[fileName] = Material( filePath )
end

function BRICKS_SERVER.Func.GetImage( key, onGetFunc )
    if( BRICKS_SERVER.CachedMaterials[key] ) then
        if( onGetFunc ) then
            onGetFunc( BRICKS_SERVER.CachedMaterials[key], key )
        else
            return BRICKS_SERVER.CachedMaterials[key], key
        end
    else
        if( string.StartWith( key, "http") ) then
            BRICKS_SERVER.Func.CacheImageFromURL( key, onGetFunc )
        end
    end
end

local files, directories = file.Find( "materials/bricks_server/*", "GAME" )
for k, v in pairs( files ) do
    BRICKS_SERVER.CachedMaterials[v] = Material( "materials/bricks_server/" .. v )
end

net.Receive( "BRS.Net.ProfileAdminSend", function( len, ply )
	local requestedID64 = net.ReadString()
	local profileTable = net.ReadTable()

	if( not requestedID64 or not profileTable ) then return end
	local requestedPly = player.GetBySteamID64( requestedID64 )

	if( IsValid( requestedPly ) ) then
		if( IsValid( BS_ADMIN_PROFILE ) and BS_ADMIN_PROFILE:IsVisible() and BS_ADMIN_PROFILE.RefreshProfile ) then
			BS_ADMIN_PROFILE:RefreshProfile( requestedID64, profileTable )
		end
	else
		notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidPlayerProfile" ), 1, 5 )
	end
end )

function BRICKS_SERVER.Func.ConfigChange( moduleKey )
    if( not BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then return end

    if( (BS_ConfigsChanged or {})[moduleKey] ) then return end

    if( not BS_ConfigsChanged ) then
        BS_ConfigsChanged = {}
    end

    BS_ConfigsChanged[moduleKey] = true
end

function BRICKS_SERVER.Func.LoadClientConfig()
    BRICKS_SERVER.CLIENTCONFIG = BRICKS_SERVER.CLIENTCONFIG or {}

    for k, v in pairs( BRICKS_SERVER.BASECLIENTCONFIG ) do
        local type = v[2] or ""

        if( type == "number" or type == "bind" ) then
            BRICKS_SERVER.CLIENTCONFIG[k] = cookie.GetNumber( "bricks_server_" .. k, v[3] or 0 )
        elseif( type == "bool" ) then
            BRICKS_SERVER.CLIENTCONFIG[k] = tobool( cookie.GetNumber( "bricks_server_" .. k, v[3] or 0 ) )
        else
            BRICKS_SERVER.CLIENTCONFIG[k] = cookie.GetString( "bricks_server_" .. k, v[3] or "" )
        end
    end
end
BRICKS_SERVER.Func.LoadClientConfig()

function BRICKS_SERVER.Func.ChangeClientConfig( key, value )
    if( BRICKS_SERVER.BASECLIENTCONFIG[key] ) then
        BRICKS_SERVER.CLIENTCONFIG = BRICKS_SERVER.CLIENTCONFIG or {}

        if( BRICKS_SERVER.BASECLIENTCONFIG[key][2] and BRICKS_SERVER.BASECLIENTCONFIG[key][2] == "bool" ) then
            BRICKS_SERVER.CLIENTCONFIG[key] = value and 1 or 0
            cookie.Set( "bricks_server_" .. key, (value and 1 or 0) )
        else
            BRICKS_SERVER.CLIENTCONFIG[key] = value
            cookie.Set( "bricks_server_" .. key, value )
        end

        if( BRICKS_SERVER.BASECLIENTCONFIG[key][4] and isfunction( BRICKS_SERVER.BASECLIENTCONFIG[key][4] ) ) then
            BRICKS_SERVER.BASECLIENTCONFIG[key][4]( value )
        end
    end
end

function BRICKS_SERVER.Func.GetClientConfig( key )
    if( not BRICKS_SERVER.BASECLIENTCONFIG[key] ) then return end

    local type = BRICKS_SERVER.BASECLIENTCONFIG[key][2] or ""

    if( type == "number" ) then
        return BRICKS_SERVER.CLIENTCONFIG[key] or ((BRICKS_SERVER.BASECLIENTCONFIG[key] or {})[3] or 0)
    elseif( type == "string" ) then
        return BRICKS_SERVER.CLIENTCONFIG[key] or ((BRICKS_SERVER.BASECLIENTCONFIG[key] or {})[3] or "")
    elseif( type == "bind" ) then
        return BRICKS_SERVER.CLIENTCONFIG[key] or ((BRICKS_SERVER.BASECLIENTCONFIG[key] or {})[3] or 0)
    elseif( type == "bool" ) then
        return tobool( BRICKS_SERVER.CLIENTCONFIG[key] )
    end
end

function BRICKS_SERVER.Func.GetClientBind( key )
    if( not BRICKS_SERVER.BASECLIENTCONFIG[key] ) then return BRICKS_SERVER.Func.L( "unbound" ), 0 end

    local bindNum = BRICKS_SERVER.Func.GetClientConfig( key ) or BRICKS_SERVER.BASECLIENTCONFIG[key][3]
    if( BRICKS_SERVER.DEVCONFIG.KEY_BINDS[bindNum] ) then
        return BRICKS_SERVER.DEVCONFIG.KEY_BINDS[bindNum], bindNum
    else
        return BRICKS_SERVER.Func.L( "unbound" ), bindNum
    end
end

function BRICKS_SERVER.Func.SetClientCookie( key, type, value )
    if( type == "bool" ) then
        cookie.Set( "bricks_server_cc_" .. key, value and 1 or 0 )
    else
        cookie.Set( "bricks_server_cc_" .. key, value )
    end
end

function BRICKS_SERVER.Func.GetClientCookie( key, type )
    if( type == "number" ) then
        return cookie.GetNumber( "bricks_server_cc_" .. key, 0 )
    elseif( type == "bool" ) then
        return tobool( cookie.GetNumber( "bricks_server_cc_" .. key, 0 ) )
    else
        return cookie.GetString( "bricks_server_cc_" .. key, "" )
    end
end

BRICKS_SERVER.ConfigPages = BRICKS_SERVER.ConfigPages or {}
function BRICKS_SERVER.Func.AddConfigPage( name, vguiElement, addon, shouldCreate )
    for k, v in pairs( BRICKS_SERVER.ConfigPages ) do
        if( v[2] == vguiElement ) then return end
    end

    table.insert( BRICKS_SERVER.ConfigPages, { name, vguiElement, addon, shouldCreate } )
end

BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "themes" ), "bricks_server_config_themes" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "groups" ), "bricks_server_config_groups" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "general" ), "bricks_server_config_general" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "itemWhitelisting" ), "bricks_server_config_itemwhitelist" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "rarities" ), "bricks_server_config_rarities" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "itemRarities" ), "bricks_server_config_itemrarities" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "languages" ), "bricks_server_config_languages" )
BRICKS_SERVER.Func.AddConfigPage( "NPCS", "bricks_server_config_npcs" )

function BRICKS_SERVER.Func.FillVariableConfigs( parent, configKey, configChanged, specialConfigs )
    if( not BRICKS_SERVER.BASECONFIG[configKey] or not parent or not IsValid( parent ) ) then return end

    local spacing = 5
    local gridWide = (ScrW()*0.6)-BRICKS_SERVER.DEVCONFIG.MainNavWidth-20
    local slotsWide = (ScrW() >= 1080 and 2) or 1
    local slotWide = (gridWide-((slotsWide-1)*spacing))/slotsWide
    local slotTall = 80

    if( not parent.grid or not IsValid( parent.grid ) ) then
        parent.grid = vgui.Create( "DIconLayout", parent )
        parent.grid:Dock( TOP )
        parent.grid:DockMargin( 0, 0, 0, 5 )
        parent.grid:SetTall( slotTall )
        parent.grid:SetSpaceY( spacing )
        parent.grid:SetSpaceX( spacing )
    end

    if( not parent.grid or not IsValid( parent.grid ) ) then return end

    local configs, specialConfigs = {}, specialConfigs or {}

    for k, v in pairs( BRICKS_SERVER.BASECONFIG[configKey] ) do
        if( isnumber( v ) or isstring( v ) or isbool( v ) ) then
            configs[k] = v
        end
    end

    if( specialConfigs ) then
        for k, v in pairs( specialConfigs ) do
            configs[k] = v
        end
    end

    for k, v in pairs( configs ) do
        parent.slots = (parent.slots or 0)+1
        local slots = parent.slots
        local slotsTall = math.ceil( slots/slotsWide )
        parent.grid:SetTall( (slotsTall*slotTall)+((slotsTall-1)*spacing) )

        local header = k
        if( istable( v ) and v[3] ) then
            header = v[3]
        end

        local description
        if( istable( v ) and v[2] ) then
            description = v[2]
        end

        local variableBack = parent.grid:Add( "DPanel" )
        variableBack:SetSize( slotWide, slotTall )
        variableBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

            draw.SimpleText( header, "BRICKS_SERVER_Font20", 10, 5, BRICKS_SERVER.Func.GetTheme( 5 ), 0, 0 )

            if( description ) then
                surface.SetFont( "BRICKS_SERVER_Font20" )
                local headerX, headerY = surface.GetTextSize( header )

                draw.SimpleText( description, "BRICKS_SERVER_Font20", 10+headerX+5, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
            end
        end

        if( not specialConfigs[k] and (isstring( v ) or isnumber( v )) ) then
            local valueEntryBack = vgui.Create( "DPanel", variableBack )
            valueEntryBack:Dock( BOTTOM )
            valueEntryBack:DockMargin( 10, 10, 10, 10 )
            valueEntryBack:SetTall( 40 )
            local Alpha = 0
            local valueEntry
            local color1 = BRICKS_SERVER.Func.GetTheme( 1 )
            valueEntryBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        
                if( valueEntry:IsEditing() ) then
                    Alpha = math.Clamp( Alpha+5, 0, 100 )
                else
                    Alpha = math.Clamp( Alpha-5, 0, 100 )
                end
                
                draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )
            end

            if( isnumber( v ) ) then
                valueEntry = vgui.Create( "bricks_server_numberwang", valueEntryBack )
                valueEntry:Dock( FILL )
                valueEntry:SetMinMax( 0, 9999999999999 )
                valueEntry:SetValue( ((BS_ConfigCopyTable or BRICKS_SERVER.CONFIG)[configKey] or {})[k] or 0 )
                valueEntry.OnValueChanged = function( self2, value )
                    BS_ConfigCopyTable[configKey][k] = tonumber( valueEntry:GetValue() )
                    BRICKS_SERVER.Func.ConfigChange( configChanged )
                end
            else
                valueEntry = vgui.Create( "bricks_server_textentry", valueEntryBack )
                valueEntry:Dock( FILL )
                valueEntry:SetValue( ((BS_ConfigCopyTable or BRICKS_SERVER.CONFIG)[configKey] or {})[k] or "" )
                valueEntry.OnChange = function( self2, value )
                    BS_ConfigCopyTable[configKey][k] = valueEntry:GetValue()
                    BRICKS_SERVER.Func.ConfigChange( configChanged )
                end
            end
        elseif( specialConfigs[k] or isbool( v ) ) then
            local toggleButton = vgui.Create( "DButton", variableBack )
            toggleButton:Dock( BOTTOM )
            toggleButton:DockMargin( 10, 10, 10, 10 )
            toggleButton:SetTall( 40 )
            toggleButton:SetText( "" )
            local alpha = 0
            toggleButton.Paint = function( self2, w, h )
                local buttonText = BRICKS_SERVER.Func.L( "edit" )
                local buttonColor = BRICKS_SERVER.Func.GetTheme( 2 )
                local buttonDownColor = BRICKS_SERVER.Func.GetTheme( 1 )

                if( not specialConfigs[k] and isbool( v ) ) then
                    local enabled = BS_ConfigCopyTable[configKey][k]
                    buttonText = (enabled and BRICKS_SERVER.Func.L( "enabled" )) or BRICKS_SERVER.Func.L( "disabled" )
                    buttonColor = (enabled and BRICKS_SERVER.DEVCONFIG.BaseThemes.Green) or BRICKS_SERVER.DEVCONFIG.BaseThemes.Red
                    buttonDownColor = (enabled and BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen) or BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed
                end
    
                if( not self2:IsDown() and self2:IsHovered() ) then
                    alpha = math.Clamp( alpha+5, 0, 200 )
                else
                    alpha = math.Clamp( alpha-5, 0, 255 )
                end
    
                draw.RoundedBox( 5, 0, 0, w, h, buttonColor )
    
                surface.SetAlphaMultiplier( alpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, buttonDownColor )
                surface.SetAlphaMultiplier( 1 )
    
                BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, buttonDownColor )
    
                draw.SimpleText( buttonText, "BRICKS_SERVER_Font20", w*0.5, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
            if( specialConfigs[k] and istable( v ) and v[1] ) then
                toggleButton.DoClick = v[1]
            else
                toggleButton.DoClick = function()
                    BS_ConfigCopyTable[configKey][k] = not BS_ConfigCopyTable[configKey][k]
                    BRICKS_SERVER.Func.ConfigChange( configChanged )
                end
            end
        end
    end
end

BRS_SERVER_OS_DIFF = 0

net.Receive( "BRS.Net.SendServerTime", function()
    local svrOSTime = net.ReadInt( 32 )
    local svrCurTime = net.ReadInt( 32 )

    BRS_SERVER_OS_DIFF = os.time()-svrOSTime+svrCurTime-CurTime()
end )

function BRICKS_SERVER.Func.GetServerTime()
    return os.time()-BRS_SERVER_OS_DIFF
end

net.Receive( "BRS.Net.OpenBrickServer", function()
    if( BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then
        BS_ConfigsChanged = {}
        BS_ConfigCopyTable = table.Copy( BRICKS_SERVER.CONFIG )
    end

	if( not IsValid( BRICKS_SERVER_MENU ) ) then
		BRICKS_SERVER_MENU = vgui.Create( "bricks_server_menu" )
		BRICKS_SERVER_MENU:FillTabs()
    elseif( not BRICKS_SERVER_MENU:IsVisible() ) then
        BRICKS_SERVER_MENU:SetVisible( true )
        if( BRICKS_SERVER_MENU.FillProfile ) then BRICKS_SERVER_MENU.FillProfile() end
        if( BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then
            hook.Run( "BRS.Hooks.RefreshConfig" )
            if( BRICKS_SERVER_MENU.FillPlayers ) then BRICKS_SERVER_MENU.FillPlayers() end
            if( BRICKS_SERVER_MENU.RefreshAdminPerms ) then BRICKS_SERVER_MENU.RefreshAdminPerms() end
        end
    end
end )

BRICKS_SERVER.AdminPlayerFunctions = {}
function BRICKS_SERVER.Func.AddAdminPlayerFunc( title, category, func )
    if( not BRICKS_SERVER.AdminPlayerFunctions ) then
        BRICKS_SERVER.AdminPlayerFunctions = {}
    end

    table.insert( BRICKS_SERVER.AdminPlayerFunctions, { title, category, func } )
end

BRICKS_SERVER.Func.AddAdminPlayerFunc( BRICKS_SERVER.Func.L( "profile" ), BRICKS_SERVER.Func.L( "view" ), function( ply ) 
    if( not IsValid( BS_ADMIN_PROFILE ) ) then
        BS_ADMIN_PROFILE = vgui.Create( "bricks_server_admin_profile" )
    end

    net.Start( "BRS.Net.ProfileAdminRequest" )
        net.WriteString( ply:SteamID64() or "" )
    net.SendToServer()
end )

concommand.Add( "brs_removeonclose", function( ply, cmd, args )
	BRS_REMOVEONCLOSE = not BRS_REMOVEONCLOSE
end )

hook.Add( "InitPostEntity", "BRS.InitPostEntity.NetworkReady", function()
	net.Start( "BRS.Net.SendNetworkReady" )
	net.SendToServer()
end )

net.Receive( "BRS.Net.SendTopNotification", function()
    local text = net.ReadString()
    local time = net.ReadUInt( 8 ) or 5
    local color = net.ReadColor() or BRICKS_SERVER.Func.GetTheme( 5 )

    BRICKS_SERVER.Func.CreateTopNotification( text, time, color )
end )

net.Receive( "BRS.Net.SendNotification", function()
    local text = net.ReadString()
    local type = net.ReadUInt( 8 ) or 1
    local time = net.ReadUInt( 8 ) or 3

    notification.AddLegacy( text, type, time )
end )

net.Receive( "BRS.Net.SendChatNotification", function()
    chat.AddText( net.ReadColor(), net.ReadString(), " ", net.ReadColor(), net.ReadString() )
end )

net.Receive( "BRS.Net.UseMenuNPC", function()
    local vguiElement = net.ReadString()
    local title = net.ReadString()

    if( not vguiElement ) then return end

    if( IsValid( BRICKS_SERVER.TEMP.NPCMenu ) ) then
        BRICKS_SERVER.TEMP.NPCMenu:Remove()
    end

    BRICKS_SERVER.TEMP.NPCMenu = vgui.Create( "bricks_server_dframe" )
	BRICKS_SERVER.TEMP.NPCMenu:SetHeader( title )
    BRICKS_SERVER.TEMP.NPCMenu:SetSize( ScrW()*0.6-BRICKS_SERVER.DEVCONFIG.MainNavWidth, ScrH()*0.65 )
    BRICKS_SERVER.TEMP.NPCMenu:Center()
    
    local vguiPanel = vgui.Create( vguiElement, BRICKS_SERVER.TEMP.NPCMenu )
    vguiPanel:Dock( FILL )
    if( vguiPanel.FillPanel ) then
        vguiPanel:FillPanel()
    end
end )

function BRICKS_SERVER.Func.SendAdminConfig()
    if( BS_ConfigsChanged and table.Count( BS_ConfigsChanged ) > 0 ) then
        local configToSend = {}
        for k, v in pairs( BS_ConfigsChanged ) do
            if( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG)[k] ) then
                configToSend[k] = (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG)[k]
            end
        end

        local configData = util.Compress( util.TableToJSON( configToSend ) )

        net.Start( "BRS.Net.UpdateConfig" )
            net.WriteData( configData, string.len( configData ) )
        net.SendToServer()
    end
end
--PATH addons/____bricks_framework/lua/bricks_server/core/client/cl_player.lua:
BRICKS_SERVER.LOCALPLYMETA = {}

setmetatable( BRICKS_SERVER.LOCALPLYMETA, BRICKS_SERVER.PLAYERMETA )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_colsheet_icon.lua:

local PANEL = {}

AccessorFunc( PANEL, "ActiveButton", "ActiveButton" )

function PANEL:Init()

	self.Navigation = vgui.Create( "bricks_server_scrollpanel", self )
	self.Navigation:Dock( LEFT )
	self.Navigation:SetWidth( 65 )
	self.Navigation:DockMargin( 0, 0, 0, 0 )
	self.Navigation.Paint = function( self2, w, h )
		draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, false, true, false )
	end

	self.Content = vgui.Create( "Panel", self )
	self.Content:Dock( FILL )

	self.Items = {}

end

function PANEL:UseButtonOnlyStyle()
	self.ButtonOnly = true
end

function PANEL:AddSheet( panel, onLoad, icon, dontShow )

	if ( !IsValid( panel ) ) then return end

	local Sheet = {}
	Sheet.Button = vgui.Create( "DButton", self.Navigation )
	Sheet.Button.Target = panel
	Sheet.Button:Dock( TOP )
	Sheet.Button:SetText( "" )
	Sheet.Button:SetTall( (not dontShow and 65) or 0 )
	local changeAlpha = 0
	local iconMat
	BRICKS_SERVER.Func.GetImage( icon or "", function( mat ) iconMat = mat end )
	Sheet.Button.Paint = function( self2, w, h )
		if( self2:IsHovered() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.DrawRect( 0, 0, 5, h )
		surface.SetAlphaMultiplier( 1 )

		if( iconMat ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 75 ) )
			surface.SetMaterial( iconMat )
			local iconSize = 32
			surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
		end
	end

	Sheet.Button.DoClick = function()
		if( not Sheet.Button.m_bSelected ) then
			changeAlpha = 0
		end

		self:SetActiveButton( Sheet.Button )
	end

	Sheet.Panel = panel
	Sheet.Panel:SetParent( self.Content )
	Sheet.Panel:SetAlpha( 0 )
	Sheet.Panel:SetVisible( false )

	if( onLoad ) then
		Sheet.Button.onLoad = onLoad
	end

	if ( self.ButtonOnly ) then
		Sheet.Button:SizeToContents()
	end

	table.insert( self.Items, Sheet )

	if ( !IsValid( self.ActiveButton ) ) then
		self:SetActiveButton( Sheet.Button )
	end
	
	return Sheet
end

function PANEL:Think()
	for k, v in pairs( self.Items ) do
		if( v.Think ) then
			v.Think()
		end
	end
end

function PANEL:SetActiveButton( active )
	if ( self.ActiveButton == active ) then return end

	if ( self.ActiveButton && self.ActiveButton.Target ) then
		local targetPanel = self.ActiveButton.Target
		targetPanel:SetVisible( false )
		targetPanel:SetAlpha( 0 )
		self.ActiveButton:SetSelected( false )
		self.ActiveButton:SetToggle( false )
	end

	self.ActiveButton = active
	active.Target:SetVisible( true )
	active.Target:AlphaTo( 255, 0.2, 0, function() end )
	active:SetSelected( true )
	active:SetToggle( true )

	if( active.onLoad and not active.loaded ) then
		active.onLoad()
		active.loaded = true
	end

	self.Content:InvalidateLayout()
end

derma.DefineControl( "bricks_server_colsheet_icon", "", PANEL, "Panel" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_colsheet_old.lua:

local PANEL = {}

AccessorFunc( PANEL, "ActiveButton", "ActiveButton" )

function PANEL:Init()
	self.Navigation = vgui.Create( "bricks_server_scrollpanel", self )
	self.Navigation:Dock( LEFT )
	self.Navigation:SetWidth( 200 )
	self.Navigation:DockMargin( 0, 0, 0, 0 )
	self.Navigation.Paint = function( self2, w, h )
		draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, false, true, false )
	end

	self.Content = vgui.Create( "Panel", self )
	self.Content:Dock( FILL )

	self.Items = {}
	self.CategoryButtons = {}
end

function PANEL:AddLinebreak()
	local lineBreak = vgui.Create( "DPanel", self.Navigation )
	lineBreak:Dock( TOP )
	lineBreak:DockMargin( 5, 10, 5, 10 )
	lineBreak:DockMargin( 5, 10, 5, 10 )
	lineBreak:SetTall( 5 )
	lineBreak.Paint = function( self2, w, h )
		draw.RoundedBox( 3, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
	end
end

function PANEL:AddSheet( label, panel, onLoad, icon, dontShow )
	if ( !IsValid( panel ) ) then return end

	local Sheet = {}
	Sheet.Button = vgui.Create( "DButton", self.Navigation )
	Sheet.Button.Target = panel
	Sheet.Button:Dock( TOP )
	Sheet.Button:SetText( "" )
	Sheet.Button:SetTall( (not dontShow and 65) or 0 )
	local changeAlpha = 0
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( label )
	local iconMat
	BRICKS_SERVER.Func.GetImage( icon or "", function( mat ) iconMat = mat end )
	Sheet.Button.Paint = function( self2, w, h )
		if( self2:IsHovered() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		if( self2.m_bSelected ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
			surface.DrawRect( 0, 0, w, h )
		elseif( self2:IsHovered() ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
			surface.DrawRect( 0, 0, 5, h )
		end
		surface.SetAlphaMultiplier( 1 )

		if( iconMat ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
			surface.SetMaterial( iconMat )
			local iconSize = 32
			surface.DrawTexturedRect( (h-iconSize)*0.5, (h*0.5)-(iconSize*0.5), iconSize, iconSize )
		end

		draw.SimpleText( label, "BRICKS_SERVER_Font25", h, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )

		if( Sheet.notifications and Sheet.notifications > 0 ) then
			local nX, nY, nW, nH = h+textX+5, (h*0.5)-(20*0.5), 20, 20
			draw.RoundedBox( 5, nX, nY, nW, nH, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )
			draw.SimpleText( Sheet.notifications, "BRICKS_SERVER_Font20", nX+(nW*0.5), nY+(nH*0.5), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end

	Sheet.Button.DoClick = function()
		if( not Sheet.Button.m_bSelected ) then
			changeAlpha = 0
		end

		self:SetActiveButton( Sheet.Button )
	end

	Sheet.Button.label = label

	Sheet.Panel = panel
	Sheet.Panel:SetParent( self.Content )
	Sheet.Panel:SetAlpha( 0 )
	Sheet.Panel:SetVisible( false )

	if( onLoad ) then
		Sheet.Button.loaded = false
		Sheet.Button.onLoad = onLoad
	end

	table.insert( self.Items, Sheet )

	if ( !IsValid( self.ActiveButton ) ) then
		self:SetActiveButton( Sheet.Button )
	end
	
	return Sheet
end

function PANEL:AddCategory( label, icon )
	local categoryButton = vgui.Create( "DButton", self.Navigation )
	categoryButton:Dock( TOP )
	categoryButton:SetText( "" )
	local tall = 65
	categoryButton:SetTall( tall )
	categoryButton:DockPadding( 0, tall, 0, 0 )
	local changeAlpha = 0
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( label )
	local iconMat
	BRICKS_SERVER.Func.GetImage( icon or "", function( mat ) iconMat = mat end )
	categoryButton.Paint = function( self2, w, h )
		if( self2:IsHovered() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		if( self2.m_bSelected ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
			surface.DrawRect( 0, 0, w, tall )
		elseif( self2:IsHovered() ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
			surface.DrawRect( 0, 0, 5, tall )
		end
		surface.SetAlphaMultiplier( 1 )

		if( iconMat ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
			surface.SetMaterial( iconMat )
			local iconSize = 32
			surface.DrawTexturedRect( (tall-iconSize)*0.5, (tall*0.5)-(iconSize*0.5), iconSize, iconSize )
		end

		draw.SimpleText( label, "BRICKS_SERVER_Font25", tall, tall*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
	end
	categoryButton.DoClick = function()
		if( not categoryButton.m_bSelected ) then
			changeAlpha = 0
		end

		for k, v in pairs( self.Items ) do
			if( v.parentCategory and v.parentCategory == categoryButton ) then
				self:SetActiveButton( v.Button )
				break
			end
		end
	end
	categoryButton.fullHeight = tall

	table.insert( self.CategoryButtons, categoryButton )
	
	return categoryButton
end

function PANEL:AddSubSheet( parentCategory, label, panel, onLoad )

	if( not IsValid( parentCategory ) or not IsValid( panel ) ) then return end

	local Sheet = {}
	Sheet.Button = vgui.Create( "DButton", parentCategory )
	Sheet.Button.Target = panel
	Sheet.Button:Dock( TOP )
	Sheet.Button:SetText( "" )
	Sheet.Button:SetTall( 30 )
	local changeAlpha = 0
	Sheet.Button.Paint = function( self2, w, h )
		if( self2:IsHovered() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 50 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 50 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 4 ) )
		surface.DrawRect( 0, 0, w, h )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( label, "BRICKS_SERVER_Font17", 15, h*0.5, BRICKS_SERVER.Func.GetTheme( 5 ), 0, TEXT_ALIGN_CENTER )
	end

	Sheet.Button.DoClick = function()
		if( not Sheet.Button.m_bSelected ) then
			changeAlpha = 0
		end

		self:SetActiveButton( Sheet.Button )
	end

	Sheet.Button.label = label

	Sheet.Panel = panel
	Sheet.Panel:SetParent( self.Content )
	Sheet.Panel:SetAlpha( 0 )
	Sheet.Panel:SetVisible( false )

	if( onLoad ) then
		Sheet.Button.loaded = false
		Sheet.Button.onLoad = onLoad
	end

	Sheet.parentCategory = parentCategory
	Sheet.Button.parentCategory = parentCategory
	parentCategory.fullHeight = parentCategory.fullHeight+Sheet.Button:GetTall()

	table.insert( self.Items, Sheet )

	if ( !IsValid( self.ActiveButton ) ) then
		self:SetActiveButton( Sheet.Button )
	end
	
	return Sheet
end

function PANEL:Think()
	for k, v in pairs( self.Items ) do
		if( v.Think ) then
			v.Think()
		end
	end
end

function PANEL:SetActiveButton( active )
	if ( self.ActiveButton == active ) then return end

	if( self.OnSheetChange ) then
		self.OnSheetChange( active )
	end

	for k, v in pairs( self.CategoryButtons ) do
		if( v.m_bSelected and (not active.parentCategory or active.parentCategory != v) ) then
			v.m_bSelected = false
			v:SizeTo( self.Navigation:GetWide(), 65, 0.2 )
			break
		elseif( not v.m_bSelected and active.parentCategory and active.parentCategory == v ) then
			v.m_bSelected = true
			v:SizeTo( self.Navigation:GetWide(), v.fullHeight, 0.2 )
			break
		end
	end
	
	if ( self.ActiveButton && self.ActiveButton.Target ) then
		local targetPanel = self.ActiveButton.Target
		targetPanel:SetVisible( false )
		targetPanel:SetAlpha( 0 )
		self.ActiveButton:SetSelected( false )
		self.ActiveButton:SetToggle( false )
	end

	self.ActiveButton = active
	active.Target:SetVisible( true )
	active.Target:AlphaTo( 255, 0.2, 0, function() end )
	active:SetSelected( true )
	active:SetToggle( true )

	if( active.onLoad and not active.loaded ) then
		active.onLoad()
		active.loaded = true
	end

	self.Content:InvalidateLayout()
end

function PANEL:SetActiveSheet( sheetLabel )
	if( not sheetLabel ) then return end

	for k, v in pairs( self.Items ) do
		if( v.Button and v.Button.label and v.Button.label == sheetLabel ) then
			self:SetActiveButton( v.Button )
			break
		end
	end
end

derma.DefineControl( "bricks_server_colsheet_old", "", PANEL, "Panel" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_config.lua:
local PANEL = {}

function PANEL:Init()
    hook.Add( "BRS.Hooks.ConfigReceived", self, function()
        if( IsValid( self ) and self.loadedPreviously ) then
            self:FillPanel()
        else
            hook.Remove( "BRS.Hooks.ConfigReceived", self )
        end
    end )
end

function PANEL:FillPanel()
    self.loadedPreviously = true
    self:Clear()

    self.colSheet = vgui.Create( "bricks_server_colsheet_left", self )
    self.colSheet:Dock( FILL )
    self.colSheet.OnNavCollapse = function( name, collapsed )
        BRICKS_SERVER.Func.SetClientCookie( name, "bool", collapsed )
    end
    self.colSheet.OnSheetChange = function( name )
        BRICKS_SERVER.Func.SetClientCookie( "configpage", "string", name )
    end

    self.colSheet:CreateSearchBar()

    BS_ConfigCopyTable = table.Copy( BRICKS_SERVER.CONFIG )
    BS_ConfigsChanged = {}

    local sortedConfig = table.Copy( BRICKS_SERVER.ConfigPages )

    table.SortByMember( sortedConfig, 1, true )

    for k, v in pairs( sortedConfig ) do
        if( v[4] and not v[4]() ) then continue end

        local addonTable = BRICKS_SERVER.DLCMODULES[v[3] or ""] or {}

        local adminConfigPage = vgui.Create( v[2], self.colSheet )
        if( not IsValid( adminConfigPage ) ) then continue end
        adminConfigPage:Dock( FILL )
        adminConfigPage:DockMargin( (adminConfigPage.margin or 10), (adminConfigPage.margin or 10), (adminConfigPage.margin or 10), (adminConfigPage.margin or 10) )
        if( adminConfigPage.FillPanel ) then
            self.colSheet:AddSheet( v[1], adminConfigPage, false, function() 
                adminConfigPage:FillPanel()
            end, addonTable.Name, addonTable.Color )

            hook.Add( "BRS.Hooks.RefreshConfig", "BRS.Hooks.RefreshConfig." .. tostring( adminConfigPage ), function()
                if( IsValid( adminConfigPage ) and adminConfigPage.RefreshPanel ) then
                    adminConfigPage.RefreshPanel()
                end
            end )
        else
            self.colSheet:AddSheet( v[1], adminConfigPage, false, false, addonTable.Name, addonTable.Color )
        end
    end

    self.colSheet:FinishAddingSheets()

    for k, v in pairs( self.colSheet.Categories ) do
        if( BRICKS_SERVER.Func.GetClientCookie( v:GetLabel(), "bool" ) ) then
            v:SetExpanded( false )
        end
    end

    self.colSheet:SetActiveSheet( BRICKS_SERVER.Func.GetClientCookie( "configpage", "string" ) )
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config", PANEL, "bricks_server_colsheet_left" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_dcategorycollapse.lua:

local PANEL = {

	Init = function( self )

		self:SetContentAlignment( 4 )
		self:SetTextInset( 5, 0 )
		self:SetFont( "DermaDefaultBold" )

	end,

	DoClick = function( self )

		self:GetParent():Toggle()

	end,

	UpdateColours = function( self, skin )

		if ( !self:GetParent():GetExpanded() ) then
			self:SetExpensiveShadow( 0, Color( 0, 0, 0, 200 ) )
			return self:SetTextStyleColor( skin.Colours.Category.Header_Closed )
		end

		self:SetExpensiveShadow( 1, Color( 0, 0, 0, 100 ) )
		return self:SetTextStyleColor( skin.Colours.Category.Header )

	end,

	Paint = function( self )

		-- Do nothing!

	end,

	GenerateExample = function()

		-- Do nothing!

	end

}

derma.DefineControl( "bricks_server_dcategoryheader", "Category Header", PANEL, "DButton" )

local PANEL = {}

AccessorFunc( PANEL, "m_bSizeExpanded",		"Expanded", FORCE_BOOL )
AccessorFunc( PANEL, "m_iContentHeight",	"StartHeight" )
AccessorFunc( PANEL, "m_fAnimTime",			"AnimTime" )
AccessorFunc( PANEL, "m_bDrawBackground",	"PaintBackground", FORCE_BOOL )
AccessorFunc( PANEL, "m_bDrawBackground",	"DrawBackground", FORCE_BOOL ) -- deprecated
AccessorFunc( PANEL, "m_iPadding",			"Padding" )
AccessorFunc( PANEL, "m_pList",				"List" )

function PANEL:Init()

	self.Header = vgui.Create( "bricks_server_dcategoryheader", self )
	self.Header:Dock( TOP )
	self.Header:SetSize( 20, 40 )

	self:SetSize( 16, 16 )
	self:SetExpanded( true )
	self:SetMouseInputEnabled( true )

	self:SetAnimTime( 0.2 )
	self.animSlide = Derma_Anim( "Anim", self, self.AnimSlide )

	self:SetPaintBackground( true )
	self:DockMargin( 0, 0, 0, 5 )
	self:DockPadding( 0, 0, 0, 0 )

end

function PANEL:Add( strName )

	local button = vgui.Create( "DButton", self )
	button.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "CategoryButton", panel, w, h ) end
	button.UpdateColours = function( button, skin )

		if ( button.AltLine ) then

			if ( button.Depressed || button.m_bSelected ) then	return button:SetTextStyleColor( skin.Colours.Category.LineAlt.Text_Selected ) end
			if ( button.Hovered ) then							return button:SetTextStyleColor( skin.Colours.Category.LineAlt.Text_Hover ) end
			return button:SetTextStyleColor( skin.Colours.Category.LineAlt.Text )

		end

		if ( button.Depressed || button.m_bSelected ) then	return button:SetTextStyleColor( skin.Colours.Category.Line.Text_Selected ) end
		if ( button.Hovered ) then							return button:SetTextStyleColor( skin.Colours.Category.Line.Text_Hover ) end
		return button:SetTextStyleColor( skin.Colours.Category.Line.Text )

	end

	button:SetHeight( 40 )
	button:SetTextInset( 4, 0 )

	button:SetContentAlignment( 4 )
	button.DoClickInternal = function()

		if ( self:GetList() ) then
			self:GetList():UnselectAll()
		else
			self:UnselectAll()
		end

		button:SetSelected( true )

	end

	button:Dock( TOP )
	button:SetText( strName )

	self:InvalidateLayout( true )
	self:UpdateAltLines()

	return button

end

function PANEL:UnselectAll()

	local children = self:GetChildren()
	for k, v in pairs( children ) do

		if ( v.SetSelected ) then
			v:SetSelected( false )
		end

	end

end

function PANEL:UpdateAltLines()

	local children = self:GetChildren()
	for k, v in pairs( children ) do
		v.AltLine = k % 2 != 1
	end

end

function PANEL:Think()

	self.animSlide:Run()

end

function PANEL:SetLabel( strLabel )

	self.Header:SetText( strLabel )

end

function PANEL:Paint( w, h )
	draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
	draw.RoundedBox( 5, 0, 0, w, 40, BRICKS_SERVER.Func.GetTheme( 3 ) )

	BRICKS_SERVER.Func.DrawPartialRoundedBox( 5, 0, 0, 3, 40, (self.backColor or BRICKS_SERVER.Func.GetTheme( 4 )), 10, 40 )

	draw.SimpleText( (self.headerText or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font20", 15, 40*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
end

function PANEL:AddButton( material, func )
	local button = vgui.Create( "DButton", self.Header )
	button:Dock( RIGHT )
	button:DockMargin( 2, 2, 2, 2 )
	button:SetWide( 36 )
	button:SetText( "" )
	local changeAlpha = 0
	local x, y = 0, 0
	button.Paint = function( self2, w, h )
		local toScreenX, toScreenY = self2:LocalToScreen( 0, 0 )
		if( x != toScreenX or y != toScreenY ) then
			x, y = toScreenX, toScreenY
		end

		if( self2:IsDown() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
		elseif( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
		surface.SetAlphaMultiplier( 1 )

		surface.SetMaterial( material )
		local size = 24
		surface.SetDrawColor( 0, 0, 0, 255 )
		surface.DrawTexturedRect( (h-size)*0.5-1, (h-size)*0.5+1, size, size )

		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect( (h-size)*0.5, (h-size)*0.5, size, size )
	end
	button.DoClick = function()
		func( x, y, button:GetWide(), button:GetWide() )
	end
end

function PANEL:SetContents( pContents )

	self.Contents = pContents
	self.Contents:SetParent( self )
	self.Contents:Dock( FILL )

	if ( !self:GetExpanded() ) then

		self.OldHeight = self:GetTall()

	elseif ( self:GetExpanded() && IsValid( self.Contents ) && self.Contents:GetTall() < 1 ) then

		self.Contents:SizeToChildren( false, true )
		self.OldHeight = self.Contents:GetTall()
		self:SetTall( self.OldHeight )

	end

	self:InvalidateLayout( true )

end

function PANEL:SetExpanded( expanded )

	self.m_bSizeExpanded = tobool( expanded )

	if ( !self:GetExpanded() ) then
		if ( !self.animSlide.Finished && self.OldHeight ) then return end
		self.OldHeight = self:GetTall()
	end

end

function PANEL:Toggle()

	self:SetExpanded( !self:GetExpanded() )

	self.animSlide:Start( self:GetAnimTime(), { From = self:GetTall() } )

	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

	local open = "1"
	if ( !self:GetExpanded() ) then open = "0" end
	self:SetCookie( "Open", open )

	self:OnToggle( self:GetExpanded() )

end

function PANEL:OnToggle( expanded )

	-- Do nothing / For developers to overwrite

end

function PANEL:DoExpansion( b )

	if ( self:GetExpanded() == b ) then return end
	self:Toggle()

end

function PANEL:PerformLayout()

	if ( IsValid( self.Contents ) ) then

		if ( self:GetExpanded() ) then
			self.Contents:InvalidateLayout( true )
			self.Contents:SetVisible( true )
		else
			self.Contents:SetVisible( false )
		end

	end

	if ( self:GetExpanded() ) then

		if ( IsValid( self.Contents ) && #self.Contents:GetChildren() > 0 ) then self.Contents:SizeToChildren( false, true ) end
		self:SizeToChildren( false, true )

	else

		if ( IsValid( self.Contents ) && !self.OldHeight ) then self.OldHeight = self.Contents:GetTall() end
		self:SetTall( self.Header:GetTall() )

	end

	-- Make sure the color of header text is set
	self.Header:ApplySchemeSettings()

	self.animSlide:Run()
	self:UpdateAltLines()

end

function PANEL:OnMousePressed( mcode )

	if ( !self:GetParent().OnMousePressed ) then return end

	return self:GetParent():OnMousePressed( mcode )

end

function PANEL:AnimSlide( anim, delta, data )

	self:InvalidateLayout()
	self:InvalidateParent()

	if ( anim.Started ) then
		if ( !IsValid( self.Contents ) && ( self.OldHeight || 0 ) < self.Header:GetTall() ) then
			-- We are not using self.Contents and our designated height is less
			-- than the header size, something is clearly wrong, try to rectify
			self.OldHeight = 0
			for id, pnl in pairs( self:GetChildren() ) do
				self.OldHeight = self.OldHeight + pnl:GetTall()
			end
		end

		if ( self:GetExpanded() ) then
			data.To = math.max( self.OldHeight, self:GetTall() )
		else
			data.To = self:GetTall()
		end
	end

	if ( IsValid( self.Contents ) ) then self.Contents:SetVisible( true ) end

	self:SetTall( Lerp( delta, data.From, data.To ) )

end

function PANEL:LoadCookies()

	local Open = self:GetCookieNumber( "Open", 1 ) == 1

	self:SetExpanded( Open )
	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

end

derma.DefineControl( "bricks_server_dcollapsiblecategory", "Collapsable Category Panel", PANEL, "Panel" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_dframepanel.lua:
local PANEL = {}

function PANEL:Init()
    self.headerHeight = 40
    self:DockPadding( 0, self.headerHeight, 0, 0 )

    self.removeOnClose = true
    self:CreateCloseButton()
end

function PANEL:CreateCloseButton()
    if( self.dontShowClose ) then return end

    local size = 24

    if( IsValid( self.closeButton ) ) then
        self.closeButton:SetSize( size, size )
        self.closeButton:SetPos( self:GetWide()-size-((self.headerHeight-size)*0.5), (self.headerHeight*0.5)-(size*0.5) )
        return
    end

    self.closeButton = vgui.Create( "DButton", self )
	self.closeButton:SetSize( size, size )
	self.closeButton:SetPos( self:GetWide()-size-((self.headerHeight-size)*0.5), (self.headerHeight*0.5)-(size*0.5) )
	self.closeButton:SetText( "" )
    local CloseMat = Material( "materials/bricks_server/close.png" )
    local textColor = BRICKS_SERVER.Func.GetTheme( 6 )
	self.closeButton.Paint = function( self2, w, h )
		if( self2:IsHovered() and !self2:IsDown() ) then
			surface.SetDrawColor( textColor.r*0.6, textColor.g*0.6, textColor.b*0.6 )
		elseif( self2:IsDown() || self2.m_bSelected ) then
			surface.SetDrawColor( textColor.r*0.8, textColor.g*0.8, textColor.b*0.8 )
		else
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
		end

		surface.SetMaterial( CloseMat )
		surface.DrawTexturedRect( 0, 0, w, h )
	end
    self.closeButton.DoClick = function()
        if( self.onCloseFunc ) then
            self.onCloseFunc()
        end

        if( self.removeOnClose or BRS_REMOVEONCLOSE ) then
            self:Remove()
        else
            self:SetVisible( false )
        end
    end
end

function PANEL:OnSizeChanged( newW, newH )
    self:CreateCloseButton()
end

function PANEL:SetHeader( header )
    self.header = header
end

function PANEL:DisableClose()
    self.dontShowClose = true

    if( IsValid( self.closeButton ) ) then
        self.closeButton:Remove()
    end
end

local rounded = 5
function PANEL:Paint( w, h )
    BRICKS_SERVER.BSHADOWS.BeginShadow()
    local x, y = self:LocalToScreen( 0, 0 )
    draw.RoundedBox( rounded, x, y, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )			
    BRICKS_SERVER.BSHADOWS.EndShadow( 1, 2, 2, 255, 0, 0, false )

    draw.RoundedBoxEx( rounded, 0, 0, w, self.headerHeight, BRICKS_SERVER.Func.GetTheme( 0 ), true, true, false, false )

    draw.SimpleText( (self.header or BRICKS_SERVER.Func.L( "menu" )), "BRICKS_SERVER_Font30", 10, (self.headerHeight or 40)*0.5-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
end

vgui.Register( "bricks_server_dframepanel", PANEL, "DPanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_dvscrollbar.lua:
--[[

	DVScrollBar

	Usage:

	Place this control in your panel. You will ideally have another panel or
		control which is bigger than the original panel. This is the Canvas.

	scrollbar:SetUp( _barsize_, _canvassize_ ) should be called whenever
		the size of your 'canvas' changes.

	scrollbar:GetOffset() can be called to get the offset of the canvas.
		You should call this in your PerformLayout function and set the Y
		pos of your canvas to this value.

	Example:

	function PANEL:PerformLayout()

		local Wide = self:GetWide()
		local YPos = 0

		-- Place the scrollbar
		self.VBar:SetPos( self:GetWide() - 16, 0 )
		self.VBar:SetSize( 16, self:GetTall() )

		-- Make sure the scrollbar knows how big our canvas is
		self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )

		-- Get data from the scrollbar
		YPos = self.VBar:GetOffset()

		-- If the scrollbar is enabled make the canvas thinner so it will fit in.
		if ( self.VBar.Enabled ) then Wide = Wide - 16 end

		-- Position the canvas according to the scrollbar's data
		self.pnlCanvas:SetPos( self.Padding, YPos + self.Padding )
		self.pnlCanvas:SetSize( Wide - self.Padding * 2, self.pnlCanvas:GetTall() )

	end

--]]

local PANEL = {}

function PANEL:Init()
	self.Offset = 0
	self.Scroll = 0
	self.CanvasSize = 1
	self.BarSize = 1
	self.cornerRadius = 5

	self.btnGrip = vgui.Create( "DScrollBarGrip", self )
	local Alpha = 0
	self.btnGrip.Paint = function( self2, w, h )
		if( h >= self.BarSize-1 ) then return end

		if( self2:IsHovered() ) then
			Alpha = math.Clamp( Alpha+10, 0, 100 )
		else
			Alpha = math.Clamp( Alpha-10, 0, 100 )
		end
	
		if( self.roundedBoxEx ) then
			draw.RoundedBoxEx( self.cornerRadius, 0, 0, w, h, (self.barColor or BRICKS_SERVER.Func.GetTheme( 3 )), self.roundTopLeft, self.roundTopRight, self.roundBottomLeft, self.roundBottomRight )
		else
			draw.RoundedBox( self.cornerRadius, 0, 0, w, h, (self.barColor or BRICKS_SERVER.Func.GetTheme( 3 )) )
		end

		surface.SetAlphaMultiplier( Alpha/255 )
		if( self.roundedBoxEx ) then
			draw.RoundedBoxEx( self.cornerRadius, 0, 0, w, h, (self.barDownColor or BRICKS_SERVER.Func.GetTheme( 2 )), self.roundTopLeft, self.roundTopRight, self.roundBottomLeft, self.roundBottomRight )
		else
			draw.RoundedBox( self.cornerRadius, 0, 0, w, h, (self.barDownColor or BRICKS_SERVER.Func.GetTheme( 2 )) )
		end
		surface.SetAlphaMultiplier( 1 )
	end

	self:SetSize( 10, 15 )
	self:SetEnabled( true )
end

function PANEL:SetRoundedCorners( roundTopLeft, roundTopRight, roundBottomLeft, roundBottomRight )
	self.roundedBoxEx = true
	self.roundTopLeft, self.roundTopRight, self.roundBottomLeft, self.roundBottomRight = roundTopLeft, roundTopRight, roundBottomLeft, roundBottomRight
end

function PANEL:SetRounded( cornerRadius )
	self.cornerRadius = cornerRadius
end

function PANEL:SetEnabled( b )

	if ( !b ) then

		self.Offset = 0
		self:SetScroll( 0 )
		self.HasChanged = true

	end

	self:SetMouseInputEnabled( b )
	self:SetVisible( b )

	-- We're probably changing the width of something in our parent
	-- by appearing or hiding, so tell them to re-do their layout.
	if ( self.Enabled != b ) then

		self:GetParent():InvalidateLayout()

		if ( self:GetParent().OnScrollbarAppear ) then
			self:GetParent():OnScrollbarAppear()
		end

	end

	self.Enabled = b

end

function PANEL:Value()

	return self.Pos

end

function PANEL:BarScale()

	if ( self.BarSize == 0 ) then return 1 end

	return self.BarSize / ( self.CanvasSize + self.BarSize )

end

function PANEL:SetUp( _barsize_, _canvassize_ )

	self.BarSize = _barsize_
	self.CanvasSize = math.max( _canvassize_ - _barsize_, 1 )

	self:InvalidateLayout()

end

function PANEL:OnMouseWheeled( dlta )

	if ( !self:IsVisible() ) then return false end

	-- We return true if the scrollbar changed.
	-- If it didn't, we feed the mousehweeling to the parent panel

	if( self.btnGrip:GetTall() >= self.BarSize-1 ) then return end

	return self:AddScroll( dlta * -2 )

end

function PANEL:AddScroll( dlta )

	local OldScroll = self:GetScroll()

	dlta = dlta * 25
	self:SetScroll( self:GetScroll() + dlta )

	return OldScroll != self:GetScroll()

end

function PANEL:SetScroll( scrll )

	if ( !self.Enabled ) then self.Scroll = 0 return end
	
	self.Scroll = math.Clamp( scrll, 0, self.CanvasSize )

	self:InvalidateLayout()

	-- If our parent has a OnVScroll function use that, if
	-- not then invalidate layout (which can be pretty slow)

	local func = self:GetParent().OnVScroll
	if ( func ) then

		func( self:GetParent(), self:GetOffset() )

	else

		self:GetParent():InvalidateLayout()

	end

end

function PANEL:AnimateTo( scrll, length, delay, ease )

	local anim = self:NewAnimation( length, delay, ease )
	anim.StartPos = self.Scroll
	anim.TargetPos = scrll
	anim.Think = function( anim, pnl, fraction )

		pnl:SetScroll( Lerp( fraction, anim.StartPos, anim.TargetPos ) )

	end

end

function PANEL:GetScroll()

	if ( !self.Enabled ) then self.Scroll = 0 end
	return self.Scroll

end

function PANEL:GetOffset()

	if ( !self.Enabled ) then return 0 end
	return self.Scroll * -1

end

function PANEL:Think()
end

function PANEL:Paint( w, h )
	if( self.roundedBoxEx ) then
		draw.RoundedBoxEx( self.cornerRadius, 0, 0, w, h, (self.backColor or BRICKS_SERVER.Func.GetTheme( 2 )), self.roundTopLeft, self.roundTopRight, self.roundBottomLeft, self.roundBottomRight )
	else
		draw.RoundedBox( self.cornerRadius, 0, 0, w, h, (self.backColor or BRICKS_SERVER.Func.GetTheme( 2 )) )
	end
end

function PANEL:OnMousePressed()

	local x, y = self:CursorPos()

	local PageSize = self.BarSize

	if ( y > self.btnGrip.y ) then
		self:SetScroll( self:GetScroll() + PageSize )
	else
		self:SetScroll( self:GetScroll() - PageSize )
	end

end

function PANEL:OnMouseReleased()

	self.Dragging = false
	self.DraggingCanvas = nil
	self:MouseCapture( false )

	self.btnGrip.Depressed = false

end

function PANEL:OnCursorMoved( x, y )

	if ( !self.Enabled ) then return end
	if ( !self.Dragging ) then return end

	local x, y = self:ScreenToLocal( 0, gui.MouseY() )

	-- Uck.
	y = y - self.HoldPos

	local TrackSize = self:GetTall() - self.btnGrip:GetTall()

	y = y / TrackSize

	self:SetScroll( y * self.CanvasSize )

end

function PANEL:Grip()

	if ( !self.Enabled ) then return end
	if ( self.BarSize == 0 ) then return end

	self:MouseCapture( true )
	self.Dragging = true

	local x, y = self.btnGrip:ScreenToLocal( 0, gui.MouseY() )
	self.HoldPos = y

	self.btnGrip.Depressed = true

end

function PANEL:PerformLayout()

	local Wide = self:GetWide()
	local Scroll = self:GetScroll() / self.CanvasSize
	local BarSize = math.max( self:BarScale() * ( self:GetTall() ), 10 )
	local Track = self:GetTall() - BarSize
	Track = Track + 1

	Scroll = Scroll * Track

	self.btnGrip:SetPos( 0, Scroll )
	self.btnGrip:SetSize( Wide, BarSize )
end

derma.DefineControl( "bricks_server_dvscrollbar", "A Scrollbar", PANEL, "Panel" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_menu.lua:
local PANEL = {}

function PANEL:Init()
    self:SetSize( ScrW()*0.6, ScrH()*0.65 )
    self:Center()
    self:SetHeader( BRICKS_SERVER.CONFIG.GENERAL["Server Name"] )
    self.removeOnClose = false
    self.centerOnSizeChanged = true

    self.onCloseFunc = function()
        if( BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then
            BRICKS_SERVER.Func.SendAdminConfig()
        end
    end

    if( BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then
		BS_ConfigCopyTable = table.Copy( BRICKS_SERVER.CONFIG )
	end
end

function PANEL:FillTabs()
    if( IsValid( self.sheet ) ) then
        if( IsValid( self.sheet.ActiveButton ) ) then
            self.previousSheet = self.sheet.ActiveButton.label
        end
        self.sheet:Remove()
    end

    local originalW, originalH = ScrW()*0.6, ScrH()*0.65 
    local newW = originalW+200

    self.sheet = vgui.Create( "bricks_server_colsheet", self )
    self.sheet:Dock( FILL )
    self.sheet.OnSheetChange = function( active )
        if( active.label == BRICKS_SERVER.Func.L( "config" ) and (self:GetWide() != newW or self:GetTall() != originalH) ) then
            self:SizeTo( newW, originalH, 0.2 )
        elseif( active.label != BRICKS_SERVER.Func.L( "config" ) and (self:GetWide() != originalW or self:GetTall() != originalH) ) then
            self:SizeTo( originalW, originalH, 0.2 )
        end
    end

    local donationRank
    for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
        if( BRICKS_SERVER.Func.IsInGroup( LocalPlayer(), v[1] ) ) then
            donationRank = k
            break
        end
    end

    local height = 55
    local avatarBackSize = height
    local textStartPos = 65
    
    local avatarBack = vgui.Create( "DPanel", self.sheet.Navigation )
    avatarBack:Dock( TOP )
    avatarBack:DockMargin( 10, 10, 0, 10 )
    avatarBack:SetTall( height )
    avatarBack.Paint = function( self2, w, h )
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
        draw.NoTexture()
        BRICKS_SERVER.Func.DrawCircle( (h-avatarBackSize)*0.5+(avatarBackSize*0.5), h*0.5, avatarBackSize*0.5, 45 )

        draw.SimpleText( LocalPlayer():Nick(), "BRICKS_SERVER_Font23", textStartPos, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )

        if( BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank] ) then
            draw.SimpleText( BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank][1], "BRICKS_SERVER_Font20", textStartPos, h*0.5-2, (BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank][3] or BRICKS_SERVER.Func.GetTheme( 5 )), 0, 0 )
        else
            draw.SimpleText( BRICKS_SERVER.Func.GetAdminGroup( LocalPlayer() ), "BRICKS_SERVER_Font20", textStartPos, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
        end
    end

    local distance = 2

    local avatarIcon = vgui.Create( "bricks_server_circle_avatar" , avatarBack )
    avatarIcon:SetPos( (height-avatarBackSize)*0.5+distance, (height-avatarBackSize)*0.5+distance )
    avatarIcon:SetSize( avatarBackSize-(2*distance), avatarBackSize-(2*distance) )
    avatarIcon:SetPlayer( LocalPlayer(), 64 )

    local profilePage = vgui.Create( "bricks_server_profile", self.sheet )
    profilePage:Dock( FILL )
    profilePage:DockMargin( 10, 10, 10, 10 )
    profilePage:FillPanel( self )
    profilePage.Paint = function( self, w, h ) end 
    self.sheet:AddSheet( BRICKS_SERVER.Func.L( "profile" ), profilePage, false, "profile_24.png" )

    local settingsPage = vgui.Create( "bricks_server_settings", self.sheet )
    settingsPage:Dock( FILL )
    settingsPage:DockMargin( 10, 10, 10, 10 )
    settingsPage.Paint = function( self, w, h ) end 
    self.sheet:AddSheet( BRICKS_SERVER.Func.L( "settings" ), settingsPage, false, "settings_24.png" )

    self.adminCreated = nil
    
    function self.RefreshAdminPerms()
        if( BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) and not self.adminCreated ) then
            self.sheet:AddLinebreak()
            
            -- PLAYERS PAGE --
            local adminPlayersPanelBack = vgui.Create( "bricks_server_admin", self.sheet )
            adminPlayersPanelBack:Dock( FILL )
            adminPlayersPanelBack.Paint = function( self, w, h ) end 
            self.sheet:AddSheet( BRICKS_SERVER.Func.L( "players" ), adminPlayersPanelBack, false, "players_24.png" )

            -- MODULES PAGE --
            local adminModulesPanel = vgui.Create( "bricks_server_config_modules", self.sheet )
            adminModulesPanel:Dock( FILL )
            adminModulesPanel.Paint = function( self, w, h ) end 
            self.sheet:AddSheet( BRICKS_SERVER.Func.L( "modules" ), adminModulesPanel, function()
                adminModulesPanel:FillPanel() 
            end, "modules_24.png" )

            -- CONFIG PAGE --
            local adminConfigPanel = vgui.Create( "bricks_server_config", self.sheet )
            adminConfigPanel:Dock( FILL )
            adminConfigPanel.Paint = function( self, w, h ) end 
            self.sheet:AddSheet( BRICKS_SERVER.Func.L( "config" ), adminConfigPanel, function()
                adminConfigPanel:FillPanel() 
            end, "admin_24.png" )

            self.adminCreated = true
        end
    end
    self.RefreshAdminPerms()

    if( self.previousSheet ) then
        self.sheet:SetActiveSheet( self.previousSheet )
    end
end

vgui.Register( "bricks_server_menu", PANEL, "bricks_server_dframe" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_navcategorycollapse.lua:

local PANEL = {}

function PANEL:Init()
	self:SetContentAlignment( 4 )
	self:SetTextInset( 5, 0 )
	self:SetFont( "DermaDefaultBold" )

	self.changeAlpha = 0
end

function PANEL:DoClick()
	self:GetParent():Toggle()
	
	if( self:GetParent().OnNavCollapse ) then
		self:GetParent().OnNavCollapse( self.headerText, not self:GetParent():GetExpanded() )
	end
end

function PANEL:Paint( w, h )
	if( self:IsDown() ) then
		self.changeAlpha = 100
	elseif( self:IsHovered() ) then
		self.changeAlpha = math.Clamp( self.changeAlpha+10, 50, 75 )
	else
		self.changeAlpha = math.Clamp( self.changeAlpha-10, 50, 100 )
	end

	surface.SetAlphaMultiplier( self.changeAlpha/255 )
		surface.SetDrawColor( self.backColor or BRICKS_SERVER.Func.GetTheme( 4 ) )
		surface.DrawRect( 0, 0, w, h )
	surface.SetAlphaMultiplier( 1 )

	draw.SimpleText( (self.headerText or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font20", 10, h*0.5, (self.backColor or BRICKS_SERVER.Func.GetTheme( 5 )), 0, TEXT_ALIGN_CENTER )
end

derma.DefineControl( "bricks_server_navcategoryheader", "Category Header", PANEL, "DButton" )

local PANEL = {}

AccessorFunc( PANEL, "m_bSizeExpanded",		"Expanded", FORCE_BOOL )
AccessorFunc( PANEL, "m_iContentHeight",	"StartHeight" )
AccessorFunc( PANEL, "m_fAnimTime",			"AnimTime" )
AccessorFunc( PANEL, "m_bDrawBackground",	"PaintBackground", FORCE_BOOL )
AccessorFunc( PANEL, "m_bDrawBackground",	"DrawBackground", FORCE_BOOL ) -- deprecated
AccessorFunc( PANEL, "m_iPadding",			"Padding" )
AccessorFunc( PANEL, "m_pList",				"List" )

function PANEL:Init()
	self.Header = vgui.Create( "bricks_server_navcategoryheader", self )
	self.Header:Dock( TOP )
	self.Header:SetSize( 20, 30 )
	self.Header:SetText( "" )

	self:SetSize( 16, 16 )
	self:SetExpanded( true )
	self:SetMouseInputEnabled( true )

	self:SetAnimTime( 0.2 )
	self.animSlide = Derma_Anim( "Anim", self, self.AnimSlide )

	self:SetPaintBackground( true )
	self:DockPadding( 0, 0, 0, 5 )
end

function PANEL:UnselectAll()

	local children = self:GetChildren()
	for k, v in pairs( children ) do

		if ( v.SetSelected ) then
			v:SetSelected( false )
		end

	end

end

function PANEL:UpdateAltLines()

	local children = self:GetChildren()
	for k, v in pairs( children ) do
		v.AltLine = k % 2 != 1
	end

end

function PANEL:Think()

	self.animSlide:Run()

end

function PANEL:SetLabel( strLabel )
	self.Header.headerText = strLabel
end

function PANEL:GetLabel()
	return self.Header.headerText or ""
end

function PANEL:SetBackColor( color )
	self.Header.backColor = color
end

function PANEL:Paint( w, h )

end

function PANEL:SetContents( pContents )

	self.Contents = pContents
	self.Contents:SetParent( self )
	self.Contents:Dock( FILL )

	if ( !self:GetExpanded() ) then

		self.OldHeight = self:GetTall()

	elseif ( self:GetExpanded() && IsValid( self.Contents ) && self.Contents:GetTall() < 1 ) then

		self.Contents:SizeToChildren( false, true )
		self.OldHeight = self.Contents:GetTall()
		self:SetTall( self.OldHeight )

	end

	self:InvalidateLayout( true )

end

function PANEL:SetExpanded( expanded )
	self.m_bSizeExpanded = tobool( expanded )

	if ( !self:GetExpanded() ) then
		if ( !self.animSlide.Finished && self.OldHeight ) then return end
		self.OldHeight = self:GetTall()
	end
end

function PANEL:Toggle()
	self:SetExpanded( !self:GetExpanded() )

	self.animSlide:Start( self:GetAnimTime(), { From = self:GetTall() } )

	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

	local open = "1"
	if ( !self:GetExpanded() ) then open = "0" end
	self:SetCookie( "Open", open )

	self:OnToggle( self:GetExpanded() )
end

function PANEL:OnToggle( expanded )

	-- Do nothing / For developers to overwrite

end

function PANEL:DoExpansion( b )

	if ( self:GetExpanded() == b ) then return end
	self:Toggle()

end

function PANEL:PerformLayout()

	if ( IsValid( self.Contents ) ) then

		if ( self:GetExpanded() ) then
			self.Contents:InvalidateLayout( true )
			self.Contents:SetVisible( true )
		else
			self.Contents:SetVisible( false )
		end

	end

	if ( self:GetExpanded() ) then

		if ( IsValid( self.Contents ) && #self.Contents:GetChildren() > 0 ) then self.Contents:SizeToChildren( false, true ) end
		self:SizeToChildren( false, true )

	else

		if ( IsValid( self.Contents ) && !self.OldHeight ) then self.OldHeight = self.Contents:GetTall() end
		self:SetTall( self.Header:GetTall() )

	end

	-- Make sure the color of header text is set
	self.Header:ApplySchemeSettings()

	self.animSlide:Run()
	self:UpdateAltLines()

end

function PANEL:OnMousePressed( mcode )

	if ( !self:GetParent().OnMousePressed ) then return end

	return self:GetParent():OnMousePressed( mcode )

end

function PANEL:AnimSlide( anim, delta, data )

	self:InvalidateLayout()
	self:InvalidateParent()

	if ( anim.Started ) then
		if ( !IsValid( self.Contents ) && ( self.OldHeight || 0 ) < self.Header:GetTall() ) then
			-- We are not using self.Contents and our designated height is less
			-- than the header size, something is clearly wrong, try to rectify
			self.OldHeight = 0
			for id, pnl in pairs( self:GetChildren() ) do
				self.OldHeight = self.OldHeight + pnl:GetTall()
			end
		end

		if ( self:GetExpanded() ) then
			data.To = math.max( self.OldHeight, self:GetTall() )
		else
			data.To = self:GetTall()
		end
	end

	if ( IsValid( self.Contents ) ) then self.Contents:SetVisible( true ) end

	self:SetTall( Lerp( delta, data.From, data.To ) )

end

function PANEL:LoadCookies()

	local Open = self:GetCookieNumber( "Open", 1 ) == 1

	self:SetExpanded( Open )
	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

end

derma.DefineControl( "bricks_server_navcategorycollapse", "Collapsable Category Panel", PANEL, "Panel" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_searchbar.lua:
local PANEL = {}

function PANEL:Init()
    self.search = vgui.Create( "bricks_server_search", self )
    self.search:Dock( FILL )
    self.search.OnChange = function()
        if( self.OnChange ) then
            self.OnChange()
        end
    end
    self.search.OnEnter = function()
        if( self.OnEnter ) then
            self.OnEnter()
        end
    end

    self:SetCornerRadius( 5 )
    self:SetRoundedCorners( true, true, true, true )
end

function PANEL:SetValue( val )
    return self.search:SetValue( val )
end

function PANEL:GetValue()
    return self.search:GetValue()
end

function PANEL:SetBackColor( color )
    self.backColor = color
end

function PANEL:SetHighlightColor( color )
    self.highlightColor = color
end

function PANEL:SetCornerRadius( cornerRadius )
    self.cornerRadius = cornerRadius
end

function PANEL:SetRoundedCorners( roundTopLeft, roundTopRight, roundBottomLeft, roundBottomRight )
    self.roundTopLeft, self.roundTopRight, self.roundBottomLeft, self.roundBottomRight = roundTopLeft, roundTopRight, roundBottomLeft, roundBottomRight
end

local search = Material( "materials/bricks_server/search.png" )
local alpha, alpha2 = 0, 20
function PANEL:Paint( w, h )
    draw.RoundedBoxEx( self.cornerRadius, 0, 0, w, h, (self.backColor or BRICKS_SERVER.Func.GetTheme( 3 )), self.roundTopLeft, self.roundTopRight, self.roundBottomLeft, self.roundBottomRight )

    if( self.search:IsEditing() ) then
        alpha = math.Clamp( alpha+5, 0, 100 )
        alpha2 = math.Clamp( alpha2+20, 20, 255 )
    else
        alpha = math.Clamp( alpha-5, 0, 100 )
        alpha2 = math.Clamp( alpha2-20, 20, 255 )
    end
    
    surface.SetAlphaMultiplier( alpha/255 )
    draw.RoundedBoxEx( self.cornerRadius, 0, 0, w, h, (self.highlightColor or BRICKS_SERVER.Func.GetTheme( 2 )), self.roundTopLeft, self.roundTopRight, self.roundBottomLeft, self.roundBottomRight )
    surface.SetAlphaMultiplier( 1 )

    surface.SetDrawColor( 255, 255, 255, alpha2 )
    surface.SetMaterial( search )
    local size = 24
    surface.DrawTexturedRect( w-size-(h-size)*0.5, (h-size)*0.5, size, size )
end

vgui.Register( "bricks_server_searchbar", PANEL, "DPanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/client/cl_gang_data.lua:
net.Receive( "BRS.Net.SetGangID", function()
    -- BRS_GANGID = net.ReadUInt( 16 )
    
    timer.Simple( 0.1, function() 
        hook.Run( "BRS.Hooks.RefreshGang" ) 
    end )
end )

net.Receive( "BRS.Net.SetGangTable", function()
    local gangID = net.ReadUInt( 16 )
    local gangTable = net.ReadTable()

    if( not BRICKS_SERVER_GANGS ) then
        BRICKS_SERVER_GANGS = {}
    end

    BRICKS_SERVER_GANGS[gangID] = gangTable

    hook.Run( "BRS.Hooks.RefreshGang" )
end )

net.Receive( "BRS.Net.SetGangTableValues", function()
    local gangID = net.ReadUInt( 16 )
    local valuesTable = net.ReadTable()

    if( not BRICKS_SERVER_GANGS ) then
        BRICKS_SERVER_GANGS = {}
    end

    if( not BRICKS_SERVER_GANGS[gangID] ) then
        BRICKS_SERVER_GANGS[gangID] = {}
    end

    local valuesChanged = {}
    for k, v in pairs( valuesTable ) do
        BRICKS_SERVER_GANGS[gangID][k] = v

        valuesChanged[k] = true
    end

    hook.Run( "BRS.Hooks.RefreshGang", valuesChanged )
end )

net.Receive( "BRS.Net.SetGangTableValue", function()
    local gangID = net.ReadUInt( 16 )
    local tableKey = net.ReadString()

    local dataType = (BRICKS_SERVER.DEVCONFIG.GangTableKeys[tableKey] or {})[2]

    if( not dataType ) then return end

    local tableValue
    if( dataType == "string" ) then
        tableValue = net.ReadString()
    elseif( dataType == "integer" ) then
        tableValue = net.ReadUInt( 32 )
    elseif( dataType == "table" ) then
        tableValue = net.ReadTable()
    end

    if( not tableValue ) then return end
    
    if( not BRICKS_SERVER_GANGS ) then
        BRICKS_SERVER_GANGS = {}
    end

    if( not BRICKS_SERVER_GANGS[gangID] ) then
        BRICKS_SERVER_GANGS[gangID] = {}
    end

    BRICKS_SERVER_GANGS[gangID][tableKey] = tableValue 

    hook.Run( "BRS.Hooks.RefreshGang", { [tableKey] = true } )
end )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_config_gang_upgrades.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( configPanel )
    function self.RefreshPanel()
        self:Clear()

        local sortedUpgrades = {}
        for k, v in pairs( BS_ConfigCopyTable.GANGS.Upgrades or {} ) do
            local upgradeTable = v
            upgradeTable.Key = k
            upgradeTable.SortValue = 1+((not v.Tiers and 100) or 0)

            table.insert( sortedUpgrades, upgradeTable )
        end

        table.SortByMember( sortedUpgrades, "SortValue", true )

        for k, v in pairs( sortedUpgrades ) do
            local devConfigTable = BRICKS_SERVER.DEVCONFIG.GangUpgrades[v.Type or v.Key]

            local itemActions = {
                [1] = { BRICKS_SERVER.Func.L( "edit" ), function()
                    BRICKS_SERVER.Func.CreateUpgradeEditor( v, v.Key, function( upgradeTable ) 
                        BS_ConfigCopyTable.GANGS.Upgrades[v.Key] = upgradeTable
                        BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                        self.RefreshPanel()
                    end, function() end )
                end }
            }

            if( devConfigTable ) then
                if( devConfigTable.Unlimited ) then
                    table.insert( itemActions, { BRICKS_SERVER.Func.L( "remove" ), function()
                        BS_ConfigCopyTable.GANGS.Upgrades[v.Key] = nil
                        BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                        self.RefreshPanel()
                    end, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed } )
                else
                    table.insert( itemActions, { BRICKS_SERVER.Func.L( "gangAddTier" ), function()
                        if( not BS_ConfigCopyTable.GANGS.Upgrades[v.Key].Tiers ) then
                            BS_ConfigCopyTable.GANGS.Upgrades[v.Key].Tiers = {}
                        end

                        table.insert( BS_ConfigCopyTable.GANGS.Upgrades[v.Key].Tiers, {
                            Price = 1500,
                            ReqInfo = {}
                        } )

                        BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                        self.RefreshPanel()
                    end, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green } ) 
                end
            end


            local itemBackPanel = vgui.Create( "DPanel", self )
            itemBackPanel:Dock( TOP )
            itemBackPanel:DockMargin( 0, 0, 0, 5 )
            itemBackPanel:SetTall( 100 )
            itemBackPanel.Paint = function( self2, w, h )
                surface.SetAlphaMultiplier( 50/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.SetAlphaMultiplier( 1 )
            end

            local itemBack = vgui.Create( "DPanel", itemBackPanel )
            itemBack:Dock( TOP )
            itemBack:SetTall( 100 )
            itemBack:DockPadding( 0, 0, 25, 0 )
            local iconMat
            BRICKS_SERVER.Func.GetImage( v.Icon or "", function( mat ) iconMat = mat end )
            itemBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                draw.RoundedBox( 5, 5, 5, h-10, h-10, BRICKS_SERVER.Func.GetTheme( 2 ) )

                if( iconMat ) then
                    surface.SetDrawColor( 255, 255, 255, 255 )
                    surface.SetMaterial( iconMat )
                    local size = 64
                    surface.DrawTexturedRect( (h-size)*0.5, (h-size)*0.5, size, size )
                end

                draw.SimpleText( v.Name, "BRICKS_SERVER_Font33", h+15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                draw.SimpleText( (v.Description or BRICKS_SERVER.Func.L( "noDescription" )), "BRICKS_SERVER_Font20", h+15, 32, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
            end

            for key2, val2 in ipairs( itemActions ) do
                local itemAction = vgui.Create( "DButton", itemBack )
                itemAction:Dock( RIGHT )
                itemAction:SetText( "" )
                itemAction:DockMargin( 5, 25, 0, 25 )
                surface.SetFont( "BRICKS_SERVER_Font25" )
                local textX, textY = surface.GetTextSize( val2[1] )
                textX = textX+20
                itemAction:SetWide( math.max( (ScrW()/2560)*150, textX ) )
                local changeAlpha = 0
                itemAction.Paint = function( self2, w, h )
                    if( self2:IsHovered() and not self2:IsDown() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
                    else
                        changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
                    end
                    
                    draw.RoundedBox( 5, 0, 0, w, h, val2[3] or BRICKS_SERVER.Func.GetTheme( 2 ) )
            
                    surface.SetAlphaMultiplier( changeAlpha/255 )
                        draw.RoundedBox( 5, 0, 0, w, h, val2[4] or BRICKS_SERVER.Func.GetTheme( 3 ) )
                    surface.SetAlphaMultiplier( 1 )

                    BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, val2[4] or BRICKS_SERVER.Func.GetTheme( 3 ) )
            
                    draw.SimpleText( val2[1], "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end
                itemAction.DoClick = function()
                    val2[2]()
                end
            end

            if( devConfigTable ) then
                if( not devConfigTable.Unlimited ) then
                    local tierCount = #v.Tiers
                    local tierTall = 40

                    itemBackPanel:SetTall( 100+(tierCount*(tierTall+5))+5 )

                    for key, val in pairs( v.Tiers ) do
                        local currentText = 0
                        local currentReqInfo = v.Default or {}
                        if( val.ReqInfo ) then
                            currentReqInfo = val.ReqInfo
                        end
        
                        if( devConfigTable.Format ) then
                            currentText = devConfigTable.Format( currentReqInfo )
                        else
                            currentText = currentReqInfo[1] or 0
                        end

                        local tierBack = vgui.Create( "DPanel", itemBackPanel )
                        tierBack:Dock( TOP )
                        tierBack:DockMargin( 5, 5, 5, 0 )
                        tierBack:SetTall( tierTall )
                        local width = 75
                        tierBack.Paint = function( self2, w, h )
                            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

                            draw.RoundedBoxEx( 5, 0, 0, width, h, BRICKS_SERVER.Func.GetTheme( 2 ), true, false, true, false )

                            draw.SimpleText( BRICKS_SERVER.Func.L( "gangTierX", key ), "BRICKS_SERVER_Font23", width*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

                            draw.SimpleText( currentText, "BRICKS_SERVER_Font20", width+10, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
                        end

                        surface.SetFont( "BRICKS_SERVER_Font20" )
                        local reqInfoX, reqInfoY = surface.GetTextSize( currentText )

                        local tierNoticeBack = vgui.Create( "DPanel", tierBack )
                        tierNoticeBack:SetSize( 0, 35 )
                        tierNoticeBack:SetPos( width+10+reqInfoX+10, (tierBack:GetTall()*0.5)-(tierNoticeBack:GetTall()*0.5) )
                        tierNoticeBack.Paint = function( self2, w, h ) end

                        local itemNotices = {}

                        table.insert( itemNotices, { DarkRP.formatMoney( val.Price or 0 ), BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen } )

                        if( val.Level ) then
                            table.insert( itemNotices, { BRICKS_SERVER.Func.L( "levelX", val.Level ) } )
                        end

                        if( val.Group ) then
                            local groupTable
                            for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
                                if( v[1] == val.Group ) then
                                    groupTable = v
                                end
                            end

                            if( groupTable ) then
                                table.insert( itemNotices, { (groupTable[1] or BRICKS_SERVER.Func.L( "none" )), groupTable[3] } )
                            end
                        end

                        for k, v in pairs( itemNotices ) do
                            surface.SetFont( "BRICKS_SERVER_Font20" )
                            local textX, textY = surface.GetTextSize( v[1] )
                            local boxW, boxH = textX+10, textY

                            local itemInfoNotice = vgui.Create( "DPanel", tierNoticeBack )
                            itemInfoNotice:Dock( LEFT )
                            itemInfoNotice:DockMargin( 0, 0, 5, 0 )
                            itemInfoNotice:SetWide( boxW )
                            itemInfoNotice.Paint = function( self2, w, h ) 
                                draw.RoundedBox( 5, 0, 0, w, h, (v[2] or BRICKS_SERVER.Func.GetTheme( 5 )) )
                                draw.SimpleText( v[1], "BRICKS_SERVER_Font20", w*0.5, (h*0.5)-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                            end

                            if( tierNoticeBack:GetWide() <= 5 ) then
                                tierNoticeBack:SetSize( tierNoticeBack:GetWide()+boxW, boxH )
                            else
                                tierNoticeBack:SetSize( tierNoticeBack:GetWide()+5+boxW, boxH )
                            end
                            tierNoticeBack:SetPos( width+10+reqInfoX+10, (tierBack:GetTall()*0.5)-(tierNoticeBack:GetTall()*0.5) )
                        end

                        local tierEdit = vgui.Create( "DButton", tierBack )
                        tierEdit:Dock( RIGHT )
                        tierEdit:SetWide( tierBack:GetTall() )
                        tierEdit:SetText( "" )
                        local Alpha = 0
                        local editMat = Material( "bricks_server/edit.png" )
                        tierEdit.Paint = function( self2, w, h ) 
                            if( not self2:IsDown() and self2:IsHovered() ) then
                                Alpha = math.Clamp( Alpha+5, 0, 100 )
                            else
                                Alpha = math.Clamp( Alpha-5, 0, 100 )
                            end
                        
                            draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ), false, true, false, true )
                
                            surface.SetAlphaMultiplier( Alpha/255 )
                            draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, true, false, true )
                            surface.SetAlphaMultiplier( 1 )
                
                            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                
                            surface.SetDrawColor( 255, 255, 255, 20+(235*(Alpha/100)) )
                            surface.SetMaterial( editMat )
                            local iconSize = 24
                            surface.DrawTexturedRect( (h*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
                        end
                        tierEdit.DoClick = function()
                            BRICKS_SERVER.Func.CreateUpgradeTierEditor( val, key, v, v.Key, function( tierTable ) 
                                BS_ConfigCopyTable.GANGS.Upgrades[v.Key].Tiers[key] = tierTable
                                BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                                self.RefreshPanel()
                            end, function() end )
                        end

                        local tierRemove = vgui.Create( "DButton", tierBack )
                        tierRemove:Dock( RIGHT )
                        tierRemove:SetWide( tierBack:GetTall() )
                        tierRemove:SetText( "" )
                        local Alpha = 0
                        local deleteMat = Material( "bricks_server/delete.png" )
                        tierRemove.Paint = function( self2, w, h ) 
                            if( not self2:IsDown() and self2:IsHovered() ) then
                                Alpha = math.Clamp( Alpha+5, 0, 100 )
                            else
                                Alpha = math.Clamp( Alpha-5, 0, 100 )
                            end
                        
                            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
                            surface.DrawRect( 0, 0, w, h )
                
                            surface.SetAlphaMultiplier( Alpha/255 )
                            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                            surface.DrawRect( 0, 0, w, h )
                            surface.SetAlphaMultiplier( 1 )
                
                            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                
                            surface.SetDrawColor( 255, 255, 255, 20+(235*(Alpha/100)) )
                            surface.SetMaterial( deleteMat )
                            local iconSize = 24
                            surface.DrawTexturedRect( (h*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
                        end
                        tierRemove.DoClick = function()
                            table.remove( BS_ConfigCopyTable.GANGS.Upgrades[v.Key].Tiers, key )
                            BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                            self.RefreshPanel()
                        end
                    end
                else
                    surface.SetFont( "BRICKS_SERVER_Font33" )
                    local nameX, nameY = surface.GetTextSize( v.Name )
        
                    local noticeBack = vgui.Create( "DPanel", itemBack )
                    noticeBack:SetSize( 0, 35 )
                    noticeBack:SetPos( itemBack:GetTall()+15+nameX+10, 5+(nameY*0.5)-(noticeBack:GetTall()*0.5) )
                    noticeBack.Paint = function( self2, w, h ) end
        
                    local itemNotices = {}
        
                    table.insert( itemNotices, { DarkRP.formatMoney( v.Price or 0 ), BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen } )
        
                    if( v.Level ) then
                        table.insert( itemNotices, { BRICKS_SERVER.Func.L( "levelX", v.Level ) } )
                    end
        
                    if( v.Group ) then
                        local groupTable
                        for key, val in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
                            if( val[1] == v.Group ) then
                                groupTable = val
                            end
                        end
        
                        if( groupTable ) then
                            table.insert( itemNotices, { (groupTable[1] or BRICKS_SERVER.Func.L( "none" )), groupTable[3] } )
                        end
                    end
        
                    for k, v in pairs( itemNotices ) do
                        surface.SetFont( "BRICKS_SERVER_Font23" )
                        local textX, textY = surface.GetTextSize( v[1] )
                        local boxW, boxH = textX+10, textY
        
                        local itemInfoNotice = vgui.Create( "DPanel", noticeBack )
                        itemInfoNotice:Dock( LEFT )
                        itemInfoNotice:DockMargin( 0, 0, 5, 0 )
                        itemInfoNotice:SetWide( boxW )
                        itemInfoNotice.Paint = function( self2, w, h ) 
                            draw.RoundedBox( 5, 0, 0, w, h, (v[2] or BRICKS_SERVER.Func.GetTheme( 5 )) )
                            draw.SimpleText( v[1], "BRICKS_SERVER_Font23", w*0.5, (h*0.5)-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                        end
        
                        if( noticeBack:GetWide() <= 5 ) then
                            noticeBack:SetSize( noticeBack:GetWide()+boxW, boxH )
                        else
                            noticeBack:SetSize( noticeBack:GetWide()+5+boxW, boxH )
                        end
                        noticeBack:SetPos( itemBack:GetTall()+15+nameX+10, 5+(nameY*0.5)-(noticeBack:GetTall()*0.5)+1 )
                    end
                end
            end
        end

        local addNewButton = vgui.Create( "DButton", self )
        addNewButton:Dock( TOP )
        addNewButton:SetText( "" )
        addNewButton:DockMargin( 0, 0, 0, 5 )
        addNewButton:SetTall( 40 )
        local changeAlpha = 0
        addNewButton.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
            elseif( self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( 1 )
    
            draw.SimpleText( "Add Upgrade", "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        addNewButton.DoClick = function()
            local options = {}
			for k, v in pairs( BRICKS_SERVER.DEVCONFIG.GangUpgrades ) do
				if( not v.Unlimited and BS_ConfigCopyTable.GANGS.Upgrades[k] ) then continue end

				options[k] = v.Name
			end

			BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "gangNewUpgradeType" ), "", options, function( value, data ) 
				if( options[data] and BRICKS_SERVER.DEVCONFIG.GangUpgrades[data] ) then
                    local newUpgrade = {
                        Name = BRICKS_SERVER.Func.L( "gangNewUpgrade" ), 
                        Description = BRICKS_SERVER.Func.L( "gangNewUpgradeDesc" ),
                        Icon = "upgrade.png",
                    }

                    local key = data
                    if( BRICKS_SERVER.DEVCONFIG.GangUpgrades[data].Unlimited ) then
                        newUpgrade.Type = data
                        newUpgrade.ReqInfo = {}
                        newUpgrade.Price = 1500

                        local currentNum = 1
                        key = data .. "_1"

                        while BS_ConfigCopyTable.GANGS.Upgrades[key] do
                            currentNum = currentNum+1

                            key = data .. "_" .. currentNum
                        end
                    else
                        newUpgrade.Default = {}
                        newUpgrade.Tiers = {}
                    end
        
                    BS_ConfigCopyTable.GANGS.Upgrades[key] = newUpgrade
                    BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                    self.RefreshPanel()
				else
					notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidType" ), 1, 3 )
				end
            end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_gang_upgrades", PANEL, "bricks_server_scrollpanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_gangmenu_admin.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( gangTable )
    local panelTall = (ScrH()*0.65)-40

    local function CreateLoadingPopout()
        if( IsValid( self.popout ) ) then
            self.popout:Remove()
        end

        local popoutClose = vgui.Create( "DPanel", self )
        popoutClose:SetSize( self.panelWide, panelTall )
        popoutClose:SetAlpha( 0 )
        popoutClose:AlphaTo( 255, 0.2 )
        popoutClose.Paint = function( self2, w, h )
            surface.SetDrawColor( 0, 0, 0, 150 )
            surface.DrawRect( 0, 0, w, h )
            BRICKS_SERVER.Func.DrawBlur( self2, 2, 2 )
        end

        local popoutWide, popoutTall = self.panelWide*0.65, panelTall*0.25

        self.popout = vgui.Create( "DPanel", self )
        self.popout:SetSize( 0, 0 )
        self.popout:SizeTo( popoutWide, popoutTall, 0.2 )
        self.popout.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        end
        self.popout.OnSizeChanged = function( self2 )
            self2:SetPos( (self.panelWide*0.5)-(self2:GetWide()*0.5), (panelTall*0.5)-(self2:GetTall()*0.5) )
        end
        self.popout.ClosePopout = function()
            if( IsValid( self.popout ) ) then
                self.popout:SizeTo( 0, 0, 0.2, 0, -1, function()
                    if( IsValid( self.popout ) ) then
                        self.popout:Remove()
                    end
                end )
            end

            popoutClose:AlphaTo( 0, 0.2, 0, function()
                if( IsValid( popoutClose ) ) then
                    popoutClose:Remove()
                end
            end )
        end

        local actionButton = vgui.Create( "DButton", self.popout )
        actionButton:Dock( BOTTOM )
        actionButton:SetTall( 40 )
        actionButton:SetText( "" )
        actionButton:DockMargin( 25, 0, 25, 25 )
        local changeAlpha = 0
        actionButton.Paint = function( self2, w, h )
            if( not self2:IsDown() and self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            surface.SetAlphaMultiplier( 1 )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            
            draw.SimpleText( BRICKS_SERVER.Func.L( "cancel" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        actionButton.DoClick = self.popout.ClosePopout

        local loadingPanel = vgui.Create( "DPanel", self.popout )
        loadingPanel:Dock( FILL )
        loadingPanel:DockMargin( 25, 10, 25, 10 )
        local loadingIcon = Material( "materials/bricks_server/loading.png" )
        loadingPanel.Paint = function( self2, w, h )
            surface.SetDrawColor( 255, 255, 255, 255 )
            surface.SetMaterial( loadingIcon )
            local size = 32
            surface.DrawTexturedRectRotated( w*0.5, h*0.5, size, size, -(CurTime() % 360 * 250) )
        
            draw.SimpleText( BRICKS_SERVER.Func.L( "loading" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5+(size*0.5)+5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
        end
    end

    local function CreateGangPopout( gangID )
        if( IsValid( self.adminPopout ) ) then
            self.adminPopout:Remove()
        end

        self.adminPopout = vgui.Create( "bricks_server_gangmenu_admin_popup", self )
        self.adminPopout:SetSize( self.panelWide, panelTall )
        self.adminPopout:FillPanel( self.panelWide, panelTall )
    end

    local topBar = vgui.Create( "DPanel", self )
    topBar:Dock( TOP )
    topBar:DockMargin( 10, 10, 10, 5 )
    topBar:SetTall( 40 )
    topBar.Paint = function( self2, w, h ) end

    local searchBarBack = vgui.Create( "DPanel", topBar )
    searchBarBack:Dock( FILL )
    local search = Material( "materials/bricks_server/search.png" )
    local Alpha = 0
    local Alpha2 = 20
    local searchBar
    local color1 = BRICKS_SERVER.Func.GetTheme( 2 )
    searchBarBack.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

        if( searchBar:IsEditing() ) then
            Alpha = math.Clamp( Alpha+5, 0, 100 )
            Alpha2 = math.Clamp( Alpha2+20, 20, 255 )
        else
            Alpha = math.Clamp( Alpha-5, 0, 100 )
            Alpha2 = math.Clamp( Alpha2-20, 20, 255 )
        end
        
        draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )
    
        surface.SetDrawColor( 255, 255, 255, Alpha2 )
        surface.SetMaterial(search)
        local size = 24
        surface.DrawTexturedRect( w-size-(h-size)*0.5, (h-size)*0.5, size, size )
    end
    
    searchBar = vgui.Create( "bricks_server_search", searchBarBack )
    searchBar:Dock( FILL )
    searchBar.OnEnter = function()
        CreateLoadingPopout()

        local canRequest, errorMsg, waitTime = BRICKS_SERVER.Func.RequestAdminGangs( searchBar:GetValue() or "" )

        if( not canRequest ) then
            timer.Create( "BRS_ADMIN_SEARCH_WAIT_" .. tostring( self ), (waitTime or 3), 1, function()
                local canRequest2, errorMsg2, waitTime2 = BRICKS_SERVER.Func.RequestAdminGangs( searchBar:GetValue() or "" )
                if( not canRequest2 ) then
                    BRICKS_SERVER.Func.Message( errorMsg, BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                end
            end )
        end
    end

    local scrollPanel = vgui.Create( "bricks_server_scrollpanel", self )
    scrollPanel:Dock( FILL )
    scrollPanel:DockMargin( 10, 0, 10, 10 )
    scrollPanel.Paint = function( self, w, h ) end 

    BRICKS_SERVER.Func.RequestAdminGangs( "" )

    function self.RefreshPanel( gangTables )
        scrollPanel:Clear()

        if( not gangTables or table.Count( gangTables or {} ) <= 0 ) then
            local text = BRICKS_SERVER.Func.L( "gangNoneFound" )
            surface.SetFont( "BRICKS_SERVER_Font25" )
            local textX, textY = surface.GetTextSize( text )
            textX, textY = textX+30, textY+20

            scrollPanel.Paint = function( self, w, h ) 
                draw.RoundedBox( 5, (w*0.5)-(textX*0.5), (h*0.5)-(textY*0.5), textX, textY, BRICKS_SERVER.Func.GetTheme( 3 ) )

                draw.SimpleText( text, "BRICKS_SERVER_Font23", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end 
        else
            scrollPanel.Paint = function( self, w, h ) end 
            
            for k, v in pairs( gangTables or {} ) do
                local text = BRICKS_SERVER.Func.L( "gangMemberCount", (v.MemberCount or 0), (v.MemberMax or 0) )
                surface.SetFont( "BRICKS_SERVER_Font23" )
                local textX, textY = surface.GetTextSize( text )
                local boxW, boxH = textX+15, textY+5
                local distance = boxW

                local itemBack = vgui.Create( "DPanel", scrollPanel )
                itemBack:Dock( TOP )
                itemBack:DockMargin( 0, 0, 0, 5 )
                itemBack:SetTall( 100 )
                local itemButton
                local clickColor = Color( BRICKS_SERVER.Func.GetTheme( 0 ).r, BRICKS_SERVER.Func.GetTheme( 0 ).g, BRICKS_SERVER.Func.GetTheme( 0 ).b, 50 )
                local alpha = 0
                itemBack.Paint = function( self2, w, h )
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

                    if( IsValid( itemButton ) ) then
                        if( not itemButton:IsDown() and itemButton:IsHovered() ) then
                            alpha = math.Clamp( alpha+3, 0, 50 )
                        else
                            alpha = math.Clamp( alpha-3, 0, 50 )
                        end
                
                        surface.SetAlphaMultiplier( alpha/255 )
                        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
                        surface.SetAlphaMultiplier( 1 )
            
                        BRICKS_SERVER.Func.DrawClickCircle( itemButton, w, h, clickColor )
                    end

                    draw.RoundedBox( 5, w-distance-(boxW*0.5), (h*0.5)-(boxH*0.5), boxW, boxH, (v[2] or BRICKS_SERVER.Func.GetTheme( 5 )) )
                    draw.SimpleText( text, "BRICKS_SERVER_Font23", w-distance, (h*0.5)-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end

                local avatarBack = vgui.Create( "DPanel", itemBack )
                avatarBack:Dock( FILL )
                avatarBack:DockMargin( 15, 15, 15, 15 )
                local avatarBackSize = 70
                local avatarSize = (v.Icon and avatarBackSize*0.6) or 32
                avatarBack.Paint = function( self2, w, h )
                    local textStartPos = avatarBackSize+15

                    surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
                    draw.NoTexture()
                    BRICKS_SERVER.Func.DrawCircle( (h-avatarBackSize)*0.5+(avatarBackSize*0.5), h*0.5, avatarBackSize*0.5, 45 )
            
                    draw.SimpleText( (v.Name or BRICKS_SERVER.Func.L( "gangNone" )), "BRICKS_SERVER_Font23", textStartPos, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )
            
                    draw.SimpleText( BRICKS_SERVER.Func.L( "gangID", k ), "BRICKS_SERVER_Font17", textStartPos, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                end

                local gangIcon = vgui.Create( "bricks_server_gangicon", avatarBack )
                gangIcon:SetSize( avatarSize, avatarSize )
                gangIcon:SetPos( (avatarBackSize-avatarSize)*0.5, (avatarBackSize-avatarSize)*0.5 )
                gangIcon:SetIconURL( v.Icon or "bricks_server/question.png" )

                itemButton = vgui.Create( "DButton", itemBack )
                itemButton:Dock( FILL )
                itemButton:SetText( "" )
                itemButton.Paint = function( self2, w, h ) end
                itemButton.DoClick = function()
                    local canRequest, errorMsg, waitTime = BRICKS_SERVER.Func.RequestAdminGangData( k )

                    if( not canRequest ) then
                        timer.Create( "BRS_ADMIN_DATA_WAIT_" .. tostring( self ), (waitTime or 3), 1, function()
                            local canRequest2, errorMsg2, waitTime2 = BRICKS_SERVER.Func.RequestAdminGangData( k )
                            if( not canRequest2 ) then
                                BRICKS_SERVER.Func.Message( errorMsg, BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                            end
                        end )
                    end

                    CreateGangPopout( k )
                end
            end
        end

        if( IsValid( self.popout ) ) then
            self.popout.ClosePopout()
        end
    end

    hook.Add( "BRS.Hooks.RefreshGangAdmin", self, function( self, gangTables )
        if( IsValid( self ) ) then
            self.RefreshPanel( gangTables )
        else
            hook.Remove( "BRS.Hooks.RefreshGangAdmin", self )
        end
    end )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_admin", PANEL, "DPanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/achievements/vgui/bricks_server_config_gang_achievements.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( configPanel )
    function self.RefreshPanel()
        self:Clear()

        local sortedAchievements = {}
        for k, v in pairs( BS_ConfigCopyTable.GANGS.Achievements or {} ) do
            local achievementTable = v
            achievementTable.Key = k

            table.insert( sortedAchievements, achievementTable )
        end

        table.SortByMember( sortedAchievements, "Name", true )

        for k, v in pairs( sortedAchievements ) do
            local devConfigTable = BRICKS_SERVER.DEVCONFIG.GangAchievements[v.Type or v.Key]

            local itemActions = {
                [1] = { BRICKS_SERVER.Func.L( "edit" ), function()
                    BRICKS_SERVER.Func.CreateAchievementEditor( v, function( achievementTable ) 
                        BS_ConfigCopyTable.GANGS.Achievements[v.Key] = achievementTable
                        BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                        self.RefreshPanel()
                    end, function() end )
                end },
                [2] = { BRICKS_SERVER.Func.L( "remove" ), function()
                    BS_ConfigCopyTable.GANGS.Achievements[v.Key] = nil
                    BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                    self.RefreshPanel()
                end, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed }
            }


            local itemBackPanel = vgui.Create( "DPanel", self )
            itemBackPanel:Dock( TOP )
            itemBackPanel:DockMargin( 0, 0, 0, 5 )
            itemBackPanel:SetTall( 100 )
            itemBackPanel.Paint = function( self2, w, h )
                surface.SetAlphaMultiplier( 50/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.SetAlphaMultiplier( 1 )
            end

            local itemBack = vgui.Create( "DPanel", itemBackPanel )
            itemBack:Dock( TOP )
            itemBack:SetTall( 100 )
            itemBack:DockPadding( 0, 0, 25, 0 )
            local iconMat
            BRICKS_SERVER.Func.GetImage( v.Icon or "", function( mat ) iconMat = mat end )
            itemBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                draw.RoundedBox( 5, 5, 5, h-10, h-10, BRICKS_SERVER.Func.GetTheme( 2 ) )

                if( iconMat ) then
                    surface.SetDrawColor( 255, 255, 255, 255 )
                    surface.SetMaterial( iconMat )
                    local size = 64
                    surface.DrawTexturedRect( (h-size)*0.5, (h-size)*0.5, size, size )
                end

                draw.SimpleText( v.Name, "BRICKS_SERVER_Font33", h+15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                draw.SimpleText( (v.Description or BRICKS_SERVER.Func.L( "noDescription" )), "BRICKS_SERVER_Font20", h+15, 32, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
            end

            for key2, val2 in ipairs( itemActions ) do
                local itemAction = vgui.Create( "DButton", itemBack )
                itemAction:Dock( RIGHT )
                itemAction:SetText( "" )
                itemAction:DockMargin( 5, 25, 0, 25 )
                surface.SetFont( "BRICKS_SERVER_Font25" )
                local textX, textY = surface.GetTextSize( val2[1] )
                textX = textX+20
                itemAction:SetWide( math.max( (ScrW()/2560)*150, textX ) )
                local changeAlpha = 0
                itemAction.Paint = function( self2, w, h )
                    if( self2:IsHovered() and not self2:IsDown() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
                    else
                        changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
                    end
                    
                    draw.RoundedBox( 5, 0, 0, w, h, val2[3] or BRICKS_SERVER.Func.GetTheme( 2 ) )
            
                    surface.SetAlphaMultiplier( changeAlpha/255 )
                        draw.RoundedBox( 5, 0, 0, w, h, val2[4] or BRICKS_SERVER.Func.GetTheme( 3 ) )
                    surface.SetAlphaMultiplier( 1 )

                    BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, val2[4] or BRICKS_SERVER.Func.GetTheme( 3 ) )
            
                    draw.SimpleText( val2[1], "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end
                itemAction.DoClick = function()
                    val2[2]()
                end
            end
        end

        local addNewButton = vgui.Create( "DButton", self )
        addNewButton:Dock( TOP )
        addNewButton:SetText( "" )
        addNewButton:DockMargin( 0, 0, 0, 5 )
        addNewButton:SetTall( 40 )
        local changeAlpha = 0
        addNewButton.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
            elseif( self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( 1 )
    
            draw.SimpleText( BRICKS_SERVER.Func.L( "gangAddAchievement" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        addNewButton.DoClick = function()
            local options = {}
			for k, v in pairs( BRICKS_SERVER.DEVCONFIG.GangAchievements ) do
				options[k] = v.Name
			end

			BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "gangNewAchievementType" ), "", options, function( value, data ) 
				if( options[data] and BRICKS_SERVER.DEVCONFIG.GangAchievements[data] ) then
                    table.insert( BS_ConfigCopyTable.GANGS.Achievements, {
                        Name = BRICKS_SERVER.Func.L( "gangNewAchievement" ), 
                        Description = BRICKS_SERVER.Func.L( "noDescription" ),
                        Icon = "gang_achievements.png",
                        Type = data,
                        ReqInfo = {},
                        Rewards = {}
                    } )

                    BRICKS_SERVER.Func.ConfigChange( "GANGS" )
                    self.RefreshPanel()
				else
					notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidType" ), 1, 3 )
				end
            end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_gang_achievements", PANEL, "bricks_server_scrollpanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/associations/vgui/bricks_server_gangmenu_associations.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( gangTable )
    local panelTall = (ScrH()*0.65)-40

    local function CreateLoadingPopout()
        if( IsValid( self.popout ) ) then
            self.popout:Remove()
        end

        local popoutClose = vgui.Create( "DPanel", self )
        popoutClose:SetSize( self.panelWide, panelTall )
        popoutClose:SetAlpha( 0 )
        popoutClose:AlphaTo( 255, 0.2 )
        popoutClose.Paint = function( self2, w, h )
            surface.SetDrawColor( 0, 0, 0, 150 )
            surface.DrawRect( 0, 0, w, h )
            BRICKS_SERVER.Func.DrawBlur( self2, 2, 2 )
        end

        local popoutWide, popoutTall = self.panelWide*0.65, panelTall*0.25

        self.popout = vgui.Create( "DPanel", self )
        self.popout:SetSize( 0, 0 )
        self.popout:SizeTo( popoutWide, popoutTall, 0.2 )
        self.popout.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        end
        self.popout.OnSizeChanged = function( self2 )
            self2:SetPos( (self.panelWide*0.5)-(self2:GetWide()*0.5), (panelTall*0.5)-(self2:GetTall()*0.5) )
        end
        self.popout.ClosePopout = function()
            if( IsValid( self.popout ) ) then
                self.popout:SizeTo( 0, 0, 0.2, 0, -1, function()
                    if( IsValid( self.popout ) ) then
                        self.popout:Remove()
                    end
                end )
            end

            popoutClose:AlphaTo( 0, 0.2, 0, function()
                if( IsValid( popoutClose ) ) then
                    popoutClose:Remove()
                end
            end )
        end

        local actionButton = vgui.Create( "DButton", self.popout )
        actionButton:Dock( BOTTOM )
        actionButton:SetTall( 40 )
        actionButton:SetText( "" )
        actionButton:DockMargin( 25, 0, 25, 25 )
        local changeAlpha = 0
        actionButton.Paint = function( self2, w, h )
            if( not self2:IsDown() and self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            surface.SetAlphaMultiplier( 1 )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            
            draw.SimpleText( BRICKS_SERVER.Func.L( "cancel" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        actionButton.DoClick = self.popout.ClosePopout

        local loadingPanel = vgui.Create( "DPanel", self.popout )
        loadingPanel:Dock( FILL )
        loadingPanel:DockMargin( 25, 10, 25, 10 )
        local loadingIcon = Material( "materials/bricks_server/loading.png" )
        loadingPanel.Paint = function( self2, w, h )
            surface.SetDrawColor( 255, 255, 255, 255 )
            surface.SetMaterial( loadingIcon )
            local size = 32
            surface.DrawTexturedRectRotated( w*0.5, h*0.5, size, size, -(CurTime() % 360 * 250) )
        
            draw.SimpleText( BRICKS_SERVER.Func.L( "loading" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5+(size*0.5)+5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
        end
    end

    local topBar = vgui.Create( "DPanel", self )
    topBar:Dock( TOP )
    topBar:DockMargin( 10, 10, 10, 5 )
    topBar:SetTall( 40 )
    topBar.Paint = function( self2, w, h ) end

    local searchBarBack = vgui.Create( "DPanel", topBar )
    searchBarBack:Dock( FILL )
    local search = Material( "materials/bricks_server/search.png" )
    local Alpha = 0
    local Alpha2 = 20
    local searchBar
    local color1 = BRICKS_SERVER.Func.GetTheme( 2 )
    searchBarBack.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

        if( searchBar:IsEditing() ) then
            Alpha = math.Clamp( Alpha+5, 0, 100 )
            Alpha2 = math.Clamp( Alpha2+20, 20, 255 )
        else
            Alpha = math.Clamp( Alpha-5, 0, 100 )
            Alpha2 = math.Clamp( Alpha2-20, 20, 255 )
        end
        
        draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )
    
        surface.SetDrawColor( 255, 255, 255, Alpha2 )
        surface.SetMaterial(search)
        local size = 24
        surface.DrawTexturedRect( w-size-(h-size)*0.5, (h-size)*0.5, size, size )
    end
    
    searchBar = vgui.Create( "bricks_server_search", searchBarBack )
    searchBar:Dock( FILL )
    searchBar.OnEnter = function()
        CreateLoadingPopout()

        local canRequest, errorMsg, waitTime = BRICKS_SERVER.Func.RequestAssociationGangs( searchBar:GetValue() or "" )

        if( not canRequest ) then
            timer.Create( "BRS_ASSOCIATION_WAIT_" .. tostring( self ), (waitTime or 3), 1, function()
                local canRequest2, errorMsg2, waitTime2 = BRICKS_SERVER.Func.RequestAssociationGangs( searchBar:GetValue() or "" )
                if( not canRequest2 ) then
                    BRICKS_SERVER.Func.Message( errorMsg, BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                end
            end )
        end
    end

    local scrollPanel = vgui.Create( "bricks_server_scrollpanel", self )
    scrollPanel:Dock( FILL )
    scrollPanel:DockMargin( 10, 0, 10, 10 )
    scrollPanel.Paint = function( self, w, h ) end 

    BRICKS_SERVER.Func.RequestAssociationGangs( "" )

    function self.RefreshPanel( gangTables )
        scrollPanel:Clear()

        if( not gangTables or table.Count( gangTables or {} ) <= 0 ) then
            local text = BRICKS_SERVER.Func.L( "gangNoneFound" )
            surface.SetFont( "BRICKS_SERVER_Font25" )
            local textX, textY = surface.GetTextSize( text )
            textX, textY = textX+30, textY+20

            scrollPanel.Paint = function( self, w, h ) 
                draw.RoundedBox( 5, (w*0.5)-(textX*0.5), (h*0.5)-(textY*0.5), textX, textY, BRICKS_SERVER.Func.GetTheme( 3 ) )

                draw.SimpleText( text, "BRICKS_SERVER_Font23", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end 
        else
            scrollPanel.Paint = function( self, w, h ) end 
            
            for k, v in pairs( gangTables ) do
                local associationType = BRICKS_SERVER.Func.GangsGetAssociation( LocalPlayer():GetGangID(), k )

                local itemBack = vgui.Create( "DPanel", scrollPanel )
                itemBack:Dock( TOP )
                itemBack:DockMargin( 0, 0, 0, 5 )
                itemBack:SetTall( 100 )
                itemBack.Paint = function( self2, w, h )
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                end

                if( LocalPlayer():GangHasPermission( "RequestAssociations" ) ) then
                    for key, val in pairs( BRICKS_SERVER.DEVCONFIG.GangAssociationTypes ) do
                        local associationButton = vgui.Create( "DButton", itemBack )
                        associationButton:Dock( RIGHT )
                        associationButton:DockMargin( 0, 10, 10, 10 )
                        associationButton:SetWide( itemBack:GetTall()-20 )
                        associationButton:SetText( "" )
                        local Alpha, iconAlpha = 0, 0
                        local iconMat
                        BRICKS_SERVER.Func.GetImage( val.Icon or "flag.png", function( mat ) 
                            iconMat = mat 
                        end )
                        local isAssociation = associationType == key
                        associationButton.Paint = function( self2, w, h )
                            if( self2:IsHovered() and not self2:IsDown() ) then
                                Alpha = math.Clamp( Alpha+5, 0, 50 )
                            else
                                Alpha = math.Clamp( Alpha-5, 0, 50 )
                            end
        
                            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        
                            surface.SetAlphaMultiplier( Alpha/255 )
                                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                            surface.SetAlphaMultiplier( 1 )

                            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
        
                            if( (self2:IsHovered() or isAssociation) and not self2:IsDown() ) then
                                iconAlpha = math.Clamp( iconAlpha+5, 20, 255 )
                            else
                                iconAlpha = math.Clamp( iconAlpha-5, 20, 255 )
                            end

                            surface.SetAlphaMultiplier( iconAlpha/255 )
                                if( iconMat ) then
                                    surface.SetDrawColor( (isAssociation and val.Color) or BRICKS_SERVER.Func.GetTheme( 6 ) )
                                    surface.SetMaterial( iconMat )
                                    local iconSize = 32
                                    surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
                                end
        
                                draw.SimpleText( string.upper( key ), "BRICKS_SERVER_Font15", w*0.5, h-5, ((isAssociation and val.Color) or BRICKS_SERVER.Func.GetTheme( 6 )), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
                            surface.SetAlphaMultiplier( 1 )
                        end
                        associationButton.DoClick = function()
                            if( not isAssociation ) then
                                BRICKS_SERVER.Func.Query( val.Query, BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                                    net.Start( "BRS.Net.RequestGangAssociation" )
                                        net.WriteString( key )
                                        net.WriteUInt( k, 16 )
                                    net.SendToServer()
                                end )
                            else
                                BRICKS_SERVER.Func.Query( BRICKS_SERVER.Func.L( "gangDissolveAssociation" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                                    net.Start( "BRS.Net.DissolveGangAssociation" )
                                        net.WriteUInt( k, 16 )
                                    net.SendToServer()
                                end )
                            end
                        end
                    end
                end

                local avatarBack = vgui.Create( "DPanel", itemBack )
                avatarBack:Dock( FILL )
                avatarBack:DockMargin( 15, 15, 15, 15 )
                local avatarBackSize = 70
                local avatarSize = (v.Icon and avatarBackSize*0.6) or 32
                avatarBack.Paint = function( self2, w, h )
                    local textStartPos = avatarBackSize+15

                    surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
                    draw.NoTexture()
                    BRICKS_SERVER.Func.DrawCircle( (h-avatarBackSize)*0.5+(avatarBackSize*0.5), h*0.5, avatarBackSize*0.5, 45 )
            
                    draw.SimpleText( (v.Name or BRICKS_SERVER.Func.L( "gangNone" )), "BRICKS_SERVER_Font23", textStartPos, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )
            
                    draw.SimpleText( BRICKS_SERVER.Func.L( "gangAssociationStatus", ((associationType and associationType) or BRICKS_SERVER.Func.L( "gangNeutral" )) ), "BRICKS_SERVER_Font17", textStartPos, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                end

                local gangIcon = vgui.Create( "bricks_server_gangicon", avatarBack )
                gangIcon:SetSize( avatarSize, avatarSize )
                gangIcon:SetPos( (avatarBackSize-avatarSize)*0.5, (avatarBackSize-avatarSize)*0.5 )
                gangIcon:SetIconURL( v.Icon or "bricks_server/question.png" )
            end
        end

        if( IsValid( self.popout ) ) then
            self.popout.ClosePopout()
        end
    end

    hook.Add( "BRS.Hooks.RefreshGangAssociations", self, function( self, gangTables )
        if( IsValid( self ) ) then
            if( gangTables ) then
                self.RefreshPanel( gangTables )
            else
                BRICKS_SERVER.Func.RequestAssociationGangs( searchBar:GetValue() or "" )
            end
        else
            hook.Remove( "BRS.Hooks.RefreshGangAssociations", self )
        end
    end )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_associations", PANEL, "DPanel" )
--PATH addons/_doctor/lua/blues_pharm_config.lua:
--NOTE: Don't use permaprop for the NPC's, use !savepillsellers instead.
BLUES_PHARMA = BLUES_PHARMA or {}
BLUES_PHARMA.CONFIG = {}

--This is how fast the "overdose" value goes down. This is per seconds (0 - 100)
--Default: 0.5 = Aprox 3 minutes from full overdose
BLUES_PHARMA.CONFIG.OverdoseCooldownRate = 2

--These are the ranks that have permission to do !savepillsellers
BLUES_PHARMA.CONFIG.AuthorisedRanks = {
	"owner",
	"superadmin"
}

--These are the prices of each full pill bottle sold at the pill market.
BLUES_PHARMA.CONFIG.SellPrices = {
	[1] = 10000, -- Aspirin
	[2] = 16000, -- Ibuprofen
	[3] = 13000, -- Naproxen
	[4] = 14000, -- Steroid
	[5] = 12000, -- Vitamin
	[6] = 12000, -- Corticosteroid
	[7] = 21000, -- Dianabol
	[8] = 17000 -- Anadrol
}  

--Set this to false if you don't wnat them to be able to eat the pills and get buffs
BLUES_PHARMA.CONFIG.CanConsumePills = true

--INFO: If you want to change more specific things about the recipes and there buff, do so in autorun/sh_blues_pharmaceuticals

--This is the maximum distance to render Cam3D2D UI at. This is Squared (Don't change it if you don't know what this means).
BLUES_PHARMA.CONFIG.Cam3D2DRenderDist = 400000  

BLUES_PHARMA.CONFIG.AddMoney = function(user, amount)
	user:AddMoney(amount)
end
--PATH addons/protection/lua/autorun/client/cl_net_debugger.lua:

-- TODO
hook.Add("Think", "LoadDebugOverlay", function()
hook.Remove("Think", "LoadDebugOverlay")

if IsValid(LocalPlayer()) and LocalPlayer():SteamID() == "STEAM_0:1:453714381" then
    local ipairs = ipairs
    local surface = surface
    local draw = draw

    print(LocalPlayer():GetEyeTrace().Entity)

    hook.Add("EntityEmitSound", "SoundOverlay", function(snd)
        if !snd.Pos or snd.Pos == vector_origin then return end

        if IsValid(snd.Entity) and (snd.SoundName:find("/footsteps/") or snd.SoundName:find("_footstep%d%.wav")) then
        elseif snd.SoundName:find("impact_bullet%d") then
            debugoverlay.Text(snd.Pos, "IMPACT", 5, false)
        else
            debugoverlay.Text(snd.Pos, snd.SoundName:match(".+/(.+)$"):gsub("%.wav$", ""), 10, false)
        end
    end)

    local breadCrumbs = setmetatable({}, {__mode = "k"})
    local MAX_CRUMBS = 2.5 / engine.TickInterval()
    hook.Add("HUDPaint", "ESP", function()
        for _, ply in ipairs(player.GetAll()) do
            do
                local scrPos = ply:GetPos():ToScreen()
                draw.SimpleText(ply:Nick(), "TargetID", scrPos.x, scrPos.y, ply:GetJobColor(), TEXT_ALIGN_CENTER)
                local _, yOffset = surface.GetTextSize(ply:Nick())
                draw.SimpleText(ply:GetUserGroup(), "TargetID", scrPos.x, scrPos.y + yOffset, color_white, TEXT_ALIGN_CENTER)
            end

            local crumbs = breadCrumbs[ply]
            if !crumbs then
                breadCrumbs[ply] = {}
                continue
            end

            crumbs[#crumbs + 1] = ply:GetPos()
            if #crumbs > MAX_CRUMBS then
                table.remove(crumbs, 1)
            end

            if #crumbs < 2 then continue end

            surface.SetDrawColor(ply:GetJobColor())
            for i = 1, #crumbs - 1 do
                local curPos = crumbs[i]:ToScreen()
                local nextPos = crumbs[i + 1]:ToScreen()
                surface.DrawLine(curPos.x, curPos.y, nextPos.x, nextPos.y)
            end
        end
    end)

    --
    local graphMt = {}
    graphMt.__index = graphMt

    function graphMt:Update()
        local data = self.dataProvider()
        self.data[#self.data + 1] = data
        if #self.data > self.maxDataSize then
            table.remove(self.data, 1)
        end

        self.ema = self.ema * self.emaFactor + data * (1 - self.emaFactor)

        local extremums = {}
        local extremumIndex = -100

        self.min = math.huge
        self.max = -math.huge
        for i = 1, #self.data do
            local data = self.data[i]
            self.min = math.min(self.min, data)
            self.max = math.max(self.max, data)

            if i > 1 and i <= #self.data - 1 then
                local prevData = self.data[i - 1]
                local nextData = self.data[i + 1]

                local grad = math.max(math.abs(data - nextData), math.abs(data - prevData))
                if grad > self.extremumThreshold then
                    extremums[#extremums + 1] = {i = i, grad = grad}
                end
            end
        end

        table.sort(extremums, function(a, b) return a.grad > b.grad end)

        self.topk = {}
        for i = 1, math.min(#extremums, self.k) do
            self.topk[extremums[i].i] = true
        end
    end

    function graphMt:Draw(x, y)
        surface.SetDrawColor(color_white)
        surface.DrawOutlinedRect(x, y, self.width, self.height)

        if #self.data < 2 then return end

        for i = 1, #self.data - 1 do
            local curData = self.data[i]
            local nextData = self.data[i + 1]

            local curDataNorm = (curData - self.min) / (self.max - self.min)
            local nextDataNorm = (nextData - self.min) / (self.max - self.min)

            local xPos = x + (i - 1) / #self.data * self.width
            local xPosNext = x + (i - 1 + 1) / #self.data * self.width

            local yPos = y + self.height - curDataNorm * self.height
            local yPosNext = y + self.height - nextDataNorm * self.height
            surface.DrawLine(xPos, yPos, xPosNext, yPosNext)

            if self.topk[i] then
                local text = self.dataFormatter(curData)
                draw.SimpleText(text, self.font, xPos, yPos, color_white, TEXT_ALIGN_CENTER)
            end
        end

        surface.SetFont(self.font)
        local _, textHeight = surface.GetTextSize("ABC")
        for i = 1, #self.textPainters do
            self.textPainters[i](self, x + 2, y + 2 + (i - 1) * textHeight)
        end
    end

    local function Graph(config)
        local obj = {
            dataProvider = config.dataProvider,
            dataFormatter = config.dataFormatter or tostring,
            textPainters = config.textPainters or {},

            font = config.font or "TargetID",
            width = config.width or 320,
            height = config.height or 130,

            data = {},
            maxDataSize = config.maxDataSize or 100,
            min = math.huge,
            max = -math.huge,
            ema = 0,
            emaFactor = config.emaFactor or 0.8,
            extremumThreshold = config.extremumThreshold or 1e-3,
            extremumInterval = config.extremumInterval or 5,
            topk = {},
            k = config.k or 0
        }

        return setmetatable(obj, graphMt)
    end

    local FONT = "debuggraph"
    surface.CreateFont(FONT, {
        font = "Fira Mono",
        size = 12,
        weight = 500
    })

    local gcGraph = Graph {
        dataProvider = function() return collectgarbage("count") end,
        dataFormatter = function(data) return string.NiceSize(data * 1000) end,
        textPainters = {
            function(graph, x, y)
                draw.SimpleText(
                    ("Cur: %s"):format(string.NiceSize(graph.data[#graph.data] * 1000)),
                    graph.font,
                    x, y)
            end,
            function(graph, x, y)
                draw.SimpleText(
                    ("Max: %s"):format(string.NiceSize(graph.max * 1000)),
                    graph.font,
                    x, y)
            end,
            function(graph, x, y)
                draw.SimpleText(
                    ("Min: %s"):format(string.NiceSize(graph.min * 1000)),
                    graph.font,
                    x, y)
            end,
            function(graph, x, y)
                draw.SimpleText(
                    ("Avg: %s"):format(string.NiceSize(graph.ema * 1000)),
                    graph.font,
                    x, y)
            end,
        },
        font = FONT,
        width = 320, height = 130,
        emaFactor = 0.8,
        k = 5
    }

    local fpsGraph = Graph {
        dataProvider = function() return 1 / FrameTime() end,
        dataFormatter = function(data) return ("%03u"):format(data) end,
        textPainters = {
            function(graph, x, y)
                draw.SimpleText(
                    ("Cur: %u"):format(graph.data[#graph.data]),
                    graph.font,
                    x, y)
            end,
            function(graph, x, y)
                draw.SimpleText(
                    ("Max: %u"):format(graph.max),
                    graph.font,
                    x, y)
            end,
            function(graph, x, y)
                draw.SimpleText(
                    ("Min: %u"):format(graph.min),
                    graph.font,
                    x, y)
            end,
            function(graph, x, y)
                draw.SimpleText(
                    ("Avg: %u"):format(graph.ema),
                    graph.font,
                    x, y)
            end,
        },
        font = FONT,
        width = 320, height = 130,
        extremumThreshold = 2,
        emaFactor = 0.95,
        k = 5
    }

    local gcGraphFrame
    concommand.Add("gcdebug", function()
        if IsValid(gcGraphFrame) then
            gcGraphFrame:Remove()
            gcGraphFrame = nil
        end

        gcGraphFrame = vgui.Create("DFrame")
        gcGraphFrame:SetTitle("GC Debug")
        gcGraphFrame:SetSize(gcGraph.width + 16, gcGraph.height + 40)
        function gcGraphFrame:Paint()

        end

        local graphPanel = vgui.Create("Panel", gcGraphFrame)
        graphPanel:Dock(FILL)
        function graphPanel:Paint()
            gcGraph:Update()
            gcGraph:Draw(0, 0)
        end
    end)

    local fpsGraphFrame
    concommand.Add("fpsdebug", function()
        if IsValid(fpsGraphFrame) then
            fpsGraphFrame:Remove()
            fpsGraphFrame = nil
        end

        fpsGraphFrame = vgui.Create("DFrame")
        fpsGraphFrame:SetTitle("FPS Debug")
        fpsGraphFrame:SetSize(gcGraph.width + 16, gcGraph.height + 40)
        function fpsGraphFrame:Paint()

        end

        local graphPanel = vgui.Create("Panel", fpsGraphFrame)
        graphPanel:Dock(FILL)
        function graphPanel:Paint()
            fpsGraph:Update()
            fpsGraph:Draw(0, 0)
        end
    end)
end

end) -- end hook.Add


--PATH addons/__main/lua/autorun/client/cl_savav_drugs_init.lua:

include("drugs_effects/savav_acid.lua")
   
include("drugs_effects/savav_watermelon.lua")   

include("drugs_effects/savav_beer.lua") 
  
include("drugs_effects/savav_LCD.lua")   

include("drugs_effects/savav_Psilocybin.lua")   

include("drugs_effects/savav_meth.lua")   

include("drugs_effects/savav_cocaine.lua")   




--PATH addons/__main/lua/drugs_effects/savav_beer.lua:
local mat_fb = Material( "pp/fb" )
local DRUG = "savav_beer"
--inQuad( delta, ScrH(), -ScrH() )

--[[
hook.Add( "RenderScreenspaceEffects", "DrugsREcts", function()

if LocalPlayer().Active == 1 then
	DrawColorModify( 

{
	[ "$pp_colour_addr" ] = 0,
	[ "$pp_colour_addg" ] = 0,
	[ "$pp_colour_addb" ] = 0,
	[ "$pp_colour_brightness" ] = 0,
	[ "$pp_colour_contrast" ] = 1,
	[ "$pp_colour_colour" ] = 1,
	[ "$pp_colour_mulr" ] = 0,
	[ "$pp_colour_mulg" ] = 0,
	[ "$pp_colour_mulb" ] = 0
}

	)
end

end )


hook.Add( "Think", "ThinkDrugsREct_savav_beer", function()
	if LocalPlayer().ALPHA1 != nil then  
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
		
		if math.random(0,600) == 1 then

				LocalPlayer():ConCommand( "+jump" )
				
		elseif math.random(0,200) == 2 then	
		LocalPlayer():ConCommand( "+forward" )
			timer.Simple(0.1,function()
				LocalPlayer():ConCommand( "-forward" )
			end)
		elseif math.random(0,600) == 2 then
				LocalPlayer():SetEyeAngles(LocalPlayer():EyeAngles()+Angle(0,math.random(-90,90),0))
		else
				LocalPlayer():ConCommand( "-jump" )
				
		end
		
	end
end
	end
end)
-]]

local LERPANGL = Angle()

local function MyCalcView( ply, pos, angles, fov )
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
		local view = {}
		
local blah = WorldToLocal( ply:GetVelocity(), Angle(0,0,0) , Vector(0,0,0), Angle(0,ply:EyeAngles().yaw,0) ) 
LERPANGL = LerpAngle(LocalPlayer().ALPHA1/258,angles,LERPANGL)
		view.origin = pos+ply:GetVelocity()/80
		view.angles = LERPANGL+Angle(((blah.x/4550)*LocalPlayer().ALPHA1),((blah.y/2550)*LocalPlayer().ALPHA1),((blah.y/2550)*LocalPlayer().ALPHA1)+math.cos(CurTime())*LocalPlayer().ALPHA1/10)
		view.fov = fov + math.cos(CurTime())*LocalPlayer().ALPHA1/20
		view.drawviewer = false

		return view
	end
end
	end
end

hook.Add( "CalcView", "CalcViewDrugsRect_savav_beer", MyCalcView )

hook.Add( "HUDPaint", "DrugsREct_savav_beer", function()
if LocalPlayer().ALPHA1 != nil then
if LocalPlayer().Active == 0 then
if LocalPlayer().ALPHA1 > 0 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 - 0.05 end
if LocalPlayer().ALPHA2 > 0 then LocalPlayer().ALPHA2 = LocalPlayer().ALPHA2 - 0.05 end
end

if LocalPlayer().ALPHA1 != nil then
	if LocalPlayer().DrugType == DRUG then
	if LocalPlayer().Active == 1 then
		if LocalPlayer().ALPHA1 < 255 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 + 0.05 end
	if !LocalPlayer():Alive() then
	LocalPlayer().MUSIC:ChangePitch( 0, 60 )
	LocalPlayer().MUSIC:ChangeVolume( 0, 100 )
	LocalPlayer().Active = 0
	end
	end
 
LocalPlayer():SetEyeAngles(LocalPlayer():EyeAngles()+Angle((math.cos(CurTime())/2550)*LocalPlayer().ALPHA1,(math.sin(CurTime()*2)/2550)*LocalPlayer().ALPHA1,0))

	for i=1,30 do

	local Cos = math.cos(i*0.5) * LocalPlayer().ALPHA1/5
	local Sin = math.sin(i*0.5) * LocalPlayer().ALPHA1/10
	local Sinonius = math.cos(CurTime())* LocalPlayer().ALPHA1/10
	local Cosonius = math.sin(CurTime())* LocalPlayer().ALPHA1/10

		surface.SetDrawColor( 255, 255, 255, ( LocalPlayer().ALPHA1/2.1 )/(i/10) )
		surface.SetMaterial( mat_fb	) 
		surface.DrawTexturedRect( Cos-Cosonius, (Sin-Sinonius), ScrW(), ScrH() )
	end

		surface.SetDrawColor(255, 255, 0, LocalPlayer().ALPHA1/30 )
		surface.DrawRect( 0, 0, ScrW(), ScrH() )

		if LocalPlayer().ALPHA1 <= 0 then

			LocalPlayer().DrugType = "0"
				LocalPlayer().MUSIC:Stop()
			
		end
end

	end
end
end )


local function DrugEffect_savav_beer(data)



if LocalPlayer().Active == 0 or LocalPlayer().Active == nil then
LocalPlayer().DrugType = data:ReadString()
LocalPlayer().Active = 1
LocalPlayer().ALPHA1 = 0
LocalPlayer().ALPHA2 = 0


LocalPlayer().MUSIC = CreateSound( LocalPlayer(), "MHWND.wav" )

LocalPlayer().MUSIC:Play()
LocalPlayer().MUSIC:ChangePitch( 0, 0 )
LocalPlayer().MUSIC:ChangeVolume( 0, 0 )
LocalPlayer().MUSIC:ChangePitch( 100, 25 )
LocalPlayer().MUSIC:ChangeVolume( 0.4, 6 )

timer.Simple(110,function()

LocalPlayer().MUSIC:ChangePitch( 0, 10 )
LocalPlayer().MUSIC:ChangeVolume( 0, 19 )
LocalPlayer().Active = 0


end)

end

end


local function DrugEffect_WATER(data)
LocalPlayer().Active = 0
end

usermessage.Hook("DrugEffect_WATER", DrugEffect_WATER ) 
usermessage.Hook("DrugEffect_savav_beer", DrugEffect_savav_beer ) 
 
--PATH addons/_outfitter/lua/autorun/client/net_playervars.lua:

pcall(require,'netqueue')

--TODO: pl:SetNetDataType("varname",TYPE_STRING)

-- magic string length handling
	local TYPE_STRING = TYPE_STRING
	local function assert_int(n) assert( math.floor(n)==n ,"not a whole byte!?") end

	local function net_ReadRest(bytes)
		assert_int(bytes)
		return net.ReadData(bytes)
	end

	local function net_WriteRest(data)
		return net.WriteData(data,#data)
	end

	local function ReadString(magic_len)
		local str = net_ReadRest(magic_len)
		return str
	end

	local function WriteString(data)
		net_WriteRest(data)
	end

	local function tobytes(magic_len)
		
		assert(ubit.band(magic_len,0x7)==0,"bits have not been consumed: "..magic_len..' b, '..(magic_len/8)..' B')
		assert(ubit.rshift(magic_len,3) == magic_len / 8 )
		return magic_len / 8
		
	end
	
	local function ReadType(tn,magic_len)
		if tn == TYPE_STRING then
			assert(magic_len)
			magic_len = tobytes(magic_len)
			return ReadString(magic_len)
		end
		return net.ReadType(tn)
	end

	local function WriteType(dat)
		if TypeID( dat )==TYPE_STRING then
			net.WriteUInt( TYPE_STRING, 8 )
			return WriteString(dat)
		end
		return net.WriteType(dat)
	end
	
	
	
local Tag="NetData"
local data_table=GetNetDataTable and GetNetDataTable() or {}

do
	local function GetNetDataTable()
		return data_table
	end

	_G.GetNetDataTable = GetNetDataTable
	player.GetNetVarsTable = GetNetDataTable
end

local net_playervar_debug = CreateClientConVar("net_playervar_debug","0",true,false)


local SetBurst,IsPlayerVarsBurst do
	local bursting=false
	IsPlayerVarsBurst = function()
		return bursting
	end
	net.IsPlayerVarsBurst = IsPlayerVarsBurst
	
	SetBurst = function(b)
		if net_playervar_debug:GetBool() then
			Msg"[PNVar] Burst " print(b and "ON" or "OFF")
		end
		bursting = b
	end
end

local function Set(id,key,value)
	local tt=data_table[id]
	if not tt then
		tt={}
		data_table[id]=tt
	end
	tt[key]=value
	if net_playervar_debug:GetBool() then
		Msg"[PNVar] " print("Set",id,key,value)
	end
end
local function Get(id,key)
	local tt = data_table[id]
	return tt and tt[key]
end
player.ModifyNetData=Set


net.Receive(Tag,function(len)
		
	-- check for burst
	local id = net.ReadUInt(16)
	if id==0 or id==1 then
		SetBurst(id==1)
		return
	end
	
	id = id - 2
	
	----
	
	local key = net.ReadString()
	local _type = net.ReadUInt( 8 )
	local value = ReadType(_type,len - 16 - #key*8 - 8 - 8 )
	local old = Get(id,key)

	Set(id,key,value)
	
	local change,ret = hook.Call(Tag,nil,id,key,value,old)
	if change == true then
		Set(id,key,ret)
	end
end)

local Player=FindMetaTable("Player")

function Player:SetNetData(key,value)
	if self~=LocalPlayer() then error"not implemented" end
	
	--TODO: Make a generic queue emptier to reduce function garbage
	local f = function()
		net.Start(Tag)
			net.WriteString(key)
			WriteType(value)
		net.SendToServer()
	end
	if net.queuesingle then
		net.queuesingle(f)
	else
		f()
	end
end

	

local lookup={}
function Player:GetNetData(key)
	local id = lookup[self]
	if id == nil then
		id = self:UserID()
		lookup[self] = id
	end
	
	-- inlined: local function Get(id,key)
	local tt = data_table[id]
	return tt and tt[key]
end

--PATH gamemodes/darkrp/gamemode/library/core/core_cl.lua:
/*---------------------------------------------------------------------------
	Three's Derma Lib
	Made by Threebow

	You are free to use this anywhere you like, or sell any addons
	made using this, as long as I am properly accredited.
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
	Constants
---------------------------------------------------------------------------*/
local blur = Material("pp/blurscreen")
local gradLeft = Material("vgui/gradient-l")
local gradUp = Material("vgui/gradient-u")
local gradRight = Material("vgui/gradient-r")
local gradDown = Material("vgui/gradient-d")


/*---------------------------------------------------------------------------
	Collection of various utilities
---------------------------------------------------------------------------*/
TDLibUtil = {}

//Beast's circle drawing function v2
TDLibUtil.DrawCircle = function(x, y, r, col)
    local circle = {}

    for i = 1, 360 do
        circle[i] = {}
        circle[i].x = x + math.cos(math.rad(i * 360) / 360) * r
        circle[i].y = y + math.sin(math.rad(i * 360) / 360) * r
    end

    surface.SetDrawColor(col)
    draw.NoTexture()
    surface.DrawPoly(circle)
end

TDLibUtil.DrawArc = function(x, y, ang, p, rad, color, seg)
	seg = seg || 80
    ang = (-ang) + 180
    local circle = {}

    table.insert(circle, {x = x, y = y})
    for i = 0, seg do
        local a = math.rad((i / seg) * -p + ang)
        table.insert(circle, {x = x + math.sin(a) * rad, y = y + math.cos(a) * rad})
    end

    surface.SetDrawColor(color)
    draw.NoTexture()
    surface.DrawPoly(circle)
end

TDLibUtil.LerpColor = function(frac, from, to)
	return Color(
		Lerp(frac, from.r, to.r),
		Lerp(frac, from.g, to.g),
		Lerp(frac, from.b, to.b),
		Lerp(frac, from.a, to.a)
	)
end

//Various handy premade transition functions
TDLibUtil.HoverFunc = function(s) return s:IsHovered() end
TDLibUtil.HoverFuncChild = function(s) return s:IsHovered() || s:IsChildHovered() end


/*---------------------------------------------------------------------------
	Circle function - credit to Beast
---------------------------------------------------------------------------*/
local function drawCircle(x, y, r)
	local circle = {}

	for i = 1, 360 do
		circle[i] = {}
		circle[i].x = x + math.cos(math.rad(i * 360) / 360) * r
		circle[i].y = y + math.sin(math.rad(i * 360) / 360) * r
	end

	surface.DrawPoly(circle)
end


/*---------------------------------------------------------------------------
	Basic helper classes
---------------------------------------------------------------------------*/
local classes = {}

classes.On = function(pnl, name, fn)
	name = pnl.AppendOverwrite || name

	local old = pnl[name]
	
	pnl[name] = function(s, ...)
		if(old) then old(s, ...) end
		fn(s, ...)
	end
end

classes.SetupTransition = function(pnl, name, speed, fn)
	fn = pnl.TransitionFunc || fn

	pnl[name] = 0
	pnl:On("Think", function(s)
		s[name] = Lerp(FrameTime()*speed, s[name], fn(s) && 1 || 0)
	end)
end


/*---------------------------------------------------------------------------
	Classes
---------------------------------------------------------------------------*/
classes.FadeHover = function(pnl, col, speed, rad)
	col = col || Color(255, 255, 255, 30)
	speed = speed || 6

	pnl:SetupTransition("FadeHover", speed, TDLibUtil.HoverFunc)
	pnl:On("Paint", function(s, w, h)
		local col = ColorAlpha(col, col.a*s.FadeHover)

		if(rad && rad > 0) then
			draw.RoundedBox(rad, 0, 0, w, h, col)
		else
			surface.SetDrawColor(col)
			surface.DrawRect(0, 0, w, h)
		end
	end)
end

classes.BarHover = function(pnl, col, height, speed)
	col = col || Color(255, 255, 255, 255)
	height = height || 2
	speed = speed || 6

	pnl:SetupTransition("BarHover", speed, TDLibUtil.HoverFunc)
	pnl:On("PaintOver", function(s, w, h)
		local bar = math.Round(w*s.BarHover)

		surface.SetDrawColor(col)
		surface.DrawRect(w*0.5-bar*0.5, h-height, bar, height)
	end)
end

classes.FillHover = function(pnl, col, dir, speed, mat)
	col = col || Color(255, 255, 255, 30)
	dir = dir || LEFT
	speed = speed || 8

	pnl:SetupTransition("FillHover", speed, TDLibUtil.HoverFunc)
	pnl:On("PaintOver", function(s, w, h)
		surface.SetDrawColor(col)

		local x, y, fw, fh
		if(dir == LEFT) then
			x, y, fw, fh = 0, 0, math.Round(w*s.FillHover), h
		elseif(dir == TOP) then
			x, y, fw, fh = 0, 0, w, math.Round(h*s.FillHover)
		elseif(dir == RIGHT) then
			local prog = math.Round(w*s.FillHover)
			x, y, fw, fh = w-prog, 0, prog, h
		elseif(dir == BOTTOM) then
			local prog = math.Round(h*s.FillHover)
			x, y, fw, fh = 0, h-prog, w, prog
		end

		if(mat) then
			surface.SetMaterial(mat)
			surface.DrawTexturedRect(x, y, fw, fh)
		else
			surface.DrawRect(x, y, fw, fh)
		end
	end)
end

classes.Background = function(pnl, col, rad, rtl, rtr, rbl, rbr)
	pnl:On("Paint", function(s, w, h)
		if(rad && rad > 0) then
			if(rtl != nil) then
				draw.RoundedBoxEx(rad, 0, 0, w, h, col, rtl, rtr, rbl, rbr)
			else
				draw.RoundedBox(rad, 0, 0, w, h, col)
			end
		else
			surface.SetDrawColor(col)
			surface.DrawRect(0, 0, w, h)
		end
	end)
end

classes.Material = function(pnl, mat, col)
	col = col || Color(255, 255, 255)

	pnl:On("Paint", function(s, w, h)
		surface.SetDrawColor(col)
		surface.SetMaterial(mat)
		surface.DrawTexturedRect(0, 0, w, h)
	end)
end

classes.TiledMaterial = function(pnl, mat, tw, th, col)
	col = col || Color(255, 255, 255, 255)

	pnl:On("Paint", function(s, w, h)
		surface.SetMaterial(mat)
		surface.SetDrawColor(col)
		surface.DrawTexturedRectUV(0, 0, w, h, 0, 0, w/tw, h/th)
	end)
end

classes.Outline = function(pnl, col, width)
	col = col || Color(255, 255, 255, 255)
	width = width || 1

	pnl:On("Paint", function(s, w, h)
		surface.SetDrawColor(col)
		
		for i=0, width-1 do
			surface.DrawOutlinedRect(0+i,0+i,w-i*2,h-i*2)
		end
	end)
end

classes.LinedCorners = function(pnl, col, len)
	col = col || Color(255, 255, 255, 255)
	len = len || 15

	pnl:On("Paint", function(s, w, h)
		surface.SetDrawColor(col)

		surface.DrawRect(0, 0, len, 1)
		surface.DrawRect(0, 1, 1, len-1)
		surface.DrawRect(w-len, h-1, len, 1)
		surface.DrawRect(w-1, h-len, 1, len-1)
	end)
end

classes.SideBlock = function(pnl, col, size, side)
	col = col || Color(255, 255, 255, 255)
	size = size || 3
	side = side || LEFT

	pnl:On("Paint", function(s, w, h)
		surface.SetDrawColor(col)
		
		if(side == LEFT) then
			surface.DrawRect(0, 0, size, h)
		elseif(side == TOP) then
			surface.DrawRect(0, 0, w, size)
		elseif(side == RIGHT) then
			surface.DrawRect(w-size, 0, size, h)
		elseif(side == BOTTOM) then
			surface.DrawRect(0, h-size, w, size)
		end
	end)
end

classes.Text = function(pnl, text, font, col, alignment, ox, oy, paint)
	font = font || "Trebuchet24"
	col = col || Color(255, 255, 255, 255)
	alignment = alignment || TEXT_ALIGN_CENTER
	ox = ox || 0
	oy = oy || 0

	if(!paint && pnl.SetText && pnl.SetFont && pnl.SetTextColor) then
		pnl:SetText(text)
		pnl:SetFont(font)
		pnl:SetTextColor(col)
	else
		pnl:On("Paint", function(s, w, h)
			local x = 0
			if(alignment == TEXT_ALIGN_CENTER) then
				x = w*0.5
			elseif(alignment == TEXT_ALIGN_RIGHT) then
				x = w
			end

			draw.SimpleText(text,font,x+ox,h*0.5+oy,col,alignment,TEXT_ALIGN_CENTER)
		end)
	end
end

classes.DualText = function(pnl, toptext, topfont, topcol, bottomtext, bottomfont, bottomcol, alignment, centerSpacing)
	topfont = topfont || "Trebuchet24"
	topcol = topcol || Color(0, 127, 255, 255)
	bottomfont = bottomfont || "Trebuchet18"
	bottomcol = bottomcol || Color(255, 255, 255, 255)
	alignment = alignment || TEXT_ALIGN_CENTER
	centerSpacing = centerSpacing || 0

	pnl:On("Paint", function(s, w, h)
		surface.SetFont(topfont)
		local tw, th = surface.GetTextSize(toptext)

		surface.SetFont(bottomfont)
		local bw, bh = surface.GetTextSize(bottomtext)

		local y1, y2 = h*0.5-bh*0.5, h*0.5+th*0.5

		local x
		if(alignment == TEXT_ALIGN_LEFT) then
			x = 0
		elseif(alignment == TEXT_ALIGN_CENTER) then
			x = w*0.5
		elseif(alignment == TEXT_ALIGN_RIGHT) then
			x = w
		end

		draw.SimpleText(toptext, topfont, x, y1+centerSpacing, topcol, alignment, TEXT_ALIGN_CENTER)
		draw.SimpleText(bottomtext, bottomfont, x, y2-centerSpacing, bottomcol, alignment, TEXT_ALIGN_CENTER)
	end)
end

classes.Blur = function(pnl, amount)
	pnl:On("Paint", function(s, w, h)
		local x, y = s:LocalToScreen(0, 0)
		local scrW, scrH = ScrW(), ScrH()

		surface.SetDrawColor(255, 255, 255)
		surface.SetMaterial(blur)

		for i = 1, 3 do
			blur:SetFloat("$blur", (i / 3) * (amount or 8))
			blur:Recompute()

			render.UpdateScreenEffectTexture()
			surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
		end
	end)
end

classes.CircleClick = function(pnl, col, speed, trad)
	col = col || Color(255, 255, 255, 50)
	speed = speed || 5

	pnl.Rad, pnl.Alpha, pnl.ClickX, pnl.ClickY = 0, 0, 0, 0

	pnl:On("Paint", function(s, w, h)
		if(s.Alpha >= 1) then
			surface.SetDrawColor(ColorAlpha(col, s.Alpha))
			draw.NoTexture()
			drawCircle(s.ClickX, s.ClickY, s.Rad)
			s.Rad = Lerp(FrameTime()*speed, s.Rad, trad || w)
			s.Alpha = Lerp(FrameTime()*speed, s.Alpha, 0)
		end
	end)

	pnl:On("DoClick", function(s)
		s.ClickX, s.ClickY = s:CursorPos()
		s.Rad = 0
		s.Alpha = col.a
	end)
end

classes.CircleHover = function(pnl, col, speed, trad)
	col = col || Color(255, 255, 255, 30)
	speed = speed || 6

	pnl.LastX, pnl.LastY = 0, 0

	pnl:SetupTransition("CircleHover", speed, TDLibUtil.HoverFunc)
	pnl:On("Think", function(s)
		if(s:IsHovered()) then
			s.LastX, s.LastY = s:CursorPos()
		end
	end)

	pnl:On("PaintOver", function(s, w, h)
		draw.NoTexture()
		surface.SetDrawColor(ColorAlpha(col, col.a*s.CircleHover))
		drawCircle(s.LastX, s.LastY, s.CircleHover*(trad || w))
	end)
end

classes.SquareCheckbox = function(pnl, inner, outer, speed)
	inner = inner || Color(0, 255, 0, 255)
	outer = outer || Color(255, 255, 255, 255)
	speed = speed || 14

	pnl:SetupTransition("SquareCheckbox", speed, function(s) return s:GetChecked() end)
	pnl:On("Paint", function(s, w, h)
		surface.SetDrawColor(outer)
		surface.DrawRect(0, 0, w, h)

		surface.SetDrawColor(inner)
		surface.DrawOutlinedRect(0, 0, w, h)

		local bw, bh = (w-4)*s.SquareCheckbox, (h-4)*s.SquareCheckbox
		bw, bh = math.Round(bw), math.Round(bh)

		surface.DrawRect(w*0.5-bw*0.5, h*0.5-bh*0.5, bw, bh)
	end)
end

classes.CircleCheckbox = function(pnl, inner, outer, speed)
	inner = inner || Color(0, 255, 0, 255)
	outer = outer || Color(255, 255, 255, 255)
	speed = speed || 14

	pnl:SetupTransition("CircleCheckbox", speed, function(s) return s:GetChecked() end)
	pnl:On("Paint", function(s, w, h)
		draw.NoTexture()
		surface.SetDrawColor(outer)
		drawCircle(w*0.5, h*0.5, w*0.5-1)

		surface.SetDrawColor(inner)
		drawCircle(w*0.5, h*0.5, w*s.CircleCheckbox*0.5)
	end)
end

classes.AvatarMask = function(pnl, mask)
	pnl.Avatar = vgui.Create("AvatarImage", pnl)
	pnl.Avatar:SetPaintedManually(true)

	pnl.Paint = function(s, w, h)
		render.ClearStencil()
		render.SetStencilEnable(true)

		render.SetStencilWriteMask(1)
		render.SetStencilTestMask(1)

		render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
		render.SetStencilPassOperation(STENCILOPERATION_ZERO)
		render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
		render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
		render.SetStencilReferenceValue(1)

		draw.NoTexture()
		surface.SetDrawColor(255, 255, 255, 255)
		mask(s, w, h)

		render.SetStencilFailOperation(STENCILOPERATION_ZERO)
		render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
		render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
		render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
		render.SetStencilReferenceValue(1)

		s.Avatar:SetPaintedManually(false)
		s.Avatar:PaintManual()
		s.Avatar:SetPaintedManually(true)

		render.SetStencilEnable(false)
		render.ClearStencil()
	end

	pnl.PerformLayout = function(s)
		s.Avatar:SetSize(s:GetWide(), s:GetTall())
	end

	pnl.SetPlayer = function(s, ply, size) s.Avatar:SetPlayer(ply, size) end
	pnl.SetSteamID = function(s, id, size) s.Avatar:SetSteamID(id, size) end
end

classes.CircleAvatar = function(pnl)
	pnl:Class("AvatarMask", function(s, w, h)
		drawCircle(w*0.5, h*0.5, w*0.5)
	end)
end

classes.Circle = function(pnl, col)
	col = col || Color(255, 255, 255, 255)

	pnl:On("Paint", function(s, w, h)
		draw.NoTexture()
		surface.SetDrawColor(col)
		drawCircle(w*0.5, h*0.5, math.min(w, h)*0.5)
	end)
end

classes.CircleFadeHover = function(pnl, col, speed)
	col = col || Color(255, 255, 255, 30)
	speed = speed || 6

	pnl:SetupTransition("CircleFadeHover", speed, TDLibUtil.HoverFunc)
	pnl:On("Paint", function(s, w, h)
		draw.NoTexture()
		surface.SetDrawColor(ColorAlpha(col, col.a*s.CircleFadeHover))
		drawCircle(w*0.5, h*0.5, math.min(w, h)*0.5)
	end)
end

classes.CircleExpandHover = function(pnl, col, speed)
	col = col || Color(255, 255, 255, 30)
	speed = speed || 6

	pnl:SetupTransition("CircleExpandHover", speed, TDLibUtil.HoverFunc)
	pnl:On("Paint", function(s, w, h)
		local rad = math.Round(w*0.5*s.CircleExpandHover)

		draw.NoTexture()
		surface.SetDrawColor(ColorAlpha(col, col.a*s.CircleExpandHover))
		drawCircle(w*0.5, h*0.5, rad)
	end)
end

classes.Gradient = function(pnl, col, dir, frac, op)
	dir = dir || BOTTOM
	frac = frac || 1

	pnl:On("Paint", function(s, w, h)
		surface.SetDrawColor(col)

		local x, y, gw, gh		
		if(dir == LEFT) then
			local prog = math.Round(w*frac)
			x, y, gw, gh = 0, 0, prog, h
			surface.SetMaterial(op && gradRight || gradLeft)
		elseif(dir == TOP) then
			local prog = math.Round(h*frac)
			x, y, gw, gh = 0, 0, w, prog
			surface.SetMaterial(op && gradDown || gradUp)
		elseif(dir == RIGHT) then
			local prog = math.Round(w*frac)
			x, y, gw, gh = w-prog, 0, prog, h
			surface.SetMaterial(op && gradLeft || gradRight)
		elseif(dir == BOTTOM) then
			local prog = math.Round(h*frac)
			x, y, gw, gh = 0, h-prog, w, prog
			surface.SetMaterial(op && gradUp || gradDown)
		end

		surface.DrawTexturedRect(x, y, gw, gh)
	end)
end

classes.SetOpenURL = function(pnl, url)
	pnl:On("DoClick", function()
		gui.OpenURL(url)
	end)
end

classes.NetMessage = function(pnl, name, data)
	data = data || function() end

	pnl:On("DoClick", function()
		net.Start(name)
			data(pnl)
		net.SendToServer()
	end)
end

classes.Stick = function(pnl, dock, margin, dontInvalidate)
	dock = dock || FILL
	margin = margin || 0

	pnl:Dock(dock)
	if(margin > 0) then
		pnl:DockMargin(margin, margin, margin, margin)
	end

	if(!dontInvalidate) then
		pnl:InvalidateParent(true)
	end
end

classes.DivTall = function(pnl, frac, target)
	frac = frac || 2
	target = target || pnl:GetParent()

	pnl:SetTall(target:GetTall()/frac)
end

classes.DivWide = function(pnl, frac, target)
	target = target || pnl:GetParent()
	frac = frac || 2

	pnl:SetWide(target:GetWide()/frac)
end

classes.SquareFromHeight = function(pnl)
	pnl:SetWide(pnl:GetTall())
end

classes.SquareFromWidth = function(pnl)
	pnl:SetTall(pnl:GetWide())
end

classes.SetRemove = function(pnl, target)
	target = target || pnl

	pnl:On("DoClick", function()
		if(IsValid(target)) then target:Remove() end
	end)
end

classes.FadeIn = function(pnl, time, alpha)
	time = time || 0.2
	alpha = alpha || 255

	pnl:SetAlpha(0)
	pnl:AlphaTo(alpha, time)
end

classes.HideVBar = function(pnl)
	local vbar = pnl:GetVBar()
	vbar:SetWide(0)
	vbar:Hide()
end

classes.SetTransitionFunc = function(pnl, fn)
	pnl.TransitionFunc = fn
end

classes.ClearTransitionFunc = function(pnl)
	pnl.TransitionFunc = nil
end

classes.SetAppendOverwrite = function(pnl, fn)
	pnl.AppendOverwrite = fn
end

classes.ClearAppendOverwrite = function(pnl)
	pnl.AppendOverwrite = nil
end

classes.ClearPaint = function(pnl)
	pnl.Paint = nil
end

classes.ReadyTextbox = function(pnl)
	pnl:SetPaintBackground(false)
	pnl:SetAppendOverwrite("PaintOver")
		:SetTransitionFunc(function(s) return s:IsEditing() end)
end


/*---------------------------------------------------------------------------
	TDLib function which adds all the classes to your panel
---------------------------------------------------------------------------*/
local meta = FindMetaTable("Panel")

function meta:TDLib()
	self.Class = function(pnl, name, ...)
		local class = classes[name]
		assert(class, "[TDLib]: Class "..name.." does not exist.")

		class(pnl, ...)

		return pnl
	end

	for k, v in pairs(classes) do
		self[k] = function(s, ...) return s:Class(k, ...) end
	end

	return self
end

function TDLib(c, p, n)
	local pnl = vgui.Create(c, p, n)
	return pnl:TDLib()
end
--PATH gamemodes/darkrp/gamemode/library/core/utf8_sh.lua:

utf8 = utf8 or {} -- Module sanity check

utf8_lc_uc = {
	["a"] = "A",
	["b"] = "B",
	["c"] = "C",
	["d"] = "D",
	["e"] = "E",
	["f"] = "F",
	["g"] = "G",
	["h"] = "H",
	["i"] = "I",
	["j"] = "J",
	["k"] = "K",
	["l"] = "L",
	["m"] = "M",
	["n"] = "N",
	["o"] = "O",
	["p"] = "P",
	["q"] = "Q",
	["r"] = "R",
	["s"] = "S",
	["t"] = "T",
	["u"] = "U",
	["v"] = "V",
	["w"] = "W",
	["x"] = "X",
	["y"] = "Y",
	["z"] = "Z",
	["µ"] = "Μ",
	["à"] = "À",
	["á"] = "Á",
	["â"] = "Â",
	["ã"] = "Ã",
	["ä"] = "Ä",
	["å"] = "Å",
	["æ"] = "Æ",
	["ç"] = "Ç",
	["è"] = "È",
	["é"] = "É",
	["ê"] = "Ê",
	["ë"] = "Ë",
	["ì"] = "Ì",
	["í"] = "Í",
	["î"] = "Î",
	["ï"] = "Ï",
	["ð"] = "Ð",
	["ñ"] = "Ñ",
	["ò"] = "Ò",
	["ó"] = "Ó",
	["ô"] = "Ô",
	["õ"] = "Õ",
	["ö"] = "Ö",
	["ø"] = "Ø",
	["ù"] = "Ù",
	["ú"] = "Ú",
	["û"] = "Û",
	["ü"] = "Ü",
	["ý"] = "Ý",
	["þ"] = "Þ",
	["ÿ"] = "Ÿ",
	["ā"] = "Ā",
	["ă"] = "Ă",
	["ą"] = "Ą",
	["ć"] = "Ć",
	["ĉ"] = "Ĉ",
	["ċ"] = "Ċ",
	["č"] = "Č",
	["ď"] = "Ď",
	["đ"] = "Đ",
	["ē"] = "Ē",
	["ĕ"] = "Ĕ",
	["ė"] = "Ė",
	["ę"] = "Ę",
	["ě"] = "Ě",
	["ĝ"] = "Ĝ",
	["ğ"] = "Ğ",
	["ġ"] = "Ġ",
	["ģ"] = "Ģ",
	["ĥ"] = "Ĥ",
	["ħ"] = "Ħ",
	["ĩ"] = "Ĩ",
	["ī"] = "Ī",
	["ĭ"] = "Ĭ",
	["į"] = "Į",
	["ı"] = "I",
	["ĳ"] = "Ĳ",
	["ĵ"] = "Ĵ",
	["ķ"] = "Ķ",
	["ĺ"] = "Ĺ",
	["ļ"] = "Ļ",
	["ľ"] = "Ľ",
	["ŀ"] = "Ŀ",
	["ł"] = "Ł",
	["ń"] = "Ń",
	["ņ"] = "Ņ",
	["ň"] = "Ň",
	["ŋ"] = "Ŋ",
	["ō"] = "Ō",
	["ŏ"] = "Ŏ",
	["ő"] = "Ő",
	["œ"] = "Œ",
	["ŕ"] = "Ŕ",
	["ŗ"] = "Ŗ",
	["ř"] = "Ř",
	["ś"] = "Ś",
	["ŝ"] = "Ŝ",
	["ş"] = "Ş",
	["š"] = "Š",
	["ţ"] = "Ţ",
	["ť"] = "Ť",
	["ŧ"] = "Ŧ",
	["ũ"] = "Ũ",
	["ū"] = "Ū",
	["ŭ"] = "Ŭ",
	["ů"] = "Ů",
	["ű"] = "Ű",
	["ų"] = "Ų",
	["ŵ"] = "Ŵ",
	["ŷ"] = "Ŷ",
	["ź"] = "Ź",
	["ż"] = "Ż",
	["ž"] = "Ž",
	["ſ"] = "S",
	["ƀ"] = "Ƀ",
	["ƃ"] = "Ƃ",
	["ƅ"] = "Ƅ",
	["ƈ"] = "Ƈ",
	["ƌ"] = "Ƌ",
	["ƒ"] = "Ƒ",
	["ƕ"] = "Ƕ",
	["ƙ"] = "Ƙ",
	["ƚ"] = "Ƚ",
	["ƞ"] = "Ƞ",
	["ơ"] = "Ơ",
	["ƣ"] = "Ƣ",
	["ƥ"] = "Ƥ",
	["ƨ"] = "Ƨ",
	["ƭ"] = "Ƭ",
	["ư"] = "Ư",
	["ƴ"] = "Ƴ",
	["ƶ"] = "Ƶ",
	["ƹ"] = "Ƹ",
	["ƽ"] = "Ƽ",
	["ƿ"] = "Ƿ",
	["ǅ"] = "Ǆ",
	["ǆ"] = "Ǆ",
	["ǈ"] = "Ǉ",
	["ǉ"] = "Ǉ",
	["ǋ"] = "Ǌ",
	["ǌ"] = "Ǌ",
	["ǎ"] = "Ǎ",
	["ǐ"] = "Ǐ",
	["ǒ"] = "Ǒ",
	["ǔ"] = "Ǔ",
	["ǖ"] = "Ǖ",
	["ǘ"] = "Ǘ",
	["ǚ"] = "Ǚ",
	["ǜ"] = "Ǜ",
	["ǝ"] = "Ǝ",
	["ǟ"] = "Ǟ",
	["ǡ"] = "Ǡ",
	["ǣ"] = "Ǣ",
	["ǥ"] = "Ǥ",
	["ǧ"] = "Ǧ",
	["ǩ"] = "Ǩ",
	["ǫ"] = "Ǫ",
	["ǭ"] = "Ǭ",
	["ǯ"] = "Ǯ",
	["ǲ"] = "Ǳ",
	["ǳ"] = "Ǳ",
	["ǵ"] = "Ǵ",
	["ǹ"] = "Ǹ",
	["ǻ"] = "Ǻ",
	["ǽ"] = "Ǽ",
	["ǿ"] = "Ǿ",
	["ȁ"] = "Ȁ",
	["ȃ"] = "Ȃ",
	["ȅ"] = "Ȅ",
	["ȇ"] = "Ȇ",
	["ȉ"] = "Ȉ",
	["ȋ"] = "Ȋ",
	["ȍ"] = "Ȍ",
	["ȏ"] = "Ȏ",
	["ȑ"] = "Ȑ",
	["ȓ"] = "Ȓ",
	["ȕ"] = "Ȕ",
	["ȗ"] = "Ȗ",
	["ș"] = "Ș",
	["ț"] = "Ț",
	["ȝ"] = "Ȝ",
	["ȟ"] = "Ȟ",
	["ȣ"] = "Ȣ",
	["ȥ"] = "Ȥ",
	["ȧ"] = "Ȧ",
	["ȩ"] = "Ȩ",
	["ȫ"] = "Ȫ",
	["ȭ"] = "Ȭ",
	["ȯ"] = "Ȯ",
	["ȱ"] = "Ȱ",
	["ȳ"] = "Ȳ",
	["ȼ"] = "Ȼ",
	["ɂ"] = "Ɂ",
	["ɇ"] = "Ɇ",
	["ɉ"] = "Ɉ",
	["ɋ"] = "Ɋ",
	["ɍ"] = "Ɍ",
	["ɏ"] = "Ɏ",
	["ɓ"] = "Ɓ",
	["ɔ"] = "Ɔ",
	["ɖ"] = "Ɖ",
	["ɗ"] = "Ɗ",
	["ə"] = "Ə",
	["ɛ"] = "Ɛ",
	["ɠ"] = "Ɠ",
	["ɣ"] = "Ɣ",
	["ɨ"] = "Ɨ",
	["ɩ"] = "Ɩ",
	["ɫ"] = "Ɫ",
	["ɯ"] = "Ɯ",
	["ɲ"] = "Ɲ",
	["ɵ"] = "Ɵ",
	["ɽ"] = "Ɽ",
	["ʀ"] = "Ʀ",
	["ʃ"] = "Ʃ",
	["ʈ"] = "Ʈ",
	["ʉ"] = "Ʉ",
	["ʊ"] = "Ʊ",
	["ʋ"] = "Ʋ",
	["ʌ"] = "Ʌ",
	["ʒ"] = "Ʒ",
	["ͅ"] = "Ι",
	["ͻ"] = "Ͻ",
	["ͼ"] = "Ͼ",
	["ͽ"] = "Ͽ",
	["ά"] = "Ά",
	["έ"] = "Έ",
	["ή"] = "Ή",
	["ί"] = "Ί",
	["α"] = "Α",
	["β"] = "Β",
	["γ"] = "Γ",
	["δ"] = "Δ",
	["ε"] = "Ε",
	["ζ"] = "Ζ",
	["η"] = "Η",
	["θ"] = "Θ",
	["ι"] = "Ι",
	["κ"] = "Κ",
	["λ"] = "Λ",
	["μ"] = "Μ",
	["ν"] = "Ν",
	["ξ"] = "Ξ",
	["ο"] = "Ο",
	["π"] = "Π",
	["ρ"] = "Ρ",
	["ς"] = "Σ",
	["σ"] = "Σ",
	["τ"] = "Τ",
	["υ"] = "Υ",
	["φ"] = "Φ",
	["χ"] = "Χ",
	["ψ"] = "Ψ",
	["ω"] = "Ω",
	["ϊ"] = "Ϊ",
	["ϋ"] = "Ϋ",
	["ό"] = "Ό",
	["ύ"] = "Ύ",
	["ώ"] = "Ώ",
	["ϐ"] = "Β",
	["ϑ"] = "Θ",
	["ϕ"] = "Φ",
	["ϖ"] = "Π",
	["ϙ"] = "Ϙ",
	["ϛ"] = "Ϛ",
	["ϝ"] = "Ϝ",
	["ϟ"] = "Ϟ",
	["ϡ"] = "Ϡ",
	["ϣ"] = "Ϣ",
	["ϥ"] = "Ϥ",
	["ϧ"] = "Ϧ",
	["ϩ"] = "Ϩ",
	["ϫ"] = "Ϫ",
	["ϭ"] = "Ϭ",
	["ϯ"] = "Ϯ",
	["ϰ"] = "Κ",
	["ϱ"] = "Ρ",
	["ϲ"] = "Ϲ",
	["ϵ"] = "Ε",
	["ϸ"] = "Ϸ",
	["ϻ"] = "Ϻ",
	["а"] = "А",
	["б"] = "Б",
	["в"] = "В",
	["г"] = "Г",
	["д"] = "Д",
	["е"] = "Е",
	["ж"] = "Ж",
	["з"] = "З",
	["и"] = "И",
	["й"] = "Й",
	["к"] = "К",
	["л"] = "Л",
	["м"] = "М",
	["н"] = "Н",
	["о"] = "О",
	["п"] = "П",
	["р"] = "Р",
	["с"] = "С",
	["т"] = "Т",
	["у"] = "У",
	["ф"] = "Ф",
	["х"] = "Х",
	["ц"] = "Ц",
	["ч"] = "Ч",
	["ш"] = "Ш",
	["щ"] = "Щ",
	["ъ"] = "Ъ",
	["ы"] = "Ы",
	["ь"] = "Ь",
	["э"] = "Э",
	["ю"] = "Ю",
	["я"] = "Я",
	["ѐ"] = "Ѐ",
	["ё"] = "Ё",
	["ђ"] = "Ђ",
	["ѓ"] = "Ѓ",
	["є"] = "Є",
	["ѕ"] = "Ѕ",
	["і"] = "І",
	["ї"] = "Ї",
	["ј"] = "Ј",
	["љ"] = "Љ",
	["њ"] = "Њ",
	["ћ"] = "Ћ",
	["ќ"] = "Ќ",
	["ѝ"] = "Ѝ",
	["ў"] = "Ў",
	["џ"] = "Џ",
	["ѡ"] = "Ѡ",
	["ѣ"] = "Ѣ",
	["ѥ"] = "Ѥ",
	["ѧ"] = "Ѧ",
	["ѩ"] = "Ѩ",
	["ѫ"] = "Ѫ",
	["ѭ"] = "Ѭ",
	["ѯ"] = "Ѯ",
	["ѱ"] = "Ѱ",
	["ѳ"] = "Ѳ",
	["ѵ"] = "Ѵ",
	["ѷ"] = "Ѷ",
	["ѹ"] = "Ѹ",
	["ѻ"] = "Ѻ",
	["ѽ"] = "Ѽ",
	["ѿ"] = "Ѿ",
	["ҁ"] = "Ҁ",
	["ҋ"] = "Ҋ",
	["ҍ"] = "Ҍ",
	["ҏ"] = "Ҏ",
	["ґ"] = "Ґ",
	["ғ"] = "Ғ",
	["ҕ"] = "Ҕ",
	["җ"] = "Җ",
	["ҙ"] = "Ҙ",
	["қ"] = "Қ",
	["ҝ"] = "Ҝ",
	["ҟ"] = "Ҟ",
	["ҡ"] = "Ҡ",
	["ң"] = "Ң",
	["ҥ"] = "Ҥ",
	["ҧ"] = "Ҧ",
	["ҩ"] = "Ҩ",
	["ҫ"] = "Ҫ",
	["ҭ"] = "Ҭ",
	["ү"] = "Ү",
	["ұ"] = "Ұ",
	["ҳ"] = "Ҳ",
	["ҵ"] = "Ҵ",
	["ҷ"] = "Ҷ",
	["ҹ"] = "Ҹ",
	["һ"] = "Һ",
	["ҽ"] = "Ҽ",
	["ҿ"] = "Ҿ",
	["ӂ"] = "Ӂ",
	["ӄ"] = "Ӄ",
	["ӆ"] = "Ӆ",
	["ӈ"] = "Ӈ",
	["ӊ"] = "Ӊ",
	["ӌ"] = "Ӌ",
	["ӎ"] = "Ӎ",
	["ӏ"] = "Ӏ",
	["ӑ"] = "Ӑ",
	["ӓ"] = "Ӓ",
	["ӕ"] = "Ӕ",
	["ӗ"] = "Ӗ",
	["ә"] = "Ә",
	["ӛ"] = "Ӛ",
	["ӝ"] = "Ӝ",
	["ӟ"] = "Ӟ",
	["ӡ"] = "Ӡ",
	["ӣ"] = "Ӣ",
	["ӥ"] = "Ӥ",
	["ӧ"] = "Ӧ",
	["ө"] = "Ө",
	["ӫ"] = "Ӫ",
	["ӭ"] = "Ӭ",
	["ӯ"] = "Ӯ",
	["ӱ"] = "Ӱ",
	["ӳ"] = "Ӳ",
	["ӵ"] = "Ӵ",
	["ӷ"] = "Ӷ",
	["ӹ"] = "Ӹ",
	["ӻ"] = "Ӻ",
	["ӽ"] = "Ӽ",
	["ӿ"] = "Ӿ",
	["ԁ"] = "Ԁ",
	["ԃ"] = "Ԃ",
	["ԅ"] = "Ԅ",
	["ԇ"] = "Ԇ",
	["ԉ"] = "Ԉ",
	["ԋ"] = "Ԋ",
	["ԍ"] = "Ԍ",
	["ԏ"] = "Ԏ",
	["ԑ"] = "Ԑ",
	["ԓ"] = "Ԓ",
	["ա"] = "Ա",
	["բ"] = "Բ",
	["գ"] = "Գ",
	["դ"] = "Դ",
	["ե"] = "Ե",
	["զ"] = "Զ",
	["է"] = "Է",
	["ը"] = "Ը",
	["թ"] = "Թ",
	["ժ"] = "Ժ",
	["ի"] = "Ի",
	["լ"] = "Լ",
	["խ"] = "Խ",
	["ծ"] = "Ծ",
	["կ"] = "Կ",
	["հ"] = "Հ",
	["ձ"] = "Ձ",
	["ղ"] = "Ղ",
	["ճ"] = "Ճ",
	["մ"] = "Մ",
	["յ"] = "Յ",
	["ն"] = "Ն",
	["շ"] = "Շ",
	["ո"] = "Ո",
	["չ"] = "Չ",
	["պ"] = "Պ",
	["ջ"] = "Ջ",
	["ռ"] = "Ռ",
	["ս"] = "Ս",
	["վ"] = "Վ",
	["տ"] = "Տ",
	["ր"] = "Ր",
	["ց"] = "Ց",
	["ւ"] = "Ւ",
	["փ"] = "Փ",
	["ք"] = "Ք",
	["օ"] = "Օ",
	["ֆ"] = "Ֆ",
	["ᵽ"] = "Ᵽ",
	["ḁ"] = "Ḁ",
	["ḃ"] = "Ḃ",
	["ḅ"] = "Ḅ",
	["ḇ"] = "Ḇ",
	["ḉ"] = "Ḉ",
	["ḋ"] = "Ḋ",
	["ḍ"] = "Ḍ",
	["ḏ"] = "Ḏ",
	["ḑ"] = "Ḑ",
	["ḓ"] = "Ḓ",
	["ḕ"] = "Ḕ",
	["ḗ"] = "Ḗ",
	["ḙ"] = "Ḙ",
	["ḛ"] = "Ḛ",
	["ḝ"] = "Ḝ",
	["ḟ"] = "Ḟ",
	["ḡ"] = "Ḡ",
	["ḣ"] = "Ḣ",
	["ḥ"] = "Ḥ",
	["ḧ"] = "Ḧ",
	["ḩ"] = "Ḩ",
	["ḫ"] = "Ḫ",
	["ḭ"] = "Ḭ",
	["ḯ"] = "Ḯ",
	["ḱ"] = "Ḱ",
	["ḳ"] = "Ḳ",
	["ḵ"] = "Ḵ",
	["ḷ"] = "Ḷ",
	["ḹ"] = "Ḹ",
	["ḻ"] = "Ḻ",
	["ḽ"] = "Ḽ",
	["ḿ"] = "Ḿ",
	["ṁ"] = "Ṁ",
	["ṃ"] = "Ṃ",
	["ṅ"] = "Ṅ",
	["ṇ"] = "Ṇ",
	["ṉ"] = "Ṉ",
	["ṋ"] = "Ṋ",
	["ṍ"] = "Ṍ",
	["ṏ"] = "Ṏ",
	["ṑ"] = "Ṑ",
	["ṓ"] = "Ṓ",
	["ṕ"] = "Ṕ",
	["ṗ"] = "Ṗ",
	["ṙ"] = "Ṙ",
	["ṛ"] = "Ṛ",
	["ṝ"] = "Ṝ",
	["ṟ"] = "Ṟ",
	["ṡ"] = "Ṡ",
	["ṣ"] = "Ṣ",
	["ṥ"] = "Ṥ",
	["ṧ"] = "Ṧ",
	["ṩ"] = "Ṩ",
	["ṫ"] = "Ṫ",
	["ṭ"] = "Ṭ",
	["ṯ"] = "Ṯ",
	["ṱ"] = "Ṱ",
	["ṳ"] = "Ṳ",
	["ṵ"] = "Ṵ",
	["ṷ"] = "Ṷ",
	["ṹ"] = "Ṹ",
	["ṻ"] = "Ṻ",
	["ṽ"] = "Ṽ",
	["ṿ"] = "Ṿ",
	["ẁ"] = "Ẁ",
	["ẃ"] = "Ẃ",
	["ẅ"] = "Ẅ",
	["ẇ"] = "Ẇ",
	["ẉ"] = "Ẉ",
	["ẋ"] = "Ẋ",
	["ẍ"] = "Ẍ",
	["ẏ"] = "Ẏ",
	["ẑ"] = "Ẑ",
	["ẓ"] = "Ẓ",
	["ẕ"] = "Ẕ",
	["ẛ"] = "Ṡ",
	["ạ"] = "Ạ",
	["ả"] = "Ả",
	["ấ"] = "Ấ",
	["ầ"] = "Ầ",
	["ẩ"] = "Ẩ",
	["ẫ"] = "Ẫ",
	["ậ"] = "Ậ",
	["ắ"] = "Ắ",
	["ằ"] = "Ằ",
	["ẳ"] = "Ẳ",
	["ẵ"] = "Ẵ",
	["ặ"] = "Ặ",
	["ẹ"] = "Ẹ",
	["ẻ"] = "Ẻ",
	["ẽ"] = "Ẽ",
	["ế"] = "Ế",
	["ề"] = "Ề",
	["ể"] = "Ể",
	["ễ"] = "Ễ",
	["ệ"] = "Ệ",
	["ỉ"] = "Ỉ",
	["ị"] = "Ị",
	["ọ"] = "Ọ",
	["ỏ"] = "Ỏ",
	["ố"] = "Ố",
	["ồ"] = "Ồ",
	["ổ"] = "Ổ",
	["ỗ"] = "Ỗ",
	["ộ"] = "Ộ",
	["ớ"] = "Ớ",
	["ờ"] = "Ờ",
	["ở"] = "Ở",
	["ỡ"] = "Ỡ",
	["ợ"] = "Ợ",
	["ụ"] = "Ụ",
	["ủ"] = "Ủ",
	["ứ"] = "Ứ",
	["ừ"] = "Ừ",
	["ử"] = "Ử",
	["ữ"] = "Ữ",
	["ự"] = "Ự",
	["ỳ"] = "Ỳ",
	["ỵ"] = "Ỵ",
	["ỷ"] = "Ỷ",
	["ỹ"] = "Ỹ",
	["ἀ"] = "Ἀ",
	["ἁ"] = "Ἁ",
	["ἂ"] = "Ἂ",
	["ἃ"] = "Ἃ",
	["ἄ"] = "Ἄ",
	["ἅ"] = "Ἅ",
	["ἆ"] = "Ἆ",
	["ἇ"] = "Ἇ",
	["ἐ"] = "Ἐ",
	["ἑ"] = "Ἑ",
	["ἒ"] = "Ἒ",
	["ἓ"] = "Ἓ",
	["ἔ"] = "Ἔ",
	["ἕ"] = "Ἕ",
	["ἠ"] = "Ἠ",
	["ἡ"] = "Ἡ",
	["ἢ"] = "Ἢ",
	["ἣ"] = "Ἣ",
	["ἤ"] = "Ἤ",
	["ἥ"] = "Ἥ",
	["ἦ"] = "Ἦ",
	["ἧ"] = "Ἧ",
	["ἰ"] = "Ἰ",
	["ἱ"] = "Ἱ",
	["ἲ"] = "Ἲ",
	["ἳ"] = "Ἳ",
	["ἴ"] = "Ἴ",
	["ἵ"] = "Ἵ",
	["ἶ"] = "Ἶ",
	["ἷ"] = "Ἷ",
	["ὀ"] = "Ὀ",
	["ὁ"] = "Ὁ",
	["ὂ"] = "Ὂ",
	["ὃ"] = "Ὃ",
	["ὄ"] = "Ὄ",
	["ὅ"] = "Ὅ",
	["ὑ"] = "Ὑ",
	["ὓ"] = "Ὓ",
	["ὕ"] = "Ὕ",
	["ὗ"] = "Ὗ",
	["ὠ"] = "Ὠ",
	["ὡ"] = "Ὡ",
	["ὢ"] = "Ὢ",
	["ὣ"] = "Ὣ",
	["ὤ"] = "Ὤ",
	["ὥ"] = "Ὥ",
	["ὦ"] = "Ὦ",
	["ὧ"] = "Ὧ",
	["ὰ"] = "Ὰ",
	["ά"] = "Ά",
	["ὲ"] = "Ὲ",
	["έ"] = "Έ",
	["ὴ"] = "Ὴ",
	["ή"] = "Ή",
	["ὶ"] = "Ὶ",
	["ί"] = "Ί",
	["ὸ"] = "Ὸ",
	["ό"] = "Ό",
	["ὺ"] = "Ὺ",
	["ύ"] = "Ύ",
	["ὼ"] = "Ὼ",
	["ώ"] = "Ώ",
	["ᾀ"] = "ᾈ",
	["ᾁ"] = "ᾉ",
	["ᾂ"] = "ᾊ",
	["ᾃ"] = "ᾋ",
	["ᾄ"] = "ᾌ",
	["ᾅ"] = "ᾍ",
	["ᾆ"] = "ᾎ",
	["ᾇ"] = "ᾏ",
	["ᾐ"] = "ᾘ",
	["ᾑ"] = "ᾙ",
	["ᾒ"] = "ᾚ",
	["ᾓ"] = "ᾛ",
	["ᾔ"] = "ᾜ",
	["ᾕ"] = "ᾝ",
	["ᾖ"] = "ᾞ",
	["ᾗ"] = "ᾟ",
	["ᾠ"] = "ᾨ",
	["ᾡ"] = "ᾩ",
	["ᾢ"] = "ᾪ",
	["ᾣ"] = "ᾫ",
	["ᾤ"] = "ᾬ",
	["ᾥ"] = "ᾭ",
	["ᾦ"] = "ᾮ",
	["ᾧ"] = "ᾯ",
	["ᾰ"] = "Ᾰ",
	["ᾱ"] = "Ᾱ",
	["ᾳ"] = "ᾼ",
	["ι"] = "Ι",
	["ῃ"] = "ῌ",
	["ῐ"] = "Ῐ",
	["ῑ"] = "Ῑ",
	["ῠ"] = "Ῠ",
	["ῡ"] = "Ῡ",
	["ῥ"] = "Ῥ",
	["ῳ"] = "ῼ",
	["ⅎ"] = "Ⅎ",
	["ⅰ"] = "Ⅰ",
	["ⅱ"] = "Ⅱ",
	["ⅲ"] = "Ⅲ",
	["ⅳ"] = "Ⅳ",
	["ⅴ"] = "Ⅴ",
	["ⅵ"] = "Ⅵ",
	["ⅶ"] = "Ⅶ",
	["ⅷ"] = "Ⅷ",
	["ⅸ"] = "Ⅸ",
	["ⅹ"] = "Ⅹ",
	["ⅺ"] = "Ⅺ",
	["ⅻ"] = "Ⅻ",
	["ⅼ"] = "Ⅼ",
	["ⅽ"] = "Ⅽ",
	["ⅾ"] = "Ⅾ",
	["ⅿ"] = "Ⅿ",
	["ↄ"] = "Ↄ",
	["ⓐ"] = "Ⓐ",
	["ⓑ"] = "Ⓑ",
	["ⓒ"] = "Ⓒ",
	["ⓓ"] = "Ⓓ",
	["ⓔ"] = "Ⓔ",
	["ⓕ"] = "Ⓕ",
	["ⓖ"] = "Ⓖ",
	["ⓗ"] = "Ⓗ",
	["ⓘ"] = "Ⓘ",
	["ⓙ"] = "Ⓙ",
	["ⓚ"] = "Ⓚ",
	["ⓛ"] = "Ⓛ",
	["ⓜ"] = "Ⓜ",
	["ⓝ"] = "Ⓝ",
	["ⓞ"] = "Ⓞ",
	["ⓟ"] = "Ⓟ",
	["ⓠ"] = "Ⓠ",
	["ⓡ"] = "Ⓡ",
	["ⓢ"] = "Ⓢ",
	["ⓣ"] = "Ⓣ",
	["ⓤ"] = "Ⓤ",
	["ⓥ"] = "Ⓥ",
	["ⓦ"] = "Ⓦ",
	["ⓧ"] = "Ⓧ",
	["ⓨ"] = "Ⓨ",
	["ⓩ"] = "Ⓩ",
	["ⰰ"] = "Ⰰ",
	["ⰱ"] = "Ⰱ",
	["ⰲ"] = "Ⰲ",
	["ⰳ"] = "Ⰳ",
	["ⰴ"] = "Ⰴ",
	["ⰵ"] = "Ⰵ",
	["ⰶ"] = "Ⰶ",
	["ⰷ"] = "Ⰷ",
	["ⰸ"] = "Ⰸ",
	["ⰹ"] = "Ⰹ",
	["ⰺ"] = "Ⰺ",
	["ⰻ"] = "Ⰻ",
	["ⰼ"] = "Ⰼ",
	["ⰽ"] = "Ⰽ",
	["ⰾ"] = "Ⰾ",
	["ⰿ"] = "Ⰿ",
	["ⱀ"] = "Ⱀ",
	["ⱁ"] = "Ⱁ",
	["ⱂ"] = "Ⱂ",
	["ⱃ"] = "Ⱃ",
	["ⱄ"] = "Ⱄ",
	["ⱅ"] = "Ⱅ",
	["ⱆ"] = "Ⱆ",
	["ⱇ"] = "Ⱇ",
	["ⱈ"] = "Ⱈ",
	["ⱉ"] = "Ⱉ",
	["ⱊ"] = "Ⱊ",
	["ⱋ"] = "Ⱋ",
	["ⱌ"] = "Ⱌ",
	["ⱍ"] = "Ⱍ",
	["ⱎ"] = "Ⱎ",
	["ⱏ"] = "Ⱏ",
	["ⱐ"] = "Ⱐ",
	["ⱑ"] = "Ⱑ",
	["ⱒ"] = "Ⱒ",
	["ⱓ"] = "Ⱓ",
	["ⱔ"] = "Ⱔ",
	["ⱕ"] = "Ⱕ",
	["ⱖ"] = "Ⱖ",
	["ⱗ"] = "Ⱗ",
	["ⱘ"] = "Ⱘ",
	["ⱙ"] = "Ⱙ",
	["ⱚ"] = "Ⱚ",
	["ⱛ"] = "Ⱛ",
	["ⱜ"] = "Ⱜ",
	["ⱝ"] = "Ⱝ",
	["ⱞ"] = "Ⱞ",
	["ⱡ"] = "Ⱡ",
	["ⱥ"] = "Ⱥ",
	["ⱦ"] = "Ⱦ",
	["ⱨ"] = "Ⱨ",
	["ⱪ"] = "Ⱪ",
	["ⱬ"] = "Ⱬ",
	["ⱶ"] = "Ⱶ",
	["ⲁ"] = "Ⲁ",
	["ⲃ"] = "Ⲃ",
	["ⲅ"] = "Ⲅ",
	["ⲇ"] = "Ⲇ",
	["ⲉ"] = "Ⲉ",
	["ⲋ"] = "Ⲋ",
	["ⲍ"] = "Ⲍ",
	["ⲏ"] = "Ⲏ",
	["ⲑ"] = "Ⲑ",
	["ⲓ"] = "Ⲓ",
	["ⲕ"] = "Ⲕ",
	["ⲗ"] = "Ⲗ",
	["ⲙ"] = "Ⲙ",
	["ⲛ"] = "Ⲛ",
	["ⲝ"] = "Ⲝ",
	["ⲟ"] = "Ⲟ",
	["ⲡ"] = "Ⲡ",
	["ⲣ"] = "Ⲣ",
	["ⲥ"] = "Ⲥ",
	["ⲧ"] = "Ⲧ",
	["ⲩ"] = "Ⲩ",
	["ⲫ"] = "Ⲫ",
	["ⲭ"] = "Ⲭ",
	["ⲯ"] = "Ⲯ",
	["ⲱ"] = "Ⲱ",
	["ⲳ"] = "Ⲳ",
	["ⲵ"] = "Ⲵ",
	["ⲷ"] = "Ⲷ",
	["ⲹ"] = "Ⲹ",
	["ⲻ"] = "Ⲻ",
	["ⲽ"] = "Ⲽ",
	["ⲿ"] = "Ⲿ",
	["ⳁ"] = "Ⳁ",
	["ⳃ"] = "Ⳃ",
	["ⳅ"] = "Ⳅ",
	["ⳇ"] = "Ⳇ",
	["ⳉ"] = "Ⳉ",
	["ⳋ"] = "Ⳋ",
	["ⳍ"] = "Ⳍ",
	["ⳏ"] = "Ⳏ",
	["ⳑ"] = "Ⳑ",
	["ⳓ"] = "Ⳓ",
	["ⳕ"] = "Ⳕ",
	["ⳗ"] = "Ⳗ",
	["ⳙ"] = "Ⳙ",
	["ⳛ"] = "Ⳛ",
	["ⳝ"] = "Ⳝ",
	["ⳟ"] = "Ⳟ",
	["ⳡ"] = "Ⳡ",
	["ⳣ"] = "Ⳣ",
	["ⴀ"] = "Ⴀ",
	["ⴁ"] = "Ⴁ",
	["ⴂ"] = "Ⴂ",
	["ⴃ"] = "Ⴃ",
	["ⴄ"] = "Ⴄ",
	["ⴅ"] = "Ⴅ",
	["ⴆ"] = "Ⴆ",
	["ⴇ"] = "Ⴇ",
	["ⴈ"] = "Ⴈ",
	["ⴉ"] = "Ⴉ",
	["ⴊ"] = "Ⴊ",
	["ⴋ"] = "Ⴋ",
	["ⴌ"] = "Ⴌ",
	["ⴍ"] = "Ⴍ",
	["ⴎ"] = "Ⴎ",
	["ⴏ"] = "Ⴏ",
	["ⴐ"] = "Ⴐ",
	["ⴑ"] = "Ⴑ",
	["ⴒ"] = "Ⴒ",
	["ⴓ"] = "Ⴓ",
	["ⴔ"] = "Ⴔ",
	["ⴕ"] = "Ⴕ",
	["ⴖ"] = "Ⴖ",
	["ⴗ"] = "Ⴗ",
	["ⴘ"] = "Ⴘ",
	["ⴙ"] = "Ⴙ",
	["ⴚ"] = "Ⴚ",
	["ⴛ"] = "Ⴛ",
	["ⴜ"] = "Ⴜ",
	["ⴝ"] = "Ⴝ",
	["ⴞ"] = "Ⴞ",
	["ⴟ"] = "Ⴟ",
	["ⴠ"] = "Ⴠ",
	["ⴡ"] = "Ⴡ",
	["ⴢ"] = "Ⴢ",
	["ⴣ"] = "Ⴣ",
	["ⴤ"] = "Ⴤ",
	["ⴥ"] = "Ⴥ",
	["ａ"] = "Ａ",
	["ｂ"] = "Ｂ",
	["ｃ"] = "Ｃ",
	["ｄ"] = "Ｄ",
	["ｅ"] = "Ｅ",
	["ｆ"] = "Ｆ",
	["ｇ"] = "Ｇ",
	["ｈ"] = "Ｈ",
	["ｉ"] = "Ｉ",
	["ｊ"] = "Ｊ",
	["ｋ"] = "Ｋ",
	["ｌ"] = "Ｌ",
	["ｍ"] = "Ｍ",
	["ｎ"] = "Ｎ",
	["ｏ"] = "Ｏ",
	["ｐ"] = "Ｐ",
	["ｑ"] = "Ｑ",
	["ｒ"] = "Ｒ",
	["ｓ"] = "Ｓ",
	["ｔ"] = "Ｔ",
	["ｕ"] = "Ｕ",
	["ｖ"] = "Ｖ",
	["ｗ"] = "Ｗ",
	["ｘ"] = "Ｘ",
	["ｙ"] = "Ｙ",
	["ｚ"] = "Ｚ",
	["𐐨"] = "𐐀",
	["𐐩"] = "𐐁",
	["𐐪"] = "𐐂",
	["𐐫"] = "𐐃",
	["𐐬"] = "𐐄",
	["𐐭"] = "𐐅",
	["𐐮"] = "𐐆",
	["𐐯"] = "𐐇",
	["𐐰"] = "𐐈",
	["𐐱"] = "𐐉",
	["𐐲"] = "𐐊",
	["𐐳"] = "𐐋",
	["𐐴"] = "𐐌",
	["𐐵"] = "𐐍",
	["𐐶"] = "𐐎",
	["𐐷"] = "𐐏",
	["𐐸"] = "𐐐",
	["𐐹"] = "𐐑",
	["𐐺"] = "𐐒",
	["𐐻"] = "𐐓",
	["𐐼"] = "𐐔",
	["𐐽"] = "𐐕",
	["𐐾"] = "𐐖",
	["𐐿"] = "𐐗",
	["𐑀"] = "𐐘",
	["𐑁"] = "𐐙",
	["𐑂"] = "𐐚",
	["𐑃"] = "𐐛",
	["𐑄"] = "𐐜",
	["𐑅"] = "𐐝",
	["𐑆"] = "𐐞",
	["𐑇"] = "𐐟",
	["𐑈"] = "𐐠",
	["𐑉"] = "𐐡",
	["𐑊"] = "𐐢",
	["𐑋"] = "𐐣",
	["𐑌"] = "𐐤",
	["𐑍"] = "𐐥",
	["𐑎"] = "𐐦",
	["𐑏"] = "𐐧",
}

utf8_uc_lc = {
	["A"] = "a",
	["B"] = "b",
	["C"] = "c",
	["D"] = "d",
	["E"] = "e",
	["F"] = "f",
	["G"] = "g",
	["H"] = "h",
	["I"] = "i",
	["J"] = "j",
	["K"] = "k",
	["L"] = "l",
	["M"] = "m",
	["N"] = "n",
	["O"] = "o",
	["P"] = "p",
	["Q"] = "q",
	["R"] = "r",
	["S"] = "s",
	["T"] = "t",
	["U"] = "u",
	["V"] = "v",
	["W"] = "w",
	["X"] = "x",
	["Y"] = "y",
	["Z"] = "z",
	["À"] = "à",
	["Á"] = "á",
	["Â"] = "â",
	["Ã"] = "ã",
	["Ä"] = "ä",
	["Å"] = "å",
	["Æ"] = "æ",
	["Ç"] = "ç",
	["È"] = "è",
	["É"] = "é",
	["Ê"] = "ê",
	["Ë"] = "ë",
	["Ì"] = "ì",
	["Í"] = "í",
	["Î"] = "î",
	["Ï"] = "ï",
	["Ð"] = "ð",
	["Ñ"] = "ñ",
	["Ò"] = "ò",
	["Ó"] = "ó",
	["Ô"] = "ô",
	["Õ"] = "õ",
	["Ö"] = "ö",
	["Ø"] = "ø",
	["Ù"] = "ù",
	["Ú"] = "ú",
	["Û"] = "û",
	["Ü"] = "ü",
	["Ý"] = "ý",
	["Þ"] = "þ",
	["Ā"] = "ā",
	["Ă"] = "ă",
	["Ą"] = "ą",
	["Ć"] = "ć",
	["Ĉ"] = "ĉ",
	["Ċ"] = "ċ",
	["Č"] = "č",
	["Ď"] = "ď",
	["Đ"] = "đ",
	["Ē"] = "ē",
	["Ĕ"] = "ĕ",
	["Ė"] = "ė",
	["Ę"] = "ę",
	["Ě"] = "ě",
	["Ĝ"] = "ĝ",
	["Ğ"] = "ğ",
	["Ġ"] = "ġ",
	["Ģ"] = "ģ",
	["Ĥ"] = "ĥ",
	["Ħ"] = "ħ",
	["Ĩ"] = "ĩ",
	["Ī"] = "ī",
	["Ĭ"] = "ĭ",
	["Į"] = "į",
	["İ"] = "i",
	["Ĳ"] = "ĳ",
	["Ĵ"] = "ĵ",
	["Ķ"] = "ķ",
	["Ĺ"] = "ĺ",
	["Ļ"] = "ļ",
	["Ľ"] = "ľ",
	["Ŀ"] = "ŀ",
	["Ł"] = "ł",
	["Ń"] = "ń",
	["Ņ"] = "ņ",
	["Ň"] = "ň",
	["Ŋ"] = "ŋ",
	["Ō"] = "ō",
	["Ŏ"] = "ŏ",
	["Ő"] = "ő",
	["Œ"] = "œ",
	["Ŕ"] = "ŕ",
	["Ŗ"] = "ŗ",
	["Ř"] = "ř",
	["Ś"] = "ś",
	["Ŝ"] = "ŝ",
	["Ş"] = "ş",
	["Š"] = "š",
	["Ţ"] = "ţ",
	["Ť"] = "ť",
	["Ŧ"] = "ŧ",
	["Ũ"] = "ũ",
	["Ū"] = "ū",
	["Ŭ"] = "ŭ",
	["Ů"] = "ů",
	["Ű"] = "ű",
	["Ų"] = "ų",
	["Ŵ"] = "ŵ",
	["Ŷ"] = "ŷ",
	["Ÿ"] = "ÿ",
	["Ź"] = "ź",
	["Ż"] = "ż",
	["Ž"] = "ž",
	["Ɓ"] = "ɓ",
	["Ƃ"] = "ƃ",
	["Ƅ"] = "ƅ",
	["Ɔ"] = "ɔ",
	["Ƈ"] = "ƈ",
	["Ɖ"] = "ɖ",
	["Ɗ"] = "ɗ",
	["Ƌ"] = "ƌ",
	["Ǝ"] = "ǝ",
	["Ə"] = "ə",
	["Ɛ"] = "ɛ",
	["Ƒ"] = "ƒ",
	["Ɠ"] = "ɠ",
	["Ɣ"] = "ɣ",
	["Ɩ"] = "ɩ",
	["Ɨ"] = "ɨ",
	["Ƙ"] = "ƙ",
	["Ɯ"] = "ɯ",
	["Ɲ"] = "ɲ",
	["Ɵ"] = "ɵ",
	["Ơ"] = "ơ",
	["Ƣ"] = "ƣ",
	["Ƥ"] = "ƥ",
	["Ʀ"] = "ʀ",
	["Ƨ"] = "ƨ",
	["Ʃ"] = "ʃ",
	["Ƭ"] = "ƭ",
	["Ʈ"] = "ʈ",
	["Ư"] = "ư",
	["Ʊ"] = "ʊ",
	["Ʋ"] = "ʋ",
	["Ƴ"] = "ƴ",
	["Ƶ"] = "ƶ",
	["Ʒ"] = "ʒ",
	["Ƹ"] = "ƹ",
	["Ƽ"] = "ƽ",
	["Ǆ"] = "ǆ",
	["ǅ"] = "ǆ",
	["Ǉ"] = "ǉ",
	["ǈ"] = "ǉ",
	["Ǌ"] = "ǌ",
	["ǋ"] = "ǌ",
	["Ǎ"] = "ǎ",
	["Ǐ"] = "ǐ",
	["Ǒ"] = "ǒ",
	["Ǔ"] = "ǔ",
	["Ǖ"] = "ǖ",
	["Ǘ"] = "ǘ",
	["Ǚ"] = "ǚ",
	["Ǜ"] = "ǜ",
	["Ǟ"] = "ǟ",
	["Ǡ"] = "ǡ",
	["Ǣ"] = "ǣ",
	["Ǥ"] = "ǥ",
	["Ǧ"] = "ǧ",
	["Ǩ"] = "ǩ",
	["Ǫ"] = "ǫ",
	["Ǭ"] = "ǭ",
	["Ǯ"] = "ǯ",
	["Ǳ"] = "ǳ",
	["ǲ"] = "ǳ",
	["Ǵ"] = "ǵ",
	["Ƕ"] = "ƕ",
	["Ƿ"] = "ƿ",
	["Ǹ"] = "ǹ",
	["Ǻ"] = "ǻ",
	["Ǽ"] = "ǽ",
	["Ǿ"] = "ǿ",
	["Ȁ"] = "ȁ",
	["Ȃ"] = "ȃ",
	["Ȅ"] = "ȅ",
	["Ȇ"] = "ȇ",
	["Ȉ"] = "ȉ",
	["Ȋ"] = "ȋ",
	["Ȍ"] = "ȍ",
	["Ȏ"] = "ȏ",
	["Ȑ"] = "ȑ",
	["Ȓ"] = "ȓ",
	["Ȕ"] = "ȕ",
	["Ȗ"] = "ȗ",
	["Ș"] = "ș",
	["Ț"] = "ț",
	["Ȝ"] = "ȝ",
	["Ȟ"] = "ȟ",
	["Ƞ"] = "ƞ",
	["Ȣ"] = "ȣ",
	["Ȥ"] = "ȥ",
	["Ȧ"] = "ȧ",
	["Ȩ"] = "ȩ",
	["Ȫ"] = "ȫ",
	["Ȭ"] = "ȭ",
	["Ȯ"] = "ȯ",
	["Ȱ"] = "ȱ",
	["Ȳ"] = "ȳ",
	["Ⱥ"] = "ⱥ",
	["Ȼ"] = "ȼ",
	["Ƚ"] = "ƚ",
	["Ⱦ"] = "ⱦ",
	["Ɂ"] = "ɂ",
	["Ƀ"] = "ƀ",
	["Ʉ"] = "ʉ",
	["Ʌ"] = "ʌ",
	["Ɇ"] = "ɇ",
	["Ɉ"] = "ɉ",
	["Ɋ"] = "ɋ",
	["Ɍ"] = "ɍ",
	["Ɏ"] = "ɏ",
	["Ά"] = "ά",
	["Έ"] = "έ",
	["Ή"] = "ή",
	["Ί"] = "ί",
	["Ό"] = "ό",
	["Ύ"] = "ύ",
	["Ώ"] = "ώ",
	["Α"] = "α",
	["Β"] = "β",
	["Γ"] = "γ",
	["Δ"] = "δ",
	["Ε"] = "ε",
	["Ζ"] = "ζ",
	["Η"] = "η",
	["Θ"] = "θ",
	["Ι"] = "ι",
	["Κ"] = "κ",
	["Λ"] = "λ",
	["Μ"] = "μ",
	["Ν"] = "ν",
	["Ξ"] = "ξ",
	["Ο"] = "ο",
	["Π"] = "π",
	["Ρ"] = "ρ",
	["Σ"] = "σ",
	["Τ"] = "τ",
	["Υ"] = "υ",
	["Φ"] = "φ",
	["Χ"] = "χ",
	["Ψ"] = "ψ",
	["Ω"] = "ω",
	["Ϊ"] = "ϊ",
	["Ϋ"] = "ϋ",
	["Ϙ"] = "ϙ",
	["Ϛ"] = "ϛ",
	["Ϝ"] = "ϝ",
	["Ϟ"] = "ϟ",
	["Ϡ"] = "ϡ",
	["Ϣ"] = "ϣ",
	["Ϥ"] = "ϥ",
	["Ϧ"] = "ϧ",
	["Ϩ"] = "ϩ",
	["Ϫ"] = "ϫ",
	["Ϭ"] = "ϭ",
	["Ϯ"] = "ϯ",
	["ϴ"] = "θ",
	["Ϸ"] = "ϸ",
	["Ϲ"] = "ϲ",
	["Ϻ"] = "ϻ",
	["Ͻ"] = "ͻ",
	["Ͼ"] = "ͼ",
	["Ͽ"] = "ͽ",
	["Ѐ"] = "ѐ",
	["Ё"] = "ё",
	["Ђ"] = "ђ",
	["Ѓ"] = "ѓ",
	["Є"] = "є",
	["Ѕ"] = "ѕ",
	["І"] = "і",
	["Ї"] = "ї",
	["Ј"] = "ј",
	["Љ"] = "љ",
	["Њ"] = "њ",
	["Ћ"] = "ћ",
	["Ќ"] = "ќ",
	["Ѝ"] = "ѝ",
	["Ў"] = "ў",
	["Џ"] = "џ",
	["А"] = "а",
	["Б"] = "б",
	["В"] = "в",
	["Г"] = "г",
	["Д"] = "д",
	["Е"] = "е",
	["Ж"] = "ж",
	["З"] = "з",
	["И"] = "и",
	["Й"] = "й",
	["К"] = "к",
	["Л"] = "л",
	["М"] = "м",
	["Н"] = "н",
	["О"] = "о",
	["П"] = "п",
	["Р"] = "р",
	["С"] = "с",
	["Т"] = "т",
	["У"] = "у",
	["Ф"] = "ф",
	["Х"] = "х",
	["Ц"] = "ц",
	["Ч"] = "ч",
	["Ш"] = "ш",
	["Щ"] = "щ",
	["Ъ"] = "ъ",
	["Ы"] = "і",
	["Ь"] = "ь",
	["Е"] = "е",
	["Ю"] = "ю",
	["Я"] = "я",
	["Ѡ"] = "ѡ",
	["Ѣ"] = "ѣ",
	["Ѥ"] = "ѥ",
	["Ѧ"] = "ѧ",
	["Ѩ"] = "ѩ",
	["Ѫ"] = "ѫ",
	["Ѭ"] = "ѭ",
	["Ѯ"] = "ѯ",
	["Ѱ"] = "ѱ",
	["Ѳ"] = "ѳ",
	["Ѵ"] = "ѵ",
	["Ѷ"] = "ѷ",
	["Ѹ"] = "ѹ",
	["Ѻ"] = "ѻ",
	["Ѽ"] = "ѽ",
	["Ѿ"] = "ѿ",
	["Ҁ"] = "ҁ",
	["Ҋ"] = "ҋ",
	["Ҍ"] = "ҍ",
	["Ҏ"] = "ҏ",
	["Ґ"] = "ґ",
	["Ғ"] = "ғ",
	["Ҕ"] = "ҕ",
	["Җ"] = "җ",
	["Ҙ"] = "ҙ",
	["Қ"] = "қ",
	["Ҝ"] = "ҝ",
	["Ҟ"] = "ҟ",
	["Ҡ"] = "ҡ",
	["Ң"] = "ң",
	["Ҥ"] = "ҥ",
	["Ҧ"] = "ҧ",
	["Ҩ"] = "ҩ",
	["Ҫ"] = "ҫ",
	["Ҭ"] = "ҭ",
	["Ү"] = "ү",
	["Ұ"] = "ұ",
	["Ҳ"] = "ҳ",
	["Ҵ"] = "ҵ",
	["Ҷ"] = "ҷ",
	["Ҹ"] = "ҹ",
	["Һ"] = "һ",
	["Ҽ"] = "ҽ",
	["Ҿ"] = "ҿ",
	["Ӏ"] = "ӏ",
	["Ӂ"] = "ӂ",
	["Ӄ"] = "ӄ",
	["Ӆ"] = "ӆ",
	["Ӈ"] = "ӈ",
	["Ӊ"] = "ӊ",
	["Ӌ"] = "ӌ",
	["Ӎ"] = "ӎ",
	["Ӑ"] = "ӑ",
	["Ӓ"] = "ӓ",
	["Ӕ"] = "ӕ",
	["Ӗ"] = "ӗ",
	["Ә"] = "ә",
	["Ӛ"] = "ӛ",
	["Ӝ"] = "ӝ",
	["Ӟ"] = "ӟ",
	["Ӡ"] = "ӡ",
	["Ӣ"] = "ӣ",
	["Ӥ"] = "ӥ",
	["Ӧ"] = "ӧ",
	["Ө"] = "ө",
	["Ӫ"] = "ӫ",
	["Ӭ"] = "ӭ",
	["Ӯ"] = "ӯ",
	["Ӱ"] = "ӱ",
	["Ӳ"] = "ӳ",
	["Ӵ"] = "ӵ",
	["Ӷ"] = "ӷ",
	["Ӹ"] = "ӹ",
	["Ӻ"] = "ӻ",
	["Ӽ"] = "ӽ",
	["Ӿ"] = "ӿ",
	["Ԁ"] = "ԁ",
	["Ԃ"] = "ԃ",
	["Ԅ"] = "ԅ",
	["Ԇ"] = "ԇ",
	["Ԉ"] = "ԉ",
	["Ԋ"] = "ԋ",
	["Ԍ"] = "ԍ",
	["Ԏ"] = "ԏ",
	["Ԑ"] = "ԑ",
	["Ԓ"] = "ԓ",
	["Ա"] = "ա",
	["Բ"] = "բ",
	["Գ"] = "գ",
	["Դ"] = "դ",
	["Ե"] = "ե",
	["Զ"] = "զ",
	["Է"] = "է",
	["Ը"] = "ը",
	["Թ"] = "թ",
	["Ժ"] = "ժ",
	["Ի"] = "ի",
	["Լ"] = "լ",
	["Խ"] = "խ",
	["Ծ"] = "ծ",
	["Կ"] = "կ",
	["Հ"] = "հ",
	["Ձ"] = "ձ",
	["Ղ"] = "ղ",
	["Ճ"] = "ճ",
	["Մ"] = "մ",
	["Յ"] = "յ",
	["Ն"] = "ն",
	["Շ"] = "շ",
	["Ո"] = "ո",
	["Չ"] = "չ",
	["Պ"] = "պ",
	["Ջ"] = "ջ",
	["Ռ"] = "ռ",
	["Ս"] = "ս",
	["Վ"] = "վ",
	["Տ"] = "տ",
	["Ր"] = "ր",
	["Ց"] = "ց",
	["Ւ"] = "ւ",
	["Փ"] = "փ",
	["Ք"] = "ք",
	["Օ"] = "օ",
	["Ֆ"] = "ֆ",
	["Ⴀ"] = "ⴀ",
	["Ⴁ"] = "ⴁ",
	["Ⴂ"] = "ⴂ",
	["Ⴃ"] = "ⴃ",
	["Ⴄ"] = "ⴄ",
	["Ⴅ"] = "ⴅ",
	["Ⴆ"] = "ⴆ",
	["Ⴇ"] = "ⴇ",
	["Ⴈ"] = "ⴈ",
	["Ⴉ"] = "ⴉ",
	["Ⴊ"] = "ⴊ",
	["Ⴋ"] = "ⴋ",
	["Ⴌ"] = "ⴌ",
	["Ⴍ"] = "ⴍ",
	["Ⴎ"] = "ⴎ",
	["Ⴏ"] = "ⴏ",
	["Ⴐ"] = "ⴐ",
	["Ⴑ"] = "ⴑ",
	["Ⴒ"] = "ⴒ",
	["Ⴓ"] = "ⴓ",
	["Ⴔ"] = "ⴔ",
	["Ⴕ"] = "ⴕ",
	["Ⴖ"] = "ⴖ",
	["Ⴗ"] = "ⴗ",
	["Ⴘ"] = "ⴘ",
	["Ⴙ"] = "ⴙ",
	["Ⴚ"] = "ⴚ",
	["Ⴛ"] = "ⴛ",
	["Ⴜ"] = "ⴜ",
	["Ⴝ"] = "ⴝ",
	["Ⴞ"] = "ⴞ",
	["Ⴟ"] = "ⴟ",
	["Ⴠ"] = "ⴠ",
	["Ⴡ"] = "ⴡ",
	["Ⴢ"] = "ⴢ",
	["Ⴣ"] = "ⴣ",
	["Ⴤ"] = "ⴤ",
	["Ⴥ"] = "ⴥ",
	["Ḁ"] = "ḁ",
	["Ḃ"] = "ḃ",
	["Ḅ"] = "ḅ",
	["Ḇ"] = "ḇ",
	["Ḉ"] = "ḉ",
	["Ḋ"] = "ḋ",
	["Ḍ"] = "ḍ",
	["Ḏ"] = "ḏ",
	["Ḑ"] = "ḑ",
	["Ḓ"] = "ḓ",
	["Ḕ"] = "ḕ",
	["Ḗ"] = "ḗ",
	["Ḙ"] = "ḙ",
	["Ḛ"] = "ḛ",
	["Ḝ"] = "ḝ",
	["Ḟ"] = "ḟ",
	["Ḡ"] = "ḡ",
	["Ḣ"] = "ḣ",
	["Ḥ"] = "ḥ",
	["Ḧ"] = "ḧ",
	["Ḩ"] = "ḩ",
	["Ḫ"] = "ḫ",
	["Ḭ"] = "ḭ",
	["Ḯ"] = "ḯ",
	["Ḱ"] = "ḱ",
	["Ḳ"] = "ḳ",
	["Ḵ"] = "ḵ",
	["Ḷ"] = "ḷ",
	["Ḹ"] = "ḹ",
	["Ḻ"] = "ḻ",
	["Ḽ"] = "ḽ",
	["Ḿ"] = "ḿ",
	["Ṁ"] = "ṁ",
	["Ṃ"] = "ṃ",
	["Ṅ"] = "ṅ",
	["Ṇ"] = "ṇ",
	["Ṉ"] = "ṉ",
	["Ṋ"] = "ṋ",
	["Ṍ"] = "ṍ",
	["Ṏ"] = "ṏ",
	["Ṑ"] = "ṑ",
	["Ṓ"] = "ṓ",
	["Ṕ"] = "ṕ",
	["Ṗ"] = "ṗ",
	["Ṙ"] = "ṙ",
	["Ṛ"] = "ṛ",
	["Ṝ"] = "ṝ",
	["Ṟ"] = "ṟ",
	["Ṡ"] = "ṡ",
	["Ṣ"] = "ṣ",
	["Ṥ"] = "ṥ",
	["Ṧ"] = "ṧ",
	["Ṩ"] = "ṩ",
	["Ṫ"] = "ṫ",
	["Ṭ"] = "ṭ",
	["Ṯ"] = "ṯ",
	["Ṱ"] = "ṱ",
	["Ṳ"] = "ṳ",
	["Ṵ"] = "ṵ",
	["Ṷ"] = "ṷ",
	["Ṹ"] = "ṹ",
	["Ṻ"] = "ṻ",
	["Ṽ"] = "ṽ",
	["Ṿ"] = "ṿ",
	["Ẁ"] = "ẁ",
	["Ẃ"] = "ẃ",
	["Ẅ"] = "ẅ",
	["Ẇ"] = "ẇ",
	["Ẉ"] = "ẉ",
	["Ẋ"] = "ẋ",
	["Ẍ"] = "ẍ",
	["Ẏ"] = "ẏ",
	["Ẑ"] = "ẑ",
	["Ẓ"] = "ẓ",
	["Ẕ"] = "ẕ",
	["Ạ"] = "ạ",
	["Ả"] = "ả",
	["Ấ"] = "ấ",
	["Ầ"] = "ầ",
	["Ẩ"] = "ẩ",
	["Ẫ"] = "ẫ",
	["Ậ"] = "ậ",
	["Ắ"] = "ắ",
	["Ằ"] = "ằ",
	["Ẳ"] = "ẳ",
	["Ẵ"] = "ẵ",
	["Ặ"] = "ặ",
	["Ẹ"] = "ẹ",
	["Ẻ"] = "ẻ",
	["Ẽ"] = "ẽ",
	["Ế"] = "ế",
	["Ề"] = "ề",
	["Ể"] = "ể",
	["Ễ"] = "ễ",
	["Ệ"] = "ệ",
	["Ỉ"] = "ỉ",
	["Ị"] = "ị",
	["Ọ"] = "ọ",
	["Ỏ"] = "ỏ",
	["Ố"] = "ố",
	["Ồ"] = "ồ",
	["Ổ"] = "ổ",
	["Ỗ"] = "ỗ",
	["Ộ"] = "ộ",
	["Ớ"] = "ớ",
	["Ờ"] = "ờ",
	["Ở"] = "ở",
	["Ỡ"] = "ỡ",
	["Ợ"] = "ợ",
	["Ụ"] = "ụ",
	["Ủ"] = "ủ",
	["Ứ"] = "ứ",
	["Ừ"] = "ừ",
	["Ử"] = "ử",
	["Ữ"] = "ữ",
	["Ự"] = "ự",
	["Ỳ"] = "ỳ",
	["Ỵ"] = "ỵ",
	["Ỷ"] = "ỷ",
	["Ỹ"] = "ỹ",
	["Ἀ"] = "ἀ",
	["Ἁ"] = "ἁ",
	["Ἂ"] = "ἂ",
	["Ἃ"] = "ἃ",
	["Ἄ"] = "ἄ",
	["Ἅ"] = "ἅ",
	["Ἆ"] = "ἆ",
	["Ἇ"] = "ἇ",
	["Ἐ"] = "ἐ",
	["Ἑ"] = "ἑ",
	["Ἒ"] = "ἒ",
	["Ἓ"] = "ἓ",
	["Ἔ"] = "ἔ",
	["Ἕ"] = "ἕ",
	["Ἠ"] = "ἠ",
	["Ἡ"] = "ἡ",
	["Ἢ"] = "ἢ",
	["Ἣ"] = "ἣ",
	["Ἤ"] = "ἤ",
	["Ἥ"] = "ἥ",
	["Ἦ"] = "ἦ",
	["Ἧ"] = "ἧ",
	["Ἰ"] = "ἰ",
	["Ἱ"] = "ἱ",
	["Ἲ"] = "ἲ",
	["Ἳ"] = "ἳ",
	["Ἴ"] = "ἴ",
	["Ἵ"] = "ἵ",
	["Ἶ"] = "ἶ",
	["Ἷ"] = "ἷ",
	["Ὀ"] = "ὀ",
	["Ὁ"] = "ὁ",
	["Ὂ"] = "ὂ",
	["Ὃ"] = "ὃ",
	["Ὄ"] = "ὄ",
	["Ὅ"] = "ὅ",
	["Ὑ"] = "ὑ",
	["Ὓ"] = "ὓ",
	["Ὕ"] = "ὕ",
	["Ὗ"] = "ὗ",
	["Ὠ"] = "ὠ",
	["Ὡ"] = "ὡ",
	["Ὢ"] = "ὢ",
	["Ὣ"] = "ὣ",
	["Ὤ"] = "ὤ",
	["Ὥ"] = "ὥ",
	["Ὦ"] = "ὦ",
	["Ὧ"] = "ὧ",
	["ᾈ"] = "ᾀ",
	["ᾉ"] = "ᾁ",
	["ᾊ"] = "ᾂ",
	["ᾋ"] = "ᾃ",
	["ᾌ"] = "ᾄ",
	["ᾍ"] = "ᾅ",
	["ᾎ"] = "ᾆ",
	["ᾏ"] = "ᾇ",
	["ᾘ"] = "ᾐ",
	["ᾙ"] = "ᾑ",
	["ᾚ"] = "ᾒ",
	["ᾛ"] = "ᾓ",
	["ᾜ"] = "ᾔ",
	["ᾝ"] = "ᾕ",
	["ᾞ"] = "ᾖ",
	["ᾟ"] = "ᾗ",
	["ᾨ"] = "ᾠ",
	["ᾩ"] = "ᾡ",
	["ᾪ"] = "ᾢ",
	["ᾫ"] = "ᾣ",
	["ᾬ"] = "ᾤ",
	["ᾭ"] = "ᾥ",
	["ᾮ"] = "ᾦ",
	["ᾯ"] = "ᾧ",
	["Ᾰ"] = "ᾰ",
	["Ᾱ"] = "ᾱ",
	["Ὰ"] = "ὰ",
	["Ά"] = "ά",
	["ᾼ"] = "ᾳ",
	["Ὲ"] = "ὲ",
	["Έ"] = "έ",
	["Ὴ"] = "ὴ",
	["Ή"] = "ή",
	["ῌ"] = "ῃ",
	["Ῐ"] = "ῐ",
	["Ῑ"] = "ῑ",
	["Ὶ"] = "ὶ",
	["Ί"] = "ί",
	["Ῠ"] = "ῠ",
	["Ῡ"] = "ῡ",
	["Ὺ"] = "ὺ",
	["Ύ"] = "ύ",
	["Ῥ"] = "ῥ",
	["Ὸ"] = "ὸ",
	["Ό"] = "ό",
	["Ὼ"] = "ὼ",
	["Ώ"] = "ώ",
	["ῼ"] = "ῳ",
	["Ω"] = "ω",
	["K"] = "k",
	["Å"] = "å",
	["Ⅎ"] = "ⅎ",
	["Ⅰ"] = "ⅰ",
	["Ⅱ"] = "ⅱ",
	["Ⅲ"] = "ⅲ",
	["Ⅳ"] = "ⅳ",
	["Ⅴ"] = "ⅴ",
	["Ⅵ"] = "ⅵ",
	["Ⅶ"] = "ⅶ",
	["Ⅷ"] = "ⅷ",
	["Ⅸ"] = "ⅸ",
	["Ⅹ"] = "ⅹ",
	["Ⅺ"] = "ⅺ",
	["Ⅻ"] = "ⅻ",
	["Ⅼ"] = "ⅼ",
	["Ⅽ"] = "ⅽ",
	["Ⅾ"] = "ⅾ",
	["Ⅿ"] = "ⅿ",
	["Ↄ"] = "ↄ",
	["Ⓐ"] = "ⓐ",
	["Ⓑ"] = "ⓑ",
	["Ⓒ"] = "ⓒ",
	["Ⓓ"] = "ⓓ",
	["Ⓔ"] = "ⓔ",
	["Ⓕ"] = "ⓕ",
	["Ⓖ"] = "ⓖ",
	["Ⓗ"] = "ⓗ",
	["Ⓘ"] = "ⓘ",
	["Ⓙ"] = "ⓙ",
	["Ⓚ"] = "ⓚ",
	["Ⓛ"] = "ⓛ",
	["Ⓜ"] = "ⓜ",
	["Ⓝ"] = "ⓝ",
	["Ⓞ"] = "ⓞ",
	["Ⓟ"] = "ⓟ",
	["Ⓠ"] = "ⓠ",
	["Ⓡ"] = "ⓡ",
	["Ⓢ"] = "ⓢ",
	["Ⓣ"] = "ⓣ",
	["Ⓤ"] = "ⓤ",
	["Ⓥ"] = "ⓥ",
	["Ⓦ"] = "ⓦ",
	["Ⓧ"] = "ⓧ",
	["Ⓨ"] = "ⓨ",
	["Ⓩ"] = "ⓩ",
	["Ⰰ"] = "ⰰ",
	["Ⰱ"] = "ⰱ",
	["Ⰲ"] = "ⰲ",
	["Ⰳ"] = "ⰳ",
	["Ⰴ"] = "ⰴ",
	["Ⰵ"] = "ⰵ",
	["Ⰶ"] = "ⰶ",
	["Ⰷ"] = "ⰷ",
	["Ⰸ"] = "ⰸ",
	["Ⰹ"] = "ⰹ",
	["Ⰺ"] = "ⰺ",
	["Ⰻ"] = "ⰻ",
	["Ⰼ"] = "ⰼ",
	["Ⰽ"] = "ⰽ",
	["Ⰾ"] = "ⰾ",
	["Ⰿ"] = "ⰿ",
	["Ⱀ"] = "ⱀ",
	["Ⱁ"] = "ⱁ",
	["Ⱂ"] = "ⱂ",
	["Ⱃ"] = "ⱃ",
	["Ⱄ"] = "ⱄ",
	["Ⱅ"] = "ⱅ",
	["Ⱆ"] = "ⱆ",
	["Ⱇ"] = "ⱇ",
	["Ⱈ"] = "ⱈ",
	["Ⱉ"] = "ⱉ",
	["Ⱊ"] = "ⱊ",
	["Ⱋ"] = "ⱋ",
	["Ⱌ"] = "ⱌ",
	["Ⱍ"] = "ⱍ",
	["Ⱎ"] = "ⱎ",
	["Ⱏ"] = "ⱏ",
	["Ⱐ"] = "ⱐ",
	["Ⱑ"] = "ⱑ",
	["Ⱒ"] = "ⱒ",
	["Ⱓ"] = "ⱓ",
	["Ⱔ"] = "ⱔ",
	["Ⱕ"] = "ⱕ",
	["Ⱖ"] = "ⱖ",
	["Ⱗ"] = "ⱗ",
	["Ⱘ"] = "ⱘ",
	["Ⱙ"] = "ⱙ",
	["Ⱚ"] = "ⱚ",
	["Ⱛ"] = "ⱛ",
	["Ⱜ"] = "ⱜ",
	["Ⱝ"] = "ⱝ",
	["Ⱞ"] = "ⱞ",
	["Ⱡ"] = "ⱡ",
	["Ɫ"] = "ɫ",
	["Ᵽ"] = "ᵽ",
	["Ɽ"] = "ɽ",
	["Ⱨ"] = "ⱨ",
	["Ⱪ"] = "ⱪ",
	["Ⱬ"] = "ⱬ",
	["Ⱶ"] = "ⱶ",
	["Ⲁ"] = "ⲁ",
	["Ⲃ"] = "ⲃ",
	["Ⲅ"] = "ⲅ",
	["Ⲇ"] = "ⲇ",
	["Ⲉ"] = "ⲉ",
	["Ⲋ"] = "ⲋ",
	["Ⲍ"] = "ⲍ",
	["Ⲏ"] = "ⲏ",
	["Ⲑ"] = "ⲑ",
	["Ⲓ"] = "ⲓ",
	["Ⲕ"] = "ⲕ",
	["Ⲗ"] = "ⲗ",
	["Ⲙ"] = "ⲙ",
	["Ⲛ"] = "ⲛ",
	["Ⲝ"] = "ⲝ",
	["Ⲟ"] = "ⲟ",
	["Ⲡ"] = "ⲡ",
	["Ⲣ"] = "ⲣ",
	["Ⲥ"] = "ⲥ",
	["Ⲧ"] = "ⲧ",
	["Ⲩ"] = "ⲩ",
	["Ⲫ"] = "ⲫ",
	["Ⲭ"] = "ⲭ",
	["Ⲯ"] = "ⲯ",
	["Ⲱ"] = "ⲱ",
	["Ⲳ"] = "ⲳ",
	["Ⲵ"] = "ⲵ",
	["Ⲷ"] = "ⲷ",
	["Ⲹ"] = "ⲹ",
	["Ⲻ"] = "ⲻ",
	["Ⲽ"] = "ⲽ",
	["Ⲿ"] = "ⲿ",
	["Ⳁ"] = "ⳁ",
	["Ⳃ"] = "ⳃ",
	["Ⳅ"] = "ⳅ",
	["Ⳇ"] = "ⳇ",
	["Ⳉ"] = "ⳉ",
	["Ⳋ"] = "ⳋ",
	["Ⳍ"] = "ⳍ",
	["Ⳏ"] = "ⳏ",
	["Ⳑ"] = "ⳑ",
	["Ⳓ"] = "ⳓ",
	["Ⳕ"] = "ⳕ",
	["Ⳗ"] = "ⳗ",
	["Ⳙ"] = "ⳙ",
	["Ⳛ"] = "ⳛ",
	["Ⳝ"] = "ⳝ",
	["Ⳟ"] = "ⳟ",
	["Ⳡ"] = "ⳡ",
	["Ⳣ"] = "ⳣ",
	["Ａ"] = "ａ",
	["Ｂ"] = "ｂ",
	["Ｃ"] = "ｃ",
	["Ｄ"] = "ｄ",
	["Ｅ"] = "ｅ",
	["Ｆ"] = "ｆ",
	["Ｇ"] = "ｇ",
	["Ｈ"] = "ｈ",
	["Ｉ"] = "ｉ",
	["Ｊ"] = "ｊ",
	["Ｋ"] = "ｋ",
	["Ｌ"] = "ｌ",
	["Ｍ"] = "ｍ",
	["Ｎ"] = "ｎ",
	["Ｏ"] = "ｏ",
	["Ｐ"] = "ｐ",
	["Ｑ"] = "ｑ",
	["Ｒ"] = "ｒ",
	["Ｓ"] = "ｓ",
	["Ｔ"] = "ｔ",
	["Ｕ"] = "ｕ",
	["Ｖ"] = "ｖ",
	["Ｗ"] = "ｗ",
	["Ｘ"] = "ｘ",
	["Ｙ"] = "ｙ",
	["Ｚ"] = "ｚ",
	["𐐀"] = "𐐨",
	["𐐁"] = "𐐩",
	["𐐂"] = "𐐪",
	["𐐃"] = "𐐫",
	["𐐄"] = "𐐬",
	["𐐅"] = "𐐭",
	["𐐆"] = "𐐮",
	["𐐇"] = "𐐯",
	["𐐈"] = "𐐰",
	["𐐉"] = "𐐱",
	["𐐊"] = "𐐲",
	["𐐋"] = "𐐳",
	["𐐌"] = "𐐴",
	["𐐍"] = "𐐵",
	["𐐎"] = "𐐶",
	["𐐏"] = "𐐷",
	["𐐐"] = "𐐸",
	["𐐑"] = "𐐹",
	["𐐒"] = "𐐺",
	["𐐓"] = "𐐻",
	["𐐔"] = "𐐼",
	["𐐕"] = "𐐽",
	["𐐖"] = "𐐾",
	["𐐗"] = "𐐿",
	["𐐘"] = "𐑀",
	["𐐙"] = "𐑁",
	["𐐚"] = "𐑂",
	["𐐛"] = "𐑃",
	["𐐜"] = "𐑄",
	["𐐝"] = "𐑅",
	["𐐞"] = "𐑆",
	["𐐟"] = "𐑇",
	["𐐠"] = "𐑈",
	["𐐡"] = "𐑉",
	["𐐢"] = "𐑊",
	["𐐣"] = "𐑋",
	["𐐤"] = "𐑌",
	["𐐥"] = "𐑍",
	["𐐦"] = "𐑎",
	["𐐧"] = "𐑏",
}

-- returns the number of bytes used by the UTF-8 character at byte i in s
-- also doubles as a UTF-8 character validator
function utf8.clen (s, i)
	-- argument defaults
	i = i or 1

	local c = s:byte(i)

	-- determine bytes needed for character, based on RFC 3629
	-- validate byte 1
	if c > 0 and c <= 127 then
		-- UTF8-1
		return 1

	elseif c >= 194 and c <= 223 then
		-- UTF8-2
		local c2 = s:byte(i + 1)

		if not c2 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end

		return 2

	elseif c >= 224 and c <= 239 then
		-- UTF8-3
		local c2 = s:byte(i + 1)
		local c3 = s:byte(i + 2)

		if not c2 or not c3 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c == 224 and (c2 < 160 or c2 > 191) then
			error("Invalid UTF-8 character")
		elseif c == 237 and (c2 < 128 or c2 > 159) then
			error("Invalid UTF-8 character")
		elseif c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end

		-- validate byte 3
		if c3 < 128 or c3 > 191 then
			error("Invalid UTF-8 character")
		end

		return 3

	elseif c >= 240 and c <= 244 then
		-- UTF8-4
		local c2 = s:byte(i + 1)
		local c3 = s:byte(i + 2)
		local c4 = s:byte(i + 3)

		if not c2 or not c3 or not c4 then
			error("UTF-8 string terminated early")
		end

		-- validate byte 2
		if c == 240 and (c2 < 144 or c2 > 191) then
			error("Invalid UTF-8 character")
		elseif c == 244 and (c2 < 128 or c2 > 143) then
			error("Invalid UTF-8 character")
		elseif c2 < 128 or c2 > 191 then
			error("Invalid UTF-8 character")
		end
		
		-- validate byte 3
		if c3 < 128 or c3 > 191 then
			error("Invalid UTF-8 character")
		end

		-- validate byte 4
		if c4 < 128 or c4 > 191 then
			error("Invalid UTF-8 character")
		end

		return 4

	else
		error("Invalid UTF-8 character")
	end
end

-- functions identically to string.sub except that i and j are UTF-8 characters
-- instead of bytes
function utf8.sub (s, i, j)
	-- argument defaults
	j = j or -1

	local pos = 1
	local bytes = s:len()
	local len = 0

	-- only set l if i or j is negative
	local l = (i >= 0 and j >= 0) or utf8.len(s)
	local startChar = (i >= 0) and i or l + i + 1
	local endChar   = (j >= 0) and j or l + j + 1

	-- can't have start before end!
	if startChar > endChar then
		return ""
	end

	-- byte offsets to pass to string.sub
	local startByte,endByte = 1,bytes
	
	while pos <= bytes do
		len = len + 1

		if len == startChar then
			startByte = pos
		end

		pos = pos + utf8.clen(s, pos)

		if len == endChar then
			endByte = pos - 1
			break
		end
	end
	
	if startChar > len then startByte = bytes+1   end
	if endChar   < 1   then endByte   = 0         end
	
	return s:sub(startByte, endByte)
end


-- replace UTF-8 characters based on a mapping table
function utf8.replace (s, mapping)
	-- argument checking

	local pos = 1
	local bytes = s:len()
	local clen
	local newstr = ""

	while pos <= bytes do
		clen = utf8.clen(s, pos)
		local c = s:sub(pos, pos + clen - 1)

		newstr = newstr .. (mapping[c] or c)

		pos = pos + clen
	end

	return newstr
end


-- identical to string.upper except it knows about unicode simple case conversions
function utf8.upper (s)
	return utf8.replace(s, utf8_lc_uc)
end

-- identical to string.lower except it knows about unicode simple case conversions
function utf8.lower (s)
	return utf8.replace(s, utf8_uc_lc)
end

-- identical to string.reverse except that it supports UTF-8
function utf8.reverse (s)
	-- argument checking

	local bytes = s:len()
	local pos = bytes
	local clen
	local newstr = ""

	while pos > 0 do
		c = s:byte(pos)
		while c >= 128 and c <= 191 do
			pos = pos - 1
			c = s:byte(pos)
		end

		clen = utf8.clen(s, pos)

		newstr = newstr .. s:sub(pos, pos + clen - 1)

		pos = pos - 1
	end

	return newstr
end

-- http://en.wikipedia.org/wiki/Utf8
-- http://developer.coronalabs.com/code/utf-8-conversion-utility
function utf8.uchar(unicode)
	if unicode <= 0x7F then return string.char(unicode) end
	
	if (unicode <= 0x7FF) then
		local Byte0 = 0xC0 + math.floor(unicode / 0x40);
		local Byte1 = 0x80 + (unicode % 0x40);
		return string.char(Byte0, Byte1);
	end;
	
	if (unicode <= 0xFFFF) then
		local Byte0 = 0xE0 +  math.floor(unicode / 0x1000);
		local Byte1 = 0x80 + (math.floor(unicode / 0x40) % 0x40);
		local Byte2 = 0x80 + (unicode % 0x40);
		return string.char(Byte0, Byte1, Byte2);
	end;
	
	if (unicode <= 0x10FFFF) then
		local code = unicode
		local Byte3= 0x80 + (code % 0x40);
		code       = math.floor(code / 0x40)
		local Byte2= 0x80 + (code % 0x40);
		code       = math.floor(code / 0x40)
		local Byte1= 0x80 + (code % 0x40);
		code       = math.floor(code / 0x40)  
		local Byte0= 0xF0 + code;
		
		return string.char(Byte0, Byte1, Byte2, Byte3);
	end;
	
	error('Unicode cannot be greater than U+10FFFF!')
end

local shift_6  = 2^6
local shift_12 = 2^12
local shift_18 = 2^18

function utf8.unicode (str, i, j, byte_pos)
	i = i or 1
	j = j or i
	
	if i > j then return end
	
	local char,bytes
	
	if byte_pos then 
		bytes = utf8.clen(str,byte_pos)
		char  = str:sub(byte_pos,byte_pos-1+bytes)
	else
		char,byte_pos = utf8.sub(str,i,i)
		bytes         = #char
	end
	
	local unicode
	
	if bytes == 1 then unicode = string.byte(char) end
	if bytes == 2 then
		local byte0,byte1 = string.byte(char,1,2)
		local code0,code1 = byte0-0xC0,byte1-0x80
		unicode = code0*shift_6 + code1
	end
	if bytes == 3 then
		local byte0,byte1,byte2 = string.byte(char,1,3)
		local code0,code1,code2 = byte0-0xE0,byte1-0x80,byte2-0x80
		unicode = code0*shift_12 + code1*shift_6 + code2
	end
	if bytes == 4 then
		local byte0,byte1,byte2,byte3 = string.byte(char,1,4)
		local code0,code1,code2,code3 = byte0-0xF0,byte1-0x80,byte2-0x80,byte3-0x80
		unicode = code0*shift_18 + code1*shift_12 + code2*shift_6 + code3
	end
	
	return unicode,utf8.unicode(str, i+1, j, byte_pos+bytes)
end

-- Returns an iterator which returns the next substring and its byte interval
function utf8.gensub(str, sub_len)
	sub_len        = sub_len or 1
	local byte_pos = 1
	local len      = #str
	return function()
		local char_count = 0
		local start      = byte_pos
		repeat
			if byte_pos > len then return end
			char_count  = char_count + 1
			local bytes = utf8.clen(str,byte_pos)
			byte_pos    = byte_pos+bytes
			
		until char_count == sub_len
		
		local last  = byte_pos-1
		local sub   = str:sub(start,last)
		return sub, start, last
	end
end

string.utf8len       = utf8.len
string.utf8sub       = utf8.sub
string.utf8reverse   = utf8.reverse
string.utf8char      = utf8.char
string.utf8unicode   = utf8.unicode
string.utf8gensub    = utf8.gensub
string.utf8upper	= utf8.upper
string.utf8lower	 = utf8.lower
--PATH gamemodes/darkrp/gamemode/core/font_cl.lua:

local surface = surface
local math = math
local sc = surface.CreateFont

local Fonts = {}

Fonts[ "Roboto" ] = "Roboto Light"
Fonts[ "RobotoM" ] = "Roboto Medium"
Fonts['RobotoR'] = 'Roboto Regular'



for a,b in pairs( Fonts ) do
    for k = 0, 500 do
        sc( a.."_"..k, { font = b, size = k, weight = 300, antialias = true, extended = true } )
    end
end

local Shadow = {}

Shadow['RobotoRS'] = 'Roboto Regular'

for a,b in pairs( Shadow ) do
    for k = 0, 150 do
        sc( a.."_"..k, { font = b, size = k, weight = 300, antialias = true, extended = true, blursize=5} )
    end
end

local d_s = draw.SimpleText

function draw.ShadowText(text,font,x,y,color,a,b)
    rp.ShadowText(text,font,x,y,color,a,b)
end

function rp.ShadowText(text,font_size,x,y,color,a,b)
    a = a or 0.5
    b = b or 0.5

    if font_size:find("DonateM_") then
        font_size = font_size:gsub("DonateM_", "")
        font_size = ScreenScale(tonumber(font_size))
    elseif font_size:find("RobotoL_") then
        font_size = font_size:gsub("RobotoL_", "")
    elseif font_size:find("RobotoM_") then
        font_size = font_size:gsub("RobotoM_", "")
    elseif font_size:find("RobotoR_") then
        font_size = font_size:gsub("RobotoR_", "")
    elseif font_size:find("Roboto_") then
        font_size = font_size:gsub("Roboto_", "")
    else
        font_size = 24
    end

    draw.BeautyText(text, "RobotoR_" .. math.ceil(font_size), "RobotoRS_" .. math.ceil(font_size), x, y, color, a * 0.5, b * 0.5)
end

local function charWrap(text, pxWidth, maxWidth)
    local total = 0

    text = text:gsub(utf8.charpattern, function(char)
        total = total + surface.GetTextSize(char)

        -- Wrap around when the max width is reached
        if total >= pxWidth then
            total = 0
            pxWidth = maxWidth
            return "\n" .. char
        end

        return char
    end)

    return text, total
end

function surface.textWrap(text, font, pxWidth)
    local total = 0

    surface.SetFont(font)

    local spaceSize = surface.GetTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
            local char = string.sub(word, 1, 1)
            if char == "\n" or char == "\t" then
                total = 0
            end

            local wordlen = surface.GetTextSize(word)
            total = total + wordlen

            -- Wrap around when the max width is reached
            if wordlen >= pxWidth then -- Split the word if the word is too big
                local splitWord, splitPoint = charWrap(word, pxWidth - (total - wordlen), pxWidth)
                total = splitPoint
                return splitWord
            elseif total < pxWidth then
                return word
            end

            -- Split before the word
            if char == ' ' then
                total = wordlen - spaceSize
                return '\n' .. string.sub(word, 2)
            end

            total = wordlen
            return '\n' .. word
        end)

    return text
end


ALIGN_LEFT = 0
ALIGN_CENTER = 0.5
ALIGN_RIGHT = 1
ALIGN_TOP = 1
ALIGN_BOTTOM = 0

local shadow_x = 1
local shadow_y = 1

local col_face = Color(255,255,255,255)
local col_shadow = Color(0,0,0,255)
local col_half_shadow = Color(0,0,0,200)
local col_money = Color(64,192,32)

function draw.BeautyText(str, font, font_shadow, x, y, color, xalign, yalign)
	font = font or "nx_hud"
	str = str or " "
	surface.SetFont( font )

	local tw, th = surface.GetTextSize( str )
	x = (x or 0) - tw * (xalign or 3)
	y = (y or 0) - th * (yalign or 3)
	surface.SetTextPos( x, y )

	-- soft shadow
	if font_shadow then
		surface.SetTextPos( x, y+3 )
		surface.SetTextColor( col_shadow )
		surface.SetFont( font_shadow )
		surface.DrawText( str )
		surface.SetTextPos( x, y )
	end
	-- sharp shadow
	surface.SetTextPos( x + shadow_x , y + shadow_y )
	surface.SetTextColor( col_half_shadow )
	surface.SetFont( font )
	surface.DrawText( str )

	-- text itself
	surface.SetTextColor( color or col_face )
	surface.SetTextPos( x, y )
	surface.DrawText( str )

	return tw, th
end


//surface.CreateFont('scrFont2',{font='Roboto Regular',size=18,weight=300,extended=true,antialias=true})//surface.CreateFont("scrFont2_shadow",{font="Roboto Regular",extended=true,antialias=true,weight=300,blursize=3,size=18})

--PATH gamemodes/darkrp/gamemode/core/binds/_binds_cl.lua:
if rp.Binds then return end
local Buttons = {}
local Identifiers = {}
local BIND = {}
BIND.__index = BIND
do
	BIND_TOGGLE = 0
	BIND_RELEASE = 1
	BIND_HOLD = 2
end

AccessorFunc( BIND, "m_ID", "ID" )
AccessorFunc( BIND, "m_Type", "Type" )
AccessorFunc( BIND, "m_Button", "Button" )
AccessorFunc( BIND, "m_Enabled", "Enabled" )
function BIND:__tostring()
	return string.format( "Bind: %p", self )
end

function BIND:OnChanged()
	-- for override
end

function BIND:SetButton( button )
	Buttons[button] = Buttons[button] or {}
	if self.m_Button then
		local i = Identifiers[self.m_ID][1]
		table.remove( Buttons[self.m_Button], i )
	end

	local i = #Buttons[button] + 1
	Buttons[button][i] = self
	Identifiers[self.m_ID] = { i, self }
	self.m_Button = button
end

function BIND:SetEnabled( enabled )
	if self.m_Enabled ~= enabled then self:OnChanged( enabled ) end
	self.m_Enabled = enabled
end

function BIND:CheckEnabled( down )
	local t = self.m_Type
	if t == BIND_HOLD then
		self:SetEnabled( down )
	elseif t == BIND_RELEASE then
		self:SetEnabled( not down )
	elseif down then
		self:SetEnabled( not self.m_Enabled )
	end
end

local function GetChecker( is_down )
	return function( _, button )
		if not IsFirstTimePredicted() then return end
		local binds = Buttons[button]
		if not binds then return end
		local i, bind = 0
		local limit = #binds
		:: LOOP ::
		do
			i = i + 1
			bind = binds[i]
			bind:CheckEnabled( is_down )
			if i ~= limit then goto LOOP end
		end
	end
end

hook.Add( "PlayerButtonDown", "Binds.CheckDown", GetChecker( true ) )
hook.Add( "PlayerButtonUp", "Binds.CheckRelease", GetChecker( false ) )
local function Remove( id )
	if id == nil then return false end
	local info = Identifiers[id]
	if not info then return false end
	local i, bind = info[1], info[2]
	local button = bind.m_Button
	Identifiers[id] = nil
	table.remove( Buttons[button], i )
	if #Buttons[button] == 0 then Buttons[button] = nil end
	setmetatable( bind, nil )
	return true
end

local function Add( id, btn, type, callback )
	if id == nil then return false end
	if Identifiers[id] then Remove( id ) end
	local bind = setmetatable( {}, BIND )
	bind:SetID( id )
	bind:SetButton( tonumber( btn ) or KEY_NONE )
	bind:SetType( tonumber( type ) or TYPE_TOGGLE )
	if isfunction( callback ) then bind.OnChanged = callback end
	return bind
end

local function Rebind( id, new_btn, new_type )
	if id == nil then return false end
	local info = Identifiers[id]
	if not info then return false end
	local bind = info[2]
	bind:SetButton( tonumber( new_btn ) or bind.m_Button or KEY_NONE )
	bind:SetType( tonumber( new_type ) or bind.m_Type or BIND_TOGGLE )
	return true
end

local function GetTable()
	return Buttons, Identifiers
end

local function Conflicts()
	local conflicts = {}
	for button, binds in pairs( Buttons ) do
		if binds[2] then conflicts[button] = binds end
	end
	return conflicts
end

rp.Binds = {
	Add = Add,
	Rebind = Rebind,
	Remove = Remove,
	GetTable = GetTable,
	Conflicts = Conflicts,
}
--PATH gamemodes/darkrp/gamemode/core/chat/__chat_object_sh.lua:
local isString = isstring
local isFunction = isfunction
local isTable = istable
local isBool = isbool
local tableCopy = table.Copy
do
    chatCommand = {}
    chatCommand.__index = chatCommand
    -- Const
    local ERROR_UNVALID_NAME = "Command name is unvalid"
    local ERROR_UNVALID_OPTIONS = "Command options are unvalid"
    local COMMAND_TARGET_SINGLE = "local"
    local COMMAND_TARGET_ALL = "all"
    local OPTION_WHITELIST = "whitelist"
    local OPTION_WHITELIST_USERGROUP = "usergroup"
    local OPTION_WHITELIST_STEAMID = "steamid"
    local OPTION_WHITELIST_STEAMID64 = "steamid64"
    local OPTION_WHITELIST_TEAM = "team"
    local OPTION_PREFIX = "prefix"
    local OPTION_EXECUTE = "execute"
    local OPTION_PLAYER = "player"
    local OPTION_SHOWCOMMAND = "showCommand"
    local OPTION_PREEXECUTE = "preExecute"
    local OPTION_POSTEXECUTE = "postExecute"
    local OPTION_ONDELETE = "onDelete"
    local function isValidCommandName( toValid )
        if toValid == nil or not isString( toValid ) then return false end
        if toValid == '' then return false end
        return true
    end

    local function isValidCommandOptions( toValid )
        if toValid == nil or not isTable( toValid ) then return false end
        -- Essential options
        if toValid[OPTION_PREFIX] == nil or not isTable( toValid[OPTION_PREFIX] ) then return false end
        if #toValid[OPTION_PREFIX] == 0 then return false end
        for _, prefix in ipairs( toValid[OPTION_PREFIX] ) do
            if #prefix ~= 1 then return false end
        end

        if toValid[OPTION_EXECUTE] == nil or not isFunction( toValid[OPTION_EXECUTE] ) then return false end
        if CLIENT then
            if toValid[OPTION_PLAYER] == nil or not isString( toValid[OPTION_PLAYER] ) then return false end
            if toValid[OPTION_PLAYER] ~= COMMAND_TARGET_SINGLE and toValid[OPTION_PLAYER] ~= COMMAND_TARGET_ALL then return false end
        end

        if toValid[OPTION_SHOWCOMMAND] == nil or not isBool( toValid[OPTION_SHOWCOMMAND] ) then return false end
        return true
    end

    -- Constructor of chatCommand class
    --
    --  @param String name The command name
    --  @param Array options The different options of the command
    --
    --  @return chatCommand
    function chatCommand:new( name, options )
        if not isValidCommandName( name ) then
            error( ERROR_UNVALID_NAME )
            return
        end

        if not isValidCommandOptions( options ) then
            error( ERROR_UNVALID_OPTIONS )
            return
        end

        if not options[OPTION_WHITELIST] or not isTable( options[OPTION_WHITELIST] ) then
            options[OPTION_WHITELIST] = {
                [OPTION_WHITELIST_USERGROUP] = {},
                [OPTION_WHITELIST_STEAMID] = {},
                [OPTION_WHITELIST_STEAMID64] = {},
                [OPTION_WHITELIST_TEAM] = {}
            }
        end

        local command = {
            name = name,
            options = options
        }

        setmetatable( command, chatCommand )
        return command
    end

    -- Pre execute command function
    --
    -- @param Player The requester of the command
    --
    -- @return ? Variables returned by the configurated function
    function chatCommand:preExecute( requester, commandOptions )
        local base = function() end
        local preExecute = function()
            base()
            if self.options[OPTION_PREEXECUTE] and isFunction( self.options[OPTION_PREEXECUTE] ) then
                return self.options[OPTION_PREEXECUTE]( requester, commandOptions )
            else
                return nil
            end
        end
        return preExecute()
    end

    -- Execute command function
    --
    -- @param Player The requester of the command
    -- @param Array Words wrote right after the command name
    function chatCommand:execute( requester, commandOptions )
        local preExecute = { self:preExecute( requester, commandOptions ) }
        local execute = self.options[OPTION_EXECUTE]
        local base = function()
            if CLIENT and self:getScope() == COMMAND_TARGET_SINGLE and requester ~= LocalPlayer() then return end
            execute( requester, commandOptions, preExecute )
        end

        base()
        self:postExecute( requester, commandOptions )
    end

    -- Post Execute command function
    --
    -- @param Player The requester of the command
    -- @param Array Words wrote right after the command name
    function chatCommand:postExecute( requester, commandOptions )
        local base = function() end
        local postExecute = function()
            base()
            if self.options[OPTION_POSTEXECUTE] and isFunction( self.options[OPTION_POSTEXECUTE] ) then
                return self.options[OPTION_POSTEXECUTE]( requester, commandOptions )
            else
                return nil
            end
        end

        postExecute()
    end

    function chatCommand:OnDelete()
        local customDelete = self:getOnDelete()
        customDelete()
    end

    -- Getters
    function chatCommand:getName()
        return self.name
    end

    function chatCommand:getOptions()
        return tableCopy( self.options )
    end

    function chatCommand:getPrefix()
        return self:getOptions()[OPTION_PREFIX]
    end

    function chatCommand:getRestricted()
        return tableCopy( self:getOptions()[OPTION_WHITELIST] )
    end

    function chatCommand:getShowMessage()
        return self:getOptions()[OPTION_SHOWCOMMAND]
    end

    function chatCommand:getOnDelete()
        local onDelete = function() end
        local customOnDelete = self:getOptions()[OPTION_ONDELETE]
        if customOnDelete and isFunction( customOnDelete ) then onDelete = customOnDelete end
        return onDelete
    end

    if CLIENT then
        function chatCommand:getScope()
            return self:getOptions()[OPTION_PLAYER]
        end
    end

    setmetatable( chatCommand, {
        __call = chatCommand.new
    } )
end
--PATH gamemodes/darkrp/gamemode/core/chat/chat_commands_sh.lua:
rp.Chat = rp.Chat or {}
rp.Chat.Commands = {}
--
commandsLib.parseRP = '<clr:white><bg_col:0,128,0> RP <bg_col:none> '
commandsLib.parseNONRP = '<clr:white><bg_col:178,34,34> NONRP <bg_col:none> '
--
function commandsLib.preChat( _, options )
    local text = ''
    for _, u in ipairs( options ) do
        if text:len() == 0 then
            text = u
            continue
        end

        text = text .. ' ' .. u
    end
    return text
end

function commandsLib.check_preChat( _, options )
    if not options then return false end
    return commandsLib.preChat( nil, options )
end

function commandsLib.check_text( text )
    if not text or #text < 1 then return false end
    local check = string.Trim( text )
    --
    if check:len() > 0 then return true end
    --
    return false
end

function commandsLib.parseText( requester, text, ... )
    local tags = echat:FinalParse( ... )
    local parsed_tags = echat:ParseText( tags )
    local parsed_message = echat:ParseText( text, requester )
    local result = table.Add( parsed_tags, parsed_message )
    --
    return result
end

local tbl_jobs = {
    ['Mayor'] = TEAM_MAYOR
}

local function createCommand( tbl, isClient )
    for _, v in ipairs( tbl ) do
        local tbl_command = {
            prefix = { '/' },
            execute = v.execute,
            showCommand = false
        }

        if isClient and CLIENT or not isClient and SERVER then
            if isClient then tbl_command.player = 'local' end
            if v.jobs then
                tbl_command.whitelist = {
                    usergroup = {},
                    steamid = {},
                    steamid64 = {},
                    team = {}
                }

                for _, job in ipairs( v.jobs ) do
                    tbl_command.whitelist.team[#tbl_command.whitelist.team + 1] = tbl_jobs[job]
                end
            end

            if v.checkchat then tbl_command.preExecute = commandsLib.check_preChat end
            if v.preexecute then tbl_command.preExecute = v.preexecute end
        end

        for _, name in ipairs( v.name ) do
            if isClient and CLIENT or not isClient and SERVER then commandsLib.register( name, tbl_command ) end
            --
            rp.Chat.Commands[#rp.Chat.Commands + 1] = {
                command = name,
                description = v.description,
                check = v.checkShow
            }
        end
    end
end

createCommand( rp.Setting.Commands.Client, true )
createCommand( rp.Setting.Commands.Server, false )
-- if CLIENT then
--     for _, v in ipairs( rp.Setting.Commands.Client ) do
--         local tbl_command = {
--             prefix = { '/' },
--             execute = v.execute,
--             player = 'local',
--             showCommand = false
--         }
--         if v.jobs then
--             tbl_command.whitelist = {
--                 usergroup = {},
--                 steamid = {},
--                 steamid64 = {},
--                 team = {}
--             }
--             for _, job in ipairs( v.jobs ) do
--                 tbl_command.whitelist.team[#tbl_command.whitelist.team + 1] = tbl_jobs[job]
--             end
--         end
--         if v.checkchat then tbl_command.preExecute = check_preChat end
--         --
--         commandsLib.register( v.name, tbl_command )
--         --
--         rp.Chat.Commands[#rp.Chat.Commands + 1] = {
--             command = v.name,
--             description = v.description,
--             check = v.checkShow
--         }
--     end
-- else
--     for _, v in ipairs( rp.Setting.Commands.Server ) do
--         local tbl_command = {
--             prefix = { '/' },
--             execute = v.execute,
--             showCommand = false
--         }
--         if v.jobs then
--             tbl_command.whitelist = {
--                 usergroup = {},
--                 steamid = {},
--                 steamid64 = {},
--                 team = {}
--             }
--             for _, job in ipairs( v.jobs ) do
--                 tbl_command.whitelist.team[#tbl_command.whitelist.team + 1] = tbl_jobs[job]
--             end
--         end
--         if v.checkchat then tbl_command.preExecute = check_preChat end
--         if v.preexecute then tbl_command.preExecute = v.preexecute end
--         --
--         for _, name in ipairs( v.name ) do
--             commandsLib.register( name, tbl_command )
--             --
--             rp.Chat.Commands[#rp.Chat.Commands + 1] = {
--                 command = name,
--                 description = v.description,
--                 check = v.checkShow
--             }
--         end
--     end
-- end
-- if CLIENT then
--     commandsLib.register( 'job', {
--         prefix = { '/' },
--         preExecute = check_preChat,
--         execute = function( _, _, preExecute ) RunConsoleCommand( 'job_name', preExecute[1] ) end,
--         player = 'local',
--         showCommand = false
--     } )
--     commandsLib.register( 'name', {
--         prefix = { '/' },
--         preExecute = check_preChat,
--         execute = function( _, _, preExecute ) RunConsoleCommand( 'rpname', preExecute[1] ) end,
--         player = 'local',
--         showCommand = false
--     } )
--     commandsLib.register( 'sell', {
--         prefix = { '/' },
--         execute = function() RunConsoleCommand( 'sell' ) end,
--         player = 'local',
--         showCommand = false
--     } )
--     commandsLib.register( 'sellall', {
--         prefix = { '/' },
--         execute = function() RunConsoleCommand( 'sellall' ) end,
--         player = 'local',
--         showCommand = false
--     } )
--     commandsLib.register( 'dropmoney', {
--         prefix = { '/' },
--         execute = function( _, options )
--             if not options[1] then return end
--             RunConsoleCommand( 'dropmoney', options[1] )
--         end,
--         player = 'local',
--         showCommand = false
--     } )
--     commandsLib.register( 'givemoney', {
--         prefix = { '/' },
--         execute = function( _, options )
--             if not options[1] then return end
--             RunConsoleCommand( 'givemoney', options[1] )
--         end,
--         player = 'local',
--         showCommand = false
--     } )
--     commandsLib.register( 'drop', {
--         prefix = { '/' },
--         execute = function() RunConsoleCommand( 'drop' ) end,
--         player = 'local',
--         showCommand = false
--     } )
--     commandsLib.register( 'wanted', {
--         prefix = { '/' },
--         execute = function( _, options )
--             if not options[1] or not options[2] then return end
--             RunConsoleCommand( 'Wanted', options[1], options[2] )
--         end,
--         player = 'local',
--         showCommand = false
--     } )
--     commandsLib.register( 'unwanted', {
--         prefix = { '/' },
--         execute = function( _, options )
--             if not options[1] then return end
--             RunConsoleCommand( 'UnWanted', options[1] )
--         end,
--         player = 'local',
--         showCommand = false
--     } )
-- else
--     do
--         local function OOC( requester, _, preExecute )
--             if not preExecute or not check_text( preExecute[1] ) then return end
--             hook.Call( 'playerOOC', nil, requester, preExecute[1] )
--             local result = parseText( requester, preExecute[1], parseNONRP, '<clr:white><bg_col:0,150,0> OOC <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ': ' )
--             --
--             echat:SendParsedMessageToPlayer( requester, player.GetAll(), result, preExecute[1] )
--         end
--         commandsLib.register( 'ooc', {
--             prefix = { '/' },
--             preExecute = check_preChat,
--             execute = OOC,
--             showCommand = false
--         } )
--         commandsLib.register( '/', {
--             prefix = { '/' },
--             preExecute = check_preChat,
--             execute = OOC,
--             showCommand = false
--         } )
--     end
--     do
--         local function preAdvert( requester, options )
--             if not options or not rp.Team[requester:Team()] then return false end
--             --
--             local noadvert = rp.Team[requester:Team()].noAdvert
--             local unlimitadvert = rp.Team[requester:Team()].unlimitAdvert or false
--             --
--             if noadvert then return rp.Notify( requester, NOTIFY_ERROR, 'Ви не можете використовувати оголошення.', '' ) end
--             if not unlimitadvert then
--                 requester.timeadvert = requester.timeadvert or 0
--                 if requester.timeadvert > CurTime() then
--                     rp.Notify( requester, NOTIFY_ERROR, string.format( 'Зачекайте %s секунд перед наступним оголошенням.', math.Round( requester.timeadvert - CurTime() ) ), '' )
--                     return ''
--                 end
--             end
--             return preChat( nil, options )
--         end
--         local function Advert( requester, _, preExecute )
--             if not preExecute or preExecute[1] == '' or not check_text( preExecute[1] ) then return end
--             hook.Call( 'playerAdverted', nil, requester, preExecute[1] )
--             local result = parseText( requester, preExecute[1], parseRP, '<clr:white><bg_col:200,200,0> Оголошення <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ': ' )
--             --
--             echat:SendParsedMessageToPlayer( requester, player.GetAll(), result, preExecute[1] )
--             --
--             requester.timeadvert = CurTime() + 120
--         end
--         commandsLib.register( 'advert', {
--             prefix = { '/' },
--             preExecute = preAdvert,
--             execute = Advert,
--             showCommand = false
--         } )
--         commandsLib.register( 'ad', {
--             prefix = { '/' },
--             preExecute = preAdvert,
--             execute = Advert,
--             showCommand = false
--         } )
--     end
--     do
--         local function Me( requester, _, preExecute )
--             if not preExecute or not check_text( preExecute[1] ) then return end
--             hook.Call( 'playerMeeeee', nil, requester, preExecute[1] )
--             local result = parseText( requester, preExecute[1], parseRP, '<clr:white><bg_col:200,200,0> Дія <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ' виконати дію: <clr:orange>' )
--             --
--             echat:SendParsedMessageToPlayer( requester, ents.FindInSphere( requester:GetPos(), rp.Setting.ChatRadius ), result, preExecute[1] )
--         end
--         commandsLib.register( 'me', {
--             prefix = { '/' },
--             preExecute = check_preChat,
--             execute = Me,
--             showCommand = false
--         } )
--     end
--     do
--         local function Do( requester, _, preExecute )
--             if not preExecute or not check_text( preExecute[1] ) then return end
--             hook.Call( 'playerDooooo', nil, requester, preExecute[1] )
--             local result = parseText( requester, preExecute[1], parseRP, '<clr:white><bg_col:200,100,0> Do <bg_col:none> ', color_white, ' (', team.GetColor( requester:Team() ), requester, color_white, ') ', ' <clr:gold>' )
--             --
--             echat:SendParsedMessageToPlayer( requester, ents.FindInSphere( requester:GetPos(), rp.Setting.ChatRadius ), result, preExecute[1] )
--         end
--         commandsLib.register( 'do', {
--             prefix = { '/' },
--             preExecute = check_preChat,
--             execute = Do,
--             showCommand = false
--         } )
--     end
--     do
--         local function Yell( requester, _, preExecute )
--             if not preExecute or not check_text( preExecute[1] ) then return end
--             hook.Call( 'playerCrick', nil, requester, preExecute[1] )
--             local result = parseText( requester, preExecute[1], parseRP, '<clr:white><bg_col:255,165,0> Кричати <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ': ' )
--             --
--             echat:SendParsedMessageToPlayer( requester, ents.FindInSphere( requester:GetPos(), rp.Setting.ChatRadius + 150 ), result, preExecute[1] )
--         end
--         commandsLib.register( 'y', {
--             prefix = { '/' },
--             preExecute = check_preChat,
--             execute = Yell,
--             showCommand = false
--         } )
--     end
--     do
--         local function Whisper( requester, _, preExecute )
--             if not preExecute or not check_text( preExecute[1] ) then return end
--             hook.Call( 'playerCrick', nil, requester, preExecute[1] )
--             local result = parseText( requester, preExecute[1], parseRP, '<clr:white><bg_col:107,142,35> Шепіт <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ': ' )
--             --
--             echat:SendParsedMessageToPlayer( requester, ents.FindInSphere( requester:GetPos(), rp.Setting.ChatRadius - 250 ), result, preExecute[1] )
--         end
--         commandsLib.register( 'w', {
--             prefix = { '/' },
--             preExecute = check_preChat,
--             execute = Whisper,
--             showCommand = false
--         } )
--     end
--     do
--         local function BroadCast( requester, _, preExecute )
--             if not preExecute or not check_text( preExecute[1] ) then return end
--             local result = parseText( requester, preExecute[1], parseRP, '<clr:white><bg_col:150,0,0> Оголошення від Мера <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ': ' )
--             --
--             echat:SendParsedMessageToPlayer( requester, player.GetAll(), result, preExecute[1] )
--         end
--         commandsLib.register( 'broadcast', {
--             prefix = { '/' },
--             whitelist = {
--                 usergroup = {},
--                 steamid = {},
--                 steamid64 = {},
--                 team = {
--                     [TEAM_MAYOR] = true
--                 }
--             },
--             preExecute = check_preChat,
--             execute = BroadCast,
--             showCommand = false
--         } )
--     end
--     do
--         local function preRoll()
--             return math.random( 1, 100 )
--         end
--         local function Roll( requester, _, preExecute )
--             if not preExecute then return end
--             local result = parseText( requester, '', parseRP, '<clr:white><bg_col:200,200,0> Кістки <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ' кинув кістки і кількість впав <clr:red>', preExecute[1] )
--             --
--             echat:SendParsedMessageToPlayer( requester, ents.FindInSphere( requester:GetPos(), rp.Setting.ChatRadius ), result, '' )
--         end
--         commandsLib.register( 'roll', {
--             prefix = { '/' },
--             preExecute = preRoll,
--             execute = Roll,
--             showCommand = false
--         } )
--     end
--     commandsLib.register( 'lottery', {
--         prefix = { '/' },
--         whitelist = {
--             usergroup = {},
--             steamid = {},
--             steamid64 = {},
--             team = {
--                 [TEAM_MAYOR] = true
--             }
--         },
--         execute = function( _, options )
--             if not options[1] then return end
--             RunConsoleCommand( 'lottery', options[1] )
--         end,
--         showCommand = false
--     } )
-- end
-- rp.Chat.Commands = {
--     {
--         command = 'ooc',
--         description = 'Глобальний чат'
--     },
--     {
--         command = '/',
--         description = 'Глобальний чат'
--     },
--     {
--         command = 'advert',
--         description = 'Оголошення'
--     },
--     {
--         command = 'ad',
--         description = 'Оголошення'
--     },
--     {
--         command = 'job',
--         description = 'Змінити назву професії'
--     },
--     {
--         command = 'name',
--         description = 'Змінити ім\'я'
--     },
--     {
--         command = 'me',
--         description = 'Провести дію'
--     },
--     {
--         command = 'do',
--         description = 'Підтвердження дії'
--     },
--     {
--         command = 'y',
--         description = 'Крик'
--     },
--     {
--         command = 'w',
--         description = 'Шепіт'
--     },
--     {
--         command = 'broadcast',
--         description = 'Оголошення від Мера'
--     },
--     {
--         command = 'sell',
--         description = 'Продати предмет навпроти'
--     },
--     {
--         command = 'sellall',
--         description = 'Продати всі предмети'
--     },
--     {
--         command = 'dropmoney',
--         description = 'Викинути гроші'
--     },
--     {
--         command = 'givemoney',
--         description = 'Передати гроші'
--     },
--     {
--         command = 'drop',
--         description = 'Викинути предмет із рук'
--     },
--     {
--         command = 'roll',
--         description = 'Випадкове число від 1 до 100'
--     }
-- }
--PATH gamemodes/darkrp/gamemode/core/player/hitman/init_sh.lua:
nw.Register( 'Hitman_Table' ):Write( net.WriteTable ):Read( net.ReadTable ):SetGlobal()
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu_cl.lua:
--[[---------------------------------------------------------
	If false is returned then the spawn menu is never created.
	This saves load times if your mod doesn't actually use the
	spawn menu for any reason.
-----------------------------------------------------------]]
function GM:SpawnMenuEnabled()
	return true
end

--[[---------------------------------------------------------
  Called when spawnmenu is trying to be opened.
   Return false to dissallow it.
-----------------------------------------------------------]]
function GM:SpawnMenuOpen()
	return true
end

--[[---------------------------------------------------------
  Called when context menu is trying to be opened.
   Return false to dissallow it.
-----------------------------------------------------------]]
function GM:ContextMenuOpen()
	return true
end


--[[---------------------------------------------------------
  Backwards compatibility. Do Not Use!!!
-----------------------------------------------------------]]
function GM:GetSpawnmenuTools(name)
	return spawnmenu.GetToolMenu(name)
end


--[[---------------------------------------------------------
  Backwards compatibility. Do Not Use!!!
-----------------------------------------------------------]]
function GM:AddSTOOL(category, itemname, text, command, controls, cpanelfunction)
	self:AddToolmenuOption('Main', category, itemname, text, command, controls, cpanelfunction)
end


--[[---------------------------------------------------------
	Don't hook or override this function.
	Hook AddToolMenuTabs instead!
-----------------------------------------------------------]]
function GM:AddGamemodeToolMenuTabs( )

	-- This is named like this to force it to be the first tab
	spawnmenu.AddToolTab('Main', 		'#spawnmenu.tools_tab', 'icon16/wrench.png')
//	spawnmenu.AddToolTab('Utilities', 	'#spawnmenu.utilities_tab', 'icon16/page_white_wrench.png')

end

--[[---------------------------------------------------------
	Add your custom tabs here.
-----------------------------------------------------------]]
function GM:AddToolMenuTabs()

	-- Hook me!

end

--[[---------------------------------------------------------
	Add categories to your tabs
-----------------------------------------------------------]]
function GM:AddGamemodeToolMenuCategories()
	spawnmenu.AddToolCategory('Main', 	'Constraints', 	'#spawnmenu.tools.constraints')
	spawnmenu.AddToolCategory('Main', 	'Construction', '#spawnmenu.tools.construction')
	spawnmenu.AddToolCategory('Main', 	'Render', 		'#spawnmenu.tools.render')
	spawnmenu.AddToolCategory('Main', 	'Roleplay',		'Roleplay')
	spawnmenu.AddToolCategory('Main', 	'Staff', 		'Staff')
end


--[[---------------------------------------------------------
	Add categories to your tabs
-----------------------------------------------------------]]
function GM:AddToolMenuCategories()

	-- Hook this function to add custom stuff

end

--[[---------------------------------------------------------
	Add categories to your tabs
-----------------------------------------------------------]]
function GM:PopulatePropMenu()

	-- This function makes the engine load the spawn menu text files.
	-- We call it here so that any gamemodes not using the default
	-- spawn menu can totally not call it.
	spawnmenu.PopulateFromEngineTextFiles()

end



--[[

	All of this model search stuff is due for an update to speed it up
	So don't rely on any of this code still being here.

--]]

local ModelIndex = {}
local ModelIndexTimer = CurTime()

local function BuildModelIndex(dir)

	-- Add models from this folder
	local files = file.Find(dir .. '*', 'GAME')
	for k, v in ipairs(files) do

		if (v:sub(-4, -1) == '.mdl') then

			-- Filter out some of the un-usable crap
			if (!v:find('_gestures') &&
				!v:find('_anim') &&
				!v:find('_gst') &&
				!v:find('_pst') &&
				!v:find('_shd') &&
				!v:find('_ss') &&
				!v:find('cs_fix') &&
				!v:find('_anm' )) then

				table.insert(ModelIndex, (dir .. v):lower())

			end

		elseif (v:sub(-4, -4) != '.') then

			--BuildModelIndex(dir..v..'/')

			-- Stagger the loading so we don't block.
			-- This means that the data is inconsistent at first
			-- but it's better than adding 5 seconds onto loadtime
			-- or pausing for 5 seconds on the first search
			-- or dumping all this to a text file and loading it
			ModelIndexTimer = ModelIndexTimer + 0.02
			timer.Simple(ModelIndexTimer - CurTime(), function() BuildModelIndex(dir..v..'/') end)

		end

	end

end



--[[---------------------------------------------------------
  Called by the toolgun to add a STOOL
-----------------------------------------------------------]]
function GM:DoModelSearch(str)

	local ret = {}

	if (#ModelIndex == 0) then
		ModelIndexTimer = CurTime()
		BuildModelIndex('models/')
	end

	if (str:len() < 3) then

		table.insert(ret, 'Enter at least 3 characters')

	else

		str = str:lower()

		for k, v in ipairs(ModelIndex) do

			if (v:find(str)) then

				table.insert(ret, v)

			end

		end

	end

	return ret

end


function GM:AddNotify( str, type, length )
	rp.Notify(type,str,'')
end
--PATH addons/__main/lua/weapons/3dgear/cl_init.lua:

include('shared.lua')

	SWEP.WepSelectIcon = surface.GetTextureID("vgui/entities/snk_sword_icon") 


function SWEP:CustomAmmoDisplay()

	self.AmmoDisplay = self.AmmoDisplay or {}
	self.AmmoDisplay.Draw = false
	
	self.AmmoDisplay.PrimaryClip 	= 1
	self.AmmoDisplay.PrimaryAmmo 	= -1
	self.AmmoDisplay.SecondaryAmmo 	= -1
	
	return self.AmmoDisplay

end




--PATH gamemodes/darkrp/entities/weapons/baton_base.lua:

-----------------------------------------------------
AddCSLuaFile()
SWEP.Base = 'weapon_rp_base'

if CLIENT then
	SWEP.PrintName = 'Baton Base'
	SWEP.Slot = 1
	SWEP.SlotPos = 3
	SWEP.DrawCrosshair = true
	SWEP.Spawnable = true
end

SWEP.Color = Color(255, 255, 255, 255)
SWEP.ViewModel = Model('models/weapons/v_stunbaton.mdl')
SWEP.WorldModel = Model('models/weapons/w_stunbaton.mdl')
SWEP.Primary.Sound = Sound('Weapon_StunStick.Swing')
SWEP.UseHands = false
SWEP.HitDistance = 100

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
	self._Reload.Sound = Sound('npc/combine_soldier/vo/administer.wav')
end

function SWEP:Deploy()
	if not IsValid(self.Owner) then return false end
	self:SetColor(self.Color)
	self:SetMaterial('models/shiny')
	local vm = self.Owner:GetViewModel()

	if IsValid(vm) then
		vm:SetColor(self.Color)
		vm:SetMaterial('models/shiny')
		vm:SendViewModelMatchingSequence(vm:LookupSequence('idle01'))
	end

	return true
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
	self:SetHoldType('melee')

	timer.Simple(0.3, function()
		if IsValid(self) then
			self:SetHoldType('normal')
			local vm = self.Owner:GetViewModel()

			if IsValid(vm) then
				vm:SendViewModelMatchingSequence(vm:LookupSequence('idle01'))
			end
		end
	end)

	self.Owner:SetAnimation(PLAYER_ATTACK1)
	self.Weapon:EmitSound(self.Primary.Sound)
	self.Weapon:SendWeaponAnim(ACT_VM_HITCENTER)
end

function SWEP:Reload()
	if not IsValid(self.Owner) or not self:CanReload() then return end
	self:SetNextReload(CurTime() + self._Reload.Delay)
	self:SetHoldType('melee')

	timer.Simple(1, function()
		if not IsValid(self) then return end
		self:SetHoldType('normal')
	end)

	self.Owner:EmitSound(self._Reload.Sound)
end

function SWEP:OnRemove(wep)
	if not IsValid(self.Owner) then return true end
	if IsValid(wep) and string.find(wep:GetClass(), "baton", 0, true) then return true end
	self:SetColor(Color(255, 255, 255, 255))
	self:SetMaterial('')
	local vm = self.Owner:GetViewModel()

	if IsValid(vm) then
		vm:SetColor(Color(255, 255, 255, 255))
		vm:SetMaterial('')
	end
end

function SWEP:Holster(wep)
	self:OnRemove(wep)

	return true
end
--PATH addons/__main/lua/weapons/bobs_shotty_base/shared.lua:
// Variables that are used on both client and server
-- Major thanks to rm-rf / for thinking up a solution to the reload glitch. Good man!

SWEP.Category				= ""
SWEP.Author				= "Generic Default, Worshipper, Clavus, and Bob"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.Base 				= "bobs_gun_base"
SWEP.MuzzleAttachment			= "1" 		// Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 		// Should be "2" for CSS models or "1" for hl2 models
SWEP.DrawCrosshair			= true		// Hell no, crosshairs r 4 nubz!
SWEP.ViewModelFOV			= 65		// How big the gun will look
SWEP.ViewModelFlip			= true		// True for CSS models, False for HL2 models

SWEP.Spawnable				= false
SWEP.AdminSpawnable			= false

SWEP.Primary.Sound 			= Sound("")				// Sound of the gun
SWEP.Primary.RPM				= 0					// This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 0					// Size of a clip
SWEP.Primary.DefaultClip			= 0					// Default number of bullets in a clip
SWEP.Primary.KickUp			= 0					// Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0					// Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= 0					// Maximum side recoil (koolaid)
SWEP.Primary.Automatic			= true					// Automatic/Semi Auto
SWEP.Primary.Ammo			= "none"					// What kind of ammo
SWEP.Primary.Reloading			= false					// Reloading func

-- SWEP.Secondary.ClipSize			= 0					// Size of a clip
-- SWEP.Secondary.DefaultClip			= 0					// Default number of bullets in a clip
-- SWEP.Secondary.Automatic			= false					// Automatic/Semi Auto
SWEP.Secondary.Ammo			= ""
SWEP.Secondary.IronFOV			= 0					// How much you 'zoom' in. Less is more! 

SWEP.data 				= {}					-- The starting firemode
SWEP.data.ironsights			= 1

SWEP.IronSightsPos = Vector (2.4537, 1.0923, 0.2696)
SWEP.IronSightsAng = Vector (0.0186, -0.0547, 0)

SWEP.ShotgunReloading		= false
SWEP.ShotgunFinish		= 0.5
SWEP.ShellTime		= 0.35
SWEP.InsertingShell	=		false

SWEP.NextReload	=	0

/*---------------------------------------------------------
   Name: SWEP:Think()
   Desc: Called every frame.
---------------------------------------------------------*/
function SWEP:Think()
	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsPlayer() then return end
	if self.Owner.NextReload == nil then self.Owner.NextReload = CurTime() + 1 end
	local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
	--if the owner presses shoot while the timer is in effect, then...
	if (self.Owner:KeyPressed(IN_ATTACK)) and (self.Weapon:GetNextPrimaryFire() <= CurTime()) and (timer.Exists(timerName)) and not (self.Owner:KeyDown(IN_SPEED)) then
		if self:CanPrimaryAttack() then --well first, if we actually can attack, then...
		
			timer.Destroy(timerName) -- kill the timer, and
			self:PrimaryAttack()-- ATTAAAAACK!
			
		end
	end
	
	if self.InsertingShell == true and self.Owner:Alive() then
		vm = self.Owner:GetViewModel()-- its a messy way to do it, but holy shit, it works!
		vm:ResetSequence(vm:LookupSequence("after_reload")) -- Fuck you, garry, why the hell can't I reset a sequence in multiplayer?
		vm:SetPlaybackRate(.01) -- or if I can, why does facepunch have to be such a shitty community, and your wiki have to be an unreadable goddamn mess?
		self.InsertingShell = false -- You get paid for this, what's your excuse?
	end
	
	self:IronSight()
	
end

/*---------------------------------------------------------
   Name: SWEP:Deploy()
   Desc: Whip it out.
---------------------------------------------------------*/
function SWEP:Deploy()
	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsPlayer() then return end
	
	self:SetHoldType(self.HoldType)
	
	local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
	if (timer.Exists(timerName)) then
		timer.Destroy(timerName)
	end

	self.Weapon:SendWeaponAnim(ACT_VM_DRAW)

	self.Weapon:SetNextPrimaryFire(CurTime() + .25)
	self.Weapon:SetNextSecondaryFire(CurTime() + .25)
	self.ActionDelay = (CurTime() + .25)

	if (SERVER) then
		self:SetIronsights(false)
	end
	
	self.Owner.NextReload = CurTime() + 1

	return true
end

/*---------------------------------------------------------
   Name: SWEP:Reload()
   Desc: Reload is being pressed.
---------------------------------------------------------*/
function SWEP:Reload()

	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsPlayer() then return end

	local maxcap = self.Primary.ClipSize
	local spaceavail = self.Weapon:Clip1()
	local shellz = (maxcap) - (spaceavail) + 1

	if (timer.Exists("ShotgunReload_" ..  self.Owner:UniqueID())) or self.Owner.NextReload > CurTime() or maxcap == spaceavail then return end
	
	if self.Owner:IsPlayer() then 

		if self.Weapon:GetNextPrimaryFire() <= (CurTime()+2) then
			self.Weapon:SetNextPrimaryFire(CurTime() + 2) -- wait TWO seconds before you can shoot again
		end
		self.Weapon:SendWeaponAnim(ACT_SHOTGUN_RELOAD_START) -- sending start reload anim
		self.Owner:SetAnimation( PLAYER_RELOAD )
		
		self.Owner.NextReload = CurTime() + 1
	
		if (SERVER) then
			self.Owner:SetFOV( 0, 0.15 )
			self:SetIronsights(false)
		end
	
		if SERVER and self.Owner:Alive() then
			local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
			timer.Create(timerName, 
			(self.ShellTime + .05), 
			shellz,
			function() if not IsValid(self) then return end 
			if IsValid(self.Owner) and IsValid(self.Weapon) then 
				if self.Owner:Alive() then 
					self:InsertShell()
				end 
			end end)
		end
	
	elseif self.Owner:IsNPC() then
		self.Weapon:DefaultReload(ACT_VM_RELOAD) 
	end
	
end

function SWEP:InsertShell()

	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsPlayer() then return end
	
	local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
	if self.Owner:Alive() then
		local curwep = self.Owner:GetActiveWeapon()
		if curwep:GetClass() != self.Gun then 
			timer.Destroy(timerName)
		return end
	
		if (self.Weapon:Clip1() >= self.Primary.ClipSize or self.Owner:GetAmmoCount(self.Primary.Ammo) <= 0) then
		-- if clip is full or ammo is out, then...
			self.Weapon:SendWeaponAnim(ACT_SHOTGUN_RELOAD_FINISH) -- send the pump anim
			timer.Destroy(timerName) -- kill the timer
		elseif (self.Weapon:Clip1() <= self.Primary.ClipSize and self.Owner:GetAmmoCount(self.Primary.Ammo) >= 0) then
			self.InsertingShell = true --well, I tried!
			timer.Simple( .05, function()
				if not IsValid(self) then return end
				self:ShellAnimCaller()
			end)
			self.Owner:RemoveAmmo(1, self.Primary.Ammo, false) -- out of the frying pan
			self.Weapon:SetClip1(self.Weapon:Clip1() + 1) --  into the fire
		end
	else
		timer.Destroy(timerName) -- kill the timer
	end
	
end

function SWEP:ShellAnimCaller()
	self.Weapon:SendWeaponAnim(ACT_VM_RELOAD)
end

--PATH addons/__main/lua/weapons/clout_gun_base/cl_init.lua:
include( 'shared.lua' )
SWEP.PrintName = '' -- 'Nice' Weapon name (Shown on HUD)	
SWEP.Slot = 4 -- Slot in the weapon selection menu
SWEP.SlotPos = 1 -- Position in the slot
SWEP.DrawAmmo = true -- Should draw the default HL2 ammo counter				// Should draw the default crosshair
SWEP.DrawWeaponInfoBox = false -- Should draw the weapon info box
SWEP.BounceWeaponIcon = false -- Should the weapon icon bounce?
SWEP.CSMuzzleFlashes = true
--PATH addons/__main/lua/weapons/divine_flintlock/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("divine_flintlock") -- must be the name of your swep but NO CAPITALS!
SWEP.Category				= "CSO/CF Weapons" --Category where you will find your weapons
SWEP.Author				= "Zekeou"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "Divine Flintlock"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 4			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false		-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight					= 30		-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg makes for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_pist_dflint.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_357.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= false
SWEP.Base				= "zekeou_gun_base" --the Base this weapon will work on. PLEASE RENAME THE BASE! 
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("weapons/D_Flint/Flintlock_Fire.wav")		-- Script that calls the primary fire sound
SWEP.Primary.SilencedSound 	= Sound("")		-- Sound if the weapon is silenced
SWEP.Primary.RPM			= 300			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 1		-- Size of a clip
SWEP.Primary.DefaultClip		= 28		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "357"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. 
--Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true
SWEP.CanBeSilenced		= false

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.Damage		= 45	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.4, 0, 0.319)
SWEP.IronSightsAng = Vector(-0.828, 4.133, 0)
SWEP.SightsPos = Vector(4.4, 0, 0.319)
SWEP.SightsAng = Vector(-0.828, 4.133, 0)
SWEP.RunSightsPos = Vector(0,0,0)	--These are for the angles your viewmodel will be when running
SWEP.RunSightsAng = Vector(0,0,0)	--Again, use the Swep Construction Kit

SWEP.WElements = {
	["Divine_Flintlock"] = { type = "Model", model = "models/weapons/w_pist_dflint.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(0.239, -0, 0.319), angle = Angle(1.299, -5.968, 180), size = Vector(0.944, 0.944, 0.944), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

--PATH gamemodes/darkrp/entities/weapons/door_ram.lua:

-----------------------------------------------------
AddCSLuaFile()
SWEP.Base = 'weapon_rp_base'

if CLIENT then
	SWEP.PrintName = 'Таран'
	SWEP.Slot = 5
	SWEP.SlotPos = 1
	SWEP.Instructions = 'Left click to open doors and unfreeze props\nRight click to ready the ram'
	SWEP.Spawnable = true
end

SWEP.ViewModel = Model('models/weapons/c_rpg.mdl')
SWEP.WorldModel = Model('models/weapons/w_rocket_launcher.mdl')
SWEP.Primary.Sound = Sound('Canals.d1_canals_01a_wood_box_impact_hard3')
SWEP.Primary.Delay = 2.5
local Ironsights = false
local OldJump = 190
local NewJump = 0
local NewRun = 180

function SWEP:Deploy()
	if not IsValid(self.Owner) then return end
	NewRun = self.Owner:GetWalkSpeed()
	OldJump = self.Owner:GetJumpPower()
end

function SWEP:OnRemove()
	if not IsValid(self.Owner) then return end
end

function SWEP:Holster()
	self:OnRemove()

	return true
end

function SWEP:PrimaryAttack()
	if not IsValid(self.Owner) or CLIENT then return end

	self.Owner:LagCompensation(true)
	local tr = self.Owner:GetEyeTrace()
	self.Owner:LagCompensation(false)
	local ent = tr.Entity
	if not IsValid(ent) or not Ironsights or (self.Owner:EyePos():Distance(tr.HitPos) > self.HitDistance) then return end

	if ent:IsVehicle() && ent.extraSeats then
		ent:ClearSeats(15, true)
	elseif ent:IsDoor() then
		local tar = ent:DoorGetOwner()
		if IsValid(tar) and tar:onyx_GetNetVar('Warrant') then
			if ent.Locked then
				ent:DoorLock(false)
			end

			ent:Fire('open', '', .6)
			ent:Fire('setanimation', 'open', .6)
		else
			rp.Notify(self.Owner,1,'Вам необхідний ордер! (ВИКОРИСТАЙТЕ РАЦІЮ)',"")
			return
		end
	elseif (ent:GetClass() == 'prop_physics') then
		local tar = ent:CPPIGetOwner()
			print(ent.isFadingDoor)

		if IsValid(tar) && tar:onyx_GetNetVar('Warrant') then
			if ent.isFadingDoor == true then
				ent:fadeActivate()
				timer.Simple(60,function()
					if IsValid(ent) then
						ent:fadeDeactivate()
					end
				end)
			end
		else
			rp.Notify(self.Owner,1,'Вам необходим ордер! (ВИКОРИСТАЙТЕ РАЦІЮ)',"")
			return
		end
	else
		return
	end

	self.Owner:SetAnimation(PLAYER_ATTACK1)
	self.Owner:EmitSound(self.Primary.Sound)
	self.Owner:ViewPunch(Angle(-10, math.random(-5, 5), 0))

	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
end

function SWEP:SecondaryAttack()
	if not IsValid(self.Owner) then return end
	self:SetNextSecondaryFire(CurTime() + self.Primary.Delay)
	Ironsights = not Ironsights

end
--[[
function SWEP:GetViewModelPosition(pos, ang) -- Fix
	return pos, ang
end
]]
--
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/editentity.lua:
--
-- This works - but I'm not certain that it's the way to go about it.
-- better instead to use the right click properties?
--
-- 73df 
TOOL.AddToMenu = false

TOOL.Category = "Construction"
TOOL.Name = "#tool.editentity.name"

function TOOL:LeftClick(trace)

	if (!trace.Hit) then return false end

	self.Weapon:SetTargetEntity1(trace.Entity)

	return true

end

function TOOL:RightClick(trace)

	return self:LeftClick(trace)

end

function TOOL:Think()

	local CurrentEditing = self.Weapon:GetTargetEntity1()

	if (CLIENT && self.LastEditing != CurrentEditing) then

		self.LastEditing = CurrentEditing

		local CPanel = controlpanel.Get("editentity")
		if (!CPanel) then return end

		CPanel:ClearControls()
		self.BuildCPanel(CPanel, CurrentEditing)

	end

end

function TOOL.BuildCPanel(CPanel, ent)

	local control = vgui.Create("DEntityProperties")
	control:SetEntity(ent)
	control:SetSize(10, 500)

	CPanel:AddPanel(control)

end
--PATH addons/____inventory/lua/weapons/itemstore_checker.lua:
if SERVER then
	AddCSLuaFile()
end

SWEP.PrintName = "Inventory Checker"

SWEP.Purpose = "Checking the inventory of another player"
SWEP.Instructions = "Primary attack: check inventory of player in front of you"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.ViewModel = "models/weapons/cstrike/c_c4.mdl"
SWEP.WorldModel = ""
SWEP.UseHands = true

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.Slot               = 1
SWEP.SlotPos 			= 10
SWEP.DrawAmmo           = false
SWEP.DrawCrosshair      = true

SWEP.Range = 250

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end

function SWEP:OnDrop()
	self:Remove()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end

	local tr = util.TraceLine{
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Range,
		filter = self.Owner
	}

	if not tr.Hit then return end
	if not IsValid( tr.Entity ) or not tr.Entity:IsPlayer() then return end

	local inv = tr.Entity.Inventory
	if not inv then return end

	inv:Sync( self.Owner )
	self.Owner:OpenContainer( inv:GetID(), itemstore.Translate( "inventory" ), true )
end

function SWEP:SecondaryAttack()
end

--PATH addons/__main/lua/weapons/m9k_1887winchester/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_1887winchester") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Winchester 87"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 30			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "shotgun"	-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_1887winchester.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_winchester_1887.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_shotty_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("1887winch.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 70		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 4			-- Size of a clip
SWEP.Primary.DefaultClip			= 12	-- Default number of bullets in a clip
SWEP.Primary.KickUp			= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.8		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= 0.6	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "slam"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 

SWEP.ShellTime			= .67

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 10		-- How many bullets to shoot per trigger pull, AKA pellets
SWEP.Primary.Damage		= 10	-- Base damage per bullet
SWEP.Primary.Spread		= .042	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .042	-- Ironsight accuracy, should be the same for shotguns
-- Because irons don't magically give you less pellet spread!

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.84, 0, 1.2)
SWEP.IronSightsAng = Vector(0, 0, 2.295)
SWEP.SightsPos = Vector(4.84, 0, 1.2)
SWEP.SightsAng = Vector(0, 0, 2.295)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 2.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)

if ((gmod.GetGamemode().Name) == "Murderthon 9000") or ((gmod.GetGamemode().Name) == "Murderthon 9000 beta") then
	SWEP.Primary.Ammo			= "slam"
	SWEP.Slot		= 1				-- Slot in the weapon selection menu
	SWEP.Weight		= 3			-- rank relative ot other weapons. bigger is better
else
	SWEP.Primary.Ammo			= "buckshot"
end



if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_ak47/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_ak47") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "AK-47"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 22			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.SelectiveFire		= true

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_dot_ak47.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_ak47_m9k.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("47ak.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 600			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 30	-- Base damage per bullet
SWEP.Primary.Spread		= .023	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .013 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
-- SWEP.IronSightsPos = Vector(4.394, -3.75, 1.48)
-- SWEP.IronSightsAng = Vector(1.419, -0.35, 0)
-- SWEP.SightsPos = Vector(4.394, -3.75, 1.48)
-- SWEP.SightsAng = Vector(1.419, -0.35, 0)

SWEP.IronSightsPos = Vector(4.539, -4.238, 1.799)
SWEP.IronSightsAng = Vector(0.958, -0.021, 0)
SWEP.SightsPos = Vector(4.539, -4.238, 1.799)
SWEP.SightsAng = Vector(0.958, -0.021, 0)
SWEP.RunSightsPos = Vector(-1.841, -3.386, 0.708)
SWEP.RunSightsAng = Vector(-7.441, -41.614, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end


if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_colt1911/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_colt1911") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Colt 1911"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 43			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/f_dmgf_co1911.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/s_dmgf_co1911.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Dmgfok_co1911.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 700			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 7		-- Size of a clip
SWEP.Primary.DefaultClip		= 45		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "pistol"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 17	-- Base damage per bullet
SWEP.Primary.Spread		= .025	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector (-2.6004, -1.3877, 1.1892)
SWEP.IronSightsAng = Vector (0.3756, -0.0032, 0.103)
SWEP.SightsPos = Vector (-2.6004, -1.3877, 1.1892)
SWEP.SightsAng = Vector (0.3756, -0.0032, 0.103)
SWEP.RunSightsPos = Vector(3.444, -7.823, -6.27)
SWEP.RunSightsAng = Vector(60.695, 0, 0)
-- SWEP.RunSightsPos = Vector (-0.7883, 0, 2.4235)
-- SWEP.RunSightsAng = Vector (-14.417, -0.7137, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_f2000/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_f2000") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= "iron angles by Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "F2000"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 27			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- Set false if you want no crosshair from hip
SWEP.XHair					= true		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 30			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_tct_f2000.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_fn_f2000.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_F2000.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 850		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= .4				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .4			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= .4		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "smg1"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true

SWEP.Secondary.ScopeZoom			= 4	
SWEP.Secondary.UseACOG			= true -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.5
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 23	--base damage per bullet
SWEP.Primary.Spread		= .025	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(3.499, 0, 1.08)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(3.499, 0, 1.08)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-7.705, -2.623, 1.475)
SWEP.RunSightsAng = Vector(-11.476, -55.083, -2.296)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_intervention/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_intervention") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Intervention"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 42			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= true		-- Is this a bolt action rifle?
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_snip_int.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_snip_int.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_INT.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 35		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 5		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .6			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= .4		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "SniperPenetratedRound"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 10	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= true	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 95	--base damage per bullet
SWEP.Primary.Spread		= .01	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .0001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector (2.2263, -0.0007, 0.115)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (2.2263, -0.0007, 0.115)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 1.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_jackhammer/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_jackhammer") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Pancor Jackhammer"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 23			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_jackhammer2.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_pancor_jackhammer.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_Jackhammer.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 240			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 10		-- Size of a clip
SWEP.Primary.DefaultClip		= 30		-- Bullets you start with
SWEP.Primary.KickUp				= 1		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.5		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.4		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "buckshot"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 6		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 10	-- Base damage per bullet
SWEP.Primary.Spread		= .045	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .045 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.026, -2.296, 0.917)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(4.026, -2.296, 0.917)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-3.116, -3.935, 0.492)
SWEP.RunSightsAng = Vector(-19.894, -47.624, 10.902)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_m60/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m60") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Machine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "M60 Machine Gun"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 34			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_m60machinegun.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_m60_machine_gun.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_M_60.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 575			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 200		-- Size of a clip
SWEP.Primary.DefaultClip		= 400		-- Bullets you start with
SWEP.Primary.KickUp				= 0.6		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 33	-- Base damage per bullet
SWEP.Primary.Spread		= .035	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .025 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-5.851, -2.763, 3.141)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(-5.851, -2.763, 3.141)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(8.689, -3.444, -0.82)
SWEP.RunSightsAng = Vector(0, 44.18, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_m92beretta/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m92beretta") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "M92 Beretta"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 26			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_pistberettam92.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_beretta_m92.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_m92b.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 500			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 15		-- Size of a clip
SWEP.Primary.DefaultClip		= 45		-- Bullets you start with
SWEP.Primary.KickUp				= 1		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.5		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "pistol"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		//how many bullets to shoot, use with shotguns
SWEP.Primary.Damage		= 14	//base damage, scaled by game
SWEP.Primary.Spread		= .027	//define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .019 // has to be the same as primary.spread

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.379, 0, 1.205)
SWEP.IronSightsAng = Vector(0.05, 0, 0)
SWEP.SightsPos = Vector(-2.379, 0, 1.205)
SWEP.SightsAng = Vector(0.05, 0, 0)
SWEP.RunSightsPos = Vector(3.444, -7.823, -6.27)
SWEP.RunSightsAng = Vector(60.695, 0, 0)
-- SWEP.RunSightsPos = Vector(0, 0, 0)
-- SWEP.RunSightsAng = Vector(-10.903, 6.885, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_psg1/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_psg1") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "PSG-1"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 45			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_psg1_snipe.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_hk_psg1.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_psg_1.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 500		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 10		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 1			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "SniperPenetratedRound"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 9	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= true	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 90	--base damage per bullet
SWEP.Primary.Spread		= .01	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .0001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(5.2, 0, 1.16)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(5.2, 0, 1.16)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 2.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_sig_p229r/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_sig_p229r") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "SIG Sauer P229R"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 33			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_sick_p228.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_sig_229r.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Sauer1_P228.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 500			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 12		-- Size of a clip
SWEP.Primary.DefaultClip		= 45		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "pistol"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 17	-- Base damage per bullet
SWEP.Primary.Spread		= .025	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.653, -.686, 1.06)
SWEP.IronSightsAng = Vector(0.3, 0, 0)
SWEP.SightsPos = Vector(-2.653, -.686, 1.06)
SWEP.SightsAng = Vector(0.3, 0, 0)

SWEP.RunSightsPos = Vector(3.444, -7.823, -6.27)
SWEP.RunSightsAng = Vector(60.695, 0, 0)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_thompson/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_thompson") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Tommy Gun"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 54			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "smg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_tommy_g.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_tommy_gun.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_tmg.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 575			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 75		-- Size of a clip
SWEP.Primary.DefaultClip		= 150		-- Bullets you start with
SWEP.Primary.KickUp				= 0.7		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.6		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.65		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 22	-- Base damage per bullet
SWEP.Primary.Spread		= .03	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .019 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(3.359, 0, 1.84)
SWEP.IronSightsAng = Vector(-2.166, -4.039, 0)
SWEP.SightsPos = Vector(3.359, 0, 1.84)
SWEP.SightsAng = Vector(-2.166, -4.039, 0)
SWEP.GSightsPos = Vector (0, 0, 0)
SWEP.GSightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 2.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)

if (gmod.GetGamemode().Name == "Murderthon 9000") then

	SWEP.Slot		= 1				-- Slot in the weapon selection menu
	SWEP.Weight		= 3			-- rank relative ot other weapons. bigger is better

end

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_usas/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_usas") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "USAS"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 29			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_usas12_shot.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_usas_12.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_usas.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 260			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 20		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 1		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.7		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "buckshot"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 10		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 7	-- Base damage per bullet
SWEP.Primary.Spread		= .048	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .048 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.519, -2.159, 1.039)
SWEP.IronSightsAng = Vector(0.072, 0.975, 0)
SWEP.SightsPos = Vector(4.519, -2.159, 1.039)
SWEP.SightsAng = Vector(0.072, 0.975, 0)
SWEP.RunSightsPos = Vector (-3.0328, 0, 1.888)
SWEP.RunSightsAng = Vector (-24.2146, -36.522, 10)

SWEP.ReloadPos = Vector (-3.0328, 0, 1.888)
SWEP.ReloadsAng = Vector (-24.2146, -36.522, 10)

SWEP.WElements = {
	["fix2"] = { type = "Model", model = "models/hunter/blocks/cube025x05x025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(22.416, 2.073, -5.571), angle = Angle(0, 0, -90), size = Vector(0.899, 0.118, 0.1), color = Color(0, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["magfix"] = { type = "Model", model = "models/XQM/cylinderx1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(10.482, 1.389, 0.078), angle = Angle(-8.098, 0, 0), size = Vector(0.2, 0.589, 0.589), color = Color(0, 0, 0, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

function SWEP:Reload()

	if ( self.Weapon:Clip1() < self.Primary.ClipSize ) and (self.Owner:GetAmmoCount("buckshot") > 0 ) and not (self.Weapon:GetNWBool("Reloading")) then
		self.Weapon:SendWeaponAnim(ACT_SHOTGUN_RELOAD_START) 
		self.Weapon:SetNWBool("Reloading", true)
		if SERVER and !self.Owner:IsNPC() then
			self.ResetSights = CurTime() + 1.65
			self.Owner:SetFOV( 0, 0.3 )
			self:SetIronsights(false)
		end
		timer.Simple(.65, function() if not IsValid(self) then return end if not IsValid(self.Owner) then return end if not IsValid(self.Weapon) then return end
			if IsValid(self.Owner) and self.Weapon:GetClass() == self.Gun then 
				self.Weapon:EmitSound(Sound("Weapon_usas.draw"))
			end
		end)
		timer.Simple(.8, function() if not IsValid(self) then return end if not IsValid(self.Owner) then return end if not IsValid(self.Weapon) then return end
		if IsValid(self.Owner) and self.Weapon != nil then self:ReloadFinish() end end)
	end

end

function SWEP:ReloadFinish()
if not IsValid(self) then return end 
	if IsValid(self.Owner) and self.Weapon != nil then
		if self.Owner:Alive() and self.Weapon:GetClass() == self.Gun then
			self.Weapon:DefaultReload(ACT_SHOTGUN_RELOAD_FINISH)
			
			if !self.Owner:IsNPC() then
				self.ResetSights = CurTime() + self.Owner:GetViewModel():SequenceDuration() 
			end
			if SERVER and self.Weapon != nil then
				if ( self.Weapon:Clip1() < self.Primary.ClipSize ) and !self.Owner:IsNPC() then
					self.Owner:SetFOV( 0, 0.3 )
					self:SetIronsights(false)
			end

		local waitdammit = (self.Owner:GetViewModel():SequenceDuration())
		timer.Simple(waitdammit + .1, 
		function() if not IsValid(self) then return end if not IsValid(self.Owner) then return end if not IsValid(self.Weapon) then return end
		if self.Weapon == nil then return end
		self.Weapon:SetNWBool("Reloading", false)
		if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then 
			if CLIENT then return end
			if self.Scoped == false then
				self.Owner:SetFOV( self.Secondary.IronFOV, 0.3 )
				self.IronSightsPos = self.SightsPos					-- Bring it up
				self.IronSightsAng = self.SightsAng					-- Bring it up
				self:SetIronsights(true, self.Owner)
				self.DrawCrosshair = false
			else return end
		elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then 
			self.Weapon:SetNextPrimaryFire(CurTime()+0.3)			-- Make it so you can't shoot for another quarter second
			self.IronSightsPos = self.RunSightsPos					-- Hold it down
			self.IronSightsAng = self.RunSightsAng					-- Hold it down
			self:SetIronsights(true, self.Owner)					-- Set the ironsight true
			self.Owner:SetFOV( 0, 0.3 )
		else return end
		end) 
			end
		end
	end
end

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_val/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_val") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "AS VAL"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 39			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_dmg_vally.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_dmg_vally.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Dmgfok_vally.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 940			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 20		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 25	-- Base damage per bullet
SWEP.Primary.Spread		= .019	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .008 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector (-2.2442, -1.8353, 1.0599)
SWEP.IronSightsAng = Vector (1.0513, 0.0322, 0)
SWEP.SightsPos = Vector (-2.2442, -1.8353, 1.0599)
SWEP.SightsAng = Vector (1.0513, 0.0322, 0)
SWEP.RunSightsPos = Vector (0.3339, -2.043, 0.6273)
SWEP.RunSightsAng = Vector (-11.5931, 48.4648, -19.7039)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_vector/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_vector") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "KRISS Vector"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 58			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "smg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_kriss_svs.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_kriss_vector.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("kriss_vector.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 1000			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.2		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.1		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 50		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 23	-- Base damage per bullet
SWEP.Primary.Spread		= .026	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .014 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(3.943, -0.129, 1.677)
SWEP.IronSightsAng = Vector(-1.922, 0.481, 0)
SWEP.SightsPos = Vector(3.943, -0.129, 1.677)
SWEP.SightsAng = Vector(-1.922, 0.481, 0)
SWEP.RunSightsPos = Vector(-3.701, -6.064, -0.551)
SWEP.RunSightsAng = Vector(-4.685, -62.559, 9.093)



if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH gamemodes/darkrp/entities/weapons/stun_baton.lua:

-----------------------------------------------------
AddCSLuaFile()
local BaseClass = baseclass.Get('baton_base')

if SERVER then
	util.AddNetworkString('StunStickFlash')
else
	SWEP.PrintName = 'Поліц Палиця'
	SWEP.SlotPos = 6
	SWEP.Instructions = 'Left click sets phaser to stun\nRight click sets phaser to kill'
	SWEP.Spawnable = true
end

SWEP.Color = Color(0, 0, 255, 255)
local Hit = Sound('Weapon_StunStick.Melee_Hit')
local Miss = Sound('Weapon_StunStick.Melee_HitWorld')

if CLIENT then
	local function StunStickFlash()
		local alpha = 255

		hook.Add('HUDPaint', 'StunStickFlash', function()
			alpha = Lerp(0.05, alpha, 0)
			surface.SetDrawColor(255, 255, 255, alpha)
			surface.DrawRect(0, 0, ScrW(), ScrH())

			if math.Round(alpha) == 0 then
				hook.Remove('HUDPaint', 'StunStickFlash')
			end
		end)
	end

	net.Receive('StunStickFlash', StunStickFlash)
end

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
	self._Reload.Sound = Sound('Weapon_StunStick.Activate')
end

function SWEP:PrimaryAttack()
	if not IsValid(self.Owner) then return end
	BaseClass.PrimaryAttack(self)
	self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	if CLIENT then return end
	self.Owner:LagCompensation(true)
	local ent = self.Owner:GetEyeTrace().Entity
	self.Owner:LagCompensation(false)
	if not IsValid(ent) or (self.Owner:GetPos():Distance(ent:GetPos()) > self.HitDistance) then return end

	if ent:IsPlayer() then
		net.Start('StunStickFlash')
		net.Send(ent)
		self.Owner:EmitSound(Hit)
	else
		self.Owner:EmitSound(Miss)
	end
end

function SWEP:SecondaryAttack()
	if not IsValid(self.Owner) then return end
	BaseClass.PrimaryAttack(self)
	self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	if CLIENT then return end
	self.Owner:LagCompensation(true)
	local ent = self.Owner:GetEyeTrace().Entity
	self.Owner:LagCompensation(false)
	if not IsValid(ent) or (self.Owner:GetPos():Distance(ent:GetPos()) > self.HitDistance) then return end

	if ent:IsPlayer() then
		ent:TakeDamage(10, self.Owner, self)
		net.Start('StunStickFlash')
		net.Send(ent)
		self.Owner:EmitSound(Hit)
	else
		self.Owner:EmitSound(Miss)
	end
end
--PATH addons/__main/lua/weapons/stungun/cl_init.lua:

--[[
Stungun SWEP Created by Donkie (http://steamcommunity.com/id/Donkie/)
For personal/server usage only, do not resell or distribute!
]]

include("shared.lua")

SWEP.PrintName = "Шокер"
SWEP.Slot = 1
SWEP.SlotPos = 1
SWEP.DrawAmmo = (not SWEP.InfiniteAmmo)
SWEP.DrawCrosshair = false

language.Add("ammo_stungun_ammo", "Stungun Ammo")

if STUNGUN.IsTTT then
	-- TTT stuff
	-- Path to the icon material
	SWEP.Icon = "stungun/icon_stungun"

	local ammotext = ""
	if SWEP.Ammo > 0 then
		ammotext = "\nIt has " .. SWEP.Ammo .. " charges."
	end

	-- Text shown in the equip menu
	SWEP.EquipMenuData = {
		type = "Weapon",
		desc = string.format("Stungun used to paralyze enemies making them\nunable to speak and move for a few seconds.%s\n\nCreated by: Donkie",ammotext)
	}
end


SWEP.VElements = {
	["Yellowbox+"] = { type = "Model", model = "models/props_c17/FurnitureFridge001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "Yellowbox", pos = Vector(-3.182, 0, 0), angle = Angle(0, 0, 0), size = Vector(0.05, 0.1, 0.029), color = Color(255, 255, 0, 255), surpresslightning = false, material = "models/debug/debugwhite", skin = 0, bodygroup = {} },
	["Yellowbox"] = { type = "Model", model = "models/props_c17/FurnitureFridge001a.mdl", bone = "ValveBiped.square", rel = "", pos = Vector(0.259, 0.455, 2.273), angle = Angle(90, 0, 180), size = Vector(0.05, 0.1, 0.029), color = Color(255, 255, 0, 255), surpresslightning = false, material = "models/debug/debugwhite", skin = 0, bodygroup = {} },
	["Yellowbox+++"] = { type = "Model", model = "models/props_c17/FurnitureFridge001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.171, 1.784, -0.456), angle = Angle(0, 90, -101.25), size = Vector(0.054, 0.293, 0.05), color = Color(0, 0, 24, 255), surpresslightning = false, material = "models/debug/debugwhite", skin = 0, bodygroup = {} },
	["Yellowbox++"] = { type = "Model", model = "models/props_c17/FurnitureFridge001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "Yellowbox", pos = Vector(-1.8, -0.201, -0.75), angle = Angle(90, -90, 0), size = Vector(0.054, 0.4, 0.05), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/stripes", skin = 0, bodygroup = {} },
	["Blackreceiver"] = { type = "Model", model = "models/props_c17/FurnitureWashingmachine001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "Yellowbox", pos = Vector(-3.5, 0, -0.201), angle = Angle(0, -90, 90), size = Vector(0.119, 0.054, 0.3), color = Color(0, 0, 0, 0), surpresslightning = false, material = "phoenix_storms/stripes", skin = 0, bodygroup = {} },
	["counter"] = { type = "Quad", bone = "ValveBiped.Bip01_R_Hand", rel = "Blackreceiver", pos = Vector(0, 0, 4.099), angle = Angle(0, -90, 0), size = 0.02, draw_func = nil}
}
SWEP.WElements = {
	["Yellowbox"] = { type = "Model", model = "models/props_c17/FurnitureFridge001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(8.635, 2.273, -3.5), angle = Angle(-5, -2, 90), size = Vector(0.05, 0.1, 0.029), color = Color(255, 255, 0, 255), surpresslightning = false, material = "models/debug/debugwhite", skin = 0, bodygroup = {} },
	["Yellowbox+"] = { type = "Model", model = "models/props_c17/FurnitureFridge001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "Yellowbox", pos = Vector(-3.182, 0, 0), angle = Angle(0, 0, 0), size = Vector(0.05, 0.1, 0.029), color = Color(255, 255, 0, 255), surpresslightning = false, material = "models/debug/debugwhite", skin = 0, bodygroup = {} },
	["Blackreceiver"] = { type = "Model", model = "models/props_c17/FurnitureWashingmachine001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "Yellowbox", pos = Vector(-3, 0, -0.201), angle = Angle(0, -90, 90), size = Vector(0.119, 0.057, 0.3), color = Color(0, 0, 0, 255), surpresslightning = false, material = "phoenix_storms/stripes", skin = 0, bodygroup = {} }
}

--[[
IN-HEAD VIEW
]]
net.Receive("tazestartview", function()
	local rag = net.ReadEntity()
	LocalPlayer().viewrag = rag
end)
net.Receive("tazeendview", function()
	LocalPlayer().viewrag = nil
end)

hook.Add("PlayerBindPress", "Tazer", function(ply,bind,pressed)
	if IsValid(ply:GetNWEntity("tazerviewrag")) and STUNGUN.Thirdperson and STUNGUN.AllowSwitchFromToThirdperson then
		if bind == "+duck" then
			if ply.thirdpersonview == nil then
				ply.thirdpersonview = false
			end

			ply.thirdpersonview = not ply.thirdpersonview
		end
	end
end)

local dist = 200
local view = {}
hook.Add("CalcView", "Tazer", function(ply, origin, angles, fov)
	local rag = ply:GetNWEntity("tazerviewrag")
	if IsValid(rag) then
		local bid = rag:LookupBone("ValveBiped.Bip01_Head1")
		if bid then
			local dothirdperson = false
			if STUNGUN.Thirdperson then
				if STUNGUN.AllowSwitchFromToThirdperson then
					dothirdperson = ply.thirdpersonview
				else
					dothirdperson = true
				end
			end

			if dothirdperson then
				local ragpos = rag:GetBonePosition(bid)

				local pos = ragpos - (ply:GetAimVector() * dist)
				local ang = (ragpos - pos):Angle()

				-- Do a traceline so he can't see through walls
				local trdata = {}
				trdata.start = ragpos
				trdata.endpos = pos
				trdata.filter = rag
				local trres = util.TraceLine(trdata)
				if trres.Hit then
					pos = trres.HitPos + (trres.HitWorld and trres.HitNormal * 3 or vector_origin)
				end

				view.origin = pos
				view.angles = ang
			else
				local pos,ang = rag:GetBonePosition(bid)
				pos = pos + ang:Forward() * 7
				ang:RotateAroundAxis(ang:Up(), -90)
				ang:RotateAroundAxis(ang:Forward(), -90)
				pos = pos + ang:Forward() * 1

				view.origin = pos
				view.angles = ang
			end

			view.drawviewer = false

			return view
		end
	end
end)

local minpos, minang = Vector(-16384, -16384, -16384), Angle(0,0,0)
hook.Add("CalcViewModelView", "Stungun", function(wep)
	if IsValid(wep.Owner) and IsValid(wep.Owner:GetNWEntity("tazerviewrag")) then
		return minpos, minang
	end
end)

--[[
Effects
]]
hook.Add("OnEntityCreated", "StungunRagdoll", function(ent)
	if ent:IsRagdoll() then
		local ply = ent:GetDTEntity(1)

		if IsValid(ply) and ply:IsPlayer() then
			-- Only copy any decals if this ragdoll was recently created
			if ent:GetCreationTime() > CurTime() - 1 then
				ent:SnatchModelInstance(ply)
			end

			-- Copy the color for the PlayerColor matproxy
			local playerColor = ply:GetPlayerColor()
			ent.GetPlayerColor = function()
				return playerColor
			end
		end
	end
end)

hook.Add("EntityRemoved", "StungunRagdoll", function(ent)
	if ent:IsRagdoll() then
		local ply = ent:GetDTEntity(1)

		if IsValid(ply) and ply:IsPlayer() then
			ply:SnatchModelInstance(ent)
		end
	end
end)

--[[
CROSSHAIR
]]

local col1 = Color(0,150,0,255)
local col2 = Color(150,0,0,255)
local w,h = ScrW(), ScrH()
local w2,h2 = w * 0.5, h * 0.5
function SWEP:DrawHUD()
	if LocalPlayer() != self.Owner then return end -- Not sure why this would happen but you never know.
	if STUNGUN.IsTTT and GetConVar("ttt_disable_crosshair"):GetBool() then return end -- If a TTT player wants it disabled, so be it.

	-- Small delay so we don't spam the shit out of the player.
	if not self.trres or self.nexttr < CurTime() then
		self.trres = util.TraceLine(util.GetPlayerTrace(LocalPlayer()))
		self.nexttr = CurTime() + .05
	end

	local hit = self.trres.HitPos:Distance(LocalPlayer():GetShootPos()) <= self.Range and (IsValid(self.trres.Entity) and self.trres.Entity:IsPlayer())

	surface.SetDrawColor(hit and col1 or col2)

	local gap = (hit and 0 or 10) + 5
	local length = 10

	surface.DrawLine( w2 - length, h2, w2 - gap, h2 )
	surface.DrawLine( w2 + length, h2, w2 + gap, h2 )
	surface.DrawLine( w2, h2 - length, w2, h2 - gap )
	surface.DrawLine( w2, h2 + length, w2, h2 + gap )
end

--[[
TARGET ID
]]
-- Stops targetids from drawing in darkrp. TTT sadly has no hook like this.
hook.Add("HUDShouldDraw", "Tazer", function(hud)
	if hud == "DarkRP_EntityDisplay" then
		local p = {}
		local edited = false
		for k,v in player.Iterator() do
			if not IsValid(v:GetNWEntity("tazerviewrag")) then
				table.insert(p, v)
			else
				edited = true
			end
		end

		if edited then -- Only override if we actually done something. So others have a chance.
			return true, p
		end
	end
end)

local function IsOnScreen(pos)
	return pos.x > 0 and pos.x < w and pos.y > 0 and pos.y < h
end
																																																																									
local function GrabPlyInfo(ply)
	if STUNGUN.IsTTT then
		local text, color
		if ply:GetNWBool("disguised", false) then
			if LocalPlayer():IsTraitor() or LocalPlayer():IsSpec() then
				text = ply:Nick() .. LANG.GetUnsafeLanguageTable().target_disg
			else
				-- Do not show anything
				return
			end

			color = COLOR_RED
		else
			text = ply:Nick()
		end

		return text, (color or COLOR_WHITE), "TargetID"
	elseif STUNGUN.IsDarkRP then
		return ply:Nick(), (team.GetColor(ply:Team()) or Color(255,255,255)), "DarkRPHUD2"
	else
		return ply:Nick(), (team.GetColor(ply:Team()) or Color(255,255,255)), "TargetID"
	end
end																																																																																	
-- For some reason, when they're ragdolled their hp isn't sent properly to the clients.
net.Receive("tazersendhealth", function()
	local ent = net.ReadEntity()
	local newhp = net.ReadInt(32)
	ent.newhp = newhp
end)

--[[
Handcuffs support!
]]
local lrender = {
	normal = {
		bone  = "ValveBiped.Bip01_Neck1",
		pos   = Vector(2,1.8,0),
		ang   = Angle(70,90,90),
		scale = Vector(0.06,0.06,0.05),
	},
	alt = { -- Eeveelotions models
		bone  = "Neck",
		pos   = Vector(1,0.5,-0.2),
		ang   = Angle(100,90,90),
		scale = Vector(0.082,0.082,0.082),
	},
}
local LeashHolder = "ValveBiped.Bip01_R_Hand"
local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"
local DefaultRope = "cable/cable2"
local function LEASHDrawWorldModel(self)
	if not IsValid(self.Owner) then return end

	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		if not IsValid( self.cmdl_LeftCuff ) then return end
		self.cmdl_LeftCuff:SetNoDraw( true )
		-- self.cmdl_LeftCuff:SetParent( vm )
	end

	local tbl = lrender.normal
	local lpos, lang = self:GetBonePos( tbl.bone, self.Owner )
	if not (lpos) then
		tbl = lrender.alt
		lpos, lang = self:GetBonePos( tbl.bone, self.Owner )
		if not (lpos) then return end
	end

	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward() * tbl.pos.x) + (lang:Right() * tbl.pos.y) + (lang:Up() * tbl.pos.z) )
	local u,r,f = lang:Up(), lang:Right(), lang:Forward() -- Prevents moving axes
	lang:RotateAroundAxis( u, tbl.ang.y )
	lang:RotateAroundAxis( r, tbl.ang.p )
	lang:RotateAroundAxis( f, tbl.ang.r )
	self.cmdl_LeftCuff:SetAngles( lang )

	local matrix = Matrix()
	matrix:Scale( tbl.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )

	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()

	if self:GetRopeMaterial() != self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end
	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end

	local ropestart = lpos
	local kidnapper = self:GetKidnapper()
	local ropeend = (kidnapper:IsPlayer() and kidnapper:GetPos() + Vector(0,0,37)) or kidnapper:GetPos()
	if kidnapper != LocalPlayer() or (hook.Call("ShouldDrawLocalPlayer", GAMEMODE, LocalPlayer())) then
		local lBone = kidnapper:LookupBone(LeashHolder)

		if lBone then
			local newPos = kidnapper:GetBonePosition( lBone )
			if newPos and (newPos.x != 0 and newPos.y != 0 and newPos.z != 0) then
				ropeend = newPos
			end
		end
	end

	render.SetMaterial( self.RopeMat )
	render.DrawBeam( ropestart, ropeend, 0.7, 0, 5, Color(255,255,255) )
	render.DrawBeam( ropeend, ropestart, -0.7, 0, 5, Color(255,255,255) )
end

local plymeta = FindMetaTable("Player")
hook.Add("PostDrawOpaqueRenderables", "STUNGUN_CUFFS", function()
	if not plymeta.IsHandcuffed then hook.Remove("PostDrawOpaqueRenderables", "STUNGUN_CUFFS") return end

	for k,v in ipairs(ents.FindByClass("prop_ragdoll")) do
		if not v:GetNWString("cuffs_ropemat") or
			not v:GetNWString("cuffs_cuffmat") or
			not isbool(v:GetNWBool("cuffs_isleash")) or
			not IsValid(v:GetNWEntity("cuffs_kidnapper")) then continue end

		if not v.swep then
			local leashowner = v:GetNWEntity("cuffs_kidnapper")
			local isleash = v:GetNWBool("cuffs_isleash")

			v.swep = {
				cuffmat = v:GetNWString("cuffs_cuffmat"),
				ropemat = v:GetNWString("cuffs_ropemat"),
				GetBonePos = weapons.Get("weapon_handcuffed").GetBonePos,
				GetCuffMaterial = function(self) return self.cuffmat end,
				GetRopeMaterial = function(self) return self.ropemat end,
				GetIsLeash = function() return isleash end,
				GetKidnapper = function() return leashowner end,
				Owner = v
			}

			if isleash then
				v.swep.DrawWorldModel = LEASHDrawWorldModel
			else
				v.swep.DrawWorldModel = weapons.Get("weapon_handcuffed").DrawWorldModel
			end
		end

		v.swep:DrawWorldModel()
	end
end)

--[[*******************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
*******************************************************]]
function SWEP:Initialize()
	-- Create a new table for every weapon instance
	self.VElements = table.FullCopy( self.VElements )
	self.WElements = table.FullCopy( self.WElements )
	self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

	self:CreateModels(self.VElements) -- create viewmodels
	self:CreateModels(self.WElements) -- create worldmodels

	-- init view model bone build function
	self.VElements["counter"].draw_func = function()
		//self:DrawScreen(-27,-65,65,123)
	end
end

function SWEP:Holster()
	return true
end

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_VM_DRAW)

	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:OnDrop()
	self:Holster()
end

net.Receive("tazerondrop",function()
	local swep = net.ReadEntity()
	if swep.OnDrop then
		swep:OnDrop()
	end
end)

SWEP.vRenderOrder = nil
function SWEP:ViewModelDrawn()

	local vm = self.Owner:GetViewModel()
	if not IsValid(vm) then return end

	if (!self.VElements) then return end

	self:UpdateBonePositions(vm)

	if (!self.vRenderOrder) then

		-- we build a render order because sprites need to be drawn after models
		self.vRenderOrder = {}

		for k, v in pairs( self.VElements ) do
			if (v.type == "Model") then
				table.insert(self.vRenderOrder, 1, k)
			elseif (v.type == "Sprite" or v.type == "Quad") then
				table.insert(self.vRenderOrder, k)
			end
		end

	end

	for k, name in ipairs( self.vRenderOrder ) do

		local v = self.VElements[name]
		if (!v) then self.vRenderOrder = nil break end
		if (v.hide) then continue end

		local model = v.modelEnt
		local sprite = v.spriteMaterial

		if (!v.bone) then continue end

		local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )

		if (!pos) then continue end

		if (v.type == "Model" and IsValid(model)) then

			model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)

			model:SetAngles(ang)
			-- model:SetModelScale(v.size)
			local matrix = Matrix()
			matrix:Scale(v.size)
			model:EnableMatrix( "RenderMultiply", matrix )

			if (v.material == "") then
				model:SetMaterial("")
			elseif (model:GetMaterial() != v.material) then
				model:SetMaterial( v.material )
			end

			if (v.skin and v.skin != model:GetSkin()) then
				model:SetSkin(v.skin)
			end

			if (v.bodygroup) then
				for k, v in pairs( v.bodygroup ) do
					if (model:GetBodygroup(k) != v) then
						model:SetBodygroup(k, v)
					end
				end
			end

			if (v.surpresslightning) then
				render.SuppressEngineLighting(true)
			end

			render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
			render.SetBlend(v.color.a/255)
			model:DrawModel()
			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)

			if (v.surpresslightning) then
				render.SuppressEngineLighting(false)
			end

		elseif (v.type == "Sprite" and sprite) then

			local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			render.SetMaterial(sprite)
			render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)

		elseif (v.type == "Quad" and v.draw_func) then

			local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)

			cam.Start3D2D(drawpos, ang, v.size)
				v.draw_func( self )
			cam.End3D2D()

		end

	end

end

SWEP.wRenderOrder = nil
function SWEP:DrawWorldModel()
	-- Fixes worldmodel being seen in firstperson spectating
	local viewent = LocalPlayer():GetObserverTarget()
	if IsValid(viewent) and viewent != LocalPlayer() and viewent == self.Owner then
		return
	end

	if (self.ShowWorldModel == nil or self.ShowWorldModel) then
		self:DrawModel()
	end

	if (!self.WElements) then return end

	if (!self.wRenderOrder) then

		self.wRenderOrder = {}

		for k, v in pairs( self.WElements ) do
			if (v.type == "Model") then
				table.insert(self.wRenderOrder, 1, k)
			elseif (v.type == "Sprite" or v.type == "Quad") then
				table.insert(self.wRenderOrder, k)
			end
		end

	end

	if (IsValid(self.Owner)) then
		bone_ent = self.Owner
	else
		-- when the weapon is dropped
		bone_ent = self
	end

	for k, name in pairs( self.wRenderOrder ) do

		local v = self.WElements[name]
		if (!v) then self.wRenderOrder = nil break end
		if (v.hide) then continue end

		local pos, ang

		if (v.bone) then
			pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
		else
			pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
		end

		if (!pos) then continue end

		local model = v.modelEnt
		local sprite = v.spriteMaterial

		if (v.type == "Model" and IsValid(model)) then

			model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)

			model:SetAngles(ang)
			-- model:SetModelScale(v.size)
			local matrix = Matrix()
			matrix:Scale(v.size)
			model:EnableMatrix( "RenderMultiply", matrix )

			if (v.material == "") then
				model:SetMaterial("")
			elseif (model:GetMaterial() != v.material) then
				model:SetMaterial( v.material )
			end

			if (v.skin and v.skin != model:GetSkin()) then
				model:SetSkin(v.skin)
			end

			if (v.bodygroup) then
				for k, v in pairs( v.bodygroup ) do
					if (model:GetBodygroup(k) != v) then
						model:SetBodygroup(k, v)
					end
				end
			end

			if (v.surpresslightning) then
				render.SuppressEngineLighting(true)
			end

			render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
			render.SetBlend(v.color.a/255)
			model:DrawModel()
			render.SetBlend(1)
			render.SetColorModulation(1, 1, 1)

			if (v.surpresslightning) then
				render.SuppressEngineLighting(false)
			end

		elseif (v.type == "Sprite" and sprite) then

			local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			render.SetMaterial(sprite)
			render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)

		elseif (v.type == "Quad" and v.draw_func) then

			local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)

			cam.Start3D2D(drawpos, ang, v.size)
				v.draw_func( self )
			cam.End3D2D()

		end

	end

end

function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )

	local bone, pos, ang
	if (tab.rel and tab.rel != "") then

		local v = basetab[tab.rel]

		if (!v) then return end

		-- Technically, if there exists an element with the same name as a bone
		-- you can get in an infinite loop. Let's just hope nobody's that stupid.
		pos, ang = self:GetBoneOrientation( basetab, v, ent )

		if (!pos) then return end

		pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
		ang:RotateAroundAxis(ang:Up(), v.angle.y)
		ang:RotateAroundAxis(ang:Right(), v.angle.p)
		ang:RotateAroundAxis(ang:Forward(), v.angle.r)

	else

		bone = ent:LookupBone(bone_override or tab.bone)

		if (!bone) then return end

		pos, ang = Vector(0,0,0), Angle(0,0,0)
		local m = ent:GetBoneMatrix(bone)
		if (m) then
			pos, ang = m:GetTranslation(), m:GetAngles()
		end

		if (IsValid(self.Owner) and self.Owner:IsPlayer() and
			ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
			ang.r = -ang.r -- Fixes mirrored models
		end

	end

	return pos, ang
end

function SWEP:CreateModels( tab )

	if (!tab) then return end

	-- Create the clientside models here because Garry says we can't do it in the render hook
	for k, v in pairs( tab ) do
		if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and
				string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then

			v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
			if (IsValid(v.modelEnt)) then
				v.modelEnt:SetPos(self:GetPos())
				v.modelEnt:SetAngles(self:GetAngles())
				v.modelEnt:SetParent(self)
				v.modelEnt:SetNoDraw(true)
				v.createdModel = v.model
			else
				v.modelEnt = nil
			end

		elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite)
			and file.Exists ("materials/" .. v.sprite .. ".vmt", "GAME")) then

			local name = v.sprite .. "-"
			local params = { ["$basetexture"] = v.sprite }
			-- make sure we create a unique name based on the selected options
			local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
			for i, j in pairs( tocheck ) do
				if (v[j]) then
					params["$" .. j] = 1
					name = name .. "1"
				else
					name = name .. "0"
				end
			end

			v.createdSprite = v.sprite
			v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)

		end
	end

end

local allbones
local hasGarryFixedBoneScalingYet = false

function SWEP:UpdateBonePositions(vm)

	if self.ViewModelBoneMods then

		if (!vm:GetBoneCount()) then return end

		-- !! WORKAROUND !! --
		-- We need to check all model names :/
		local loopthrough = self.ViewModelBoneMods
		if (!hasGarryFixedBoneScalingYet) then
			allbones = {}
			for i=0, vm:GetBoneCount() do
				local bonename = vm:GetBoneName(i)
				if (self.ViewModelBoneMods[bonename]) then
					allbones[bonename] = self.ViewModelBoneMods[bonename]
				else
					allbones[bonename] = {
						scale = Vector(1,1,1),
						pos = Vector(0,0,0),
						angle = Angle(0,0,0)
					}
				end
			end

			loopthrough = allbones
		end
		-- !! ----------- !! --

		for k, v in pairs( loopthrough ) do
			local bone = vm:LookupBone(k)
			if (!bone) then continue end

			-- !! WORKAROUND !! --
			local s = Vector(v.scale.x,v.scale.y,v.scale.z)
			local p = Vector(v.pos.x,v.pos.y,v.pos.z)
			local ms = Vector(1,1,1)
			if (!hasGarryFixedBoneScalingYet) then
				local cur = vm:GetBoneParent(bone)
				while(cur >= 0) do
					local pscale = loopthrough[vm:GetBoneName(cur)].scale
					ms = ms * pscale
					cur = vm:GetBoneParent(cur)
				end
			end

			s = s * ms
			-- !! ----------- !! --

			if vm:GetManipulateBoneScale(bone) != s then
				vm:ManipulateBoneScale( bone, s )
			end
			if vm:GetManipulateBoneAngles(bone) != v.angle then
				vm:ManipulateBoneAngles( bone, v.angle )
			end
			if vm:GetManipulateBonePosition(bone) != p then
				vm:ManipulateBonePosition( bone, p )
			end
		end
	else
		self:ResetBonePositions(vm)
	end

end

function SWEP:ResetBonePositions(vm)

	if (!vm:GetBoneCount()) then return end
	for i=0, vm:GetBoneCount() do
		vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
		vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
		vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
	end

end

--[[*************************
	Global utility code
*************************]]

-- Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
-- Does not copy entities of course, only copies their reference.
-- WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
function table.FullCopy( tab )

	if (!tab) then return nil end

	local res = {}
	for k, v in pairs( tab ) do
		if (type(v) == "table") then
			res[k] = table.FullCopy(v) -- recursion ho!
		elseif (type(v) == "Vector") then
			res[k] = Vector(v.x, v.y, v.z)
		elseif (type(v) == "Angle") then
			res[k] = Angle(v.p, v.y, v.r)
		else
			res[k] = v
		end
	end

	return res

end

--PATH addons/swb_base/lua/weapons/swb_357/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = ".357 Revolver"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-4.691, -3.958, 0.66)
	SWEP.AimAng = Vector(0, -0.216, 0)
	
	SWEP.SprintPos = Vector(1.185, -15.796, -14.254)
	SWEP.SprintAng = Vector(64.567, 0, 0)
	
	SWEP.ZoomAmount = 5
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "f"
	
	SWEP.MuzzleEffect = "swb_pistol_large"
	SWEP.MuzzlePosMod = {x = 6.5, y =	30, z = -2}
	--SWEP.PosBasedMuz = true
end

SWEP.SpeedDec = 12
SWEP.BulletDiameter = 9.1
SWEP.CaseLength = 33

SWEP.PlayBackRate = 2
SWEP.PlayBackRateSV = 2

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_revolver_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "Pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"double"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/c_357.mdl"
SWEP.WorldModel		= "models/weapons/w_357.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 6
SWEP.Primary.DefaultClip	= 6
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "357"

SWEP.FireDelay = 0.45
SWEP.FireSound = Sound("Weapon_357.Single")
SWEP.Recoil = 3
SWEP.Chamberable = false

SWEP.HipSpread = 0.048
SWEP.AimSpread = 0.0075
SWEP.VelocitySensitivity = 1.85
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.015
SWEP.SpreadCooldown = 0.5
SWEP.Shots = 1
SWEP.Damage = 55
SWEP.DeployTime = 1
--PATH addons/swb_css/lua/weapons/swb_awp/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "AWP"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-7.467, -9.525, 2.279)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(0, 0, 0)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ViewModelMovementScale = 1.25
	
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("scope/gdcw_scopesight")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 70
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 40
	SWEP.MaxZoom = 80
	
	SWEP.IconLetter = "r"
	
	SWEP.MuzzleEffect = "swb_sniper"
end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 40
SWEP.BulletDiameter = 8.58
SWEP.CaseLength = 69.20

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"bolt"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_snip_awp.mdl"
SWEP.WorldModel		= "models/weapons/w_snip_awp.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 10
SWEP.Primary.DefaultClip	= 10
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "buckshot"

SWEP.FireDelay = 1.5
SWEP.FireSound = Sound("Weapon_AWP.Single")
SWEP.Recoil = 5

SWEP.HipSpread = 0.06
SWEP.AimSpread = 0.0001
SWEP.VelocitySensitivity = 2.2
SWEP.MaxSpreadInc = 0.05
SWEP.SpreadPerShot = 0.05
SWEP.SpreadCooldown = 1.44
SWEP.Shots = 1
SWEP.Damage = 100
SWEP.DeployTime = 1
--PATH addons/swb_base/lua/weapons/swb_base/sh_sounds.lua:
--[[
You can use this function to create weapon sound scripts if you plan to make weapons with separate sounds
Example usage:
SWB_RegisterSound("ExampleSound", "path/to/example/sound.format", 100)

Supported formats: .wav, .mp3, .ogg
The 'level' argument indicates how far the sound will be audible.
The 'pstart' and 'pend' arguments dictate the random pitch that will be used when the sound is played.
]]--

function SWB_RegisterSound(n, s, l, pstart, pend)
	local tbl = {channel = CHAN_STATIC,
		volume = 1,
		level = l,
		name = n,
		sound = s,
		pitchstart = pstart,
		pitchend = pend}
	
	sound.Add(tbl)
end

SWB_RegisterSound("SWB_Empty", "weapons/shotgun/shotgun_empty.wav", 60, 95, 112)
SWB_RegisterSound("SWB_Knife_Hit", {"weapons/knife/knife_hit1.wav", "weapons/knife/knife_hit2.wav", "weapons/knife/knife_hit3.wav", "weapons/knife/knife_hit4.wav"}, 70, 92, 122)
SWB_RegisterSound("SWB_Knife_HitElse", "weapons/knife/knife_hitwall1.wav", 70, 92, 122)
SWB_RegisterSound("SWB_Knife_Swing", {"weapons/knife/knife_slash1.wav", "weapons/knife/knife_slash2.wav"}, 65, 92, 122)
--PATH addons/swb_base/lua/weapons/swb_base/cl_calcview.lua:
local FT, CT, cos1, cos2, ws, vel, att, ang
local Ang0, curang, curviewbob = Angle(0, 0, 0), Angle(0, 0, 0), Angle(0, 0, 0)
local reg = debug.getregistry()
local GetVelocity = reg.Entity.GetVelocity
local Length = reg.Vector.Length
local Right = reg.Angle.Right
local Up = reg.Angle.Up
local Forward = reg.Angle.Forward
local RotateAroundAxis = reg.Angle.RotateAroundAxis

SWEP.LerpBackSpeed = 10

function SWEP:CalcView(ply, pos, ang, fov)
	FT, CT = FrameTime(), CurTime()
	
	if self.ReloadViewBobEnabled then
		if self.IsReloading and self.Cycle <= 0.9 then
			att = self.Owner:GetAttachment(1)
			
			if att then
				ang = ang * 1
				
				self.LerpBackSpeed = 1
				curang = LerpAngle(FT * 10, curang, (ang - att.Ang) * 0.1)
			else
				self.LerpBackSpeed = math.Approach(self.LerpBackSpeed, 10, FT * 50)
				curang = LerpAngle(FT * self.LerpBackSpeed, curang, Ang0)
			end
		else
			self.LerpBackSpeed = math.Approach(self.LerpBackSpeed, 10, FT * 50)
			curang = LerpAngle(FT * self.LerpBackSpeed, curang, Ang0)
		end
		
		RotateAroundAxis(ang, Right(ang), curang.p * self.RVBPitchMod)
		RotateAroundAxis(ang, Up(ang), curang.r * self.RVBYawMod)
		RotateAroundAxis(ang, Forward(ang), (curang.p + curang.r) * 0.15 * self.RVBRollMod)
	end
	
	if self.dt.State == SWB_AIMING then
		if self.DelayedZoom then
			if CT > self.AimTime then
				if self.SnapZoom then
					self.CurFOVMod = self.ZoomAmount
				else
					self.CurFOVMod = Lerp(FT * 10, self.CurFOVMod, self.ZoomAmount)
				end
			else
				self.CurFOVMod = Lerp(FT * 10, self.CurFOVMod, 0)
			end
		else
			if self.SnapZoom then
				self.CurFOVMod = self.ZoomAmount
			else
				self.CurFOVMod = Lerp(FT * 10, self.CurFOVMod, self.ZoomAmount)
			end
		end
	else
		self.CurFOVMod = Lerp(FT * 10, self.CurFOVMod, 0)
	end
	
	fov = math.Clamp(fov - self.CurFOVMod, 5, 90)
	
	if self.Owner then
		if self.ViewbobEnabled then
			ws = self.Owner:GetWalkSpeed()
			vel = Length(GetVelocity(self.Owner))
			
			if self.Owner:OnGround() and vel > ws * 0.3 then
				if vel < ws * 1.2 then
					cos1 = math.cos(CT * 15)
					cos2 = math.cos(CT * 12)
					curviewbob.p = cos1 * 0.15
					curviewbob.y = cos2 * 0.1
				else
					cos1 = math.cos(CT * 20)
					cos2 = math.cos(CT * 15)
					curviewbob.p = cos1 * 0.25
					curviewbob.y = cos2 * 0.15
				end
			else
				curviewbob = LerpAngle(FT * 10, curviewbob, Ang0)
			end
		end
	end
	
	return pos, ang + curviewbob * self.ViewbobIntensity, fov
end

function SWEP.CreateMove(move)
	ply = LocalPlayer()
	wep = ply:GetActiveWeapon()
	
	if IsValid(wep) and wep.SWBWeapon then
		if wep.dt and wep.dt.State == SWB_AIMING and wep.AimBreathingEnabled then
			CT = CurTime()
			ang = move:GetViewAngles()
			ang.p = ang.p - math.cos(CT * 1.25) * 0.003
			
			move:SetViewAngles(ang)
		end
	end
end

hook.Add("CreateMove", "SWEP.CreateMove (SWB)", SWEP.CreateMove)

function SWEP:AdjustMouseSensitivity()
	if self.dt.State == SWB_RUNNING then
		if self.RunMouseSensMod then
			return self.RunMouseSensMod
		end
	end
	
	if self.dt.State == SWB_AIMING then
		if self.OverrideAimMouseSens then
			return self.OverrideAimMouseSens
		end
		
		return 1 - math.Clamp(self.ZoomAmount / 100, 0.1, 1)
	end
	
	return 1
end
--PATH addons/swb_css/lua/weapons/swb_famas/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "FAMAS F1"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-2.681, -3.332, 1.44)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(0, 0, -0.7)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ZoomAmount = 15
	
	SWEP.IconLetter = "t"
	
	SWEP.MuzzleEffect = "swb_rifle_med"
	SWEP.InvertShellEjectAngle = true
end

SWEP.FadeCrosshairOnAim = false

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 25
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "3burst", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_rif_famas.mdl"
SWEP.WorldModel		= "models/weapons/w_rif_famas.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 25
SWEP.Primary.DefaultClip	= 25
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.06
SWEP.FireSound = Sound("Weapon_FAMAS.Single")
SWEP.Recoil = 1.15

SWEP.HipSpread = 0.05
SWEP.AimSpread = 0.003
SWEP.VelocitySensitivity = 2
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.1
SWEP.Shots = 1
SWEP.Damage = 24
SWEP.DeployTime = 1
--PATH addons/swb_css/lua/weapons/swb_g3sg1/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "G3SG/1"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-6.204, -10.476, 1.858)
	SWEP.AimAng = Vector(0, 0, 0)
		
	SWEP.SprintPos = Vector(0, 0, 0)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 70
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 40
	SWEP.MaxZoom = 80
	
	SWEP.IconLetter = "i"
	
	SWEP.MuzzleEffect = "swb_rifle_large"
	SWEP.InvertShellEjectAngle = true
end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 30
SWEP.BulletDiameter = 7.62
SWEP.CaseLength = 51

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_snip_g3sg1.mdl"
SWEP.WorldModel		= "models/weapons/w_snip_g3sg1.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 20
SWEP.Primary.DefaultClip	= 20
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.12
SWEP.FireSound = Sound("Weapon_G3SG1.Single")
SWEP.Recoil = 1.6

SWEP.HipSpread = 0.055
SWEP.AimSpread = 0.0002
SWEP.VelocitySensitivity = 2.2
SWEP.MaxSpreadInc = 0.05
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.15
SWEP.Shots = 1
SWEP.Damage = 48
SWEP.DeployTime = 1
--PATH addons/swb_css/lua/weapons/swb_tmp/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Steyr TMP"
	SWEP.CSMuzzleFlashes = true

	SWEP.AimPos = Vector(-2.6, -3.072, 1.639)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(0.736, -3.971, 1.802)
	SWEP.SprintAng = Vector(-13.205, 37.048, 0)
	
	SWEP.ZoomAmount = 15
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "d"
	SWEP.NoStockMuzzle = true
	
	SWEP.MuzzleEffect = "swb_silenced_small"
end

SWEP.FadeCrosshairOnAim = false

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 15
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_smg1_ttt"

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "Pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_smg_tmp.mdl"
SWEP.WorldModel		= "models/weapons/w_smg_tmp.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.0666
SWEP.FireSound = Sound("Weapon_TMP.Single")
SWEP.Recoil = 0.7

SWEP.HipSpread = 0.037
SWEP.AimSpread = 0.013
SWEP.VelocitySensitivity = 1.3
SWEP.MaxSpreadInc = 0.05
SWEP.SpreadPerShot = 0.007
SWEP.SpreadCooldown = 0.1
SWEP.Shots = 1
SWEP.Damage = 18
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 3.5
--PATH addons/swb_css/lua/weapons/swb_ump/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "HK UMP .45"
	SWEP.CSMuzzleFlashes = true

	SWEP.AimPos = Vector(-8.721, -9.707, 4.081)
	SWEP.AimAng = Vector(-1.331, -0.281, -2.579)
	
	SWEP.SprintPos = Vector(0.736, -3.971, 3)
	SWEP.SprintAng = Vector(-13.205, 37.048, 0)
	
	SWEP.ZoomAmount = 15
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "q"
	
	SWEP.MuzzleEffect = "swb_rifle_small"
end

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 20
SWEP.BulletDiameter = 11.5
SWEP.CaseLength = 22.8

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_smg1_ttt"

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "smg"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_smg_ump45.mdl"
SWEP.WorldModel		= "models/weapons/w_smg_ump45.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 25
SWEP.Primary.DefaultClip	= 25
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("Weapon_UMP45.Single")
SWEP.Recoil = 0.8

SWEP.HipSpread = 0.041
SWEP.AimSpread = 0.01
SWEP.VelocitySensitivity = 1.4
SWEP.MaxSpreadInc = 0.05
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.1
SWEP.Shots = 1
SWEP.Damage = 21
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 3.5
--PATH addons/swb_css/lua/weapons/swb_xm1014/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "XM1014"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-6.886, -8.721, 2.691)
	SWEP.AimAng = Vector(-0.213, -0.787, -1.463)
		
	SWEP.SprintPos = Vector(3.957, -4.112, 1.013)
	SWEP.SprintAng = Vector(-8.613, 32.743, 0)
	
	SWEP.ZoomAmount = 5
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "shotshell"
	
	SWEP.IconLetter = "B"
	
	SWEP.MuzzleEffect = "swb_shotgun"
end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 5
SWEP.CaseLength = 10

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_box_buckshot_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "shotgun"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_shot_xm1014.mdl"
SWEP.WorldModel		= "models/weapons/w_shot_xm1014.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 7
SWEP.Primary.DefaultClip	= 7
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "buckshot"

SWEP.FireDelay = 0.2
SWEP.FireSound = Sound("Weapon_XM1014.Single")
SWEP.Recoil = 2.5
SWEP.ShotgunReload = true
SWEP.ReloadStartWait = 0.6
SWEP.ReloadFinishWait = 0.7
SWEP.ReloadShellInsertWait = 0.6
SWEP.Chamberable = false

SWEP.HipSpread = 0.036
SWEP.AimSpread = 0.003
SWEP.ClumpSpread = 0.012
SWEP.VelocitySensitivity = 2.2
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.02
SWEP.SpreadCooldown = 1.03
SWEP.Shots = 12
SWEP.Damage = 10
SWEP.DeployTime = 1
--PATH addons/_avatar/lua/weapons/weapon_air_bending.lua:
SWEP.Category = "Avatar"
SWEP.PrintName = "Air Bending"
SWEP.Author = "Kilburn, robotboy655, MaxOfS2D, Tenrys & Kurome76" -- changing this will void your support
SWEP.Purpose = "Bend Air."
SWEP.Slot = 1
SWEP.SlotPos = 10
SWEP.Spawnable = true
SWEP.ViewModel = Model( "models/weapons/c_arms.mdl" )
SWEP.WorldModel = ""
SWEP.ViewModelFOV = 54
SWEP.UseHands = true
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.DrawAmmo = false
local SwingSound = Sound( "WeaponFrag.Throw" )
sound.Add( {
	name = "bending.tornado",
	channel = CHAN_AUTO,
	volume = 1.0,
	level = 75,
	pitch = { 100, 100 },
	sound = "ambient/levels/canals/windmill_wind_loop1.wav"
} )

function SWEP:Initialize()
	self:SetHoldType( "fist" )
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Float", 0, "NextMeleeAttack" )
	self:NetworkVar( "Float", 1, "NextIdle" )
end

function SWEP:GetViewModelPosition( pos, ang )
	--this is always applied
	local DefPos = Vector( 0, 0, -1 )
	local DefAng = Vector( 0, 0, 0 )
	if DefAng then
		ang = ang * 1
		ang:RotateAroundAxis( ang:Right(), DefAng.x )
		ang:RotateAroundAxis( ang:Up(), DefAng.y )
		ang:RotateAroundAxis( ang:Forward(), DefAng.z )
	end

	if DefPos then
		local Right = ang:Right()
		local Up = ang:Up()
		local Forward = ang:Forward()
		pos = pos + DefPos.x * Right
		pos = pos + DefPos.y * Forward
		pos = pos + DefPos.z * Up
	end
	return pos, ang
end

function SWEP:UpdateNextIdle()
	local vm = self:GetOwner():GetViewModel()
	self:SetNextIdle( CurTime() + vm:SequenceDuration() / vm:GetPlaybackRate() )
end

function SWEP:PrimaryAttack()
	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
	local anim = "fists_left"
	if math.random() < 0.5 then anim = "fists_right" end
	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( anim ) )
	self:EmitSound( SwingSound )
	self:UpdateNextIdle()
	self:SetNextMeleeAttack( CurTime() + 0.2 )
	self:SetNextPrimaryFire( CurTime() + 0.9 )
	self:SetNextSecondaryFire( CurTime() + 0.9 )
end

function SWEP:SecondaryAttack()
	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "fists_uppercut" ) )
	self:EmitSound( SwingSound )
	self:UpdateNextIdle()
	if SERVER then
		local srcpos = self:GetOwner():GetShootPos() + self:GetOwner():GetForward() * 64
		local tr = util.TraceLine( {
			start = srcpos,
			endpos = srcpos + vector_up * -110,
			filter = self:GetOwner()
		} )

		if tr.Hit then
			local tornadoe = ents.Create( "prop_dynamic" )
			tornadoe:SetModel( "models/blackout.mdl" )
			tornadoe:SetAngles( self:GetOwner():EyeAngles() )
			tornadoe:SetPos( tr.HitPos + tr.HitNormal * 128 )
			tornadoe:SetColor( Color( 255, 255, 255, 255 ) )
			tornadoe:SetRenderMode( RENDERMODE_NORMAL )
			tornadoe:SetKeyValue( "solid", "6" )
			--tornadoe:SetParent(ply)
			tornadoe:Spawn()
			tornadoe:Activate()
			tornadoe.DoNotDuplicate = true
			tornadoe:SetOwner( self:GetOwner() )
			tornadoe:Fire( "kill", "", 8 )
			tornadoe:EmitSound( "bending.tornado" )
			tornadoe:CallOnRemove( "NoWind", function( ent ) ent:StopSound( "bending.tornado" ) end )
			--sound.Play("physics/concrete/boulder_impact_hard"..math.random(1,4)..".wav",tr.HitPos)
			util.ScreenShake( tr.HitPos, 5, 5, 1, 256 )
			tornadoeSmok = ents.Create( "env_smokestack" )
			tornadoeSmok:SetPos( tornadoe:GetPos() + vector_up * -90 )
			tornadoeSmok:SetKeyValue( "InitialState", "1" )
			tornadoeSmok:SetKeyValue( "WindAngle", self:GetOwner():GetAimVector():Angle().y .. " 0 0" )
			tornadoeSmok:SetKeyValue( "WindSpeed", "200" )
			tornadoeSmok:SetKeyValue( "rendercolor", "150 150 100" )
			tornadoeSmok:SetKeyValue( "renderamt", "60" )
			tornadoeSmok:SetKeyValue( "BaseSpread", "50" )
			tornadoeSmok:SetKeyValue( "SmokeMaterial", "particle/smokesprites_0001.vmt" )
			tornadoeSmok:SetKeyValue( "SpreadSpeed", "5" )
			tornadoeSmok:SetKeyValue( "Speed", "100" )
			tornadoeSmok:SetKeyValue( "StartSize", "90" )
			tornadoeSmok:SetKeyValue( "EndSize", "90" )
			tornadoeSmok:SetKeyValue( "roll", "1000" )
			tornadoeSmok:SetKeyValue( "Rate", "100" )
			tornadoeSmok:SetKeyValue( "JetLength", "400" )
			tornadoeSmok:SetKeyValue( "twist", "5" )
			tornadoeSmok:SetParent( tornadoe )
			tornadoeSmok:Spawn()
			tornadoeSmok:Activate()
			tornadoeSmok:Fire( "turnon", "", 0.01 )
			tornadoeSmok:Fire( "turnoff", "", 6.5 )
			tornadoeSmok:Fire( "kill", "", 8 )
			for i = 0, 600 do
				timer.Simple( i / 100, function()
					if IsValid( tornadoe ) then
						local srcpos = tornadoe:GetPos() + vector_up * -0.5
						local ownr = tornadoe:GetOwner()
						local dtr = util.TraceLine( {
							start = srcpos,
							endpos = srcpos + vector_up * -400
						} )

						--filter = ownr
						tornadoe:SetPos( Vector( tornadoe:GetPos().x, tornadoe:GetPos().y, ( dtr.HitPos + dtr.HitNormal * 64 ).z ) + tornadoe:GetForward() * 3 )
						local htr = util.TraceLine( {
							start = srcpos,
							endpos = srcpos + tornadoe:GetForward() * 64
						} )

						--filter = ownr
						if htr.HitWorld then
							tornadoe:Remove()
							return
						end

						local dmginfo = DamageInfo()
						dmginfo:SetAttacker( ownr )
						dmginfo:SetInflictor( tornadoe )
						dmginfo:SetDamage( math.random( 30, 60 ) )
						dmginfo:SetDamageForce( vector_up * 5000 )
						dmginfo:SetDamageType( DMG_FALL )
						for _, v in ipairs( ents.FindAlongRay( srcpos + vector_up * -128, srcpos + vector_up * 600, Vector( -128, -128, -128 ), Vector( 128, 128, 128 ) ) ) do
							if v ~= ownr and IsValid( v ) and not v:IsWeapon() then
								local phys = v:GetPhysicsObject()
								if IsValid( phys ) then phys:ApplyForceOffset( vector_up * ( 80 + phys:GetMass() * 40 ), tornadoe:GetPos() ) end
								v:TakeDamageInfo( dmginfo )
								if v:IsPlayer() or v:IsNPC() or v.Type == "nextbot" then
									v:SetVelocity( vector_up * 50 )
									if v.Type == "nextbot" then v.loco:SetVelocity( vector_up * 50 ) end
								end
							end
						end

						util.ScreenShake( dtr.HitPos, 2, 2, 0.2, 128 )
					end
				end )
			end
		end
	end

	self:SetNextPrimaryFire( CurTime() + 0.9 )
	self:SetNextSecondaryFire( CurTime() + 0.9 )
end

local windSounds = { "ambient/wind/windgust.wav", "ambient/wind/wind_hit1.wav", "ambient/wind/wind_hit2.wav", "ambient/wind/wind_hit3.wav" }
function SWEP:GetHeadPos( ent )
	local model = ent:GetModel() or ""
	if model:find( "crow" ) or model:find( "seagull" ) or model:find( "pigeon" ) then
		return ent:LocalToWorld( ent:OBBCenter() + Vector( 0, 0, -5 ) )
	elseif ent:GetAttachment( ent:LookupAttachment( "eyes" ) ) ~= nil then
		return ent:GetAttachment( ent:LookupAttachment( "eyes" ) ).Pos
	else
		return ent:LocalToWorld( ent:OBBCenter() )
	end
end

function SWEP:DealDamage()
	--local anim = self:GetSequenceName(self:GetOwner():GetViewModel():GetSequence())
	if SERVER then
		local snd = table.Random( windSounds )
		self:GetOwner():EmitSound( snd, 85 )
		for i = 0, 25 do
			timer.Simple( 0.2 + i / 10, function()
				if not IsValid( self ) then return end
				if not IsValid( self:GetOwner() ) then return end
				for g = 0, 10 do
					local srcpos = self:GetOwner():GetShootPos()
					local forward = self:GetOwner():GetAimVector()
					local dtr = util.TraceLine( {
						start = srcpos + forward * 90 * g,
						endpos = srcpos + forward * 90 * g + vector_up * -400
					} )

					--filter = ownr
					local effectdata = EffectData()
					effectdata:SetOrigin( dtr.HitPos )
					effectdata:SetScale( math.random( 50, 120 ) )
					effectdata:SetEntity( self:GetOwner() )
					util.Effect( "ThumperDust", effectdata )
					util.ScreenShake( dtr.HitPos, 2, 2, 0.2, 128 )
					if i == 0 then sound.Play( snd, dtr.HitPos, 70, 100, 0.4 ) end
				end

				self:GetOwner():SetVelocity( self:GetOwner():GetAimVector() * -100 )
				local dmginfo = DamageInfo()
				dmginfo:SetAttacker( self:GetOwner() )
				dmginfo:SetInflictor( self )
				dmginfo:SetDamage( math.random( 8, 12 ) )
				dmginfo:SetDamageForce( self:GetOwner():GetAimVector() * 5000 )
				dmginfo:SetDamageType( DMG_CRUSH )
				local srcpos = self:GetOwner():GetShootPos()
				local aim = self:GetOwner():GetAimVector()
				for _, v in ipairs( ents.FindAlongRay( srcpos, srcpos + aim * 800, Vector( -85, -85, -85 ), Vector( 85, 85, 85 ) ) ) do
					if v ~= self:GetOwner() and IsValid( v ) and not v:IsWeapon() and self:GetOwner():IsLineOfSightClear( self:GetHeadPos( v ) + vector_up * 4 ) then
						local phys = v:GetPhysicsObject()
						if IsValid( phys ) then phys:ApplyForceOffset( aim * ( 80 + phys:GetMass() * 20 ), self:GetOwner():GetShootPos() ) end
						v:TakeDamageInfo( dmginfo )
						if v:IsPlayer() or v:IsNPC() or v.Type == "nextbot" then
							v:SetVelocity( self:GetOwner():GetAimVector() * 500 )
							if v.Type == "nextbot" then v.loco:SetVelocity( self:GetOwner():GetAimVector() * 500 ) end
						end
					end
				end
			end )
		end
		--self.part:SetParent(self:GetOwner())
	end
end

function SWEP:Think()
	local vm = self:GetOwner():GetViewModel()
	local idletime = self:GetNextIdle()
	if idletime > 0 and CurTime() > idletime then
		vm:SendViewModelMatchingSequence( vm:LookupSequence( "fists_idle_0" .. math.random( 1, 2 ) ) )
		self:UpdateNextIdle()
	end

	local meleetime = self:GetNextMeleeAttack()
	if meleetime > 0 and CurTime() > meleetime then
		self:DealDamage()
		self:SetNextMeleeAttack( 0 )
	end
end

function SWEP:Deploy()
	local speed = GetConVar( "sv_defaultdeployspeed" ):GetInt()
	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "fists_draw" ) )
	vm:SetPlaybackRate( speed )
	self:SetNextPrimaryFire( CurTime() + vm:SequenceDuration() / speed )
	self:SetNextSecondaryFire( CurTime() + vm:SequenceDuration() / speed )
	self:UpdateNextIdle()
	return true
end

function SWEP:Holster()
	self:SetNextMeleeAttack( 0 )
	return true
end

function SWEP:OnRemove()
	self:Holster()
	return true
end

function SWEP:OnDrop()
	self:Holster()
	self:Remove() -- You can't drop fists
end

function SWEP:DrawHUD()
	local x, y = ScrW(), ScrH()
	local w, h = x * 0.5, y * 0.5
	draw.SimpleTextOutlined( "Стихія: Повітря", onyx.Font( "Comfortaa@24" ), w, y - h / 8, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, color_black )
end
--PATH addons/__main/lua/weapons/weapon_armorkit/cl_init.lua:
include("shared.lua")
include("animations.lua")

SWEP.Category = "Other"

SWEP.UseHands = true
SWEP.DrawAmmo = true
SWEP.DrawCrosshair = true
SWEP.ViewModelFOV = 60

SWEP.Slot = 5
SWEP.SlotPos = 3

SWEP.ShowWorldModel = false--true
SWEP.ShowViewModel = false

SWEP.WCustom = false--true
SWEP.WBone = "ValveBiped.Bip01_R_Hand"
SWEP.WPos = Vector(4,2,3)
SWEP.WAng = Angle(180,-90-45,15)

SWEP.VElements = {
	--["armorkit"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(0,0,1.5), angle = Angle(180,180,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	["armorkit"] = { type = "Model", model = "models/items/battery.mdl", bone = "medkit_bone", rel = "", pos = Vector(-0.5,4,-1.5), angle = Angle(90,185,90), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["armorkit+"] = { type = "Model", model = "models/items/battery.mdl", bone = "medkit_bone", rel = "armorkit", pos = Vector(0,3,0), angle = Angle(0,90,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["armorkit++"] = { type = "Model", model = "models/items/battery.mdl", bone = "medkit_bone", rel = "armorkit", pos = Vector(0,-3,0), angle = Angle(0,-90,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
--	["armorkit"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.5,3,2), angle = Angle(180,180,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	["armorkit"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4,5.5,2.5), angle = Angle(190,20,-10), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["armorkit+"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "armorkit", pos = Vector(0,3,0), angle = Angle(0,90,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["armorkit++"] = { type = "Model", model = "models/items/battery.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "armorkit", pos = Vector(0,-3,0), angle = Angle(0,-90,0), size = Vector(0.7, 0.7, 0.7), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

function SWEP:OnRemove()
	self:Anim_OnRemove()
end

function SWEP:ViewModelDrawn()
	self:Anim_ViewModelDrawn()
end

function SWEP:PreDrawViewModel(vm)
	if self.ShowViewModel == false then
		render.SetBlend(0)
	end
end

function SWEP:PostDrawViewModel(vm)
	if self.ShowViewModel == false then
		render.SetBlend(1)
	end
end

function SWEP:DrawWorldModel()
	self:Anim_DrawWorldModel()
end

--PATH addons/__main/lua/weapons/weapon_cf_base.lua:
if SERVER then AddCSLuaFile() end
SWEP.Category = "Weapons"
SWEP.Author = "SWEP by UnkN\nModel by ClearSkyC"
SWEP.Base = "weapon_base"
SWEP.UseHands = true
SWEP.HoldType = "pistol"
SWEP.Spawnable = false
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.MeleeRange = 50
SWEP.MeleeDamage = 54
SWEP.DeployDuration = 0.5
SWEP.MeleeDuration = 1
SWEP.MuzzleAttach = 1
SWEP.MuzzleScale = 1
SWEP.MeleeSequence = 9
SWEP.ReloadSequence = 7
SWEP.DeploySequence = 4
local swing, hitsnd, mins, maxs, punch = { "weapons/knife/knife_slash1.wav", "weapons/knife/knife_slash2.wav" }, { "weapons/knife/knife_hit1.wav", "weapons/knife/knife_hit2.wav", "weapons/knife/knife_hit3.wav", "weapons/knife/knife_hit4.wav" }, Vector( -10, -10, -10 ), Vector( 10, 10, 10 ), Angle( 0, 3, 0 )
function SWEP:Initialize()
	self:SetWeaponHoldType( self.HoldType )
	self.NextReload = 0
	self.ChargeShoot = 0
end

local function GetRandDamage( dmg, mul )
	local adddmg = dmg * mul
	return dmg + math.random( -adddmg, 0 )
end

function SWEP:AttackTrace()
	local o = self:GetOwner()
	o:LagCompensation( true )
	local sp, av = o:GetShootPos(), o:GetAimVector()
	local ran = sp + av * self.MeleeRange
	local tr = util.TraceHull( {
		filter = o,
		start = sp,
		mask = MASK_SHOT_HULL,
		endpos = ran,
		mins = mins,
		maxs = maxs
	} )

	if tr.Hit then
		o:ViewPunch( punch )
		local ent = tr.Entity
		if IsValid( ent ) then
			local dmg = DamageInfo()
			dmg:SetDamage( GetRandDamage( self.MeleeDamage, 0.1 ) )
			dmg:SetAttacker( o )
			dmg:SetInflictor( self )
			dmg:SetDamageForce( av * 10 )
			dmg:SetDamagePosition( tr.HitPos )
			dmg:SetDamageType( DMG_SLASH )
			ent:DispatchTraceAttack( dmg, sp, ran )
			if ent:IsPlayer() or ent:IsNPC() or ent.Type == "nextbot" or ent:GetClass() == "prop_ragdoll" then
				self:EmitSound( hitsnd[math.random( 1, 4 )] )
			else
				self:EmitSound( "weapons/knife/knife_hitwall1.wav" )
			end
		elseif tr.HitWorld then
			self:EmitSound( "weapons/knife/knife_hitwall1.wav" )
		end

		util.Decal( "ManhackCut", sp, ran )
	else
		self:EmitSound( self.MeleeSound or swing[math.random( 1, 2 )] )
	end

	o:LagCompensation( false )
end

DMG_THROUGHTWALL = bit.bor( DMG_AIRBOAT, DMG_ENERGYBEAM )
function SWEP:BulletPenetrate( attacker, tr, dmginfo )
	if CLIENT then return end
	local mat = tr.MatType
	if mat == MAT_SAND then return false end
	local dir = tr.Normal * 16
	if mat == MAT_GLASS or mat == MAT_PLASTIC or mat == MAT_WOOD or mat == MAT_FLESH or mat == MAT_ALIENFLESH then dir = tr.Normal * 32 end
	local trace = {
		start = tr.HitPos + dir,
		endpos = tr.HitPos,
		mask = MASK_SHOT
	}

	trace = util.TraceLine( trace )
	if trace.StartSolid or trace.Fraction >= 1 or tr.Fraction <= 0 then return false end
	local fDamageMulti = 0.5
	if mat == MAT_CONCRETE then
		fDamageMulti = 0.3
	elseif mat == MAT_WOOD or mat == MAT_PLASTIC or mat == MAT_GLASS then
		fDamageMulti = 0.8
	end

	local bullet = {
		Num = 1,
		Src = trace.HitPos,
		Dir = tr.Normal,
		Spread = vector_origin,
		Tracer = 1,
		TracerName = "effect_penetration_trace",
		Force = 5,
		Damage = dmginfo:GetDamage() * fDamageMulti,
		HullSize = 2
	}

	if bullet.Damage > 1 then
		bullet.Callback = function( a, b, c )
			c:SetDamageType( DMG_THROUGHTWALL )
			if IsValid( self ) and self.BulletPenetrate then self:BulletPenetrate( a, b, c ) end
		end
	end

	timer.Simple( 0.05, function()
		if not IsFirstTimePredicted() then return end
		if attacker then attacker.FireBullets( attacker, bullet, true ) end
	end )
	return true
end

local CurTime, single = CurTime, game.SinglePlayer()
function SWEP:FireAnimationEvent( _, _, event )
	if event == 21 then
		local fx = EffectData()
		fx:SetEntity( self:GetOwner():GetViewModel() )
		fx:SetAttachment( self.MuzzleAttach )
		fx:SetScale( self.MuzzleScale )
		util.Effect( "CS_MuzzleFlash", fx )
		return true
	end
end

function SWEP:Muzzle()
	local o = self:GetOwner()
	if o:ShouldDrawLocalPlayer() then
		local fx = EffectData()
		fx:SetEntity( self )
		fx:SetOrigin( o:GetShootPos() )
		fx:SetNormal( o:GetAimVector() )
		fx:SetAttachment( 1 )
		fx:SetScale( self.MuzzleScale )
		util.Effect( "CS_MuzzleFlash", fx )
	end

	if self.ShellEffect then
		local vm = o:GetViewModel()
		if not IsValid( vm ) then return end
		local att = vm:LookupAttachment( "shell" )
		if not att or att < 0 then
			self.ShellEffect = nil
			return
		end

		local angpos = vm:GetAttachment( att )
		if angpos and angpos.Pos then
			local fx = EffectData()
			fx:SetEntity( vm )
			fx:SetOrigin( angpos.Pos )
			fx:SetAttachment( att )
			fx:SetAngles( angpos.Ang )
			util.Effect( "RifleShellEject", fx )
		end
	end
end

local max, min, ceil = math.max, math.min, math.ceil
function SWEP:PrimaryAttack()
	if not self:CanPrimaryAttack() then return end
	if single then self:CallOnClient( "Muzzle" ) end
	self:EmitSound( self.Primary.Sound )
	local o, ct = self:GetOwner(), CurTime()
	local sp, av = o:GetShootPos(), o:GetAimVector()
	self:TakePrimaryAmmo( 1 )
	local bullet = {
		Num = self.Primary.NumShots,
		Src = sp,
		Dir = av,
		Tracer = 1,
		TracerName = "Tracer",
		Force = 5,
		Damage = GetRandDamage( self.Primary.Damage, 0.25 )
	}

	local mult = 1
	if not o:IsOnGround() then
		mult = 3
	else
		local vel = o:GetVelocity():Length2DSqr()
		if vel > 0 then mult = mult * math.Clamp( vel * 0.000025, 1, 5 ) end
		if o:Crouching() then mult = mult * 0.5 end
	end

	local put = self.Primary.Cone * min( self.ChargeShoot * 0.05, 1 ) * mult
	bullet.Spread = Vector( put, put, put )
	bullet.Callback = function( a, b, c ) self:BulletPenetrate( a, b, c ) end
	o:FireBullets( bullet, SERVER )
	if CLIENT then self:Muzzle() end
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	o:SetAnimation( PLAYER_ATTACK1 )
	self:SetNextPrimaryFire( ct + self.Primary.Delay )
	self:SetNextSecondaryFire( ct + self.Primary.Delay )
	self.ChargeShoot = self.ChargeShoot + 5
end

function SWEP:SendWeaponSequence( seq, o )
	o = o or self:GetOwner()
	local vm = o:GetViewModel()
	if IsValid( vm ) then vm:SendViewModelMatchingSequence( seq ) end
end

function SWEP:Deploy()
	self:SetWeaponHoldType( self.HoldType )
	if self.ENUMSetup == nil then
		self.ENUMSetup = true
		pcall( self.SetupENUM, self )
	end

	self:SendWeaponSequence( self.DeploySequence )
	local ct = CurTime() + self.DeployDuration
	self:SetNextPrimaryFire( ct )
	self:SetNextSecondaryFire( ct )
	if self.CustomDeploy then return true, self:CustomDeploy( ct ) end
	return true
end

function SWEP:Holster()
	if self.NextReload > CurTime() then return false end
	return true
end

function SWEP:SecondaryAttack()
	self:SendWeaponSequence( self.MeleeSequence )
	local ct = CurTime() + self.MeleeDuration
	self:SetNextSecondaryFire( ct - 0.3 )
	self:SetNextPrimaryFire( ct )
	self.NextReload = ct - 0.3
	self:GetOwner():DoAnimationEvent( ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND )
	self.NextHit = CurTime() + self.MeleeAttack
	self.ChargeShoot = max( self.ChargeShoot - ceil( ( self.MeleeDuration - 0.4 ) * 100 ), 0 )
end

function SWEP:SetupENUM()
	local vm = self:GetOwner():GetViewModel()
	if IsValid( vm ) then
		self.ReloadSpeed = select( 2, vm:LookupSequence( "reload" ) )
	else
		self.ReloadSpeed = 0
	end
end

function SWEP:Think()
	if self.ENUMSetup == nil then
		self.ENUMSetup = true
		pcall( self.SetupENUM, self )
	end

	local ct = CurTime()
	if self.NextHit and self.NextHit <= ct then
		self:AttackTrace()
		self.NextHit = nil
	end

	if self.ChargeShoot ~= 0 and self:GetNextPrimaryFire() + self.Primary.Delay < ct then self.ChargeShoot = self.ChargeShoot - 1 end
end

function SWEP:Reload()
	if CurTime() < self.NextReload then return end
	if self:DefaultReload( ACT_VM_RELOAD ) then
		self:SendWeaponSequence( self.ReloadSequence )
		self.ChargeShoot = max( self.ChargeShoot - ceil( self.ReloadSpeed * 100 ), 0 )
		self:GetOwner():SetAnimation( PLAYER_RELOAD )
	end
end
--PATH addons/__main/lua/weapons/weapon_hl2pickaxe/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Pickaxe"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack : Push"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pickaxe.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_pickaxe.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 40
SWEP.HitInclination		= 0.4
SWEP.HitPushback		= 1000
SWEP.HitRate			= 1.35
SWEP.MinDamage			= 34
SWEP.MaxDamage			= 50

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 1.5 * 40,
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

	if ( tr.Hit ) then
	self:EmitSound( PushSoundBody )
	if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
	tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * 500 )
	end
	end

end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 15
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 34, 50 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()
	
	timer.Remove("hitdelay")
	return true
end
--PATH addons/__main/lua/weapons/weapon_hl2pipe/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Pipe"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pipe.mdl" )
SWEP.WorldModel				= Model( "models/props_canal/mattpipe.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 40
SWEP.HitInclination		= 0.2
SWEP.HitPushback		= 400
SWEP.HitRate			= 1.10
SWEP.MinDamage			= 20
SWEP.MaxDamage			= 27

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()
	
	return true
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 10
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 34, 50 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay")
	return true
end
--PATH addons/__main_only_1st/lua/weapons/weapon_shield.lua:
if SERVER then
	SWEP.Weight = 0
	SWEP.AutoSwitchFrom = false
	SWEP.AutoSwitchTo = false
end

SWEP.PrintName = 'Riot Shield'
SWEP.Author = ''
SWEP.Purpose = 'To Defend Against The Evil Powers'
SWEP.Instructions = ''
SWEP.Category = 'RP'
SWEP.Slot = 4
SWEP.SlotPos = 3
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.ViewModel = ''
SWEP.WorldModel = ''
SWEP.AnimPrefix = 'rpg'
SWEP.Base = 'weapon_rp_base'
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = 'none'
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = 'none'
SWEP.HoldType = 'normal'
function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:Deploy()
	if SERVER then
		if IsValid( self.ent ) or not IsValid( self:GetOwner() ) then return end
		self.ent = ents.Create( 'prop_physics' )
		self.ent:SetModel( 'models/custom/ballisticshield.mdl' )
		self.ent:SetPos( self:GetOwner():GetPos() + Vector( ( Angle( 0, self:GetOwner():GetAngles().y, 0 ):Forward() * 20 ).x, ( Angle( 0, self:GetOwner():GetAngles().y, 0 ):Forward() * 20 ).y, 38 ) )
		self.ent:SetAngles( Angle( 0, self:GetOwner():EyeAngles().y, 0 ) )
		self.ent:SetParent( self:GetOwner() )
		self.ent:Fire( 'SetParentAttachmentMaintainOffset', 'eyes', 0.01 ) -- Garry fucked up the parenting on players in latest patch..
		self.ent:SetCollisionGroup( COLLISION_GROUP_WORLD )
		self.ent:Spawn()
		self.ent:Activate()
	end
	return true
end

local sounds = { Sound( 'physics/body/body_medium_impact_hard1.wav' ), Sound( 'physics/body/body_medium_impact_hard2.wav' ), Sound( 'physics/body/body_medium_impact_hard3.wav' ), Sound( 'physics/body/body_medium_impact_hard4.wav' ), Sound( 'physics/body/body_medium_impact_hard5.wav' ), Sound( 'physics/body/body_medium_impact_hard6.wav' ) }
function SWEP:PrimaryAttack()
	if SERVER then
		if not IsValid( self:GetOwner() ) then return end
		local trdata = {}
		trdata.start = self:GetOwner():GetShootPos()
		trdata.endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * 100
		trdata.filter = self:GetOwner()
		trdata.mins = self:GetOwner():OBBMins() * .4
		trdata.maxs = self:GetOwner():OBBMins() * .4
		trdata.mask = MASK_SHOT_HULL
		local tr = util.TraceHull( trdata )
		if not IsValid( tr.Entity ) then return false end
		if tr.Entity:IsPlayer() and tr.Entity:OnGround() then
			tr.Entity:SetVelocity( ( tr.Entity:GetPos() - self:GetOwner():GetPos() ) * 3 )
			self:GetOwner():EmitSound( sounds[math.random( 1, #sounds )] )
		end

		local nextuse = CurTime() + 0.5
		self:SetNextPrimaryFire( nextuse )
		self:SetNextSecondaryFire( nextuse )
	end
	return true
end

function SWEP:SecondaryAttack()
	self:PrimaryAttack()
end

function SWEP:Holster()
	if SERVER and IsValid( self.ent ) then self.ent:Remove() end
	return true
end

function SWEP:OnDrop()
	if SERVER then
		if not IsValid( self.ent ) then return end
		self.ent:Remove()
	end
end

function SWEP:OnRemove()
	if SERVER then
		if not IsValid( self.ent ) then return end
		self.ent:Remove()
	end
end

function SWEP:Think()
	if SERVER then
		if not IsValid( self.ent ) then
			self:GetOwner():SelectWeapon( 'weapon_physgun' )
			timer.Simple( .1, function() if IsValid( self:GetOwner() ) then self:GetOwner():SelectWeapon( 'weapon_shield' ) end end )
		end

		if not self:GetOwner():Alive() then self.ent:Remove() end
	end
end
--PATH addons/__main/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/__main/lua/weapons/weapon_vape_medicinal.lua:
-- weapon_vape_medicinal.lua
-- Defines a vape that heals the player

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Medicinal Vape"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nThis healthy, organic juice has amazing healing abilities."

SWEP.VapeID = 3

SWEP.VapeAccentColor = Vector(0,1,0.5)
SWEP.VapeTankColor = Vector(0,0.5,0.25)

-- note: healing functionality is in weapon_vape/init.lua
--PATH addons/__main/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/__main_only_1st/lua/weapons/zen_healing_m.lua:
game.AddParticles( "particles/zen_magic_effects.pcf" )
game.AddParticles( "particles/zen_healing_effects.pcf" )
game.AddParticles( "particles/zen_health_gun.pcf" )
game.AddParticles( "particles/z_zombie_effects.pcf" )
game.AddParticles( "particles/z_regeneration_effects.pcf" )

PrecacheParticleSystem( "z_regeneration" )

PrecacheParticleSystem( "z_group_healer_zombie_radius" )
PrecacheParticleSystem( "z_group_healer_zombie_spinning_effects" )
PrecacheParticleSystem( "z_group_healer_zombie_buff" )
PrecacheParticleSystem( "z_entity_healing_effects" )

PrecacheParticleSystem( "z_h_shield" )
PrecacheParticleSystem( "z_shield_radius" )
PrecacheParticleSystem( "z_shield_heal" )
PrecacheParticleSystem( "z_shield_buff" )


PrecacheParticleSystem( "zen_life_steal" )
PrecacheParticleSystem( "zen_magic_missile_blast" )

PrecacheParticleSystem( "Zen_Ring_Buff" )


-- TODO:
-- \n\n( Walk + Primary Attack ) When your { super charge meter } is full, You can activate this and cause yourself and optionaly an ally to become invunerable for a while. [ Emptys the super charge meter ]


SWEP.PrintName              =       "Healing Magic"
SWEP.Author                 =       "Zenlenafelex [PSF]"
SWEP.Instructions           =       "( Primary Attack / Hold Down Primary Attack ) Zap an enemy dealing damage to them or zap an ally healing them a little. It will remove negative conditions from allys, Such as fire. [ Drains 2 Power ]\n\n( Secondary Attack ) Fire a bolt of regeneration at allys, Healing them over time. [ 25 Power ]\n\n( Reload ) Cast a healing circle healing allies and enemies with in the circle. [ 50 Power ]\n\n( Walk + Secondary Attack ) Zap an enemy and steal their life converting it into healing for yourself. If the enemy dies, You will be given regeneration."
SWEP.Category               =       "Other"
SWEP.Purpose                =       ""

SWEP.Spawnable              =       true
SWEP.AdminOnly              =       false

SWEP.Primary.ClipSize		=       100
SWEP.Primary.DefaultClip	=       100
SWEP.Primary.Automatic		=       false
SWEP.Primary.Ammo		    =       "none"

SWEP.Secondary.ClipSize		=       -1
SWEP.Secondary.DefaultClip	=       -1
SWEP.Secondary.Automatic	=       false
SWEP.Secondary.Ammo		    =       "none"

SWEP.Weight			        =       5
SWEP.AutoSwitchTo		    =       false
SWEP.AutoSwitchFrom		    =       false

SWEP.Slot			        =       4
SWEP.SlotPos			    =       3
SWEP.DrawAmmo			    =       true
SWEP.DrawCrosshair		    =       true

SWEP.ViewModel				=		"models/weapons/c_stunstick.mdl"
SWEP.WorldModel				=		""

SWEP.ViewModelFOV			=		8
SWEP.UseHands				=		true



if ( SERVER ) then
	
	CreateConVar( "z_gmod_spells_HealingMagic_recharge_speed" , "0.12" )
	
	CreateConVar( "z_gmod_spells_HealingMagic_devine_bolt_damage" , "4" )
	CreateConVar( "z_gmod_spells_HealingMagic_devine_bolt_heal" , "2" )
	
	CreateConVar( "z_gmod_spells_HealingMagic_radius_heal_amount" , "40" )
	CreateConVar( "z_gmod_spells_HealingMagic_radius_heal_regen_amount" , "3" )
	CreateConVar( "z_gmod_spells_HealingMagic_radius_heal_regen_speed" , "0.60" )
	CreateConVar( "z_gmod_spells_HealingMagic_radius_heal_range" , "225" )
	
	CreateConVar( "z_gmod_spells_HealingMagic_enemie_damage_min" , "8" )
	CreateConVar( "z_gmod_spells_HealingMagic_enemie_damage_max" , "16" )
	
	CreateConVar( "z_gmod_spells_HealingMagic_regen_bolt_duration" , "12" )
	CreateConVar( "z_gmod_spells_HealingMagic_regen_bolt_heal_amount" , "2" )
	CreateConVar( "z_gmod_spells_HealingMagic_regen_bolt_heal_speed" , "0.30" )
	
	CreateConVar( "z_gmod_spells_HealingMagic_life_steal_amount" , "20" )
	
	CreateConVar( "z_gmod_spells_HealingMagic_shield_range" , "225" )
	
	
	util.AddNetworkString( "ZEN_NET_H_MAGIC_BLAST" )
	util.AddNetworkString( "ZEN_NET_H_MAGIC_RADIUS" )
	util.AddNetworkString( "ZEN_NET_H_MAGIC_RADIUS_HEAL" )
	util.AddNetworkString( "Z_NET_REGEN_EFFECTS" )
	util.AddNetworkString( "Z_NET_REGEN_EFFECTS_STOP" )
	util.AddNetworkString( "Z_NET_CLEAR_SPELL_EFFECTS" )
	util.AddNetworkString( "Z_NET_MARK_INVUN" )
	util.AddNetworkString( "ZEN_NET_H_MAGIC_RADIUS_SHIELD" )

	resource.AddWorkshop(2119972050)
	
end


local function MakeInvun( ent )
	if ( CLIENT ) then return end
	if !IsValid( ent ) or !ent:IsNPC() and !ent:IsPlayer() then return end
	
	ent.IsHInvun			=	true
	
	local index				=	ent:EntIndex()
	
	timer.Create( "z_h_shield_delay" .. index , 10 , 0 , function()
		
		if IsValid( ent ) then
			
			ent.IsHInvun		=	false
			
		end
		
		timer.Remove( "z_h_shield_delay" .. index )
		timer.Remove( "z_h_shield_sound" .. index )
		
	end)
	
	timer.Create( "z_h_shield_sound" .. index , 1.50 , 0 , function()
		
		if IsValid( ent ) then
			
			ent:EmitSound( Sound( "npc/antlion/rumble1.wav" ) , 68 , 120 , 1 )
			
		else
			
			timer.Remove( "z_h_shield_sound" .. index )
			
		end
		
	end)
	
	net.Start( "Z_NET_MARK_INVUN" )
		net.WriteEntity( ent )
	net.Broadcast()
	
end

local function Z_CheckRange( start , endpos , dist )
	
	return start:DistToSqr( endpos ) < dist * dist
	
end



local function GiveRegenTo( ent )
	if !IsValid( ent ) then return end
	
	local index			=	ent:EntIndex()
	
	if timer.Exists( "z_h_regen_duration" .. index ) then
		
		timer.Adjust( "z_h_regen_duration" .. index , GetConVar( "z_gmod_spells_HealingMagic_regen_bolt_duration" ):GetFloat() )
		
		return
	end
	
	timer.Create( "z_h_regen_duration" .. index , GetConVar( "z_gmod_spells_HealingMagic_regen_bolt_duration" ):GetFloat() , 0 , function()
		
		timer.Remove( "z_h_regen_duration" .. index )
		timer.Remove( "z_h_regen_effect" .. index )
		
		net.Start( "Z_NET_REGEN_EFFECTS_STOP" )
			net.WriteEntity( ent )
		net.Broadcast()
		
	end)
	
	timer.Create( "z_h_regen_effect" .. index , GetConVar( "z_gmod_spells_HealingMagic_regen_bolt_heal_speed" ):GetFloat() , 0 , function()
		
		if IsValid( ent ) then
			
			if ent:IsPlayer() and ent:Alive() or ent:IsNPC() and ent:GetNPCState() != 7 then
				
				if ent:Health() < ent:GetMaxHealth() then
					
					ent:SetHealth( math.Clamp( ent:Health() + GetConVar( "z_gmod_spells_HealingMagic_regen_bolt_heal_amount" ):GetInt() , 0 , ent:GetMaxHealth() ) )
					
				end
				
			else
				
				timer.Remove( "z_h_regen_duration" .. index )
				timer.Remove( "z_h_regen_effect" .. index )
				
				net.Start( "Z_NET_REGEN_EFFECTS_STOP" )
					net.WriteEntity( ent )
				net.Broadcast()
				
			end
			
		else
			
			timer.Remove( "z_h_regen_duration" .. index )
			timer.Remove( "z_h_regen_effect" .. index )
			
		end
		
	end)
	
	net.Start( "Z_NET_REGEN_EFFECTS" )
		net.WriteEntity( ent )
	net.Broadcast()
	
end

-- Remove dark magic effects from my dark spells mod.
local function RemoveSpellConditions( ent )
	if !IsValid( ent ) then return end
	if ( CLIENT ) and ent.IsHInvun == true then return end
	
	if ( SERVER ) then
		
		net.Start( "Z_NET_CLEAR_SPELL_EFFECTS" )
			net.WriteEntity( ent )
		net.Broadcast()
		
	end
	
	local index		=	ent:EntIndex()
	
	ent:StopParticles()
	
	if ( CLIENT ) then
		
		timer.Remove( "dark_blast_cover_client_" .. index )
		timer.Remove( "dark_blast_cover_client_delay_" .. index )
		
		if ent.IsRegenerating == true then
			
			ParticleEffectAttach( "z_regeneration" , 1 , ent , 0 )
			
		end
		
	end
	
	if ( SERVER ) then
		
		timer.Remove( "zen_dark_blast_damage_" .. index )
		timer.Remove( "zen_dark_blast_duration_" .. index )
		
		ent:Extinguish()
		
	end
	
end

local function BlockEnemy( ent )
	if !IsValid( ent ) then return end
	
	if ent:IsNPC() then
		
		if IsValid( ent:GetActiveWeapon() ) then
			
			ent:GetActiveWeapon():Remove()
			
		end
		
	elseif ent:IsPlayer() then
		
		ent:StripWeapons()
		
	end
	
end


function SWEP:CanBePickedUpByNPCs()
	return true
end

function SWEP:OnDrop()
	
	self:Remove()
	
end


function SWEP:Initialize()
	
	self:SetHoldType( "smg" )
	
	local index		=	self:EntIndex()
	
	-- A new strange BUG that seems to give this timer nil. Perhaps this entity was spawned on map load?
	if GetConVar( "z_gmod_spells_HealingMagic_recharge_speed" ) and isnumber( GetConVar( "z_gmod_spells_HealingMagic_recharge_speed" ):GetFloat() ) then
		
		timer.Create( "gmod_spells_healing_recharge" .. index , GetConVar( "z_gmod_spells_HealingMagic_recharge_speed" ):GetFloat() , 0 , function()
			
			if IsValid( self ) then
				
				if self:Clip1() < 100 then
					
					self:SetClip1( self:Clip1() + 1 )
					
				end
				
			else
				
				timer.Remove( "gmod_spells_healing_recharge" .. index )
				
			end
			
		end)
		
	else
		
		print( "[ Player Healing Spells Mod ]: Something went wrong. Defaulting to 0.12 recharge rate." )
		
		timer.Create( "gmod_spells_healing_recharge" .. index , 0.12 , 0 , function()
			
			if IsValid( self ) then
				
				if self:Clip1() < 100 then
					
					self:SetClip1( self:Clip1() + 1 )
					
				end
				
			else
				
				timer.Remove( "gmod_spells_healing_recharge" .. index )
				
			end
			
		end)
		
	end
	
	timer.Simple( 0.10 , function()
		
		if !IsValid( self ) then return end
		
		if !IsValid( self:GetOwner() ) then
			
			self:Remove()
			
		else
			
			self:OnOwnerChanged( self:GetOwner() )
			
		end
		
	end)
	
end

function SWEP:OnOwnerChanged( newowner )
	
	if newowner:IsPlayer() then
		
		self:SetHoldType( "magic" )
		
		self:StopParticles()
		
	else
		
		self:SetHoldType( "smg" )
		
	end
	
end


function SWEP:GetCapabilities() -- Needed for Father Grigori to use the magic
	
	return bit.bor( CAP_WEAPON_RANGE_ATTACK1  , CAP_USE_SHOT_REGULATOR )
	
end

function SWEP:GetNPCRestTimes()
	
	return 0.40 , 0.60
	
end

function SWEP:GetNPCBurstSettings()
	
	return 3 , 5 , 0.15
	
end

function SWEP:CustomAmmoDisplay() 
	
	self.AmmoDisplay = self.AmmoDisplay or {}
	self.AmmoDisplay.Draw = true
	self.AmmoDisplay.PrimaryClip = self:Clip1()
	
	return self.AmmoDisplay
end



function SWEP:ShieldAll()
	if ( CLIENT ) then return end
	
	for k, v in ipairs( ents.GetAll() ) do
		
		if v:IsNPC() and v:GetNPCState() != 7 or v:IsPlayer() then
			
			if Z_CheckRange( v:GetPos() , self:GetPos() , GetConVar( "z_gmod_spells_HealingMagic_shield_range" ):GetFloat() ) then
				
				RemoveSpellConditions( v )
				
				if v:IsPlayer() then
					
					v:ViewPunch( Angle( 12 , 0 , 0 ) )
					
				elseif v:IsNPC() and v:GetNPCState() != 4 and v:GetNPCState() != 7 then
					
					v:SetSchedule( 40 )
					
				end
				
				timer.Simple( 0.05 , function()
					
					if IsValid( v ) then
						
						MakeInvun( v )
						
					end
					
				end)
				
			end
			
		end
		
	end
	
	local index					=	self:EntIndex()
	
	if timer.Exists( "gmod_spells_healing_recharge" .. index ) and GetConVar( "z_gmod_spells_HealingMagic_recharge_speed" ):GetFloat() < 0.35 then
		-- Slow down recharge speeds.
		timer.Adjust( "gmod_spells_healing_recharge" .. index , 0.35 )
		
	end
	
	
	local User					=	self:GetOwner()
	
	net.Start( "ZEN_NET_H_MAGIC_RADIUS_SHIELD" )
		net.WriteVector( User:GetPos() )
	net.Broadcast()
	
	User:EmitSound( Sound( "npc/antlion/digup1.wav" ) , 80 , math.random( 230 , 250 ) , 1 )
	User:EmitSound( Sound( "npc/antlion/distract1.wav" ) , 80 , math.random( 160 , 180 ) , 1 )
	User:EmitSound( Sound( "npc/antlion/rumble1.wav" ) , 75 , math.random( 160 , 180 ) , 1 )
	
	self.BlockShield			=	true
	
	timer.Simple( 10.05 , function()
		
		if IsValid( self ) then
			
			self.BlockShield	=	false
			
			if timer.Exists( "gmod_spells_healing_recharge" .. index ) then
				
				timer.Adjust( "gmod_spells_healing_recharge" .. index , GetConVar( "z_gmod_spells_HealingMagic_recharge_speed" ):GetFloat() )
				
			end
			
		end
		
	end)
	
end

function SWEP:PrimaryAttack()
	if self:Clip1() < 4 then return end
	if !IsValid( self:GetOwner() ) and ( SERVER ) then self:Remove() return end
	
	
	
	
	
	if self:GetOwner():IsPlayer() and self:GetOwner():KeyDown( IN_WALK ) then
		if self:Clip1() < 100 then return end
		
		self:TakePrimaryAmmo( 100 )
		
		self:ShieldAll()
		
		return
	end
	
	
	
	
	self:Cast()
	
end



function SWEP:SecondaryAttack()
	if ( CLIENT ) then return end
	if self:Clip1() < 25 then return end
	if !IsValid( self:GetOwner() ) then self:Remove() return end
	
	local User		=	self:GetOwner()
	local Trace		=	User:GetEyeTrace()
	
	local Target	=	Trace.Entity
	
	if User:IsPlayer() and User:KeyDown( IN_WALK ) then
		if self:Clip1() < 35 then return end
		
		local Target		=	Trace.Entity
		
		if IsValid( Target ) then
			
			if Target:IsNPC() or Target:IsPlayer() then
				
				self:TakePrimaryAmmo( 35 )
				
				local HealAndDamageAmount		=	GetConVar( "z_gmod_spells_HealingMagic_life_steal_amount" ):GetFloat()
				
				Target:TakeDamage( HealAndDamageAmount , User , User )
				
				User:ViewPunch( Angle( -3 , 0 , 0 ) )
				
				if User:Health() < User:GetMaxHealth() then
					
					User:SetHealth( math.Clamp( User:Health() + HealAndDamageAmount , 0 , User:GetMaxHealth() ) )
					
					User:ViewPunch( Angle( 6 , 0 , 0 ) )
					
				end
				
				timer.Simple( 0.03 , function()
					
					if IsValid( User ) then
						
						if !IsValid( Target ) or Target:IsNPC() and Target:GetNPCState() == 7 or Target:IsPlayer() and !Target:Alive() then
							
							GiveRegenTo( User )
							
							User:ViewPunch( Angle( 9 , 0 , 0 ) )
							User:ScreenFade( SCREENFADE.IN , Color( 0 , 255 , math.random( 0 , 60 ) ) , 0.35 , 0 )
							
						end
						
					end
					
				end)
				
				if Trace.Hit then
					
					for i = 1 , 4 do
						
						sound.Play( Sound( "ambient/levels/canals/windchime2.wav" ) , Trace.HitPos , 80 , 50 + ( 10 * i ) , 1 )
						
					end
					
					net.Start( "ZEN_NET_H_MAGIC_BLAST" )
						net.WriteVector( Trace.HitPos )
					net.Broadcast()
					
				end
				
			else
				
				self:TakePrimaryAmmo( 20 )
				
				if Trace.Hit then
					
					for i = 1 , 4 do
						
						sound.Play( Sound( "ambient/levels/canals/windchime2.wav" ) , Trace.HitPos , 80 , 210 + ( 10 * i ) , 1 )
						
					end
					
					net.Start( "ZEN_NET_H_MAGIC_BLAST" )
						net.WriteVector( Trace.HitPos )
					net.Broadcast()
					
				end
				
			end
			
		else
			
			self:TakePrimaryAmmo( 20 )
			
			if Trace.Hit then
				
				for i = 1 , 4 do
					
					sound.Play( Sound( "ambient/levels/canals/windchime2.wav" ) , Trace.HitPos , 80 , 210 + ( 10 * i ) , 1 )
					
				end
				
				net.Start( "ZEN_NET_H_MAGIC_BLAST" )
					net.WriteVector( Trace.HitPos )
				net.Broadcast()
				
			end
			
		end
		
		return
	end
	
	
	
	if Trace.Hit then
		
		User:ViewPunch( Angle( -1 , 0 , 0 ) )
		
		if IsValid( Target ) then
			
			if Target:IsPlayer() or Target:IsNPC() and Target:Disposition( User ) == D_NU or Target:IsNPC() and Target:Disposition( User ) == D_LI then
				
				GiveRegenTo( Target )
				
			end
			
			self:TakePrimaryAmmo( 25 )
			
			net.Start( "ZEN_NET_H_MAGIC_BLAST" )
				net.WriteVector( Trace.HitPos )
			net.Broadcast()
			
			Target:EmitSound( Sound( "ambient/levels/labs/electric_explosion1.wav" ) , 80 , math.random( 210 , 230 ) , 1 )
			
		else
			
			net.Start( "ZEN_NET_H_MAGIC_BLAST" )
				net.WriteVector( Trace.HitPos )
			net.Broadcast()
			
			sound.Play( Sound( "ambient/levels/labs/electric_explosion1.wav" ) , Trace.HitPos , 80 , math.random( 210 , 230 ) , 1 )
			
			self:TakePrimaryAmmo( 15 )
			
		end
		
	end
	
end



function SWEP:Cast()
	if ( CLIENT ) then return end
	if IsValid( self:GetOwner() ) and self:GetOwner():IsNPC() then return end
	
	local User		=	self:GetOwner()
	local Trace		=	User:GetEyeTrace()
	
	local Target	=	Trace.Entity
	
	if Trace.Hit then
		
		User:ViewPunch( Angle( -1 , 0 , 0 ) )
		
		if IsValid( Target ) then
			
			if Target:IsPlayer() or Target:IsNPC() and Target:Disposition( User ) == D_NU or Target:IsNPC() and Target:Disposition( User ) == D_LI then
				
				self:TakePrimaryAmmo( 2 )
				
				if Target:Health() < Target:GetMaxHealth() then
					
					Target:SetHealth( math.Clamp( Target:Health() + GetConVar( "z_gmod_spells_HealingMagic_devine_bolt_heal" ):GetInt() , 0 , Target:GetMaxHealth() ) )
					
				end
				
				RemoveSpellConditions( Target ) -- Clear all other negative effects.
				
				net.Start( "ZEN_NET_H_MAGIC_BLAST" )
					net.WriteVector( Trace.HitPos )
					net.WriteEntity( Target )
				net.Broadcast()
				
				--Target:EmitSound( Sound( "ambient/levels/canals/windchime2.wav" ) , 80 , math.random( 135 , 220 ) , 1 )
				Target:EmitSound( Sound( "ambient/levels/labs/electric_explosion1.wav" ) , 70 , math.random( 220 , 230 ) , 1 )
				
			elseif Target:IsNPC() and Target:Disposition( User ) == D_HT or Target:IsNPC() and Target:Disposition( User ) == D_FR then
				
				Target:EmitSound( Sound( "ambient/levels/canals/windchime2.wav" ) , 80 , math.random( 35 , 45 ) , 1 )
				Target:EmitSound( Sound( "ambient/levels/labs/electric_explosion1.wav" ) , 80 , math.random( 210 , 230 ) , 1 )
				
				net.Start( "ZEN_NET_H_MAGIC_BLAST" )
					net.WriteVector( Trace.HitPos )
				net.Broadcast()
				
				Target:TakeDamage( math.random( GetConVar( "z_gmod_spells_HealingMagic_enemie_damage_min" ):GetFloat() , GetConVar( "z_gmod_spells_HealingMagic_enemie_damage_max" ):GetFloat() ) , User , User )
				
				self:TakePrimaryAmmo( 5 )
				
			end
			
		else
			
			net.Start( "ZEN_NET_H_MAGIC_BLAST" )
				net.WriteVector( Trace.HitPos )
			net.Broadcast()
			
			sound.Play( Sound( "ambient/levels/labs/electric_explosion1.wav" ) , Trace.HitPos , 80 , math.random( 125 , 160 ) , 1 )
			
			self:TakePrimaryAmmo( 1 )
			
		end
		
	end
	
	timer.Simple( 0.10 , function()
		
		if IsValid( self ) and IsValid( User ) and User:KeyDown( IN_ATTACK ) then
			
			self:PrimaryAttack()
			
		end
		
	end)
	
end





function SWEP:Reload()
	if self:Clip1() < 50 then return end
	if ( CLIENT ) then return end
	if !IsValid( self:GetOwner() ) or self:GetOwner():IsNPC() then self:Remove() return end
	if self.BlockReload == true then return end
	
	self:TakePrimaryAmmo( 50 )
	
	if self:GetOwner():OnGround() then
		
		self:GetOwner():ConCommand( "act cheer" )
		
	end
	
	local OurIndex	=	self:EntIndex()
	
	for k, v in ipairs( ents.GetAll() ) do
		
		if v:IsNPC() and v:GetNPCState() != 7 or v:IsPlayer() then
			
			if Z_CheckRange( v:GetPos() , self:GetPos() , GetConVar( "z_gmod_spells_HealingMagic_radius_heal_range" ):GetFloat() ) then
				
				RemoveSpellConditions( v )
				
				net.Start( "ZEN_NET_H_MAGIC_RADIUS_HEAL" )
					net.WriteEntity( v )
				net.Broadcast()
				
				local index		=	v:EntIndex()
				
				timer.Create( "z_spell_heal_buff" .. index .. OurIndex , 8 , 0 , function()
					
					timer.Remove( "z_spell_heal_buff" .. index .. OurIndex )
					timer.Remove( "z_spell_heal" .. index .. OurIndex )
					
				end)
				
				timer.Create( "z_spell_heal" .. index .. OurIndex , GetConVar( "z_gmod_spells_HealingMagic_radius_heal_regen_speed" ):GetFloat() , 0 , function()
					
					if IsValid( v ) then
						
						if v:Health() < v:GetMaxHealth() then
							
							v:SetHealth( math.Clamp( v:Health() + GetConVar( "z_gmod_spells_HealingMagic_radius_heal_regen_amount" ):GetFloat() , 0 , v:GetMaxHealth() ) )
							
							v:EmitSound( Sound( "common/wpn_moveselect.wav" ) , 77 , math.random( 120 , 140 ) , 1 )
							
						end
						
					else
						
						timer.Remove( "z_spell_heal" .. index .. OurIndex )
						timer.Remove( "z_spell_heal_buff" .. index .. OurIndex )
						
					end
					
				end)
				
				if v:IsPlayer() then
					
					v:ViewPunch( Angle( 12 , 0 , 0 ) )
					
				elseif v:IsNPC() and v:GetNPCState() != 4 and v:GetNPCState() != 7 then
					
					v:SetSchedule( 40 )
					
				end
				
				if v:Health() < v:GetMaxHealth() then
					
					v:SetHealth( math.Clamp( v:Health() + GetConVar( "z_gmod_spells_HealingMagic_radius_heal_amount" ):GetFloat() , 0 , v:GetMaxHealth() ) )
					
				end
				
			end
			
		end
		
	end
	
	net.Start( "ZEN_NET_H_MAGIC_RADIUS" )
		net.WriteVector( self:GetPos() )
	net.Broadcast()
	
	local User		=	self:GetOwner()
	
	User:EmitSound( Sound( "npc/antlion/digup1.wav" ) , 80 , math.random( 200 , 210 ) , 1 )
	User:EmitSound( Sound( "npc/antlion/distract1.wav" ) , 80 , math.random( 40 , 50 ) , 1 )
	User:EmitSound( Sound( "npc/antlion/rumble1.wav" ) , 75 , math.random( 140 , 150 ) , 1 )
	
	self.BlockReload			=	true
	
	timer.Simple( 8.0 , function()
		
		if IsValid( self ) then
			
			self.BlockReload	=	false
			
		end
		
	end)
	
end


local ShieldGlow	=					{
	
	[ "$pp_colour_addr" ]			=	0.01,
	[ "$pp_colour_addg" ]			=	0.01,
	[ "$pp_colour_addb" ]			=	0.01,
	[ "$pp_colour_brightness" ]		=	0,
	[ "$pp_colour_colour" ]			=	1,
	[ "$pp_colour_contrast" ]		=	1,
	[ "$pp_colour_mulr" ]			=	0,
	[ "$pp_colour_mulg" ]			=	0,
	[ "$pp_colour_mulb" ]			=	32
	
	
}



--list.Add( "NPCUsableWeapons" , { class = "zen_healing_m" , title = "[ Magic ]: Dark Energy" } ) 


if ( CLIENT ) then
	
	hook.Add( "RenderScreenspaceEffects" , "ZEN_HOOK_EFFECT_PORTAL" , function()
		
		if IsValid( LocalPlayer() ) and LocalPlayer().IsHInvun == true then
			
			DrawColorModify( ShieldGlow ) 
			
		end
		
	end)
	
	net.Receive( "Z_NET_MARK_INVUN" , function()
		
		local ent			=	net.ReadEntity()
		if !IsValid( ent ) then return end
		
		ent.IsHInvun				=	true
		
		local index			=	ent:EntIndex()
		
		timer.Create( "z_h_shield_delay" .. index , 10 , 0 , function()
			
			if IsValid( ent ) then
				
				ent.IsHInvun		=	false
				ent:StopParticles()
				
			end
			
			timer.Remove( "z_h_shield_delay" .. index )
			
		end)
		
		ent:StopParticles()
		
		timer.Simple( 0.04 , function()
			
			if IsValid( ent ) then
				
				ParticleEffectAttach( "z_h_shield" , 1 , ent , 0 )
				
			end
			
		end)
		
	end)
	
	net.Receive( "ZEN_NET_H_MAGIC_RADIUS_SHIELD" , function()
		
		local Position		=	net.ReadVector()
		if !isvector( Position ) then return end
		
		ParticleEffect( "z_shield_radius" , Position , Angle( 0 , 0 , 0 ) )
		
	end)
	
	net.Receive( "ZEN_NET_H_MAGIC_RADIUS" , function()
		
		local Position		=	net.ReadVector()
		if !isvector( Position ) then return end
		
		ParticleEffect( "z_group_healer_zombie_radius" , Position , Angle( 0 , 0 , 0 ) )
		
	end)
	
	net.Receive( "ZEN_NET_H_MAGIC_RADIUS_HEAL" , function()
		
		local Ent		=	net.ReadEntity()
		if !IsValid( Ent ) then return end
		
		ParticleEffectAttach( "z_entity_healing_effects" , 1 , Ent , 0 )
		
	end)
	
	net.Receive( "ZEN_NET_H_MAGIC_BLAST" , function()
		
		local Position		=	net.ReadVector()
		if !isvector( Position ) then return end
		
		ParticleEffect( "zen_magic_missile_blast" , Position , Angle( 0 , 0 , 0 ) )
		
		local Ent			=	net.ReadEntity()
		if !IsValid( Ent ) then return end
		
		ParticleEffectAttach( "Zen_Ring_Buff" , 1 , Ent , 0 )
		
	end)
	
	
	
	net.Receive( "Z_NET_REGEN_EFFECTS" , function()
		
		local ent				=	net.ReadEntity()
		if !IsValid( ent ) then return end
		
		ParticleEffectAttach( "z_regeneration" , 1 , ent , 0 )
		
		ent.IsRegenerating		=	true
		
	end)
	
	net.Receive( "Z_NET_REGEN_EFFECTS_STOP" , function()
		
		local ent			=	net.ReadEntity()
		if !IsValid( ent ) then return end
		if ent.IsHInvun == true then return end
		
		ent:StopParticles()
		
		ent.IsRegenerating		=	false
		
	end)
	
	
	
	net.Receive( "Z_NET_CLEAR_SPELL_EFFECTS" , function()
		
		local ent		=	net.ReadEntity()
		if !IsValid( ent ) then return end
		
		if ent.IsHInvun == true then return end
		
		RemoveSpellConditions( ent )
		
	end)
	
	
	local GlowList		=	{}
	local GlowColour	=	255
	
	timer.Create( "z_timer_check_health" , 0.20 , 0 , function()
		
		if IsValid( LocalPlayer() ) then
			GlowList					=	{}
			
			local PrimaryWeapon			=	LocalPlayer():GetActiveWeapon()
			
			if IsValid( PrimaryWeapon ) and PrimaryWeapon:GetClass() == "zen_healing_m" then
				
				local Trace					=	LocalPlayer():GetEyeTrace()
				
				if IsValid( Trace.Entity ) then
					
					if Trace.Entity:IsNPC() or Trace.Entity:IsPlayer() then
						
						local HealthCol		=	255 / Trace.Entity:GetMaxHealth()
						GlowColour			=	Trace.Entity:Health() * HealthCol
						
						GlowList			=	{ Trace.Entity }
						
					end
					
				end
				
			end
			
		end
		
	end)
	
	hook.Add( "PreDrawHalos" , "Z_HOOK_HEALTH_SPELLS_DRAW_HALOS" , function()
		
		if istable( GlowList ) and !table.IsEmpty( GlowList ) then
			
			halo.Add( GlowList , Color( 255 - GlowColour , GlowColour , 0 ) , 2 , 2 , 1 , true , false ) 
			
		end
		
	end)
	
end

if ( SERVER ) then
	
	hook.Add( "EntityTakeDamage" , "Z_HOOK_HEALTH_SPELLS_INVUN" , function( ent , dmginfo )
		if !IsValid( ent ) or !dmginfo then return end
		
		if ent:IsNPC() or ent:IsPlayer() then
			
			if ent.IsHInvun == true then
				
				dmginfo:ScaleDamage( 0 ) 
				-- No damage for players or NPCs
				-- Also allows players to remain in GodMode() when the effects end.
				
			end
			
		end
		
	end)
	
end




























































--PATH addons/__main/lua/entities/aot_rope/shared.lua:
ENT.Type = "anim"


/*---------------------------------------------------------
---------------------------------------------------------*/
function ENT:SetEndPos( endpos )

	self.Entity:SetNetworkedVector( 0, endpos )	
	self.Entity:SetCollisionBoundsWS( self.Entity:GetPos(), endpos, Vector() * 0.25 )
	
end


/*---------------------------------------------------------
---------------------------------------------------------*/
function ENT:GetEndPos()
	return self.Entity:GetNetworkedVector( 0 )
end

--PATH addons/_farmer/lua/entities/ba_food/cl_init.lua:
include("shared.lua");

surface.CreateFont("BA_Food_Text", {
	font = "Tahoma",
	size = 38,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	
end;


function ENT:Think()
end;

function ENT:Draw()
	self:DrawModel();
	
	local camPos = self:GetPos();
	local camAng = self:GetAngles();
	
	camAng:RotateAroundAxis(camAng:Up(), 0);
	camAng:RotateAroundAxis(camAng:Forward(), 0);	
	camAng:RotateAroundAxis(camAng:Right(), 0);
	
	local name = self:GetNWString("name");
	local length = (string.len(self:GetNWString("name"))*21);

	local color = string.Explode(",", self:GetNWString("color"));
	
	local amount = math.Clamp((self:GetNWInt("amount")*2)/length, 0, (length));
	
	
	if (LocalPlayer():GetPos():Distance(self:GetPos()) < B_Animals_Config.DrawDistance) then
		cam.Start3D2D(camPos + Vector(0, 0, self:OBBMaxs().z*1.4), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.075)
			draw.RoundedBox(0, -(length*0.5)-28, -16, length+42, 36, Color(0, 0, 0, 240));
			draw.SimpleText(self:GetNWString("name"), "BA_Food_Text", 13, 0, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
			
			draw.RoundedBox(0, -(length*0.5)-28, -16, 42, 36, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 200));
			draw.SimpleText(self:GetNWInt("amount"), "BA_Food_Text", -(length*0.5)-8, 0, Color(0, 0, 0, 240), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		cam.End3D2D();
	end;
end;

--PATH addons/_farmer/lua/entities/ba_lowquality_meals/cl_init.lua:
include("shared.lua");

surface.CreateFont("BA_Box_Text", {
	font = "Tahoma",
	size = 30,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

surface.CreateFont("BA_Box_Big", {
	font = "Tahoma",
	size = 64,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

surface.CreateFont("BA_Box_Icon", {
	font = "Webdings",
	size = 256,
	weight = 0,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = true,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	
end;


function ENT:Think()
end;

function ENT:Draw()
	self:DrawModel();
	
	local camPos = self:GetPos();
	local camAng = self:GetAngles();
	
	camAng:RotateAroundAxis(camAng:Up(), 0);
	camAng:RotateAroundAxis(camAng:Forward(), 90);
	camAng:RotateAroundAxis(camAng:Right(), 0);
	
	local name = self:GetNWString("name");
	local length = (string.len(self:GetNWString("name"))*21);

	local color = string.Explode(",", self:GetNWString("color"));
	
	local amount = math.Clamp((self:GetNWInt("amount")*2)/length, 0, (length));
	
	
	if (LocalPlayer():GetPos():Distance(self:GetPos()) < B_Animals_Config.DrawDistance) then
		cam.Start3D2D(camPos+camAng:Up()*19.5, camAng, 0.125)
			draw.RoundedBox(0, -120, -87, 240, 170, Color(0, 0, 0, 230));
			draw.SimpleText(self:GetNWString("name"), "BA_Box_Text", 0, -70, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);

			--draw.SimpleText("F", "BA_Box_Icon", 0, 0, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 20), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
			draw.SimpleText(self:GetNWInt("amount").."cal", "BA_Box_Big", 0, 0, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		cam.End3D2D();
		
		camAng:RotateAroundAxis(camAng:Forward(), -90);	
		cam.Start3D2D(camPos+camAng:Up()*12, camAng, 0.125)
			draw.RoundedBox(0, -120, -145, 240, 290, Color(0, 0, 0, 230));

		cam.End3D2D();
		cam.Start3D2D(camPos+camAng:Up()*12, camAng, 0.2)
			draw.SimpleText("N", "BA_Box_Icon", 0, 0, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		cam.End3D2D();
	end;
end;
--PATH addons/_bitminers2/lua/entities/bm2_bitminer_server/cl_init.lua:
include( "shared.lua" )
function ENT:Initialize()
	self.fanAng = 0
end

--Animate fans
function ENT:Think()
	if LocalPlayer():GetPos():Distance( self:GetPos() ) < 500 and self:GetShouldAnimate() then
		self.fanAng = self.fanAng + FrameTime() * 400
		for i = 0, self:GetBoneCount() - 1 do
			if string.match( self:GetBoneName( i ), "fan" ) ~= nil then self:ManipulateBoneAngles( i, Angle( self.fanAng, 0, 0 ) ) end
		end
	end
end

function ENT:Draw()
	self:DrawModel()
end
--PATH addons/_bitminers2/lua/entities/bm2_generator/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Generator"
ENT.Spawnable = true
ENT.Category = "Bitminers"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "IsOn" )
	self:NetworkVar( "Bool", 2, "ShowToMuchPowerWarning" )
	self:NetworkVar( "Bool", 3, "ShowNoFuelWarning" )
	self:NetworkVar( "Int", 1, "FuelLevel" )
	self:NetworkVar( "Float", 2, "PowerConsumpsion" )
end
--PATH addons/_doctor/lua/entities/bp_chemical_2nap/cl_init.lua:
include("shared.lua")

local levelIcon = Material("blues_pharm/ui/level.png", "smooth")
local titleIcon = Material("blues_pharm/ui/title.png", "smooth")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist  then return end

	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * 15)

	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	cam.Start3D2D(pos, ang2, 0.05)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-160, -270, 280, 65)

		draw.RoundedBox(0, -160, -270, 20, 570, Color(43, 43, 43))

		draw.SimpleText(BLUES_PHARMA.Chemicals[self.ChemicalID].name, "BP_Chemical_Title",  -135, -270, Color(255, 255, 255), 0, 0)

		surface.SetMaterial(levelIcon)
		surface.SetDrawColor(Color(255, 255, 255, 60))
		surface.DrawTexturedRect(-135, -240, 32, 32)

		draw.SimpleText(self:GetLiquidAmount().."ml", "BP_Chemical_Amount",  - 100, -240, Color(255, 255, 255, 60), 0, 0)
	cam.End3D2D()
end
--PATH addons/_doctor/lua/entities/bp_chemical_acet2/cl_init.lua:
include("shared.lua")

local levelIcon = Material("blues_pharm/ui/level.png", "smooth")
local titleIcon = Material("blues_pharm/ui/title.png", "smooth")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist  then return end
	
	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * 15)

	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	cam.Start3D2D(pos, ang2, 0.05)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-160, -270, 280, 65)

		draw.RoundedBox(0, -160, -270, 20, 570, Color(43, 43, 43))

		draw.SimpleText(BLUES_PHARMA.Chemicals[self.ChemicalID].name, "BP_Chemical_Title",  -135, -270, Color(255, 255, 255), 0, 0)

		surface.SetMaterial(levelIcon)
		surface.SetDrawColor(Color(255, 255, 255, 60))
		surface.DrawTexturedRect(-135, -240, 32, 32)

		draw.SimpleText(self:GetLiquidAmount().."ml", "BP_Chemical_Amount",  - 100, -240, Color(255, 255, 255, 60), 0, 0)
	cam.End3D2D()
end
--PATH addons/_doctor/lua/entities/bp_chemical_deio/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "Deionized water"
ENT.Spawnable = true
ENT.Category = "Blue's Pharmaceuticals"

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.ChemicalID = 10


function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "LiquidAmount")
end
--PATH addons/_doctor/lua/entities/bp_chemical_sali_acid/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "Salicylic Acid"
ENT.Spawnable = true
ENT.Category = "Blue's Pharmaceuticals"

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.ChemicalID = 2


function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "LiquidAmount")
end
--PATH addons/_doctor/lua/entities/bp_freezer/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "Freezer"
ENT.Spawnable = true
ENT.Category = "Blue's Pharmaceuticals"
--PATH addons/_doctor/lua/entities/bp_pill_press/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "Pill Press"
ENT.Spawnable = true
ENT.Category = "Blue's Pharmaceuticals"

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "RecipeID")
	self:NetworkVar("Float", 1, "PressedAmount")
	self:NetworkVar("Int", 1, "AnimationAngle")
	self:NetworkVar("Entity", 1, "owning_ent")
end
--PATH addons/_ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )
net.Receive( "bs_shield_info", function() LocalPlayer().bs_shieldIndex = net.ReadUInt( 16 ) end )
local Delay = 0
function bshields_materials_reload()
	for _, v in pairs( bshields.materialstoload ) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL( v[1], v[2], v[3] ) end )
	end

	bshields.hshield_webmat = surface.GetURL( bshields.config.hShieldTexture, 256, 256 )
	bshields.rshield_webmat = surface.GetURL( bshields.config.rShieldTexture, 256, 256 )
	bshields.dshield_webmat = surface.GetURL( bshields.config.dShieldTexture, 256, 256 )
end

bshields.materialstoload = { { bshields.config.hShieldTexture, 256, 256 }, { bshields.config.rShieldTexture, 256, 256 }, { bshields.config.dShieldTexture, 256, 256 } }
hook.Add( "InitPostEntity", "bshields_init_client", function() bshields_materials_reload() end )
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}
bshields.shields = {
	{
		[1] = {
			["angles"] = Angle( 4, 6, -14 ),
			["position"] = Vector( 0, 8, -1 )
		},
		[2] = {
			["angles"] = Angle( 6, 6, -12 ),
			["position"] = Vector( 8, 10, -4 )
		},
		[3] = {
			["angles"] = Angle( -3, 7, -16 ),
			["position"] = Vector( -1, 4, -3 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -4, -8 )
		},
		[2] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 16, -3, -12 )
		},
		[3] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -3, -12 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -7, -13 )
		},
		[2] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -6, -22 )
		},
		[3] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -8, -12 )
		}
	}
}
--PATH addons/__main/lua/entities/connection_gun/cl_init.lua:
include("shared.lua")

ENT.RenderGroup = RENDERGROUP_OPAQUE

function ENT:Draw()
	self.Entity:DrawModel()
end
--PATH addons/_drones/lua/entities/dronesrewrite_balltur/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "BT 'Ball Turret'"
ENT.PrintName = "Ball Turret"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.RenderInCam = false
ENT.UNIT = "BT"

ENT.Model = "models/XQM/Rails/trackball_1.mdl"

ENT.Weight = 80

ENT.Speed = 200
ENT.UpSpeed = 0
ENT.SprintCoefficient = 1.5
ENT.RotateSpeed = 0
ENT.AngOffset = 0
ENT.NoiseCoefficient = 0
ENT.Alignment = 3
ENT.PitchOffset = 0

ENT.Fuel = 40
ENT.MaxFuel = 40

ENT.HackValue = 2

ENT.FirstPersonCam_pos = Vector(0, 0, 0)
ENT.ThirdPersonCam_pos = Vector(0, 0, 0)
ENT.ThirdPersonCam_distance = 90
ENT.SimplestCamera = true

ENT.UseFlashlight = false

ENT.HUD_hudName = "White Box"
ENT.HUD_shouldDrawCenter = false

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()
ENT.KeysFuncs.Physics["Forward"] = function(self)
	local phys = self:GetPhysicsObject()

	phys:ApplyForceCenter(self.CamAngles:Forward() * self.Speed * self.MoveCoefficient)

	self.MoveDir = 1
	self.IsMoving = true
end

ENT.KeysFuncs.Physics["Back"] = function(self)
	local phys = self:GetPhysicsObject()

	phys:ApplyForceCenter(-self.CamAngles:Forward() * self.Speed * self.MoveCoefficient)

	self.MoveDir = -1
	self.IsMoving = true
end

ENT.KeysFuncs.Physics["Left"] = function(self)
	local phys = self:GetPhysicsObject()

	phys:ApplyForceCenter(-self.CamAngles:Right() * self.Speed * self.MoveCoefficient)

	self.MoveDir = 1
	self.IsMoving = true
end

ENT.KeysFuncs.Physics["Right"] = function(self)
	local phys = self:GetPhysicsObject()

	phys:ApplyForceCenter(self.CamAngles:Right() * self.Speed * self.MoveCoefficient)

	self.MoveDir = 1
	self.IsMoving = true
end

ENT.KeysFuncs.Physics["Up"] = function(self)
	if self:WasKeyPressed("Up") then
		local phys = self:GetPhysicsObject()
		phys:ApplyForceCenter(vector_up * 30000)
	end
end

ENT.AllowPitchRestrictions = false

ENT.HealthAmount = 250
ENT.DefaultHealth = 250

ENT.Sounds = {
	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 85
	}
}

ENT.NoPropellers = true
ENT.Modules = DRONES_REWRITE.GetBaseModules()

ENT.AI_CustomEnemyChecker = function(drone, v)
	return drone:GetPos():Distance(v:GetPos()) < 500
end

ENT.AI_DistanceEnemy = 400
ENT.AI_UseZ = false
--PATH addons/_drones/lua/entities/dronesrewrite_base/cl_init.lua:
include("shared.lua")

local matLamp = Material("sprites/light_glow02_add_noz")
local matTarget = Material("stuff/whiteboxhud/target")

function ENT:Draw()
	if not (not self.RenderInCam and LocalPlayer() == self:GetDriver() and not self:GetNWBool("ThirdPerson") and self:GetMainCamera() == self:GetCamera()) then 
		self:DrawModel() 
	end
	
	if self:GetNWBool("Flashlight") then
		if not self.PixVis then
			self.PixVis = util.GetPixelVisibleHandle()
		end

		local cam = self:GetMainCamera()

		if IsValid(cam) then
			local LightNrm = self:GetAngles():Forward()
			local ViewNormal = self:GetPos() - EyePos()
			local Distance = ViewNormal:Length()
			ViewNormal:Normalize()
			local ViewDot = ViewNormal:Dot( LightNrm * -1 )
			local LightPos = cam:GetPos() - self:GetForward() * 4

			if ViewDot >= 0 then
				local Visibile = util.PixelVisible(LightPos, 16, self.PixVis)	
				if not Visibile then return end
					
				local Size = math.Clamp(Distance * Visibile * ViewDot, 0, 128)
				Distance = math.Clamp(Distance, 32, 800)
				local Alpha = math.Clamp((1000 - Distance) * Visibile * ViewDot, 0, 255)

				render.SetMaterial(matLamp)
				--cam.IgnoreZ(true)
					render.DrawSprite(LightPos, Size, Size, Color(255, 255, 255, Alpha), Visibile * ViewDot)
					render.DrawSprite(LightPos, Size * 2, Size * 0.4, Color(255, 255, 255, Alpha), Visibile * ViewDot)
				--cam.IgnoreZ(false)
			end
		end
	end

	if self.Attachments and not self:GetNWBool("ThirdPerson") then
		cam.IgnoreZ(true)

		for k, v in pairs(self.Attachments) do 
			local pos = self:LocalToWorld(v.Pos)
			local dist = EyePos():Distance(pos)
			
			if (dist > 300) then continue end

			local ang = (EyePos() - pos):Angle()
			ang:RotateAroundAxis(ang:Up(), 90)
			ang:RotateAroundAxis(ang:Forward(), 90)

			cam.Start3D2D(pos, ang, math.Clamp(dist / 1000, 0.1, 100))
				local ppos
				if v.Pos then
					ppos = v.Pos.x .. " " .. v.Pos.y .. " " .. v.Pos.z
				end

				if not ppos then ppos = "No pos" end

				local pang
				if v.Angle then
					pang = v.Angle.p .. " " .. v.Angle.y .. " " .. v.Angle.r
				end

				if not pang then pang = "No angle" end
				
				draw.SimpleText(k, "DronesRewrite_font3", 5, -32, Color(255, 255, 255), TEXT_ALIGN_LEFT)
				--draw.SimpleText("Pos: " .. ppos, "DronesRewrite_font3", -48, -32, Color(255, 255, 255), TEXT_ALIGN_LEFT)
				--draw.SimpleText("Ang: " .. pang, "DronesRewrite_font3", -48, 0, Color(255, 255, 255), TEXT_ALIGN_LEFT)

				surface.SetDrawColor(Color(255, 255, 255))
				--surface.SetMaterial(matTarget)
				--surface.DrawTexturedRect(-64, -64, 128, 128)

				surface.DrawRect(-32, -2, 28, 4)
				surface.DrawRect(-2, -32, 4, 28)

				surface.DrawRect(4, -2, 28, 4)
				surface.DrawRect(-2, 4, 4, 28)
			cam.End3D2D()
		end

		cam.IgnoreZ(false)
	end
end

function ENT:DrawIndicator(index, val)
	if not self.HUD_indicators then self.HUD_indicators = { } end
	if not self.HUD_indicators[index] then self.HUD_indicators[index] = table.Count(self.HUD_indicators) end

	if val >= 100 then 
		self.HUD_indicators = nil
		return 
	end

	local x, y = ScrW() * 0.5 - 128, ScrH() - 86 - self.HUD_indicators[index] * 90
	local w, h = 256, 32

	draw.SimpleText(index .. ": " .. val .. "%", "DronesRewrite_font3", x + 128, y - 42, Color(0, 255, 255, 150), TEXT_ALIGN_CENTER)
						
	surface.SetDrawColor(Color(0, 150, 255, 200))
	surface.DrawOutlinedRect(x - 2, y - 2, w + 4, h + 4)
	surface.DrawRect(x, y, val * 2.56, h)
end

function ENT:GetOverlayName()
	local overlayname = self.OverlayName
	return overlayname
end

function ENT:GetHUDName()
	local hudname = self.HUD_hudName
	return hudname
end

function ENT:CallBindMenu()
	net.Start("dronesrewrite_requestweapons")
		net.WriteEntity(self)
		net.WriteString("dronesrewrite_openbindsmenu")
		net.WriteBit(false)
	net.SendToServer()
end

function ENT:OpenBindsMenu(weps)
	if not weps then return end

	local win = DRONES_REWRITE.CreateWindow(200, 180)
	local p = DRONES_REWRITE.CreateScrollPanel(0, 26, 200, 154, win)

	local function foo(btn, v, isLeftKey)
		timer.Create("dronesrewritekey", 0.1, 1, function()
			if not btn then return end

			if isLeftKey == "unbind" then
				net.Start("dronesrewrite_makebind")
					net.WriteEntity(self)
					net.WriteBit(false)
					net.WriteString(v)
				net.SendToServer()

				return
			end

			btn:SetText("PRESS ANY BUTTON")
			btn:SetEnabled(false)

			hook.Add("DronesRewriteKey", "dronesrewrite_bindwep", function(key, pressed)
				local key = DRONES_REWRITE.KeyNames[key]

				net.Start("dronesrewrite_makebind")
					net.WriteEntity(self)
					net.WriteBit(isLeftKey)
					net.WriteString(v)
					net.WriteString(key)
				net.SendToServer()

				if IsValid(btn) then
					btn:SetEnabled(true)
					btn:SetText(v .. " - " .. key)
				end

				hook.Remove("DronesRewriteKey", "dronesrewrite_bindwep")
			end)
		end)
	end

	for k, v in pairs(weps) do
		local btn = DRONES_REWRITE.CreateButton(v, 0, (k - 1) * 21, 200, 20, p, function(btn)
			local menu = DermaMenu()

			menu:AddOption("Bind Attack1", function()
				foo(btn, v, true)
			end)

			menu:AddOption("Bind Attack2", function()
				foo(btn, v, false)
			end)

			menu:AddOption("Unbind", function()
				foo(btn, v, "unbind")
			end)

			menu:Open()
		end)
	end
end

function ENT:CallWeaponsMenu()
	if not LocalPlayer():IsAdmin() then LocalPlayer():ChatPrint("[Drones] You're not admin!") return end

	net.Start("dronesrewrite_requestweapons")
		net.WriteEntity(self)
		net.WriteString("dronesrewrite_openweaponscustom")
		net.WriteBit(true)
	net.SendToServer()
end

function ENT:OpenWeaponsMenu(weps)
	if not LocalPlayer():IsAdmin() then LocalPlayer():ChatPrint("[Drones] You're not admin!") return end
	--if not weps then return end

	local win = DRONES_REWRITE.CreateWindow(500, 460)

	local old = win.Paint
	win.Paint = function(win)
		old(win)
		draw.RoundedBox(0, 0, 25, 200, 445, DRONES_REWRITE.Colors.DarkGrey2)

		surface.SetDrawColor(DRONES_REWRITE.Colors.Border)

		surface.DrawLine(200, 25, 200, 460) -- Separate sections
		surface.DrawLine(0, 225, 200, 225) -- Separate menus
		surface.DrawLine(0, 259, 200, 259) -- Separate menus 2
	end

	local wepslist = DRONES_REWRITE.CreateScrollPanel(0, 25, 200, 200, win)

	DRONES_REWRITE.CreateLabel(self:GetUnit() .. "'s weapons:", 20, 235, win)
	local lab = DRONES_REWRITE.CreateLabel("No selected weapon!", 220, 35, win)

	local existweps = DRONES_REWRITE.CreateScrollPanel(0, 260, 200, 200, win)

	local addWep = ""
	local sync = { }

	local i = 0
	for k, v in pairs(DRONES_REWRITE.Weapons) do
		if k == "Template" then continue end -- Weapon that users shouldnt know about

		local btn = DRONES_REWRITE.CreateButton(k, 0, i * 31, 200, 30, wepslist, function() -- k is 1 first not 0 but we need 0
			addWep = k

			if lab then 
				lab:Remove() 
				lab = nil 
			end

			lab = DRONES_REWRITE.CreateLabel("Selected weapon: " .. k, 220, 35, win)
		end)

		i = i + 1
	end

	local btns = { }

	local function AddWeps()
		if not weps then weps = { } end
		if btns then
			for k, v in pairs(btns) do
				if IsValid(v) then v:Remove() end
			end

			table.Empty(btns)
		end

		local i = 0

		for k, v in pairs(weps) do
			local btn = DRONES_REWRITE.CreateButton(v, 0, i * 31, 200, 30, existweps, function() 
				if not sync[v] then sync[v] = { } end

				local menu = DermaMenu()
				menu:AddOption("Bind " .. addWep .. " weapon Attack1 to this " .. v .. " Attack1", function() sync[v].fire1 = "fire1" end)
				menu:AddOption("Bind " .. addWep .. " weapon Attack1 to this " .. v .. " Attack2", function() sync[v].fire2 = "fire1" end)
				menu:AddOption("Bind " .. addWep .. " weapon Attack2 to this " .. v .. " Attack1", function() sync[v].fire1 = "fire2" end)
				menu:AddOption("Bind " .. addWep .. " weapon Attack2 to this " .. v .. " Attack2", function() sync[v].fire2 = "fire2" end)

				menu:AddOption("Remove all chosen binds", function() sync[v] = nil end)

				menu:AddOption("Remove", function()
					net.Start("dronesrewrite_removeweapon")
						net.WriteEntity(self)
						net.WriteString(v)
					net.SendToServer()

					weps[k] = nil

					AddWeps()
				end)

				menu:Open()
			end)

			i = i + 1

			btns[i] = btn
		end
	end

	AddWeps()

	local sel = vgui.Create("DCheckBox", win)
	sel:SetPos(220, 110)
	sel:SetValue(1)
	DRONES_REWRITE.CreateLabel("Should be visible in weapon selection menu", 240, 110, win)

	local prims = vgui.Create("DCheckBox", win)
	prims:SetPos(220, 130)
	prims:SetValue(0)
	DRONES_REWRITE.CreateLabel("Primary ammo as secondary", 240, 130, win)

	DRONES_REWRITE.CreateLabel("Position", 220, 150, win)

	local pos = { "X", "Y", "Z" }
	local sliders = { }

	for k, v in pairs(pos) do
		local slider = vgui.Create("DNumSlider", win)
		slider:SetSize(220, 30)
		slider:SetPos(220, 150 + k * 20)
		slider:SetText(v)
		slider:SetMin(-5000)
		slider:SetMax(5000)
		slider:SetDecimals(0)
		slider:SetValue(0)
		slider.Label:SetFont("DronesRewrite_customfont1")

		sliders[k] = slider
	end

	DRONES_REWRITE.CreateLabel("Angle", 220, 240, win)

	local ang = { "P", "Y", "R" }
	local slidersa = { }

	for k, v in pairs(ang) do
		local slider = vgui.Create("DNumSlider", win)
		slider:SetSize(220, 30)
		slider:SetPos(220, 240 + k * 20)
		slider:SetText(v)
		slider:SetMin(-180)
		slider:SetMax(180)
		slider:SetDecimals(0)
		slider:SetValue(0)
		slider.Label:SetFont("DronesRewrite_customfont1")

		slidersa[k] = slider
	end

	local menu = vgui.Create("DComboBox", win)
	menu:SetSize(260, 25)
	menu:SetPos(220, 350)

	if self.Attachments then
		menu:SetText("Choose attachment")

		for k, v in pairs(self.Attachments) do
			menu:AddChoice(k)
		end
	else
		menu:SetText("No attachments found")
	end

	local del = true
	local text = vgui.Create("DTextEntry", win)
	text:SetSize(260, 25)
	text:SetPos(220, 380)
	text:SetText("Weapon name")
	text.OnGetFocus = function() 
		if del then text:SetText("") del = false end
	end

	local btn = DRONES_REWRITE.CreateButton("How to bind", 358, 415, 120, 25, win, function()
		DRONES_REWRITE.ShowHelpWindow("Binding weapons")
	end)

	local btn = DRONES_REWRITE.CreateButton("Add", 220, 60, 260, 40, win, function() -- k is 1 first not 0 but we need 0
		local ang = Angle(slidersa[1]:GetValue(), slidersa[2]:GetValue(), slidersa[3]:GetValue())
		local pos = Vector(sliders[1]:GetValue(), sliders[2]:GetValue(), sliders[3]:GetValue())
		local name = text:GetValue()

		net.Start("dronesrewrite_addweapon")
			net.WriteEntity(self)
			net.WriteString(name)
			net.WriteString(addWep)

			net.WriteAngle(ang)
			net.WriteVector(pos)
			net.WriteTable(sync)

			net.WriteBool(sel:GetChecked())
			net.WriteBool(prims:GetChecked())
			
			net.WriteString(menu:GetValue())
		net.SendToServer()

		table.insert(weps, name)
		AddWeps()
	end)
end

function ENT:IsFull(slot)
	local count = self.Slots[slot] or 9999
	return self:GetNWInt("SlotCount" .. slot) >= count
end

function ENT:OpenUpgradesMenu()
	--sync = sync or 1
	local selected = ""

	local win = DRONES_REWRITE.CreateWindow(365, 490)
	local oldpaint = win.Paint
	win.Paint = function(win)
		oldpaint(win)
		draw.RoundedBox(0, 0, 360, 365, 130, DRONES_REWRITE.Colors.DarkGrey2)
	end

	local old = win.Think
	win.Think = function(win) 
		old(win)
		if not self:IsValid() then win:Close() end 
	end

	local panel = DRONES_REWRITE.CreateScrollPanel(0, 25, 365, 335, win)

	local btns = { }
	local slots = { }

	local function UpdateBtns()
		for k, v in pairs(btns) do if IsValid(v) then v:Remove() end end
		btns = { }

		local i = 0

		local found = false
		for k, v in SortedPairsByMemberValue(self.Modules, "Slot", false) do
			if not v.System and not self:GetNWBool("hasModule" .. k) then continue end

			local slot = v.Slot or "System"
			local y = 1 + i * 31

			table.insert(btns, DRONES_REWRITE.CreateButton(k, 1, y, 170, 30, panel, function() end))
			table.insert(btns, DRONES_REWRITE.CreateButton(slot, 172, y, 125, 30, panel, function() end))

			local remove = vgui.Create("DButton", panel)
			remove:SetPos(315, y)
			remove:SetSize(30, 30)
			remove:SetText("")

			if slot != "System" then
				remove.DoClick = function()
					net.Start("dronesrewrite_addmodule")
						net.WriteEntity(self)
						net.WriteString(k)
						net.WriteBit(false)
					net.SendToServer()

					timer.Simple(0.15, function() UpdateBtns() end)
				end
			end
			remove.Paint = function(remove, w, h)
				local color = DRONES_REWRITE.Colors.Green
				if slot == "System" then color = DRONES_REWRITE.Colors.DarkGrey end

				surface.SetMaterial(Material("stuff/cross"))
				surface.SetDrawColor(color)
				surface.DrawTexturedRect(4, 4, w - 8, h - 8)
			end
			table.insert(btns, remove)

			i = i + 1
			found = true
		end

		if not found then
			win:SetTitle("No module installed!")
		end

		for k, v in pairs(slots) do if IsValid(v) then v:Remove() end end
		slots = { }

		DRONES_REWRITE.CreateLabel("Slots list and limits", 240, 366, win)

		for k, v in pairs(self.Slots) do
			if type(v) != "table" then -- Hotfix for BaseClass
				local lab = DRONES_REWRITE.CreateLabel(k .. " " .. self:GetNWInt("SlotCount" .. k) .. "/" .. v, 10, 350 + (table.Count(slots) + 1) * 16, win)
				lab:SetColor(DRONES_REWRITE.Colors.LightGrey)

				slots[k] = lab

				local oldshit
				slots[k].Think = function()
					if self:GetNWInt("SlotCount" .. k) != oldshit then
						slots[k]:SetText(k .. " " .. self:GetNWInt("SlotCount" .. k) .. "/" .. v)
						slots[k]:SizeToContents()

						oldshit = self:GetNWInt("SlotCount" .. k)
					end
				end
			end
		end
	end

	UpdateBtns()
end

ENT.selected = 1

function ENT:OpenSelectionMenu(weps)
	if not weps then surface.PlaySound("common/wpn_denyselect.wav") return end
	if self._SelectingWep == -1 then return end
	self._SelectingWep = -1

	surface.PlaySound("vehicles/atv_ammo_open.wav")

	local btns = { }

	local posx = 0
	local posy = 0

	local function close()
		if IsValid(self) then self._SelectingWep = 0 end
		for k, v in pairs(btns) do v:Remove() end

		hook.Remove("DronesRewriteKey", "dronesrewrite_selectwep_gui")
		hook.Remove("Think", "dronesrewrite_selectwep_gui_sel")
	end

	local function select()
		surface.PlaySound("common/wpn_moveselect.wav")
		timer.Create("dronesrewrite_selectwep_gui_close" .. self:EntIndex(), 1.5, 1, function() close() end)

		if self.selected < 1 then self.selected = #weps end
		if self.selected > #weps then self.selected = 1 end
	end

	select()

	for k, v in pairs(weps) do
		local btn = DRONES_REWRITE.CreateButton(string.upper(v), 15 + posx * 210, 30 + posy * 74, 200, 64, nil, function()
			if IsValid(self) then
				net.Start("dronesrewrite_changewep")
					net.WriteString(v)
				net.SendToServer()
			end

			self.selected = k

			close()
		end)

		btn:SetFont("DronesRewrite_font6")

		local paint = btn.Paint
		btn.Paint = function(btn)	
			paint(btn)

			if self.selected == k then
				draw.RoundedBox(0, 0, 0, btn:GetWide(), btn:GetTall(), DRONES_REWRITE.Colors.LightBlue)
			end
		end

		table.insert(btns, btn)

		posx = posx + 1

		if posx > 5 then 
			posx = 0
			posy = posy + 1
		end
	end

	local old = self.selected
	hook.Add("Think", "dronesrewrite_selectwep_gui_sel", function(ply, bind, p)
		if not IsValid(self) then hook.Remove("Think", "dronesrewrite_selectwep_gui_sel") return end
		if old != self.selected then select() old = self.selected end
	end)

	for k, v in pairs(btns) do
		if self.selected == k then
			v.DoClick()
			break
		end
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_crucifier/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.DrrBaseType = "walker"
ENT.Type = "anim"
//ENT.PrintName = "CRC 'Crucifier'"
ENT.PrintName = "Crucifier"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "CRC"

ENT.Model = "models/dronesrewrite/walkertank/walkertank.mdl"

ENT.SpawnHeight = 128
ENT.Weight = 10000

ENT.OverlayName = "Drones 1"
ENT.HUD_hudName = "White Box"

ENT.FirstPersonCam_pos = Vector(145, 0, 110)
ENT.ThirdPersonCam_pos = Vector(0, 0, 100)
ENT.ThirdPersonCam_distance = 600
ENT.RenderCam = false

ENT.Speed = 200000
ENT.SprintCoefficient = 1
ENT.RotateSpeed = 4
ENT.PitchOffset = 0
ENT.Hover = 120
ENT.AngOffset = 0

ENT.HackValue = 4

ENT.ExplosionForce = 2
ENT.ExplosionAngForce = 0
ENT.DoExplosionEffect = "splode_big_drone_main"

ENT.Fuel = 2000
ENT.MaxFuel = 2000
ENT.FuelReduction = 10

ENT.AllowPitchRestrictions = true
ENT.PitchMin = -90
ENT.PitchMax = 50

ENT.AllowYawRestrictions = true
ENT.YawMin = -70
ENT.YawMax = 70

ENT.NoiseCoefficient = 5

ENT.WaitForSound = 0.7

ENT.Slip = 180
ENT.AngSlip = 0.03

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()
ENT.KeysFuncs.Physics["Up"] = function(self)
end

ENT.KeysFuncs.Physics["Down"] = function(self)
end

ENT.HealthAmount = 2000
ENT.DefaultHealth = 2000

ENT.Sounds = {
	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 82
	},

	FootSound = {
		Sounds = {
			"physics/metal/metal_barrel_impact_hard1.wav",
			"physics/metal/metal_barrel_impact_hard2.wav",
			"physics/metal/metal_barrel_impact_hard3.wav"
		},

		Pitch = 40,
		Volume = 90
	}
}

ENT.Corners = {
	Vector(-110, -100, 0),
	Vector(-110, 100, 0),
	Vector(100, 100, 0),
	Vector(100, -100, 0)
}

ENT.Attachments = {
	["Minigun"] = {
		Pos = Vector(120, 0, 54.4)
	},

	["Shield"] = {
		Pos = Vector(60, 64, 62)
	},


	["UpRight"] = {
		Pos = Vector(80, 54, 113),
		Angle = Angle(0, 0, 180)
	},

	["UpRight+"] = {
		Pos = Vector(80, 84, 113),
		Angle = Angle(0, 0, 180)
	},

	["UpLeft"] = {
		Pos = Vector(80, -54, 113),
		Angle = Angle(0, 0, 180)
	},

	["UpLeft+"] = {
		Pos = Vector(80, -84, 113),
		Angle = Angle(0, 0, 180)
	},
}

ENT.Weapons = {
	["Heavy Minigun"] = {
		Name = "Heavy Minigun",
		Attachment = "Minigun"
	},

	["Shield"] = {
		Name = "Shield",
		Attachment = "Shield"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_drrwalker/cl_init.lua:
include("shared.lua")


--PATH addons/_drones/lua/entities/dronesrewrite_mine.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/landmine/landmine.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)
	    self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)

	    local phys = self:GetPhysicsObject()

		phys:EnableDrag(false)
	    if IsValid(phys) then phys:Wake() end
	end

	function ENT:Boom()
		self.OnTakeDamage = function() end

		local owner = self.Owner
		if not IsValid(owner) then owner = self end

		util.BlastDamage(self, owner, self:GetPos(), 250, 120)

		ParticleEffect("splode_big_main", self:GetPos(), Angle(0, 0, 0))	
		
		self:EmitSound("ambient/explosions/explode_1.wav", 100, 100)
		
		self:Remove()
	end

	function ENT:Think()
		if self.Enabled then
			for k, v in ipairs(ents.FindInSphere(self:GetPos(), 64)) do
				--if v:GetClass() == "dronesrewrite_mine" then continue end
				--if v:GetClass() == "dronesrewrite_minedr" then continue end

				if (v:IsPlayer() or v:IsNPC() or v.IS_DRR) and v != self.DroneOwner then
					local phys = v:GetPhysicsObject()

					if phys:IsValid() then
						self:Boom()
					end
				end
			end
		end

		self:NextThink(CurTime() + 0.4)
		return true
	end

	function ENT:PhysicsCollide(data, physobj)
		if self.Enabled then
			if not data.HitEntity:IsWorld() and data.HitEntity:GetVelocity():Length() > 50 then self:Boom() end
		else
			self.Enabled = true
			self:EmitSound("drones/alarm.wav", 60)
		end
	end

	function ENT:OnTakeDamage() self:Boom() end
else
	function ENT:Draw()
		self:DrawModel()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_missile.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

local rSound = Sound("Missile.Accelerate")

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/bigrocket/bigrocket.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    local phys = self:GetPhysicsObject()

		phys:EnableDrag(false)
	    if IsValid(phys) then phys:Wake() end
		
	    self.Entity:EmitSound(rSound, 100, 100)
	end

	function ENT:Boom()
		ParticleEffect("splode_big_main", self:GetPos(), Angle(0, 0, 0))	
		
		self:EmitSound("BaseExplosionEffect.Sound", 500, 100)

		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 1024,
			filter = self,
			mask = MASK_SOLID_BRUSHONLY
		})

		util.Decal("DrrBigExpo", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		util.BlastDamage(self, IsValid(self:GetOwner()) and self:GetOwner() or self, self:GetPos(), 200, math.random(180,220))
		util.ScreenShake(self:GetPos(), 2, 0.5, 1, 1000) 
		
		self:Remove()
	end

	function ENT:PhysicsCollide(data, physobj)
		self:Boom()
	end

	function ENT:OnRemove()
		self.Entity:StopSound(rSound)
	end

	function ENT:Think()
		local ef = EffectData()
		ef:SetOrigin(self:GetPos() - self:GetForward() * 4)
		util.Effect("dronesrewrite_rocketfly", ef, true, true)      

		local phys = self:GetPhysicsObject()
		phys:ApplyForceCenter(self:GetForward() * 10000)

		phys:AddAngleVelocity(VectorRand() * math.sin(CurTime() * 3) * 0.14)

		self:NextThink(CurTime())
		return true
	end
else
	function ENT:Draw()
		self:DrawModel()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_mothership/cl_init.lua:
include("shared.lua")

local engine = {
	Vector(-880, 450, 180),
	Vector(-880, -450, 180)
}

function ENT:Draw()
	self:DrawModel()

	if not self.Emitter then self.Emitter = ParticleEmitter(Vector(0, 0, 0)) return end

	if self:IsDroneWorkable() then
		render.SetMaterial(Material("particle/particle_glow_04_additive"))

		for k, v in pairs(engine) do
			local pos = self:LocalToWorld(v)

			render.DrawSprite(pos, 150, 150, Color(255, 125, 0))

			if math.random(1, 5) == 1 then
				local p = self.Emitter:Add("sprites/heatwave", pos)
					
				p:SetDieTime(math.Rand(0.4, 0.8))
				p:SetStartAlpha(70)
				p:SetEndAlpha(0)
				p:SetStartSize(math.Rand(100, 200))
				p:SetRoll(math.Rand(-10, 10))
				p:SetRollDelta(math.Rand(-1, 1))
				p:SetEndSize(50)		
				p:SetCollide(true)
				p:SetGravity(Vector(0, 0, 5))
				p:SetVelocity(-self:GetForward() * math.random(100, 300))
			end
		end

		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:LocalToWorld(Vector(-495, -50, 753))
			dlight.r = 0
			dlight.g = 155
			dlight.b = 255
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 1080
			dlight.DieTime = CurTime() + 0.1
		end
	end
end

function ENT:OnRemove() if self.Emitter then self.Emitter:Finish() end end
--PATH addons/_drones/lua/entities/dronesrewrite_rainbow/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self.BaseClass.Draw(self)
	
	if not self.Emitter then self.Emitter = ParticleEmitter(Vector(0, 0, 0)) end

	if self:IsDroneWorkable() then
		if math.random(1, 2) == 1 then
			local p = self.Emitter:Add("sprites/light_glow02_add", self:GetPos())
						
			p:SetDieTime(math.Rand(0.4, 0.8))
			p:SetStartAlpha(255)
			p:SetEndAlpha(0)
			p:SetStartSize(30)
			p:SetRoll(math.Rand(-10, 10))
			p:SetRollDelta(math.Rand(-1, 1))
			p:SetEndSize(5)		
			p:SetCollide(true)
			p:SetGravity(Vector(0, 0, -5))
			p:SetColor(math.random(0, 255), math.random(0, 255), math.random(0, 255))

			p:SetVelocity(VectorRand() * 80)
		end
	end
end

function ENT:OnRemove() if self.Emitter then self.Emitter:Finish() end end
--PATH addons/_drones/lua/entities/dronesrewrite_rainbow/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Rainbow Drone"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.RenderInCam = false
ENT.UNIT = "RAINBOW"
ENT.HUD_hudName = "No HUD"
ENT.OverlayName = "No Overlay"

ENT.Weight = 1000

ENT.Model = "models/Combine_Helicopter/helicopter_bomb01.mdl"

ENT.FirstPersonCam_pos = Vector(6, 0, 0)
ENT.RenderCam = false

ENT.DoExplosionEffect = "splode_drone_sparks"
ENT.ExplosionForce = 0
ENT.ExplosionAngForce = 0

ENT.Alignment = 5

ENT.NoiseCoefficient = 0
ENT.AngOffset = 6

ENT.Speed = 15000
ENT.UpSpeed = 60000
ENT.RotateSpeed = 7

ENT.PitchOffset = 0

ENT.AllowPitchRestrictions = false

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.ShouldConsumeFuel = false
ENT.Fuel = 1
ENT.MaxFuel = 1

ENT.HealthAmount = 60
ENT.DefaultHealth = 60

ENT.UseFlashlight = false
ENT.UseNightVision = false

ENT.Sounds = {
	PropellerSound = {
		Name = "ambient/water/drip_loop1.wav",
		Level = 76,
		Pitch = 140,
		NoPitchChanges = true
	}
}

ENT.NoPropellers = true
ENT.Propellers = {
	Model = "models/props_junk/PopCan01a.mdl",
	Info = { Vector(0, 0, 0) }
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_turret/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Combine Turret Drone"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "TUR"

ENT.Weight = 128
ENT.SpawnHeight = 1
ENT.Model = "models/Combine_turrets/Floor_turret.mdl"

ENT.HealthAmount = 640
ENT.DefaultHealth = 640

ENT.HUD_hudName = "Drones 1"
ENT.OverlayName = "Default"

ENT.FirstPersonCam_pos = Vector(8, -2, 58.5)
ENT.ThirdPersonCam_pos = Vector(0, 0, 64)
ENT.RenderCam = false

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.HackValue = 2

ENT.PitchMin = -15
ENT.PitchMax = 15

ENT.UseFlashlight = false

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()
ENT.KeysFuncs.Physics = { }

ENT.Sounds = {
	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 80
	}
}

-- TODO: add turret weapon
ENT.Weapons = {
	["Turret's Gun"] = {
		Name = "Turret's Gun",
		Pos = Vector(50, 4, 50)
	}
}

ENT.Modules = DRONES_REWRITE.GetAIModules()
DRONES_REWRITE.CopyModule(ENT.Modules, "Healer")
--PATH addons/_drones/lua/entities/dronesrewrite_ye_laser.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/lray/lray.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    self:DrawShadow(false)
		self:SetColor(Color(255, 255, 255))

	    local phys = self:GetPhysicsObject()

	    phys:SetMass(1)
		phys:EnableDrag(false)
		phys:EnableGravity(false)	
	    phys:Wake()

		self:SetCustomCollisionCheck(true)
	end

	function ENT:PhysicsUpdate(phys)
		if self.LastPhys == CurTime() then return end

		if self:WaterLevel() >= 3 then self:Remove() end

		phys:ApplyForceCenter(self:GetForward() * 100000)

		self.LastPhys = CurTime()
	end

	function ENT:PhysicsCollide(data, physobj)
		local ent = data.HitEntity
		if ent:IsValid() then
			local owner = self.Owner
			ent:TakeDamage(math.random(12,15), owner, owner)
			ent:Ignite(0.7,1)
		end

		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 1024,
			filter = self,
			mask = MASK_SOLID_BRUSHONLY
		})

		ParticleEffect("sparks_rdbl", self:GetPos(), Angle(0, 0, 0))

		util.Decal("FadingScorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		self:Remove()
	end
else
	function ENT:Draw()
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:GetPos()
			dlight.r = 255
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 0.3
		end	

		render.SetMaterial(Material("particle/particle_glow_04_additive"))

		local color = Color(255, 255, 0, 32)
		local xs = 32
		
		render.DrawSprite(self:GetPos() - self:GetForward() * 24, xs, xs, color)
		render.DrawSprite(self:GetPos() - self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos(), xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 24, xs, xs, color)
		
		self:DrawModel()
	end
end
--PATH addons/__main/lua/entities/durgz_cocaine/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.PrintName = "Cocaine"
ENT.Nicknames = {"coke", "cocaine", "candy cane", "the big C"}
ENT.OverdosePhrase = {"overdosed on", "snorted too much", "took too much"}
ENT.Author = "Arash Ansari"
ENT.Category = "Drugs"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Information	 = "Looks like sugar to me..." 

--function for high visuals

ENT.TRANSITION_TIME = 5


if(CLIENT)then

	local cdw, cdw2, cdw3
	cdw2 = -1
	local TRANSITION_TIME = ENT.TRANSITION_TIME; --transition effect from sober to high, high to sober, in seconds how long it will take etc.
	local HIGH_INTENSITY = 0.8; --1 is max, 0 is nothing at all
	local STROBE_PACE = 1
	
	local function DoCocaine()
		if(!DURGZ_LOST_VIRGINITY)then return; end
		--self:SetNWFloat( "SprintSpeed"
		local pl = LocalPlayer();
		local pf;
		
		local tab = {}
		tab[ "$pp_colour_addr" ] = 0
		tab[ "$pp_colour_addg" ] = 0
		tab[ "$pp_colour_addb" ] = 0
		tab[ "$pp_colour_brightness" ] = 0
		tab[ "$pp_colour_contrast" ] = 1
		tab[ "$pp_colour_mulr" ] = 0
		tab[ "$pp_colour_mulg" ] = 0
		tab[ "$pp_colour_mulb" ] = 0
		
		
		if( pl:GetNWFloat("durgz_cocaine_high_start") && pl:GetNWFloat("durgz_cocaine_high_end") > CurTime() )then
		
			if( pl:GetNWFloat("durgz_cocaine_high_start") + TRANSITION_TIME > CurTime() )then
			
				local s = pl:GetNWFloat("durgz_cocaine_high_start");
				local e = s + TRANSITION_TIME;
				local c = CurTime();
				pf = (c-s) / (e-s);
				
				pf = pf*HIGH_INTENSITY
				
				
				
			elseif( pl:GetNWFloat("durgz_cocaine_high_end") - TRANSITION_TIME < CurTime() )then
			
				local e = pl:GetNWFloat("durgz_cocaine_high_end");
				local s = e - TRANSITION_TIME;
				local c = CurTime();
				pf = 1 - (c-s) / (e-s);
				
				pf = pf*HIGH_INTENSITY
				
				pl:SetDSP(1)
				
				
				
			else
			
				
				pf = HIGH_INTENSITY;
				
			end
			
			
				
			if( !cdw || cdw < CurTime() )then
				cdw = CurTime() + STROBE_PACE
				cdw2 = cdw2*-1
			end
			if( cdw2 == -1 )then
				cdw3 = 2
			else
				cdw3 = 0
			end
			local ich = (cdw2*((cdw - CurTime())*(2/STROBE_PACE)))+cdw3 - 1
			
			DrawMaterialOverlay("highs/shader3",  pf*ich*0.05	)
			DrawSharpen(pf*ich*5, 2) 
			
		end
	end
	hook.Add("RenderScreenspaceEffects", "durgz_cocaine_high", DoCocaine)
end

--PATH addons/_eml/lua/entities/eml_ciodine/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()

	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < self:GetNWInt("distance") then
		cam.Start3D2D(pos + ang:Up(), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.1)
				draw.SimpleTextOutlined("Кристалічний Йод ("..self:GetNWInt("amount").." КГ)", "methFont", 32, -96, Color(220, 134, 159, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));			
		cam.End3D2D()	
	end;
end;

-- maxAmount = 60
-- amount = x


--PATH addons/_eml/lua/entities/eml_pot/cl_init.lua:
include("shared.lua");



function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()
	local macidColor = Color(160, 221, 99, 255);
	local sulfurColor = Color(243, 213, 19, 255);
	
	local potTime = "Time: "..self:GetNWInt("time").."s";
	
	if (self:GetNWInt("status") == "inprogress") then
		potTime = "Час: "..self:GetNWInt("time").."сек";
	elseif (self:GetNWInt("status") == "ready") then	
		potTime = "Фосфор Готовий!";
	end;
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < self:GetNWInt("distance") then
		cam.Start3D2D(pos + ang:Up()*8, ang, 0.10)
			surface.SetDrawColor(Color(0, 0, 0, 200));
			surface.DrawRect(-64, -38, 128, 96);		
		cam.End3D2D();
		cam.Start3D2D(pos + ang:Up()*8, ang, 0.055)
			draw.ShadowText("Червоний Фосфор", "Roboto_31", 0, -56, Color(175, 0, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.ShadowText("______________", "Roboto_31", 0, -54, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));

			surface.SetDrawColor(Color(0, 0, 0, 200));
			surface.DrawRect(-104, -32, 204, 24);			
			surface.SetDrawColor(Color(175, 0, 0, 200));
			surface.DrawRect(-101.5, -30, math.Round((self:GetNWInt("time")*198)/self:GetNWInt("maxTime")), 20);		
			
			draw.ShadowText("Інгредієнти", "Roboto_31", -101, 8, Color(175, 0, 0, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.ShadowText("______________", "Roboto_31", 0, 10, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));

			if (self:GetNWInt("macid")==0) then
				macidColor = Color(100, 100, 100, 255);
			else
				macidColor = Color(160, 221, 99, 255);
			end;
			
			if (self:GetNWInt("sulfur")==0) then
				sulfurColor = Color(100, 100, 100, 255);
			else
				sulfurColor = Color(243, 213, 19, 255);
			end;			
			draw.ShadowText("Соляна Кислота ("..self:GetNWInt("macid")..")", "Roboto_31", -101, 38, macidColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.ShadowText("Рідка Сірка ("..self:GetNWInt("sulfur")..")", "Roboto_31", -101, 68, sulfurColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));				
		cam.End3D2D();	
		cam.Start3D2D(pos + ang:Up()*8, ang, 0.035)		
			draw.ShadowText(potTime, "Roboto_31", -152, -32, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));		
		cam.End3D2D();					
	end;
end;


--PATH addons/__________scripts__loader/lua/entities/ent_eblanjob/cl_init.lua:
include( 'shared.lua' )
function ENT:Draw()
    self:DrawModel()
    onyx.npc.label( self, 'Дэбил' )
end
--PATH addons/____onyx_creditstore/lua/entities/ent_npc_onyx_store/shared.lua:
ENT.Type = 'ai'
ENT.Base = 'base_ai'

ENT.PrintName = 'NPC'
ENT.Author = 'tochnonement'
ENT.Category = 'Onyx Store'
ENT.Spawnable = true
ENT.AdminOnly = true
--PATH gamemodes/darkrp/entities/entities/ent_skup/shared.lua:
ENT.Base = "base_ai"
ENT.Type = "ai"
ENT.AutomaticFrameAdvance = true

function ENT:SetAutomaticFrameAdvance(bUsingAnim)
    self.AutomaticFrameAdvance = bUsingAnim
end
--PATH addons/_drones/lua/entities/item_drr_spydr.lua:
AddCSLuaFile()

ENT.Base = "item_drr_ammobase"
ENT.Type = "anim"
ENT.PrintName = "Spy Drones"
ENT.Category = "Drones Rewrite Ammo"
ENT.Spawnable = true
ENT.AdminSpaawnable = true

ENT.Amount = 1
ENT.Model = "models/maxofs2d/hover_classic.mdl"

ENT.RemoveTouched = true
--PATH addons/____inventory/lua/entities/itemstore_bank.lua:
ENT.Type = "anim"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

ENT.PrintName = "Bank"
ENT.Category = "ItemStore"

ENT.Spawnable = true
ENT.AdminOnly = true

if SERVER then
	AddCSLuaFile()

	function ENT:Initialize()
		self:SetModel( "models/props_lab/reciever_cart.mdl" )

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )

		self:GetPhysicsObject():EnableMotion( false )
	end

	function ENT:SpawnFunction( pl, trace, class )
		local ent = ents.Create( class )
		ent:SetPos( trace.HitPos + trace.HitNormal * 16 )
		ent:Spawn()

		return ent
	end

	function ENT:Use( pl )
		if not IsValid( pl ) then return end

		pl.Bank:Sync()
		pl:OpenContainer( pl.Bank:GetID(), itemstore.Translate( "bank" ) )
	end

	concommand.Add( "itemstore_savebanks", function( pl )
		if not game.SinglePlayer() and IsValid( pl ) then return end

		local banks = {}

		for _, ent in ipairs( ents.FindByClass( "itemstore_bank" ) ) do
			table.insert( banks, {
				Position = ent:GetPos(),
				Angles = ent:GetAngles()
			} )
		end

		file.Write( "itemstore/banks/" .. game.GetMap() .. ".txt", util.TableToJSON( banks ) )

		print( "Banks for map " .. game.GetMap() .. " saved." )
	end )

	local function spawn_banks()
		local banks = util.JSONToTable( file.Read( "itemstore/banks/" .. game.GetMap() .. ".txt", "DATA" ) or "" ) or {}

		for _, data in ipairs( banks ) do
			local bank = ents.Create( "itemstore_bank" )
			bank:SetPos( data.Position )
			bank:SetAngles( data.Angles )
			bank:Spawn()
		end
	end

	hook.Add( "InitPostEntity", "ItemStoreSpawnBanks", spawn_banks )
	hook.Add( "PostCleanupMap", "ItemStoreRespawnBanks", spawn_banks )
else
	function ENT:DrawTranslucent()
		self:DrawModel()

		local text = itemstore.Translate( "bank" )
		local font = "DermaLarge"

		surface.SetFont( font )
		local textw, texth = surface.GetTextSize( text )
		local w = 5 + textw + 5
		local h = 2 + texth + 2
		local x, y = -w * 0.5, -h * 0.5

		cam.Start3D2D( self:GetPos() + self:GetAngles():Up() * 50, Angle( 0, CurTime() * 45, 90 ), 0.35 )
			surface.SetDrawColor( Color( 0, 0, 0, 200 ) )
			surface.DrawRect( x, y, w, h )

			draw.SimpleTextOutlined( text, font, 0, 0, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color( 0, 0, 0 ) )
		cam.End3D2D()
	end
end

--PATH addons/____inventory/lua/entities/itemstore_deathloot.lua:
ENT.Type = "anim"
ENT.Base = "itemstore_box"

ENT.PrintName = "Death Loot"
ENT.Category = "ItemStore"

ENT.Spawnable = false
ENT.AdminOnly = false

if SERVER then
	AddCSLuaFile()

	ENT.Model = "models/props_junk/garbage_bag001a.mdl"

	ENT.ContainerWidth = 5
	ENT.ContainerHeight = 5
	ENT.ContainerPages = 2

	ENT.Timeout = 0

	function ENT:Think()
		if self.Timeout < CurTime() then self:Remove() end
	end
end

--PATH addons/____inventory/lua/entities/itemstore_item.lua:
ENT.Type = "anim"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:SetItem( item )
	self.Item = item

	if SERVER then
		self:Sync()
	end
end

function ENT:GetItem()
	return self.Item
end

if SERVER then
	AddCSLuaFile()

	function ENT:Initialize()
		local item = self:GetItem()
		if not item then self:Remove() end

		self:SetModel( item:GetModel() )

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:SetUseType( SIMPLE_USE )

		self:SetColor( item:GetColor() or color_white )
		self:SetMaterial( item:GetMaterial() )

		local phys = self:GetPhysicsObject()
		if not IsValid( phys ) then
			self:PhysicsInitSphere( 16, "default" )
			phys = self:GetPhysicsObject()
		end

		phys:Wake()
	end

	function ENT:Use( pl )
		if not IsValid( pl ) then return end

		local item = self:GetItem()
		if not item then return end

		if pl.Inventory:AddItem( item ) then
			pl:EmitSound( "items/itempickup.wav" )
			self:Remove()
		else
			pl:SendError( "Your inventory is full." )
		end
	end

	function ENT:Sync( pl )
		local item = self:GetItem()
		if not item then return end

		net.Start( "ItemStoreSyncItem" )
			net.WriteEntity( self )
			net.WriteString( item.Class )
			net.WriteTable( item.Data )
		net.Send( pl or player.GetAll() )
	end

	util.AddNetworkString( "ItemStoreSyncItem" )
	net.Receive( "ItemStoreSyncItem", function( len, pl )
		if pl.ItemStoreTimeout and pl.ItemStoreTimeout > CurTime() then return end

		local ent = net.ReadEntity()
		if not IsValid( ent ) or ent:GetClass() ~= "itemstore_item" then return end

		ent:Sync( pl )

		pl.ItemStoreTimeout = CurTime() + ITEMSTORE_TIMEOUT
	end )
else
	function ENT:Initialize()
		net.Start( "ItemStoreSyncItem" )
			net.WriteEntity( self )
		net.SendToServer()
	end

	function ENT:DrawTranslucent()
		local item = self:GetItem()
		if not item then return end

		item:PreRender( self )
			self:DrawModel()
		item:PostRender( self )
	end

	net.Receive( "ItemStoreSyncItem", function()
		local ent = net.ReadEntity()
		
		if not IsValid( ent ) then return end
		if not ent.SetItem then return end

		local class = net.ReadString()
		local data = net.ReadTable()

		ent:SetItem( itemstore.Item( class, data ) )
	end )
end

--PATH addons/lvs_base-main/lua/entities/lvs_base/sh_weapons.lua:

ENT.WEAPONS = {
	[1] = {},
}

function ENT:InitWeapons()
end

function ENT:AddWeapon( weaponData, PodID )
	if not istable( weaponData ) then print("[LVS] couldn't register weapon") return end

	local data = table.Copy( weaponData )

	if not PodID or PodID <= 1 then
		PodID = 1
	end

	if not self.WEAPONS[ PodID ] then
		self.WEAPONS[ PodID ] = {}
	end

	local default = LVS:GetWeaponPreset( "DEFAULT" )

	data.Icon = data.Icon or Material("lvs/weapons/bullet.png")
	data.Ammo = data.Ammo or -1
	data.Delay = data.Delay or FrameTime()

	if isnumber( data.Clip ) and data.Clip > 0 then
		data.HeatIsClip = true

		local ShootDelay = data.Delay

		local Clip = data.Clip
		local ReloadSpeed = data.ReloadSpeed or 2

		data.HeatRateUp = 1.00001 / (ShootDelay * Clip)
		data.HeatRateDown = 1 / ReloadSpeed
		data.OnReload = data.OnReload or default.OnReload
	else
		data.HeatRateUp = data.HeatRateUp or default.HeatRateUp
		data.HeatRateDown = data.HeatRateDown or default.HeatRateDown
	end

	data.Attack = data.Attack or default.Attack
	data.StartAttack = data.StartAttack or default.StartAttack
	data.FinishAttack = data.FinishAttack or default.FinishAttack
	data.OnSelect = data.OnSelect or default.OnSelect
	data.OnDeselect = data.OnDeselect or default.OnDeselect
	data.OnThink = data.OnThink or default.OnThink
	data.OnOverheat = data.OnOverheat or default.OnOverheat
	data.OnRemove = data.OnRemove or default.OnRemove
	data.UseableByAI = data.UseableByAI ~= false

	table.insert( self.WEAPONS[ PodID ], data )
end

function ENT:UpdateWeapon( PodID, WeaponID, weaponData )
	if not self.WEAPONS[ PodID ] then return end

	if not self.WEAPONS[ PodID ][ WeaponID ] then return end

	table.Merge( self.WEAPONS[ PodID ][ WeaponID ], weaponData )
end

function ENT:HasWeapon( ID )
	return istable( self.WEAPONS[1][ ID ] )
end

function ENT:AIHasWeapon( ID )
	local weapon = self.WEAPONS[1][ ID ]
	if not istable( weapon ) then return false end

	return weapon.UseableByAI
end

function ENT:GetActiveWeapon()
	local SelectedID = self:GetSelectedWeapon()
	local CurWeapon = self.WEAPONS[1][ SelectedID ]

	return CurWeapon, SelectedID
end

function ENT:GetMaxAmmo()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return -1 end

	return CurWeapon.Ammo or -1
end

function ENT:GetClip()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return 0 end

	local HeatIncrement = (CurWeapon.HeatRateUp or 0.2) * math.max(CurWeapon.Delay or 0, FrameTime())

	local Ammo = self:GetNWAmmo()

	if self:GetMaxAmmo() <= 0 and CurWeapon.Clip then
		Ammo = CurWeapon.Clip
	end

	return math.min( math.ceil( math.Round( (1 - self:GetNWHeat()) / HeatIncrement, 1 ) ), Ammo )
end

if SERVER then
	function ENT:WeaponRestoreAmmo()
		local AmmoIsSet = false

		for PodID, data in pairs( self.WEAPONS ) do
			for id, weapon in pairs( data ) do
				local MaxAmmo = weapon.Ammo or -1
				local CurAmmo = weapon._CurAmmo or -1

				if CurAmmo == MaxAmmo then continue end

				self.WEAPONS[PodID][ id ]._CurAmmo = MaxAmmo

				AmmoIsSet = true
			end
		end

		if AmmoIsSet then
			self:SetNWAmmo( self:GetAmmo() )

			for _, pod in pairs( self:GetPassengerSeats() ) do
				local weapon = pod:lvsGetWeapon()

				if not IsValid( weapon ) then continue end

				weapon:SetNWAmmo( weapon:GetAmmo() )
			end
		end

		return AmmoIsSet
	end
	
	function ENT:WeaponsOnRemove()
		for _, data in pairs( self.WEAPONS ) do
			for ID, Weapon in pairs( data ) do
				if not Weapon.OnRemove then continue end

				Weapon.OnRemove( self )
			end
		end
	end

	function ENT:WeaponsFinish()
		if not self._activeWeapon then return end

		local CurWeapon = self.WEAPONS[1][ self._activeWeapon ]

		if not CurWeapon then return end

		if CurWeapon.FinishAttack then
			CurWeapon.FinishAttack( self )
		end

		self._activeWeapon = nil
		self.OldAttack = false
	end

	function ENT:GetAmmo()
		if self:GetAI() then return self:GetMaxAmmo() end

		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return -1 end

		return CurWeapon._CurAmmo or self:GetMaxAmmo()
	end

	function ENT:TakeAmmo( num )
		if self:GetMaxAmmo() <= 0 then return end

		local CurWeapon = self:GetActiveWeapon()

		CurWeapon._CurAmmo = math.max( self:GetAmmo() - (num or 1), 0 )

		self:SetNWAmmo( CurWeapon._CurAmmo )
	end

	function ENT:GetHeat( weaponid )
		local CurWeapon

		if isnumber( weaponid ) and weaponid > 0 then
			CurWeapon = self.WEAPONS[1][ weaponid ]
		else
			CurWeapon = self:GetActiveWeapon()
		end

		if not CurWeapon then return 0 end

		return (CurWeapon._CurHeat or 0)
	end

	function ENT:GetOverheated()
		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return false end

		return CurWeapon.Overheated == true
	end

	function ENT:SetOverheated( overheat )
		if self:GetOverheated() == overheat then return end

		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return end

		CurWeapon.Overheated = overheat

		self:SetNWOverheated( overheat )

		if self:GetHeat() == 0 then return end

		if CurWeapon.OnOverheat then
			CurWeapon.OnOverheat( self )
		end
	end

	function ENT:SetHeat( heat )
		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return end

		heat = math.Clamp( heat, 0, 1 )

		CurWeapon._CurHeat = heat

		if self:GetNWHeat() == heat then return end

		self:SetNWHeat( heat )
	end

	function ENT:CanAttack()
		local CurWeapon = self:GetActiveWeapon()

		return (CurWeapon._NextFire or 0) < CurTime()
	end

	function ENT:SetNextAttack( time )
		local CurWeapon = self:GetActiveWeapon()

		CurWeapon._NextFire = time
	end

	function ENT:WeaponsShouldFire()
		if self:GetAI() then return self._AIFireInput end

		local ply = self:GetDriver()

		if not IsValid( ply ) then return false end

		return ply:lvsKeyDown( "ATTACK" )
	end

	function ENT:WeaponsThink()
		local EntTable = self:GetTable()

		local T = CurTime()
		local FT = FrameTime()
		local CurWeapon, SelectedID = self:GetActiveWeapon()
	
		for ID, Weapon in pairs( EntTable.WEAPONS[1] ) do
			local IsActive = ID == SelectedID

			if Weapon.OnThink then Weapon.OnThink( self, IsActive ) end

			if IsActive then continue end

			if Weapon.HeatIsClip and not Weapon.Overheated and Weapon._CurHeat ~= 0 then
				Weapon.Overheated = true
				Weapon._CurHeat = 1

				if Weapon.OnReload then Weapon.OnReload( self ) end
			end

			-- cool all inactive weapons down
			Weapon._CurHeat = Weapon._CurHeat and Weapon._CurHeat - math.min( Weapon._CurHeat, (Weapon.HeatRateDown or 0.25) * FT ) or 0
		end

		if not CurWeapon then return end

		local ShouldFire = self:WeaponsShouldFire()
		local CurHeat = self:GetHeat()

		if self:GetOverheated() then
			if CurHeat <= 0 then
				self:SetOverheated( false )
			else
				ShouldFire = false
			end
		else
			if CurHeat >= 1 then
				self:SetOverheated( true )
				ShouldFire = false
				if CurWeapon.OnReload then CurWeapon.OnReload( self ) end
			end
		end

		if self:GetMaxAmmo() > 0 then
			if self:GetAmmo() <= 0 then
				ShouldFire = false
			end
		end

		if ShouldFire ~= EntTable.OldAttack then
			EntTable.OldAttack = ShouldFire

			if ShouldFire then
				if CurWeapon.StartAttack then
					CurWeapon.StartAttack( self )
				end
				EntTable._activeWeapon = SelectedID
			else
				self:WeaponsFinish()
			end
		end

		if ShouldFire then
			if not self:CanAttack() then return end

			local ShootDelay = (CurWeapon.Delay or 0)

			self:SetNextAttack( T + ShootDelay )
			self:SetHeat( CurHeat + (CurWeapon.HeatRateUp or 0.2) * math.max(ShootDelay, FT) )

			if not CurWeapon.Attack then return end

			if CurWeapon.Attack( self ) then
				self:SetHeat( CurHeat - math.min( self:GetHeat(), (CurWeapon.HeatRateDown or 0.25) * FT ) )
				self:SetNextAttack( T )
			end

			EntTable._lvsNextActiveWeaponCoolDown = T + 0.25
		else
			if (EntTable._lvsNextActiveWeaponCoolDown or 0) > T then return end

			if CurWeapon.HeatIsClip and not CurWeapon.Overheated then

				self:SetHeat( self:GetHeat() )
	
				return
			end

			self:SetHeat( self:GetHeat() - math.min( self:GetHeat(), (CurWeapon.HeatRateDown or 0.25) * FT ) )
		end
	end

	function ENT:SelectWeapon( ID )
		if not isnumber( ID ) then return end

		if self.WEAPONS[1][ ID ] then
			self:SetSelectedWeapon( ID )
		end

		local ply = self:GetDriver()

		if not IsValid( ply ) then return end

		net.Start( "lvs_select_weapon" )
		net.Send( ply )
	end

	function ENT:OnWeaponChanged( name, old, new)
		if new == old then return end

		self:WeaponsFinish()

		local PrevWeapon = self.WEAPONS[1][ old ]
		if PrevWeapon and PrevWeapon.OnDeselect then
			PrevWeapon.OnDeselect( self, new )
		end

		local NextWeapon = self.WEAPONS[1][ new ]
		if NextWeapon and NextWeapon.OnSelect then
			NextWeapon.OnSelect( self, old )
			self:SetNWAmmo( NextWeapon._CurAmmo or NextWeapon.Ammo or -1 )
			self:SetNWOverheated( NextWeapon.Overheated == true )
		end
	end

	return
end

function ENT:DrawWeaponIcon( PodID, ID, x, y, width, height, IsSelected, IconColor )
end

function ENT:SelectWeapon( ID )
	if not isnumber( ID ) then return end

	net.Start( "lvs_select_weapon" )
		net.WriteInt( ID, 5 )
		net.WriteBool( false )
	net.SendToServer()
end

function ENT:NextWeapon()
	net.Start( "lvs_select_weapon" )
		net.WriteInt( 1, 5 )
		net.WriteBool( true )
	net.SendToServer()
end

function ENT:PrevWeapon()
	net.Start( "lvs_select_weapon" )
		net.WriteInt( -1, 5 )
		net.WriteBool( true )
	net.SendToServer()
end

LVS:AddHudEditor( "WeaponSwitcher", ScrW() - 210, ScrH() - 165,  200, 68, 200, 68, "WEAPON SELECTOR", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintWeapons then return end
		vehicle:LVSHudPaintWeapons( X, Y, W, H, ScrX, ScrY, ply )
	end
)

LVS:AddHudEditor( "WeaponInfo", ScrW() - 230, ScrH() - 85,  220, 75, 220, 75, "WEAPON INFO", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintWeaponInfo then return end

		vehicle:LVSHudPaintWeaponInfo( X, Y, W, H, ScrX, ScrY, ply )
	end
)

function ENT:GetAmmoID( ID )
	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return -1 end

	local selected = Base:GetSelectedWeapon()
	local weapon = self.WEAPONS[ Base:GetPodIndex() ][ ID ]

	if ID == selected then
		weapon._CurAmmo = Base:GetNWAmmo()
	else
		weapon._CurAmmo = weapon._CurAmmo or weapon.Ammo or -1
	end

	return weapon._CurAmmo
end


local Circles = {
	[1] = {r = -1, col = Color(0,0,0,200)},
	[2] = {r = 0, col = Color(255,255,255,200)},
	[3] = {r = 1, col = Color(255,255,255,255)},
	[4] = {r = 2, col = Color(255,255,255,200)},
	[5] = {r = 3, col = Color(0,0,0,200)},
}

local function DrawCircle( X, Y, target_radius, heatvalue, overheated )
	local endang = 360 * heatvalue

	if endang == 0 then return end

	for i = 1, #Circles do
		local data = Circles[ i ]
		local radius = target_radius + data.r
		local segmentdist = endang / ( math.pi * radius * 0.5 )

		for a = 0, endang, segmentdist do
			local r = data.col.r
			local g = data.col.g * (1 - math.min(a / 270,1))
			local b = data.col.b * (1 - math.min(a / 90,1))

			surface.SetDrawColor( r, g, b, data.col.a )

			surface.DrawLine( X - math.sin( math.rad( a ) ) * radius, Y + math.cos( math.rad( a ) ) * radius, X - math.sin( math.rad( a + segmentdist ) ) * radius, Y + math.cos( math.rad( a + segmentdist ) ) * radius )
		end
	end
end

ENT.HeatMat = Material( "lvs/heat.png" )
ENT.HeatIsClipMat = Material( "lvs/3d2dmats/refil.png" )

local color_white = color_white
local color_red = Color(255,0,0,255)

function ENT:LVSHudPaintWeaponInfo( X, Y, w, h, ScrX, ScrY, ply )
	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return end

	local ID = Base:GetSelectedWeapon()

	if not Base:HasWeapon( ID ) then return end

	local Weapon = Base:GetActiveWeapon()
	local Heat = Base:GetNWHeat()
	local OverHeated = Base:GetNWOverheated()
	local Ammo = Base:GetNWAmmo()

	if Weapon and Weapon.HeatIsClip then
		local Pod = ply:GetVehicle()

		if not IsValid( Pod ) then return end

		local PodID = Base:GetPodIndex()

		local FT = FrameTime()
		local ShootDelay = math.max(Weapon.Delay or 0, FT)
		local HeatIncrement = (Weapon.HeatRateUp or 0.2) * ShootDelay

		local Clip = Base:GetClip()

		if OverHeated then
			Clip = 0

			local hX = X + w - h * 0.5
			local hY = Y + h * 0.25 + h * 0.25
	
			surface.SetMaterial( self.HeatIsClipMat )
			surface.SetDrawColor( 0, 0, 0, 200 )
			surface.DrawTexturedRectRotated( hX + 3, hY + 1, h, h, 0 )
			surface.SetDrawColor( 255, 0, 0, 255 )
			surface.DrawTexturedRectRotated( hX + 1, hY - 1, h, h, 0 )

			DrawCircle( hX, hY, h * 0.35, Heat )
		end

		Ammo = Ammo - Clip

		local ColDyn = (Clip == 0 or OverHeated) and color_red or color_white

		draw.DrawText( "AMMO ", "LVS_FONT", X + 72, Y + 35, ColDyn, TEXT_ALIGN_RIGHT )

		draw.DrawText( Clip, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, ColDyn, TEXT_ALIGN_LEFT )

		if Base:GetMaxAmmo() <= 0 then return end

		local ColDyn2 = Ammo <= Weapon.Clip and color_red or color_white

		X = X + math.max( (#string.Explode( "", Clip ) - 1) * 18, 0 )

		draw.DrawText( "/", "LVS_FONT_HUD_LARGE", X + 96, Y + 30, ColDyn2, TEXT_ALIGN_LEFT )

		draw.DrawText( Ammo, "LVS_FONT", X + 110, Y + 40, ColDyn2, TEXT_ALIGN_LEFT )

		return
	end

	local hX = X + w - h * 0.5
	local hY = Y + h * 0.25 + h * 0.25
	local hAng = math.cos( CurTime() * 50 ) * 5 * (OverHeated and 1 or Heat ^ 2)

	surface.SetMaterial( self.HeatMat )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, h * 0.5, h * 0.5, hAng )

	if OverHeated then
		surface.SetDrawColor( 255, 0, 0, 255 )
	else
		surface.SetDrawColor( 255, 255 * (1 - Heat), 255 * math.max(1 - Heat * 1.5,0), 255 )
	end

	surface.DrawTexturedRectRotated( hX + 2, hY - 1, h * 0.5, h * 0.5, hAng )

	DrawCircle( hX, hY, h * 0.35, Heat )

	if Base:GetMaxAmmo() <= 0 then return end

	draw.DrawText( "AMMO ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( Ammo, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )
end

function ENT:LVSHudPaintWeapons( X, Y, w, h, ScrX, ScrY, ply )
	local EntTable = self:GetTable()

	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return end

	local Pod = ply:GetVehicle()

	if not IsValid( Pod ) then return end

	local PodID = Base:GetPodIndex()

	local num = #self.WEAPONS[ PodID ]

	if num <= 1 then return end

	local CenterY = (Y + h * 0.5)
	local CenterX = (X + w * 0.5)

	local FlatSelector = CenterX > ScrX * 0.333 and CenterX < ScrX * 0.666

	local T = CurTime()
	local FT = RealFrameTime()

	local gap = 4
	local SizeY = h - gap

	local Selected = Base:GetSelectedWeapon()
	if Selected ~= EntTable._OldSelected then
		EntTable._OldSelected = Selected
		Pod._SelectActiveTime = T + 2
	end

	local tAlpha = (Pod._SelectActiveTime or 0) > T and 1 or 0
	local tAlphaRate = FT * 15

	EntTable.smAlphaSW = EntTable.smAlphaSW and (EntTable.smAlphaSW + math.Clamp(tAlpha - EntTable.smAlphaSW,-tAlphaRate,tAlphaRate)) or 0

	if EntTable.smAlphaSW > 0.95 then
		EntTable._DisplaySelected = Selected
	else
		EntTable._DisplaySelected = EntTable._DisplaySelected or Selected
	end

	local A255 = 255 * EntTable.smAlphaSW
	local A150 = 150 * EntTable.smAlphaSW

	local Col = Color(0,0,0,A150)
	local ColSelect = Color(255,255,255,A150)

	local SwapY = 0

	if Y < (ScrY * 0.5 - h * 0.5) then
		SwapY = 1
	end

	for ID = 1, num do
		local IsSelected = EntTable._DisplaySelected == ID
		local n = num - ID
		local xPos = FlatSelector and X + (w + gap) * (ID - 1) - ((w + gap) * 0.5 * num - w * 0.5) or X
		local yPos = FlatSelector and Y - h * math.min(SwapY,0) or Y - h * n + (num - 1) * h * SwapY

		draw.RoundedBox(5, xPos, yPos, w, SizeY, IsSelected and ColSelect or Col )

		if IsSelected then
			surface.SetDrawColor( 0, 0, 0, A255 )
		else
			surface.SetDrawColor( 255, 255, 255, A255 )
		end

		if isbool( EntTable.WEAPONS[PodID][ID].Icon ) then
			local col = IsSelected and Color(255,255,255,A255) or Color(0,0,0,A255) 
			self:DrawWeaponIcon( PodID, ID, xPos, yPos, SizeY * 2, SizeY, IsSelected, col )
		else
			surface.SetMaterial( self.WEAPONS[PodID][ID].Icon )
			surface.DrawTexturedRect( xPos, yPos, SizeY * 2, SizeY )
		end

		local ammo = self:GetAmmoID( ID )

		if ammo > -1 then
			draw.DrawText( ammo, "LVS_FONT_HUD", xPos + w - 10, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
		else
			draw.DrawText( "O", "LVS_FONT_HUD", xPos + w - 19, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
			draw.DrawText( "O", "LVS_FONT_HUD", xPos + w - 10, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
		end
	end
end
--PATH addons/lvs_base-main/lua/entities/lvs_destruction.lua:
AddCSLuaFile()

ENT.Type            = "anim"

local gibs = {
	"models/gibs/manhack_gib01.mdl",
	"models/gibs/manhack_gib02.mdl",
	"models/gibs/manhack_gib03.mdl",
	"models/gibs/manhack_gib04.mdl",
	"models/props_c17/canisterchunk01a.mdl",
	"models/props_c17/canisterchunk01d.mdl",
	"models/props_c17/oildrumchunk01a.mdl",
	"models/props_c17/oildrumchunk01b.mdl",
	"models/props_c17/oildrumchunk01c.mdl",
	"models/props_c17/oildrumchunk01d.mdl",
	"models/props_c17/oildrumchunk01e.mdl",
}

for _, modelName in ipairs( gibs ) do
	util.PrecacheModel( modelName )
end

if SERVER then
	function ENT:Initialize()
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false ) 

		self.Vel = isvector( self.Vel ) and self.Vel or Vector(0,0,0)

		local fxPos = self:LocalToWorld( self:OBBCenter() )
	
		local effectdata = EffectData()
			effectdata:SetOrigin( fxPos )
		util.Effect( "lvs_explosion", effectdata )

		self.GibModels = istable( self.GibModels ) and self.GibModels or gibs

		self.Gibs = {}
		self.DieTime = CurTime() + 5

		local Speed = self.Vel:Length()

		for _, v in pairs( self.GibModels ) do
			local ent = ents.Create( "prop_physics" )

			if not IsValid( ent ) then continue end

			table.insert( self.Gibs, ent ) 

			ent:SetPos( self:GetPos() )
			ent:SetAngles( self:GetAngles() )
			ent:SetModel( v )
			ent:Spawn()
			ent:Activate()
			ent:SetRenderMode( RENDERMODE_TRANSALPHA )
			ent:SetCollisionGroup( COLLISION_GROUP_WORLD )

			local PhysObj = ent:GetPhysicsObject()
			if IsValid( PhysObj ) then
				if Speed <= 250 then
					local GibDir = Vector( math.Rand(-1,1), math.Rand(-1,1), 1.5 ):GetNormalized()
					PhysObj:SetVelocityInstantaneous( GibDir * math.random(800,1300)  )
				else
					PhysObj:SetVelocityInstantaneous( VectorRand() * math.max(300,self.Vel:Length() / 3) + self.Vel  )
				end

				PhysObj:AddAngleVelocity( VectorRand() * 500 ) 
				PhysObj:EnableDrag( false ) 

				local effectdata = EffectData()
					effectdata:SetOrigin( fxPos )
					effectdata:SetStart( PhysObj:GetMassCenter() )
					effectdata:SetEntity( ent )
					effectdata:SetScale( math.Rand(0.3,0.7) )
					effectdata:SetMagnitude( math.Rand(0.5,2.5) )
				util.Effect( "lvs_firetrail", effectdata )
			end

			timer.Simple( 4.5 + math.Rand(0,0.5), function()
				if not IsValid( ent ) then return end

				ent:SetRenderMode( RENDERMODE_TRANSCOLOR )
				ent:SetRenderFX( kRenderFxFadeFast  )
			end )
		end
	end

	function ENT:Think()
		if self.DieTime < CurTime() then
			self:Remove()
		end

		self:NextThink( CurTime() + 1 )

		return true
	end

	function ENT:OnRemove()
		if istable( self.Gibs ) then
			for _, v in pairs( self.Gibs ) do
				if IsValid( v ) then
					v:Remove()
				end
			end
		end
	end
else
	function ENT:Draw()
	end
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_gauge.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Gauge"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/diggercars/tacho.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:PhysWake()
	end

	function ENT:Think()
		return false
	end

	function ENT:PhysicsCollide( data )
		if self.MarkForRemove then return end

		local ent = data.HitEntity

		if not IsValid( ent ) or not ent.LVS or not isfunction( ent.SetRacingHud ) then return end

		ent:SetRacingHud( not ent:GetRacingHud() )

		local ply = self:GetCreator()

		if ent:GetRacingHud() then
			ent:EmitSound("common/wpn_hudoff.wav")

			if IsValid( ply ) then
				ply:ChatPrint( "Gauge Added" )
			end
		else
			ent:EmitSound("common/wpn_denyselect.wav")

			if IsValid( ply ) then
				ply:ChatPrint( "Gauge Removed" )
			end
		end

		self.MarkForRemove = true

		SafeRemoveEntityDelayed( self, 0 )
	end

	function ENT:OnTakeDamage( dmginfo )
	end

else
	function ENT:Draw( flags )
		self:DrawModel( flags )
	end
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_jerrycan.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Jerry Can (Petrol)"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

ENT.AutomaticFrameAdvance = true

ENT.FuelAmount = 500 -- seconds
ENT.FuelType = LVS.FUELTYPE_PETROL

ENT.lvsGasStationFillSpeed = 0.05
ENT.lvsGasStationRefillMe = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Active" )
	self:NetworkVar( "Float", 0, "Fuel" )
	self:NetworkVar( "Entity",0, "User" )

	if SERVER then
		self:SetFuel( 1 )
	end
end

function ENT:IsOpen()
	return self:GetActive()
end

function ENT:IsUpright()
	local Up = self:GetUp()

	return Up.z > 0.5
end

function ENT:GetFuelType()
	return self.FuelType
end

function ENT:GetSize()
	return self.FuelAmount
end

function ENT:GetFuelType()
	return self.FuelType
end

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/misc/fuel_can.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )
	end

	function ENT:OnRefueled()
		self:EmitSound( "vehicles/jetski/jetski_no_gas_start.wav" )
	end

	function ENT:TakeFuel( Need )
		local Fuel = self:GetFuel()
		local Size = self:GetSize()
		local Available = math.min( Size * Fuel, Size* self.lvsGasStationFillSpeed )
		local Give = math.min( Need, Available )

		self:SetFuel( Fuel - Give / Size )

		return Give
	end

	function ENT:giveSWEP( ply )
		self:EmitSound("common/wpn_select.wav")

		ply:SetSuppressPickupNotices( true )
		ply:Give( "weapon_lvsfuelfiller" )
		ply:SetSuppressPickupNotices( false )

		ply:SelectWeapon( "weapon_lvsfuelfiller" )
		self:SetUser( ply )

		local SWEP = ply:GetWeapon( "weapon_lvsfuelfiller" )
	
		if not IsValid( SWEP ) then return end

		SWEP:SetFuelType( self:GetFuelType() )
		SWEP:SetCallbackTarget( self )
	end

	function ENT:removeSWEP( ply )
		if ply:HasWeapon( "weapon_lvsfuelfiller" ) then
			ply:StripWeapon( "weapon_lvsfuelfiller" )
			ply:SwitchToDefaultWeapon()
		end
		self:SetUser( NULL )
	end

	function ENT:checkSWEP( ply )
		if not ply:Alive() or ply:InVehicle() then

			self:removeSWEP( ply )

			return
		end

		local weapon = ply:GetActiveWeapon()

		if not IsValid( weapon ) or weapon:GetClass() ~= "weapon_lvsfuelfiller" then
			self:removeSWEP( ply )

			return
		end

		if (ply:GetPos() - self:GetPos()):LengthSqr() < 150000 then return end

		self:removeSWEP( ply )
	end

	function ENT:Think()
		if self:IsOpen() and not self:IsUpright() then
			local amount = FrameTime() * 0.25

			self:SetFuel( math.max( self:GetFuel() - amount, 0 ) )
		end

		local ply = self:GetUser()
		local T = CurTime()

		if IsValid( ply ) then
			self:checkSWEP( ply )
		end

		self:NextThink( T )

		return true
	end

	function ENT:Use( ply )
		if not IsValid( ply ) or not ply:IsPlayer() then return end

		local Active = self:GetActive()
		local User = self:GetUser()

		if IsValid( User ) and User == ply then
			self:removeSWEP( ply )
			self:PlayAnimation( "close" )
			self:SetActive( false )

			return
		end

		if Active then
			if ply:HasWeapon("weapon_lvsfuelfiller") or ply:KeyDown( IN_WALK ) or ply:KeyDown( IN_SPEED ) then
				self:PlayAnimation( "close" )
				self:SetActive( false )
			else
				if not IsValid( User ) then
					self:giveSWEP( ply )
				end
			end
	
			return
		end

		self:SetActive ( true )
		self:PlayAnimation( "open" )
		self:EmitSound("buttons/lever7.wav")
	end

	function ENT:OnRemove()
		local User = self:GetUser()

		if not IsValid( User ) then return end

		self:removeSWEP( User )
	end

	function ENT:PhysicsCollide( data, physobj )
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:PlayAnimation( animation, playbackrate )
		playbackrate = playbackrate or 1

		local sequence = self:LookupSequence( animation )

		self:ResetSequence( sequence )
		self:SetPlaybackRate( playbackrate )
		self:SetSequence( sequence )
	end
end

if CLIENT then
	ENT.FrameMat = Material( "lvs/3d2dmats/frame.png" )
	ENT.RefuelMat = Material( "lvs/3d2dmats/refuel.png" )

	function ENT:Draw()
		self:DrawModel()
		self:DrawCable()

		local ply = LocalPlayer()
		local Pos = self:GetPos()

		if not IsValid( ply ) then return end

		if ply:HasWeapon("weapon_lvsfuelfiller") then return end

		if (ply:GetPos() - Pos):LengthSqr() > 5000000 then return end

		local data = LVS.FUELTYPES[ self.FuelType ]
		local Text = data.name
		local IconColor = Color( data.color.x, data.color.y, data.color.z, 255 )

		for i = -1, 1, 2 do
			cam.Start3D2D( self:LocalToWorld( Vector(0,4 * i,0) ), self:LocalToWorldAngles( Angle(0,90 + 90 * i,90) ), 0.1 )
				surface.SetDrawColor( IconColor )

				surface.SetMaterial( self.FrameMat )
				surface.DrawTexturedRect( -50, -50, 100, 100 )

				surface.SetMaterial( self.RefuelMat )
				surface.DrawTexturedRect( -50, -50, 100, 100 )

				draw.SimpleText( Text, "LVS_FONT", 0, 75, IconColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

				draw.SimpleText( math.Round( self:GetFuel() * 100, 0 ).."%", "LVS_FONT", 0, 95, IconColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			cam.End3D2D()
		end
	end

	local cable = Material( "cable/cable2" )
	local function bezier(p0, p1, p2, p3, t)
		local e = p0 + t * (p1 - p0)
		local f = p1 + t * (p2 - p1)
		local g = p2 + t * (p3 - p2)

		local h = e + t * (f - e)
		local i = f + t * (g - f)

		local p = h + t * (i - h)

		return p
	end

	function ENT:DrawCable()
		local plyL = LocalPlayer()

		if not IsValid( plyL ) then return end

		if plyL:GetPos():DistToSqr( self:GetPos() ) > 350000 then return end

		local ply = self:GetUser()

		if not IsValid( ply ) then return end

		local pos = self:LocalToWorld( Vector(10,0,45) )
		local ang = self:LocalToWorldAngles( Angle(0,90,90) )

		local startPos = self:LocalToWorld( Vector(7,0,5) )
		local p2 = self:LocalToWorld( Vector(8,0,40) )
		local p3
		local endPos

		local id = ply:LookupAttachment("anim_attachment_rh")
		local attachment = ply:GetAttachment( id )

		if not attachment then return end

		endPos = (attachment.Pos + attachment.Ang:Forward() * -3 + attachment.Ang:Right() * 2 + attachment.Ang:Up() * -3.5)
		p3 = endPos + attachment.Ang:Right() * 5 - attachment.Ang:Up() * 20

		render.StartBeam( 15 )
		render.SetMaterial( cable )

		for i = 0,15 do
			local pos = bezier(startPos, p2, p3, endPos, i / 14)

			local Col = (render.GetLightColor( pos ) * 0.8 + Vector(0.2,0.2,0.2)) * 255

			render.AddBeam( pos, 1, 0, Color(Col.r,Col.g,Col.b,255) )
		end

		render.EndBeam()
	end

	function ENT:OnRemove()
		self:StopPour()
	end

	function ENT:StartPour()
		if self.snd then return end

		self.snd =  CreateSound( self, "lvs/jerrycan_use.wav" )
		self.snd:PlayEx(0.5,80)
		self.snd:ChangePitch(120,3)
	end

	function ENT:StopPour()
		if not self.snd then return end

		self.snd:Stop()
		self.snd = nil
	end

	function ENT:DoEffect()
		local Up = self:GetUp()
		local Pos = self:LocalToWorld( Vector(7.19,-0.01,10.46) )

		local emitter = ParticleEmitter( Pos, false )
		local particle = emitter:Add( "effects/slime1", Pos )

		if particle then
			particle:SetVelocity( Up * math.abs( Up.z ) * 100 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetDieTime( 2 )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 1.5 )
			particle:SetEndSize( 1.5 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 240,200,0,255 )
			particle:SetCollide( true )
			particle:SetCollideCallback( function( part, hitpos, hitnormal )
				local effectdata = EffectData() 
					effectdata:SetOrigin( hitpos ) 
					effectdata:SetNormal( hitnormal * 2 ) 
					effectdata:SetMagnitude( 0.2 ) 
					effectdata:SetScale( 0.2 ) 
					effectdata:SetRadius( 0.2 ) 
				util.Effect( "StriderBlood", effectdata )

				sound.Play( "ambient/water/water_spray"..math.random(1,3)..".wav", hitpos, 55, math.Rand(95,105), 0.5 )

				particle:SetDieTime( 0 )

				if not IsValid( self ) then return false end

				if not self.LastPos then self.LastPos = hitpos end

				if (self.LastPos - hitpos):Length() < 10 then
					return
				end

				self.LastPos = hitpos

				util.Decal( "BeerSplash", hitpos + hitnormal * 2, hitpos - hitnormal * 2 )
			end )
		end

		emitter:Finish()
	end

	function ENT:Think()
		self:SetNextClientThink( CurTime() + 0.02 )

		if self:GetFuel() <= 0 then self:StopPour() return end

		local T = CurTime()

		if not self:IsOpen() or self:IsUpright() then

			self:StopPour()

			return true
		end

		self:StartPour()

		self:DoEffect()

		return true
	end
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_turbo.lua:
AddCSLuaFile()

ENT.Base = "lvs_wheeldrive_engine_mod"

ENT.PrintName = "Turbo"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

if SERVER then
	function ENT:Initialize()	
		self:SetModel("models/diggercars/dodge_charger/turbo.mdl")
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:PhysWake()
	end

	function ENT:OnLinked( ent )
		ent:OnTurboCharged( true )
		ent:SetTurbo( self )

		if not self.PlaySound then return end

		ent:EmitSound("lvs/equip_turbo.ogg")
	end

	function ENT:OnUnLinked( ent )
		ent:OnTurboCharged( false )

		if not duplicator or not duplicator.ClearEntityModifier then return end

		duplicator.ClearEntityModifier( ent, "lvsCarTurbo" )
	end

	function ENT:CanLink( ent )
		if not ent.AllowTurbo or IsValid( ent:GetTurbo() ) then return false end

		return true
	end

	local function SaveTurbo( ply, ent, data )
		if not duplicator or not duplicator.StoreEntityModifier then return end

		timer.Simple( 0.2, function()
			if not IsValid( ent ) or not isfunction( ent.AddTurboCharger ) then return end

			local turbo = ent:AddTurboCharger()
			if IsValid( turbo ) then
				if data.Curve then turbo:SetEngineCurve( data.Curve ) end
				if data.Torque then turbo:SetEngineTorque( data.Torque ) end
			end
		end )

		duplicator.StoreEntityModifier( ent, "lvsCarTurbo", data )
	end

	if duplicator and duplicator.RegisterEntityModifier then
		duplicator.RegisterEntityModifier( "lvsCarTurbo", SaveTurbo )
	end

	function ENT:OnVehicleUpdated( ent )
		if not duplicator or not duplicator.ClearEntityModifier or not duplicator.StoreEntityModifier then return end

		duplicator.ClearEntityModifier( ent, "lvsCarTurbo" )
		local data = {
			Curve = self:GetEngineCurve(),
			Torque = self:GetEngineTorque(),
		}
		duplicator.StoreEntityModifier( ent, "lvsCarTurbo", data )
	end

	return
end

function ENT:OnEngineActiveChanged( Active, soundname )
	if Active then
		self:StartSounds( soundname )
	else
		self:StopSounds()
	end
end

function ENT:StartSounds( soundname )
	if self.snd then return end

	self.snd = CreateSound( self, soundname )
	self.snd:PlayEx(0,100)
end

function ENT:StopSounds()
	if not self.snd then return end

	self.snd:Stop()
	self.snd = nil
end

function ENT:HandleSounds( vehicle, engine )
	if not self.snd then return end

	if not self.TurboRPM then
		self.TurboRPM = 0
	end

	local FT = FrameTime()

	local throttle = engine:GetClutch() and 0 or vehicle:GetThrottle()

	local volume = math.Clamp(((self.TurboRPM - 300) / 300),0,1) * vehicle.TurboVolume
	local pitch = math.min(self.TurboRPM / 3,150)

	if throttle == 0 and (self.TurboRPM > 350) then
		if istable( vehicle.TurboBlowOff ) then
			self:EmitSound( vehicle.TurboBlowOff[ math.random( 1, #vehicle.TurboBlowOff ) ], 75, 100, volume * LVS.EngineVolume )
		else
			self:EmitSound( vehicle.TurboBlowOff, 75, 100, volume * LVS.EngineVolume )
		end
		self.TurboRPM = 0
	end

	local rpm = engine:GetRPM()
	local maxRPM = vehicle.EngineMaxRPM

	local ply = LocalPlayer()
	local doppler = vehicle:CalcDoppler( ply )

	self.TurboRPM = self.TurboRPM + math.Clamp(math.min(rpm / maxRPM,1) * 600 * (0.75 + 0.25 * throttle) - self.TurboRPM,-100 * FT,500 * FT)

	self._smBoost = self._smBoost and self._smBoost + (math.min( (self.TurboRPM or 0) / 400, 1 ) - self._smBoost) * FT * 10 or 0

	self.snd:ChangeVolume( volume * engine:GetEngineVolume() )
	self.snd:ChangePitch( pitch * doppler )
end

function ENT:Think()
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then return end

	local EngineActive = vehicle:GetEngineActive()

	if self._oldEnActive ~= EngineActive then
		self._oldEnActive = EngineActive

		self:OnEngineActiveChanged( EngineActive, vehicle.TurboSound )
	end

	if EngineActive then
		local engine = vehicle:GetEngine()

		if not IsValid( engine ) then return end

		self:HandleSounds( vehicle, engine )
	end
end

function ENT:OnRemove()
	self:StopSounds()
end

function ENT:Draw( flags )
	if IsValid( self:GetBase() ) then return end

	self:DrawModel( flags )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_tank_wheeldrive/modules/cl_tankview.lua:
if SERVER then return end

function ENT:TankViewOverride( ply, pos, angles, fov, pod )
	return pos, angles, fov
end

function ENT:CalcTankView( ply, original_pos, original_ang, original_fov, pod )
	local pos, angles, fov = self:TankViewOverride( ply, original_pos, original_ang, original_fov, pod )

	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local clamped_angles = pod:WorldToLocalAngles( angles )
	clamped_angles.p = math.max( clamped_angles.p, -20 )
	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

	local StartPos = pos
	local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * pod:GetCameraHeight())

	local WallOffset = 4

	local tr = util.TraceHull( {
		start = StartPos,
		endpos = EndPos,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.angles = angles + Angle(5,0,0)
	view.origin = tr.HitPos + pod:GetUp() * 65
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:CalcViewDirectInput( ply, pos, angles, fov, pod )
	if not pod:GetThirdPersonMode() then
		angles = pod:LocalToWorldAngles( ply:EyeAngles() )
	end

	return self:CalcTankView( ply, pos, angles, fov, pod )
end

function ENT:CalcViewMouseAim( ply, pos, angles, fov, pod )
	return self:CalcTankView( ply, pos, angles, fov, pod )
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	if not pod:GetThirdPersonMode() then
		angles = pod:LocalToWorldAngles( ply:EyeAngles() )
	end

	return self:CalcTankView( ply, pos, angles, fov, pod )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_audi_s5_b8/cl_init.lua:
include("shared.lua")

function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
	self:SetPoseParameter( "vehicle_steer", steer )
	self:SetPoseParameter( "tacho_gauge", engine_rpm / 8000 )
	self:SetPoseParameter( "vehicle_gauge", speed_kmh / 300 )
	self:SetPoseParameter( "temp_gauge", temperature )
	self:SetPoseParameter( "fuel_gauge", fuel )
	self:SetPoseParameter( "throttle_pedal", throttle )
	self:SetPoseParameter( "brake_pedal", brake )
	self:SetPoseParameter( "handbrake_pedal", handbrake )
	self:SetPoseParameter( "clutch_pedal", clutch )

	local GearIDtoPose = {
		[-1] = 0,
		[1] = 3,
		[2] = 5,
		[3] = 8,
		[4] = 10,
		[5] = 13,
		[6] = 15,
	}

	self:SetPoseParameter( "gear",  self:QuickLerp( "gear", (GearIDtoPose[ gear ] or 1) ) )

end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_gtr34/shared.lua:

ENT.Base = "lvs_base_wheeldrive"

ENT.PrintName = "Nissan Skyline (BNR34)"
ENT.Author = "Digger"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars - Pack"

ENT.VehicleCategory = "Cars"
ENT.VehicleSubCategory = "Civilian"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/diggercars/nissan_skyline_gtr34/gtr.mdl"

ENT.MaxVelocity = 2850

ENT.EngineCurve = 0.15
ENT.EngineTorque = 125
ENT.EngineIdleRPM = 1000
ENT.EngineMaxRPM = 8500

ENT.TransGears = 6
ENT.TransGearsReverse = 1

ENT.WheelPhysicsMass = 120

ENT.HornSound = "lvs/horn4.wav"
ENT.HornPos = Vector(40,0,35)

ENT.RandomColor = {
	{
		Skin = 0,
		Color = Color(230,230,230),
		Wheels = {
			Skin = 1,
			Color = Color(61,53,39),
		}
	},
	{
		Skin = 0,
		Color = Color(130,130,130),
		Wheels = {
			Skin = 1,
			Color = Color(61,53,39),
		}
	},
	{
		Skin = 0,
		Color = Color(30,30,30),
		Wheels = {
			Skin = 1,
			Color = Color(61,53,39),
		}
	},
	{
		Skin = 0,
		Color = Color(18,14,24),
		Wheels = {
			Skin = 1,
			Color = Color(61,53,39),
		}
	},
	{
		Skin = 0,
		Color = Color(27,36,90),
		Wheels = {
			Skin = 1,
			Color = Color(61,53,39),
		}
	},
	{
		Skin = 0,
		Color = Color(106,116,102),
		Wheels = {
			Skin = 1,
			Color = Color(61,53,39),
		}
	},
	{
		Skin = 0,
		Color = Color(200,180,0),
		Wheels = {
			Skin = 1,
			Color = Color(61,53,39),
		}
	},
	{
		Skin = 0,
		Color = Color(200,00,0),
		Wheels = {
			Skin = 1,
			Color = Color(61,53,39),
		}
	},
}

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/skyline/eng_idle_loop.wav",
		Volume = 1,
		Pitch = 85,
		PitchMul = 25,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_IDLE_ONLY,
	},
	{
		sound = "lvs/vehicles/skyline/eng_loop.wav",
		Volume = 1,
		Pitch = 50,
		PitchMul = 75,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_UP,
		UseDoppler = true,
	},
	{
		sound = "lvs/vehicles/skyline/eng_revdown_loop.wav",
		Volume = 1,
		Pitch = 50,
		PitchMul = 75,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_DOWN,
		UseDoppler = true,
	},
}

ENT.ExhaustPositions = {
	{
		pos = Vector(-90.33,14.84,12.82),
		ang = Angle(0,180,0),
	},
	{
		pos = Vector(-90.21,18.63,12.87),
		ang = Angle(0,180,0),
	}
}

ENT.Lights = {
	{
		Trigger = "main",
		SubMaterialID = 27,
		Sprites = {
			{ pos = Vector(81.5,24.61,26.71), colorB = 200, colorA = 150 },
			{ pos = Vector(81.5,-24.61,26.71), colorB = 200, colorA = 150 },
			{ pos = Vector(78.37,28.75,26.41), colorB = 200, colorA = 150 },
			{ pos = Vector(78.37,-28.75,26.41), colorB = 200, colorA = 150 },
		},
		ProjectedTextures = {
			{ pos = Vector(81.5,24.61,26.71), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
			{ pos = Vector(81.5,-24.61,26.71), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "main",
		SubMaterialID = 3,
	},
	{
		Trigger = "high",
		SubMaterialID = 26,
		Sprites = {
			{ pos = Vector(83.53,19.34,25.91), colorB = 200, colorA = 150 },
			{ pos = Vector(83.53,-19.34,25.91), colorB = 200, colorA = 150 },

		},
		ProjectedTextures = {
			{ pos = Vector(83.53,19.34,25.91), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
			{ pos = Vector(83.53,-19.34,25.91), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},

	{
		Trigger = "brake",
		SubMaterialID = 31,
		Sprites = {
			{ width = 55, height = 15, pos = Vector(-87.95,-0.11,39.11), colorG = 0, colorB = 0, colorA = 150 },
		}
	},
	{
		Trigger = "main+brake",
		SubMaterialID = 24,
		Sprites = {
			{ width = 75, height = 75, pos = Vector(-86.35,26.09,33.79), colorG = 0, colorB = 0, colorA = 150 },
			{ width = 75, height = 75, pos = Vector(-86.35,-26.09,33.79), colorG = 0, colorB = 0, colorA = 150 },
		}
	},
	{
		Trigger = "reverse",
		SubMaterialID = 30,
		Sprites = {
			{ pos = Vector(-91.79,10.73,21.85), height = 25, width = 25, colorA = 150 },
		}
	},
	{
		Trigger = "turnright",
		SubMaterialID = 23,
		Sprites = {
			{ width = 35, height = 35, pos = Vector(85.86,-25.24,18.39), colorG = 100, colorB = 0, colorA = 150 },
			{ width = 20, height = 20, pos = Vector(34.69,-35.06,27.14), colorG = 100, colorB = 0, colorA = 150 },
			{ width = 40, height = 40, pos = Vector(-87.93,-18.22,33.07), colorG = 100, colorB = 0, colorA = 150 },
		},
	},
	{
		Trigger = "turnleft",
		SubMaterialID = 22,
		Sprites = {
			{ width = 35, height = 35, pos = Vector(85.86,25.24,18.39), colorG = 100, colorB = 0, colorA = 150 },
			{ width = 20, height = 20, pos = Vector(34.69,35.06,27.14), colorG = 100, colorB = 0, colorA = 150 },
			{ width = 40, height = 40, pos = Vector(-87.93,18.22,33.07), colorG = 100, colorB = 0, colorA = 150 },
		},
	},
}

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_lighthandler.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "Entity",1, "DoorHandler" )

	self:NetworkVar( "Bool",0, "Active" )
	self:NetworkVar( "Bool",1, "HighActive" )
	self:NetworkVar( "Bool",2, "FogActive" )

	if SERVER then
		self:NetworkVarNotify( "Active", self.OnActiveChanged )
	end
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
	end

	function ENT:OnActiveChanged( name, old, new)
		if new == old then return end

		local DoorHandler = self:GetDoorHandler()

		if not IsValid( DoorHandler ) then return end

		if new then
			if not DoorHandler:IsOpen() then
				DoorHandler:Open()
			end
		else
			if DoorHandler:IsOpen() then
				DoorHandler:Close()
			end
		end
	end

	function ENT:Think()
		local DoorHandler = self:GetDoorHandler()

		if not IsValid( DoorHandler ) then
			self:NextThink( CurTime() + 1 )
		else
			self:NextThink( CurTime() )

			if self:GetActive() and not DoorHandler:IsOpen() then
				DoorHandler:Open()
			end
		end

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	return
end

function ENT:Initialize()
	local base = self:GetBase()

	if not IsValid( base ) or not isfunction( base.IsInitialized ) or not base:IsInitialized() then

		timer.Simple( 1, function()
			if not IsValid( self ) then return end

			self:Initialize()
		end )

		return
	end

	if not istable( base.Lights ) then return end

	self:InitializeLights( base, base.Lights )

	for typeid, typedata in pairs( base.Lights ) do
		if not typedata.Siren or not typedata.Trigger then continue end

		if not istable( self._TriggerList ) then
			self._TriggerList = {}
		end

		local data = {}
		data.pattern = {}

		for id, n in ipairs( string.Explode( "", typedata.Trigger ) ) do
			data.pattern[ id ] = tonumber( n or 0 )
		end

		data.cur = 1
		data.max = #data.pattern

		self._TriggerList[ typedata.Trigger ] = data
	end
end

function ENT:InitializeLights( base, data )

	if not istable( data ) then return end

	local materials = base:GetMaterials()

	for typeid, typedata in pairs( data ) do
		if not typedata.Trigger then
			data[typeid] = nil
		end

		if typedata.SubMaterialID then
			if isstring( typedata.SubMaterialID ) then
				local ID = table.KeyFromValue( materials, typedata.SubMaterialID )

				if isnumber( ID ) then
					data[typeid].SubMaterialID = ID - 1
				end
			end

			data[typeid].SubMaterial = self:CreateSubMaterial( typedata.SubMaterialID, typedata.Trigger )
			data[typeid].SubMaterialBrightness = typedata.SubMaterialBrightness or 1
		end

		if typedata.Sprites then
			for lightsid, lightsdata in pairs( typedata.Sprites ) do
				data[typeid].Sprites[ lightsid ].PixVis = util.GetPixelVisibleHandle()

				if isstring( lightsdata.pos ) then
					data[typeid].Sprites[ lightsid ].att = base:LookupAttachment( lightsdata.pos )
				else
					data[typeid].Sprites[ lightsid ].pos = isvector( lightsdata.pos ) and lightsdata.pos or vector_origin
				end

				data[typeid].Sprites[ lightsid ].mat = isstring( lightsdata.mat ) and Material( lightsdata.mat ) or Material( "sprites/light_ignorez" )
				data[typeid].Sprites[ lightsid ].width = lightsdata.width or 50
				data[typeid].Sprites[ lightsid ].height = lightsdata.height or 50
				data[typeid].Sprites[ lightsid ].colorR = lightsdata.colorR or 255
				data[typeid].Sprites[ lightsid ].colorG = lightsdata.colorG or 255
				data[typeid].Sprites[ lightsid ].colorB = lightsdata.colorB or 255
				data[typeid].Sprites[ lightsid ].colorA = lightsdata.colorA or 255
			end
		end

		if typedata.ProjectedTextures then
			for projid, projdata in pairs( typedata.ProjectedTextures ) do
				if typedata.Trigger == "high" then
					data[typeid].ProjectedTextures[ projid ].PixVis = util.GetPixelVisibleHandle()
				end

				if isstring( projdata.pos ) then
					data[typeid].ProjectedTextures[ projid ].att = base:LookupAttachment( projdata.pos )
				else
					data[typeid].ProjectedTextures[ projid ].pos = projdata.pos or vector_origin
					data[typeid].ProjectedTextures[ projid ].ang = projdata.ang or angle_zero
				end

				data[typeid].ProjectedTextures[ projid ].mat = projdata.mat or (typedata.Trigger == "high" and "effects/flashlight/soft" or "effects/lvs/car_projectedtexture")
				data[typeid].ProjectedTextures[ projid ].farz = projdata.farz or (typedata.Trigger == "high" and 4000 or 1000)
				data[typeid].ProjectedTextures[ projid ].nearz = projdata.nearz or 65
				data[typeid].ProjectedTextures[ projid ].fov = projdata.fov or (typedata.Trigger == "high" and 40 or 60)
				data[typeid].ProjectedTextures[ projid ].colorR = projdata.colorR or 255
				data[typeid].ProjectedTextures[ projid ].colorG = projdata.colorG or 255
				data[typeid].ProjectedTextures[ projid ].colorB = projdata.colorB or 255
				data[typeid].ProjectedTextures[ projid ].colorA = projdata.colorA or 255
				data[typeid].ProjectedTextures[ projid ].color = Color( projdata.colorR or 255, projdata.colorG or 255, projdata.colorB or 255 )
				data[typeid].ProjectedTextures[ projid ].brightness = projdata.brightness or (typedata.Trigger == "high" and 5 or 5)
				data[typeid].ProjectedTextures[ projid ].shadows = projdata.shadows == true
			end
		end

		if typedata.DynamicLights then
			for dLightid, dLightdata in pairs( typedata.DynamicLights ) do

				if isstring( dLightdata.pos ) then
					data[typeid].DynamicLights[ dLightid ].att = base:LookupAttachment( dLightdata.pos )
				else
					data[typeid].DynamicLights[ dLightid ].pos = isvector( dLightdata.pos ) and dLightdata.pos or vector_origin
				end

				data[typeid].DynamicLights[ dLightid ].colorR = dLightdata.colorR or 255
				data[typeid].DynamicLights[ dLightid ].colorG = dLightdata.colorG or 255
				data[typeid].DynamicLights[ dLightid ].colorB = dLightdata.colorB or 255
				data[typeid].DynamicLights[ dLightid ].brightness = dLightdata.brightness or 0.1
				data[typeid].DynamicLights[ dLightid ].decay = dLightdata.decay or 1000
				data[typeid].DynamicLights[ dLightid ].size = dLightdata.size or 128
				data[typeid].DynamicLights[ dLightid ].lifetime = dLightdata.lifetime or 0.1
			end
		end
	end

	self.Enabled = true
end

function ENT:CreateSubMaterial( SubMaterialID, name )
	local base = self:GetBase()

	if not IsValid( base ) or not SubMaterialID then return end

	local mat = base:GetMaterials()[ SubMaterialID + 1 ]

	if not mat then return end

	local string_data = file.Read( "materials/"..mat..".vmt", "GAME" )

	if not string_data then return end

	return CreateMaterial( name..SubMaterialID..base:GetClass()..base:EntIndex(), "VertexLitGeneric", util.KeyValuesToTable( string_data ) )
end

function ENT:ResetSubMaterials()
	local base = self:GetBase()

	if not IsValid( base ) then return end

	local data = base.Lights

	if not istable( data ) then return end

	for typeid, typedata in pairs( data ) do
		if not typedata.SubMaterialID or not typedata.SubMaterial then continue end

		base:SetSubMaterial(typedata.SubMaterialID, "")
	end
end

function ENT:CreateProjectedTexture( id, mat, col, brightness, shadows, nearz, farz, fov )
	if not mat then return end

	local thelamp = ProjectedTexture()
	thelamp:SetTexture( mat )
	thelamp:SetColor( col )
	thelamp:SetBrightness( brightness ) 
	thelamp:SetEnableShadows( shadows ) 
	thelamp:SetNearZ( nearz ) 
	thelamp:SetFarZ( farz ) 
	thelamp:SetFOV( fov )

	if istable( self._ProjectedTextures ) then
		if IsValid( self._ProjectedTextures[ id ] ) then
			self._ProjectedTextures[ id ]:Remove()
			self._ProjectedTextures[ id ] = nil
		end
	else
		self._ProjectedTextures = {}
	end

	self._ProjectedTextures[ id ] = thelamp

	return thelamp
end

function ENT:GetProjectedTexture( id )
	if not id or not istable( self._ProjectedTextures ) then return end

	return self._ProjectedTextures[ id ]
end

function ENT:RemoveProjectedTexture( id )
	if not id or not istable( self._ProjectedTextures ) then return end

	if IsValid( self._ProjectedTextures[ id ] ) then
		self._ProjectedTextures[ id ]:Remove()
		self._ProjectedTextures[ id ] = nil
	end
end

function ENT:ClearProjectedTextures()
	if not istable( self._ProjectedTextures ) then return end

	for id, proj in pairs( self._ProjectedTextures ) do
		if IsValid( proj ) then
			proj:Remove()
		end

		self._ProjectedTextures[ id ] = nil
	end
end

local function DistanceMul( ent )
	local dist = (LocalPlayer():GetPos() - ent:GetPos()):LengthSqr()

	return math.max( 1 - (dist / 10000000), 0 )
end

function ENT:LightsThink( base )
	local EntID = base:EntIndex()
	local Class = base:GetClass()
	local data = base.Lights

	if not istable( data ) then return end

	local brightness = DistanceMul( self )

	for typeid, typedata in pairs( data ) do
		local mul = self:GetTypeActivator( typedata.Trigger ) * brightness
		local active = mul > 0.01

		if typedata.Trigger == "main" then
			if self:GetHighActive() then
				active = false
			end
		end

		if typedata.ProjectedTextures then
			for projid, projdata in pairs( typedata.ProjectedTextures ) do
				local id = typeid.."-"..projid

				local proj = self:GetProjectedTexture( id )
				local proj_active = active

				if proj_active and istable( projdata.bodygroup ) then
					if not base:BodygroupIsValid( projdata.bodygroup.name, projdata.bodygroup.active ) then
						proj_active = false
					end
				end

				if IsValid( proj ) then
					if proj_active then
						proj:SetBrightness( projdata.brightness * mul ) 

						if projdata.att then
							local att = base:GetAttachment( projdata.att )

							if att then
								proj:SetPos( att.Pos )
								proj:SetAngles( att.Ang )
							end
						else
							if not isvector( projdata.pos ) then self:InitializeLights( base ) break end

							proj:SetPos( base:LocalToWorld( projdata.pos ) )
							proj:SetAngles( base:LocalToWorldAngles( projdata.ang ) )
						end

						proj:Update()
					else
						self:RemoveProjectedTexture( id )
					end
				else
					if proj_active then
						self:CreateProjectedTexture( id, projdata.mat, projdata.color, projdata.brightness, projdata.shadows, projdata.nearz, projdata.farz, projdata.fov )
					else
						self:RemoveProjectedTexture( id )
					end
				end
			end
		end

		if typedata.DynamicLights then
			for dLightid, dLightdata in pairs( typedata.DynamicLights ) do
				if not active then continue end

				local dlight = DynamicLight( self:EntIndex() * 1000 + dLightid )

				if not dlight then continue end

				local pos

				if dLightdata.att then
					local att = base:GetAttachment( dLightdata.att )

					if not att then
						dlight.pos = vector_origin
					else
						dlight.pos = att.Pos
					end
				else
					if not isvector( dLightdata.pos ) then self:InitializeLights( base ) break end

					dlight.pos = base:LocalToWorld( dLightdata.pos )
				end

				dlight.r = dLightdata.colorR
				dlight.g = dLightdata.colorG
				dlight.b = dLightdata.colorB
				dlight.brightness = dLightdata.brightness
				dlight.decay = dLightdata.decay
				dlight.size = dLightdata.size
				dlight.dietime = CurTime() + dLightdata.lifetime
			end
		end

		if not isnumber( typedata.SubMaterialID ) or not typedata.SubMaterial then continue end

		typedata.SubMaterial:SetFloat("$detailblendfactor", mul * typedata.SubMaterialBrightness )

		if typedata.SubMaterialValue ~= active then
			data[typeid].SubMaterialValue = active
			base:SetSubMaterial(typedata.SubMaterialID, "!"..typedata.Trigger..typedata.SubMaterialID..Class..EntID)
		end
	end
end

function ENT:LerpActivator( name, target, rate )
	name =  "_sm"..name

	if not self[ name ] then self[ name ] = 0 end

	if not rate then rate = 10 end

	self[ name ] = self[ name ] + (target - self[ name ]) * rate

	return self[ name ]
end

function ENT:GetTypeActivator( name )
	if not self[ "_sm"..name ] then return 0 end

	return self[ "_sm"..name ] ^ 2
end

local Left = {
	[1] = true,
	[3] = true,
}
local Right = {
	[2] = true,
	[3] = true,
}

function ENT:CalcTypeActivators( base )
	local base = self:GetBase()

	if not IsValid( base ) then return end

	local main = self:GetActive() and 1 or 0
	local high = self:GetHighActive() and 1 or 0
	local fog = self:GetFogActive() and 1 or 0
	local brake = base:GetBrake() > 0 and 1 or 0
	local reverse = base:GetReverse() and 1 or 0

	local engineActive = base:GetEngineActive() and 1 or 0

	local Flasher = base:GetTurnFlasher()
	local TurnMode = base:GetTurnMode()

	local turnleft = (Left[ TurnMode ] and Flasher) and 1 or 0
	local turnright = (Right[ TurnMode ] and Flasher) and 1 or 0

	local Rate = RealFrameTime() * 10

	self:LerpActivator( "active", engineActive, Rate )
	self:LerpActivator( "fog", fog, Rate )
	self:LerpActivator( "brake", brake, Rate )
	self:LerpActivator( "reverse", reverse, Rate )
	self:LerpActivator( "turnleft", turnleft, Rate * 2 )
	self:LerpActivator( "turnright", turnright, Rate * 2 )

	local DoorHandler = self:GetDoorHandler()
	if IsValid( DoorHandler ) then
		main = (DoorHandler.sm_pp or 0) >= 0.5 and main or 0
		high = (DoorHandler.sm_pp or 0) >= 0.5 and high or 0
	end

	self:LerpActivator( "main", main, Rate )

	if Left[ TurnMode ] then
		if main >= 0.5 then
			self:LerpActivator( "main+brake+turnleft", main * 0.75 + turnleft * 1.25, Rate )
		else
			self:LerpActivator( "main+brake+turnleft", turnleft, Rate )
		end
	else
		if main >= 0.5 then
			self:LerpActivator( "main+brake+turnleft", main * 0.75 + brake * 1.25, Rate )
		else
			self:LerpActivator( "main+brake+turnleft", brake, Rate )
		end
	end

	if Right[ TurnMode ] then
		if main >= 0.5 then
			self:LerpActivator( "main+brake+turnright", main * 0.75 + turnright * 1.25, Rate )
		else
			self:LerpActivator( "main+brake+turnright", turnright, Rate )
		end
	else
		if main >= 0.5 then
			self:LerpActivator( "main+brake+turnright", main * 0.75 + brake * 1.25, Rate )
		else
			self:LerpActivator( "main+brake+turnright", brake, Rate )
		end
	end

	if main >= 0.5 then
		self:LerpActivator( "main+brake", main * 0.75 + brake * 1.25, Rate )
	else
		self:LerpActivator( "main+brake", brake, Rate )
	end

	self:LerpActivator( "main+high", main * 0.75 + high * 1.25, Rate )

	self:LerpActivator( "main+fog", main * 0.75 + fog * 1.25, Rate )

	self:LerpActivator( "high", high, Rate )

	if not istable( self._TriggerList ) then return end

	local RateSiren = math.min( Rate * 50, 1 )

	if base:GetSirenMode() < 0 then
		for id, data in pairs( self._TriggerList ) do
			self:LerpActivator( id, 0, RateSiren )
		end

		return
	end

	for id, data in pairs( self._TriggerList ) do
		self:LerpActivator( id, data.pattern[ data.cur ], RateSiren )
	end

	local T = CurTime() + self:EntIndex() * 1337

	if (self._calcNext or 0) > T then return end

	self._calcNext = T + 0.1

	for id, data in pairs( self._TriggerList ) do
		data.cur = data.cur + 1

		if data.cur > data.max then
			data.cur = 1
		end
	end
end

ENT.LensFlare1 = Material( "effects/lvs/car_lensflare" )
ENT.LensFlare2 = Material( "sprites/light_ignorez" )
ENT.LightMaterial = Material( "effects/lvs/car_spotlight" )
function ENT:GetAmbientLight( base )
	local T = CurTime()
	local FT = RealFrameTime()
	local ply = LocalPlayer()

	if not IsValid( ply ) then return 0, vector_origin end

	local plyPos = ply:GetShootPos()

	local ViewEnt = ply:GetViewEntity()

	if IsValid( ViewEnt ) and ViewEnt ~= ply then
		plyPos = ViewEnt:GetPos()
	end

	local EntTable = self:GetTable()

	if (EntTable._NextLightCheck or 0) > T then return (EntTable._AmbientLightMul or 0), plyPos end

	local LightVeh = render.GetLightColor( base:LocalToWorld( base:OBBCenter() ) )
	local LightPlayer = render.GetLightColor( plyPos )
	local AmbientLightMul =  (1 - math.min( LightVeh:Dot( LightPlayer ) * 200, 1 )) ^ 2

	EntTable._NextLightCheck = T + FT

	if not EntTable._AmbientLightMul then
		EntTable._AmbientLightMul = 0
	end

	EntTable._AmbientLightMul = EntTable._AmbientLightMul and EntTable._AmbientLightMul + (AmbientLightMul - EntTable._AmbientLightMul) * FT or 0

	return EntTable._AmbientLightMul, plyPos
end

local DoMagic = {
	["main"] = true,
	["high"] = true,
	["main+high"] = true,
}

function ENT:RenderLights( base, data )
	if not self.Enabled then return end

	local brightness = 1 - DistanceMul( self )

	for _, typedata in pairs( data ) do

		local mul = self:GetTypeActivator( typedata.Trigger )

		if mul < 0.01 then continue end

		if typedata.ProjectedTextures and DoMagic[ typedata.Trigger ] then
			for projid, projdata in pairs( typedata.ProjectedTextures ) do
				if istable( projdata.bodygroup ) then
					if not base:BodygroupIsValid( projdata.bodygroup.name, projdata.bodygroup.active ) then continue end
				end

				local pos
				local dir

				if projdata.att then
					local att = base:GetAttachment( projdata.att )

					if not att then continue end

					pos = att.Pos
					dir =  att.Ang:Forward()

				else
					pos = base:LocalToWorld( projdata.pos )
					dir = base:LocalToWorldAngles( projdata.ang ):Forward()
				end

				if not projdata.colorR or not projdata.colorG or not projdata.colorB or not projdata.brightness then self:InitializeLights( base ) break end

				local L = 100 + 700 * brightness
				local W = 50 + 100 * brightness

				render.SetMaterial( self.LightMaterial )
				render.DrawBeam( pos, pos + dir * L, W, -0.01, 0.99, Color( projdata.colorR * mul, projdata.colorG * mul, projdata.colorB * mul, projdata.brightness ) )

				if not projdata.PixVis then continue end

				local AmbientLightMul, plyPos = self:GetAmbientLight( base )
	
				local visible = util.PixelVisible( pos, 1, projdata.PixVis ) * mul

				if not visible or visible == 0 then continue end

				local aimdir = (plyPos - pos):GetNormalized()

				local ang = base:AngleBetweenNormal( dir, aimdir )

				if ang < 20 then
					local Alpha = 1 - (ang / 20) * 255
					render.SetMaterial( self.LensFlare2 )
					render.DrawSprite( pos, 512, 512, Color( projdata.colorR * mul * AmbientLightMul, projdata.colorG * mul * AmbientLightMul, projdata.colorB * mul * AmbientLightMul, Alpha * visible) )
				end
				if ang < 10 then
					local RGB = 30 * AmbientLightMul * mul
					local Scale = 1 - (ang / 10)
					local Alpha = Scale * 255 * math.Rand(0.8,1.2) * visible
					local ScaleX = 1024 * math.Rand(0.98,1.02)
					local ScaleY = 1024 * math.Rand(0.98,1.02)

					render.SetMaterial( self.LensFlare1 )
					render.DrawSprite( pos, ScaleX, ScaleY, Color(RGB,RGB,RGB,Alpha) )
				end
			end
		end

		if not typedata.Sprites then continue end

		for id, lightsdata in pairs( typedata.Sprites ) do
			if not lightsdata.PixVis then
				continue
			end

			if istable( lightsdata.bodygroup ) then
				if not base:BodygroupIsValid( lightsdata.bodygroup.name, lightsdata.bodygroup.active ) then continue end
			end

			local pos

			if lightsdata.att then
				local att = base:GetAttachment( lightsdata.att )

				if not att then continue end

				pos = att.Pos
			else
				if not isvector( lightsdata.pos ) then self:InitializeLights( base ) break end

				pos = base:LocalToWorld( lightsdata.pos )
			end

			local visible = util.PixelVisible( pos, 2, lightsdata.PixVis )

			if not visible then continue end

			if visible <= 0.1 then continue end

			if isstring( lightsdata.mat ) then self:InitializeLights( base ) break end

			render.SetMaterial( lightsdata.mat )
			render.DrawSprite( pos, lightsdata.width, lightsdata.height , Color(lightsdata.colorR,lightsdata.colorG,lightsdata.colorB,lightsdata.colorA*mul*visible^2) )
		end
	end
end

function ENT:Think()
	local base = self:GetBase()

	if not IsValid( base ) or not self.Enabled then
		self:SetNextClientThink( CurTime() + 1 )

		return true
	end

	self:CalcTypeActivators( base )
	self:LightsThink( base )
end

function ENT:OnRemove()
	self:ClearProjectedTextures()
	self:ResetSubMaterials()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_sdkfz250/cl_init.lua:
include("shared.lua")
include("sh_tracks.lua")
include("cl_tankview.lua")

function ENT:OnSpawn()
	self:CreateBonePoseParameter( "hatch1", 59, Angle(0,0,0), Angle(0,60,0), Vector(0,0,0), Vector(0,0,0) )
	self:CreateBonePoseParameter( "hatch2", 60, Angle(0,0,0), Angle(0,60,0), Vector(0,0,0), Vector(0,0,0) )
end


--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_vw_touareg_1/shared.lua:

ENT.Base = "lvs_base_wheeldrive"

ENT.PrintName = "VolksWagen Touareg (I)"
ENT.Author = "Digger"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars - Pack"

ENT.VehicleCategory = "Cars"
ENT.VehicleSubCategory = "Civilian"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/diggercars/vw_touareg/touareg.mdl"

ENT.MaxVelocity = 2500

ENT.EngineTorque = 95
ENT.EngineIdleRPM = 660
ENT.EngineMaxRPM = 6000

ENT.TransGears = 5
ENT.TransGearsReverse = 1

ENT.PhysicsMass = 1500

ENT.RandomColor = {
	Color(237,236,233),
}

ENT.HornSound = "lvs/horn1.wav"
ENT.HornPos = Vector(40,0,35)

ENT.RandomColor = {
	{
		Skin = 4,
		Color = Color(200,200,200),
	},
	{
		Skin = 10,
		Color = Color(90,21,21),
	},
	{
		Skin = 7,
		Color = Color(140,140,140),
	},
	{
		Skin = 0,
		Color = Color(61,60,57),
	},
	{
		Skin = 2,
		Color = Color(55,60,51),
	},
	{
		Skin = 14,
		Color = Color(20,20,20),
	},
	{
		Skin = 1,
		Color = Color(36,41,80),
	},
}

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/audi_r8/idle2.wav",
		Volume = 1,
		Pitch = 70,
		PitchMul = 70,
		SoundLevel = 55,
		SoundType = LVS.SOUNDTYPE_IDLE_ONLY,
	},
	{
		sound = "lvs/vehicles/audi_r8/high.wav",
		Volume = 1,
		Pitch = 80,
		PitchMul = 110,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_UP,
		UseDoppler = true,
	},
	{
		sound = "lvs/vehicles/audi_r8/revdown.wav",
		Volume = 1,
		Pitch = 80,
		PitchMul = 110,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_DOWN,
		UseDoppler = true,
	},
}

ENT.ExhaustPositions = {
	{
		pos = Vector(-90.99,22.9,6.434),
		ang = Angle(20,180,0),
	},
	{
		pos = Vector(-90.99,-22.9,6.43),
		ang = Angle(20,180,0),
	},
}


ENT.Lights = {
	{
		Trigger = "main",
		SubMaterialID = 24,
		SubMaterialBrightness = 10,
		Sprites = {
			{ pos = Vector(77.45,30.08,24.04), colorR = 200, colorG = 200, colorB = 250, colorA = 250 },
			{ pos = Vector(77.45,-30.08,24.04), colorR = 200, colorG = 200, colorB = 250, colorA = 250 },
			{ width = 65, height = 65, pos = Vector(-87.53,21.57,31.12), colorG = 0, colorB = 0, colorA = 150 },
			{ width = 65, height = 65, pos = Vector(-87.53,-21.57,31.12), colorG = 0, colorB = 0, colorA = 150 },
			{ width = 15, height = 15, pos = Vector(-87.53,21.57,31.12), colorR = 255, colorG = 255, colorB = 255, colorA = 105, },
			{ width = 15, height = 15, pos = Vector(-87.53,-21.57,31.12), colorR = 255, colorG = 255, colorB = 255, colorA = 105, },
		},
		ProjectedTextures = {
			{ pos = Vector(82,30.08,24.04), ang = Angle(0,0,0), colorR = 200, colorG = 200, colorB = 250, colorA = 150, shadows = true },
			{ pos = Vector(82,-30.08,24.04), ang = Angle(0,0,0), colorR = 200, colorG = 200, colorB = 250, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "main+brake",
		SubMaterialID = 5,
		SubMaterialBrightness = 2,
		Sprites = {
			{ width = 65, height = 65, pos = Vector(-83.91,29.78,31.07), colorG = 0, colorB = 0, colorA = 250 },
			{ width = 65, height = 65, pos = Vector(-83.91,-29.78,31.07), colorG = 0, colorB = 0, colorA = 250 },
			{ width = 15, height = 15, pos = Vector(-83.91,29.78,31.07), colorR = 255, colorG = 255, colorB = 255, colorA = 155, },
			{ width = 15, height = 15, pos = Vector(-83.91,-29.78,31.07), colorR = 255, colorG = 255, colorB = 255, colorA = 155, },
		},
	},
	{
		Trigger = "main",
		SubMaterialID = 12,
	},
	{
		Trigger = "main",
		SubMaterialID = 16,
	},
	{
		Trigger = "brake",
		SubMaterialID = 3,
		SubMaterialBrightness = 2,
		Sprites = {
			{ width = 65, height = 15, pos = Vector(-76.05,0,54.49), colorG = 0, colorB = 0, colorA = 150 },
		},
	},
	{
		Trigger = "main+high",
		SubMaterialID = 23,
		SubMaterialBrightness = 2,
		Sprites = {
			{ pos = Vector(81.62,24.07,24.54), colorR = 200, colorG = 200, colorB = 250, colorA = 150 },
			{ pos = Vector(81.62,-24.07,24.54), colorR = 200, colorG = 200, colorB = 250, colorA = 150 },
		},

	},
	{
		Trigger = "high",
		ProjectedTextures = {
			{ pos = Vector(86,27.51,19.7), ang = Angle(0,0,0), colorR = 200, colorG = 200, colorB = 250, colorA = 150, shadows = true },
			{ pos = Vector(86,-27.51,19.7), ang = Angle(0,0,0), colorR = 200, colorG = 200, colorB = 250, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "fog",
		SubMaterialID = 31,
		Sprites = {
			{ width = 25, height = 25, pos = Vector(85.68,24.73,5.41), colorR = 200, colorG = 200, colorB = 250, colorA = 150 },
			{ width = 25, height = 25, pos = Vector(85.68,-24.73,5.41), colorR = 200, colorG = 200, colorB = 250, colorA = 150 },
		},
	},

	{
		Trigger = "reverse",
		SubMaterialID = 4,
		SubMaterialBrightness = 2,
		Sprites = {

			{ width = 45, height = 25, pos = Vector(-88.95,-21.52,27.28), height = 25, width = 25, colorA = 150 },
			{ width = 45, height = 25, pos = Vector(-88.95,21.52,27.28), height = 25, width = 25, colorA = 150 },

		}
	},
	{
		Trigger = "turnright",
		SubMaterialID = 2,
		SubMaterialBrightness = 1,
		Sprites = {
			{ width = 45, height = 25,  pos = "tlr", colorG = 100, colorB = 0, colorA = 50 },
			{ width = 45, height = 45,  pos = Vector(75.11,-34.16,23.96), colorG = 100, colorB = 0, colorA = 50 },
			{ width = 45, height = 25, pos = Vector(-86.02,-30.5,27.37), colorG = 100, colorB = 0, colorA = 50 },
		},
	},
	{
		Trigger = "turnleft",
		SubMaterialID = 1,
		SubMaterialBrightness = 1,
		Sprites = {
			{ width = 45, height = 25,  pos = "tll", colorG = 100, colorB = 0, colorA = 50 },
			{ width = 45, height = 45, pos = Vector(75.11,34.16,23.96), colorG = 100, colorB = 0, colorA = 50 },
			{ width = 45, height = 25, pos = Vector(-86.02,30.5,27.37), colorG = 100, colorB = 0, colorA = 50 },

		},
	},
}


--PATH addons/__main/lua/entities/m9k_ammo_pistol/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
ENT.PrintName		= "Pistol Rounds"
ENT.Category		= "M9K Ammunition"

ENT.Spawnable		= true
ENT.AdminOnly = false
ENT.DoNotDuplicate = true

if SERVER then

AddCSLuaFile("shared.lua")

function ENT:SpawnFunction(ply, tr)

	if (!tr.Hit) then return end
	
	local SpawnPos = tr.HitPos + tr.HitNormal * 16
	
	local ent = ents.Create("m9k_ammo_pistol")
	
	ent:SetPos(SpawnPos)
	ent:Spawn()
	ent:Activate()
	ent.Planted = false
	
	return ent
end


/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()

	local model = ("models/Items/BoxSRounds.mdl")
	
	self.Entity:SetModel(model)
	
	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:DrawShadow(false)
	
	self.Entity:SetCollisionGroup(COLLISION_GROUP_WEAPON)
	
	local phys = self.Entity:GetPhysicsObject()
	
	if (phys:IsValid()) then
		phys:Wake()
	end

	self.Entity:SetUseType(SIMPLE_USE)
end


/*---------------------------------------------------------
   Name: PhysicsCollide
---------------------------------------------------------*/
function ENT:PhysicsCollide(data, physobj)
	
	// Play sound on bounce
	if (data.Speed > 80 and data.DeltaTime > 0.2) then
		self.Entity:EmitSound("Default.ImpactSoft")
	end
end

/*---------------------------------------------------------
   Name: OnTakeDamage
---------------------------------------------------------*/
function ENT:OnTakeDamage(dmginfo)

	if dmginfo:GetAttacker():GetClass() == "m9k_ammo_explosion" then return end
	
	self.Entity:TakePhysicsDamage(dmginfo)
	if GetConVar("M9KAmmoDetonation") == nil then return end
	if not (GetConVar("M9KAmmoDetonation"):GetBool()) then return end
	blaster = dmginfo:GetAttacker()
	pos = self.Entity:GetPos()+Vector(0,0,10)
	
	dice = math.random(1,5)

	if dmginfo:GetDamage() >75 or dice == 1 then
		self.Entity:Remove()
	
		local effectdata = EffectData()
		effectdata:SetOrigin(self.Entity:GetPos())
		util.Effect("ThumperDust", effectdata)
		util.Effect("Explosion", effectdata)
	
		timer.Simple(.01, function()
		
			for i=1, 100 do
			
			ouchies = {}
			ouchies.start = pos
			ouchies.endpos = pos + Vector(math.Rand(-1,1), math.Rand(-1,1), math.Rand(0,1)) * 64000
			ouchies = util.TraceLine(ouchies)
			
			if ouchies.Hit and not ouchies.HitSky then 
				util.Decal("Impact.Concrete", ouchies.HitPos + ouchies.HitNormal, ouchies.HitPos - ouchies.HitNormal )//and ouchies.Entity then
				ouchies.Entity:TakeDamage(30 * math.Rand(.85,1.15), blaster, self.Entity)
			end
			end
		end)
	end	

end

/*---------------------------------------------------------
   Name: Use
---------------------------------------------------------*/
function ENT:Use(activator, caller)

	
	if (activator:IsPlayer()) and not self.Planted then
		activator:GiveAmmo(100, "pistol")
		self.Entity:Remove()
	end
end

end

if CLIENT then

/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()
end

/*---------------------------------------------------------
   Name: DrawPre
---------------------------------------------------------*/
function ENT:Draw()
	
	self.Entity:DrawModel()
	
	local ledcolor = Color(230, 45, 45, 255)

  	local TargetPos = self.Entity:GetPos() + (self.Entity:GetUp() * 11.6) + (self.Entity:GetRight() * 2) + (self.Entity:GetForward() * 1.5)

	local FixAngles = self.Entity:GetAngles()
	local FixRotation = Vector(90, 90, 90)
	
	FixAngles:RotateAroundAxis(FixAngles:Right(), FixRotation.x)
	FixAngles:RotateAroundAxis(FixAngles:Up(), FixRotation.y)
	FixAngles:RotateAroundAxis(FixAngles:Forward(), FixRotation.z)

	self.Text = "Pistol Rounds"
	
	cam.Start3D2D(TargetPos, FixAngles, .07)
		draw.SimpleText(self.Text, "DermaLarge", 31, -22, ledcolor, 1, 1)
	cam.End3D2D()
end

end
--PATH gamemodes/darkrp/entities/entities/police_arrest/cl_init.lua:
include("Shared.lua")


local ipairs 		= ipairs
local CurTime 		= CurTime 
local LocalPlayer 	= LocalPlayer
local math_sin 		= math.sin
local math_pi 		= math.pi
local cam_Start3D2D	= cam.Start3D2D
local cam_End3D2D	= cam.End3D2D
local draw_SimpleTextOutlined = draw.SimpleTextOutlined
local ents_FindByClass = ents.FindByClass

local vec = Vector(0,0,0)

local color_white = Color(200,0,0)
local color_black = Color(0,0,0)

local function Draw(self)
	local pos = self:GetPos()
	local ang = self:GetAngles()
	local dist = pos:Distance(LocalPlayer():GetPos())
	

	    //self:DrawModel()		

		--[[color_white.a = 3000 - dist
		color_black.a = 3000 - dist

		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(),180)
		
		ang:RotateAroundAxis(ang:Right(),0)
		
		cam_Start3D2D(pos, ang, 0.065)
			//draw.ShadowText('Заказать убийство', 'Roboto_150', 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)
		
			surface.SetMaterial(Material("data/MafiaRP/image/loads2.png"))
			surface.SetDrawColor(Color(255,255,255))
			surface.DrawTexturedRect(0,0,3405,1785)


		cam_End3D2D()]]
		
		
		//cam_Start3D2D(pos + vec + ang:Right() * 1.2, ang, 0.065)
		//	draw_SimpleTextOutlined('Заказать убийство', 'Roboto_150', 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)		
		//cam_End3D2D()

end

function ENT:Draw()
	Draw(self)
end

--PATH gamemodes/darkrp/entities/entities/police_arrest/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "[Police] Arrest"
ENT.Author = "Jerivssss"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "RP"

--PATH gamemodes/darkrp/entities/entities/radio/cl_init.lua:
include('shared.lua')
local lw, lh = 700, 100

function ENT:Draw()
    self:DrawModel()
end

function ENT:OnRemove()
    local muz = self.sound

    if IsValid(muz) then
        muz:Stop()
    end
end

function ENT:Think()
    if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1500000 then return end
    local muz = self.sound

    if muz and IsValid(muz) then
        muz:SetPos(self:GetPos())
    end
end

timer.Create('RadioCheck', 5, 0, function()
    for k, v in ipairs(ents.FindByClass('radio') or {}) do
        if not v.GetURL then continue end

        if v:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1500000 and IsValid(v.sound) then
            v.sound:SetVolume(0)
        elseif IsValid(v.sound) then
            v.sound:SetVolume(1)
        end

        local url = v:GetURL()

        if url and url ~= '' then
            local muzlo = v.sound

            if not muzlo or not IsValid(muzlo) then
                sound.PlayURL(url, '3d noblock', function(s)
                    if IsValid(s) and IsValid(v) then
                        s:SetPos(v:GetPos())
                        s:Play()
                        s:SetVolume(1)
                        s:Set3DFadeDistance(200, 1500000)

                        if not s:IsBlockStreamed() then
                            s:SetTime(CurTime() - v:GetStartTime())

                            if v:GetLoop() then
                                s:EnableLooping(true)
                            end
                        end

                        v.sound = s
                    end
                end)
            elseif muzlo:GetFileName() == url then
                muzlo:SetPos(v:GetPos())

                if not muzlo:IsBlockStreamed() and not v:GetLoop() then
                    muzlo:SetTime(CurTime() - v:GetStartTime())
                end
            else
                muzlo:Stop()
                v.sound = nil

                sound.PlayURL(url, '3d noblock', function(s)
                    if IsValid(s) and IsValid(v) then
                        s:SetPos(v:GetPos())
                        s:Play()
                        s:SetVolume(1)
                        s:Set3DFadeDistance(200, 1500000)

                        if not s:IsBlockStreamed() then
                            s:SetTime(CurTime() - v:GetStartTime())

                            if v:GetLoop() then
                                s:EnableLooping(true)
                            end
                        end

                        v.sound = s
                    end
                end)
            end
        elseif v.sound then
            if IsValid(v.sound) then
                v.sound:Stop()
            end

            v.sound = nil
        end
    end
end)

concommand.Add('govradio_refresh', function()
    for k, v in ipairs(ents.FindByClass('radio') or {}) do
        if v.sound and IsValid(v.sound) then
            v.sound:Stop()
            v.sound = nil
            v:SetURL('')
            v:SetLoop(false)
        end
    end
end)

local function setmusic(url, loop)
    net.Start('MuzonMenu')

    if url then
        net.WriteString(url)
        net.WriteBool(loop)
    end

    net.SendToServer()
end

local char_to_hex = function(c) return string.format('%%%02X', string.byte(c)) end

local function urlencode(url)
    url = url:gsub('\n', '\r\n')
    url = url:gsub('([^%w ])', char_to_hex)
    url = url:gsub(' ', '+')

    return url
end

net.Receive('MuzonMenu', function()
    local radio = LocalPlayer():GetEyeTrace().Entity
    if not radio or radio:GetClass() ~= 'radio' then return end
    local menu = vgui.Create('DFrame')
    menu:SetSize(500, 0)
    menu:SetTitle('Радио')
    menu:MakePopup()

    menu.Paint = function(s, w, h)
        draw.RoundedBox(4, 0, 0, w, h, Color(54, 57, 62))
    end

    local guide = vgui.Create('DLabel', menu)
    guide:SetText('Якщо радіо перестало працювати, то введи команду govradio_refresh в консоль')
    guide:SetWrap(true)
    guide:Dock(TOP)
    local entry = vgui.Create('DTextEntry', menu)
    entry:SetSize(0, 25)
    entry:SetPlaceholderText('Встав пряму силку [http://xxxxxxx.mp3]')
    entry:SizeToContents()
    entry:Dock(TOP)
    local stop = vgui.Create('DButton', entry)
    stop:SetSize(30, 25)
    stop:SetText('■')
    stop:Dock(RIGHT)

    stop.DoClick = function()
        setmusic()
    end

    local play = vgui.Create('DButton', entry)
    play:SetSize(30, 25)
    play:SetText('►')
    play:Dock(RIGHT)

    local loop = vgui.Create('DCheckBoxLabel', menu)
    loop:SetTall(25)
    loop:Dock(TOP)
    loop:DockMargin(0, 10, 0, 0)
    loop:SetText('Увімкнути повторення')
    
    local freeze = vgui.Create('DButton', menu)
    freeze:SetText('Заморозити / Розморозити')
    freeze:Dock(TOP)
    freeze:DockMargin(0, 10, 0, 0)

    freeze.DoClick = function()
        net.Start('RadioFreeze')
        net.SendToServer()
    end

    play.DoClick = function()
        if not entry:GetValue() or entry:GetValue() == '' then return notification.AddLegacy('Ти не вставив силку', 1, 2) end
        setmusic(entry:GetValue(), loop:GetChecked())
    end

    menu:InvalidateLayout(true)
    menu:SizeToChildren(false, true)
    menu:Center()
end)
--PATH addons/_boombox/lua/entities/retro_boombox_base/cl_init.lua:
include( "shared.lua" )
local materials = {
	["volume-up"] = onyx.wimg.Simple( "https://i.imgur.com/EaWNAxa.png" ),
	["volume-down"] = onyx.wimg.Simple( "https://i.imgur.com/2NcFx73.png" ),
	["right"] = onyx.wimg.Simple( "https://i.imgur.com/qSXd5dK.png" ),
	["grab"] = onyx.wimg.Simple( "https://i.imgur.com/E7SX8b7.png" ),
	["light"] = onyx.wimg.Simple( "https://i.imgur.com/xwSRKAy.png" ),
	["pause"] = onyx.wimg.Simple( "https://i.imgur.com/tyUsWoA.png" ),
	["power"] = onyx.wimg.Simple( "https://i.imgur.com/Ezg0o5j.png" ),
	["left"] = onyx.wimg.Simple( "https://i.imgur.com/il2W1jM.png" ),
	["play"] = onyx.wimg.Simple( "https://i.imgur.com/94j9BML.png" ),
}

local color_background = Color( 32, 32, 32 )
function ENT:Draw()
	self:DrawModel()
	local aAngle = self:LocalToWorldAngles( Angle( 0, 90, 90 ) )
	local vPosition = self:LocalToWorld( Vector( 3.59, -7.85, 1.35 ) )
	cam.Start3D2D( vPosition, aAngle, 0.01 )
	if self:GetPower() then
		self:DrawRightScreen():PaintManual3D( vPosition, aAngle, 0.01 )
	else
		self:DrawOffScreen( 1 ):PaintManual3D( vPosition, aAngle, 0.01 )
	end

	cam.End3D2D()
	local aAngle2 = self:LocalToWorldAngles( Angle( 0, 90, 90 ) )
	local vPosition2 = self:LocalToWorld( Vector( 3.6, 1.65, 1.35 ) )
	cam.Start3D2D( vPosition2, aAngle2, 0.01 )
	if self:GetPower() then
		self:DrawLeftScreen():PaintManual()
	else
		self:DrawOffScreen( 2 ):PaintManual3D( vPosition2, aAngle2, 0.01 )
	end

	cam.End3D2D()
end

function ENT:SetParticleEffect( bShouldPlay )
	if not RetroBoombox.Config.ShouldUseParticles then return end
	if bShouldPlay then
		if not IsValid( self.ParticleOne ) then self.ParticleOne = CreateParticleSystem( self, "music_stars", PATTACH_ABSORIGIN_FOLLOW ) end
		if not IsValid( self.ParticleTwo ) then self.ParticleTwo = CreateParticleSystem( self, "music_notes_02", PATTACH_ABSORIGIN_FOLLOW ) end
		if not IsValid( self.ParticleThree ) then self.ParticleThree = CreateParticleSystem( self, "music_notes_core", PATTACH_ABSORIGIN_FOLLOW ) end
	else
		if IsValid( self.ParticleOne ) then self.ParticleOne:StopEmission() end
		if IsValid( self.ParticleTwo ) then self.ParticleTwo:StopEmission() end
		if IsValid( self.ParticleThree ) then self.ParticleThree:StopEmission() end
	end
end

function ENT:PlayAnimation( iLevel )
	if ( self.NextAnimation or 0 ) > CurTime() then return end
	self:ResetSequence( iLevel )
	self.NextAnimation = CurTime() + 0.3
end

function ENT:GetFrequenceIndicator()
	if IsValid( self.Indicator ) then return self.Indicator end
	self.Indicator = ClientsideModel( "models/sterling/retro_boombox_slider.mdl", RENDERGROUP_TRANSLUCENT )
end

function ENT:Initialize()
	self:GetFrequenceIndicator()
	color_background = self.ScreenBackgroundColor or Color( 32, 32, 32, 255 )
	color_lightblue = self.ScreenContentColor or Color( 0, 255, 219, 255 )
end

function ENT:PlayFailSound()
	if IsValid( self.FailSound ) then
		if self.FailSound:GetState() ~= GMOD_CHANNEL_PLAYING then self.FailSound:Play() end
		return
	end

	sound.PlayFile( "sound/retro_boombox/no-radio.mp3", "3d", function( station )
		if IsValid( station ) then
			station:Play()
			station:SetVolume( 10 )
			self.FailSound = station
		end
	end )
end

local frequencies = RetroBoombox.Config.Frequencies
function ENT:PlayStation( frequence )
	if self.FrequenceAsked then return end
	local tInfos = frequencies[frequence]
	if not tInfos then return end
	self.FrequenceAsked = true
	sound.PlayURL( tInfos.url, "3d", function( station )
		if not IsValid( self ) then return end
		self.FrequenceAsked = false
		if IsValid( self.Station ) then self.Station:Stop() end
		if IsValid( self.FailSound ) then self.FailSound:Pause() end
		if IsValid( station ) then
			station:SetPos( self:GetPos() )
			station:Play()
			self.Station = station
		else
			self:PlayFailSound()
		end
	end )
end

function ENT:OnRemove()
	if IsValid( self.Station ) then self.Station:Stop() end
	if IsValid( self.FailSound ) then self.FailSound:Stop() end
	if IsValid( self.Indicator ) then self.Indicator:Remove() end
end

local left = Vector( 3.3, -7.4, 6.6 )
local right = Vector( 3.3, 7.4, 6.6 )
function ENT:Think()
	if self:GetLightMode() ~= self.LightMode then RetroBoombox:ChangeLightMode( self, self:GetLightMode() ) end
	if IsValid( self.Indicator ) then
		local percentage = self:GetFrequence() / #RetroBoombox.Config.Frequencies - 1 / #RetroBoombox.Config.Frequencies * 0.5
		self.Percentage = self.Percentage or 0
		if self.Percentage ~= percentage and math.abs( self.Percentage - percentage ) < 0.01 then
			self.Percentage = percentage
		elseif self.Percentage < percentage then
			self.Percentage = self.Percentage + 0.01
		elseif self.Percentage > percentage then
			self.Percentage = self.Percentage - 0.01
		end

		local vPosition = self:LocalToWorld( LerpVector( self.Percentage, left, right ) )
		local aAngle = self:LocalToWorldAngles( Angle( 0, 0, 0 ) )
		self.Indicator:SetPos( vPosition )
		self.Indicator:SetAngles( aAngle )
	end

	if self:GetPower() then
		if IsValid( self.FailSound ) and self.FailSound:GetState() == GMOD_CHANNEL_PLAYING then
			if IsValid( self.Station ) then
				self.FailSound:Pause()
				return
			elseif self:GetPos():DistToSqr( LocalPlayer():GetPos() ) > 1160000 then
				self.FailSound:SetVolume( 0 )
				return
			end

			self.FailSound:SetPos( self:GetPos() )
			self.FailSound:SetVolume( self:GetSoundLevel() / RetroBoombox.Config.MaxSoundVolume )
		end

		if IsValid( self.Station ) then
			if self.Station:GetState() == ( GMOD_CHANNEL_PLAYING or GMOD_CHANNEL_PAUSED ) and self:GetPos():DistToSqr( LocalPlayer():GetPos() ) > 1160000 then
				self.Station:Stop()
				self:SetParticleEffect( false )
				return
			end

			if self:GetPlaying() then
				if self.Station:GetState() ~= GMOD_CHANNEL_PLAYING then
					self.Station:Play()
					return
				end
			elseif self.Station:GetState() ~= GMOD_CHANNEL_PAUSED then
				self.Station:Pause()
				return
			end

			if self.Station:GetFileName() ~= frequencies[self:GetFrequence()].url then
				self.Station:Stop()
				self:PlayStation( self:GetFrequence() )
				return
			end

			if self.Station:GetVolume() ~= self:GetSoundLevel() / RetroBoombox.Config.MaxSoundVolume then self.Station:SetVolume( self:GetSoundLevel() / RetroBoombox.Config.MaxSoundVolume ) end
			self.Station:SetPos( self:GetPos() )
			self:PlayAnimation( ( self.LightLevel or 3 ) / 3 )
		elseif self:GetPos():DistToSqr( LocalPlayer():GetPos() ) < 1160000 then
			self:PlayStation( self:GetFrequence() )
			self:SetParticleEffect( true )
		end
	elseif IsValid( self.Station ) then
		self:SetParticleEffect( false )
		self.Station:Stop()
	end
end

function ENT:DrawOffScreen( iID )
	if self.OffScreen and self.OffScreen[iID] and IsValid( self.OffScreen[iID] ) then return self.OffScreen[iID] end
	local this = self
	local size_x, size_y = 620, 400
	self.OffScreen = self.OffScreen or {}
	self.OffScreen[iID] = vgui.Create( "Boombox.3DFrame" )
	local dFrame = self.OffScreen[iID]
	dFrame:SetPaintedManually( true )
	dFrame:SetSize( size_x, size_y )
	dFrame:SetDrawCursor( false )
	dFrame:SetCursorColor( Color( 0, 255, 0 ) )
	dFrame:SetCursorRadius( 10 )
	dFrame:SetPaintedManually( true )
	dFrame:ShowCloseButton( false )
	dFrame:SetTitle( "" )
	function dFrame:Paint( w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_background )
		materials["power"]( size_x * 0.5 - 150, 50, 300, 300 )
	end

	local dTurnPower = vgui.Create( "DButton", dFrame )
	dTurnPower:Dock( FILL )
	dTurnPower:SetText( "" )
	function dTurnPower:DoClick()
		net.Start( "RetroBoombox:TurnPower" )
		net.WriteEntity( this )
		net.WriteBool( true )
		net.SendToServer()
	end

	dTurnPower.Paint = nil
	dFrame:UpdateChildren()
	return dFrame
end

function ENT:DrawRightScreen()
	if self.RightScreen and IsValid( self.RightScreen ) then return self.RightScreen end
	local this = self
	local size_x, size_y = 620, 400
	local hover_extend = 20
	local hover_move = hover_extend * 0.5
	self.RightScreen = vgui.Create( "Boombox.3DFrame" )
	local dFrame = self.RightScreen
	dFrame:SetPaintedManually( true )
	dFrame:SetSize( size_x, size_y )
	dFrame:SetDrawCursor( false )
	dFrame:SetCursorColor( Color( 0, 255, 0 ) )
	dFrame:SetCursorRadius( 10 )
	dFrame:SetPaintedManually( true )
	dFrame:ShowCloseButton( false )
	dFrame:SetTitle( "" )
	dFrame.ClicEffects = {}
	function dFrame:Paint( w, h )
		draw.RoundedBox( 3, 0, 0, w, h, color_background )
		for iID, tData in pairs( self.ClicEffects or {} ) do
			if not IsValid( tData.panel ) then
				self.ClicEffects[iID] = nil
				continue
			end

			local animationTime = 0.1
			local minSizeX, minSizeY = tData.panel:GetSize()
			local maxSizeX, maxSizeY = minSizeX * 1.5, minSizeY * 1.5
			local basePosX, basePosY = tData.panel:GetPos()
			local currentPercentage = ( CurTime() - tData.startTime ) / animationTime
			local lerpX, lerpY = Lerp( currentPercentage, minSizeX, maxSizeX ), Lerp( currentPercentage, minSizeY, maxSizeY )
			materials[tData.mat]( basePosX - ( lerpX - minSizeX ) * 0.5, basePosY - ( lerpY - minSizeY ) * 0.5, lerpX, lerpY, ColorAlpha( color_white, math.max( 50 - 50 * currentPercentage, 0 ) ) )
			if CurTime() - tData.startTime > animationTime then self.ClicEffects[iID] = nil end
		end
	end

	function dFrame:DrawClicEffect( dPanel, sTexture )
		table.insert( self.ClicEffects, {
			panel = dPanel,
			mat = sTexture,
			startTime = CurTime()
		} )
	end

	--[[ 
		Sound part
	]]
	local dSoundUp = vgui.Create( "DButton", dFrame )
	dSoundUp:SetPos( 418, 31 - hover_move )
	dSoundUp:SetSize( 62 + hover_extend, 62 + hover_extend )
	dSoundUp:SetText( "" )
	function dSoundUp:DoClick()
		net.Start( "RetroBoombox:ChangeSound" )
		net.WriteEntity( this )
		net.WriteInt( 1, 3 )
		net.SendToServer()
		dFrame:DrawClicEffect( self, "volume-up" )
	end

	dSoundUp.color = ColorAlpha( color_white, 50 )
	function dSoundUp:Paint( w, h )
		if self:IsHovered() then
			self.color = color_white
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) + 4, w - hover_extend, w )
		else
			self.color = ColorAlpha( color_white, 50 )
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) - 4, w - hover_extend, w )
		end

		materials["volume-up"]( 0, ( h - self.CurrentSize ) * 0.5, self.CurrentSize, self.CurrentSize, self.color )
	end

	local dSoundDown = vgui.Create( "DButton", dFrame )
	dSoundDown:SetPos( 141 - hover_move * 2, 31 - hover_move )
	dSoundDown:SetSize( 62 + hover_extend, 62 + hover_extend )
	dSoundDown:SetText( "" )
	function dSoundDown:DoClick()
		net.Start( "RetroBoombox:ChangeSound" )
		net.WriteEntity( this )
		net.WriteInt( -1, 3 )
		net.SendToServer()
		dFrame:DrawClicEffect( self, "volume-down" )
	end

	dSoundDown.CurrentSize = 0
	dSoundDown.color = ColorAlpha( color_white, 50 )
	function dSoundDown:Paint( w, h )
		if self:IsHovered() then
			self.color = color_white
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) + 4, w - hover_extend, w )
		else
			self.color = ColorAlpha( color_white, 50 )
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) - 4, w - hover_extend, w )
		end

		materials["volume-down"]( w - self.CurrentSize, ( h - self.CurrentSize ) * 0.5, self.CurrentSize, self.CurrentSize, self.color )
	end

	local dSoundShow = vgui.Create( "DPanel", dFrame )
	dSoundShow:SetPos( 211, 58 )
	dSoundShow:SetSize( 197, 7 )
	dSoundShow.CurrentSize = 0
	function dSoundShow:Paint( w, h )
		local soundPercentage = math.Clamp( IsValid( this ) and this.GetSoundLevel and this:GetSoundLevel() or 0, 0, RetroBoombox.Config.MaxSoundVolume ) / RetroBoombox.Config.MaxSoundVolume
		local currentSound = w * soundPercentage or 0
		self.CurrentSize = ( self.CurrentSize or 0 ) + ( currentSound > self.CurrentSize and 1 or -1 )
		draw.RoundedBox( h * 0.5, 0, 0, w, h, ColorAlpha( color_white, 30 ) )
		draw.RoundedBox( h * 0.5, 0, 0, self.CurrentSize, h, color_white )
	end

	--[[ 
		Main part
	]]
	local dPowerButton = vgui.Create( "DButton", dFrame )
	dPowerButton:SetPos( 231 - hover_move, 107 - hover_move )
	dPowerButton:SetSize( 157 + hover_extend, 157 + hover_extend )
	dPowerButton:SetText( "" )
	function dPowerButton:DoClick()
		net.Start( "RetroBoombox:TurnPower" )
		net.WriteEntity( this )
		net.WriteBool( false )
		net.SendToServer()
		dFrame:DrawClicEffect( self, "power" )
	end

	dPowerButton.color = ColorAlpha( color_white, 50 )
	function dPowerButton:Paint( w, h )
		if self:IsHovered() then
			self.color = color_white
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) + 4, w - hover_extend, w )
		else
			self.color = ColorAlpha( color_white, 50 )
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) - 4, w - hover_extend, w )
		end

		materials["power"]( ( w - self.CurrentSize ) * 0.5, ( h - self.CurrentSize ) * 0.5, self.CurrentSize, self.CurrentSize, self.color )
	end

	local dLightButton = vgui.Create( "DButton", dFrame )
	dLightButton:SetPos( 64 - hover_move, 161 - hover_move )
	dLightButton:SetSize( 77 + hover_extend, 77 + hover_extend )
	dLightButton:SetText( "" )
	function dLightButton:DoClick()
		net.Start( "RetroBoombox:ChangeLightMode" )
		net.WriteEntity( this )
		net.SendToServer()
		dFrame:DrawClicEffect( self, "light" )
	end

	dLightButton.color = ColorAlpha( color_white, 50 )
	function dLightButton:Paint( w, h )
		if self:IsHovered() then
			self.color = color_white
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) + 4, w - hover_extend, w )
		else
			self.color = ColorAlpha( color_white, 50 )
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) - 4, w - hover_extend, w )
		end

		materials["light"]( ( w - self.CurrentSize ) * 0.5, ( h - self.CurrentSize ) * 0.5, self.CurrentSize, self.CurrentSize, self.color )
	end

	local dGrabButton = vgui.Create( "DButton", dFrame )
	dGrabButton:SetPos( 468 - hover_move, 161 - hover_move )
	dGrabButton:SetSize( 77 + hover_extend, 77 + hover_extend )
	dGrabButton:SetText( "" )
	function dGrabButton:DoClick()
		net.Start( "RetroBoombox:GrabBoombox" )
		net.WriteEntity( this )
		net.SendToServer()
	end

	dGrabButton.color = ColorAlpha( color_white, 50 )
	function dGrabButton:Paint( w, h )
		if self:IsHovered() then
			self.color = color_white
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) + 4, w - hover_extend, w )
		else
			self.color = ColorAlpha( color_white, 50 )
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) - 4, w - hover_extend, w )
		end

		materials["grab"]( ( w - self.CurrentSize ) * 0.5, ( h - self.CurrentSize ) * 0.5, self.CurrentSize, self.CurrentSize, self.color )
	end

	--[[ 
		Frequence part
	]]
	local dPreviousFrequence = vgui.Create( "DButton", dFrame )
	dPreviousFrequence:SetPos( 137 - hover_move, 299 - hover_move )
	dPreviousFrequence:SetSize( 69 + hover_extend, 69 + hover_extend )
	dPreviousFrequence:SetText( "" )
	function dPreviousFrequence:DoClick()
		net.Start( "RetroBoombox:ChangeFrequence" )
		net.WriteEntity( this )
		net.WriteInt( -1, 3 )
		net.SendToServer()
		dFrame:DrawClicEffect( self, "left" )
	end

	dPreviousFrequence.color = ColorAlpha( color_white, 50 )
	function dPreviousFrequence:Paint( w, h )
		if self:IsHovered() then
			self.color = color_white
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) + 4, w - hover_extend, w )
		else
			self.color = ColorAlpha( color_white, 50 )
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) - 4, w - hover_extend, w )
		end

		materials["left"]( ( w - self.CurrentSize ) * 0.5, ( h - self.CurrentSize ) * 0.5, self.CurrentSize, self.CurrentSize, self.color )
	end

	local dPause = vgui.Create( "DButton", dFrame )
	dPause:SetPos( 283 - hover_move, 306 - hover_move )
	dPause:SetSize( 55 + hover_extend, 55 + hover_extend )
	dPause:SetText( "" )
	function dPause:DoClick()
		net.Start( "RetroBoombox:TurnPlaying" )
		net.WriteEntity( this )
		net.SendToServer()
		dFrame:DrawClicEffect( self, this:GetPlaying() and "pause" or "play" )
	end

	dPause.color = ColorAlpha( color_white, 50 )
	function dPause:Paint( w, h )
		if self:IsHovered() then
			self.color = color_white
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) + 4, w - hover_extend, w )
		else
			self.color = ColorAlpha( color_white, 50 )
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) - 4, w - hover_extend, w )
		end

		self.mat = this:GetPlaying() and materials["pause"] or materials["play"]
		self.mat( ( w - self.CurrentSize ) * 0.5, ( h - self.CurrentSize ) * 0.5, self.CurrentSize, self.CurrentSize, self.color )
	end

	local dNextFrequence = vgui.Create( "DButton", dFrame )
	dNextFrequence:SetPos( 413 - hover_move, 299 - hover_move )
	dNextFrequence:SetSize( 72 + hover_extend, 72 + hover_extend )
	dNextFrequence:SetText( "" )
	function dNextFrequence:DoClick()
		net.Start( "RetroBoombox:ChangeFrequence" )
		net.WriteEntity( this )
		net.WriteInt( 1, 3 )
		net.SendToServer()
		dFrame:DrawClicEffect( self, "right" )
	end

	dNextFrequence.color = ColorAlpha( color_white, 50 )
	function dNextFrequence:Paint( w, h )
		if self:IsHovered() then
			self.color = color_white
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) + 4, w - hover_extend, w )
		else
			self.color = ColorAlpha( color_white, 50 )
			self.CurrentSize = math.Clamp( ( self.CurrentSize or 0 ) - 4, w - hover_extend, w )
		end

		materials["right"]( ( w - self.CurrentSize ) * 0.5, ( h - self.CurrentSize ) * 0.5, self.CurrentSize, self.CurrentSize, self.color )
	end

	dFrame:UpdateChildren()
	return dFrame
end

local smoothdata = {}
function ENT:DrawLeftScreen()
	if self.LeftScreen and IsValid( self.LeftScreen ) then return self.LeftScreen end
	local this = self
	local size_x, size_y = 620, 400
	self.LeftScreen = vgui.Create( "Boombox.3DFrame" )
	local dFrame = self.LeftScreen
	dFrame:SetPaintedManually( true )
	dFrame:SetSize( size_x, size_y )
	dFrame:SetDrawCursor( false )
	dFrame:SetCursorColor( Color( 0, 255, 0 ) )
	dFrame:SetCursorRadius( 10 )
	dFrame:SetPaintedManually( true )
	dFrame:ShowCloseButton( false )
	dFrame:SetTitle( "" )
	function dFrame:Paint( w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color( 32, 32, 32 ) )
		if IsValid( this.Station ) then
			local boxSize = 4
			local boxNumber = 170
			local AMP = 1500
			local data = {}
			this.LightLevel = 0
			this.Station:FFT( data, FFT_1024 )
			local maxHeight = 0
			for i = 1, boxNumber * 0.5 do
				smoothdata[i] = Lerp( 10 * FrameTime(), smoothdata[i] or 0, data[i] or 0 )
				local height = math.Clamp( smoothdata[i] * AMP, 0, size_y )
				maxHeight = math.max( maxHeight, height )
				draw.RoundedBox( 0, i * boxSize, size_y - height, boxSize, height, color_white )
				draw.RoundedBox( 0, size_x - i * boxSize, size_y - height, boxSize, height, color_white )
			end

			this.LightLevel = math.Round( 9 * maxHeight / size_y ) or 9
		end
	end

	local dCurrentFrequence = vgui.Create( "DPanel", dFrame )
	dCurrentFrequence:SetPos( 0, 0 )
	dCurrentFrequence:SetSize( size_x, size_y )
	dCurrentFrequence.Paint = nil
	function dCurrentFrequence:UpdateRadio()
		local imageSize = size_y
		local dLogo = vgui.Create( "DHTML", dCurrentFrequence )
		dLogo:Dock( TOP )
		dLogo:DockMargin( ( size_x - imageSize ) * 0.5 + 10, 0, ( size_x - imageSize ) * 0.5 + 0, 0 )
		dLogo:SetTall( imageSize )
		function dLogo:Think()
			if not IsValid( this ) then return end
			if not this.GetFrequence then return end
			if self.Frequence ~= this:GetFrequence() then
				self:SetHTML( string.format( "<img src='%s' width ='%s' height='%s' >", frequencies[this:GetFrequence() or 1].logo, imageSize - 20, imageSize - 20 ) )
				self.Frequence = this:GetFrequence()
			end
		end
	end

	dCurrentFrequence:UpdateRadio()
	dFrame:UpdateChildren()
	return dFrame
end
--PATH addons/____sprinter/lua/entities/sprinter_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Printer"
ENT.Author = "Stromic"
ENT.Category = "sPrinter"
ENT.Spawnable = false
ENT.sPrinter_ent = true
ENT.upgStringToInt = {}

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "Money")
	self:NetworkVar("Int", 1, "PrintSpeed")
	self:NetworkVar("Int", 2, "Temperature")
	self:NetworkVar("Int", 3, "ClockSpeed")
	self:NetworkVar("Bool", 0, "Power")
	self:NetworkVar("Float", 0, "Battery")
	self:NetworkVar("Entity", 0, "Rack")
	self:NetworkVar("Entity", 1, "owning_ent")
end

function ENT:GetWithdrawAmount()
	local amount = self:GetMoney()

	local result = hook.Run("sP:PreWithdraw", self, amount)

	return result or amount
end

function ENT:GetUpgradePrice(upgrade, stage)
	local price = self.data.upgrades[upgrade].enforced_pricing and self.data.upgrades[upgrade].enforced_pricing[stage] or (self.data.upgrades[upgrade].baseprice * stage)

	local new_price = hook.Run("sP:PrePrinterUpgradePrice", self, price, upgrade, stage)

	return isnumber(new_price) and new_price or price
end

function ENT:GetFullUpgradePrice(upg_int)
	local cur_stage = self.data.upgrades[upg_int].stage or 0
    local sum = 0

    for i = (cur_stage + 1), self.data.upgrades[upg_int].max do
        sum = sum + self:GetUpgradePrice(upg_int, i)
    end

    return sum
end

function ENT:GetUpgrade(upgrade)
	if table.IsEmpty(self.upgStringToInt) then
		for k,v in pairs(self.data.upgrades) do
			self.upgStringToInt[v.upgrade] = k
		end
	end

	local upg = self.upgStringToInt[upgrade] and self.data.upgrades[self.upgStringToInt[upgrade]] or self.data.upgrades[upgrade]
	
	return istable(upg) and upg.stage or 0
end

function ENT:GetMaxStorage()
	local upgradedStorage = 0
	local upgradeIndex = self.upgStringToInt["storage"]

	if upgradeIndex then
		local upgradeLevel = self:GetUpgrade("storage")

		upgradedStorage = upgradeLevel * self.data.upgrades[upgradeIndex].increment
	end

	return self.data.maxstorage + upgradedStorage
end

function ENT:GetRechargePrice()
	local rechargePrice = self.data.rechargeprice

	if sPrinter.config["recharge_price_per_percentage"] then
		rechargePrice = rechargePrice * (1 - self:GetBattery())
	end

	return math.Round(rechargePrice)
end
--PATH addons/____sprinter/lua/entities/sprinter_base_phys/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Printer"
ENT.Author = "Stromic"
ENT.Category = "sPrinter"
ENT.Spawnable = false
ENT.sPrinter_ent = true
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_bud/cl_init.lua:
include("shared.lua")

local grn = Color(0, 0, 0, 255)
local xpos = 20
local ypos = 10

function ENT:Draw() end

function ENT:DrawTranslucent()
	self:DrawModel()
	if self:GetPos():Distance(LocalPlayer():GetPos()) > 500 then return end
	local ang = LocalPlayer():EyeAngles()
	local pos = self:GetPos() + Vector(0,0,10)

	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)

	cam.Start3D2D(pos, ang, 0.06)
		-- Background
		draw.RoundedBox(0, xpos, ypos+0, 400, 120, Color(0, 0, 0, 225))
		-- Side bar
		draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)
	
		draw.SimpleText(string.upper(UWeed.Translation.Bud.title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw.SimpleText(UWeed.Translation.Bud.Estimated.." "..math.Clamp(self:GetBudCounter()-self:GetEstimateLower(), 1, 10).."-"..math.Clamp(self:GetBudCounter()+self:GetEstimateHigher(), 1, 10)..UWeed.Translation.Bud.Gram, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_plant/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "[UWeed] Plant"
ENT.Author = "Owain Owjo"
ENT.Category = "UWeed"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "owning_ent")
	self:NetworkVar("Int", 0, "Stage")
	self:NetworkVar("Int", 1, "NBodygroup")
	self:NetworkVar("Int", 2, "BudCount")
	self:NetworkVar("Int", 3, "LightLevel")
end
--PATH addons/_farmer/lua/effects/ba_cage_drink.lua:
--[[
	Just a first attempt in effect.
	Green text just makes me feel better.
]]--

function EFFECT:Init(data)
	
	local offset = data:GetOrigin();
	
	sound.Play("npc/barnacle/barnacle_gulp"..math.random(1, 2)..".wav", offset, 70);
	
	local particlesAmount = math.random(16, 32);
	local emitter = ParticleEmitter(offset, false);
		for i=0, particlesAmount do
			local particle = emitter:Add("particle/smokesprites_000"..math.random(1, 9), offset);
			
			if (particle) then
				
				particle:SetVelocity(Vector(math.random(-16, 16), math.random(-16, 16), math.random(-16, 16)));
				
				particle:SetLifeTime(0);
				particle:SetDieTime(1);
				
				particle:SetStartAlpha(128);
				particle:SetEndAlpha(64);
				
				particle:SetStartSize(math.random(3, 4));
				particle:SetEndSize(math.random(1, 2));
				
				particle:SetRoll(math.random(180, 480));
				particle:SetRollDelta(math.random(-2, 2));
				
				particle:SetAirResistance(0);
				particle:SetGravity(Vector(0, 0, -128));
				
				particle:SetColor(130, 171, 212);
				
				particle:SetCollide(true);
				particle:SetBounce(1);
				
				particle:SetAngleVelocity(Angle(math.random(-2, 2), math.random(-2, 2), math.random(-2, 2)));
				
				particle:SetLighting(true);
			end;
		end;
	emitter:Finish();
end;


function EFFECT:Think()
	return false;
end;


function EFFECT:Render()

end;

--PATH addons/_drones/lua/effects/dronesrewrite_beam.lua:
function EFFECT:Init(data)
	self.startPos = data:GetStart()
	self.endPos = data:GetOrigin()
	local clr = data:GetAngles()
	self.entity = data:GetEntity()

	self.color = Color(clr.x, clr.y, clr.z)

	self.dieTime = CurTime() + 0.05

	if IsValid(self.entity) then
		self:SetRenderBoundsWS(self.entity:LocalToWorld(self.startPos), self.endPos)
	end
end

function EFFECT:Think()
	return CurTime() < self.dieTime
end

function EFFECT:Render()
	if not self.entity:IsValid() then return end

	local start = self.entity:LocalToWorld(self.startPos)

	render.SetMaterial(Material("effects/laser1"))
	render.DrawBeam(start, self.endPos, math.Rand(6, 16), 1, math.Rand(1, 5), self.color)

	render.SetMaterial(Material("sprites/light_glow02_add"))
	render.DrawSprite(self.endPos, math.random(32, 64), math.random(32, 64), self.color)

	render.DrawSprite(self.endPos + (start - self.endPos):GetNormal() * 8, 32, 32, self.color)
	render.DrawSprite(self.endPos + (start - self.endPos):GetNormal() * 16, 16, 16, self.color)
end

--PATH addons/_drones/lua/effects/dronesrewrite_explosionbig.lua:
AddCSLuaFile()

local sin = math.sin
local cos = math.cos
local random = math.random
local Rand = math.Rand
local abs = math.abs

function EFFECT:Init(data)
	self.Start = data:GetOrigin()

	local ef = EffectData()
	ef:SetOrigin(self.Start)
	util.Effect("HelicopterMegaBomb", ef) 

	self.Emitter = ParticleEmitter(self.Start)
	if not self.Emitter then return end

	local p = self.Emitter:Add("particle/warp1_warp", self.Start)

	p:SetDieTime(0.4)
	p:SetStartAlpha(255)
	p:SetEndAlpha(0)
	p:SetStartSize(0)
	p:SetEndSize(2500)
	
	for i = 1, 15 do
		local vec = VectorRand()
		vec.z = abs(vec.z)

		local p = self.Emitter:Add("effects/fleck_cement" .. random(1, 2), self.Start)

		p:SetDieTime(random(7, 12))
		p:SetStartAlpha(random(120, 250))
		p:SetEndAlpha(0)
		p:SetStartSize(random(10, 40))
		p:SetRoll(Rand(-10, 10))
		p:SetRollDelta(Rand(-10, 10))	
		p:SetVelocity(vec * 1000)
		p:SetAirResistance(40)
		p:SetGravity(Vector(0, 0, random(-300, -100)))
		p:SetColor(0, 0, 0)
	end

	for i = 1, 5 do
		local p = self.Emitter:Add("particle/smokesprites_000" .. random(1, 3), self.Start)

		p:SetDieTime(1.8)
		p:SetStartAlpha(130)
		p:SetEndAlpha(0)
		p:SetStartSize(100)
		p:SetRollDelta(Rand(-1, 1))
		p:SetEndSize(1500)		
		p:SetVelocity(Vector(sin(i), cos(i), 0) * 2500)
		p:SetAirResistance(300)
		p:SetColor(50, 50, 20)

		local vec = VectorRand()
		local p = self.Emitter:Add("particles/fir21", self.Start + vec * 100)

		p:SetDieTime(0.15)
		p:SetStartAlpha(120)
		p:SetEndAlpha(0)
		p:SetStartSize(0)
		p:SetRoll(Rand(-10, 10))
		p:SetRollDelta(Rand(-32, 32))
		p:SetEndSize(1000)		
		p:SetVelocity(Vector(sin(i), cos(i), 0) * 3500)
		p:SetAirResistance(300)
		p:SetColor(255, 200, 0)
	end

	for i = 1, math.random(3, 5) do
		local vec = VectorRand()

		for a = 1, random(5, 8) do
			local p = self.Emitter:Add("particle/smokesprites_000" .. random(1, 3), self.Start)

			p:SetDieTime(Rand(0.4, 1))
			p:SetStartAlpha(255)
			p:SetEndAlpha(0)
			p:SetStartSize(80)
			p:SetRoll(Rand(-10, 10))
			p:SetRollDelta(Rand(-0.5, 0.5))
			p:SetEndSize(360 + a * 10)		
			p:SetGravity(Vector(0, 0, -random(10, 50) - a * 22))
			p:SetVelocity(vec * a * 850)
			p:SetAirResistance(350)
			p:SetColor(70, 70, 20)
		end
	end


	for i = 1, 30 do
		local vec = VectorRand()
		local p = self.Emitter:Add("particles/fir21", self.Start + vec * 100)

		p:SetDieTime(0.2)
		p:SetStartAlpha(60)
		p:SetEndAlpha(0)
		p:SetStartSize(100)
		p:SetRoll(Rand(-10, 10))
		p:SetRollDelta(Rand(-0.5, 0.5))
		p:SetEndSize(200)		
		p:SetVelocity(vec * 1500)
		p:SetAirResistance(40)
		p:SetColor(255, 200, 0)
	end	

	-- Exp core

	local vec = VectorRand()
	local p = self.Emitter:Add("sprites/orangecore1", self.Start + vec * 40)

	p:SetAirResistance(50)
	p:SetDieTime(0.2)
	p:SetStartAlpha(255)
	p:SetEndAlpha(0)
	p:SetStartSize(0)
	p:SetRoll(Rand(-1, 1))
	p:SetRollDelta(Rand(-15, 15))
	p:SetEndSize(800)		
	p:SetColor(255, 255, 255)

	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()

end






--PATH addons/_drones/lua/effects/dronesrewrite_flame.lua:
function EFFECT:Init(data)     
    local Startpos = data:GetStart()
    local Hitpos = data:GetOrigin()
                       
    if not Startpos then return end
    self.Emitter = ParticleEmitter(Startpos)
               
    for i = 1, 20 do
        local p = self.Emitter:Add("particles/firebom21", Startpos)    
        p:SetDieTime(1.8)
        p:SetStartAlpha(math.random(170, 200))
        p:SetEndAlpha(0)
        p:SetStartSize(2)
        p:SetEndSize(math.random(55, 75))
        p:SetRoll(math.random(-10, 10))
        p:SetRollDelta(math.random(-15, 15))   
        p:SetVelocity(((Hitpos - Startpos):GetNormal() * math.random(500, 800)) + VectorRand() * math.random(1, 20))
        p:SetCollide(true)                      
    end
               
    for i = 1, 2 do
        local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), Startpos)    
        p:SetDieTime(2)
        p:SetStartAlpha(255)
        p:SetEndAlpha(0)
        p:SetStartSize(math.Rand(2, 4))
        p:SetEndSize(math.random(70, 90))
        p:SetRoll(math.random(-10, 10))
        p:SetRollDelta(math.random(-10, 10))   
        p:SetVelocity(((Hitpos - Startpos):GetNormal() * math.random(500, 800)) + VectorRand() * math.random(1, 30) + Vector(0,0,20))
        p:SetCollide(true)
        p:SetColor(40, 40, 40)
    end

    self.Emitter:Finish()
end
               
function EFFECT:Think()
    return false
end
 
function EFFECT:Render()
end
--PATH addons/_drones/lua/effects/dronesrewrite_muzzleflashblaster4.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.Forward = data:GetNormal()

	self.Emitter = ParticleEmitter(self.Start)

	local dlight = DynamicLight(self:EntIndex())
	if dlight then
		dlight.pos = self.Start
		dlight.r = 0
		dlight.g = 0
		dlight.b = 255
		dlight.brightness = 1
		dlight.Decay = 1
		dlight.Size = math.random(150, 300)
		dlight.DieTime = CurTime()
	end

	local p = self.Emitter:Add("sprites/heatwave", self.Start - self.Forward * 2)
	p:SetVelocity(120 * self.Forward + 20 * VectorRand() * 2)
	p:SetGravity(Vector(0, 0, 100))
	p:SetAirResistance(160)
	p:SetDieTime(math.Rand(0.1, 0.15))
	p:SetStartSize(30)
	p:SetEndSize(0)
	p:SetRoll(math.Rand(180, 480))
	p:SetRollDelta(math.Rand(-1, 1))

	for a = 1, 12 do
		for i = 1, 4 do
			local p = self.Emitter:Add("sprites/light_glow02_add", self.Start + i * 4 * self.Forward)

			p:SetAirResistance(200)
			p:SetVelocity(6 * VectorRand())
			p:SetDieTime(math.Rand(0.05, 0.15))
			p:SetStartAlpha(155)
			p:SetStartSize(0)
			p:SetEndSize(34 - i * 6)
			p:SetRoll(math.Rand(180, 480))
			p:SetRollDelta(math.Rand(-1, 1))
			p:SetColor(0, 0, 255)	
		end
	end
	
	for i = 1, 4 do
		local p = self.Emitter:Add("sprites/light_glow02_add", self.Start + i * 4 * self.Forward)

		p:SetAirResistance(200)
		p:SetVelocity(6 * VectorRand())
		p:SetDieTime(math.Rand(0.05, 0.15))
		p:SetStartAlpha(155)
		p:SetStartSize(0)
		p:SetEndSize(34 - i * 6)
		p:SetRoll(math.Rand(180, 480))
		p:SetRollDelta(math.Rand(-1, 1))
		p:SetColor(255, 255, 255)	
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end





--PATH addons/lvs_base-main/lua/effects/lvs_bullet_impact.lua:

EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local scale = data:GetMagnitude()

	sound.Play( "physics/flesh/flesh_strider_impact_bullet"..math.random(1,3)..".wav", pos, 85, math.random(180,200) + 55 * math.max(1 - scale,0), 0.75 )
	sound.Play( "ambient/materials/rock"..math.random(1,5)..".wav", pos, 75, 180, 1 )

	local emitter = ParticleEmitter( pos, false )

	local VecCol = (render.GetLightColor( pos + dir ) * 0.5 + Vector(0.2,0.18,0.15)) * 255

	local DieTime = math.Rand(0.8,1.6)

	if dir.z > 0.85 then
		for i = 1, 10 do
			for n = 0,6 do
				local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ] , pos )

				if not particle then continue end

				particle:SetVelocity( (dir * 50 * i + VectorRand() * 25) * scale )
				particle:SetDieTime( (i / 8) * DieTime )
				particle:SetAirResistance( 10 ) 
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( 10 * scale )
				particle:SetEndSize( 20 * i * scale )
				particle:SetRollDelta( math.Rand(-1,1) )
				particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
				particle:SetGravity( Vector(0,0,-600) * scale )
				particle:SetCollide( false )
			end
		end

		for i = 1, 10 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , pos )

			if not particle then continue end

			particle:SetVelocity( (dir * 50 * i + VectorRand() * 40) * scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * scale )
			particle:SetEndSize( 20 * i * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 1,12 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , pos )
		
		if particle then
			local ang = i * 30
			local X = math.cos( math.rad(ang) )
			local Y = math.sin( math.rad(ang) )

			local Vel = Vector(X,Y,0) * math.Rand(200,1600) + Vector(0,0,50)
			Vel:Rotate( dir:Angle() + Angle(90,0,0) )

			particle:SetVelocity( Vel * scale )
			particle:SetDieTime( DieTime )
			particle:SetAirResistance( 500 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 40 * scale )
			particle:SetEndSize( 200 * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,60) * scale )
			particle:SetCollide( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/lvs_base-main/lua/effects/lvs_firetrail.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	self.Scale = data:GetScale()
	self.DieTime = CurTime() + data:GetMagnitude()
	self.Pos = data:GetStart()
	
	if not IsValid( self.Entity ) then return end

	self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.Pos ), false )
end


function EFFECT:Think()
	if IsValid( self.Entity ) then
		local Pos = self.Entity:LocalToWorld( self.Pos )

		local T = CurTime()

		if (self.nextDFX or 0) < T then
			self.nextDFX = T + 0.05

			if self.Emitter then
				local particle = self.Emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )

				if particle then
					particle:SetVelocity( VectorRand() * 100 * self.Scale )
					particle:SetDieTime( 3 )
					particle:SetAirResistance( 0 )
					particle:SetStartAlpha( 150 )
					particle:SetStartSize( 150 * self.Scale )
					particle:SetEndSize( math.Rand(200,300) * self.Scale )
					particle:SetRoll( math.Rand(-1,1) * 100 )
					particle:SetColor( 40,40,40 )
					particle:SetGravity( Vector( 0, 0, 0 ) )
					particle:SetCollide( false )
				end

				local particle = self.Emitter:Add( "effects/lvs_base/fire", Pos )

				if particle then
					particle:SetVelocity( VectorRand() * 100 * self.Scale )
					particle:SetDieTime( math.random(40,80) / 100 )
					particle:SetAirResistance( 0 ) 
					particle:SetStartAlpha( 255 )
					particle:SetStartSize( 130 * self.Scale )
					particle:SetEndSize( math.Rand(50,100) * self.Scale )
					particle:SetRoll( math.Rand(-1,1) * 180 )
					particle:SetColor( 255,255,255 )
					particle:SetGravity( Vector( 0, 0, 70 ) )
					particle:SetCollide( false )
				end

				for i = 0,3 do
					local particle = self.Emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), Pos + VectorRand() * 100 * self.Scale )

					if particle then
						particle:SetVelocity( VectorRand() * 100 * self.Scale )
						particle:SetDieTime( math.random(30,60) / 100 )
						particle:SetAirResistance( 0 ) 
						particle:SetStartAlpha( 255 )
						particle:SetStartSize( 70 * self.Scale )
						particle:SetEndSize( math.Rand(25,80) * self.Scale )
						particle:SetRoll( math.Rand(-1,1) * 180 )
						particle:SetColor( 255,255,255 )
						particle:SetGravity( Vector( 0, 0, 40 ) )
						particle:SetCollide( false )
					end
				end
			end
		end

		if self.DieTime < CurTime() then 
			if self.Emitter then
				self.Emitter:Finish()
			end

			return false
		end

		return true
	end

	if self.Emitter then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
end

--PATH addons/lvs_base-main/lua/effects/lvs_missiletrail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )
		if particle then
			particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
			particle:SetVelocity( -self.Entity:GetForward() * 200  )
			particle:SetAirResistance( 600 ) 
			particle:SetDieTime( math.Rand(1.5,2) )
			particle:SetStartAlpha( 50 )
			particle:SetStartSize( 20 )
			particle:SetEndSize( 60 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetRollDelta( math.Rand( -1, 1 ) )
			particle:SetColor(40,40,40)
			particle:SetCollide( false )
		end

		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 8 )
			particle:SetEndSize( 1 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 0.25 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 6 )
			particle:SetEndSize( 2 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity

	if not IsValid( ent ) then return end

	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )
	render.DrawSprite( pos, 100, 100, Color( 255, 200, 150, 255 ) )
end

--PATH addons/lvs_base-main/lua/effects/lvs_physics_water.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	self.LifeTime = math.Rand(1.5,3)
	self.DieTime = CurTime() + self.LifeTime

	self.Splash = {
		Pos = Pos,
		Mat = Material("effects/splashwake1"),
		RandomAng = math.random(0,360),
	}

	local emitter = Ent:GetParticleEmitter( Ent:GetPos() )

	if emitter and emitter.Add then
		local particle = emitter:Add( "effects/splash4", Pos + VectorRand(-10,10) - Vector(0,0,20) )
		if particle then
			particle:SetVelocity( Vector(0,0,250) )
			particle:SetDieTime( 0.8 )
			particle:SetAirResistance( 60 ) 
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 50 )
			particle:SetEndSize( 100 )
			particle:SetRoll( math.Rand(-1,1) * 100 )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( false )
		end
	end
end


function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	end
	return true
end

function EFFECT:Render()
	if self.Splash and self.LifeTime then
		local Scale = (self.DieTime - self.LifeTime - CurTime()) / self.LifeTime
		local S = 200 - Scale * 600
		local Alpha = 100 + 100 * Scale

		cam.Start3D2D( self.Splash.Pos + Vector(0,0,1), Angle(0,0,0), 1 )
			surface.SetMaterial( self.Splash.Mat )
			surface.SetDrawColor( 255, 255, 255 , Alpha )
			surface.DrawTexturedRectRotated( 0, 0, S , S, self.Splash.RandomAng )
		cam.End3D2D()
	end
end
--PATH addons/lvs_cars_3027255911/lua/effects/lvs_tracer_autocannon.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

EFFECT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )

	self.emitter = ParticleEmitter( pos, false )

	self.OldPos = pos
	self.Dir = dir

	if not self.emitter then return end

	local VecCol = (render.GetLightColor( pos ) * 0.8 + Vector(0.2,0.2,0.2)) * 255
	for i = 0, 2 do
		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], pos )

		if not particle then continue end

		particle:SetVelocity( dir * 700 + VectorRand() * 200 )
		particle:SetDieTime( math.Rand(0.5,1) )
		particle:SetAirResistance( 250 ) 
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 5 )
		particle:SetEndSize( 80 )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,100) )
		particle:SetCollide( false )
	end

	for i = 0, math.random(1,12) do
		local particle = self.emitter:Add( "sprites/rico1", pos )

		if not particle then continue end

		particle:SetVelocity( dir * 2000 + VectorRand() * 50 )
		particle:SetDieTime( math.Rand(0.1,0.2) )
		particle:SetStartAlpha( 0 )
		particle:SetEndAlpha( 5 )
		particle:SetStartSize( math.Rand(0,0.5) )
		particle:SetEndSize( math.Rand(0,0.5) )
		particle:SetRollDelta( 100 )
		particle:SetAirResistance( 0 )
		particle:SetColor( 255, 200, 120 )
	end

	local trace = util.TraceLine( {
		start = pos,
		endpos = pos - Vector(0,0,500),
		mask = MASK_SOLID_BRUSHONLY,
	} )

	if not trace or not trace.Hit then return end

	local VecCol = (render.GetLightColor( trace.HitPos + trace.HitNormal ) * 0.8 + Vector(0.17,0.15,0.1)) * 255
	for i = 1, 12 do
		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], trace.HitPos )
		
		if not particle then continue end

		local ang = i * 30
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )

		particle:SetVelocity( Vector(X,Y,0) * 1000 )
		particle:SetDieTime( math.Rand(0.5,1) )
		particle:SetAirResistance( 500 ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 25 )
		particle:SetEndSize( 80 )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,150) + self.Dir * 1000 )
		particle:SetCollide( false )
	end

	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local ViewEnt = ply:GetViewEntity()

	if not IsValid( ViewEnt ) then return end

	local Intensity = ply:InVehicle() and 1 or 2
	local Ratio = math.min( 250 / (ViewEnt:GetPos() - trace.HitPos):Length(), 1 )

	if Ratio < 0 then return end

	util.ScreenShake( trace.HitPos, Intensity * Ratio, 0.1, 0.5, 250 )
end

function EFFECT:Think()
	local bullet = LVS:GetBullet( self.ID )

	if not bullet then
		if self.emitter then
			self.emitter:Finish()
		end

		local StartPos = self.OldPos
		local EndPos = StartPos + self.Dir * 1000

		local trace = util.TraceLine( {
			start = StartPos,
			endpos = EndPos,
		} )

		local effectdata = EffectData()
		effectdata:SetOrigin( trace.HitPos )
		effectdata:SetStart( self.Dir )
		effectdata:SetEntity( trace.Entity )
		effectdata:SetNormal( trace.HitNormal )
		effectdata:SetSurfaceProp( trace.SurfaceProps )
		effectdata:SetMagnitude( 0.5 )
		util.Effect( "lvs_bullet_impact_ap", effectdata )

		return false
	end

	if not self.emitter then return true end

	local Pos = bullet:GetPos()

	self.Dir = bullet:GetDir()

	local Sub = self.OldPos - Pos
	local Dist = Sub:Length()
	local Dir = Sub:GetNormalized()

	local Vel = bullet.Velocity / 10

	for i = 0, Dist, 100 do
		local cur_pos = self.OldPos + Dir * i

		local VecCol = (render.GetLightColor( cur_pos ) * 0.8 + Vector(0.2,0.2,0.2)) * 255

		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], cur_pos )
		
		if not particle then continue end

		particle:SetVelocity( -Dir * Vel + VectorRand() * 10 )
		particle:SetDieTime( math.Rand(0.05,1) )
		particle:SetAirResistance( 250 )
		particle:SetStartAlpha( 100 )
		particle:SetEndAlpha( 0 )

		particle:SetStartSize( 0 )
		particle:SetEndSize( 15 )

		particle:SetRollDelta( 1 )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetCollide( false )
	end

	self.OldPos = Pos

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 2000 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )

	render.DrawBeam( endpos - dir * len, endpos + dir * len * 0.1, 10, 1, 0, Color( 100, 100, 100, 100 ) )
	render.DrawBeam( endpos - dir * len * 0.5, endpos + dir * len * 0.1, 5, 1, 0, Color( 255, 255, 255, 255 ) )

	render.SetMaterial( self.MatSprite ) 
	render.DrawSprite( endpos, 400, 400, Color( 100, 100, 100, 255 ) )
end

--PATH addons/____inventory/lua/itemstore/cl_gui.lua:
include( "skins/" .. itemstore.config.Skin .. ".lua" )

for _, filename in ipairs( file.Find( "itemstore/vgui/*.lua", "LUA" ) ) do
	include( "vgui/" .. filename )
end

itemstore.ContextInventory = nil

function itemstore.CreateContextInventory()
	if not itemstore.config.ContextInventory then return end
	if not IsValid( g_ContextMenu ) then return end

	local inv = vgui.Create( "ItemStoreContainerWindow", g_ContextMenu )
	inv:SetTitle( itemstore.Translate( "inventory" ) )
	inv:SetContainerID( LocalPlayer().InventoryID )
	inv:ShowCloseButton( false )
	inv:SetDraggable( false )
	inv:InvalidateLayout( true )

	local side = itemstore.config.ContextInventoryPosition

	if side == "bottom" then
		inv:SetPos( ScrW() * 0.5 - inv:GetWide() * 0.5, ScrH() - inv:GetTall() )
	elseif side == "bottomleft" then
		inv:SetPos( 0, ScrH() - inv:GetTall() )
	elseif side == "bottomright" then
		inv:SetPos( ScrW() - inv:GetWide(), ScrH() - inv:GetTall() )
	elseif side == "top" then
		inv:SetPos( ScrW() * 0.5 - inv:GetWide() * 0.5, 0 )
	elseif side == "topleft" then
		inv:SetPos( 0, 0 )
	elseif side == "topright" then
		inv:SetPos( ScrW() - inv:GetWide(), 0 )
	elseif side == "left" then
		inv:SetPos( 0, ScrH() * 0.5 - inv:GetTall() * 0.5 )
	elseif side == "right" then
		inv:SetPos( ScrW() - inv:GetWide(), ScrH() * 0.5 - inv:GetTall() * 0.5 )
	end

	itemstore.ContextInventory = inv
end

hook.Add( "Tick", "ItemStoreHideContextInventory", function()
	if not IsValid( LocalPlayer() ) then return end

	if IsValid( itemstore.ContextInventory ) then 
		itemstore.ContextInventory:SetVisible( LocalPlayer():CanUseInventory() )
	else
		if LocalPlayer().InventoryID then
			itemstore.CreateContextInventory()
		end
	end
end )

hook.Add( "ContextMenuCreated", "ItemStoreInventory", function( context )
	if not IsValid( context ) then return end
	
	context:Receiver( "ItemStore", function( receiver, droppable, dropped )
		local container_id = droppable[ 1 ]:GetContainerID()
		local slot = droppable[ 1 ]:GetSlot()

		if dropped then
			LocalPlayer():DropItem( container_id, slot )
		end
	end )
end )

net.Receive( "ItemStoreRecreateContextMenu", function()
	if IsValid( itemstore.ContextInventory ) then
		itemstore.ContextInventory:Remove()
		itemstore.ContextInventory = nil
	end
end )
--PATH addons/____inventory/lua/itemstore/vgui/containerwindow.lua:
local PANEL = {}

if itemstore.config.UseNewUI then
	function PANEL:Init()
		self:SetSkin( "itemstore" )
	
		self.Container = vgui.Create( "ItemStoreNewContainer", self )
		self.Container:Dock( FILL )
	end
	
	function PANEL:Refresh()
		self.Container:Refresh()
	end
	
	function PANEL:SetContainerID( id )
		self.Container:SetContainerID( id )
	
		local con = itemstore.containers.Get( id )
		if not con then return end
	
		local p = 1
		local sw, sh = 48, 48
		local cw, ch = con:GetWidth(), con:GetHeight()
		local w, h = 10 + ( sw + p ) * cw, 34 + 37 + ( sh + p ) * ch
	
		self:SetSize( w, h )
	end
	
	function PANEL:GetContainerID()
		return self.Container:GetContainerID()
	end
else
	function PANEL:Init()
		self:SetSkin( "itemstore" )

		self.Container = vgui.Create( "ItemStoreContainer", self )
		self.Container:SizeToContents()
	end

	function PANEL:PerformLayout()
		self:SetSize( self.Container:GetWide() + 10, self.Container:GetTall() + 32 )
		self.Container:SetPos( 5, 27 )

		self.BaseClass.PerformLayout( self )
	end

	function PANEL:Refresh()
		self.Container:Refresh()
	end

	function PANEL:SetContainerID( id )
		self.Container:SetContainerID( id )
	end

	function PANEL:GetContainerID()
		return self.Container:GetContainerID()
	end
end

vgui.Register( "ItemStoreContainerWindow", PANEL, "DFrame" )

--PATH addons/____plogs/lua/plogs_hooks/cuffs.lua:
--[[
addons/lgos/lua/plogs_hooks/cuffs.lua
--]]
plogs.Register('Наручники', false)

plogs.AddHook('OnHandcuffed', function(pl, targ)
	plogs.PlayerLog(pl, 'Наручники', pl:NameID() .. ' завязал ' .. targ:NameID(), {
		['Name'] 			= pl:Name(),
		['SteamID']			= pl:SteamID(),
		['Target Name'] 	= targ:Name(),
		['Target SteamID']	= targ:SteamID()
	})
end)

plogs.AddHook('OnHandcuffBreak', function(pl, cuffs, friend)
	if IsValid(friend) then
		plogs.PlayerLog(pl, 'Наручники', friend:NameID() .. ' развазял ' .. pl:NameID(), {
			['Name'] 			= pl:Name(),
			['SteamID']			= pl:SteamID(),
			['Fried Name'] 		= friend:Name(),
			['Target SteamID']	= friend:SteamID()
		})
	else
		plogs.PlayerLog(pl, 'Наручники', pl:NameID() .. ' освободился из наручников', {
			['Name'] 			= pl:Name(),
			['SteamID']			= pl:SteamID()
		})
	end
end)


--PATH addons/____plogs/lua/plogs_hooks/darkrp.lua:
--[[
addons/lgos/lua/plogs_hooks/darkrp.lua
--]]

-- Names
plogs.Register('Имена', true, Color(51, 128, 255))

plogs.AddHook('onPlayerChangedName', function(pl, old, new)
	if IsValid(pl) and (old ~= nil) then
		plogs.PlayerLog(pl, 'Имена', pl:NameID() .. ' changed their name to ' .. new ..  ' from ' .. old, {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID()
		})
	end
end)


plogs.Register('Гроші', false, Color(51, 128, 255))

plogs.AddHook('PlayerPickupRPMoney', function(pl, amout, newcash)
	if IsValid(pl) then
		plogs.PlayerLog(pl, 'Гроші', pl:NameID() .. ' підняв $' .. amout .. ' (Нова сума грошей: $ ' .. newcash .. ')', {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID()
		})
	end
end)

plogs.AddHook('playerGiveMoneyPodarit_BattlePass', function(pl, pl2, amout)
	if IsValid(pl) then
		plogs.PlayerLog(pl,'Гроші', pl:NameID() .. ' дав $' .. amout .. ' гравцю: ' .. pl2:NameID(), {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID(),
			['NameTarget'] = pl2:Name(),
			['SteamIDTarget'] = pl2:SteamID()
		})
	end
end)

plogs.AddHook('PlayerDropRPMoney', function(pl, amout, newcash)
	if IsValid(pl) then
		plogs.PlayerLog(pl,'Гроші', pl:NameID() .. ' скинув на землю $' .. amout .. ' (Нова сума грошей: $' .. newcash .. ')',{
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID(),
		})
	end
end)

plogs.AddHook('PlayerDropRPCheck', function(pl, pl2, amout, newcash)
	if IsValid(pl) then
		plogs.PlayerLog(pl,'Гроші', pl:NameID() .. ' відмовився від чека до ' .. pl2:NameID() .. ' за $' .. amout .. ' (Нова сума грошей: $' .. newcash .. ')', {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID(),
			['NameTarget'] = pl2:Name(),
			['SteamIDTarget'] = pl2:SteamID()
		})
	end
end)

plogs.AddHook('PlayerDropRPCheck', function(pl, pl2, amout, newcash)
	if IsValid(pl) then
		plogs.PlayerLog(pl,'Гроші', pl:NameID() .. ' Передал ' .. pl2:NameID() .. ' сумма $' .. amout .. ' (Нова сума грошей: $' .. newcash .. ')', {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID(),
			['NameTarget'] = pl2:Name(),
			['SteamIDTarget'] = pl2:SteamID()
		})
	end
end)

plogs.AddHook('PlayerDropRPCheck', function(pl, pl2, amout, newcash)
	if IsValid(pl) then
		plogs.PlayerLog(pl,'Гроші', pl:NameID() .. ' Ограбил ' .. pl2:NameID() .. ' на $' .. amout .. ' (Нова сума грошей: $' .. newcash .. ')', {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID(),
			['NameTarget'] = pl2:Name(),
			['SteamIDTarget'] = pl2:SteamID()
		})
	end
end)

-- Job changes
plogs.Register('Праці', true, Color(51, 128, 255))

plogs.AddHook('OnPlayerChangedTeam', function(pl, old, new)
	if IsValid(pl) then
		plogs.PlayerLog(pl, 'Праці', pl:NameID() .. ' changed their job to ' .. team.GetName(new) ..  ' from ' .. team.GetName(old), {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID()
		})
	end
end)


-- Demotions
plogs.Register('Звільнення', true, Color(51, 128, 255))

plogs.AddHook('onPlayerDemoted', function(demoter, demotee, reason)
	if IsValid(demoter) and IsValid(demotee) then
		plogs.PlayerLog(demoter, 'Звільнення', demoter:NameID() .. ' почав пониження на ' .. demotee:NameID() ..  ' за ' .. reason, {
			['Target Name'] 	= demotee:Name(),
			['Target SteamID']	= demotee:SteamID(),
			['Demotee Name'] 	= demoter:Name(),
			['Demotee SteamID']	= demoter:SteamID(),
		})
	end
end)

-- Police logs
plogs.Register('Полиция', true, Color(51, 128, 255))

plogs.AddHook('playerArrested', function(target, time, officer)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Полиция', officer:NameID() .. ' арестовал ' .. target:NameID(), {
			['Target Name'] 	= target:Name(),
			['Target SteamID']	= target:SteamID(),
			['Officer Name'] 	= officer:Name(),
			['Officer SteamID']	= officer:SteamID(),
		})
	end
end)

plogs.AddHook('playerUnArrested', function(target, officer)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Полиция', officer:NameID() .. ' снял арест ' .. target:NameID(), {
			['Target Name'] 	= target:Name(),
			['Target SteamID']	= target:SteamID(),
			['Officer Name'] 	= officer:Name(),
			['Officer SteamID']	= officer:SteamID(),
		})
	else
		plogs.Log('Полиция', target:NameID() .. ' вышел с джайла.', {
			['Name'] 	= target:Name(),
			['SteamID']	= target:SteamID(),
		})
	end
end)

plogs.AddHook('playerWanted', function(target, officer, reason)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Полиция', officer:NameID() .. ' розыск ' .. target:NameID() .. ' причина ' .. reason, {
			['Target Name'] 	= target:Name(),
			['Target SteamID']	= target:SteamID(),
			['Officer Name'] 	= officer:Name(),
			['Officer SteamID']	= officer:SteamID(),
		})
	end
end)

plogs.AddHook('playerUnWanted', function(target, officer)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Полиция', officer:NameID() .. ' снял розыск ' .. target:NameID(), {
			['Target Name'] 	= target:Name(),
			['Target SteamID']	= target:SteamID(),
			['Officer Name'] 	= officer:Name(),
			['Officer SteamID']	= officer:SteamID(),
		})
	else
		plogs.Log('Полиция', target:NameID() .. '\'s wanted has expired', {
			['Name'] 	= target:Name(),
			['SteamID']	= target:SteamID(),
		})
	end
end)

plogs.AddHook('playerWarranted', function(target, officer, reason)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Полиция', officer:NameID() .. ' warranted ' .. target:NameID() .. ' for ' .. reason, {
			['Target Name'] 	= target:Name(),
			['Target SteamID']	= target:SteamID(),
			['Officer Name'] 	= officer:Name(),
			['Officer SteamID']	= officer:SteamID(),
		})
	end
end)

plogs.AddHook('playerUnWarranted', function(target, officer)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Полиция', officer:NameID() .. ' unwarranted ' .. target:NameID(), {
			['Target Name'] 	= target:Name(),
			['Target SteamID']	= target:SteamID(),
			['Officer Name'] 	= officer:Name(),
			['Officer SteamID']	= officer:SteamID(),
		})
	else
		plogs.Log('Полиция', target:NameID() .. '\'s warrant has expired', {
			['Name'] 	= target:Name(),
			['SteamID']	= target:SteamID(),
		})
	end
end)


-- Purchases
plogs.Register('Покупки', false)

plogs.AddHook('PlayerBoughtItem', function(pl, name, price, newcash)
	plogs.PlayerLog(pl, 'Покупки', pl:NameID() .. ' придбав ' .. name .. ' за $' .. price .. ' (Нова сума грошей: $' .. newcash .. ')', {
		['Name'] 	= pl:Name(),
		['SteamID']	= pl:SteamID()
	})
end)

-- Raids
plogs.Register('Рейди', false)

plogs.AddHook('PlayerPlaceC4', function(pl, ent)
	if IsValid(ent) then
		local owner = ent:CPPIGetOwner() or ent.ItemOwner or ent:DoorGetOwner()
		if IsValid(owner) then
			plogs.PlayerLog(pl, 'Рейди', Format('%s(%s) поставив c4 на %s, що належить %s(%s)', pl:Name(), pl:SteamID(), ent:GetClass(), owner:Name(), owner:SteamID()), {
				['Name'] 	= pl:Name(),
				['SteamID']	= pl:SteamID()
			})
		else
			plogs.PlayerLog(pl, 'Рейди', Format('%s(%s) поставив c4 на %s', pl:Name(), pl:SteamID(), ent:GetClass()), {
				['Name'] 	= pl:Name(),
				['SteamID']	= pl:SteamID()
			})
		end
	else
		plogs.PlayerLog(pl, 'Рейди', Format('%s(%s) випустив c4', pl:Name(), pl:SteamID()), {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID()
		})
	end
end)

plogs.AddHook('PlayerStartKeypadCrack', function(pl, ent)
	plogs.PlayerLog(pl, 'Рейди', Format('%s(%s) почав зламувати keypad, що належить %s(%s)', pl:Name(), pl:SteamID(), ent:CPPIGetOwner():Name(), ent:CPPIGetOwner():SteamID()), {
		['Name'] 	= pl:Name(),
		['SteamID']	= pl:SteamID()
	})
end)

plogs.AddHook('PlayerFinishKeypadCrack', function(pl, ent)
	plogs.PlayerLog(pl, 'Рейди', Format('%s(%s) закінчив злом keypad, що належить %s(%s)', pl:Name(), pl:SteamID(), ent:CPPIGetOwner():Name(), ent:CPPIGetOwner():SteamID()), {
		['Name'] 	= pl:Name(),
		['SteamID']	= pl:SteamID()
	})
end)

plogs.AddHook('PlayerStartLockpicking', function(pl, ent)
	if IsValid(ent:DoorGetOwner()) then
		plogs.PlayerLog(pl, 'Рейди', Format('%s(%s) почав злом дверей, що належать %s(%s)', pl:Name(), pl:SteamID(), ent:DoorGetOwner():Name(), ent:DoorGetOwner():SteamID()), {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID()
		})
	else
		plogs.PlayerLog(pl, 'Рейди', Format('%s(%s) почав злом дверей, що належать %s', pl:Name(), pl:SteamID(), (ent:DoorGetGroup() or team.GetName(ent:DoorGetTeam()))), {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID()
		})
	end
end)

plogs.AddHook('PlayerFinishLockpicking', function(pl, ent)
	if IsValid(ent:DoorGetOwner()) then
		plogs.PlayerLog(pl, 'Рейди', Format('%s(%s) завершив злом дверей, які належать %s(%s)', pl:Name(), pl:SteamID(), ent:DoorGetOwner():Name(), ent:DoorGetOwner():SteamID()), {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID()
		})
	else
		plogs.PlayerLog(pl, 'Рейди', Format('%s(%s) закінчив злом дверей, що належать %s', pl:Name(), pl:SteamID(), (ent:DoorGetGroup() or team.GetName(ent:DoorGetTeam()))), {
			['Name'] 	= pl:Name(),
			['SteamID']	= pl:SteamID()
		})
	end
end)


-- Door buys
plogs.Register('Двери', false)

plogs.AddHook('playerBoughtDoor', function(pl, ent, cost)
	plogs.PlayerLog(pl, 'Двери', pl:NameID() .. ' купил дверь за $' .. cost, {
		['Name'] 	= pl:Name(),
		['SteamID']	= pl:SteamID()
	})
end)

plogs.AddHook('playerSellDoor', function(pl, ent)
	plogs.PlayerLog(pl, 'Двери', pl:NameID() .. ' продал дверь', {
		['Name'] 	= pl:Name(),
		['SteamID']	= pl:SteamID()
	})
end)
--PATH addons/____esclib/lua/elib/essentials/libs/esc_files.lua:
esclib.file = {}

local function Split(istring,sep)
	local sep = sep or "%s"
    local t={}
    for str in string.gmatch(istring, "([^"..sep.."]+)") do
        table.insert(t, str)
    end
    return t
end

function esclib.file:NameFromPath(path)
    local _, startIndex = path:find("[^/\\]*$")
    if startIndex then
        return path:sub(startIndex)
    end
    return path
end

function esclib.file:MakeIfNotExists(file_name)
	if file.Exists(file_name, "DATA") then return end
	local files = Split(file_name,"/")
	local o_file_name = ""
	if #files > 1 then
		o_file_name = files[1]
		for i=2,#files-1 do
			o_file_name = o_file_name.."/"..files[i]
		end
		file.CreateDir( o_file_name )
		o_file_name = o_file_name.."/"..files[#files]
		file.Write(o_file_name,"")

		return true
	elseif #files == 0 then
		return false
	end
end

function esclib.file:MakeDirectoriesIfNotExists(path)
    if not file.Exists(path, "DATA") then
        local folders = string.Explode("/", path)
        local currentPath = ""

        for _, folder in ipairs(folders) do
            currentPath = currentPath == "" and folder or currentPath .. "/" .. folder

            if not file.Exists(currentPath, "DATA") then
                file.CreateDir(currentPath)
            end
        end

        return true
    end

    return false
end



--EXAMPLE:
-- esclib.file:SaveVar("ehud/savedvars.txt",{["hello"]={"214151","215161664",""}})
-- print(esclib.file:ReadVar("ehud/savedvars.txt","hello"))

function esclib.file:SaveVar(file_name,content)
	esclib.file:MakeIfNotExists(file_name)

	local filecontent = file.Read(file_name,"DATA")
	if filecontent then
		filecontent = util.JSONToTable(filecontent) or {}
	else
		filecontent = {}
	end

	if istable(content) then
		if not table.IsEmpty(filecontent) then
			esclib:SafeMerge(filecontent,content, true)
		else
			filecontent = content
		end
	else
		table.insert(filecontent,content)
	end

	file.Write(file_name,util.TableToJSON(filecontent))
end

function esclib.file:ReadVar(file_name, var)
	local filecontent = file.Read(file_name,"DATA")
	if filecontent then
		local content = util.JSONToTable(filecontent) or {}
		if var then
			return content[var]
		else
			return content
		end
	else
		return
	end
end

function esclib.file:Remove(file_name)
	print("[esclib] Removing file/dir [".. file_name .. "] from DATA folder.")
	file.Delete(file_name)
end

function esclib.file:RemoveFolder(path, recurse)
	if not file.Exists(path, "DATA") then return end
	local files, directories = file.Find( path.."/*", "DATA" )
	
	for _, ffile in ipairs(files) do
		self:Remove(path.."/"..ffile)
	end

	if recurse ~= false then
		for _, fdir in ipairs(directories) do
			self:RemoveFolder(path.."/"..fdir)
			self:Remove(path.."/"..fdir)
		end
	end

	self:Remove(path)
end
--PATH addons/____esclib/lua/elib/vgui/esc_circle_avatar.lua:
local cos, sin, rad, floor = math.cos, math.sin, math.rad, math.floor

local PANEL = {}

AccessorFunc(PANEL, "poly_count", "PolyCount")
 
function PANEL:Init()
    self.Avatar = vgui.Create("AvatarImage", self)
    self.Avatar:SetPaintedManually(true)

    self:SetPolyCount(16)
end

function PANEL:MakeCirclePoly( x, y, r )
    local circle = {}

    local count = self.poly_count
    for i = 1, count do
        circle[i] = {}
        circle[i].x = x + cos(rad(i * 360) / count) * r
        circle[i].y = y + sin(rad(i * 360) / count) * r
    end

    return circle
end

function PANEL:SetPolyCount(count)
    self.poly_count = count
    self:PerformLayout()
end
 
function PANEL:PerformLayout()
    self:OnSizeChanged(self:GetWide(), self:GetTall())
end
 
function PANEL:SetSteamID(...)
    self.Avatar:SetSteamID(...)
end
 
function PANEL:SetPlayer(...)
    self.Avatar:SetPlayer(...)
end
 
function PANEL:OnSizeChanged(w, h)
    self.Avatar:SetSize(self:GetWide(), self:GetTall())
    self.poly = self:MakeCirclePoly(floor(self:GetWide()*0.5), floor(self:GetTall()*0.5), floor(self:GetWide()*0.5))
end
 
function PANEL:DrawMask(w, h)
    draw.NoTexture();
    surface.SetDrawColor( color_white )
    surface.DrawPoly( self.poly )
end

function PANEL:DrawBackground(w,h)
    --for override
end
 
function PANEL:Paint(w, h)
    self:DrawBackground(w,h)

    render.ClearStencil()
    render.SetStencilEnable(true)
    render.SetStencilWriteMask( 1 )
    render.SetStencilTestMask( 1 )
 
    render.SetStencilFailOperation( STENCILOPERATION_REPLACE )
    render.SetStencilPassOperation( STENCILOPERATION_ZERO )
    render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )
    render.SetStencilReferenceValue( 1 )
    self:DrawMask(w, h)

    render.SetStencilFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
    render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
    render.SetStencilReferenceValue( 1 )
 
    self.Avatar:SetPaintedManually(false)
    self.Avatar:PaintManual()
    self.Avatar:SetPaintedManually(true)
    render.SetStencilEnable(false)
 
    render.ClearStencil()
 
end

vgui.Register("esclib.circle_avatar", PANEL)
--PATH addons/____esclib/lua/elib/vgui/esc_dragbase.lua:
local PANEL={}

AccessorFunc( PANEL, "m_bDraggable",		"Draggable",		FORCE_BOOL )
AccessorFunc( PANEL, "m_bScreenLock",		"ScreenLock",		FORCE_BOOL )
AccessorFunc( PANEL, "m_bSizable",			"Sizable",			FORCE_BOOL )

AccessorFunc( PANEL, "m_iMinWidth",			"MinWidth",			FORCE_NUMBER )
AccessorFunc( PANEL, "m_iMinHeight",		"MinHeight",		FORCE_NUMBER )

function PANEL:Init()
	self:SetSize(400,400)
	self.dragarea = { x=0, y=0, w=self:GetWide(), h=self:GetTall()}

	self:SetDraggable( true )
	self:SetSizable( false )
	self:SetMinWidth( 100 )
	self:SetMinHeight( 50 )
	self:SetScreenLock( false )
end

function PANEL:IsMouseInDragArea()
    local x, y = self:LocalToScreen(0, 0)
    local mx, my = gui.MousePos()

    return mx >= x + self.dragarea.x 
    and my >= y + self.dragarea.y 
    and mx < x + self.dragarea.x + self.dragarea.w 
    and my < y + self.dragarea.y + self.dragarea.h
end

function PANEL:IsMouseInSizeArea()
	local screenX, screenY = self:LocalToScreen( 0, 0 )
	return gui.MouseX() > ( screenX + self:GetWide() - 20 ) && gui.MouseY() > ( screenY + self:GetTall() - 20 )
end

--MOUSE DRAGGING
function PANEL:OnMousePressed()
	self:OnPress()
	local screenX, screenY = self:LocalToScreen( 0, 0 )
	if ( self.m_bSizable && self:IsMouseInSizeArea() ) then
		self.Sizing = { gui.MouseX() - self:GetWide(), gui.MouseY() - self:GetTall() }
		self:MouseCapture( true )
		return
	end

	--if ( self:GetDraggable() && gui.MouseY() < ( screenY + 24 ) ) then
	if ( self:GetDraggable() && self:IsMouseInDragArea()) then
		self.Dragging = { gui.MouseX() - self.x, gui.MouseY() - self.y }
		self:MouseCapture( true )
		self:OnStartDragging(self:GetX(),self:GetY())
		return
	end
end

function PANEL:OnMouseReleased()
	self:OnUnpress()
	if self.Dragging then
		self.Dragging = nil
		self:OnEndDragging(self:GetX(),self:GetY())
	end
	if self.Sizing then
		self.Sizing = nil
		self:InvalidateChildren(true)
		self:OnEndSizing(self:GetWide(),self:GetTall())
	end
	self:MouseCapture( false )
end

function PANEL:SetDragArea(x,y,w,h)
	self.dragarea.x = x
	self.dragarea.y = y
	self.dragarea.w = w
	self.dragarea.h = h
end

function PANEL:OnDragging(newx,newy)
	--for override
end

function PANEL:OnSizing(neww,newh)
	--for override
end

function PANEL:OnStartDragging(x,y)
	--for override
end

function PANEL:OnEndDragging(newx,newy)
	--for override
end

function PANEL:UpdateDragArea()
	self.dragarea = { x=0, y=0, w=self:GetWide(), h=self:GetTall()}
end

function PANEL:OnEndSizing(neww, newh)
	--for override
	self:UpdateDragArea()
end

function PANEL:OnPress()
	--for override
end

function PANEL:OnUnpress()
	--for override
end

function PANEL:Think()

	local mousex = math.Clamp( gui.MouseX(), 1, esclib.scrw - 1 )
	local mousey = math.Clamp( gui.MouseY(), 1, esclib.scrh - 1 )

	if ( self.Dragging ) then

		local x = mousex - self.Dragging[1]
		local y = mousey - self.Dragging[2]

		-- Lock to screen bounds if screenlock is enabled
		if ( self:GetScreenLock() ) then

			x = math.Clamp( x, 0, esclib.scrw - self:GetWide() )
			y = math.Clamp( y, 0, esclib.scrh - self:GetTall() )

		end

		self:OnDragging(newx,newy)
		self:SetPos( x, y )

	end

	if ( self.Sizing ) then

		local x = mousex - self.Sizing[1]
		local y = mousey - self.Sizing[2]
		local px, py = self:GetPos()

		if ( x < self.m_iMinWidth ) then x = self.m_iMinWidth elseif ( x > esclib.scrw - px && self:GetScreenLock() ) then x = esclib.scrw - px end
		if ( y < self.m_iMinHeight ) then y = self.m_iMinHeight elseif ( y > esclib.scrh - py && self:GetScreenLock() ) then y = esclib.scrh - py end

		self:OnSizing(x,y)
		self:SetSize( x, y )
		return

	end

	local screenX, screenY = self:LocalToScreen( 0, 0 )
	if ( self.Hovered && self.m_bSizable && mousex > ( screenX + self:GetWide() - 20 ) && mousey > ( screenY + self:GetTall() - 20 ) ) then
		self:SetCursor( "sizenwse" )
		return
	end

	--if ( self.Hovered && self:GetDraggable() && mousey < ( screenY + 24 ) ) then
	if ( self.Hovered && self:GetDraggable() && self:IsMouseInDragArea() ) then
		self:SetCursor( "sizeall" )
		return
	end

	self:SetCursor( "arrow" )

	if ( self.y < 0 ) then
		self:SetPos( self.x, 0 )
	end

end

function PANEL:Paint(w,h)
	--for rewrite
end

vgui.Register( "esclib.dragbase", PANEL, "EditablePanel" );
--PATH addons/____esclib/lua/elib/vgui/esc_dropdown.lua:
local accessor_fn = esclib.accessor
local PANEL = {}

accessor_fn(PANEL, "value", "Value", "SetValue", "string")
accessor_fn(PANEL, "values", "Values", {}, "table")
accessor_fn(PANEL, "opened", "Opened", false, "boolean")

function PANEL:Init()
    self.colors = esclib.addon:GetColors()

    accessor_fn(self, "font", "Font", esclib:AdaptiveFont("esclib", 20, 500), "string")
    accessor_fn(self, "IconFont", "IconFont", esclib:AdaptiveFont("esclib", 12, 500), "string")
    accessor_fn(self, "TextColor", "TextColor", self.colors.button.text)
    accessor_fn(self, "TextColorHover", "TextColorHover", self.colors.button.text_hover)
    accessor_fn(self, "BackgroundColor", "BackgroundColor", self.colors.button.main)
    accessor_fn(self, "BackgroundColorHover", "BackgroundColorHover", self.colors.button.hover)
    accessor_fn(self, "context_parent", "ContextParent", self:GetParent())


    self.offset_x = esclib:AdaptiveSize(10)
    self:SetWide(100)
    self:SetTall(draw.GetFontHeight(self.font)+10)
    self:SetText("")
end

function PANEL:DoClick()
    local bg = IsValid(self.context_parent) and self.context_parent or self:GetParent()
    self:SetOpened(true)
    --Context
    local context = vgui.Create("esclib.contextmenu", bg)
    context:SetColor(self.BackgroundColor)
    context:SetBorderColor(self.BackgroundColorHover)
    local x,y = self:LocalToScreen(0,self:GetTall())
    context:SetPosClamped(x, y)
    context:SetBorder(0)
    context:SetEnableLayouting(false)

    function context.OnClose(pnl)
        if not IsValid(self) then return end
        self:SetOpened(false)
    end

    function context.Paint(pnl,w,h)
        if not IsValid(self) then pnl:Remove() return end
        draw.RoundedBoxEx(8,0,0,w,h,self.BackgroundColorHover, false, false, true, true)
        draw.RoundedBoxEx(6,2,2,w-4,h-4,self.BackgroundColor, false, false, true, true)
    end

    self.context = context

    for _,v in ipairs(self.values) do
        local btn = context:AddButton(v, function()
            self:SetValue(v)
        end)
        btn:SetFont(self.font)
        btn:SetTextColor(self.TextColor)
        btn:SetColor(self.BackgroundColor)
        btn:SetColorHover(self.BackgroundColorHover)
        btn:SetWide(self:GetWide())
    end


    context:SetWide(self:GetWide() - context.list:GetBorder()*2)
    self:OnClick(context)
    return context
end

function PANEL:OnClick(context)
    --For override
end

function PANEL:OnValueChanged(value)
    --For override
end

function PANEL:SetValue(value)
    self.value = value
    self:OnValueChanged(value)
end

function PANEL:IsOpened()
    return self.opened
end

function PANEL:Paint(w,h)
    local hovered = self:IsHovered()
    draw.RoundedBoxEx(8, 0, 0, w, h, self.BackgroundColorHover, true, true, not self.opened, not self.opened)
    draw.RoundedBoxEx(6,2,2,w-4,h-(self.opened and 0 or 4), hovered and self.BackgroundColorHover or self.BackgroundColor, true, true, not self.opened, not self.opened)

    draw.SimpleText(self.value, self.font, self.offset_x, h*0.5, hovered and self.TextColorHover or self.TextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    draw.SimpleText(self:IsOpened() and "▲" or "▼", self.IconFont, w-self.offset_x, h*0.5-1, hovered and self.TextColorHover or self.TextColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
end

function PANEL:SizeToContents()
    self:SetTall(draw.GetFontHeight(self.font)+10)

    local max_width = 0
    for _,v in ipairs(self.values) do
        local w,h = esclib.util:TextSize(v, self.font)
        if w > max_width then max_width = w end
    end
    self:SetWide(max_width+self.offset_x*4)
end

vgui.Register("esclib.dropdown", PANEL, "DButton")
--PATH addons/____esclib/lua/elib/essentials/settings_menu/settings_types/esc_type_float.lua:
local draw_bg = esclib.settings_shared_funcs.draw_bg
local VarsIsEqual = esclib.settings_shared_funcs.VarsIsEqual
local SharedDoRightClick = esclib.settings_shared_funcs.SharedDoRightClick

-------------
--# FLOAT #--
-------------
local stype = esclib:RegisterSettingsType("float")
stype:Require("value")
stype:SoftRequire("min")
stype:SoftRequire("max")
function stype:Build( parent )
	local addon     = parent.addon
	local varid     = parent.var_uid
	local varc      = parent.var
	local callback  = parent.ApplyValue
	local varc_copy = parent.initial_values
	local settab    = parent.bg
	local def_val   = parent.default_value

	local button_wide = parent:GetWide()
	local button_tall = parent:GetTall()

	local clr = esclib.addon:GetColors()
	local name_tr  = varc.name or addon:Translate(varc.name_tr)
	local desc = varc.desc or addon:Translate(varc.desc_tr)

	local font = esclib:AdaptiveFont("esclib", 20, 500)
	local font2 = esclib:AdaptiveFont("esclib", 16, 500)
	local name = esclib.util:TextCutAccurate(name_tr, font, button_wide*0.8, "...")
	-- local desc_text = esclib.util:TextCutAccurate(desc or "", font2, button_wide*0.8, "...")

	local button = parent:Add("DButton")
	button:SetSize(button_wide, button_tall)
	button:SetText("")
	if desc then
		local added = ""
		if varc.max or varc.min then
			added = "("..(varc.min or "∞").." - "..(varc.max or "∞")..")\n"
		end
		button:eAddHint(added.." "..desc,font,TEXT_ALIGN_CENTER,settab)
	end

	function button:DoClick()
		local text_input = esclib:TextInputWindow(esclib.addon:Translate("window_ValueEdit"), (addon:Translate(varc.name_tr) or varc.name).." ("..varc.value..")",false,true,function(res)
			if not res then return end
			if res == 0 then return end
			if varc.max and varc.min then
				res = math.Clamp(res, varc.min, varc.max)
			elseif varc.max then
				res = math.Clamp(res, -math.huge, varc.max)
			elseif varc.min then
				res = math.Clamp(res, varc.min, math.huge)
			end
				
			varc.value = res
			callback(varid,varc.value)
		end)
		text_input:SetValue(varc.value)
	end

	button.DoRightClick = function(self) SharedDoRightClick(self, settab, name_tr, addon, varid, varc, def_val, callback) end

	local wrench_mat = esclib:GetMaterial("wrench.png")
	local offset_x = 10.0
	function button:Paint(w,h)
		local hovered = self:IsHovered()
		local is_changed = varc.value ~= varc_copy[varid]
		draw_bg(w,h,hovered,clr, is_changed)

		if hovered then
			offset_x = Lerp(0.1, offset_x, h)
			esclib.draw:MaterialCentered(offset_x-h*0.5, h*0.5, h*0.25, clr.button.text, wrench_mat)
		else
			offset_x = Lerp(0.1, offset_x, 10.0)
		end

		if desc then
			draw.SimpleText(name,font,offset_x,h*0.2,clr.button.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_TOP)
			local desc_text = esclib.util:TextCut(desc or "", font2, w*0.8-offset_x, "...")
			draw.SimpleText(desc_text,font2,offset_x,h*0.85,clr.button.text_gray,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM)
		else
			draw.SimpleText(name,font,offset_x,h*0.5,clr.button.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)
		end
		draw.SimpleText(varc.value,font,w-15,h*0.5,clr.button.accent,TEXT_ALIGN_RIGHT,TEXT_ALIGN_CENTER,1)
	end
end
--PATH addons/____esclib/lua/elib/essentials/settings_menu/esc_settings_wrapper.lua:
local function Capitalize(str)
	return (str:gsub("^%l", string.upper))
end

-----------------
--# VARS META #--
-----------------
local VarsMeta = {}
VarsMeta.__index = VarsMeta
function VarsMeta:Set(param, value)
	if param == nil or value == nil then return end
	self[param] = value
	return self
end

function VarsMeta:SetName(value)
	self:Set("name", value)
	return self
end

function VarsMeta:SetDesc(value)
	self:Set("desc", value)
	return self
end

function VarsMeta:SetNameTranslateKey(value)
	self:Set("name_tr", value)
	return self
end

function VarsMeta:SetDescTranslateKey(value)
	self:Set("desc_tr", value)
	return self
end

function VarsMeta:SetPosition(value)
	self:Set("sortOrder", value)
	return self
end

function VarsMeta:SetShared(value)
	if CLIENT then return self end --do nothing on client
	self:Set("shared", value)
	return self
end

--Do nothing, just for support
function VarsMeta:RestartAddon(value)
	self:Set("restart_addon", value)
	return self
end

function VarsMeta:CustomCheck(fun)
	self:Set("customCheck", fun)
	return self
end

function VarsMeta:CanChange(change_type, change_who)
	local fun

	if type(change_type) == "boolean" then
		fun = function() return change_type or esclib:HasAdminAccess(LocalPlayer()) end
		self:Set("change_type",'boolean')
		self:Set("who_can_change",change_type)
	elseif (change_type == "steamid") then
		if type(change_who) ~= "table" then change_who = {change_who} end
		fun = function()
			return change_who[LocalPlayer():SteamID()] or esclib:HasAdminAccess(LocalPlayer())
		end
		self:Set("change_type",'steamid')
		self:Set("who_can_change",change_who)
	elseif (change_type == "usergroup") then
		if type(change_who) ~= "table" then change_who = {change_who} end
		fun = function()
			return change_who[LocalPlayer():GetUserGroup()] or esclib:HasAdminAccess(LocalPlayer())
		end
		self:Set("change_type",'usergroup')
		self:Set("who_can_change",change_who)
	end

	self:Set("customCheck", fun)
	return self
end

esclib.VARS_META = VarsMeta

-----------------
--# TABS META #--
-----------------
local TabMeta = {}
TabMeta["__index"] = TabMeta
function TabMeta:Set(param, value)
	if param == nil or value == nil then return end
	self[param] = value
	return self
end

function TabMeta:SetName(value)
	self:Set("name", value)
	return self
end

function TabMeta:SetNameTranslateKey(value)
	self:Set("name_tr", value)
	return self
end

function TabMeta:SetPosition(value)
	self:Set("sortOrder", value)
	return self
end

function TabMeta:AddVar(var_uid, vtype)

	if self["vars"][var_uid] then
		print("[ESCLIB] [ERROR HELPER] This name is already exists, please take another one. Busy names:\n")
		for k,v in ipairs(table.GetKeys(vars)) do
			print(k,v)
		end
		print("\nStack trace: ")
		error("Not valid var name ("..tostring(var_uid)..")")
	end

	local stype = esclib.allowed_settings_types[vtype]
	if not stype then
		print("[ESCLIB] [ERROR HELPER] Valid types are:\n")
		for k,v in pairs(table.GetKeys(esclib.allowed_settings_types)) do
			print(k,v)
		end
		print("\nStack trace: ")
		error("Not valid var type ("..tostring(vtype)..")")
	end

	setmetatable(stype, VarsMeta)

	-- esclib:SafeMerge(stype, VarsMeta, true)

	self["vars"][var_uid] = {}
	self["vars"][var_uid]["type"] = vtype

	stype["__index"] = stype
	setmetatable(self["vars"][var_uid], stype)

	return self["vars"][var_uid]
end

function TabMeta:CustomCheck(fun)
	self:Set("customCheck", fun)
	return self
end

esclib.TAB_META = TabMeta


---------------------
--# SETTINGS META #--
---------------------
local settings_meta = {}
settings_meta["__index"] = settings_meta
function settings_meta:AddTab(uid)
	local uid = string.lower(uid)

	if self[uid] then
		print("[ESCLIB] [ERROR HELPER] This name is already exists, please take another one. Busy names:\n")
		for k,v in ipairs(table.GetKeys(self)) do
			print(k,v)
		end
		print("\nStack trace: ")
		error("Not valid tab name ("..tostring(uid)..")")
	end

	self[uid] = {
		["vars"] = {},
		["__realm"] = self.__realm
	}
	setmetatable(self[uid], TabMeta)

	return self[uid]
end

function settings_meta:Print()
	PrintTable(self)
end

function settings_meta:End()
	local add_name = self.__addon
	local addon = esclib:GetAddon(add_name)
	if not addon then return end
	local realm = self.__realm

	--check all
	for tab,tab_val in pairs(self) do
		local vars = tab_val["vars"]
		for varid,varc in pairs(vars) do
			for id,need in ipairs(esclib.allowed_settings_types[varc.type]["important_vars"]) do
				if varc[need] == nil then
					print("[ESCLIB] [ERROR HELPER] No important keys for "..varid.."! Needed keys:\n")
					for k,v in ipairs(esclib.allowed_settings_types[varc.type]["important_vars"]) do
						print(k,v)
					end
					print("\nStack trace: ")
					error(varid.." - not contains key ["..tostring(need).."]")
				end
			end
		end
	end

	if realm == "client" and CLIENT then --ONLY on client
		-- Init settings and load from file
		addon:RegisterSettings(self)
	elseif realm == "server" then --can be both
		addon:RegisterServerSettings(self)
	end
	
	if (CLIENT) then
		hook.Add("InitPostEntity",add_name.."_request_settings",function()
			addon:RequestSettings()
			hook.Remove("InitPostEntity",add_name.."_request_settings")
		end)
	end
end

---------------
--# WRAPPER #--
---------------
local all_realms = {
	["client"] = true,
	["server"] = true
}
function esclib:InitSettings(addon_uid, realm)
	realm = realm or "client"
	if not all_realms[realm] then
		print("[ESCLIB] [ERROR HELPER] invalid addon realm (Must be client or server)\n")
		error("Invalid addon realm ("..tostring(addon_uid)..")")
	end
	
	local addons = esclib:GetAddons()
	if not addons[addon_uid] then
		print("[ESCLIB] [ERROR HELPER] Addon uid not found. Available addons:\n")
		for k,v in ipairs(table.GetKeys(addons)) do
			print(k,v)
		end
		print("\nStack trace: ")
		error("Not valid addon uid ("..tostring(addon_uid)..")")
	end

	local addon_settings_meta = {}
	settings_meta["__addon"] = addon_uid
	settings_meta["__realm"] = realm

	setmetatable(addon_settings_meta,settings_meta)

	return addon_settings_meta
end
--PATH addons/____echat/lua/echat/vgui/echat_text_entry.lua:
local min = math.min
local max = math.max
local clamp = math.Clamp

local PANEL = {}

AccessorFunc(PANEL, "autocompletetext", "AutoCompleteText")

function PANEL:Init()
	self.clr = echat.addon:GetColors()
	self:SetHistoryEnabled(true)
	-- self:SetFont(echat:AdaptiveFont("echat", 20, 500))

	self.check_cooldown = 0

	self.oldcaret = 0
	self.oldstart = 0 --selection
	self.oldend = 0

	self.scroll = 0
	self.caretX = 0
	self.selStartX = 0
	self.selEndX = 0

	self.padding_left = 10
	self.padding_right = 10

	self.blink = true
	self.next_blink = 0

	self.text_width = 0
	self.text_height = 0
	self.text_len = 0

	local old_fontchange = self.SetFont
	function self:SetFont(font)
		old_fontchange(self,font)
		-- self:SetFontInternal(font)
	end

	self:SetUpdateOnType(true)
end

function PANEL:Paint(w,h)
	draw.RoundedBox(6,0,0,w,h,self.clr.main.text_entry)
	self:DrawTextEntryText(self.clr.main.text, self.clr.main.text_selection, self.clr.main.text )
	self:DrawAutocompleteHint(w,h)
end

function PANEL:Think()
	local caret_pos = self:GetCaretPos()
	if caret_pos ~= self.oldcaret then
		self:CalculateScroll()
		self.oldcaret = caret_pos
	end

	local start, stop = self:GetSelectedTextRange()
	if (start ~= stop) and ((self.oldstart ~= start) or (self.oldend ~= stop)) then
		local w,h = self:GetSize()
		local text = self:GetText()
		surface.SetFont(self:GetFont())

		self.selStartX = surface.GetTextSize(eutf8.sub(text, 0, start-1)) - self.scroll
	    self.selEndX = surface.GetTextSize(eutf8.sub(text, 0, stop-1)) - self.scroll

		self.oldstart = start
		self.oldend = stop

		if self.selStartX > w then
            self.selStartX = w
        end
        if self.selEndX < 0 then
            self.selEndX = 0
        end
	end
end


function PANEL:DrawAutocompleteHint(w,h)
	local text = self:GetValue()
    local font = self:GetFont()
	local caret_pos = self:GetCaretPos()
	local autocomplete = self:GetAutoCompleteText()
    if autocomplete && (caret_pos == #text) then
    	local text_w, text_h = esclib.util:TextSize(text, font)
		draw.SimpleText(autocomplete, font, text_w+5,  self.text_height+1, self.clr.main.text_gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
    end
end


--offset in px
function PANEL:GetCaretOffsetX()
	local pos = self:GetCaretPos()
	surface.SetFont(self:GetFont())
	local text = self:GetText()
	local tw, th = surface.GetTextSize(eutf8.sub(text,0,pos-1))
	local max_w, max_h = self:LocalToScreen(self:GetWide(),self:GetTall())
	return min(tw, max_w)
end

function PANEL:SendToChat()
	local text = self:GetText()

	if ( IsValid( self.Menu ) ) then
		self.Menu:Close()
		self:RequestFocus()
		return
	end

	self:FocusNext()
	self:OnEnter( self:GetText() )
	self.HistoryPos = 0

	if string.Trim( text ) ~= "" then -- if not empty string
		echat:SendMessageToServer(text)

		table.insert(self.History, text)

		timer.Simple(0,function() --gmod things
			self:SetText("")
		end)
	else
		timer.Simple(0,function() --gmod things
			self:SetText("")
		end)
	end
end

function PANEL:OnKeyCodeTyped( code )

	local ply = LocalPlayer()
	local text = self:GetText()
	local has_menu = IsValid( self.Menu)

	self:OnKeyCode( code )

	--if pressed space when menu is opened
	if code == KEY_SPACE && has_menu then
		self.Menu:Close()
		self:RequestFocus()
		self.HistoryPos = 0
		return true --prevent 
	end

	--arrows
	if (code == KEY_RIGHT || code == KEY_LEFT || code == KEY_ENTER) and has_menu then
		if has_menu then
			self.Menu:Close()
			self:RequestFocus()
			self.HistoryPos = 0
		end
	end

	--On enter
	if ( (not input.IsKeyDown(KEY_LSHIFT) and code == KEY_ENTER) and self:GetEnterAllowed() ) then
		if ( IsValid( self.Menu ) ) then
			self.Menu:Close()
			self:RequestFocus()
			return
		end

		local text = self:GetText()

		self:FocusNext()
		self:OnEnter( text )
		self.HistoryPos = 0

		table.insert(self.History, text)
		timer.Simple(0, function()
			self:SetText("")
		end)
	end

	--recalculate size
	timer.Simple(0, function()
		if IsValid(self) and self.CalculateParentSize then
			self:CalculateParentSize()
		end
	end)

	-- history related
	if ( self.m_bHistory || has_menu ) then

		if ( code == KEY_UP and (self:GetLineCount() < 2) ) then
			self.HistoryPos = self.HistoryPos - 1
			self:UpdateFromHistory()
		end

		if  ( (code == KEY_DOWN) and (self:GetLineCount() < 2) ) then
			self.HistoryPos = self.HistoryPos + 1
			self:UpdateFromHistory()
		end

		if (code == KEY_TAB) then
			self.HistoryPos = self.HistoryPos - 1
			self:UpdateFromHistory()
		end

		if code == KEY_TAB then return true end --prevent loose focus
	end
end

function PANEL:GetLineCount()
	local text = self:GetText()
	local count = 1
	for _ in string.gmatch(text, "\n") do
	    count = count + 1
	end
	return count
end
	
function PANEL:CalculateScroll()
	local w,h = self:GetSize()

	local font = self:GetFont()
	local text = self:GetText()

	local caret_pos = self:GetCaretPos()

	if text == "" then return end
	self.caretX = esclib.util:TextSize(eutf8.sub(text, 0, caret_pos-1),font)
	if self.caretX - self.scroll > w - self.padding_right then 
        self.scroll = self.caretX - (w - self.padding_right)
    elseif self.caretX - self.scroll < self.padding_left and self.scroll > 0 then
        self.scroll = self.caretX
    end
    self.caretX = self.caretX - self.scroll
end

function PANEL:CalculateParentSize()
	local lines = math.min(self:GetLineCount(), 3) --only to 3 lines up
	local font = self:GetFont()
	local fh = draw.GetFontHeight(font)
	local parent = self:GetParent()
	local px, py, pw, ph = parent:GetDockPadding()
	parent:SetTall(fh*lines+2 + py + ph)
	parent:InvalidateParent()
end

function PANEL:OnTextChanged( noMenuRemoval )
	
	self.HistoryPos = 0
	local text = self:GetText()

	if ( self:GetUpdateOnType() ) then
		self:UpdateConvarValue()
		self:OnValueChange( text )
	end

	if ( IsValid( self.Menu ) && not noMenuRemoval ) then
		self:SetAutoCompleteText(text)
		self.Menu:Remove()
	end

	local font = self:GetFont()
	local tw,th = esclib.util:TextSize(text, font)
	self.text_width = tw
	self.text_height = th
	self.text_len = #text

	local caret_pos = self:GetCaretPos()
	if caret_pos < 1 then
		caret_pos = utf8.len(text)
	end

	if text == "" then return end
	local subbed_text = eutf8.sub(text, 0, caret_pos-1) --perfomance +- friendly (utf8 suc s)
	
	local last_word = eutf8.getLastWord(subbed_text) or ""
	local tab = self:GetAutoComplete( text, last_word )
	if ( tab and istable(tab) and (#tab > 0)) then
		self:OpenAutoComplete( tab )

		local target = tab[1].text
		local offset = tab[1].offset or 0
		local target_len = utf8.len(target)
		local last_text_len = utf8.len(last_word)

		if last_text_len < target_len then
			local tail_auto_text = eutf8.sub(target, last_text_len+offset, target_len-1)
			self:SetAutoCompleteText(tail_auto_text)
		else
			self:SetAutoCompleteText("")
		end
	else
		self:SetAutoCompleteText("")
	end

	self:OnChange()

end

function PANEL:OpenAutoComplete( tab )

	if ( not tab ) then return end
	if ( #tab == 0 ) then return end

	self.Menu = vgui.Create("echat.menu")

	local font = self:GetFont()
	local count = self.Menu:ChildCount()
	local max_w = 50
	for i=1,#tab do
		local v = tab[i]
		local option = self.Menu:AddOption( v.text, function() 
			self:SetText( v.text ) 
			self:SetCaretPos( v.text:len() ) 
			self:RequestFocus() 
		end )
		option.command_data = v
		option.DoClick = function(pnl)
			self:UpdateFromMenu(i)
		end

		if v.icon then option:SetIcon(v.icon) end
		option:SetDescription(v.description or "")
		option:SetArgs(v.args)
		local tw = option:GetFullWide()
		if tw > max_w then
			max_w = tw
		end
	end

	local x, y = self:LocalToScreen( 0, 0 )
	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, true, self )
	self.Menu:SetMaxHeight( echat.chatbox:GetTall()*0.5 )
	self.Menu:SetPos( x, y-min(self.Menu:GetMaxHeight(), self.Menu:GetTall())+1 )
end

local function replace_last(str, replacement)
    local lastWord = str:match("[%S%p]+$") or ""
    local new_str = utf8.sub(str, 1, utf8.len(str) - utf8.len(lastWord))
    return new_str .. replacement
end

local function replaceWordAtCaret(str, replacement, caretPos)
	if str == "" then return replacement end
    local head = eutf8.sub(str, 0, caretPos-1)
    local tail = eutf8.sub(str, caretPos)

	head = replace_last(string.TrimRight(head), replacement)
	return head.." "..tail, utf8.len(head)+1
end

function PANEL:UpdateFromMenu(new_pos)

	local pos = new_pos or self.HistoryPos
	local num = self.Menu:ChildCount()

	self.Menu:ClearHighlights()

	if ( pos < 1 ) then pos = num end
	if ( pos > num ) then pos = 1 end

	local item = self.Menu:GetChild( pos )
	if ( not item ) then
		self:SetText( "" )
		self.HistoryPos = pos
		return
	end
	if item.command_data and item.command_data.type == "command" then
		self.command_data = item.command_data
	end

	self.Menu:HighlightItem( item )
	self.Menu:ScrollToChild( item )

	--replace last word
	local target = item:GetText()
	local current_text = self:GetText()
	local target_len = #target
	local current_text_len = #current_text

	if self.Menu:ChildCount() < 2 then
		self.Menu:Close()
	end

	local replaced_text, replaced_text_len = replaceWordAtCaret(string.Trim(current_text, " "), target, self:GetCaretPos())
	self:SetText(replaced_text)
	self:SetCaretPos(self:GetCaretPos()+replaced_text_len)

	self:OnTextChanged(true)
	self.HistoryPos = pos

	self:SetAutoCompleteText("")
end



function PANEL:UpdateFromHistory()

	if ( IsValid( self.Menu ) ) then
		return self:UpdateFromMenu()
	end

	local pos = self.HistoryPos
	-- Is the Pos within bounds?
	if #self.History < 1 then return end
	if ( pos < 0 ) then pos = #self.History end
	if ( pos > #self.History ) then pos = 0 end

	local text = self.History[ pos ]
	if ( not text ) then text = "" end

	self:SetText( text )
	self:SetCaretPos( text:len() )

	self:OnTextChanged()

	self.HistoryPos = pos

end

vgui.Register("echat.textentry", PANEL, "DTextEntry")
--PATH addons/____echat/lua/echat/core/tools/fonts.lua:
local floor = math.floor

--Register font here

echat.font = "Inter" --name from font file
echat.monofont = "Roboto Mono" --name from font file

local current_fontname = "echat"
echat.fonts = echat.fonts or {}
echat.font_exist = echat.font_exist or {}

function echat:GetFonts()
    return echat.fonts
end

local function register_fontname(name)
    if CLIENT then esclib:SetFontName(name) end
    current_fontname = name
end

local function register_font(size, weight)
    if CLIENT then esclib:Font(size,weight) end --register font on client. Font will not be registered if exists
    local name = "es_"..current_fontname.."_"..size.."_"..weight
    if not echat.font_exist[name] then
        table.insert(echat.fonts, name)
        echat.font_exist[name] = true
    end
    return name
end

local function set_font(name) --does nothing on server
    if CLIENT then return esclib:SetFont(name) end
end

function echat:AdaptiveSize(base_size, screen_base)
	local base_size = base_size or 18
	local base_scrh = screen_base or 1080
	local dif = ScrH() / base_scrh

	return floor(base_size * dif)+1
end

function echat:AdaptiveFont(name, base_size, weight)
    register_fontname(name)
    set_font(echat.font)
    return register_font(echat:AdaptiveSize(base_size), weight)
end

function echat:AdaptiveMonoFont(name, base_size, weight)
    register_fontname(name)
    set_font(echat.monofont)
    return register_font(echat:AdaptiveSize(base_size), weight)
end

-------------
--- FONTS ---
-------------
--static fonts for <font> modifier
register_fontname("echat")
set_font(echat.font)
register_font(12,500) --"es_echat_12_500"
register_font(14,500)
register_font(16,500)
register_font(18,500)
register_font(20,500)
register_font(30,500)

register_fontname("echatmono")
set_font(echat.monofont)
register_font(12,500) --"es_echatmono_12_500"
register_font(14,500)
register_font(16,500)
register_font(18,500)
register_font(20,500)
register_font(30,500)
--PATH addons/____echat/lua/echat/core/modules/darkrp_overrides.lua:
local format = string.format

--------------------------------
--# REWRITE DARKRP FUNCTIONS #--
--------------------------------
--If you are using a different game mode, don't worry - this code won't cause any errors
local function RewriteDarkRP(bg)
    if not DarkRP then return end

    if echat.config.advert_command["enabled"] then
        DarkRP.declareChatCommand({
            command = "advert",
            description = "Displays an advertisement to everyone in chat.",
            delay = 1.5
        })

        if CLIENT then DarkRP.addChatReceiver("/advert", "advertise", function(ply) return true end) end
    end

    if SERVER then

        --part1: text without access check
        --part2: text with check
        --example of usage:
        -- HalfParse(ply, "[OOC] (superadmin) onexev: ", "text from onexev <clr:blue> text")
        local function HalfParse(ply, part1, part2, inverse)            
            local parsed_tags = echat:ParseText(echat:FinalParse(part1), inverse and ply or nil)
            local parsed_text = echat:ParseText(part2, (not inverse) and ply or nil)
            return table.Add(parsed_tags, parsed_text)
        end

        --https://github.com/FPtje/DarkRP/blob/a3bb21aad0a885b8d87ac5c7da00f772c4e2021f/gamemode/modules/base/sv_util.lua
        function DarkRP.talkToRange(ply, PlayerName, Message, size, default_parse)
            local ents = player.GetHumans()
            local col = team.GetColor(ply:Team())
            local filter = {}

            local plyPos = ply:EyePos()
            local sizeSqr = size * size
        
            for _, v in ipairs(ents) do
                if (v:EyePos():DistToSqr(plyPos) <= sizeSqr) and (v == ply or hook.Run("PlayerCanSeePlayersChat", PlayerName .. ": " .. Message, false, v, ply) ~= false) then
                    table.insert(filter, v)
                end
            end

            if default_parse then
                if Message ~= "" and PlayerName ~= "" then 
                    Message = ": "..Message
                end
                
                local str_without_msg = echat:FinalParse(color_white, PlayerName, Message)
                echat:SendParsedMessageToPlayer(ply, filter, echat:ParseText(str_without_msg), Message)
            else
                local prefix_text = ""
                if PlayerName ~= "" then
                    local expl = string.Explode(" ", PlayerName) --we dont need name, only prefix (ooc / pm etc)
                    prefix_text = expl[1] or ""
                end

                if prefix_text ~= "" and string.StartsWith(ply:Nick() or "", prefix_text) then
                    prefix_text = ""
                else
                    prefix_text = prefix_text.." "
                end

                local str_without_msg = echat:FinalParse(col, prefix_text, ply, color_white, ": ")
                local parsed_tags = echat:ParseText(str_without_msg) --we dont need to parse tags with checks from server
                local parsed_message = echat:ParseText(Message, ply) --parse message with checks
                local result = table.Add(parsed_tags, parsed_message)

                echat:SendParsedMessageToPlayer(ply, filter, result, Message)
            end
        end
        
        function DarkRP.talkToPerson(receiver, col1, prefixText, col2, text2, sender)
            if not IsValid(receiver) then return end
            if receiver:IsBot() then return end

            local concatenatedText = (prefixText or "") .. ": " .. (text2 or "")
            
            if sender == receiver or hook.Run("PlayerCanSeePlayersChat", concatenatedText, false, receiver, sender) ~= false then
                sender = sender or Entity(0)
                
                local str_without_msg = echat:FinalParse(col1, prefixText, prefixText != "" and ": " or "", col2 or color_black, text2)
                local result = echat:ParseText(str_without_msg)

                echat:SendParsedMessageToPlayer(sender, receiver, result, text2)
            end
        end


        ----------
        --# ME #--
        ----------
        --override default me function
        local function Me(ply, args)
            if args == "" then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("invalid_x", DarkRP.getPhrase("arguments"), ""))
                return ""
            end
        
            local DoSay = function(text)
                if text == "" then
                    DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("invalid_x", DarkRP.getPhrase("arguments"), ""))
                    return ""
                end
                if GAMEMODE.Config.alltalk then
                    local col = team.GetColor(ply:Team())
                    local name = ply:Nick()
                    for _, target in ipairs(player.GetAll()) do
                        DarkRP.talkToPerson(target, col, name .. " " .. text)
                    end
                else
                    local format_str = echat.config.me_command["format"]
                    local text = esclib.text:KeyFormat(format_str, {
                        ["nick"] = ply:Nick() or "???",
                        ["text"] = text or "",
                    })
                    DarkRP.talkToRange(ply, "", text, GAMEMODE.Config.meDistance, true)
                end
            end
            return args, DoSay
        end
        if echat.config.me_command["enabled"] then
            DarkRP.defineChatCommand("me", Me, 1.5)
        end

        ----------
        --# PM #--
        ----------
        --override default PM function
        local function PM(ply, args)
            local namepos = string.find(args, " ")
            if not namepos then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("invalid_x", DarkRP.getPhrase("arguments"), ""))
                return ""
            end
        
            local name = string.sub(args, 1, namepos - 1)
            local msg = string.sub(args, namepos + 1)
        
            if msg == "" then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("invalid_x", DarkRP.getPhrase("arguments"), ""))
                return ""
            end
        
            local target = DarkRP.findPlayer(name)
            if target == ply then return "" end
        
            if target then
                local col = team.GetColor(ply:Team())
                local pname = ply:Nick()
                local col2 = color_white

                local out_format = echat.config.pm_command["sender"]["format"]
                local in_format = echat.config.pm_command["reciever"]["format"]

                local to_parse = {
                    ["from"] = echat:ParseVararg(ply) or "???",
                    ["to"] = echat:ParseVararg(target) or "???",
                    ["from_nick"] = ply:Nick(),
                    ["to_nick"] = target:Nick(),
                }

                local out_text = esclib.text:KeyFormat(out_format, to_parse)
                local in_text = esclib.text:KeyFormat(in_format, to_parse)

                local recievers = player.GetAll()
                echat:SendParsedMessageToPlayer(ply, target, HalfParse(ply, in_text, msg), msg)
                echat:SendParsedMessageToPlayer(ply, ply, HalfParse(ply, out_text, msg), msg)
            else
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("could_not_find", tostring(name)))
            end
        
            return ""
        end
        if echat.config.pm_command["enabled"] then
            DarkRP.defineChatCommand("pm", PM, 1.5)
        end

        -----------
        --# OOC #--
        -----------
        local function OOC(ply, args)
            if not GAMEMODE.Config.ooc then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("disabled", DarkRP.getPhrase("ooc"), ""))
                return ""
            end

            local rgb_ref = echat.COMMAND_BRACKET_1.."rgb:%d,%d,%d,%d"..echat.COMMAND_BRACKET_2
        
            local DoSay = function(text)
                if text == "" then
                    DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("invalid_x", DarkRP.getPhrase("arguments"), ""))
                    return ""
                end

                local col = team.GetColor(ply:Team())
                team_clr = format(rgb_ref, col.r, col.g, col.b, col.a)

                local tags = esclib.text:KeyFormat(echat.config.ooc_command["format"], {
                    ["jobclr"] = team_clr,
                    ["ply"] = echat:ParseVararg(ply) or "???",
                    ["ply_nick"] = ply:Nick(),
                    ["steamid"] = ply:SteamID(),
                    ["steamid64"] = ply:SteamID64()
                })

                local recievers = player.GetAll()
                echat:SendParsedMessageToPlayer(ply, recievers, HalfParse(ply, tags, text), text)
            end
            return args, DoSay
        end

        if echat.config.ooc_command["enabled"] then
            DarkRP.defineChatCommand("/", OOC, true, 1.5)
            DarkRP.defineChatCommand("a", OOC, true, 1.5)
            DarkRP.defineChatCommand("ooc", OOC, true, 1.5)
        end


        --------------
        --# ADVERT #--
        --------------
        local function Advert(ply, args)
            if args == "" then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("invalid_x", "argument", ""))
                return ""
            end

            local rgb_ref = echat.COMMAND_BRACKET_1.."rgb:%d,%d,%d,%d"..echat.COMMAND_BRACKET_2

            local DoSay = function(text)
                if text == "" then
                    DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("invalid_x", "argument", ""))
                    return ""
                end

                local col = team.GetColor(ply:Team())
                team_clr = format(rgb_ref, col.r, col.g, col.b, col.a)

                local tags = esclib.text:KeyFormat(echat.config.advert_command["format"], {
                    ["jobclr"] = team_clr,
                    ["ply"] = echat:ParseVararg(ply) or "???",
                    ["ply_nick"] = ply:Nick(),
                    ["steamid"] = ply:SteamID(),
                    ["steamid64"] = ply:SteamID64()
                })

                local recievers = player.GetAll()
                echat:SendParsedMessageToPlayer(ply, recievers, HalfParse(ply, tags, text), text)
            end
            hook.Call("playerAdverted", nil, ply, args)
            return args, DoSay
        end

        if echat.config.advert_command["enabled"] then
            DarkRP.defineChatCommand("advert", Advert, true, 1.5)
        end
    
    end
end

RewriteDarkRP()
--PATH addons/____echat/lua/echat/core/__core_build__.lua:
local max = math.max
local min = math.min

------------------
--# MAIN BUILD #--
------------------
function echat:Build()
	echat.addon:ClearDownloadCache("temp")

	self.skin = echat.addon:GetCurrentSkin()
	self.sizing = false
	local clr = echat.addon:GetColors()
	local ply = LocalPlayer()

	--fullscreen panel
	local bg = vgui.Create("EditablePanel")
	bg:SetText("")
	bg:SetSize(esclib.scrw,esclib.scrh)
	bg:SetZPos(-10)
	bg:SetMouseInputEnabled(true)
	bg:SetKeyboardInputEnabled(true)
	bg.Paint = nil
	self.bg = bg

	function bg:OnKeyCodeReleased(key)
		if key == KEY_ESCAPE then
			echat:Close()
		end
	end

	-- Fullscreen button, detecting click outside
	local loose_focus_button = bg:Add("DButton")
	loose_focus_button:Dock(FILL)
	loose_focus_button:SetZPos(-1)
	loose_focus_button:SetText("")
	loose_focus_button:SetCursor("arrow")
	loose_focus_button:SetMouseInputEnabled(true)
	loose_focus_button:SetKeyboardInputEnabled(true)
	loose_focus_button.Paint = nil
	function loose_focus_button:DoClick()
		echat:Close()
	end
	loose_focus_button:SetZPos(-1)

	-----------------
	--# DRAG BASE #--
	-----------------
	local panel_top_height = max(bg:GetTall()*0.028, 20)
	local pnl = vgui.Create("esclib.dragbase", bg)
	if IsValid(echat.chatbox) then echat.chatbox:Remove() end
	echat.chatbox = pnl
	local size_w = bg:GetWide()*(echat.addon:GetVar("size_w") or 0.45)
	local size_h = bg:GetTall()*(echat.addon:GetVar("size_h") or 0.37)
	local pos_x  = bg:GetWide()*(echat.addon:GetVar("pos_x") or 0.01)
	local pos_y  = bg:GetTall()*(echat.addon:GetVar("pos_y") or 0.41)
	pnl:SetSize(size_w, size_h)
	pnl:SetPos(pos_x, pos_y)
	pnl:SetSizable(true)
	pnl:SetZPos(10)
	pnl:SetMinimumSize(bg:GetWide()*0.2, bg:GetTall()*0.2)
	pnl:DockPadding(5,panel_top_height,5,10)
	pnl.alpha_clr = table.Copy(clr.main.bg2)

	local sizing_clr = Color(13,13,13)
	local sizing_sub_clr = clr.main.accent
	local sizing_text = echat.addon:Translate("sizing_mode")

	local font = echat:AdaptiveFont("echat", 16, 500)
	function pnl:PaintOver(w,h)
		if echat.sizing then
			draw.RoundedBox(8,0,0,w,h,sizing_sub_clr)
			draw.RoundedBox(6,3,3,w-6,h-6,sizing_clr)

			draw.SimpleText(sizing_text, font, w*0.5, h*0.5, sizing_sub_clr, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
			draw.SimpleText(string.format("(%dpx x %dpx)", w, h), font, w*0.5, h*0.5, sizing_sub_clr, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			draw.SimpleText(w.."px", font, w*0.5, h-15, sizing_sub_clr, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
			draw.SimpleText(h.."px", font, w-15, h*0.5, sizing_sub_clr, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

			draw.SimpleText(w.."px", font, w*0.5, 15, sizing_sub_clr, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			draw.SimpleText(h.."px", font, 15, h*0.5, sizing_sub_clr, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end
		
	end

	--------------------
	--# OPENED PANEL #--
	--------------------
	local opened_base = pnl:Add("EditablePanel")
	opened_base:Dock(FILL)
	opened_base:InvalidateParent(true)
	opened_base:SetAlpha(0)
	echat.chatbox.opened_panel = opened_base

	local text_entry_font = echat:AdaptiveFont("echat", 18, 500)
	local button_tall = draw.GetFontHeight(text_entry_font)+4 -- font

	--panel for text entry, chat modes
	local bottom_panel = opened_base:Add("EditablePanel")
	bottom_panel:Dock(BOTTOM)
	bottom_panel:DockPadding(5,4,5,4) --just few pixels
	echat.bottom_panel = bottom_panel
	function bottom_panel:Paint(w,h)
		-- draw.RoundedBoxEx(8,0,0,w,h,clr.main.bg2,false,false,true,true)
	end

	
	function opened_base:Paint(w,h)
		-- draw.RoundedBox(0,0,0,w,h-bottom_panel:GetTall(), clr.main.bg)
	end

	------------------
	--# TEXT MODES #--
	------------------
	local text_mode = bottom_panel:Add("echat.choicelist")
	local tw, th = esclib.util:TextSize(echat.addon:Translate("chat_mode_normal"),text_entry_font)
	text_mode:SetWide(tw+30)
	text_mode:Dock(LEFT)
	text_mode:SetFont(text_entry_font)
	text_mode:SetColor(clr.main.text)
	text_mode:SetBackgroundColor(color_transparent)

	text_mode:AddChoice(echat.addon:Translate("chat_mode_normal"), nil, true)
	text_mode:AddChoice(echat.addon:Translate("chat_mode_team"))
	for k,_ in pairs(echat.chat_modes) do
		text_mode:AddChoice(k)
	end
	bg.mode_pnl = text_mode

	function text_mode:OnSelect(index, value, data)
		local tw, th = esclib.util:TextSize(value,self:GetFont())
		self:SetWide(tw+30)
	end
	
	local close_button = pnl:Add("DButton")
	close_button:Hide()
	close_button:SetText("")
	echat.chatbox.close_button = close_button
	function close_button:Paint(w,h)
		
		draw.SimpleText("r", "Marlett", w*0.5, h*0.5, self:IsHovered() and clr.main.text_gray or clr.main.text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end
	function close_button:DoClick() 
		echat:Close()
	end
	
	local btn_mar_x = bottom_panel:GetWide()*0.05
	local send_button = bottom_panel:Add("DButton")
	send_button:SetWide(button_tall)
	send_button:Dock(RIGHT)
	send_button:SetText("")
	send_button:eAddHint( echat.addon:Translate("send"), nil, nil, bg)
	send_button:DockMargin(btn_mar_x,0,btn_mar_x,0)
	function send_button:Paint(w,h)
		local hovered = self:IsHovered()
		esclib.draw:MaterialCentered(w*0.5,h*0.5,w*0.4,hovered and clr.main.text_hover or clr.main.text,echat:GetMaterial("send.png"))
	end

	local settings_button = bottom_panel:Add("DButton")
	settings_button:SetWide(button_tall)
	settings_button:Dock(RIGHT)
	settings_button:SetText("")
	settings_button:eAddHint(echat.addon:Translate("settings"), nil, nil, bg)
	settings_button:DockMargin(btn_mar_x,0,0,0)
	function settings_button:Paint(w,h)
		local hovered = self:IsHovered()
		esclib.draw:MaterialCentered(w*0.5,h*0.5,w*0.4,hovered and clr.main.text_hover or clr.main.text,esclib.Materials["cog.png"])
	end
	function settings_button:DoClick()
		esclib:opensettings("echat")
	end

	local font = echat:AdaptiveFont("echat", 16, 500)
	--panel paint
	pnl:NoClipping(true)
	local chat_name = echat.addon:GetVar("chat_name") or echat.config.chat_name
	function pnl:Paint(w,h)
		if not self.opened then return end
		if echat.sizing then return end

		self.alpha_clr.a = opened_base:GetAlpha()
		
		local px,py,pw,ph = self:GetDockPadding()
		if self.ambilight then
			-- draw.RoundedBox(8,px-3,-3,w-px-pw+6,h-ph+6,clr.main.bg)
			self.ambilight:Draw(px-2,-2,w-px-pw+4,h-ph+4)
		end

		draw.RoundedBox(6,px,0,w-px-pw,h-ph,clr.main.bg)
		
		draw.SimpleText(chat_name, font, 15, panel_top_height*0.5-1, clr.main.text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

	------------------
	--# TEXT ENTRY #--
	------------------
	local text_entry = bottom_panel:Add("echat.textentry")
	text_entry:Dock(FILL)
	text_entry:DockMargin(0,0,btn_mar_x,0)
	text_entry:SetFont(text_entry_font)
	text_entry:SetPlaceholderText(echat.addon:Translate("type_something"))
	text_entry:SetDrawLanguageID(false)
	text_entry:SetMaximumCharCount(echat.config.max_message_len)
	text_entry:SetMultiline(echat.config.multiline)
	timer.Simple(0, function() -- update size
		if text_entry and text_entry.CalculateParentSize then text_entry:CalculateParentSize() end
	end)
	echat.chatbox.text_entry = text_entry
	function send_button:DoClick()
		text_entry:OnEnter( text_entry:GetText() )
	end

	function text_entry:OnKeyCode(key) 
		if input.IsKeyDown(KEY_ESCAPE) then
			echat:Close()
		end
	end

	function text_entry:OnEnter(text)
		self:SetText("")
		echat:SendMessageToServer(text)
		echat:Close()
	end

	--Auto complete sorting
	local function sortWordsBySubstring(words, target)
	  table.sort(words, function(a, b)
	    local aScore = string.find(a.text, target, 1, true)
	    local bScore = string.find(b.text, target, 1, true)
	    if aScore == bScore then
	      return a.text < b.text
	    else
	      return (aScore > bScore)
	    end
	  end)
	  return words
	end

	--Auto complete
	function text_entry:GetAutoComplete( text, word )
		local suggestions = {}

		local max_iters = echat.addon:GetVar("autocomplete_count") or 20 --maximum commands visible at once
		local iters = 0
		local need_break = false
		for id,fn in pairs(echat.auto_complete) do
			local prompt = fn(text, word)
			if prompt then
				for k,cmd in ipairs(prompt) do
					if iters >= max_iters then
						need_break = true
						break
					end
					table.insert(suggestions,cmd)
					iters = iters + 1
				end
				if need_break then
					break
				end
			end
		end
		
		suggestions = sortWordsBySubstring(suggestions, text)

		return suggestions
	end

	function text_entry:OnChange(text)
		hook.Run("ChatTextChanged", self:GetText())
	end


	--------------------
	--# EMOJI BUTTON #--
	--------------------
	if echat.config.emojies then
		local emoji_button = bottom_panel:Add("DButton")
		emoji_button:SetWide(button_tall)
		emoji_button:Dock(RIGHT)
		emoji_button:SetText("")
		emoji_button:eAddHint(echat.addon:Translate("emoji"), nil, nil, bg)
		emoji_button:DockMargin(btn_mar_x,0,0,0)
		function emoji_button:Paint(w,h)
			local hovered = self:IsHovered()
			esclib.draw:MaterialCentered(w*0.5,h*0.5,w*0.4,hovered and clr.main.text_hover or clr.main.text,echat:GetMaterial("emoji.png"))
		end
		function emoji_button:DoClick()
			local bg_clicker = esclib:GenerateBGClicker()
			bg_clicker.Paint = nil
			
			local mx,my = gui.MouseX(), gui.MouseY()
			local emoji_size = echat:AdaptiveSize(32)

			local pnl = bg_clicker:Add("DPanel")
			pnl:SetSize(emoji_size*10+5*12, esclib.scrh*0.4)
			pnl:SetPos(mx-pnl:GetWide()*0.5, my-pnl:GetTall()-15)
			function pnl:Paint(w,h)
				draw.RoundedBox(4,0,0,w,h,clr.main.bg2)
			end

			local scroll = pnl:Add("esclib.scrollpanel")
			scroll:Dock(FILL)
			scroll:SetScrollSpeed(10)
			
			local layout = scroll:Add("DIconLayout")
			layout:Dock(FILL)
			layout:SetBorder(5)
			layout:SetSpaceX(5)
			layout:SetSpaceY(5)

			local emoji_list = echat:GetEmojiList()
			table.sort(emoji_list)

			local prev_char = nil

			local font = echat:AdaptiveFont("echat", 24, 500)
			local font_height = draw.GetFontHeight(font)
			for i, name in ipairs(emoji_list) do
				if name == "" then continue end
				local ch = string.sub(name, 1,1)

				if prev_char ~= ch then
					local ch_pnl = layout:Add("DPanel")
					ch_pnl:SetSize(pnl:GetWide()-layout:GetBorder(),font_height+2)
					function ch_pnl:Paint(w,h)
						draw.RoundedBox(0,0,h-2,w,2,clr.main.scrollbar)
						draw.SimpleText(ch, font, 5, h*0.5-2, clr.main.text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
					end
				end

				local img_btn = layout:Add("DImageButton")
				img_btn:SetMaterial(echat:GetEmoji(name))
				img_btn:SetSize(emoji_size,emoji_size)
				img_btn:eAddHint( ":"..name..":", nil, nil, bg_clicker)

				function img_btn:DoClick()
					text_entry:SetValue(text_entry:GetValue()..":"..name..":")
					bg_clicker:Close()
					text_entry:RequestFocus()
					text_entry:SetCaretPos( string.len(text_entry:GetValue() or "") ) 
				end

				prev_char = ch
			end
		end
	end



	local msg_base = vgui.Create("EditablePanel", opened_base)
	echat.bg.message_base = msg_base
	msg_base:Dock(FILL)

	----------------
	--# RICHTEXT #--
	----------------
	local richtext = vgui.Create("echat.richtext", msg_base)
	echat.richtext = richtext
	richtext:Dock(FILL)
	richtext:DockMargin(opened_base:GetWide()*0.01,0,0,0)
	richtext:SetW(opened_base:GetWide())
	richtext:SetMouseInputEnabled(true)
	richtext:GetVBar():SetColor(clr.main.scrollbar)
	richtext:SetMaximumLines(echat.addon:GetVar("max_lines") or 512)

	function richtext:DoRightClick()
		local text = richtext:GetSelectedText()
		if text then
			local bg_clicker = esclib:GenerateBGClicker()
			bg_clicker.Paint = nil

			local text = echat.addon:Translate("copy")
			local font = echat:AdaptiveFont("echat", 16, 500)

			local text_w, text_h = esclib.util:TextSize(text,font)
			local btn = bg_clicker:Add("DButton")
			btn:SetSize(text_w+40, text_h + 10)
			btn:SetText("")
			function btn:Paint(w,h)
				local hovered = self:IsHovered()
				draw.RoundedBox(8,0,0,w,h,hovered and clr.main.button_hover or clr.main.button)
				esclib.draw:MaterialCentered(h*0.6, h*0.5,h*0.3, hovered and clr.main.accent or clr.main.text, echat:GetMaterial("copy.png"))
				draw.SimpleText(text,font, h*1.1, h*0.5, clr.main.text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			end
			local mx,my = gui.MouseX(), gui.MouseY()
			btn:SetPos(mx+2,my+2)

			function btn:DoClick()
				if IsValid(richtext) then
					richtext:CopySelectedToClipboard(true)
					bg_clicker:Close()
				end
			end


			function bg_clicker:OnClose()
				btn:Remove()
			end
		end
	end

	richtext:GotoTextEnd()


	------------------------
	--# GO TO END BUTTON #--
	------------------------
	local gotoend_btn = msg_base:Add("DButton")
	gotoend_btn:SetZPos(1)
	gotoend_btn:SetText("")
	function gotoend_btn:DoClick()
		if (richtext:GetVBar():GetScroll() + 50 < richtext.pnlCanvas:GetTall()-richtext:GetTall()) then
			richtext:GotoTextEnd()
		end
	end
	local gotoend_material = echat:GetMaterial("down_arrow.png")
	local gotoend_text = echat.addon:Translate("goto_end")
	local gotoend_button_size = echat:AdaptiveSize(28)
	gotoend_btn:SetSize(gotoend_button_size,gotoend_button_size)
	echat.bg.message_base.gotoend_btn = gotoend_btn
	function gotoend_btn:Paint(w,h)
		if (richtext:GetVBar():GetScroll() + 50 < richtext.pnlCanvas:GetTall()-richtext:GetTall()) then
			self:SetCursor("hand")
			local hovered = self:IsHovered()

			esclib.draw:MaterialCentered(h*0.5, h*0.5+1, h*0.25, hovered and clr.main.accent or clr.main.text, gotoend_material)

		else
			self:SetCursor("arrow")
		end
	end


	--drag area
	pnl:SetDragArea(0,0,pnl:GetWide(),pnl:GetTall()*0.1)
	function pnl:OnSizing(w,h)
		echat.sizing = true
	end
	function pnl:OnEndSizing(w,h)
		echat.sizing = false
		richtext:AppendEmptyToEnd(nil, true)
		self:UpdateDragArea()
		self:InvalidateChildren()
		echat:InvalidateLayout()

		echat.addon:SetVar("size_w", (w / esclib.scrw) or 0.45) --save settings to file
		echat.addon:SetVar("size_h", (h / esclib.scrh) or 0.37)

		if echat.addon:GetVar("ambilight") then
			esclib.print(echat.addon:GetVar("ambilight_clr1"))
			local colors = {
				echat.addon:GetVar("ambilight_clr1") or Color(0,225,255, 100),
				echat.addon:GetVar("ambilight_clr2") or Color(0,255,157, 100)
			}
			pnl.ambilight = esclib.util:PrechacheAmbilight(8, colors, 1, 1)
		end
	end
	pnl:OnEndSizing(pnl:GetWide(), pnl:GetTall())
	function pnl:OnEndDragging(newx, newy)
		echat.addon:SetVar("pos_x", (newx / esclib.scrw) or 0.02) --save settings to file
		echat.addon:SetVar("pos_y", (newy / esclib.scrh) or 0.41)
	end
	
	pnl:UpdateDragArea()
	echat:InvalidateLayout()
	self:Close() --hidden by default

	echat:LoadModules()
end

--place items in chat depending on size
function echat:InvalidateLayout()
	local chatbox = echat.chatbox
	local richtext = echat.richtext

	local dx, dy, dw, dh = chatbox:GetDockPadding()
	local close_button = echat.chatbox.close_button
	close_button:SetSize(dy,dy)
	close_button:SetPos(chatbox:GetWide()-close_button:GetWide()-5)

	local msg_base = echat.bg.message_base
	msg_base:InvalidateChildren(true)
	msg_base:InvalidateParent(true)
	msg_base:InvalidateLayout(true)

	local gotoend_btn = echat.bg.message_base.gotoend_btn
	gotoend_btn:SetPos(msg_base:GetWide() - gotoend_btn:GetWide()-15, chatbox:GetTall() - gotoend_btn:GetTall() - 70)

	local px,py = chat.GetChatBoxPos()
	local pw,ph = chat.GetChatBoxSize()
	hook.Run("echat.InvalidateLayout", px,py,pw,ph)

end

--lua refresh
if echat.IsValid && echat:IsValid() then echat:Restart() end
--PATH addons/_doctor/lua/itemstore/items/bp_pill_bottle.lua:
ITEM.Name = "Pills"
ITEM.Description = "Nig"
ITEM.Model = "models/blues_pharm/pill_bottle.mdl"
ITEM.Stackable = false
ITEM.DropStack = false
ITEM.Base = "base_rp"

-- Because all of you feel the need to fuck with your shipments on a daily basis.
function ITEM:GetName()
	if not self:GetData("RecipeID") then return end
	return "Pills ("..BLUES_PHARMA.Medicines[self:GetData("RecipeID")].name..")"
end

function ITEM:GetDescription()
	if not self:GetData("RecipeID") then return end
	return BLUES_PHARMA.Medicines[self:GetData("RecipeID")].name.."\n\n"..self:GetData("UsesLeft").." Pills Left.\n\n"..BLUES_PHARMA.Pages[self:GetData("RecipeID") + 1].effects
end

function ITEM:CanPickup( pl, ent )
	return true
end

function ITEM:CanMerge( item )
	return false
end
 
function ITEM:SaveData( ent )
	self:SetData("UsesLeft", ent:GetUsesLeft())
	self:SetData("RecipeID", ent:GetRecipeID())
end

function ITEM:LoadData( ent )
	ent:SetUsesLeft(self:GetData("UsesLeft"))
	ent:SetRecipeID(self:GetData("RecipeID"))
end

function ITEM:Use( pl )
	if not self:GetData("RecipeID") then return end
	if not BLUES_PHARMA.CONFIG.CanConsumePills  then return end

	local uses = self:GetData("UsesLeft")
	uses = uses - 1
	self:SetData("UsesLeft", uses)

	self.Description = BLUES_PHARMA.Medicines[self:GetData("RecipeID")].name.."\n\n"..self:GetData("UsesLeft").." Pills Left.\n\n"

	--Call use func
	local useFunc = BLUES_PHARMA.Medicines[self:GetData("RecipeID")].onConsumed
	useFunc(BLUES_PHARMA.Medicines[self:GetData("RecipeID")], pl)

	pl:BPAddOverdose(BLUES_PHARMA.Medicines[self:GetData("RecipeID")].overdoseRate)

	if uses <= 0 then
		return true
	end

	return false
end

--PATH addons/____inventory/lua/itemstore/items/prop_physics.lua:
ITEM.Name = itemstore.Translate( "prop_name" )
ITEM.Description = itemstore.Translate( "prop_desc" )
ITEM.Base = "base_auto"

function ITEM:CanPickup( pl, ent )
	if CPPI then
		if ent:CPPIGetOwner() ~= pl then
			return false
		end
	end

	return true
end
--PATH addons/____inventory/lua/itemstore/items/spawned_weapon.lua:
ITEM.Name = itemstore.Translate( "weapon_name" )
ITEM.Description = itemstore.Translate( "weapon_desc" )
ITEM.Model = "models/weapons/w_pistol.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Weapons
ITEM.Base = "base_rp"
ITEM.Stackable = true

ITEM.Weapons = {
	weapon_physgun = itemstore.Translate( "weapon_physgun" ),
	weapon_physcannon = itemstore.Translate( "weapon_physcannon" ),
	weapon_crowbar = itemstore.Translate( "weapon_crowbar" ),
	weapon_stunstick = itemstore.Translate( "weapon_stunstick" ),
	weapon_pistol = itemstore.Translate( "weapon_pistol" ),
	weapon_357 = itemstore.Translate( "weapon_357" ),
	weapon_smg1 = itemstore.Translate( "weapon_smg1" ),
	weapon_ar2 = itemstore.Translate( "weapon_ar2" ),
	weapon_annabelle = itemstore.Translate( "weapon_annabelle" ),
	weapon_shotgun = itemstore.Translate( "weapon_shotgun" ),
	weapon_crossbow = itemstore.Translate( "weapon_crossbow" ),
	weapon_frag = itemstore.Translate( "weapon_frag" ),
	weapon_rpg = itemstore.Translate( "weapon_rpg" ),
	weapon_slam = itemstore.Translate( "weapon_slam" ),
	weapon_bugbait = itemstore.Translate( "weapon_bugbait" ),
	m9k_ares_shrike = 'ДАУНИЗМ'
}

function ITEM:IsValid()
	return self.Weapons[ self:GetData( "Class" ) ] or weapons.Get( self:GetData( "Class" ) )
end

function ITEM:GetWeaponClass( wep )
	return wep.GetWeaponClass and wep:GetWeaponClass() or wep.weaponclass
end

function ITEM:GetName()
	local name = self.Name

	if self.Weapons[ self:GetData( "Class" ) ] then
		name = self.Weapons[ self:GetData( "Class"  ) ]
	end

	local wep_class = weapons.Get( self:GetData( "Class" ) )
	if wep_class and wep_class.PrintName then
		name = wep_class.PrintName
	end

	return self:GetData( "Name", name )
end

function ITEM:GetDescription()
	local desc = self.Description

	local clip = self:GetData( "Clip1", 0 )
	local reserve = self:GetData( "Ammo", 0 )

	return self:GetData( "Description", string.format( desc, clip, reserve ) )
end

function ITEM:CanPickup( pl, ent )
	if ent.PlayerUse then return false end
	if not weapons.Get( ent:GetNWString('GetWeapon') ) and
		not self.Weapons[ ent:GetNWString('GetWeapon') ] then return false end
	if itemstore.config.DisabledItems[ ent:GetNWString('GetWeapon') ] then return false end

	return true
end

function ITEM:CanMerge( item )
	return self.Stackable and item:GetClass() == self:GetClass() and
		item:GetData( "Class" ) == self:GetData( "Class" ) and
		self.MaxStack >= self:GetAmount() + item:GetAmount()
end

function ITEM:Merge( item )
	self:SetAmount( self:GetAmount() + item:GetAmount() )

	self:SetData( "Clip2", item:GetData( "Clip2", 0 ) + self:GetData( "Clip2", 0 ) )
	self:SetData( "Ammo", item:GetData( "Ammo", 0 ) + self:GetData( "Ammo", 0 )
		+ item:GetData( "Clip1", 0 ) )
end

-- 76561198843434426

function ITEM:Split( amount )
	self:SetAmount( self:GetAmount() - amount )

	local item = self:Copy()
	item:SetAmount( amount )

	self:SetData( "Clip1", 0 )
	self:SetData( "Clip2", 0 )
	self:SetData( "Ammo", 0 )

	return item
end

function ITEM:SaveData( ent )
	self:SetData( "Class", ent:GetNWString('GetWeapon') )
	self:SetData( "Model", ent:GetModel() )

	if ent.clip1 then self:SetData( "Clip1", ent.clip1 ) end
	if ent.clip2 then self:SetData( "Clip2", ent.clip2 ) end

	local reserve = 0
	if ent.clip1 then
		reserve = reserve + ent.clip1
	end

	if ent.ammoadd then
		reserve = reserve + ent.ammoadd
	end

	self:SetData( "Ammo", reserve )
end

function ITEM:LoadData( ent )
	ent:SetModel( self:GetData( "Model" ) )

	if ent.GetWeaponClass then
		ent:SetWeaponClass( self:GetData( "Class" ) )
	else
		ent:SetNWString('GetWeapon', self:GetData( "Class" ))
	end

	ent.clip1 = math.floor( self:GetData( "Clip1", 0 ) )
	ent.clip2 = math.floor( self:GetData( "Clip2", 0 ) )
	ent.ammoadd = math.floor( self:GetData( "Ammo", 0 ) )

	self:SetData( "Clip1", 0 )
	self:SetData( "Clip2", 0 )
	self:SetData( "Ammo", 0 )

	function ent:Initialize()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )
		self:GetPhysicsObject():Wake()

		self:SetCollisionGroup( COLLISION_GROUP_INTERACTIVE_DEBRIS )
	end
end

local hl2_ammo = {
	weapon_pistol = 3,
	weapon_357 = 5,
	weapon_smg1 = 4,
	weapon_ar2 = 1,
	weapon_annabelle = 7,
	weapon_shotgun = 7,
	weapon_crossbow = 6,
	weapon_frag = 10,
	weapon_rpg = 8,
}

function ITEM:Use( pl )
	if pl:IsArrested() then return false end

	local class = self:GetData( "Class" )

	if not self.Weapons[ class ] and
		not weapons.Get( class ) then return false end

	local has_weapon = pl:HasWeapon( class )

	local wep_table = weapons.Get( class )
	local ammo, ammo_type

	if wep_table then
		ammo_type = wep_table.Primary.Ammo
	else
		ammo_type = hl2_ammo[ class ]
	end

	if ammo_type then
		ammo = pl:GetAmmoCount( ammo_type )
	end

	pl:Give( class )

	if ammo and ammo_type then
		pl:SetAmmo( ammo, ammo_type )
	end
	
	local wep = pl:GetWeapon( class )

	-- make sure we actually gave the weapon before we start deducting stuff
	if not IsValid( wep ) then return end

	if self:GetData( "Clip1" ) then
		if has_weapon then
			pl:GiveAmmo( self:GetData( "Clip1" ), wep:GetPrimaryAmmoType() )
		else
			wep:SetClip1( self:GetData( "Clip1" ) )
		end
	end

	if self:GetData( "Clip2" ) then
		if has_weapon then
			pl:GiveAmmo( self:GetData( "Clip2" ), wep:GetSecondaryAmmoType() )
		else
			wep:SetClip2( self:GetData( "Clip2" ) )
		end
	end

	self:SetData( "Clip1", 0 )
	self:SetData( "Clip2", 0 )

	if itemstore.config.SplitWeaponAmmo then
		if self:GetData( "Ammo" ) then
			local reserve = self:GetData( "Ammo" )
			local amount = self:GetAmount()

			local ammo = math.min( math.ceil( reserve / amount ), reserve )

			pl:GiveAmmo( ammo, wep:GetPrimaryAmmoType() )
			self:SetData( "Ammo", reserve - ammo )
		end
	else
		pl:GiveAmmo( self:GetData( "Ammo", 0 ), wep:GetPrimaryAmmoType() )
		self:SetData( "Ammo", 0 )
	end

	return self:TakeOne()
end
