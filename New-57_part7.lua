--Stealed clientside server code by exechack.cc
--Hostname: 🧿 New Era - Solo Leveling | .gg/nwsl - Part 7/10 - 08/04/2025


--PATH addons/sl_util_accessory/lua/autorun/advanced_accessories_loader.lua:
local files, directories = file.Find("advanced_accessories/languages/*", "LUA")
for k,v in ipairs(files) do
    include("advanced_accessories/languages/"..v)
end

include("advanced_accessories/sh_config.lua")
include("advanced_accessories/sh_materials.lua")
include("advanced_accessories/shared/sh_functions.lua")
include("advanced_accessories/sh_advanced_config.lua")

if SERVER then 
    include("advanced_accessories/server/sv_sql.lua")
    include("advanced_accessories/server/sv_functions.lua")
    include("advanced_accessories/server/sv_hooks.lua")
    include("advanced_accessories/server/sv_nets.lua")
    include("advanced_accessories/server/sv_sql.lua")

    local files, directories = file.Find("advanced_accessories/languages/*", "LUA")
    for k,v in ipairs(files) do
        AddCSLuaFile("advanced_accessories/languages/"..v)
    end
    
    AddCSLuaFile("advanced_accessories/sh_config.lua")
    AddCSLuaFile("advanced_accessories/sh_materials.lua")
    AddCSLuaFile("advanced_accessories/shared/sh_functions.lua")
    AddCSLuaFile("advanced_accessories/sh_advanced_config.lua")

    AddCSLuaFile("advanced_accessories/client/cl_gradients.lua")
    AddCSLuaFile("advanced_accessories/client/cl_fonts.lua")
    AddCSLuaFile("advanced_accessories/client/cl_main.lua")
    AddCSLuaFile("advanced_accessories/client/cl_functions.lua")
    AddCSLuaFile("advanced_accessories/client/cl_notify.lua")
    AddCSLuaFile("advanced_accessories/client/cl_bodygroup.lua")
    AddCSLuaFile("advanced_accessories/client/cl_admin.lua")
    AddCSLuaFile("advanced_accessories/client/cl_inventory.lua")
    AddCSLuaFile("advanced_accessories/client/cl_models.lua")
    AddCSLuaFile("advanced_accessories/client/cl_player_settings.lua")
    
    AddCSLuaFile("advanced_accessories/vgui/cl_button.lua")
    AddCSLuaFile("advanced_accessories/vgui/cl_cards.lua")
    AddCSLuaFile("advanced_accessories/vgui/cl_searchbar.lua")
    AddCSLuaFile("advanced_accessories/vgui/cl_slider.lua")
    AddCSLuaFile("advanced_accessories/vgui/cl_scroll.lua")
    AddCSLuaFile("advanced_accessories/vgui/cl_textentry.lua")
    AddCSLuaFile("advanced_accessories/vgui/cl_combobox.lua")
    AddCSLuaFile("advanced_accessories/vgui/cl_dmodel.lua")
    AddCSLuaFile("advanced_accessories/vgui/cl_checkbox.lua")
else
    include("advanced_accessories/client/cl_gradients.lua")
    include("advanced_accessories/client/cl_fonts.lua")
    include("advanced_accessories/client/cl_main.lua")
    include("advanced_accessories/client/cl_functions.lua")
    include("advanced_accessories/client/cl_notify.lua")
    include("advanced_accessories/client/cl_bodygroup.lua")
    include("advanced_accessories/client/cl_admin.lua")
    include("advanced_accessories/client/cl_inventory.lua")
    include("advanced_accessories/client/cl_models.lua")
    include("advanced_accessories/client/cl_player_settings.lua")
    
    include("advanced_accessories/vgui/cl_button.lua")
    include("advanced_accessories/vgui/cl_cards.lua")
    include("advanced_accessories/vgui/cl_searchbar.lua")
    include("advanced_accessories/vgui/cl_slider.lua")
    include("advanced_accessories/vgui/cl_scroll.lua")
    include("advanced_accessories/vgui/cl_textentry.lua")
    include("advanced_accessories/vgui/cl_combobox.lua")
    include("advanced_accessories/vgui/cl_dmodel.lua")
    include("advanced_accessories/vgui/cl_checkbox.lua")
end
--PATH addons/sl_util_accessory/lua/advanced_accessories/client/cl_player_settings.lua:
local lerpBack, offsetsValue = false, {}

local function getItemSettings(typeSet)
    local tbl = offsetsValue or {}
    for i=1, 3 do tbl[i] = tbl[i] or {} end 

    if typeSet == "pos" then 
        return Vector((tbl[1][typeSet] or 0), (tbl[2][typeSet] or 0), (tbl[3][typeSet] or 0))
    elseif typeSet == "rotate" then 
        return Angle((tbl[1][typeSet] or 0), (tbl[2][typeSet] or 0), (tbl[3][typeSet] or 0))
    elseif typeSet == "scale" then 
        return Vector((tbl[1][typeSet] or 1), (tbl[2][typeSet] or 1), (tbl[3][typeSet] or 1))
    end
end

local function sliderMove(x, y, panel, title, name, itemTable)
    local sliderPanel = vgui.Create("DPanel", panel)
    sliderPanel:SetSize(AAS.ScrW*0.19, AAS.ScrH*0.175)
    sliderPanel:SetPos(x, y)

    sliderPanel.Paint = function(self,w,h)
        draw.RoundedBoxEx(8, 0, 0, w, h, AAS.Colors["black18230"], false, false, true, true)
        draw.RoundedBox(0, 0, 0, w, h*0.26, AAS.Colors["black18"])
        draw.RoundedBox(0, 0, h*0.26, w, h*0.05, AAS.Colors["black18100"])
        
        draw.DrawText(title, "AAS:Font:05", w/2, h*0.05, AAS.Colors["white"], TEXT_ALIGN_CENTER)
    end 

    for i=1, 3 do
        offsetsValue[i] = offsetsValue[i] or {}

        local slider = vgui.Create("AAS:Slider", sliderPanel)
        slider:SetPos(0, i*AAS.ScrH*0.04)
        slider:ChangeBackground(false)

        local offsetItems = AAS.ClientTable["offsetItems"] or {}
        local offsetTable = offsetItems[tostring(itemTable["uniqueId"])] or {}

        if name == "pos" then
            local pos = isvector(offsetTable.pos) and offsetTable.pos or Vector(0,0,0)

            slider.Slider:SetMin(-AAS.MaxVectorOffset)
            slider.Slider:SetMax(AAS.MaxVectorOffset)
            slider.Slider:SetValue(pos[i])

            offsetsValue[i]["pos"] = pos[i]
        elseif name == "rotate" then
            local ang = isangle(offsetTable.ang) and offsetTable.ang or Angle(0,0,0)

            slider.Slider:SetMin(-AAS.MaxAngleOffset)
            slider.Slider:SetMax(AAS.MaxAngleOffset)
            slider.Slider:SetValue(ang[i])

            offsetsValue[i]["rotate"] = ang[i]
        end 

        if name == "scale" then 
            local scale = isvector(offsetTable.scale) and offsetTable.scale or Vector(1,1,1)

            slider.Slider:SetMin(-AAS.MaxVectorOffset)
            slider.Slider:SetMax(AAS.MaxVectorOffset)
            slider.Slider:SetValue(scale[i])

            slider:SetAccurateNumber(0.002)

            offsetsValue[i]["scale"] = scale[i]
        end

        slider.Slider.OnValueChanged = function()
            offsetsValue[i] = offsetsValue[i] or {}

            offsetsValue[i][name] = slider.Slider:GetValue()
        end
    end 
end

local curentPosx, curentPosY, curentFov = 0, 0, 0
function AAS.PlayerSettings(itemTable)
    if not istable(itemTable) then return end
    if IsValid(playerSettingsPanel) then playerSettingsPanel:Remove() end

    lerpBack = false

    if IsValid(accessoriesFrame) then 
        accessoriesFrame:AlphaTo(100, 0.3, 0, function() 
            if not IsValid(accessoriesFrame) then return end 
            accessoriesFrame:Remove()
        end)
    end

    local linearGradient = {
        {offset = 0, color = AAS.Gradient["upColor"]},
        {offset = 0.4, color = AAS.Gradient["midleColor"]},
        {offset = 1, color = AAS.Gradient["downColor"]},
    }

    playerSettingsPanel = vgui.Create("DFrame")
    playerSettingsPanel:SetSize(AAS.ScrW, AAS.ScrH)
    playerSettingsPanel:ShowCloseButton(false)
    playerSettingsPanel:SetTitle("")
    playerSettingsPanel:MakePopup()
    playerSettingsPanel:AlphaTo( 255, 0.3, 0 )
    playerSettingsPanel.Paint = function() end
    playerSettingsPanel:SetCursor("sizeall")
    playerSettingsPanel.OnMousePressed = function(self, mouseCode)
        if mouseCode != MOUSE_LEFT then return end

        self.startMouseX = gui.MouseX()
        self.startMouseY = gui.MouseY()
    end
    playerSettingsPanel.OnMouseReleased = function(self, mouseCode)
        if mouseCode != MOUSE_LEFT then return end
        
        self.startMouseX = nil       
        self.startMouseY = nil       
    end

    local lastPosX, lastPosY = 0, 50
    local posMouseX, posMouseY = 0,0

    playerSettingsPanel.Think = function(self) 
        if input.IsMouseDown(MOUSE_FIRST) and playerSettingsPanel:IsHovered() then 
            local currentMouseX, currentMouseY = input.GetCursorPos()
            local differenceMousePosX = currentMouseX - posMouseX
            local differenceMousePosY = currentMouseY - posMouseY

            curentPosx = lastPosX + differenceMousePosX / AAS.ScrW*10
            curentPosY = math.Clamp(lastPosY + differenceMousePosY,-20,200)
        end 
    end
    function playerSettingsPanel:OnMousePressed()
        if playerSettingsPanel:IsHovered() then
            posMouseX, posMouseY = input.GetCursorPos()
        end
    end
    function playerSettingsPanel:OnMouseReleased()
        lastPosX = curentPosx
        lastPosY = curentPosY
    end
    function playerSettingsPanel:OnMouseWheeled(keycode)    
        if keycode == 1 and curentFov < 150 then curentFov = curentFov + 6 end
        if keycode == -1 and curentFov > -20 then curentFov = curentFov - 6 end
    end
    
    local topPanel = vgui.Create("DPanel", playerSettingsPanel)
    topPanel:SetSize(AAS.ScrW, AAS.ScrH*0.04)
    topPanel:SetPos(0,0)
    topPanel.Paint = function(self,w,h)
        draw.RoundedBoxEx(0, 0, 0, w, h, AAS.Colors["black18"])

        surface.SetDrawColor(AAS.Colors["white"])
        surface.SetMaterial(AAS.Materials["scale"])
        surface.DrawTexturedRect( w*0.01, h/2-10, 20, 20 )
    end

    AAS.PlayerSettingsModel(itemTable)

    sliderMove(AAS.ScrW*0.13, AAS.ScrH*0.82, playerSettingsPanel, AAS.GetSentence("position"), "pos", itemTable)
    sliderMove(AAS.ScrW*0.34, AAS.ScrH*0.82, playerSettingsPanel, AAS.GetSentence("rotation"), "rotate", itemTable)
    sliderMove(AAS.ScrW*0.55, AAS.ScrH*0.82, playerSettingsPanel, AAS.GetSentence("scale"), "scale", itemTable)

    local closeButton = vgui.Create("DButton", playerSettingsPanel)
    closeButton:SetSize(AAS.ScrW*0.011, AAS.ScrW*0.011)
    closeButton:SetPos(playerSettingsPanel:GetWide()*0.98, AAS.ScrH*0.04/2-closeButton:GetTall()/2) 
    closeButton:SetText("")
    closeButton.Paint = function(self,w,h)
        surface.SetDrawColor(AAS.Colors["white"])
        surface.SetMaterial(AAS.Materials["close"])
        surface.DrawTexturedRect( 0, 0, w, h )
    end  
    closeButton.DoClick = function()
        lerpBack = true
        calcPosE, calcAngE, calcPos, calcAng = AAS.LocalPlayer:EyePos(), AAS.LocalPlayer:GetAngles(), ((AAS.LocalPlayer:GetPos() - (AAS.LocalPlayer:GetAngles():Forward() * -100) + AAS.LocalPlayer:GetAngles():Up() * 100)), (AAS.LocalPlayer:GetAngles() + Angle(0, -180, 0))

        if IsValid(playerSettingsPanel) then
            playerSettingsPanel:AlphaTo( 100, 1, 0, function() 
                if not IsValid(playerSettingsPanel) then return end 
                playerSettingsPanel:Remove()

                AAS.InventoryMenu()
            end)
        end
    end

    local lerpFirstButton = 255
    local firstButton = vgui.Create("DButton", playerSettingsPanel)
    firstButton:SetSize(AAS.ScrW*0.055, AAS.ScrH*0.027)
    firstButton:SetPos(playerSettingsPanel:GetWide()*0.11, AAS.ScrH*0.007)
    firstButton:SetFont("AAS:Font:04")
    firstButton:SetTextColor(AAS.Colors["white"])
    firstButton:SetText(AAS.GetSentence("cancel"))
    firstButton.Paint = function(self,w,h)
        lerpFirstButton = Lerp(FrameTime()*10, lerpFirstButton, self:IsHovered() and 255 or 100)

        draw.RoundedBox(5, 0, 0, w, h, ColorAlpha(AAS.Colors["red49"], lerpFirstButton))
    end 
    firstButton.DoClick = function()
        lerpBack = true
        calcPosE, calcAngE, calcPos, calcAng = AAS.LocalPlayer:EyePos(), AAS.LocalPlayer:GetAngles(), ((AASClientSide:GetPos() - (AASClientSide:GetAngles():Forward() * -100) + AASClientSide:GetAngles():Up() * 100)), (AAS.LocalPlayer:GetAngles() + Angle(0, -180, 0))

        if IsValid(playerSettingsPanel) then
            playerSettingsPanel:AlphaTo( 100, 1, 0, function() 
                if not IsValid(playerSettingsPanel) then return end 
                playerSettingsPanel:Remove()

                AAS.InventoryMenu()
            end)
        end
    end 

    local lerpSecondButton = 255
    local secondButton = vgui.Create("DButton", playerSettingsPanel)
    secondButton:SetSize(AAS.ScrW*0.065, AAS.ScrH*0.027)
    secondButton:SetPos(playerSettingsPanel:GetWide()*0.04, AAS.ScrH*0.007)
    secondButton:SetFont("AAS:Font:04")
    secondButton:SetTextColor(AAS.Colors["white"])
    secondButton:SetText(AAS.GetSentence("save"))
    secondButton.Paint = function(self,w,h)
        lerpSecondButton = Lerp(FrameTime()*10, lerpSecondButton, self:IsHovered() and 255 or 100)

        draw.RoundedBox(5, 0, 0, w, h, ColorAlpha(AAS.Colors["blue77"], lerpSecondButton))
    end
    secondButton.DoClick = function()
        net.Start("AAS:Inventory")
            net.WriteUInt(5, 5)
            net.WriteUInt(itemTable["uniqueId"], 32)
            net.WriteVector(getItemSettings("pos"))
            net.WriteAngle(getItemSettings("rotate"))
            net.WriteVector(getItemSettings("scale"))
        net.SendToServer()
    end
end

function AAS.PlayerSettingsModel(itemTable)
    if IsValid(AASClientSide) then AASClientSide:Remove() end
    if not istable(itemTable["options"]) then itemTable["options"] = {} end

    AASClientSide = ClientsideModel( "models/props_c17/oildrum001_explosive.mdl" )
	AASClientSide:SetPos(AAS.LocalPlayer:LocalToWorld(Vector(0,0,0)))

    local skin = tonumber(itemTable["options"]["skin"])
    if isnumber(skin) then
        AASClientSide:SetSkin(skin)
    end
	AASClientSide:Spawn()

    calcPos, calcAng, calcPosE, calcAngE = AAS.LocalPlayer:EyePos(), AAS.LocalPlayer:GetAngles(), ((AAS.LocalPlayer:GetPos() - (AAS.LocalPlayer:GetAngles():Forward() * -100) + AAS.LocalPlayer:GetAngles():Up() * 100)), (AAS.LocalPlayer:GetAngles() + Angle(0, -180, 0))

    timer.Create("AAS:updateClientSideModel", 0, 0, function()
        if not IsValid(playerSettingsPanel) then AASClientSide:Remove() timer.Remove("AAS:updateClientSideModel") return end 
        if not IsValid(AASClientSide) then timer.Remove("AAS:updateClientSideModel") return end

        local BonePos, BoneAngles
        if isnumber(AAS.LocalPlayer:LookupBone(itemTable["options"]["bone"])) then
            BonePos, BoneAngles = AAS.LocalPlayer:GetBonePosition(AAS.LocalPlayer:LookupBone(itemTable["options"]["bone"]))
        else
            BonePos, BoneAngles = Vector(0,0,0), Angle(0,0,0)
        end

        local newpos = AAS.ConvertVector(BonePos, (getItemSettings("pos") + itemTable["pos"]), BoneAngles)
		local newang = AAS.ConvertAngle(BoneAngles, (getItemSettings("rotate") + itemTable["ang"]))

        AASClientSide:SetPos(newpos)
        AASClientSide:SetRenderOrigin(newpos)
		AASClientSide:SetRenderAngles(newang)
        AASClientSide:SetAngles(newang)
        AASClientSide:FollowBone(AAS.LocalPlayer, 6)
        AASClientSide:SetModel(itemTable["model"])
        AASClientSide:SetPredictable(true)
        AASClientSide:SetColor(itemTable["options"]["color"])

        local mat = Matrix()
        mat:Scale(getItemSettings("scale") / 50 + itemTable["scale"])
        AASClientSide:EnableMatrix("RenderMultiply", mat)
    end)
end

hook.Add( "CalcView", "AAS:CalcView:PlayerSettings", function( ply, pos, angles, fov )
    if not IsValid(playerSettingsPanel) then return end

    local BonePos, BoneAngles
    if isnumber(AAS.LocalPlayer:LookupBone("ValveBiped.Bip01_Head1")) then
        BonePos, BoneAngles = AAS.LocalPlayer:GetBonePosition(AAS.LocalPlayer:LookupBone("ValveBiped.Bip01_Head1"))
    else
        BonePos, BoneAngles = Vector(0,0,0), Angle(0,0,0)
    end

    if not lerpBack then
        calcPos = LerpVector(FrameTime()*5, calcPos, BonePos + Vector(math.cos(curentPosx)*(200 -curentFov),math.sin(curentPosx)*(200 -curentFov),curentPosY))
        calcAng = (pos - calcPos):Angle()
    else
        calcPos = LerpVector(FrameTime()*3, calcPos, calcPosE)
        calcAng = LerpAngle(FrameTime()*3, calcAng, calcAngE)
    end

	local view = {
		origin = calcPos,
		angles = calcAng,
		fov = fov,
		drawviewer = true,
	}

	return view
end)

hook.Add("AAS:ClosePlayerSettingsPanel", "AAS:ClosePlayerSettingsPanel", function()
    lerpBack = true
    calcPosE, calcAngE, calcPos, calcAng = AAS.LocalPlayer:EyePos(), AAS.LocalPlayer:GetAngles(), ((AASClientSide:GetPos() - (AASClientSide:GetAngles():Forward() * -100) + AASClientSide:GetAngles():Up() * 100)), (AAS.LocalPlayer:GetAngles() + Angle(0, -180, 0))

    if IsValid(playerSettingsPanel) then
        playerSettingsPanel:AlphaTo( 100, 1, 0, function() 
            if not IsValid(playerSettingsPanel) then return end 
            playerSettingsPanel:Remove()

            AAS.InventoryMenu()
        end)
    end
end)
--PATH addons/sl_aphone/lua/aphone/_libs/_utilities/cl_pictures.lua:
aphone.GUI = aphone.GUI or {}

// Data Pictures
aphone.Pictures = aphone.Pictures or {}
local dir = "aphone/" .. string.Replace(game.GetIPAddress(), ":", "_") .. "/"

// Functions caching
local material_ = Material
local table_insert = table.insert
local get_extension = string.GetExtensionFromFilename
local string_replace = string.Replace

if table.IsEmpty(aphone.Pictures) then
    for k,v in SortedPairs(select(1, file.Find(dir .. "*", "DATA")) or {}, true) do
        // No need to use smooth there
        local mat = material_("../data/" .. dir .. v)

        if !mat:IsError() then
            table_insert(aphone.Pictures, mat)
        end
    end
end

// Web picture
local webtable = {}
local downloading = {}
function aphone.GUI.WebPicture(name, link, flags)
    local format = link and get_extension(link) or ".jpg"
    local sub_dir = "aphone/link_" .. name .. "." .. format

    if webtable[name] and !webtable[name]:IsError() then
        return webtable[name]
    else
        if !file.Exists(sub_dir, "DATA") then
            // Cooldown - Don't start a lot of downloads
            if downloading[name] then return end
            downloading[name] = true

            http.Fetch(link, function(body)
                file.Write(sub_dir, body)

                timer.Simple(3, function()
                    webtable[name] = Material("../data/" .. sub_dir, flags)
                end)
                downloading[name] = false
            end, function(err)
                timer.Simple(5, function()
                    if err != "unsuccessful" then
                        print("[APhone] - Download failed, link may be dead ? Error : " .. err)
                        downloading[name] = false
                    end
                end)
            end)
        else
            webtable[name] = Material("../data/" .. sub_dir, flags)
            return webtable[name]
        end
    end
end

function aphone.GUI.GetWebPicture(name, link, flags)
    if webtable[name] and !webtable[name]:IsError() then
        return webtable[name]
    end

    return aphone.GUI.WebPicture(name, link, flags)
end

// Imgur

local function add_imgur(url)
    if !url then return end

    id = string_replace( url, "https://i.imgur.com/", "" )
    id = string_replace( id, ".jpg", "" )
    id = string_replace( id, ".jpeg", "" )

    local tbl_settings = aphone.Clientside.GetSetting("Imgur_Links", {})
    table_insert(tbl_settings, 1, id)
    aphone.Clientside.SaveSetting("Imgur_Links", tbl_settings)

    aphone.GUI.WebPicture("Imgur_" .. id, url)
end

function aphone.GetImgurPics()
    return aphone.Clientside.GetSetting("Imgur_Links", {})
end

function aphone.GetImgurMat(imgur_id)
    if !imgur_id then return end
    imgur_id = string_replace(imgur_id, "imgur://", "")

    return aphone.GUI.GetWebPicture("imgur_" .. imgur_id, "https://i.imgur.com/" .. imgur_id .. ".jpg", "smooth 1")
end

function aphone.SendImgur(read_dir)
    http.Post( "https://akulla.dev/aphone/send_imgur.php", {["img"] = util.Base64Encode(file.Read( read_dir, "DATA" ))},
        function( body, length, headers, code )
            if (!string.StartWith(body, "[APhone-PHP]")) then
                // We can do that because my API return directly the imgur id, and not the whole thing we can get with the default imgur request
                add_imgur(body)
            else
                print(body)
            end
            aphone.ImgurUploading = nil
        end,
        function(err)
            print("[APhone] Upload error : " .. err)
            aphone.ImgurUploading = nil
        end
    )
end

// Load imgur pics
hook.Add("aphone_PostLoad", "aphone_LoadClientPictures", function()
    for k, v in ipairs(aphone.GetImgurPics()) do
        aphone.GetImgurMat(v)
    end
end)

hook.Add("aphone_PostLoad", "aphone_LoadBackground", function()
    for k, v in ipairs(aphone.backgrounds_imgur) do
        aphone.GetImgurMat(v)
    end
end)

// Background
local mat_bg = Material("akulla/aphone/phone_bg.jpg")
local bg_value = aphone.GetImgurMat(aphone.Clientside.GetSetting("Background"))

hook.Add("APhone_ChangedBackground", "APhone_GetNewBackground", function()
    bg_value = aphone.GetImgurMat(aphone.Clientside.GetSetting("Background"))
end)

function aphone.GUI.GetBackground()
    return (bg_value and !bg_value:IsError()) and bg_value or mat_bg
end
--PATH addons/sl_aphone/lua/aphone/_libs/banks/sh_glorifiedbanking.lua:
hook.Add("PostGamemodeLoaded", "Aphone_GB", function()
    if GlorifiedBanking then
        local p = FindMetaTable("Player")

        if aphone.Bank then
            print("[APhone] Do you got multiples bank addons ? The last loaded bank will be used for the bank app")
        end

        aphone.Bank = aphone.Bank or {}

        aphone.Bank.clr = Color(5, 116, 179)
        aphone.Bank.logo = Material("glorified_banking/logo_small.png", "smooth 1")
        aphone.Bank.name = "GlorifiedBanking"

        function p:aphone_bankWithdraw(amt)
            if amt < 0 or !self:CanAffordBank(amt) then return end
            self:WithdrawFromBank(amt)
        end

        function p:aphone_bankDeposit(amt)
            if amt < 0 or !aphone.Gamemode.Afford(self, amt) then return end
            self:DepositToBank( amt )
        end

        function p:aphone_bankTransfer(ply2, amt)
            if amt < 0 or !self:CanAffordBank(amt) then return end
            self:TransferBankMoney(ply2, amt)
        end

        function p:aphone_getmoney()
            return self:GetBankBalance()
        end

        function aphone.Bank.FormatMoney(amt)
            return GlorifiedBanking.FormatMoney(amt)
        end
    end
end)
--PATH addons/sl_aphone/lua/aphone/_libs/banks/sh_slownlsatm.lua:
hook.Add("PostGamemodeLoaded", "Aphone_SlownLSATM", function()
    if SlownLS and SlownLS.ATM then
        local p = FindMetaTable("Player")

        if aphone.Bank then
            print("[APhone] Do you got multiples banks addons ? The last loaded bank will be used for the bank app")
        end

        aphone.Bank = aphone.Bank or {}

        aphone.Bank.clr = Color(231, 76, 60)
        aphone.Bank.logo = Material("akulla/aphone/atm.png", "smooth 1")

        function p:aphone_bankWithdraw(amt)
            if amt < 0 or !SlownLS.ATM:CanAfford(self, amt) then return end

            SlownLS.ATM:Withdraw(self:SteamID64(), amt)
            SlownLS.ATM:AddLog(self, "APhone - -" .. amt)
            aphone.Gamemode.AddMoney(self, amt)
        end

        function p:aphone_bankDeposit(amt)
            if amt < 0 or !aphone.Gamemode.Afford(self, amt) then return end

            SlownLS.ATM:Deposit(self:SteamID64(), amt)
            SlownLS.ATM:AddLog(self, "APhone - +" .. amt)
            aphone.Gamemode.AddMoney(self, -amt)
        end

        function p:aphone_bankTransfer(ply2, amt)
            if amt < 0 or !SlownLS.ATM:CanAfford(self, amt) then return end

            SlownLS.ATM:Withdraw(self:SteamID64(), amt)
            SlownLS.ATM:Deposit(ply2:SteamID64(), amt)
            SlownLS.ATM:AddLog(ply2, "APhone - +" .. amt)
            SlownLS.ATM:AddLog(self, "APhone - -" .. amt)
        end

        function p:aphone_getmoney()
            return SERVER and self:GetBankBalance() or LocalPlayer():SlownLS_ATM_Balance()
        end

        function aphone.Bank.FormatMoney(amt)
            return aphone.Gamemode.Format(amt)
        end
    end
end)
--PATH addons/sl_aphone/lua/aphone/_libs/printers/sh_elegantprinters.lua:
hook.Add("PostGamemodeLoaded", "APhone_LoadPrinter_ElegantPrinters", function()
    if scripted_ents.Get("sent_elegant_printer") then
        aphone.Printer = aphone.Printer or {}

        function aphone.Printer.GetPrinters(ply)
            local tbl = {}

            for k, v in ipairs(ents.FindByClass("sent_elegant_printer")) do
                if v:CPPIGetOwner() == ply or v:Getowning_ent() == ply then
                    table.insert(tbl, v)
                end
            end

            return tbl
        end

        function aphone.Printer.FormatMoney(amt)
            return DarkRP.formatMoney(amt)
        end

        function aphone.Printer.GetInfo(ents)
            local capacity = 0
            local money = 0
            local sec = 0
            local danger = 0

            for k, v in ipairs(ents) do
                if IsValid(v) then
                    money = money + v:GetMoney()
                    capacity = capacity + v.MaxMoney

                    if v:GetMoney() < v.MaxMoney then
                        sec = sec + v.PrintAmount
                    end

                    danger = danger + (v:GetExploding() and 1 or 0)
                else
                    ents[k] = nil
                end
            end

            return {
                [1] = {
                    val = money,
                    name = "money",
                },

                [2] = {
                    val = sec,
                    name = "sec",
                },

                [3] = {
                    val = capacity,
                    name = "capacity",
                },

                [4] = {
                    val = danger,
                    name = "danger",
                },
            }, ents
        end
    end
end)
--PATH addons/sl_aphone/lua/aphone/_libs/printers/sh_sprinter.lua:
hook.Add("PostGamemodeLoaded", "Aphone_SPrinter", function()
    if sPrinter then
        aphone.Printer = aphone.Printer or {}

        function aphone.Printer.GetPrinters(ply)
            local tbl = {}
    
            for k, ent in ipairs(ents.FindByClass("sprinter_*") or {}) do
                local owner = ent.Getowning_ent and ent:Getowning_ent() or nil

                if IsValid(ent:GetParent()) and ent:GetParent():GetClass() == "sprinter_rack" then
                    owner = ent:GetParent():Getowning_ent()
                end

                if !IsValid(ent) or !IsValid(owner) or owner != ply then continue end

                table.insert(tbl, ent)
            end
    
            return tbl
        end
    
        function aphone.Printer.FormatMoney(amt)
            return aphone.Gamemode.Format(amt)
        end
    
        function aphone.Printer.GetInfo(ents)
            local capacity = 0
            local money = 0
            local sec = 0
            local danger = 0
    
            for k, v in pairs(ents) do
                if IsValid(v) and v:GetClass() != "sprinter_rack" then
                    if !v.GetBattery or v:GetBattery() <= 0 or !v:GetPower() then continue end
    
                    money = money + v:GetMoney()
                    capacity = capacity + v.data.maxstorage
    
                    if v.data.maxstorage > v:GetMoney() then
                        sec = sec + (v.data.baseincome * (v:GetUpgrade("overclocking") + v.data.clockspeed)) * 6
                    end
    
                    local temp = v:GetTemperature()
                    local rack = v:GetRack()
    
                    if IsValid(rack) then
                        local racktemp = 0
                        if rack:GetSkin() == 1 then
                            racktemp = math.random(10, 15)
                        else
                            racktemp = math.random(25, 40)
                        end
    
                        if rack.printers then
                            racktemp = racktemp + (racktempsplit * table.Count(rack.printers))
                        end
    
                        temp = temp + racktemp
                    end
    
                    danger = danger + (v:GetTemperature() > 80 and 1 or 0)
                else
                    ents[k] = nil
                end
            end
    
            return {
                [1] = {
                    val = money,
                    name = "money",
                },
    
                [2] = {
                    val = sec,
                    name = "sec",
                },
    
                [3] = {
                    val = capacity,
                    name = "capacity",
                },
    
                [4] = {
                    val = danger,
                    name = "danger",
                },
            }, ents
        end
    end
end)
--PATH addons/sh_reports/lua/reports/cl_main.lua:
if (!SH_REPORTS.ActiveReports) then
	SH_REPORTS.ActiveReports = {}
end

function SH_REPORTS:ReportCreated(data)
	chat.AddText(self.Style.header, "[" .. self:L("reports") .. "] ", color_white, self:L("report_received", data.reporter_name, data.reported_name, self.ReportReasons[data.reason_id])) -- 76561199385207498

	if (self.NewReportSound.enabled) then
		surface.PlaySound(self.NewReportSound.path)
	end

	self:MakeNotification(data)
	self:MakePending(data)

	if (!self.ActiveReports) then
		self.ActiveReports = {}
	end
	table.insert(self.ActiveReports, data)
end

hook.Add("Think", "SH_REPORTS.Ready", function()
	if (IsValid(LocalPlayer())) then
		hook.Remove("Think", "SH_REPORTS.Ready")
		easynet.SendToServer("SH_REPORTS.PlayerReady")
	end
end)

easynet.Callback("SH_REPORTS.SendList", function(data)
	local pendings = {}
	for _, report in pairs (SH_REPORTS.ActiveReports) do
		if (IsValid(report.pending)) then
			pendings[report.id] = report.pending
		end
	end

	SH_REPORTS.ServerTime = data.server_time
	SH_REPORTS.ActiveReports = data.struct_reports

	for _, report in pairs (SH_REPORTS.ActiveReports) do
		report.pending = pendings[report.id]
	end
	
	SH_REPORTS:ShowReports()
end)

easynet.Callback("SH_REPORTS.MinimizeReport", function(data)
	if (IsValid(_SH_REPORTS_VIEW)) then
		_SH_REPORTS_VIEW:Close()
	end

	local report
	for _, rep in pairs (SH_REPORTS.ActiveReports) do
		if (rep.id == data.report_id) then
			report = rep
			break
		end
	end

	if (report) then
		SH_REPORTS:MakeTab(report)
	end
end)

easynet.Callback("SH_REPORTS.ReportClosed", function(data)
	for k, rep in pairs (SH_REPORTS.ActiveReports) do
		if (rep.id == data.report_id) then
			if (IsValid(rep.line)) then
				rep.line:Close()
			end

			if (IsValid(rep.pending)) then
				rep.pending:Close()
			end

			SH_REPORTS.ActiveReports[k] = nil
		end
	end

	if (IsValid(_SH_REPORTS_TAB) and _SH_REPORTS_TAB.id == data.report_id) then
		_SH_REPORTS_TAB:Close()
	end

	SH_REPORTS:ClosePendingPanel(data.report_id)
end)

easynet.Callback("SH_REPORTS.ReportClaimed", function(data)
	for _, rep in pairs (SH_REPORTS.ActiveReports) do
		if (rep.id == data.report_id) then
			rep.admin_id = data.admin_id

			if (IsValid(rep.line)) then
				rep.line.claimed.avi:SetSteamID(data.admin_id)
				rep.line.claimed.avi:SetVisible(true)

				local admin = player.GetBySteamID64(data.admin_id)
				if (IsValid(admin)) then
					rep.line.claimed.name:SetTextInset(32, 0)
					rep.line.claimed.name:SetContentAlignment(4)
					rep.line.claimed.name:SetText(admin:Nick())
				end
			end

			if (IsValid(rep.pending)) then
				rep.pending:Close()
			end

			if (data.admin_id ~= LocalPlayer():SteamID64() and IsValid(rep.line) and IsValid(rep.line.delete)) then
				rep.line.delete:Remove()
			end
		end
	end

	SH_REPORTS:ClosePendingPanel(data.report_id)
end)

easynet.Callback("SH_REPORTS.Notify", function(data)
	-- do NOT do this
	SH_REPORTS:Notify(SH_REPORTS:L(unpack(string.Explode("\t", data.msg))), nil, data.positive and SH_REPORTS.Style.success or SH_REPORTS.Style.failure)
end)

easynet.Callback("SH_REPORTS.Chat", function(data)
	chat.AddText(SH_REPORTS.Style.header, "[" .. SH_REPORTS:L("reports") .. "] ", color_white, data.msg)
end)

easynet.Callback("SH_REPORTS.ReportCreated", function(data)
	SH_REPORTS:ReportCreated(data)
end)

easynet.Callback("SH_REPORTS.ReportsPending", function(data)
	chat.AddText(SH_REPORTS.Style.header, "[" .. SH_REPORTS:L("reports") .. "] ", color_white, SH_REPORTS:L("there_are_x_reports_pending", data.num)) -- 76561199385207507

	SH_REPORTS.ActiveReports = table.Copy(data.struct_reports)

	for _, report in pairs (SH_REPORTS.ActiveReports) do
		SH_REPORTS:MakePending(report)
	end
end)

easynet.Callback("SH_REPORTS.AdminLeft", function(data)
	for _, rep in pairs (SH_REPORTS.ActiveReports) do
		if (rep.id == data.report_id) then
			rep.admin_id = ""

			if (IsValid(rep.line)) then
				rep.line.claimed.avi:SetVisible(false)

				rep.line.claimed.name:SetTextInset(0, 0)
				rep.line.claimed.name:SetContentAlignment(5)
				rep.line.claimed.name:SetText(SH_REPORTS:L("unclaimed"))
			end
		end
	end
end)
--PATH lua/drgbase/wrappers.lua:

-- Wrapper --

local entMETA = FindMetaTable("Entity")

local WRAPPERS = {}
local function NewWrapper(wrapper, ent)
	WRAPPERS[wrapper] = WRAPPERS[wrapper] or {}
	if not WRAPPERS[wrapper][ent] then
		local self = {}
		setmetatable(self, {__index = function(self, key)
			if key == "Wrapper" then return true
			elseif key == "Entity" then return ent
			elseif wrapper[key] ~= nil then return wrapper[key]
			elseif IsValid(ent) and ent:GetTable()[key] ~= nil then
				local val = ent:GetTable()[key]
				if isfunction(val) then
					return function(self, ...)
						return val(ent, ...)
					end
				else return val end
			elseif entMETA[key] ~= nil then
				local val = entMETA[key]
				if isfunction(val) then
					return function(self, ...)
						return val(ent, ...)
					end
				else return val end
			end
		end})
		WRAPPERS[wrapper][ent] = self
		return self
	else return WRAPPERS[wrapper][ent] end
end

local DEFAULT_WRAPPER = {}
function entMETA:DrG_Wrap()
	if SERVER then
		if self:DrG_IsDoor() then
			return DrGBase.WrapDoor(self)
		end
	end
	return NewWrapper(DEFAULT_WRAPPER, self)
end

if SERVER then

	-- Doors --

	local Door = {}
	Door.__index = Door
	function Door:New(ent)
		return NewWrapper(self, ent)
	end

	function Door:GetDouble()
		if not IsValid(self) then return NULL end
		local keyvalues = self:GetKeyValues()
		if isstring(keyvalues.slavename) then
			return ents.FindByName(keyvalues.slavename)[1]
		end
	end
	function Door:IsDouble()
		return IsValid(self:GetDouble())
	end

	function Door:Open(ent)
		if not IsValid(self) then return end
		if IsValid(ent) then
			local name = ent:GetName()
			self:Fire("OpenAwayFrom", name)
			if self:IsDouble() then
				self:GetDouble():Fire("OpenAwayFrom", name)
			end
		else
			self:Fire("Open")
			if self:IsDouble() then
				self:GetDouble():Fire("Open")
			end
		end
	end
	function Door:Close()
		if not IsValid(self) then return end
		self:Fire("Close")
		if self:IsDouble() then
			self:GetDouble():Fire("Close")
		end
	end

	function Door:GetSpeed()
		if not IsValid(self) then return -1 end
		return self:GetKeyValues()["speed"]
	end
	function Door:SetSpeed(speed)
		if not IsValid(self) then return end
		self:Fire("SetSpeed", speed)
		if self:IsDouble() then
			self:GetDouble():Fire("SetSpeed", speed)
		end
	end

	function DrGBase.WrapDoor(ent)
		return Door:New(ent)
	end

	-- CombineBall --

	local CombineBall = {}
	CombineBall.__index = CombineBall
	function CombineBall:New(ent)
		return NewWrapper(CombineBall, ent)
	end

	function CombineBall:Explode()
		self:Fire("Explode")
	end

end

--PATH lua/drgbase/modules/timer.lua:
function timer.DrG_Simple(delay, callback, ...)
	local args, n = table.DrG_Pack(...)
	timer.Simple(delay, function()
		callback(table.DrG_Unpack(args, n))
	end)
end

function timer.DrG_Loop(delay, callback, ...)
	local args, n = table.DrG_Pack(...)
	timer.Simple(delay, function()
		local res = callback(table.DrG_Unpack(args, n))
		if res == false then return end
		if isnumber(res) then
			timer.DrG_Loop(res, callback, table.DrG_Unpack(args, n))
		else timer.DrG_Loop(delay, callback, table.DrG_Unpack(args, n)) end
	end)
end

--PATH addons/sm_weapon_selector/lua/eliteswephud/cl_hud.lua:
--[[
    Addon : EliteWeaponSelector
    By : Esteb
    Support : !Esteb.#6666
    Version : 2.0
--]]
--[[
╔═╗╔═╗╔═╗  ╔╦╗╔═╗  ╔═╗╔═╗╔╗╔╔═╗╦╔═╗  ╦╔═╗╦
╠═╝╠═╣╚═╗   ║║║╣   ║  ║ ║║║║╠╣ ║║ ╦  ║║  ║
╩  ╩ ╩╚═╝  ═╩╝╚═╝  ╚═╝╚═╝╝╚╝╚  ╩╚═╝  ╩╚═╝╩
--]]
-- Optimisation
local surface = surface
local draw = draw
local timer = timer
local Lerp = Lerp
local LocalPlayer = LocalPlayer

-- HUD
local hud = {
    -- Slots général
    slotSelected = 0,
    slotIndex = 1,
    slotDraw = false,
    slotWeapon = "",
    lastWeapon = "",
    recordLastWep = false,
    slotIcon = "",
    slotMaterials = {},
    drawAlpha = 0,
    slotBinds = {},
    -- HUD POSITION
    selectionW = 0,
    totalW = 0,
    posX = 0,
    -- Outline
    outlineX = 0,
    outlineY = 0,
    outlineW = 0,
    outlineH = 0,
    -- Invisible
    noDraw = {
        ["CHudWeaponSelection"] = true
    }
}

function hud:SelectWeapon(wep)
    RunConsoleCommand("use", wep)
end

function hud:EnableDrawing()
    local lp = LocalPlayer()
    if lp:InVehicle() then return end

    if (timer.Exists("eliteswephud_linger")) then
        timer.Remove("eliteswephud_linger")
    end

    timer.Create("eliteswephud_linger", eliteswephud_config.lingerDuration, 1, function()
        self.slotDraw = false
    end)

    self.slotDraw = true
end

function hud:GetWeaponsInSlot(iSlot)
    local weps = {}

    for k, v in next, LocalPlayer():GetWeapons() do
        local slot = 1

        if (v.Slot) then
            slot = v.Slot + 1
        elseif (v.BaseClass) then
            if (v.BaseClass.Slot) then
                slot = v.BaseClass.Slot + 1
            end
        end

        if (slot == iSlot) then
            weps[#weps + 1] = v
        end
    end

    return weps
end

function hud:Draw()
    if (self.slotDraw) then
        self.drawAlpha = Lerp(0.1, self.drawAlpha, 245)
    elseif (self.drawAlpha > 1) then
        self.drawAlpha = Lerp(0.1, self.drawAlpha, 0)
    end

    eliteswephud_config.bgSelectedColor.a = self.drawAlpha
    eliteswephud_config.bgNonSelectedColor.a = self.drawAlpha
    eliteswephud_config.bgSelectedOutline.a = self.drawAlpha
    eliteswephud_config.textSelectedColor.a = self.drawAlpha
    eliteswephud_config.textNonSelectedColor.a = self.drawAlpha

    if (self.drawAlpha > 1) then
        local wepsInSlot = self:GetWeaponsInSlot(self.slotSelected)
        local cW = self.selectionW / 4

        for i = 1, 6 do
            if (i == self.slotSelected) then continue end
            surface.SetDrawColor(eliteswephud_config.bgNonSelectedColor)
            surface.DrawRect(self.posX + self.selectionW * (i - 1) - cW / 2, eliteswephud_config.originY, cW, eliteswephud_config.bgH)
            draw.SimpleTextOutlined(tostring(i) .. ".", "eliteswephud_font", self.posX + self.selectionW * (i - 1), eliteswephud_config.originY + eliteswephud_config.bgH / 2, eliteswephud_config.textNonSelectedColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(0, 0, 0, self.drawAlpha))
        end

        for k, v in next, wepsInSlot do
            local bgColor
            local color

            if (k == self.slotIndex) then
                color = eliteswephud_config.textSelectedColor
                bgColor = eliteswephud_config.bgSelectedColor
            else
                bgColor = eliteswephud_config.bgNonSelectedColor
                color = eliteswephud_config.textNonSelectedColor
            end

            surface.SetFont("eliteswephud_font")
            local cW = self.selectionW
            local tW, tH = surface.GetTextSize(v:GetPrintName())
            tW = tW + 20

            if (tW > cW) then
                cW = tW
            end

            local cX = self.posX + self.selectionW * (self.slotSelected - 1)
            local cY = eliteswephud_config.originY + (k - 1) * eliteswephud_config.bgH
            surface.SetDrawColor(bgColor)
            surface.DrawRect(cX - cW / 2, cY, cW, eliteswephud_config.bgH)

            if (k == self.slotIndex) then
                self.outlineX = cX - cW / 2
                self.outlineY = cY
                self.outlineW = cW
                self.outlineH = eliteswephud_config.bgH

                if (self.slotIcon ~= "") then
                    surface.SetMaterial(self.slotMaterials[self.slotIcon])
                    surface.SetDrawColor(Color(255, 255, 255, self.drawAlpha))
                    surface.DrawTexturedRect(cX + cW / 2 + 5, cY - 5, 35, 35)
                end
            end

            draw.SimpleTextOutlined(v:GetPrintName(), "eliteswephud_font", cX, cY + eliteswephud_config.bgH / 2, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(0, 0, 0, self.drawAlpha))
        end

        if (#wepsInSlot == 0) then
            self.outlineX = self.posX + self.selectionW * (self.slotSelected - 1) - self.selectionW / 2
            self.outlineY = eliteswephud_config.originY
            self.outlineW = self.selectionW
            self.outlineH = eliteswephud_config.bgH
            surface.SetDrawColor(eliteswephud_config.bgSelectedColor)
            surface.DrawRect(self.posX + self.selectionW * (self.slotSelected - 1) - self.selectionW / 2, eliteswephud_config.originY, self.selectionW, eliteswephud_config.bgH)
            draw.SimpleTextOutlined(eliteswephud_config.emptySlotText, "eliteswephud_font", self.posX + self.selectionW * (self.slotSelected - 1), eliteswephud_config.originY + eliteswephud_config.bgH / 2, eliteswephud_config.textSelectedColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(0, 0, 0, drawAlpha))
        end

        surface.SetDrawColor(eliteswephud_config.bgSelectedOutline)
        surface.DrawOutlinedRect(self.outlineX, self.outlineY, self.outlineW, self.outlineH)
    end
end

function hud:PlayerBindPress(ply, bind, bPressed)
    local oldSlotIndex = self.slotIndex
    local oldSlotSelected = self.slotSelected

    if (bind == "lastinv") then
        if (IsValid(LocalPlayer():GetActiveWeapon())) then
            self:SelectWeapon(self.lastWeapon)
            local buffer = self.lastWeapon
            self.lastWeapon = self.slotWeapon
            self.slotWeapon = buffer

            return
        end
    end

    -- Base 
    if (bind == "+attack" and self.slotDraw) then
        local wepsInSlot = self:GetWeaponsInSlot(self.slotSelected)

        if (#wepsInSlot > 0) then
            self.lastWeapon = self.slotWeapon
            self.slotWeapon = self:GetWeaponsInSlot(self.slotSelected)[self.slotIndex]:GetClass()
            self:SelectWeapon(self.slotWeapon)

            if (timer.Exists("eliteswephud_linger")) then
                timer.Remove("eliteswephud_linger")
            end

            self.slotDraw = false
            surface.PlaySound(eliteswephud_config.weaponSelectedSound)
        end

        return true
    end

    if (input.IsMouseDown(MOUSE_LEFT)) then return end

    -- changer de slots par numéro
    if (self.slotBinds[bind]) then
        local slot = self.slotBinds[bind]

        if (self.slotSelected ~= slot) then
            self.slotSelected = slot
            self.slotIndex = 1
        else -- même emplacement mais sans le même emplacement 
            self.slotIndex = self.slotIndex + 1

            if (self.slotIndex > #self:GetWeaponsInSlot(self.slotSelected)) then
                self.slotIndex = 1
            end
        end
    elseif (bind == "invnext") then
        self.slotIndex = self.slotIndex + 1

        -- move to the next slot 
        if (self.slotIndex > #self:GetWeaponsInSlot(self.slotSelected)) then
            self.slotSelected = self.slotSelected + 1
            self.slotIndex = 1

            -- cycle back to 1 
            if (self.slotSelected > 6) then
                self.slotSelected = 1
            end
        end
    elseif (bind == "invprev") then
        self.slotIndex = self.slotIndex - 1

        -- move to the next slot 
        if (self.slotIndex < 1) then
            self.slotSelected = self.slotSelected - 1
            self.slotIndex = #self:GetWeaponsInSlot(self.slotSelected)

            -- cycle back to 1 
            if (self.slotSelected < 1) then
                self.slotSelected = 6
                self.slotIndex = #self:GetWeaponsInSlot(self.slotSelected)
            end
        end
    end

    local lp = LocalPlayer()
    if lp:InVehicle() then return end

    if (self.slotIndex ~= oldSlotIndex or self.slotSelected ~= oldSlotSelected) then
        self:EnableDrawing()
        surface.PlaySound(eliteswephud_config.slotChangeSound)
        local wep = self:GetWeaponsInSlot(self.slotSelected)[self.slotIndex]

        -- if the weapon is valid..
        if (IsValid(wep)) then
            local files = file.Find("" .. wep:GetClass() .. ".vtf", "GAME") -- find its spawn icon

            if (#files > 0) then
                self.slotIcon = "vgui/entities/" .. files[1] -- use this for determining wether to draw or not 

                -- make a material as we haven't made one yet
                if (self.slotMaterials[self.slotIcon] == nil) then
                    self.slotMaterials[self.slotIcon] = Material(self.slotIcon)
                end
            else
                self.slotIcon = ""
            end
        end
    end
end

function hud:NoDraw(name)
    if (self.noDraw[name]) then return false end
end

function hud:Init()
    -- Création de la police
    surface.CreateFont("eliteswephud_font", {
        font = eliteswephud_config.baseFont,
        extended = false,
        size = eliteswephud_config.baseSizeFont,
        weight = 500,
        blursize = 0,
        scanlines = 0,
        antialias = true,
        underline = false,
        italic = false,
        strikeout = false,
        symbol = false,
        rotary = false,
        shadow = false,
        additive = false,
        outline = false
    })

    -- Définir les slots
    self.slotBinds["slot1"] = 1
    self.slotBinds["slot2"] = 2
    self.slotBinds["slot3"] = 3
    self.slotBinds["slot4"] = 4
    self.slotBinds["slot5"] = 5
    self.slotBinds["slot6"] = 6
    -- Calculer la position
    self.selectionW = ScrW() / 10
    self.totalW = self.selectionW * 6
    self.posX = ScrW() / 2 - self.totalW / 2 + self.selectionW / 2

    -- HUDPaint Hook
    hook.Add("HUDPaint", "eliteswephud_draw", function()
        self:Draw()
    end)

    -- Bind
    hook.Add("PlayerBindPress", "eliteswephud_bindpress", function(ply, bind, bPressed)
        local result = self:PlayerBindPress(ply, bind, bPressed)
        if (result ~= nil) then return result end
    end)

    -- Hook HUD
    hook.Add("HUDShouldDraw", "eliteswephud_nodraw", function(name)
        local result = hud:NoDraw(name)
        if (result ~= nil) then return result end
    end)
end

hud:Init()
--PATH addons/sl_util_wallet/lua/ezwallet/shared/animation.lua:

-- Returns the sequence name of the viewmodel
function easzy.wallet.GetViewModelAnimationName(ply)
    if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end

    local viewModel = ply:GetViewModel()
    if not IsValid(viewModel) then return end

    local sequence = viewModel:GetSequence()
    local sequenceName = viewModel:GetSequenceName(sequence)

    return sequenceName
end

-- Plays an animation on the viewmodel by its name
function easzy.wallet.AnimViewModel(ply, name, rate)
    if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end

    local viewModel = ply:GetViewModel()
    if not IsValid(viewModel) then return end

    local sequence, duration = viewModel:LookupSequence(name)
    if sequence == -1 or duration == 0 then return end

    -- In order not to restart the sequence
    if viewModel:GetSequence() == sequence and viewModel:GetPlaybackRate() == rate then return end

    viewModel:SendViewModelMatchingSequence(sequence)
    viewModel:SetPlaybackRate(rate or 1)

    return math.abs(duration/rate)
end

-- Plays multiple animations on the viewmodel and calls a callback at the end of each animation
function easzy.wallet.AnimViewModelSequence(ply, animationsList, time)
    if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end

    local viewModel = ply:GetViewModel()
    if not IsValid(viewModel) then return end

    -- Used to stop the previous sequence when a new one is started
    local time = time or CurTime()
    viewModel:SetVar("ezwallet_lastAnimationsSequence", time)

    local animation = animationsList[1]
    if not animation then return end

    local duration = easzy.wallet.AnimViewModel(ply, animation.name, animation.rate)
    if not duration then duration = 0 end

    local delay = duration + (animation.delay or 0)

    timer.Simple(delay, function()
        if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end

        local lastAnimationsSequence = viewModel:GetVar("ezwallet_lastAnimationsSequence") or 0
        if #animationsList == 0 or lastAnimationsSequence > time then
            return
        end

        if animation.callback then
            local result = animation.callback(ply)
            if result == -1 then return end
        end
        table.remove(animationsList, 1)

        easzy.wallet.AnimViewModelSequence(ply, animationsList, time)
    end)
end


--PATH addons/sl_util_wallet/lua/ezwallet/shared/wallet.lua:


if CLIENT then
    -- Toggle screen clicker when pressing use with wallet in hands
    hook.Add("PlayerButtonDown", "ezwallet_toggle_screen_clicker_PlayerButtonDown", function(ply, key)
        local isWalletActive, _ = easzy.wallet.IsWeaponActive(ply, "ez_wallet_wallet")
        if isWalletActive and key == KEY_E then
            easzy.wallet.ToggleScreenClicker()
        end
    end)

    -- Give the item when clicking on it
    hook.Add("VGUIMousePressed", "ezwallet_give_item_VGUIMousePressed", function(_, mouseCode)
        local localPlayer = LocalPlayer()
        local isWalletActive, wallet = easzy.wallet.IsWeaponActive(localPlayer, "ez_wallet_wallet")

        if not isWalletActive or mouseCode != MOUSE_LEFT then return end

        local hoveredItem = wallet:GetVar("hoveredItem")
        local hoveredItemConfig = easzy.wallet.walletItemsConfig[hoveredItem]
        if hoveredItemConfig then
            net.Start("ez_wallet_give_item")
            net.WriteString(hoveredItem)
            net.SendToServer()
        end
    end)

    -- Disable screen clicker when switching from wallet to another weapon
    hook.Add("PlayerSwitchWeapon", "ezwallet_screen_clicker_PlayerSwitchWeapon", function(ply, oldWeapon, newWeapon)
        if not IsValid(oldWeapon) then return end
        local oldWeaponClass = oldWeapon:GetClass()
        if oldWeaponClass == "ez_wallet_wallet" then
            gui.EnableScreenClicker(false)
            GUIToggled = false
        end
    end)
else
    util.AddNetworkString("ez_wallet_give_item")
    util.AddNetworkString("ez_wallet_hover_item")

    -- Verify if we can cut the current wallet animation
    local function CanCutWalletAnimation(ply)
        local animationsWeCanCut = {
            ["idle"] = true,
            ["banknote_slide"] = true,
            ["credit_card_slide"] = true,
            ["id_card_slide"] = true,
            ["driver_license_slide"] = true,
            ["weapon_license_slide"] = true,
        }
        local currentAnim = easzy.wallet.GetViewModelAnimationName(ply)
        return animationsWeCanCut[currentAnim]
    end

    local function GiveItemMe(ply, itemName)
        if not easzy.wallet.config.itemMe then return end
        ply:Say("/me" .. " " .. easzy.wallet.languages.takeOut .. " " .. string.lower(itemName) .. ".")
    end

    -- Give a the wanted item to the player and disable screen clicker
    net.Receive("ez_wallet_give_item", function(len, ply)
        if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end
        local isWalletActive, _ = easzy.wallet.IsWeaponActive(ply, "ez_wallet_wallet")
        if not isWalletActive then return end
        if not CanCutWalletAnimation(ply) then return end

        local baseTexture = net.ReadString()
        local itemConfig = easzy.wallet.walletItemsConfig[baseTexture]
        if not itemConfig or not itemConfig.ent or not itemConfig.take then return end

        local function HideItemBodygroup(ply)
            local isWalletActive, wallet = easzy.wallet.IsWeaponActive(ply, "ez_wallet_wallet")
            if not isWalletActive then return end

            local viewModel = ply:GetViewModel()
            if not IsValid(viewModel) then return end

            if viewModel:GetModel() != wallet:GetWeaponViewModel() then return end

            wallet.bodygroupsList[itemConfig.bodygroup] = "blank"
            wallet:UpdateBodygoups()
        end

        local function GiveItem(ply)
            local item = easzy.wallet.GiveWeapon(ply, itemConfig.ent)
            if not IsValid(item) then return end

            GiveItemMe(ply, itemConfig.walletText)

            -- Set the base texture of the chosen card
            if itemConfig.ent == "ez_wallet_card" then
                item:UpdateBaseTexture(baseTexture)
            end
        end

        local function SetSideIfCard(ply)
            local isCardActive, card = easzy.wallet.IsWeaponActive(ply, "ez_wallet_card")
            if not isCardActive then return -1 end
            card:SetSide("front")
        end

        local animationsList = {
            {name = itemConfig.take, rate = 1, callback = HideItemBodygroup},
            {name = "take_out", rate = -1, callback = GiveItem},
            {name = "take_out", rate = 1},
            {name = "idle_front", rate = 1, callback = SetSideIfCard}
        }

        easzy.wallet.AnimViewModelSequence(ply, animationsList)
    end)

    -- Plays the slide animation when an item is hovered
    net.Receive("ez_wallet_hover_item", function(len, ply)
        if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end
        local isWalletActive, _ = easzy.wallet.IsWeaponActive(ply, "ez_wallet_wallet")
        if not isWalletActive then return end
        if not CanCutWalletAnimation(ply) then return end

        local baseTexture = net.ReadString()

        -- Idle
        if baseTexture == "" then
            easzy.wallet.AnimViewModel(ply, "idle", 1)
            return
        end

        -- Item slide
        local itemConfig = easzy.wallet.walletItemsConfig[baseTexture]
        if not itemConfig or not itemConfig.slide then return end
        easzy.wallet.AnimViewModel(ply, itemConfig.slide, 1)
    end)
end

--PATH addons/gmodadminsuite-config-master/lua/gmodadminsuite_lua_functions.lua:
--[[

	    __                   ______                 __  _                 
	   / /   __  ______ _   / ____/_  ______  _____/ /_(_)___  ____  _____
	  / /   / / / / __ `/  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
	 / /___/ /_/ / /_/ /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  ) 
	/_____/\__,_/\__,_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/  
	                                                                      

	Welcome to the Lua functions config.
	GmodAdminSuite has been designed to be as customizable as possible.
	In this configuration, you can define custom Lua functions which GmodAdminSuite can use.
	You'll find ways of integrating these Lua functions with GmodAdminSuite modules.

	More information on using GmodAdminSuite Lua functions can be found in module wikis.

]]

GAS.LuaFunctions = {
	["example_function"] = function(ply)
		if (ply:SteamID() == "STEAM_0:1:40314158" or ply:SteamID64() == "76561198112561190") then
			return true -- allow!
		elseif (ply:SteamID() == "STEAM_0:1:7099") then
			return false -- disallow!
		else
			return -- ignore!
		end
	end,
}

-- Do not delete the following line; your config will break.
return true
--PATH lua/gmodadminsuite/lang/chinese.lua:
return {
    Name = "Chinese",
    Flag = "flags16/cn.png",
    Phrases = function()
        return {
            open_menu = "打开菜单",
            menu_nopermission = "对不起，您没有权限访问GmodAdminSuite菜单。",
            menu_unknown_module = "对不起，该名称的模块未安装或不存在。",
            menu_disabled_module = "对不起，该模块已禁用。",
            menu_module_nopermission = "对不起，您没有权限访问此模块。",
            open_gas = "打开GmodAdminSuite",
            module_shortcut = "模块快捷方式",
            module_reset_data = "重置模块位置/大小",
            module_shortcut_info = [[
                您可以通过控制台和聊天命令快速访问此GmodAdminSuite模块。

                通过控制台访问模块，请输入：%s
                通过聊天访问模块，请输入：%s

                此外，您可以将键盘上的键绑定到特定模块。
                要做到这一点，请在控制台中输入：%s

                请确保将KEY替换为您选择的键盘上的键。
            %s]],
            close = "关闭",
            wiki = "维基",
            licensee = "许可证持有者",
            support = "支持",
            module_shop = "模块商店",
            welcome = "欢迎",
            operator = "操作员",
            script_page = "脚本页面",
            no_modules_available = "没有可用的模块！",
            no_modules_available_info = [[
                对不起，没有可供您使用的GmodAdminSuite模块。
		        您可能没有足够的权限使用任何模块，或者没有启用任何模块。
            ]],
            custom_ellipsis = "自定义...",
            usergroup_ellipsis = "用户组...",
            steamid_ellipsis = "SteamID...",
            enter_steamid_ellipsis = "输入SteamID...",
            by_distance = "按距离",
            by_usergroup = "按用户组",
            by_team = "按团队",
            by_name = "按名称",
            right_click_to_focus = "右键点击聚焦",
            unknown = "未知",
            utilities = "实用工具",
            player_management = "玩家管理",
            administration = "管理",
            s_second = "1秒",
            s_seconds = "%d秒",
            s_minute = "1分钟",
            s_minutes = "%d分钟",
            s_hour = "1小时",
            s_hours = "%d小时",
            second_ago = "1秒前",
            seconds_ago = "%d秒前",
            minute_ago = "1分钟前",
            minutes_ago = "%d分钟前",
            hour_ago = "1小时前",
            hours_ago = "%d小时前",
            just_now = "刚刚",
            click_to_focus = "点击聚焦",
            add_steamid = "自定义SteamID",
            copied = "已复制！",
            settings = "设置",
            add_steamid_help = [[
                输入SteamID或SteamID64。例如：
                SteamID：%s
                SteamID64：%s
            ]],

            setting_default_module = "默认模块",
            setting_default_module_tip = "打开GmodAdminSuite主菜单时应打开哪个模块？",
            none = "无",
            general = "通用",
            localization = "本地化",
            setting_menu_voicechat = "打开GAS菜单时允许语音聊天",
            setting_menu_voicechat_tip = "GmodAdminSuite的菜单不会阻止您的语音聊天键。如果此选项开启，只需按下您的语音聊天键即可在菜单中进行交谈。",
            use_gas_language = "使用GmodAdminSuite语言",
            default_format = "默认格式",
            short_date_format = "短日期格式",
            long_date_format = "长日期格式",
            short_date_format_tip = "用于较短日期格式的日期格式\n\n默认格式会自动匹配您所在地区的日期格式（北美、欧洲等）",
            long_date_format_tip = "用于较长日期格式的日期格式",
            permissions = "权限",
            module_enable_switch_tip = "此更改只会在服务器重启/地图更改后应用",
            enabled = "已启用",
            modules = "模块",
            permissions_help = [[
                GmodAdminSuite使用了一个名为OpenPermissions的开源权限库，由Billy为GAS开发。它为任何大小的服务器上运行的高级系统提供了优化的权限处理。
		
                OpenPermissions是您将控制哪些组可以访问哪些模块以及他们可以对这些模块做什么的地方。
                您可以随时通过在聊天中输入"!openpermissions"或在控制台中输入"openpermissions"来打开它。

                需要帮助和信息，请点击OpenPermissions菜单中的"帮助"标签。
            ]],
            website = "网站",
            fun = "权限",

            bvgui_copied = "已复制！",
            bvgui_open_context_menu = "打开上下文菜单",
            bvgui_open_steam_profile = "打开Steam个人资料",
            bvgui_right_click_to_focus = "右键点击聚焦",
            bvgui_click_to_focus = "点击聚焦",
            bvgui_unknown = "未知",
            bvgui_no_data = "无数据",
            bvgui_no_results_found = "未找到结果",
            bvgui_done = "完成",
            bvgui_enter_text_ellipsis = "输入文本...",
            bvgui_loading_ellipsis = "加载中...",
            bvgui_pin_tip = "按ESC再次点击菜单",
            bvgui_click_to_render = "点击渲染",
            bvgui_teleport = "传送",
            bvgui_inspecting = "检查中",
            bvgui_inspect = "检查",
            bvgui_screenshot = "截图",
            bvgui_ok = "确定",
            bvgui_screenshot_saved = "截图已保存",
            bvgui_screenshot_saved_to = "截图已保存到您的电脑上的%s",
            bvgui_reset = "重置",
            bvgui_right_click_to_stop_rendering = "右键点击停止渲染",

            settings_player_popup_close = "当\n他们失去焦点时关闭玩家弹窗",
            settings_player_popup_close_tip = "当您点击不同菜单时，玩家弹窗是否应该关闭？"
        }
    end
}

--PATH lua/gmodadminsuite/modules/secondaryusergroups/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("sh_core.lua")
	AddCSLuaFile("cl_menu.lua")
end

GAS:hook("gmodadminsuite:LoadModule:secondaryusergroups", "LoadModule:secondaryusergroups", function()
	include("gmodadminsuite/modules/secondaryusergroups/sh_core.lua")
	if (SERVER) then
		include("gmodadminsuite/modules/secondaryusergroups/sv_secondaryusergroups.lua")
		include("gmodadminsuite/modules/secondaryusergroups/sv_permissions.lua")
	else
		include("gmodadminsuite/modules/secondaryusergroups/cl_menu.lua")
	end
end)
--PATH addons/employer_npc/lua/employer_npc/config_lang.lua:
ENPC.Langs = {}

ENPC.Langs["en"] = {
	["Unavailable"]                       = "Unavailable",
	["Limit reached"]                     = "Limit reached",
	["Time"]                              = "Time",
	["Lvl"]                               = "Lvl",
	["Add Job"]                           = "Add Job",
	["Select Job"]                        = "Select Job",
	["Jobs"]                              = "Jobs",
	["OK"]                                = "OK",
	["Cancel"]                            = "Cancel",
	["Settings"]                          = "Settings",
	["Name of NPC"]                       = "Name of NPC",
	["Model path"]                        = "Model path",
	["Jobs List"]                         = "Jobs List",
	["Job Name"]                          = "Job Name",
	["Remove Job"]                        = "Remove Job",
	["Save"]                              = "Save",
	["Required"]                          = "Required",
	["Select"]                            = "Select",
	["Job Cost"]                          = "Job Cost",
	["You can't afford this job"]         = "You can't afford this job",
	["You unlocked"]                      = "You unlocked",
	["Need to buy"]                       = "Need to buy",
	["Available"]                         = "Available",
	["Selected"]                          = "Selected",
	["You should find NPC to change job"] = "You should find NPC to change job",
	["model"]                             = "model",
	["skin"]                              = "skin",
}

ENPC.Langs["fr"] = {
	["Unavailable"]                       = "Indisponible",
	["Limit reached"]                     = "Limite atteinte",
	["Time"]                              = "Temps",
	["Lvl"]                               = "Lvl",
	["Add Job"]                           = "Ajouter",
	["Select Job"]                        = "Sélectionner",
	["Jobs"]                              = "Emplois",
	["OK"]                                = "OK",
	["Cancel"]                            = "Annuler",
	["Settings"]                          = "Paramètres",
	["Name of NPC"]                       = "Nom du NPC",
	["Model path"]                        = "Chemin du modèle",
	["Jobs List"]                         = "Liste des emplois",
	["Job Name"]                          = "Nom du travail",
	["Remove Job"]                        = "Retirer",
	["Save"]                              = "sauvegarder",
	["Required"]                          = "Champs obligatoires",
	["Select"]                            = "Sélectionner",
	["Job Cost"]                          = "Coût de l'emploi",
	["You can't afford this job"]         = "Vous ne pouvez pas vous permettre ce travail",
	["You unlocked"]                      = "Vous avez déverrouillé",
	["Need to buy"]                       = "Besoin d'acheter",
	["Available"]                         = "Disponible",
	["Selected"]                          = "Choisi",
	["You should find NPC to change job"] = "Vous devriez trouver un NPC pour changer de travail",
	["model"]                             = "model",
	["skin"]                              = "skin",
}

ENPC.Langs["ru"] = {
	["Unavailable"]                       = "Недоступно",
	["Limit reached"]                     = "Достигнут лимит",
	["Time"]                              = "Время",
	["Lvl"]                               = "Ур.",
	["Add Job"]                           = "Добавить",
	["Select Job"]                        = "Выбрать",
	["Jobs"]                              = "Профессии",
	["OK"]                                = "OK",
	["Cancel"]                            = "Отмена",
	["Settings"]                          = "Настройки",
	["Name of NPC"]                       = "Название",
	["Model path"]                        = "Модель",
	["Jobs List"]                         = "Список работ",
	["Job Name"]                          = "Название работ",
	["Remove Job"]                        = "Удалить",
	["Save"]                              = "Сохранить",
	["Required"]                          = "Требуется",
	["Select"]                            = "Выбрать",
	["Job Cost"]                          = "Цена",
	["You can't afford this job"]         = "У вас не хватает денег",
	["You unlocked"]                      = "Вы открыли",
	["Need to buy"]                       = "Нужно купить",
	["Available"]                         = "Доступные",
	["Selected"]                          = "Выбранные",
	["You should find NPC to change job"] = "Найдите NPC, чтобы сменить работу",
	["model"]                             = "модель",
	["skin"]                              = "скин",
}

ENPC.Langs["es"] = {
	["Unavailable"]                       = "No Disponible",
	["Limit reached"]                     = "Limite Alcanzado",
	["Time"]                              = "Tiempo",
	["Lvl"]                               = "Lvl",
	["Add Job"]                           = "Agregar Job",
	["Select Job"]                        = "Seleccionar Job",
	["Jobs"]                              = "Jobs",
	["OK"]                                = "OK",
	["Cancel"]                            = "Cancelar",
	["Settings"]                          = "Ajustes",
	["Name of NPC"]                       = "Nombre",
	["Model path"]                        = "Modelo",
	["Jobs List"]                         = "Lista de Jobs",
	["Job Name"]                          = "Nombre del Job",
	["Remove Job"]                        = "Eliminar Job",
	["Save"]                              = "Guardar",
	["Required"]                          = "Requerido",
	["Select"]                            = "Seleccionar",
	["Job Cost"]                          = "Costo del Job",
	["You can't afford this job"]         = "No tienes dinero para el Job",
	["You unlocked"]                      = "Has desbloqueado",
	["Need to buy"]                       = "Necesito comprar",
	["Available"]                         = "Disponible",
	["Selected"]                          = "Seleccionado",
	["You should find NPC to change job"] = "Debes encontrar un NPC para cambiar el trabajo",
	["model"]                             = "model",
	["skin"]                              = "skin",
}

ENPC.Langs["de"] = {
	["Unavailable"]                       = "Nicht verfügbar",
	["Limit reached"]                     = "Limit wurde erreicht",
	["Time"]                              = "Zeit",
	["Lvl"]                               = "Lvl",
	["Add Job"]                           = "Hinzufügen",
	["Select Job"]                        = "Auswählen",
	["Jobs"]                              = "Berufe",
	["OK"]                                = "OK",
	["Cancel"]                            = "Abbrechnen",
	["Settings"]                          = "Einstellungen",
	["Name of NPC"]                       = "NPC Name",
	["Model path"]                        = "Model",
	["Jobs List"]                         = "Berufliste",
	["Job Name"]                          = "Berufsname",
	["Remove Job"]                        = "Beruf löschen",
	["Save"]                              = "Speichern",
	["Required"]                          = "Erforderlich",
	["Select"]                            = "Auswählen",
	["Job Cost"]                          = "Preis",
	["You can't afford this job"]         = "Sie haben nicht genügend Geld",
	["You unlocked"]                      = "Sie haben freigeschaltet",
	["Need to buy"]                       = "Muss kaufen",
	["Available"]                         = "Verfügbar",
	["Selected"]                          = "Ausgewählt",
	["You should find NPC to change job"] = "Sie sollten einen NPC finden, um den Job zu wechseln",
	["model"]                             = "model",
	["skin"]                              = "skin",
}

ENPC.Langs["no"] = {
	["Unavailable"]                       = "Ikke tilgjengelig",
	["Limit reached"]                     = "Grense nådd",
	["Time"]                              = "Tid",
	["Lvl"]                               = "Level",
	["Add Job"]                           = "Legg til jobb",
	["Select Job"]                        = "Velg jobb",
	["Jobs"]                              = "Jobber",
	["OK"]                                = "OK",
	["Cancel"]                            = "Avbryt",
	["Settings"]                          = "Instillinger",
	["Name of NPC"]                       = "Navngi NPC",
	["Model path"]                        = "Model plassering",
	["Jobs List"]                         = "Jobb liste",
	["Job Name"]                          = "Jobb navn",
	["Remove Job"]                        = "Fjern Jobb",
	["Save"]                              = "Lagre",
	["Required"]                          = "Obligatorisk",
	["Select"]                            = "Velg",
	["Job Cost"]                          = "Pris på jobb",
	["You can't afford this job"]         = "Du har ikke nok til denne jobben.",
	["You unlocked"]                      = "Du låst opp",
	["Need to buy"]                       = "Trenger å kjøpe",
	["Available"]                         = "Tilgjengelig",
	["Selected"]                          = "valgt",
	["You should find NPC to change job"] = "Du bør finne en NPC for å endre jobben",
	["model"]                             = "model",
	["skin"]                              = "skin",
}

--PATH addons/rogue_scoreboard/lua/roguescoreboard/incog.lua:
if SERVER then
	util.AddNetworkString( "Scoreboard.Hidden" )
	net.Receive("Scoreboard.Hidden", function(len, ply)
		if IsValid(ply) and ply:IsPlayer() then
			ply:SetRogueNetBool("Incognito", !ply:GetRogueNetBool("Incognito", false))
		end
	end)
end
--PATH addons/msd_ui/lua/msd/sh_config.lua:
-- ┏━┓┏━┳━━━┳━━━┓───────────────────────
-- ┃┃┗┛┃┃┏━┓┣┓┏┓┃───────────────────────
-- ┃┏┓┏┓┃┗━━┓┃┃┃┃──By MacTavish <3──────
-- ┃┃┃┃┃┣━━┓┃┃┃┃┃───────────────────────
-- ┃┃┃┃┃┃┗━┛┣┛┗┛┃───────────────────────
-- ┗┛┗┛┗┻━━━┻━━━┛───────────────────────
-- MIT License
-- Copyright (c) 2021 Ayden Mactavish
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
MSD.Config.Language = "en"
MSD.Config.Rounded = 8
MSD.Config.Blur = false
MSD.Config.Vignette = false
MSD.Config.BgrColor = Color(45, 45, 45)

MSD.Config.MainColor = {
	["p"] = Color(0, 155, 255),
	["r"] = Color(255, 0, 0),
	["rd"] = Color(220, 0, 0),
}

MSD.Config.HUD = {
	ShowIcon = false,
	Icon = "https://i.imgur.com/ND3b6Do.png",
	Text = "MacNCo",
	X = 0.5,
	Y = 0.5,
	AlignX = 0,
	IconRight = false,
	IconSize = 48,
	FontSize = 28,
	ShowGroup = true,
	TeamColor = false,
	Follow = true,
	Dist = 200,
}

function MSD.AddModule(name, menu, icon)
	local mod = {
		name = name,
		icon = icon,
		menu = menu
	}

	local id = MSD.ModuleIds[name]

	if id then
		MSD.Modules[id] = mod
	else
		id = table.insert(MSD.Modules, mod)
		MSD.ModuleIds[name] = id
	end

	return id
end

--──────────────────────────────────--
------------- CFG Saving -------------
--──────────────────────────────────--
net.Receive("MSD.GetConfigData", function(l, ply)
	if CLIENT then
		MSD.Config = net.ReadTable()
	else
		net.Start("MSD.GetConfigData")
		net.WriteTable(MSD.Config)
		net.Send(ply)
	end
end)

MSD.SaveConfig = function()
	if CLIENT then
		local json_data = util.TableToJSON(MSD.Config, false)
		local cd = util.Compress(json_data)
		local bn = string.len(cd)
		net.Start("MSD.SaveConfig")
		net.WriteInt(bn, 32)
		net.WriteData(cd, bn)
		net.SendToServer()
	else
		net.Start("MSD.GetConfigData")
		net.WriteTable(MSD.Config)
		net.Broadcast()
		file.Write("msd_data/config.txt", util.TableToJSON(MSD.Config, true))
	end
end

function MSD.LoadConfig()
	if CLIENT then
		net.Start("MSD.GetConfigData")
		net.SendToServer()
	else
		net.Receive("MSD.SaveConfig", function(l, ply)
			if MSD.cfgLastChange and MSD.cfgLastChange > CurTime() then return end
			MSD.cfgLastChange = CurTime() + 1
			if not ply:IsSuperAdmin() then return end
			local bytes_number = net.ReadInt(32)
			local compressed_data = net.ReadData(bytes_number)
			local json_data = util.Decompress(compressed_data)
			local config = util.JSONToTable(json_data)
			MSD.Config = config
			MSD.SaveConfig()
		end)

		if not file.Exists("msd_data/config.txt", "DATA") then
			file.Write("msd_data/config.txt", util.TableToJSON(MSD.Config, true))
		else
			local config = util.JSONToTable(file.Read("msd_data/config.txt", "DATA"))

			for k, v in pairs(config) do
				if MSD.Config[k] ~= nil then
					MSD.Config[k] = v
				end
			end

			if #player.GetAll() > 0 then
				net.Start("MSD.GetConfigData")
				net.WriteTable(MSD.Config)
				net.Broadcast()
			end
		end
	end
end

if SERVER then
	hook.Add("PostGamemodeLoaded", "MQMSDS.Load.SV", function()
		MSD.LoadConfig()
	end)
else
	hook.Add("InitPostEntity", "MSD.Load.CL", function()
		MSD.LoadConfig()
	end)
end

if GAMEMODE then
	MSD.LoadConfig()
end
--PATH addons/msd_ui/lua/msd/language/nl.lua:
MSD.Language["nl"] = {

	lang_name = "Netherlands",

	ok = "OKE",
	map = "Kaart",
	off = "Uit",
	on = "Op",
	time_add = "Tijd om toe te voegen",
	type = "Type",
	delay = "Vertraging",
	cancel = "Annuleren",
	enable = "Inschakelen",
	model = "Model",
	name = "Naam",
	settings = "Instellingen",
	editor = "Editor",
	red = "Rood",
	green = "Groente",
	blue = "Blauw",
	admin_menu = "Administratie menu",
	ui_settings = "UI instellingen",
	active = "Actief",
	inactive = "Inactief",
	disabled = "Gehandicapt",
	warning = "Waarschuwing!",
	remove = "Verwijderen",
	theme = "Thema",
	dark_theme = "Donker thema",
	payment = "Betaling",
	load_autosave = "Laad laatste autosave?",
	load_save = "Laad gegevens",
	create_new = "Maak nieuw",
	enable_option = "Optie inschakelen",
	main_opt = "Belangrijkste opties",
	copy_data = "Gegevens kopiëren",
	save_chng = "Wijzigingen opslaan",
	enter_name = "Voer de naam in",
	enter_id = "Voer de ID in",
	confirm_action = "Bevestig uw acties a.u.b.",
	check_fpr_errors = "Controleer op fouten",
	enter_description = "Voer beschrijving in",
	cooldown_ok = "Cooldown bij succes",
	cooldown_fail = "Afkoelen bij mislukt",
	s_team_whitelist = "Witte lijst voor team instellen",
	whitelist_blacklist = "De witte lijst is een zwarte lijst",
	custom_val = "Aangepaste waarde instellen",
	set_hp_full = "Zet volledige HP",
	dist_to_close = "Afstand tot dichtstbijzijnde",

	e_text = "Tekst invoeren",
	e_number = "Voer nummer in",
	e_class = "Ga naar de klas",
	e_value = "Voer waarde in",
	e_blank_dis = "Laat leeg om uit te schakelen",
	e_blank_default = "Laat leeg om standaard te gebruiken",
	e_url = "Binnenkomen URL",
	e_model = "Voer modelpad in", -- voorbeeld: model/alyx.mdl
	e_material = "Voer materiaalpad in",
	e_wep_class = "Voer wapenklasse in",
	e_ent_class = "Entiteitsklasse invoeren",
	e_veh_class = "Voer voertuigklasse in",
	e_npc_class = "Voer NPC-klasse in",

	select_ammo = "geselecteerde munitie",
	amount_ammo = "Munitie hoeveelheid",
	disable_phys = "Schakel natuurkunde uit",
	none = "Geen",
	custom_icon = "Aangepast pictogram instellen",
	weapon_name = "wapen naam",
	moveup = "Omhoog gaan",
	movedown = "Naar beneden verplaatsen",
	movepoint = "Punt verplaatsen",
	swap = "Ruil",
	swapmod = "Swap-mod ingeschakeld. Klik om uit te schakelen",
	copy_from_ent = "Kopiëren van kijkende entiteit",
	set_pos_self = "Instellen op uw positie",
	set_pos_aim = "Ingesteld op kijkpunt",
	spawn_point = "spawn punt",
	spawn_ang = "Spawn hoek",
	mark_area = "Markeer gebied",
	time_wait = "Tijd om te wachten",
	map_marker = "Selecteer kaartmarkering",
	in_sec = "in seconden",
	def_units = "Standaard %s eenheden", -- "Standaard 350 units" het verlof %s zoals het is
	def_seconds = "Standaard %s seconden", -- "Standaard 10 seconds" het verlof %s zoals het is
	ent_show_pointer = "Toon aanwijzer boven de entiteit",
	ent_arcade_style = "Uiterlijk van entiteit in arcadestijl",
	ent_stnd_style = "Standaard uiterlijk van entiteit",
	custom_color = "Aangepaste kleur inschakelen",
	mat_default = "Leeg laten voor standaard materiaal",

	set_ui = "UI instellingen",
	set_hud = "HUD instellingen",
	set_hud_pos = "Quest HUD positie",
	set_hud_themes = "HUD Thema's",
	set_server = "Server instellingen",
	set_ui_blur = "Blur achtergrond",
	set_ui_mono = "Monochrome achtergrond",
	set_ui_vignette = "Vigneteffect voor achtergrond",
	set_ui_brightness = "Achtergrondhelderheid",
	set_ui_color = "Selecteer de hoofdkleur",
	set_ui_align_left = "Horizontale uitlijning naar links",
	set_ui_align_right = "Horizontale uitlijning naar rechts",
	set_ui_align_top = "Verticale uitlijning naar boven",
	set_ui_align_bottom = "Verticale uitlijning naar beneden",
	set_ui_offset_h = "Horizontale verschuiving",
	set_ui_offset_v = "Verticale verschuiving",

	upl_changes = "Wijzigingen uploaden naar server",
	res_changes = "Wijzigingen herstellen",

	-- Player 

	dead = "Je bent dood",
	time_ex = "Tijd verlopen",
	vehicle_bum = "Uw voertuig is vernietigd",
	left_area = "Je hebt het gebied verlaten",
	m_blew = "You blew up the mission",
	m_failed = "Missie gefaald",
	m_success = "Missie geslaagd",
	m_loop = "Missie update",

	-- Errors

	inv_quest = "Ongeldige zoektocht",
	team_bl = "Uw team staat op de zwarte lijst",
	no_players = "Server heeft meer spelers nodig om online te zijn voordat je dit kunt doen",
	no_players_team = "Server heeft meer spelers nodig voor specifieke team(s) om online te zijn voordat je dit kunt doen",
	need_admin = "Alleen beheerders kunnen deze actie uitvoeren",

	-- Quests

	active_quest = "Je hebt een actieve zoektocht",
	inactive_quest = "Je kunt deze zoektocht niet spelen",
	quest_editor = "Speurtocht Editor",
	quest_list = "Speurtocht List",
	quests = "Speurtochts",
	leave_pnt = "Het verlof point",

	q_editobj = "Doelstellingen bewerken",
	q_incvobj = "Ongeldige doelstelling",
	q_setobj = "Ongeldige instellingen",
	q_newobj = "Nieuwe doelstelling toevoegen",
	q_editrwd = "Bewerk beloningen",
	q_rwdeditor = "Belonings editor",
	q_rwdlist = "Reward list",
	q_rwdsets = "Belonings lijst",
	q_findmap = "Zoek een zoektocht van andere kaarten",
	q_obj_des = "Objectieve beschrijving",
	q_dist_point = "Afstand tot punt",
	q_dist_from_point = "Afstand vanaf punt",
	q_ignore_veh = "Negeer zoektocht voertuig",
	q_timer_show = "Toon de timer aan speler",
	q_area_stay = "Speler moet in het gebied blijven",
	q_start = "Zoektocht starten",
	q_new = "Nieuwe zoektocht",
	q_submit = "Zoekopdracht indienen",
	q_addnew = "Nieuwe zoektocht toevoegen",
	q_remove = "Zoektocht verwijderen",
	q_id_unique = "ID moet uniek zijn voor elke zoektocht",
	q_complete_msg = "Quest voltooid bericht",
	q_dotime = "Quest doe tijd",
	q_dotime_ok = "Slaag de zoektocht op tijd einde",
	q_dotime_fail = "Mislukte zoektocht op tijd einde",
	q_death_fail = "Mislukte zoektocht bij dood van speler",
	q_loop = "Loop-queeste genomen",
	q_loop_reward = "Beloon speler bij elke lus",
	q_enable = "Zoektocht inschakelen",
	q_events = "Evenementen",
	q_eventadd = "Toevoegen Evenementen",
	q_eventedit = "Evenementen edit",
	q_eventremove = "Evenement verwijderen",
	q_in_progress = "Quest in uitvoering",
	q_time_left = "Tijd over",
	q_ply_limit = "Spelerslimiet voor de zoektocht",
	q_ply_team_limit = "Teamlimieten instellen",
	q_ply_team_need = "benodigde teamspelers",
	q_ply_need = "Spelersbedrag nodig om te starten",
	q_play_limit = "Er is een limiet aan hoeveel spelers deze zoektocht kunnen spelen",
	q_must_stay_area = "Je moet binnen dit gebied blijven, anders mislukt de zoektocht",
	q_time_wait = "Je moet wachten voordat je deze quest opnieuw kunt spelen",
	q_dotime_reset = "Reset quest do time",
	q_dotime_add = "Quest do time toevoegen",
	q_noreplay = "Je kunt deze zoektocht niet opnieuw spelen",
	q_dis_replay = "Disable quest replay",
	q_needquest = "You need to finish another quest first",
	q_needquest_menu = "Voltooide zoektocht vereisen",
	q_enterror = "Quest-entiteiten zijn niet voortgekomen, controleer de setup van de missie",
	q_get = "Je kunt een quest krijgen van deze NPC's",
	q_noquests = "Er is nog geen manier om speurtochten te spelen :(",
	q_ent_draw = "Trekafstand van de queeste-entiteit",
	q_loop_stop_key = "Stop-toets voor doorlopende zoektocht",
	q_hold_key_stop = "Om quest hold te stoppen [%s]", -- To stop quest hold [P]
	q_enter_veh = "Voer uw voertuig in",
	q_npc_link = "Zoektocht koppelen aan een NPC",
	q_icon68 = "Voer url in naar .PNG pictogram 68x68 px",
	q_ent_pos_show = "Locatie van entiteiten aan speler tonen",
	q_area_size = "Oppervlakte",
	q_area_pos = "Gebiedspositie",
	q_s_area_size = "Grootte van het zoekgebied",
	q_s_area_pos = "Zoekgebied positie",
	q_npc_answer_ok = "Positief antwoord van de speler",
	q_npc_answer_no = "Negatief antwoord van de speler",
	q_npc_answer_noq = "Het antwoord van de speler als er geen speurtochten zijn",
	q_npc_quest_no = "NPC spraak als er geen speurtochten zijn",
	q_money_give = "Geld om te geven",

	-- Simple NPCs

	npc_editor = "NPC-editor",
	npc_new = "Nieuwe NPC",
	npc_select = "Selecteer een NPC",
	npc_e_speech = "Voer NPC-spraak in",
	npc_submit = "Aanmaak van NPC bevestigen",
	npc_update = "NPC bijwerken",
	npc_remove = "NPC verwijderen",
	npc_q_enable = "Zoek-NPC's inschakelen",
	npc_did_open = "Dialoogvenster-ID om te openen",
	npc_q_target = "NPC is een objectief doelwit",
	npc_hostile = "Vijandige NPC",


	-- Update 1.1.0

	cam_start = "Startparameters camera",
	cam_end = "Camera einde parameters",
	cam_pos = "Camera positie",
	cam_ang = "Camera hoek",
	cam_fov = "Camerabeeldhoek",
	cam_effect = "Camerasluitereffect",
	q_open_target = "Sta andere spelers toe om NPC's te doden",
	q_npc_mind = "Min. afstand tot NPC's",
	not_spawned = "niet voortgebracht",
	dis_text = "Weergegeven tekst",
	cam_speed = "Bewegingssnelheid camera (langzamer getal - langzamere beweging)",
	fov_speed = "FOV-veranderingssnelheid (lager getal - langzamere beweging)",
	category_des = "Missiecategorie, gebruikt om missies te sorteren",
	sortquests_cat = "Sorteer missies op categorie",
	search_q = "Zoekopdrachten",
	quest_tools = "Quest-tools",
	set_anim = "Animatieset",
	s_quest_blacklist = "Zwarte lijst voor missies instellen",
	s_quest_blacklist_desc = "Selecteer missies die deze missie blokkeren als je ze hebt gespeeld",
	hold_use = "Houden [%s] key",
	duplicate = "Duplicaat",
	unsorted = "ongesorteerd",
	search = "Zoekopdracht",
	duration = "Looptijd",
	category = "Categorie",
	blacklist = "Zwarte lijst",


	--  Update 1.2.0

	restore_wep = "Wapens herstellen aan het einde van de zoektocht",
	e_cmd = "Voer consoleopdracht in",
	e_args = "Voer opdrachtargumenten in",
	hint_cmd = "Sneltoetsen aanvullen: \n$uid - UserID, \n$sid - SteamID,  \n$s64 - SteamID 64, \n$n - Plaag naam",
	youaretracked = "Your position is now compromised to other players!",
	border_rounded = "Rounded border design",
	border_square = "Vierkant randontwerp",
	access_settings = "Toegang tot menu",
	compact_obj = "Compacte doelstellingenlijst voor speurtochten",
	e_usergroup = "Gebruikersgroep invoeren",
	ug_isanadmin = "Deze gebruikersgroep heeft al volledige toegang",
	find_player_id32 = "Vind spelergegevens op SteamID 32",
	user_data = "Editor voor gebruikersgegevens",
	access_editors = "Toegang voor quest-editors instellen",
	access_admins = "Volledige toegang instellen",
	add_usergroup = "Gebruikersgroep toevoegen",
	edit_objmod = "Objectvolgorde bewerken",
	editmod = "Mode bewerken",
	move = "Beweging",
	q_errorloop = "Quest ingevoerd in een eindeloze lus",
	q_cooldow_perply = "Openbare afkoeltimer",
	q_cooldow_publick = "Afkoeltimer per speler",
	q_stop_anytime = "Toestaan om de zoektocht handmatig te verlaten",
	quest_abandon = "Je hebt de zoektocht opgegeven",
	q_dotime_set = "Tijd voor quest instellen",


	-- Ranks

	enter_path_or_url = "Voer pad of url in",
	rank_edit = "Rangen instellen",
	rank_list = "Ranglijst",
	group_list = "Groepslijst",
	group_addnew = "Nieuwe groep toevoegen",
	blank = "Blanco",
	mrs_show_all = "Toon rangen aan alle spelers",
	mrs_show_team = "Toon rangen alleen aan de groep",
	mrs_use_sn = "Korte rangnamen weergeven",
	use_url = "Gebruik URL",
	enter_srt_name = "Voer korte naam in",
	srt_name = "Korte naam",
	mrs_prom_demote = "De volgende 2 opties zijn alleen van invloed op lagere rangen. Spelers met deze rang kunnen andere spelers niet promoveren naar hogere rangen of dezelfde rang.",
	mrs_whilelist = "Als je een rangvereiste voor een baan selecteert, kan de speler deze baan alleen spelen als zijn rang overeenkomt met de gekozen of hoger.",
	can_promote = "Kan de spelersrang bevorderen",
	can_demote = "Kan spelerrang degraderen",
	edit_player_model = "Aangepast spelersmodel bewerken",
	enable_player_model = "Aangepast spelermodel inschakelen",
	disable_player_model = "Aangepast spelermodel uitschakelen",
	edit_custom_stats = "Aangepaste spelerstatistieken bewerken",
	autoprom = "Automatisch promoveren naar de volgende rang",
	in_min = "in minuten",
	mrs_promoted = "Je bent gepromoveerd",
	mrs_demoted = "Je bent gedegradeerd",
	mrs_job_smallrank = "Je moet %s of hoger zijn om als %s. te spelen", -- You must be Sergeant II or higher to play as Watch Commander
	show_group = "Naam ranggroep weergeven",
	hide_rank = "Toon alleen rang icoon",
	mrs_hud_follow = "Draai de gebruikersinterface rond de speler, afhankelijk van de kijkhoek",
	set_overhead = "Spelers info UI",
	offline_users = "Offline gebruikers",
	mrs_noranks = "Je huidige baan heeft geen rangen",
	mrs_nopower = "Je huidige rang heeft geen extra rechten",
	promotion = "Promotie",
	on_duty = "In functie",
	other_players = "andere spelers",
	mrs_change_jobname = "Wijzig de taaknaam in de rangnaam",
	mrs_set_prefix = "Voeg de rangnaam toe als voorvoegsel aan de taaknaam",
	copy_all_data = "Kopieer alle gegevens",
	copy_only_stats = "Kopieer alleen statistieken en spelersmodel",
}

-- Other phrases
local lng = "nl"

MSD.Language[lng]["Move to point"] = "Verplaatsen naar punt"
MSD.Language[lng]["Leave area"] = "Verlaat gebied"
MSD.Language[lng]["Kill NPC"] = "Dood NPC"
MSD.Language[lng]["Collect quest ents"] = "Verzamel zoektochten"
MSD.Language[lng]["Talk to NPC"] = "Praat met NPC"
MSD.Language[lng]["There is no quests available"] = "Er zijn geen speurtochten beschikbaar"
MSD.Language[lng]["Give weapon"] = "Geef wapen"
MSD.Language[lng]["Give ammo"] = "Geef munitie"
MSD.Language[lng]["Strip Weapon"] = "Stripwapen"
MSD.Language[lng]["Spawn quest entity"] = "Spawn Quest-entiteit"
MSD.Language[lng]["Spawn entity"] = "Spawn entiteit"
MSD.Language[lng]["Spawn npc"] = "spawn npc"
MSD.Language[lng]["Manage do time"] = "Beheer doe tijd"
MSD.Language[lng]["Spawn vehicle"] = "Spawn voertuig"
MSD.Language[lng]["Remove vehicle"] = "Voertuig verwijderen"
MSD.Language[lng]["Remove all entites"] = "Alle entiteiten verwijderen"
MSD.Language[lng]["Set HP"] = "Stel HP"
MSD.Language[lng]["Set Armor"] = "Pantser instellen"
MSD.Language[lng]["DarkRP Money"] = "DarkRP Geld"
MSD.Language[lng]["Quest NPCs are disabled"] = "Quest-NPC's zijn uitgeschakeld"
MSD.Language[lng]["You can enable them in settings"] = "Je kunt ze inschakelen in instellingen"

--PATH addons/msd_ui/lua/msd/language/ru.lua:
MSD.Language["ru"] = {

	-- UI

	lang_name = "Русский",

	ok = "ОК",
	map = "Карта",
	off = "Выкл",
	on = "Вкл",
	time_add = "Добавить время",
	type = "Тип",
	delay = "Задержка",
	cancel = "Отменить",
	enable = "Активировать",
	model = "Модель",
	name = "Название",
	settings = "Настройки",
	editor = "Редактор",
	red = "Красный",
	green = "Зеленый",
	blue = "Синий",
	admin_menu = "Админ меню",
	ui_settings = "Настройки интерфейса",
	active = "Активно",
	inactive = "Неактивно",
	disabled = "Отключено",
	warning = "Внимание!",
	remove = "Удалить",
	theme = "Тема",
	dark_theme = "Темная тема",
	payment = "Оплата",
	load_autosave = "Загрузить последнее автосохранение?",
	load_save = "Загрузить сохранение",
	create_new = "Создать новый",
	enable_option = "Включить опцию",
	main_opt = "Главные опции",
	copy_data = "Копировать данные",
	save_chng = "Сохранить изменения",
	enter_name = "Ввести название",
	enter_id = "Ввести ID",
	confirm_action = "Подтвердите пожалуйста действия",
	check_fpr_errors = "Проверить на ошибки",
	enter_description = "Ввести описание",
	cooldown_ok = "Задержка при успехе",
	cooldown_fail = "Задержка при провале",
	s_team_whitelist = "Настроить командный вайтлист",
	whitelist_blacklist = "Вайтлист=блэклист",
	custom_val = "Установить собственное значение",
	set_hp_full = "сделать полное ХП",
	dist_to_close = "Дистанция к ближайшему",

	e_text = "Введите текст",
	e_number = "Введите номер",
	e_class = "Введите класс",
	e_value = "Введите значение",
	e_blank_dis = "Оставьте пустым чтобы отключить",
	e_blank_default = "Оставьте пустым чтобы использовать по-умолчанию",
	e_url = "Введите URL",
	e_model = "Введите путь модели",
	e_material = "Введите путь материала",
	e_wep_class = "Введите класс оружия",
	e_ent_class = "Введите класс энтити",
	e_veh_class = "Введите класс транспорта",
	e_npc_class = "Введите класс НПС",

	select_ammo = "Выбранные патроны",
	amount_ammo = "Количество патронов",
	disable_phys = "Отключить физику",
	none = "Нет",
	custom_icon = "Выбрать кастомную иконку",
	weapon_name = "Название оружия",
	moveup = "Передвинуть вверх",
	movedown = "Передвинуть вниз",
	movepoint = "Передвинуть точку",
	swap = "Поменять",
	swapmod = "Мод замены включен. Нажмите чтобы отключить",
	copy_from_ent = "Коп. с предмета",
	set_pos_self = "Выставить свою поз.",
	set_pos_aim = "Выставить по взгляду",
	spawn_point = "Точка спавна",
	spawn_ang = "Угол спавна",
	mark_area = "Обозначить территорию",
	time_wait = "Время ожидания",
	map_marker = "Выберите маркер карты",
	in_sec = "В секундах",
	def_units = "единицы по-умолчанию", -- "По-умолчанию 350 единиц" оставьте %s без изменений
	def_seconds = "Секунды по-умолчанию", -- "По-умолчанию 10 секунд" оставьте %s без изменений
	ent_show_pointer = "Показать маркер над энтити",
	ent_arcade_style = "Аркадный стиль появления энтити",
	ent_stnd_style = "Стандартное появление энтити",
	custom_color = "Включить кастомный цвет",
	mat_default = "Оставьте пустым для материала по-умолчанию",

	set_ui = "UI настройки",
	set_hud = "HUD настройки",
	set_hud_pos = "Позиция интерфейса квеста",
	set_hud_themes = "Темы интерфейса",
	set_server = "Настройки сервера",
	set_ui_blur = "Размытие заднего фона",
	set_ui_mono = "Монохром заднего фона",
	set_ui_vignette = "Эффект виньетки заднего фона",
	set_ui_brightness = "Яркость заднего фона",
	set_ui_color = "Выберите главный цвет",
	set_ui_align_left = "Горизонтальное выравнивание влево",
	set_ui_align_right = "Горизонтальное выравнивание вправо",
	set_ui_align_top = "Вертикальное выравнивание вверх",
	set_ui_align_bottom = "Вертикальное выравнивание вниз",
	set_ui_offset_h = "Горизонтальное смещение",
	set_ui_offset_v = "Вертикальное смещение",

	upl_changes = "Загрузить изменения на сервер",
	res_changes = "Восстановить изменения",

	-- Player

	dead = "Вы мертвы",
	time_ex = "Время вышло",
	vehicle_bum = "Ваш транспорт уничтожен",
	left_area = "Вы покинули территорию",
	m_blew = "Ваша миссия раскрыта",
	m_failed = "Миссия провалена",
	m_success = "Миссия выполнена",
	m_loop = "Обновление миссии",

	-- Errors

	inv_quest = "Неправильный квест",
	team_bl = "Ваша команда в блэклисте",
	no_players = "Нужно больше игроков онлайн для данного действия",
	no_players_team = "Нужно больше игроков онлайн в определенных командах для данного действия",
	need_admin = "Только администратор может это сделать",

	-- Quests

	active_quest = "У Вас есть активный квест",
	inactive_quest = "Вы не можете взять этот квест",
	quest_editor = "Редактор квеста",
	quest_list = "Список квестов",
	quests = "Квесты",
	leave_pnt = "Покинуть точку",

	q_editobj = "Редактировать задачи",
	q_incvobj = "Неправильная задача",
	q_setobj = "Настройки задачи",
	q_newobj = "Добавить задачу",
	q_editrwd = "Редактировать награду",
	q_rwdeditor = "Редактор награды",
	q_rwdlist = "Список наград",
	q_rwdsets = "Настройка наград",
	q_findmap = "Найти квесты с других карт",
	q_obj_des = "Описание задачи",
	q_dist_point = "Расстояние до точки",
	q_dist_from_point = "Расстояние от точки",
	q_ignore_veh = "Игнорировать квестовый транспорт",
	q_timer_show = "Показывать таймер игроку",
	q_area_stay = "Игрок должен находиться в зоне",
	q_start = "Начать квест",
	q_new = "Новый квест",
	q_submit = "Опубликовать квест",
	q_addnew = "Добавить новый квест",
	q_remove = "Удалить квест",
	q_id_unique = "ID должен быть уникален для каждого квеста",
	q_complete_msg = "Сообщение при выполнение квеста",
	q_dotime = "Время квеста",
	q_dotime_ok = "Засчитать выполнение квеста по истечению таймера",
	q_dotime_fail = "Засчитать провал квеста по истечению таймера",
	q_death_fail = "Засчитать провал квеста при смерти игрока",
	q_loop = "Зациклить задачи квеста",
	q_loop_reward = "Награждать игрока при выполнении цикла",
	q_enable = "Включить квест",
	q_events = "Эвенты",
	q_eventadd = "Добавить эвент",
	q_eventedit = "редактировать эвент",
	q_eventremove = "убрать эвент",
	q_in_progress = "Квест в работе",
	q_time_left = "Оставшееся время",
	q_ply_limit = "Лимит игроков для квеста",
	q_ply_team_limit = "Установить лимит команд",
	q_ply_team_need = "Требование к игрокам в команде",
	q_ply_need = "Требование к кол-ву игроков для старта",
	q_play_limit = "Установлен лимит на кол-во игроков для квеста",
	q_must_stay_area = "Вы должны находится в этой зоне или квест будет провален",
	q_time_wait = "Вы должны подождать прежде чем начинать квест снова",
	q_dotime_reset = "Сбросить время выполнения квеста",
	q_dotime_add = "Добавить время выполнения квеста",
	q_noreplay = "Вы не можете повторить этот квест",
	q_dis_replay = "Выключить повтор квеста",
	q_needquest = "Сначала Вы должны закончить другой квест",
	q_needquest_menu = "Необходим выполненный квест",
	q_enterror = "Энтити квеста не заспавнились, проверьте настройки квеста",
	q_get = "Вы можете взять квест у этих НПС",
	q_noquests = "Пока что нет способа начать квесты :(",
	q_ent_draw = "Дистанция прорисовки квестового энтити",
	q_loop_stop_key = "Кнопка остановки повторяемого квеста",
	q_hold_key_stop = "Чтобы остановить квест удерживайте [%s]", -- Чтобы остановить квест удерживайте [P]
	q_enter_veh = "Садитесь в свое транспортное средство",
	q_npc_link = "Привязать квест к НПС",
	q_icon68 = "Введите url для .PNG иконки 68x68 пикс.",
	q_ent_pos_show = "Показывать локацию энтити игроку",
	q_area_size = "Размер зоны",
	q_area_pos = "Позиция зоны",
	q_s_area_size = "Поиск размера зоны",
	q_s_area_pos = "Поиск позиции зоны",
	q_npc_answer_ok = "Положительный ответ игрока",
	q_npc_answer_no = "Отрицательный ответ игрока",
	q_npc_answer_noq = "Ответ игрока при отсутствии квестов",
	q_npc_quest_no = "Реплика НПСа при отсутствии квестов",
	q_money_give = "Деньги для выдачи",

	-- Simple NPCs

	npc_editor = "Редактор НПС",
	npc_new = "Новый НПС",
	npc_select = "Выберите НПС",
	npc_e_speech = "Введите реплику НПС",
	npc_submit = "Подтвердите создание НПС",
	npc_update = "Обновить НПС",
	npc_remove = "Убрать НПС",
	npc_q_enable = "Включить квестовых НПС",
	npc_did_open = "ID диалога для открытия",
	npc_q_target = "Цель задачи - НПС",
	npc_hostile = "Врадждебный НПС",

	-- Update 1.1.0

	duration = "Продолжительность",
	dis_text = "Отображаемый текст",
	cam_speed = "Скорость движения камеры (меньше число - медленнее движение)",
	fov_speed = "Скорость изменения поля зрения (меньше число - медленнее движение)",
	cam_start = "Параметры запуска камеры",
	cam_end = "Параметры конца камеры",
	cam_pos = "Позиция камеры",
	cam_ang = "Угол камеры",
	cam_fov = "Поля зрения камеры",
	cam_effect = "Эффект затвора камеры",
	not_spawned = "не создан",
	q_open_target = "Разрешить другим игрокам убивать NPC",
	q_npc_mind = "Мин. расстояние до NPC",
	duplicate = "Дублировать",
	hold_use = "Удерживайте кнопку [%s]",
	category = "Категория",
	category_des = "Категория квестов, используемая для сортировки квестов",
	sortquests_cat = "Сортировать квесты по категориям",
	unsorted = "Без Категория",
	search = "Поиск",
	search_q = "Искать квесты",
	quest_tools = "Инструменты",
	set_anim = "Установить анимацию",
	s_quest_blacklist = "Установить черный список квестов",
	blacklist = "Черный список",
	s_quest_blacklist_desc = "Выберите квесты, которые заблокируют этот квест, если вы их сыграли",

	--  Update 1.2.0

	restore_wep = "Восстановить оружие по окончании квеста",
	e_cmd = "Введите консольную команду",
	e_args = "Введите аргументы команды",
	hint_cmd = "Параметры для автозаполнение: \n$uid - UserID, \n$sid - SteamID,  \n$s64 - SteamID 64, \n$n - Имя игрока",
	youaretracked = "Ваше местоположение теперь видно другим игрокам!",
	border_rounded = "Дизайн с закругленными краями",
	border_square = "Дизайн с квадратными краями",
	access_settings = "Доступ к меню",
	compact_obj = "Компактный список задач для квестов",
	e_usergroup = "Введите группу пользователей",
	ug_isanadmin = "Эта группа пользователей уже имеет полный доступ",
	find_player_id32 = "Найти данные игрока по SteamID 32",
	user_data = "Редактор данных игрока",
	access_editors = "Установить доступ для редакторов квестов",
	access_admins = "Установить полный доступ",
	add_usergroup = "Добавить группу пользователей",
	edit_objmod = "Изменить порядок задач",
	editmod = "Режим редактирования",
	move = "Передвинуть",
	q_errorloop = "Квест вошел в бесконечный цикл",
	q_cooldow_perply = "Публичный таймер",
	q_cooldow_publick = "Индивидуальный таймер",
	q_stop_anytime = "Разрешить отказаться от квеста вручную",
	quest_abandon = "Вы отказались от квеста",
	q_dotime_set = "Установить время выполнения квеста",


	-- Ranks

	enter_path_or_url = "Введите путь или веб адрес",
	rank_edit = "Настройка рангов",
	rank_list = "Список рангов",
	group_list = "Список групп",
	group_addnew = "Добавить новую группу",
	blank = "Пустой",
	mrs_show_all = "Показывать ранги всем игрокам",
	mrs_show_team = "Показывать ранги только группе",
	mrs_use_sn = "Отображать короткие названия рангов",
	use_url = "Использовать веб адрес",
	enter_srt_name = "Введите короткое имя",
	srt_name = "Короткое имя",
	mrs_prom_demote = "Следующие 2 параметра влияют только на более низкие ранги. Игроки с этим рангом не смогут повышать других игроков до более высоких рангов или того же ранга.",
	mrs_whilelist = "Если вы выберете требование ранга для профессии, игрок сможет играть за эту профессию, только если его ранг соответсвует выбранному или выше.",
	can_promote = "Может повышать ранг игрока",
	can_demote = "Может понижать ранг игрока",
	edit_player_model = "Настроить модель игрока",
	enable_player_model = "Включить уникальную модель игрока",
	disable_player_model = "Выключить уникальную модель игрока",
	edit_custom_stats = "Настроить параметры игрока",
	autoprom = "Автоматическое повышение до следующего ранга",
	in_min = "в минутах",
	mrs_promoted = "Вы получили повышение",
	mrs_demoted = "Вы были понижены",
	mrs_job_smallrank = "Вы должны быть %s или выше что бы играть за %s",
	show_group = "Отображение названия группы рангов",
	hide_rank = "Отображать только значок ранга",
	mrs_hud_follow = "Интерфейс игрока следует за камерой",
	set_overhead = "Интерфейс информации об игроке",
	offline_users = "Офлайн-пользователи",
	mrs_noranks = "Ваша текущая работа не имеет званий",
	mrs_nopower = "У вашего текущего ранга нет дополнительных разрешений",
	promotion = "Повышение",
	on_duty = "На службе",
	other_players = "Другие игроки",
	mrs_change_jobname = "Поменять название профессии на название ранга",
	mrs_set_prefix = "Добавьте ранг в качестве префикса к названию профессии",
	mrs_change_plyname = "Поменять имя игрока на название ранга",
	mrs_set_prefix_ply = "Добавьте ранг в качестве префикса к имени игрока",

	promote_limit = "Ограничение повышения",
	demote_limit = "Ограничение понижения",
	salary_value = "Заработная плата",
	salary_set = "Установить данное значение в качестве зарплаты",
	salary_add = "Добавить указанное значение к зарплате",
	salary_multiply = "Умножить зарплату на заданное значение",
	force_team = "Принудительно cменить команду на",
	mrs_hud_3d2d = "Использовать 3D2D интерфейс",
	mrs_chat_command = "Чат-команда для открытия меню рангов",
	mrs_promote_command = "Чат-команда для повышения игрока",
	mrs_demote_command = "Чат-команда для понижения игрока",
}

-- Other phrases
local lng = "ru"

MSD.Language[lng]["Move to point"] = "Выдвигайтесь к точке"
MSD.Language[lng]["Leave area"] = "Покиньте территорию"
MSD.Language[lng]["Kill NPC"] = "Убейте НПС"
MSD.Language[lng]["Collect quest ents"] = "Соберите квестовые энтити"
MSD.Language[lng]["Talk to NPC"] = "Поговорите с НПС"
MSD.Language[lng]["Wait time"] = "Ожидать время"

MSD.Language[lng]["There is no quests avalible"] = "На данный момент квесты отсутствуют"

MSD.Language[lng]["Give weapon"] = "Дать оружие"
MSD.Language[lng]["Give ammo"] = "Дать патроны"
MSD.Language[lng]["Strip Weapon"] = "Забрать оружие"
MSD.Language[lng]["Spawn quest entity"] = "Заспавнить квестовый энтити"
MSD.Language[lng]["Spawn entity"] = "Заспавнить энтити"
MSD.Language[lng]["Spawn npc"] = "Заспавнить НПС"
MSD.Language[lng]["Manage do time"] = "Управление временем для квеста"
MSD.Language[lng]["Spawn vehicle"] = "Заспавнить транспорт"
MSD.Language[lng]["Remove vehicle"] = "Убрать транспорт"
MSD.Language[lng]["Remove all entites"] = "Убрать все энтити"
MSD.Language[lng]["Set HP"] = "Установить ХП"
MSD.Language[lng]["Set Armor"] = "Установить броню"

MSD.Language[lng]["DarkRP money"] = "DarkRP Валюта"

MSD.Language[lng]["Quest NPCs are disabled"] = "Квестовые НПС выключены"
MSD.Language[lng]["You can enable them in settings"] = "Вы можете включить их в настройках"
--PATH addons/pcasino/lua/perfectcasino/derma/cl_fonts.lua:
-- This just creates the font. to keep them organised
surface.CreateFont("pCasino.Header.Static", {
	font = "Roboto",
	size = 35,
})
surface.CreateFont("pCasino.Title.Static", {
	font = "Roboto",
	size = 36,
})
surface.CreateFont("pCasino.Entity.Bid", {
	font = "Roboto",
	size = 40,
})
surface.CreateFont("pCasino.Entity.Arrows", {
	font = "Roboto",
	size = 60,
})
surface.CreateFont("pCasino.SubTitle.Static", {
	font = "Roboto",
	size = 24,
})
surface.CreateFont("pCasino.Main.Static", {
	font = "Roboto",
	size = 28,
})
surface.CreateFont("pCasino.Nav.Static", {
	font = "Roboto",
	size = 25,
})
surface.CreateFont("pCasino.Textbox.Static", {
	font = "Roboto",
	size = 20,
	weight = 500,
})
surface.CreateFont("pCasino.Button.Micro", {
	font = "Roboto",
	size = 15,
	weight = 500,
})
--PATH addons/pcasino/lua/perfectcasino/core/sh_chip.lua:
-- All the types of chips
PerfectCasino.Chips.Types = {1, 5, 10, 25, 50, 100, 250, 500, 1000, 2000, 5000, 25000, 50000, 100000, 250000, 500000, 1000000, 10000000, 100000000, 1000000000, 10000000000}
-- Builds a stack of chips to equal the number given
function PerfectCasino.Chips:GetFromNumber(num)
	local total = num
	local chips = {}

	-- Loop the chip set and break it into chips
	for i = #PerfectCasino.Chips.Types, 1, -1 do
		local chip = PerfectCasino.Chips.Types[i]
		-- We offset by 1 to account for skins starting at 0
		chips[i-1] = math.floor(total/chip)
		total = total - (chips[i-1]*chip)

		-- Don't include it if it's empty
		if chips[i-1] == 0 then
			chips[i-1] = nil
		end
	end

	return chips
end

--PATH addons/pcasino/lua/perfectcasino/config/sh_language.lua:
-- Config Menu
PerfectCasino.Translation.ConfigMenu = {}
PerfectCasino.Translation.ConfigMenu.Title = "pCasino Entity Creator"
PerfectCasino.Translation.ConfigMenu.EntityToConfig = "Entity To Config"
PerfectCasino.Translation.ConfigMenu.EntityToConfigComboBox = "Choose an entity!"
PerfectCasino.Translation.ConfigMenu.RewardComboBox = "Choose a reward!"
PerfectCasino.Translation.ConfigMenu.SpawnEntity = "Create Entity"
PerfectCasino.Translation.ConfigMenu.ResetButton = "Go Back"
PerfectCasino.Translation.ConfigMenu.AddComboButton = "New Combo"
PerfectCasino.Translation.ConfigMenu.TableHeaderChance = "Combo"
PerfectCasino.Translation.ConfigMenu.TableHeaderActions = "Actions"
PerfectCasino.Translation.ConfigMenu.TakeoutBonusMultiplier = "Takeout Bonus Multiplier:"
PerfectCasino.Translation.ConfigMenu.IsJackpot = "Is Jackpot:"
PerfectCasino.Translation.ConfigMenu.Delete = "DELETE"

-- Entities
PerfectCasino.Translation.Entities = {}
PerfectCasino.Translation.Entities["pcasino_slot_machine"] = "Basic Slot Machine"
PerfectCasino.Translation.Entities["pcasino_wheel_slot_machine"] = "Wheel Slot Machine"
PerfectCasino.Translation.Entities["pcasino_roulette_table"] = "Roulette Table"
PerfectCasino.Translation.Entities["pcasino_blackjack_table"] = "Blackjack Table"
PerfectCasino.Translation.Entities["pcasino_mystery_wheel"] = "Mystery Wheel"
PerfectCasino.Translation.Entities["pcasino_sign_plaque"] = "Sign Plaque"
PerfectCasino.Translation.Entities["pcasino_sign_stand"] = "Sign Stand"
PerfectCasino.Translation.Entities["pcasino_sign_wall_logo"] = "Sign Wall Logo"
PerfectCasino.Translation.Entities["pcasino_sign_interior_standing"] = "Sign Interior Standing"
PerfectCasino.Translation.Entities["pcasino_sign_interior_wall"] = "Sign Interior Wall"
PerfectCasino.Translation.Entities["pcasino_chair"] = "Chair"
PerfectCasino.Translation.Entities["pcasino_prize_plinth"] = "Prize Plinth"
PerfectCasino.Translation.Entities["pcasino_npc"] = "NPC"

-- Rewards
PerfectCasino.Translation.Rewards = {}
PerfectCasino.Translation.Rewards["nothing"] = "Nothing"
PerfectCasino.Translation.Rewards["money"] = "Money"
PerfectCasino.Translation.Rewards["jackpot"] = "Jackpot"
PerfectCasino.Translation.Rewards["prize_wheel"] = "Free Mystery Wheel Spin"
PerfectCasino.Translation.Rewards["weapon"] = "Weapon"
PerfectCasino.Translation.Rewards["health"] = "Health"
PerfectCasino.Translation.Rewards["armor"] = "Armor"
PerfectCasino.Translation.Rewards["kill"] = "Kill"
PerfectCasino.Translation.Rewards["setmodel"] = "Set Playermodel"
PerfectCasino.Translation.Rewards["ps1_points"] = "[Pointshop 1] Points"
PerfectCasino.Translation.Rewards["ps1_item"] = "[Pointshop 1] Item"
PerfectCasino.Translation.Rewards["ps2_points"] = "[Pointshop 2] Points"
PerfectCasino.Translation.Rewards["ps2_item"] = "[Pointshop 2] Item"
PerfectCasino.Translation.Rewards["ps2_prempoints"] = "[Pointshop 2] Premium Points"
PerfectCasino.Translation.Rewards["pssh_points"] = "[SH Pointshop] Points"
PerfectCasino.Translation.Rewards["pssh_item"] = "[SH Pointshop] Item"
PerfectCasino.Translation.Rewards["pssh_prempoints"] = "[SH Pointshop] Premium Points"
PerfectCasino.Translation.Rewards["wcd_givecar"] = "[William's Car Dealer] Give Car"
PerfectCasino.Translation.Rewards["fcd_givecar"] = "[Fresh Car Dealer] Give Car"
PerfectCasino.Translation.Rewards["bwe_givexp"] = "[BrickWall's Essentials] Give XP"
PerfectCasino.Translation.Rewards["mtkn_tokens"] = "[mTokens] Give Tokens"
PerfectCasino.Translation.Rewards["srp_givecar"] = "[SantosRP] Give Car"
PerfectCasino.Translation.Rewards["bc_credits"] = "[Brick's Credits] Credits"
PerfectCasino.Translation.Rewards["3dcd_givecar"] = "[3D Car Dealer 2] Give Car"
PerfectCasino.Translation.Rewards["vcmod_givecar"] = "[VCMod] Give Car"
PerfectCasino.Translation.Rewards["mcd_givecar"] = "[Modern Car Dealer] Give Car"

-- Config Options
PerfectCasino.Translation.Config = {}
PerfectCasino.Translation.Config.general = {}
PerfectCasino.Translation.Config.general.Title = "General Settings"
PerfectCasino.Translation.Config.general.Desc = "The general game settings"
PerfectCasino.Translation.Config.general.betPeriod = "The period after the first bet before the game starts"
PerfectCasino.Translation.Config.general.useFreeSpins = "The ability to use won free spins on this wheel"
PerfectCasino.Translation.Config.general.rope = "Add a rope around the edge"
PerfectCasino.Translation.Config.general.model = "The model to show off"
PerfectCasino.Translation.Config.general.spin = "Make the platform spin"
PerfectCasino.Translation.Config.general.bow = "A cute bow on top (This will not work with models that have oversized collision boxes)"
PerfectCasino.Translation.Config.general.bowOffset = "If having a bow is enabled, you can set a vertical offset here. (Negative or positive)"
PerfectCasino.Translation.Config.general.limitUse = "Only allow use of 1 machine at a time"

PerfectCasino.Translation.Config.buySpin = {}
PerfectCasino.Translation.Config.buySpin.Title = "Buy Spins Settings"
PerfectCasino.Translation.Config.buySpin.Desc = "Buying spins for a wheel"
PerfectCasino.Translation.Config.buySpin.buy = "The ability to purchase a spin for money"
PerfectCasino.Translation.Config.buySpin.cost = "If so, the price a spin costs"
PerfectCasino.Translation.Config.jackpot = {}
PerfectCasino.Translation.Config.jackpot.Title = "Jackpot Settings"
PerfectCasino.Translation.Config.jackpot.Desc = "The jackpot settings"
PerfectCasino.Translation.Config.jackpot.toggle = "Should the jackpot be winnable?"
PerfectCasino.Translation.Config.jackpot.startValue = "Starting Jackpot value"
PerfectCasino.Translation.Config.jackpot.betAdd = "The % of the bet to add to the jackpot. 0.1 = 10%, 0.5 = 50%, 1 = 100%, ect"
PerfectCasino.Translation.Config.reward = {}
PerfectCasino.Translation.Config.reward.Title = "Reward Settings"
PerfectCasino.Translation.Config.reward.Desc = "Choose what reward combos are given"
PerfectCasino.Translation.Config.combo = {}
PerfectCasino.Translation.Config.combo.Title = "Combo Settings"
PerfectCasino.Translation.Config.combo.Desc = "Create combos for payouts"
PerfectCasino.Translation.Config.wheel = {}
PerfectCasino.Translation.Config.wheel.Title = "Wheel Settings"
PerfectCasino.Translation.Config.wheel.Desc = "Set what rewards are given on the wheel"
PerfectCasino.Translation.Config.bet = {}
PerfectCasino.Translation.Config.bet.Title = "Bet Settings"
PerfectCasino.Translation.Config.bet.Desc = "Set bet limits"
PerfectCasino.Translation.Config.bet.default = "The default betting value"
PerfectCasino.Translation.Config.bet.max = "The max betting value"
PerfectCasino.Translation.Config.bet.min = "The minimum betting value"
PerfectCasino.Translation.Config.bet.iteration = "The betting increase when the arrow is pressed"
PerfectCasino.Translation.Config.bet.betLimit = "Max bet per round per user (0 for no limit)"
PerfectCasino.Translation.Config.chance = {}
PerfectCasino.Translation.Config.chance.Title = "Chance Settings"
PerfectCasino.Translation.Config.chance.Desc = "Set the chances of it landing on this item. Higher value = more chance"
PerfectCasino.Translation.Config.chance.Bar = "Chance rates visualized"
PerfectCasino.Translation.Config.other = {}
PerfectCasino.Translation.Config.other.Title = "Other Settings"
PerfectCasino.Translation.Config.other.Desc = "Misc settings"
PerfectCasino.Translation.Config.turn = {}
PerfectCasino.Translation.Config.turn.Title = "Turn Settings"
PerfectCasino.Translation.Config.turn.Desc = "The settings for each turn"
PerfectCasino.Translation.Config.turn.timeout = "The amount of seconds until the turn times out"
PerfectCasino.Translation.Config.payout = {}
PerfectCasino.Translation.Config.payout.Title = "Payout Settings"
PerfectCasino.Translation.Config.payout.Desc = "The payout settings"
PerfectCasino.Translation.Config.payout.win = "The payout multiplier for a win"
PerfectCasino.Translation.Config.payout.blackjack = "The payout multiplier for a blackjack win"
PerfectCasino.Translation.Config.text = {}
PerfectCasino.Translation.Config.text.Title = "Text Settings"
PerfectCasino.Translation.Config.text.Desc = "The text settings"
PerfectCasino.Translation.Config.text.overhead = "The text to display above the NPC"
PerfectCasino.Translation.Config.text.chat = "The chat message to say when interacted with"

-- Toolgun
PerfectCasino.Translation.ToolGun = {}
PerfectCasino.Translation.ToolGun.NoEntity = "Please configure an entity with Right Click first"
PerfectCasino.Translation.ToolGun.DeletePermissions = "FPP BLOCKS YOUR PCASINO TOOLGUN PERMISSIONS"
PerfectCasino.Translation.ToolGun.FPPCheck = "Check you can toolgun this entity with FPP!"

-- Entity Interfaces
PerfectCasino.Translation.UI = {}
PerfectCasino.Translation.UI.JackPot = "JackPot: %s"
PerfectCasino.Translation.UI.Number = "Number: %i"
PerfectCasino.Translation.UI.Start = "Start: %is"
PerfectCasino.Translation.UI.PlaceBet = "Place Bet"
PerfectCasino.Translation.UI.Waiting = "Waiting"
PerfectCasino.Translation.UI.DoubleDown = "Double Down"
PerfectCasino.Translation.UI.Split = "Split"
PerfectCasino.Translation.UI.Hit = "Hit"
PerfectCasino.Translation.UI.Stand = "Stand"
PerfectCasino.Translation.UI.Blackjack = "%i (Blackjack)"
PerfectCasino.Translation.UI.Bust = "%i (Bust)"
PerfectCasino.Translation.UI.CurrentHandTotalValue = "Hand Value: %s"
PerfectCasino.Translation.UI.CurrentHand = "Current Hand: %s"
PerfectCasino.Translation.UI.SpinThatWheel = "Spin That Wheel!"
PerfectCasino.Translation.UI.ReadyToPlay = "Ready To Play!"
PerfectCasino.Translation.UI.PurchaseASpin = "Purchase a Spin!"
PerfectCasino.Translation.UI.FreeSpin = "Free Spin!"
PerfectCasino.Translation.UI.FreeSpinCount = "Free Spins: %s"
PerfectCasino.Translation.UI.Play = "Play: %s"
PerfectCasino.Translation.UI.LeaveSeat = "Hold E to leave the seat"
PerfectCasino.Translation.UI.BetLimit = "Bet Limit: %s"

-- Chat messages
PerfectCasino.Translation.Chat = {}
PerfectCasino.Translation.Chat.NoMoney = "You do not have enough money to place this bet..."
PerfectCasino.Translation.Chat.Payout = "You have won %s!"
PerfectCasino.Translation.Chat.RouletteFail = "None of your bets paid out..."
PerfectCasino.Translation.Chat.PayoutJackpot = "You hit the jackpot worth %s!"
PerfectCasino.Translation.Chat.AlreadyPlaced = "You have already placed a bet..."
PerfectCasino.Translation.Chat.BetPlaced = "Your bet has been placed!"
PerfectCasino.Translation.Chat.HandBust = "Your hand has bust, you will receive no payout..."
PerfectCasino.Translation.Chat.DealerHandBust = "The dealer has bust, your payout is %s!"
PerfectCasino.Translation.Chat.HandDraw = "You drew with the house, your bet has been returned to you."
PerfectCasino.Translation.Chat.HandLose = "The house's hand beats your hand, you will receive no payout..."
PerfectCasino.Translation.Chat.HandWin = "You beat the house, your payout is %s!"
PerfectCasino.Translation.Chat.SlotWheelSpin = "You spun the wheel and got %s!"
PerfectCasino.Translation.Chat.UsedFreeSpin = "You have used a free spin!"
PerfectCasino.Translation.Chat.UsedPaidSpin = "You have paid %s for a spin!"
PerfectCasino.Translation.Chat.BetLimit = "You have reached the betting limit for this round!"
PerfectCasino.Translation.Chat.WillReachBetLimit = "This bet will exceed the bet limit. You cannot bet more than %s..."
PerfectCasino.Translation.Chat.LimitMachineUse = "You are trying to use a different machine too quickly..."
PerfectCasino.Translation.Chat.LimitMachineUsedByOther = "This machine is currently being used by someone else!"

--PATH addons/permanent_sweps/lua/autorun/perm_swepy_load.lua:
if SERVER then
	AddCSLuaFile("perm_swepy/shared_perm_sweps.lua")
	AddCSLuaFile("perm_swepy/cl_perm_sweps.lua")
	include("perm_swepy/shared_perm_sweps.lua")
	include("perm_swepy/sv_perm_sweps.lua")
else
	include("perm_swepy/shared_perm_sweps.lua")
	include("perm_swepy/cl_perm_sweps.lua")
end

--PATH addons/sl_utils/lua/autorun/runscripthidenames.lua:
AddCSLuaFile()
if SERVER then
	print("Hide names script by le0nid0s loaded.")
	local l_scriptEnabled = true

	function hereGoesANewPlayer(ply)
		if(l_scriptEnabled)then
			ply:SendLua("function GAMEMODE:HUDDrawTargetID() return false end RunConsoleCommand('hud_deathnotice_time', '0')")
		end
	end

	function toggleHideNames(player)
		if(player:IsSuperAdmin())then
			if(l_scriptEnabled)then
				PrintMessage(HUD_PRINTTALK, "Names are shown")
			else
				PrintMessage(HUD_PRINTTALK, "Names are hidden")
			end
			l_scriptEnabled = !l_scriptEnabled
			umsg.Start("toggleHideNamesScript")
			umsg.Bool(l_scriptEnabled)
			umsg.End()
		end
	end

	concommand.Add("toggleHideNames",toggleHideNames)
	hook.Add("PlayerInitialSpawn", "Hides names", hereGoesANewPlayer)
end

if CLIENT then
	usermessage.Hook( "toggleHideNamesScript", function(data) //toggleHideNamesClient)local function toggleHideNamesClient(data)
		if(!data:ReadBool()) then
			function GAMEMODE:HUDDrawTargetID()
				local tr = util.GetPlayerTrace( LocalPlayer() )
				local trace = util.TraceLine( tr )
				if (!trace.Hit) then return end
				if (!trace.HitNonWorld) then return end
					
				local text = "ERROR"
				local font = "TargetID"
					
				if (trace.Entity:IsPlayer()) then
					text = trace.Entity:Nick()
				else
					return
						--text = trace.Entity:GetClass()
				end
					
				surface.SetFont( font )
				local w, h = surface.GetTextSize( text )
					
				local MouseX, MouseY = gui.MousePos()
					
				if ( MouseX == 0 && MouseY == 0 ) then
					MouseX = ScrW() / 2
					MouseY = ScrH() / 2
				end
					
				local x = MouseX
				local y = MouseY
					
				x = x - w / 2
				y = y + 30
					
				-- The fonts internal drop shadow looks lousy with AA on
				draw.SimpleText( text, font, x+1, y+1, Color(0,0,0,120) )
				draw.SimpleText( text, font, x+2, y+2, Color(0,0,0,50) )
				draw.SimpleText( text, font, x, y, self:GetTeamColor( trace.Entity ) )
					
				y = y + h + 5
					
				local text = trace.Entity:Health() .. "%"
				local font = "TargetIDSmall"
					
				surface.SetFont( font )
				local w, h = surface.GetTextSize( text )
				local x =  MouseX  - w / 2
					
				draw.SimpleText( text, font, x+1, y+1, Color(0,0,0,120) )
				draw.SimpleText( text, font, x+2, y+2, Color(0,0,0,50) )
				draw.SimpleText( text, font, x, y, self:GetTeamColor( trace.Entity ) )
			end
			RunConsoleCommand('hud_deathnotice_time', '6')
		else
			function GAMEMODE:HUDDrawTargetID()
				return false
			end 
			RunConsoleCommand('hud_deathnotice_time', '0')
		end
	end)
end
--PATH addons/sam-157/lua/sam/libs/sh_sfs.lua:
-- SFS (Srlion's Fast Serializer)
-- we try to avoid NYI operations in luajit as much as possible
-- unforunately, we can't avoid all of them in luajit 2.0.5 - pairs & table.concat
-- https://github.com/tarantool/tarantool/wiki/LuaJIT-Not-Yet-Implemented
-- we don't use string concating because it's also NYI in luajit 2.0.5
-- we never error so we don't get blacklisted by the jit compiler
-- errors return strings instead of throwing errors

-- this is intentionally made for net messages, so you don't have to use pcall to check if there are any errors
-- you should use this without using util.Compress, as this just adds one byte to each value, you will probably end up with a larger string if you compress it

-- this idea is from messagepack which is really smart
-- small numbers (0 ~ 127) and (-32 ~ -1) are encoded as a single byte
-- tables and arrays are encoded with a prefix byte, which is the number of elements in the table or array, but it can be one byte if it's less than 16
-- strings are encoded with a prefix byte, which is the length of the string, but it can be one byte if it's less than 32

local math = math
local HUGE = math.huge
local floor = math.floor
local internal_type = type
local IsColor = IsColor
local type = function(v)
    if IsColor(v) then
        return "Color"
    end
    return internal_type(v)
end

-- string.char is not jit compiled in luajit 2.0.5
local chars = {}; do
    for i = 0, 255 do
        chars[i] = string.char(i)
    end
end

local MAX_NUMBER = 1.7976931348623e+308
local MIN_NUMBER = -MAX_NUMBER

---
local POSITIVE_INT = 0x00
local POSITIVE_INT_END = 0x7f

local TABLE_FIXED = 0x80
local TABLE_FIXED_END = 0x8f

local ARRAY_FIXED = 0x90
local ARRAY_FIXED_END = 0x9f

local STR_FIXED = 0xa0
local STR_FIXED_END = 0xbf

local NIL = 0xc0
local FALSE = 0xc1
local TRUE = 0xc2

local UINT_8 = 0xc3
local UINT_16 = 0xc4
local UINT_32 = 0xc5
local UINT_52 = 0xc6

local NINT_8 = 0xc7
local NINT_16 = 0xc8
local NINT_32 = 0xc9
local NINT_52 = 0xca

local DOUBLE = 0xcb

local STR_8 = 0xcc
local STR_16 = 0xcd
local STR_32 = 0xce

local ARRAY_8 = 0xcf
local ARRAY_16 = 0xd0
local ARRAY_32 = 0xd1

local TABLE_8 = 0xd2
local TABLE_16 = 0xd3
local TABLE_32 = 0xd4

local VECTOR = 0xd5
local ANGLE = 0xd6

local ENTITY = 0xd7
local PLAYER = 0xd8

local COLOR = 0xd9

-- this was added in version 2.0.0
-- it's used for arrays that start at 0, I'm not sure if lua 5.1 has same behavior as luajit 2.0.5
-- but luajit 2.0.5 supports starting arrays at 0 index, so checking if table is an array or not gets messed up and output is wrong
-- so if you supply local t = {[0] = 0, 1, 2, 3} and do next(t, #t) it will return (nil, nil) instead of (0, 0)
local ARRAY_ZERO_BASED_INDEX = 0xda

local FREE_FOR_CUSTOM = 0xdb
local FREE_FOR_CUSTOM_END = 0xdf

local NEGATIVE_INT = 0xe0
local NEGATIVE_INT_END = 0xff
---

local encoders = {}
local Encoder = {
    encoders = encoders
}
do
    local pairs = pairs
    local next = next
    local ceil = math.ceil
    local log = math.log
    local concat = table.concat
    local write, write_unsigned, write_double

    -- garry's mod related
    local Vector_Unpack, Angle_Unpack
    local Entity_EntIndex, Player_UserID
    if FindMetaTable then
        Vector_Unpack = FindMetaTable("Vector").Unpack
        Angle_Unpack = FindMetaTable("Angle").Unpack

        Entity_EntIndex = FindMetaTable("Entity").EntIndex
        Player_UserID = FindMetaTable("Player").UserID
    end
    --

    local get_encoder = function(buf, t)
        local encoder = encoders[type(t)]
        if encoder == nil then
            write(buf, "Unsupported type: ")
            write(buf, type(t))
            return nil
        end
        return encoder
    end

    local buffer = {
        [0] = 0 -- buffer length
    }

    -- this function is obviously not jit compiled in luajit 2.0.5 but internal functions are
    function Encoder.encode(val, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        local encoder = get_encoder(buffer, val)
        if encoder == nil then
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        if encoder(buffer, val, arg) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function Encoder.encode_array(arr, len, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        if encoders.array(buffer, arr, len) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function write(buf, chr)
        local buf_len = buf[0] + 1
        buf[0] = buf_len
        buf[buf_len] = chr
    end
    Encoder.write = write

    encoders["nil"] = function(buf)
        write(buf, chars[NIL])
    end

    function encoders.boolean(buf, bool)
        if bool == true then
            write(buf, chars[TRUE])
        else
            write(buf, chars[FALSE])
        end
    end

    function encoders.array(buf, arr, len, start_index)
        start_index = (start_index == nil or start_index ~= 0 and start_index ~= 1) and 1 or start_index

        if len < 0 then
            write(buf, "Array size cannot be negative: ")
            write(buf, len)
            return true
        elseif len > 0xFFFFFFFF then
            write(buf, "Array size too large to encode: ")
            write(buf, len)
            return true
        end

        if len <= 0xF then
            write(buf, chars[ARRAY_FIXED + len])
        else
            write_unsigned(buf, ARRAY_8, len)
        end

        if start_index == 0 then
            write(buf, chars[ARRAY_ZERO_BASED_INDEX])
        end

        for idx = start_index, len do
            local val = arr[idx]
            local encoder = get_encoder(buf, val)
            if encoder == nil then return true end
            encoder(buf, val)
        end
    end

    -- we can't check if a table is an array or not because lua tables are not arrays, they are tables
    -- use Encoder.encode_array if you want to encode an array
    function encoders.table(buf, tbl)
        -- check if it's an array, it's not accurate for arrays with holes but better than nothing
        do
            -- this is the fastest possible way, a lot better than cbor's/messagepack's/pon's way of checking if it's an array
            local tbl_len = #tbl
            if tbl_len > 0 and next(tbl, tbl_len) == nil and ((tbl_len == 1 and next(tbl) == 1) or (tbl_len > 1 and next(tbl, tbl_len - 1) == tbl_len)) then
                if tbl[0] ~= nil then
                    return encoders.array(buf, tbl, tbl_len, 0)
                else
                    return encoders.array(buf, tbl, tbl_len)
                end
            end
        end

        local buf_len = buf[0]
        local table_start = buf_len -- we store the start of the table so when we write the table size, we can change the current buffer index to the start of the table
        -- we have no way to get the table size without iterating through it, so we just add 5 empty strings to the buffer as a placeholder
        -- we add 5 empty strings because we don't know if table size is going to be a fixed number, uint8, uint16 or uint32
        -- uint32 takes 5 bytes, so we add 5 empty strings
        do
            for idx = 1, 5 do
                buf[buf_len + idx] = ""
            end
            buf_len = buf_len + 5
            buf[0] = buf_len
        end

        local table_count = 0
        for key, val in pairs(tbl) do
            table_count = table_count + 1

            local encoder_key = get_encoder(buf, key)
            if encoder_key == nil then return true end
            encoder_key(buf, key)

            local encoder_val = get_encoder(buf, val)
            if encoder_val == nil then return true end
            encoder_val(buf, val)
        end

        local table_end = buf[0] -- we store the end of the table because we need to change current buffer index to the start of the table to write the table size
        buf[0] = table_start -- change current buffer index to the start of the table

        -- write the table size
        if table_count <= 0xF then
            write(buf, chars[TABLE_FIXED + table_count])
        else
            if table_count > 0xFFFFFFFF then
                write(buf, "Table size too large to encode: ")
                write(buf, table_count)
                return true
            end
            write_unsigned(buf, TABLE_8, table_count)
        end

        buf[0] = table_end -- change current buffer index back to the end of the table
    end

    function encoders.string(buf, str)
        local str_len = #str
        if str_len > 0xFFFFFFFF then
            write(buf, "String too large to encode: ")
            write(buf, str_len)
            return true
        end

        if str_len <= 0x1F then
            write(buf, chars[STR_FIXED + str_len])
        else
            write_unsigned(buf, STR_8, str_len)
        end
        write(buf, str)
    end

    function encoders.number(buf, num)
        if (num > MAX_NUMBER and num ~= HUGE) or (num < MIN_NUMBER and num ~= -HUGE) then
            write(buf, "Number too large to encode: ")
            write(buf, num)
            return true
        end

        if num % 1 ~= 0 or num > 0xFFFFFFFFFFFFF or num < -0xFFFFFFFFFFFFF then -- DOUBLE
            write_double(buf, DOUBLE, num)
            return
        end

        if num < 0 then
            num = -num
            if num <= 0x1F then
                write(buf, chars[NEGATIVE_INT + num])
            else
                write_unsigned(buf, NINT_8, num)
            end
        else
            if num <= 0x7F then
                write(buf, chars[POSITIVE_INT + num])
            else
                write_unsigned(buf, UINT_8, num)
            end
        end
    end

    function encoders.Vector(buf, vec)
        write(buf, chars[VECTOR])
        local x, y, z = Vector_Unpack(vec)
        encoders.number(buf, x)
        encoders.number(buf, y)
        encoders.number(buf, z)
    end

    function encoders.Angle(buf, ang)
        write(buf, chars[ANGLE])
        local p, y, r = Angle_Unpack(ang)
        encoders.number(buf, p)
        encoders.number(buf, y)
        encoders.number(buf, r)
    end

    function encoders.Entity(buf, ent)
        write(buf, chars[ENTITY])
        encoders.number(buf, Entity_EntIndex(ent))
    end

    function encoders.Player(buf, ply)
        write(buf, chars[PLAYER])
        encoders.number(buf, Player_UserID(ply))
    end

    function encoders.Color(buf, col)
        write(buf, chars[COLOR])
        encoders.number(buf, col.r)
        encoders.number(buf, col.g)
        encoders.number(buf, col.b)
        encoders.number(buf, col.a)
    end

    function write_unsigned(buf, tag, num)
        if num <= 0xFF then -- uint8
            write(buf, chars[tag + 0x00])
            write(buf, chars[num])
        elseif num <= 0xFFFF then -- uint16
            write(buf, chars[tag + 0x01])
            write(buf, chars[floor(num / 256)])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFF then -- uint32
            write(buf, chars[tag + 0x02])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFFFFFFF then -- uint52
            write(buf, chars[tag + 0x3])
            write(buf, chars[num % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x100000000) % 256])
            write(buf, chars[floor(num / 0x10000000000) % 256])
            write(buf, chars[floor(num / 0x1000000000000) % 256])
        end
    end
    Encoder.write_unsigned = write_unsigned

    -- i can't remember where i got this from, but it's not mine (i swear i always credit people)
    local log2 = log(2)
    function write_double(buf, tag, value)
        local abs_value = value < 0 and -value or value
        --IEEE double-precision floating point number
        --Specification: https://en.wikipedia.org/wiki/Double-precision_floating-point_format
        --Separate out the sign, exponent and fraction
        local sign = value < 0 and 1 or 0
        local exponent = ceil(log(abs_value) / log2) - 1
        local fraction = abs_value / (2 ^ exponent) - 1
        --Make sure the exponent stays in range - allowed values are -1023 through 1024
        if exponent < -1023 then
            --We allow this case for subnormal numbers and just clamp the exponent and re-calculate the fraction
            --without the offset of 1
            exponent = -1023
            fraction = abs_value / (2 ^ exponent)
        elseif abs_value ~= HUGE and exponent > 1024 then
            write(buf, "Exponent out of range: ")
            write(buf, value)
            return true
        end

        --Handle special cases
        if value == 0 then
            --Zero
            exponent = -1023
            fraction = 0
        elseif abs_value == HUGE then
            --Infinity
            exponent = 1024
            fraction = 0
        elseif value ~= value then
            --NaN
            exponent = 1024
            fraction = 1
        end

        local exp_out = exponent + 1023
        local fraction_out = fraction * 0x10000000000000

        write(buf, chars[tag])
        write(buf, chars[128 * sign + floor(exp_out / 16)])
        write(buf, chars[(exp_out % 16) * 16 + floor(fraction_out / 0x1000000000000)])
        write(buf, chars[floor(fraction_out / 0x10000000000) % 256])
        write(buf, chars[floor(fraction_out / 0x100000000) % 256])
        write(buf, chars[floor(fraction_out / 0x1000000) % 256])
        write(buf, chars[floor(fraction_out / 0x10000) % 256])
        write(buf, chars[floor(fraction_out / 0x100) % 256])
        write(buf, chars[floor(fraction_out % 256)])
    end
    Encoder.write_double = write_double
end

local decoders = {}
local Decoder = {
    decoders = decoders
}
do
    local sub = string.sub

    local read_type, read_byte, read_word, read_dword
    local decode_array, decode_table, decode_string, decode_double

    -- garry's mod related
    local Vector, Angle, Entity, Player, Color = Vector, Angle, Entity, Player, Color
    --

    local str_byte = string.byte
    local byte = function(ctx, size)
        local index = ctx[1]
        if index + size - 1 > ctx[3] then -- buffer length
            return nil, "Attemped to read beyond buffer size"
        elseif index + size - 1 > ctx[4] then -- max size
            return nil, "Max decode size exceeded"
        end
        ctx[1] = index + size
        return str_byte(ctx[2], index, index + size - 1)
    end
    Decoder.byte = byte

    local get_decoder = function(ctx)
        local t = read_type(ctx)
        local decoder = decoders[t]
        if decoder == nil then
            return nil, "Unsupported type: ", t
        end
        return decoder
    end
    Decoder.get_decoder = get_decoder

    local context = {
        1,  -- index
        "", -- buffer
        0,  -- buffer length
        HUGE, -- max size for decode, useful when decoding from user input that was sent over netmessages
    }

    local decode = function()
        if context[3] < 1 then -- this will make string.byte fail
            return nil, "Buffer is empty"
        end

        local err, err_2
        local decoder
        local val

        decoder, err, err_2 = get_decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        val, err, err_2 = decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        return val
    end

    function Decoder.decode(str)
        if type(str) ~= "string" then
            return nil, "str is not a string", str
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = HUGE

        return decode()
    end

    function Decoder.decode_with_max_size(str, max_size)
        if type(str) ~= "string" then
            return nil, "str is not a string", str
        end

        if type(max_size) ~= "number" then
            return nil, "max_size is not a number", max_size
        end

        if max_size < 0 then
            return nil, "max_size can either be a positive number or math.huge for unlimited", max_size
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = max_size

        return decode()
    end

    decoders[NIL] = function(ctx)
        ctx[1] = ctx[1] + 1
        return nil
    end

    decoders[FALSE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return false
    end

    decoders[TRUE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return true
    end

    --
    decoders[ARRAY_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - ARRAY_FIXED
        return decode_array(ctx, len)
    end

    for i = ARRAY_FIXED + 1, ARRAY_FIXED_END do
        decoders[i] = decoders[ARRAY_FIXED]
    end
    --

    decoders[ARRAY_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if len == nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    --
    decoders[TABLE_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - TABLE_FIXED
        return decode_table(ctx, len)
    end

    for i = TABLE_FIXED + 1, TABLE_FIXED_END do
        decoders[i] = decoders[TABLE_FIXED]
    end
    --

    decoders[TABLE_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    --
    decoders[STR_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        local len = bty - STR_FIXED
        return decode_string(ctx, len)
    end

    for i = STR_FIXED + 1, STR_FIXED_END do
        decoders[i] = decoders[STR_FIXED]
    end
    --

    decoders[STR_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    --
    decoders[POSITIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return bty - POSITIVE_INT
    end

    for i = POSITIVE_INT + 1, POSITIVE_INT_END do
        decoders[i] = decoders[POSITIVE_INT]
    end
    --

    decoders[UINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u8, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return u8
    end

    decoders[UINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return u16
    end

    decoders[UINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return u32
    end

    decoders[UINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000)
    end

    --
    decoders[NEGATIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        return NEGATIVE_INT - bty
    end

    for i = NEGATIVE_INT + 1, NEGATIVE_INT_END do
        decoders[i] = decoders[NEGATIVE_INT]
    end
    --

    decoders[NINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n8, err = read_byte(ctx)
        if n8 == nil then
            return nil, err
        end
        return -n8
    end

    decoders[NINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n16
    end

    decoders[NINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n32
    end

    decoders[NINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return -(b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000))
    end

    decoders[DOUBLE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return decode_double(ctx)
    end

    decoders[VECTOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local x, y, z

        -- x
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        x, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- z
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        z, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Vector(x, y, z)
    end

    decoders[ANGLE] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local p, y, r

        -- p
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        p, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Angle(p, y, r)
    end

    decoders[ENTITY] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local ent_index

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        ent_index, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Entity(ent_index)
    end

    decoders[PLAYER] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local user_id

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        user_id, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Player(user_id)
    end

    decoders[COLOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local r, g, b, a

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- g
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        g, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- b
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        b, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- a
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        a, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Color(r, g, b, a)
    end

    function decode_array(ctx, len)
        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local arr = {nil, nil, nil, nil, nil, nil, nil, nil}

        local start_index = 1
        if read_type(ctx) == ARRAY_ZERO_BASED_INDEX then
            ctx[1] = ctx[1] + 1
            start_index = 0
        end

        for idx = start_index, len do
            local err, err_2
            local decoder
            local val

            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end

            arr[idx] = val
        end

        return arr
    end
    Decoder.decode_array = decode_array

    function decode_table(ctx, len)
        local err, err_2
        local decoder
        local key, val

        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local tbl = {nil, nil, nil, nil, nil, nil, nil, nil}
        for _ = 1, len do
            -- key
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            key, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            -- val
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            tbl[key] = val
        end

        return tbl
    end
    Decoder.decode_table = decode_table

    function decode_string(ctx, len)
        local index = ctx[1]
        if index + len - 1 > ctx[3] then
            return nil, "Attemped to read beyond buffer size"
        elseif index + len - 1 > ctx[4] then
            return nil, "Max decode size exceeded"
        end

        ctx[1] = index + len

        return sub(ctx[2], index, index + len - 1)
    end
    Decoder.decode_string = decode_string

    function decode_double(ctx)
        local b1, b2, b3, b4, b5, b6, b7, b8 = byte(ctx, 8)
        if b1 == nil then
            return nil, b2
        end

        --Separate out the values
        local sign = b1 >= 128 and 1 or 0
        local exponent = (b1 % 128) * 16 + floor(b2 / 16)
        local fraction = (b2 % 16) * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8
        --Handle special cases
        if exponent == 2047 then
            --Infinities
            if fraction == 0 then return ((sign == 0 and 1) or -1) * HUGE end
            --NaN
            if fraction == 0xfffffffffffff then return 0 / 0 end
        end

        --Combine the values and return the result
        if exponent == 0 then
            --Handle subnormal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * (fraction / 0x10000000000000)
        else
            --Handle normal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * ((fraction / 0x10000000000000) + 1)
        end
    end
    Decoder.decode_double = decode_double

    function read_type(ctx)
        local typ = str_byte(ctx[2], ctx[1])
        return typ
    end
    Decoder.read_type = read_type

    function read_byte(ctx)
        local bty, err = byte(ctx, 1)
        if bty == nil then
            return nil, err
        end
        return bty
    end
    Decoder.read_byte = read_byte

    function read_word(ctx)
        local b1, b2 = byte(ctx, 2)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x100 + b2
    end
    Decoder.read_word = read_word

    function read_dword(ctx)
        local b1, b2, b3, b4 = byte(ctx, 4)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x1000000 + b2 * 0x10000 + b3 * 0x100 + b4
    end
    Decoder.read_dword = read_dword
end

return {
    Encoder = Encoder, -- to allow usage of internal functions
    Decoder = Decoder, -- to allow usage of internal functions

    encode = Encoder.encode,
    encode_with_buffer = Encoder.encode_with_buffer,
    encode_array = Encoder.encode_array,

    decode = Decoder.decode,
    decode_with_max_size = Decoder.decode_with_max_size,

    set_type_function = function(t_fn) -- this is for me as I have custom type function in sam/scb to allow type function to get jit compiled :c
        type = t_fn
    end,

    add_encoder = function(typ, encoder)
        encoders[typ] = encoder
        if FREE_FOR_CUSTOM == FREE_FOR_CUSTOM_END then
            return nil, "No more free slots for custom encoders"
        end
        FREE_FOR_CUSTOM = FREE_FOR_CUSTOM + 1
        return FREE_FOR_CUSTOM - 1
    end,

    add_decoder = function(typ, decoder)
        decoders[typ] = decoder
    end,

    chars = chars,
    VERSION = "2.0.8"
}

--PATH addons/sam-157/lua/sam/sh_colors.lua:
if SAM_LOADED then return end

local colors = {
	Red   = Color(244, 67, 54),
	Blue  = Color(13, 130, 223),
	Green = Color(0, 230, 64),
	White = Color(236, 240, 241),
	Black = Color(10, 10, 10)
}

function sam.get_color(name)
	return colors[name]
end

function sam.add_color(name, color)
	if isstring(name) and IsColor(color) then
		colors[name] = color
	end
end
--PATH addons/sam-157/lua/sam/config/sh_config.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

sam.permissions.add("manage_config", nil, "superadmin")

local updates = {}
function config.hook(keys, func)
	for i = #keys, 1, -1 do
		keys[keys[i]] = true
		keys[i] = nil
	end

	local id = table.insert(updates, {
		keys = keys,
		func = func
	})

	if config.loaded then
		func()
	end

	return id
end

function config.get_updated(key, default)
	local setting = {}
	config.hook({key}, function()
		setting.value = config.get(key, default)
	end)
	return setting
end

function config.remove_hook(key)
	updates[key] = nil
end

hook.Add("SAM.LoadedConfig", "RunHooks", function()
	for k, v in pairs(updates) do
		v.func()
	end
end)

hook.Add("SAM.UpdatedConfig", "RunHooks", function(key, value, old)
	for k, v in pairs(updates) do
		if v.keys[key] then
			v.func(value, old)
		end
	end
end)
--PATH addons/sam-157/lua/sam/player/cl_player.lua:
if SAM_LOADED then return end

local sam = sam
local netstream = sam.netstream

netstream.Hook("PlaySound", function(sound)
	surface.PlaySound(sound)
end)
--PATH addons/sam-157/lua/sam/command/cl_command.lua:
if SAM_LOADED then return end

local sam = sam
local command = sam.command

local get_syntax = function(args, cmd_args, cmd_str)
	for i = 1, #cmd_args do
		cmd_str = cmd_str .. " "

		local cmd_arg = cmd_args[i]
		local arg = args[i]

		if arg == "" then
			arg = nil
		end

		local optional = cmd_arg.optional
		local c_1, c_2 = "<", ">"
		if optional then
			c_1, c_2 = "[", "]"
		end

		cmd_str = cmd_str .. (arg and "\"" or c_1)

		cmd_str = cmd_str .. (arg or cmd_arg.hint or cmd_arg.name)

		if not arg then
			local default = cmd_arg.default
			if default then
				cmd_str = cmd_str .. " = " .. tostring(default)
			end
		end

		cmd_str = cmd_str .. (arg and "\"" or c_2)
	end

	return cmd_str
end

--
-- Auto Complete
--
concommand.Add("sam", function(_, _, _, text)
	LocalPlayer():ConCommand("sam_run " .. text)
end, function(_, text)
	local ply = LocalPlayer()
	local result = {}

	local new_arg = text:EndsWith(" ")
	local args = sam.parse_args(text)

	local cmd_name = (args[1] or ""):lower()
	local cmd = command.get_command(cmd_name)

	if not cmd or (#args == 1 and not new_arg) then
		local commands = command.get_commands()

		for _, v in ipairs(commands) do
			local name = v.name
			if name:find(cmd_name, nil, true) and ply:HasPermission(name) then
				table.insert(result, "sam " .. name)
			end
		end

		return result
	end

	if not ply:HasPermission(cmd_name) then return end

	table.remove(args, 1)

	if new_arg then
		local syntax = get_syntax(args, cmd.args, "sam " .. cmd.name)
		if #args == 0 then
			print(syntax)
		end
		table.insert(result, syntax)
		return result
	end

	local arg_index = new_arg and #args + 1 or #args

	local cmd_args = cmd.args
	local cmd_args_n = #cmd_args
	if cmd_args_n == 0 then return end

	if arg_index >= cmd_args_n then
		arg_index = cmd_args_n

		if cmd.get_rest_args then
			local arg = table.concat(args, " ", cmd_args_n)
			if arg ~= "" then
				args[cmd_args_n] = arg
				for i = cmd_args_n + 1, #args do
					args[i] = nil
				end
			end
		end
	end

	local arguments = command.get_arguments()
	local cmd_arg = cmd_args[arg_index]
	local func = arguments[cmd_arg.name].auto_complete
	if func then
		func(cmd_arg, result, args[arg_index] or "")
	end

	local cmd_str = "sam " .. cmd_name .. " "
	if arg_index - 1 > 0 then
		cmd_str = cmd_str .. "\"" .. table.concat(args, "\" ", 1, arg_index - 1) .. "\" "
	end

	for k, v in ipairs(result) do
		result[k] = cmd_str .. "\"" .. v .. "\""
	end

	return result
end)
--PATH addons/sui/lua/sui/libs/types.lua:
-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function sui.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		sui["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function sui.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
sui.IsEntity = sui.isentity

local type = sui.type
function sui.istable(value)
	return type(value) == "table"
end
--PATH addons/sui/lua/sui/libs/png_encoder.lua:
local string = string
local table = table
local bit = bit

local char = string.char
local byte = string.byte

local insert = table.insert
local concat = table.concat

local bor = bit.bor
local bxor = bit.bxor
local band = bit.band
local bnot = bit.bnot
local lshift = bit.lshift
local rshift = bit.rshift

local ceil = math.ceil

local SIGNATURE = char(137, 80, 78, 71, 13, 10, 26, 10)

local crc_table = {}; do
	local n = 0
	while n < 256 do
		local c = n
		local k = 0
		while k < 8 do
			if band(c, 1) ~= 0 then
				c = bxor(0xedb88320, rshift(c, 1))
			else
				c = rshift(c, 1)
			end
			k = k + 1
		end
		crc_table[n + 1] = c
		n = n + 1
	end
end

local crc = function(buf)
	local c = 0xffffffff
	for i = 1, #buf do
		c = bxor(crc_table[band(bxor(c, byte(buf, i)), 0xff) + 1], rshift(c, 8))
	end
	return bxor(c, 0xffffffff)
end

local dword_as_string = function(dword)
	return char(
		rshift(band(dword, 0xff000000), 24),
		rshift(band(dword, 0x00ff0000), 16),
		rshift(band(dword, 0x0000ff00), 8),
		band(dword, 0x000000ff)
	)
end

local create_chunk = function(type, data, length)
	local CRC = crc(type .. data)
	return concat({
		dword_as_string(length or #data),
		type,
		data,
		dword_as_string(CRC)
	}, "", 1, 4)
end

local create_IHDR; do
	local ARGS = (
		-- bit depth
		char(8) ..
		-- color type: 6=truecolor with alpha
		char(6) ..
		-- compression method: 0=deflate, only allowed value
		char(0) ..
		-- filtering: 0=adaptive, only allowed value
		char(0) ..
		-- interlacing: 0=none
		char(0)
	)

	create_IHDR = function(w, h)
		return create_chunk("IHDR", concat({
			dword_as_string(w),
			dword_as_string(h),
			ARGS
		}, "", 1, 3), 13)
	end
end

local deflate_pack; do
	local BASE = 6552
	local NMAX = 5552
	local adler32 = function(str)
		local s1 = 1
		local s2 = 0
		local n = NMAX

		for i = 1, #str do
			s1 = s1 + byte(str, i)
			s2 = s2 + s1

			n = n - 1
			if n == 0 then
				s1 = s1 % BASE
				s2 = s2 % BASE
				n = NMAX
			end
		end

		s1 = s1 % BASE
		s2 = s2 % BASE

		return bor(lshift(s2, 16), s1)
	end

	local splitChunks = function(chunk, chunkSize)
		local len = ceil(#chunk / chunkSize)
		local ret = {}
		for i = 1, len do
			ret[i - 1] = chunk:sub(((i - 1) * chunkSize) + 1, chunkSize)
		end
		return ret
	end

	deflate_pack = function(str)
		local ret = {"\x78\x9c"}

		local chunks = splitChunks(str, 0xFFFF)
		local len = #chunks

		local i = 0
		while i < (len + 1) do
			local chunk = chunks[i]
			local chunk_n = #chunk

			insert(ret, i < len and "\x00" or "\x01")
			insert(ret, char(band(chunk_n, 0xff), band(rshift(chunk_n, 8), 0xff)))
			insert(ret, char(band(bnot(chunk_n), 0xff), band(rshift(bnot(chunk_n), 8), 0xff)))
			insert(ret, chunk)
			i = i + 1
		end

		local t = adler32(str)
		t = char(
			band(rshift(t, 24), 0xff),
			band(rshift(t, 16), 0xff),
			band(rshift(t, 8), 0xff),
			band(t, 0xff)
		)

		insert(ret, t)

		return concat(ret)
	end
end

local create_IDAT; do
	local slice = function(a, s, e)
		local ret, j = {}, 0
		for i = s, e - 1 do
			ret[j] = char(band(a[i] or 0, 0xFF))
			j = j + 1
		end
		return ret
	end

	local array_split_chunks = function(w, h, array, chunkSize)
		local ret = {}
		local i = 0
		local len = ceil((w * h * 4 + 4) / chunkSize)
		while i < len do
			ret[i] = slice(array, i * chunkSize, (i + 1) * chunkSize)
			i = i + 1
		end
		return ret
	end

	create_IDAT = function(w, h, chunk)
		local scanlines = array_split_chunks(w, h, chunk, w * 4)

		local image_bytes = {}
		for i = 0, #scanlines do
			local scanline = scanlines[i]
			insert(image_bytes, char(band(0, 0xFF)))
			insert(image_bytes, concat(scanline, "", 0, #scanline))
		end
		image_bytes = deflate_pack(concat(image_bytes))

		return create_chunk("IDAT", image_bytes)
	end
end

local IEND = create_chunk("IEND", "", 0)
local to_return = {SIGNATURE, nil, nil, IEND}
local generate_png = function(w, h, chunk)
	local IHDR = create_IHDR(w, h)
	local IDAT = create_IDAT(w, h, chunk)

	to_return[2] = IHDR
	to_return[3] = IDAT

	return concat(to_return, "", 1, 4)
end

return generate_png
--PATH addons/sui/lua/sui/vgui/sui_query_box.lua:
local ScrW, ScrH = ScrW, ScrH
local DisableClipping = DisableClipping
local SetDrawColor = surface.SetDrawColor
local DrawRect = surface.DrawRect
local BlurPanel = sui.TDLib.BlurPanel
local lerp_color = sui.lerp_color

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local PANEL = {}

function PANEL:SetCallback(callback)
	self.callback = callback
end

function PANEL:Init()
	self:SetSize(0, 0)

	local bottom = self:Add("Panel")
	bottom:Dock(BOTTOM)
	bottom:DockMargin(4, 10, 4, 4)
	bottom:SetZPos(100)

	local save = bottom:Add(NAME .. ".Button")
	save:SetText("SAVE")
	save:Dock(RIGHT)
	save:SetEnabled(false)
	self.save = save

	function save.DoClick()
		self.callback()
		self:Remove()
	end

	local cancel = bottom:Add(NAME .. ".Button")
	cancel:Dock(RIGHT)
	cancel:DockMargin(0, 0, 4, 0)
	cancel:SetContained(false)
	cancel:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))
	cancel:SetText("CANCEL")
	self.cancel = cancel

	function cancel.DoClick()
		self:Remove()
	end

	bottom:SetSize(save:GetWide() * 2 + 4, SUI.Scale(30))

	local body = self:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(4, 4, 4, 4)
	body:DockPadding(3, 3, 3, 3)
	body:InvalidateLayout(true)
	body:InvalidateParent(true)

	local added = 1
	function body.OnChildAdded(s, child)
		added = added + 1
		child:Dock(TOP)
		child:SetZPos(added)
		child:InvalidateLayout(true)
		s:InvalidateLayout(true)
	end
	self.body = body

	function self:Add(name)
		return body:Add(name)
	end

	local old_Paint = self.Paint
	local trans = Color(0, 0, 0, 0)
	local new_col = Color(70, 70, 70, 100)
	function self:Paint(w, h)
		lerp_color(trans, new_col)

		local x, y = self:LocalToScreen(0, 0)
		DisableClipping(true)
			BlurPanel(self)
			SetDrawColor(trans)
			DrawRect(x * -1, y * -1, ScrW(), ScrH())
		DisableClipping(false)

		old_Paint(self, w, h)
	end
end

function PANEL:ChildrenHeight()
	local body = self.body

	self.header:InvalidateLayout(true)
	local height = self.header:GetTall()

	body:InvalidateLayout(true)
	self:InvalidateLayout(true)
	height = height + select(2, body:ChildrenSize())

	height = height + SUI.Scale(30) + 14 + 6

	return height
end

function PANEL:Paint(w, h)
	if GetColor("frame_blur") then
		BlurPanel(self)
	end

	self:RoundedBox("Background", 8, 0, 0, w, h, GetColor("query_box_bg"))
end

function PANEL:Done()
	self:InvalidateChildren(true)

	self.size_to_children = function()
		local h = self:ChildrenHeight()
		self:RealSetSize(self:GetWide(), h)
		self.real_h = h
	end

	self:Center()
	self:MakePopup()
	self:DoModal(true)

	timer.Simple(0.08, function()
		self:AddAnimations(self:GetWide(), self:ChildrenHeight(), true)
	end)
end

sui.register("QueryBox", PANEL, NAME .. ".Frame")
--PATH addons/sui/lua/sui/vgui/sui_text_entry.lua:
local sui = sui

local surface = surface
local utf8 = sui.utf8
local draw = draw
local math = math

local IsValid = IsValid
local tostring = tostring
local tonumber = tonumber

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor
local TEXT_ENTRY_FONT = SUI.CreateFont("TextEntry", "Roboto Regular", 16)

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_FontName", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_Editable", "Editable", FORCE_BOOL)
AccessorFunc(Panel, "m_Placeholder", "Placeholder", FORCE_STRING)
AccessorFunc(Panel, "m_MaxChars", "MaxChars", FORCE_NUMBER)
AccessorFunc(Panel, "m_Numeric", "Numeric", FORCE_BOOL)
AccessorFunc(Panel, "m_NoBar", "NoBar", FORCE_BOOL)
AccessorFunc(Panel, "m_BarColor", "BarColor")
AccessorFunc(Panel, "m_Background", "Background")
AccessorFunc(Panel, "m_Radius", "Radius")
AccessorFunc(Panel, "m_NoEnter", "NoEnter")

Panel:SetRadius(3)

function Panel:Init()
	self:ScaleInit()

	self:SetupTransition("TextEntryReady", 0.9, function()
		return self:IsEditing() or self:GetBarColor() ~= nil
	end)

	self:SetUpdateOnType(true)
	self:SetCursor("beam")
	self:SetFont(TEXT_ENTRY_FONT)
	self:SetPlaceholder("Placeholder text")

	self:SetSize(200, 22)

	self.allowed_numeric_characters = "1234567890.-"

	self.history = {}
	self.history_pos = 1
	self.can_use_history = true

	self:OnScaleChange()
end

function Panel:SetCaretPos(pos)
	DTextEntry.SetCaretPos(self, math.Clamp(pos, 0, utf8.len(self:GetText())))
end

function Panel:SetValue(value)
	self:SetText(value)
	self:OnValueChange(value)
end

function Panel:AllowInput(ch)
	if self:CheckNumeric(ch) then return true end

	if sui.wspace_chs[ch] or sui.cntrl_chs[ch] then
		return true
	end

	local max_chars = self:GetMaxChars()
	if max_chars and #self:GetText() >= max_chars then
		surface.PlaySound("resource/warning.wav")
		return true
	end
end

function Panel:AddValue(v, i, j)
	local original_text = self:GetText()

	local start
	if i then
		start = original_text:sub(1, i)
	else
		start = utf8.sub(original_text, 1, self:GetCaretPos())
	end

	local text = start .. v
	local caret_pos = utf8.len(text)

	local _end
	if j then
		_end = original_text:sub(j)
	else
		_end = utf8.sub(original_text, utf8.len(start) + 1)
	end
	text = text .. _end

	local max_chars = self:GetMaxChars()
	if max_chars then
		text = text:sub(1, max_chars)
	end

	self:SetValue(text)
	self:SetCaretPos(caret_pos)
end

function Panel:OnKeyCodeTyped(code)
	if self.no_down then
		self.no_down = nil
		return
	end

	if code == KEY_UP or code == KEY_DOWN then
		if not self:UpdateFromHistory(code) then
			return true
		end

		local lines, caret_line = self:GetNumLines()

		if lines == 1 then
			return true
		end

		--
		-- this fixes a weird issue
		-- make the text entry has at least 2 lines, go up then go down, you won't be able to go up again
		--
		if code == KEY_DOWN and lines == caret_line + 1 then
			self.no_down = true
			gui.InternalKeyCodeTyped(KEY_DOWN)
		end
	end

	self:OnKeyCode(code)

	if code == KEY_ENTER then
		if IsValid(self.Menu) then
			self.Menu:Remove()
		end

		if not self:GetNoEnter() then
			self:FocusNext()
			self:OnEnter()
		end
	end
end

function Panel:DisallowFloats(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%.", "", 1)
	elseif not self.allowed_numeric_characters:find(".", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "."
	end
end

function Panel:DisallowNegative(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%-", "", 1)
	elseif not self.allowed_numeric_characters:find("-", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "-"
	end
end

function Panel:CheckNumeric(value)
	if not self:GetNumeric() then return false end

	if not self.allowed_numeric_characters:find(value, 1, true) then
		return true
	end

	local new_value = ""
	local current_value = tostring(self:GetText())

	local caret_pos = self:GetCaretPos()
	for i = 0, #current_value do
		new_value = new_value .. current_value:sub(i, i)
		if i == caret_pos then
			new_value = new_value .. value
		end
	end

	if #current_value ~= 0 and not tonumber(new_value) then
		return true
	end

	return false
end

function Panel:AddHistory(txt)
	if not txt or txt == "" then return end
	local history = self.history
	if history[#history] ~= txt then
		table.insert(history, txt)
	end
end

function Panel:UpdateFromHistory(code)
	if not self.can_use_history then return end

	local lines, caret_line = self:GetNumLines()

	if code == KEY_UP then
		if caret_line > 1 then return true end -- enable the caret to move up and down

		if self.history_pos <= 1 then return end

		self.history_pos = self.history_pos - 1
	elseif code == KEY_DOWN then
		if caret_line ~= lines then return true end

		if self.history_pos >= #self.history then
			self:SetValue("")
			self:SetCaretPos(0)
			self.history_pos = #self.history + 1
			return
		end

		self.history_pos = self.history_pos + 1
	end

	local text = self.history[self.history_pos]
	if not text then return end

	self:SetValue(text)
	self:SetCaretPos(utf8.len(text))
end

function Panel:OnTextChanged()
	self.history_pos = #self.history + 1

	local text = self:GetText()

	self.can_use_history = text == "" and true or false

	if self:GetUpdateOnType() then
		self:UpdateConvarValue()
		self:OnValueChange(text)
	end

	self:OnChange()
end

function Panel:OnScaleChange()
	self:InvalidateLayout()
	self:InvalidateLayout(true)
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", self:GetRadius(), 0, 0, w, h, GetColor("text_entry_bg") or self:GetBackground())

	local text_entry_3 = GetColor("text_entry_3")

	if self:GetText() == "" then
		local old_text = self:GetText()
		self:SetText(self:GetPlaceholder())
		self:DrawTextEntryText(GetColor("text_entry_2"), text_entry_3, text_entry_3)
		self:SetText(old_text)
	else
		self:DrawTextEntryText(GetColor("text_entry"), text_entry_3, text_entry_3)
	end

	if not self:GetNoBar() then
		local bar_color = self:GetBarColor()

		self:RoundedBox("Bar1", 0, 0, h - 1, w, 1, GetColor("text_entry_bar_color"))

		local bar = math.Round(w * self.TextEntryReady)
		if bar > 0 then
			self:RoundedBox("Bar2", 0, (w / 2) - (bar / 2), h - 1, bar, 1, bar_color or text_entry_3)
		end
	end
end

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/vgui2/vgui_controls/TextEntry.cpp#L969
function Panel:GetNumLines(wide)
	local num_lines = 1

	wide = wide or self:GetWide() - 2

	local vbar = self:GetChildren()[1]
	if vbar then
		wide = wide - vbar:GetWide()
	end

	local char_width
	local x = 3

	local word_start_index = 1
	local word_start_len
	local word_length = 0
	local has_word = false
	local just_started_new_line = true
	local word_started_on_new_line = true

	local start_char = 1

	surface.SetFont(self:GetFont())

	local i = start_char
	local text, n = utf8.force(self:GetText())
	local caret_line = 0
	local caret_pos = self:GetCaretPos()
	local caret_i = 1
	while i <= n do
		local ch_len = utf8.char_bytes(text:byte(i))
		local ch = text:sub(i, i + ch_len - 1)

		if ch ~= " " then
			if not has_word then
				word_start_index = i
				word_start_len = ch_len
				has_word = true
				word_started_on_new_line = just_started_new_line
				word_length = 0
			end
		else
			has_word = false
		end

		char_width = surface.GetTextSize(ch)
		just_started_new_line = false

		if (x + char_width) >= wide then
			x = 3

			just_started_new_line = true
			has_word = false

			if word_started_on_new_line then
				num_lines = num_lines + 1
			else
				num_lines = num_lines + 1
				i = (word_start_index + word_start_len) - ch_len
			end

			word_length = 0
		end

		x = x + char_width
		word_length = word_length + char_width

		if caret_i == caret_pos then
			caret_line = num_lines
		end

		i = i + ch_len
		caret_i = caret_i + 1
	end

	return num_lines, caret_line
end

function Panel:SetCheck(func, col)
	function self:OnValueChange(text)
		if func(text) == false then
			self.valid = false
			self:SetBarColor(GetColor("close_hover"))
			self:SetNoEnter(true)
		else
			self.valid = true
			self:SetBarColor(col)
			self:SetNoEnter(false)
		end
	end
	self:SetValue(self:GetText())
end

sui.register("TextEntry", Panel, "DTextEntry")
--PATH addons/sui/lua/sui/vgui/sui_zbutton.lua:
local draw = draw
local render = render

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local BUTTON_FONT = SUI.CreateFont("Button", "Roboto Medium", 16)

local color_white = color_white
local color_transparent = Color(0, 0, 0, 0)

local PANEL = {}

AccessorFunc(PANEL, "m_Background", "Background")
AccessorFunc(PANEL, "m_bContained", "Contained", FORCE_BOOL)

sui.TDLib.Install(PANEL)
sui.scaling_functions(PANEL)

PANEL:ClearPaint()
PANEL:SetContained(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local IsMouseInputEnabled = Panel.IsMouseInputEnabled
local SetCursor = Panel.SetCursor
local SetContentAlignment = Panel.SetContentAlignment
function PANEL:Init()
	self:ScaleInit()

	self.vertices, self.vertices_2 = {}, {}

	SetMouseInputEnabled(self, true)
	SetCursor(self, "hand")
	SetContentAlignment(self, 5)

	self:SetSize(90, 30)
	self:SetFont(BUTTON_FONT)

	self:CircleClick(nil, 7)

	self.OldPaint, self.Paint = self.Paint, self.Paint2

	self.cur_col = Color(0, 0, 0, 0)
end

function PANEL:SetEnabled(b)
	SetMouseInputEnabled(self, b)
end

function PANEL:IsEnabled()
	return IsMouseInputEnabled(self)
end

function PANEL:ContainedPaint(w, h)
	local enabled = self:IsEnabled()
	local col
	if enabled then
		col = self:GetBackground() or SUI.GetColor("button")
		self:SetTextColor(SUI.GetColor("button_text"))
	else
		col = SUI.GetColor("button_disabled")
		self:SetTextColor(SUI.GetColor("button_disabled_text"))
	end
	self:RoundedBox("Background", 4, 0, 0, w, h, col)

	if not enabled then return end

	self.circle_click_color = SUI.GetColor("button_click")

	if self.Hovered or self.Selected then
		self:RoundedBox("Hover", 4, 0, 0, w, h, SUI.GetColor("button_hover"))
	end
end

function PANEL:SetColors(hover_color, text_color)
	self.hover = hover_color
	self.text_color = text_color
end

function PANEL:Paint2(w, h)
	if self:GetContained() then
		self:ContainedPaint(w, h)
		self:OldPaint(w, h)
		return
	end

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_ZERO)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(1)

	TDLib.RoundedBox(self.vertices, 4, 0, 0, w, h, color_white)

	render.SetStencilFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(1)

	local cur_col = self.cur_col
	if self.Selected then
		lerp_color(cur_col, SUI.GetColor("button2_selected"))
	elseif self.Hovered then
		lerp_color(cur_col, self.hover or SUI.GetColor("button2_hover"))
	else
		lerp_color(cur_col, color_transparent)
	end

	TDLib.RoundedBox(self.vertices_2, 4, 0, 0, w, h, cur_col)

	if self.text_color then
		self.circle_click_color = self.text_color
		self:SetTextColor(self.text_color)
	else
		local col = contrast_color(cur_col)
		self.circle_click_color = col
		self:SetTextColor(col)
	end

	self:OldPaint(w, h)

	render.SetStencilEnable(false)
	render.ClearStencil()
end

sui.register("Button", PANEL, NAME .. ".Label")
--PATH addons/sui/lua/sui/vgui/sui_image.lua:
local table = table
local file = file
local coroutine = coroutine
local surface = surface

local UnPredictedCurTime = UnPredictedCurTime
local pairs = pairs

local color_white = color_white

local sui = sui
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local read_gif = include("sui/libs/gif_loader.lua")
local generate_png = include("sui/libs/png_encoder.lua")

local images_path = (NAME .. "/images/"):lower()
file.CreateDir(images_path)

local get_image_path = function(url)
	return images_path .. (url:gsub("%W", "_") .. ".png")
end

local Write = file.Write
local gif_to_png; do
	local internal_gif_to_png = function(file_path, chunk)
		local gif = read_gif(chunk)
		local frames = gif:get_frames()
		local w, h = gif.width, gif.height

		local path = file_path .. "/"
		file.CreateDir(path)

		for frame_id = 1, #frames do
			local frame = frames[frame_id]
			local data = frame.data
			local png = generate_png(w, h, data)
			Write(("%s%d_%d.png"):format(path, frame_id, frame.delay), png)
			coroutine.yield()
		end
	end

	local delay = 0.01
	local next_run = 0

	local coroutines = {}
	local callbacks = {}
	gif_to_png = function(file_path, data, callback)
		local co = coroutine.create(internal_gif_to_png)
		local i = table.insert(coroutines, co)
		callbacks[i] = callback
		coroutine.resume(co, file_path, data)
		next_run = UnPredictedCurTime()
	end

	hook.Add("Think", NAME .. "ProcessGIFs", function()
		local co = coroutines[1]
		if not co then return end
		if UnPredictedCurTime() < next_run then return end

		if coroutine.status(co) == "suspended" then
			coroutine.resume(co)
		else
			callbacks[1]()
			table.remove(coroutines, 1)
			table.remove(callbacks, 1)
		end

		next_run = UnPredictedCurTime() + delay
	end)

	hook.Add(NAME .. "ImagesCleared", "ClearCoroutines", function()
		table.Empty(coroutines)
		table.Empty(callbacks)
	end)
end

local download_image, is_downloading_image; do
	-- https://stackoverflow.com/questions/25959386/how-to-check-if-a-file-is-a-valid-image
	local valid_images = {
		["\xff\xd8\xff"] = "jpeg",
		["\x89PNG\r\n\x1a\n"] = "png",
		["GIF87a"] = "gif",
		["GIF89a"] = "gif",
	}

	local get_image_type = function(data)
		for k, v in pairs(valid_images) do
			if data:StartWith(k) then
				return v
			end
		end
		return false
	end

	local downloading_images = {}

	local process_callbacks = function(url)
		local callbacks = downloading_images[url] or {}
		downloading_images[url] = nil

		for _, func in ipairs(callbacks) do
			func()
		end
	end

	download_image = function(url, callback)
		if downloading_images[url] then
			table.insert(downloading_images[url], callback)
			return
		end

		downloading_images[url] = {callback}

		http.Fetch(url, function(data)
			local image_type = get_image_type(data)
			if not image_type then
				downloading_images[url] = nil
				return
			end

			local image_path = get_image_path(url)

			if image_type == "gif" then
				gif_to_png(image_path, data, function()
					process_callbacks(url)
				end)
			else
				file.Write(image_path, data)
				process_callbacks(url)
			end
		end, function(err)
			print("(SUI) Failed to download an image, error: " .. err)
			downloading_images[url] = nil
		end)
	end

	is_downloading_image = function(url)
		return downloading_images[url] ~= nil
	end

	hook.Add(NAME .. "ImagesCleared", "ClearDownloadingImages", function()
		table.Empty(downloading_images)
	end)
end

local images_panels = {}

local PANEL = {}

local err_mat = SUI.Material("error")

function PANEL:Init()
	self:SetMouseInputEnabled(false)

	self.minus = 0
	self.rotation = 0
	self.image = err_mat
	self.image_col = color_white

	table.insert(images_panels, self)
end

function PANEL:OnRemove()
	for k, v in ipairs(images_panels) do
		if v == self then
			table.remove(images_panels, k)
			return
		end
	end
end

function PANEL:SetMinus(minus)
	self.minus = minus
end

function PANEL:SetRotation(rotation)
	self.rotation = rotation
end

function PANEL:SetImageColor(col)
	self.image_col = col
end

local cached_files = {}
local get_files = function(image_path)
	local f = cached_files[image_path]
	if f then return f end

	cached_files[image_path] = file.Find(image_path .. "/*", "DATA")

	return cached_files[image_path]
end

function PANEL:SetImage(url)
	self.image = err_mat

	self.pos = nil
	self.delay = nil

	self.images = nil
	self.delays = nil
	self.url = url

	if url:sub(1, 4) ~= "http" then
		self.image = SUI.Material(url)
		return
	end

	local image_path = get_image_path(url)
	if not file.Exists(image_path, "DATA") or is_downloading_image(url) then
		download_image(url, function()
			if self:IsValid() then
				self:SetImage(url)
			end
		end)
		return
	end

	local is_gif = file.IsDir(image_path, "DATA")
	if is_gif then
		local images = {}
		local delays = {}

		local files = get_files(image_path)
		for i = 1, #files do
			local v = files[i]
			local id, delay = v:match("(.*)_(.*)%.png")
			id = tonumber(id)
			local img_path = "../data/" .. image_path .. "/" .. v
			images[id] = img_path
			delays[id] = delay
		end

		self.frame = 1
		self.delay = (UnPredictedCurTime() * 100) + delays[1]

		self.images = images
		self.delays = delays

		self.max_images = #files
	else
		self.image = SUI.Material("../data/" .. image_path)
	end
end

local SetMaterial = surface.SetMaterial
function PANEL:PaintGIF(w, h, images)
	local frame = self.frame

	-- SUI.Material() caches materials by default
	local mat = SUI.Material(images[frame], true)
	if not mat then
		if frame > 1 then
			mat = SUI.Material(images[frame - 1])
		else
			mat = err_mat
		end

		SetMaterial(mat)

		return
	end

	SetMaterial(mat)

	local curtime = UnPredictedCurTime() * 100
	if curtime < self.delay then return end
	frame = frame + 1
	if frame > self.max_images then
		frame = 1
	end

	self.frame = frame
	self.delay = curtime + self.delays[frame]
end

local PaintGIF = PANEL.PaintGIF
local SetDrawColor = surface.SetDrawColor
local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
function PANEL:Paint(w, h)
	SetDrawColor(self.image_col)

	local images = self.images
	if images then
		PaintGIF(self, w, h, images)
	else
		SetMaterial(self.image)
	end

	if self.Draw then
		self:Draw(w, h, true)
	else
		local minus = self.minus
		DrawTexturedRectRotated(w * 0.5, h * 0.5, w - minus, h - minus, self.rotation)
	end
end

sui.register("Image", PANEL, "PANEL")

function SUI.ClearImages()
	local files, dirs = file.Find(images_path .. "/*", "DATA")
	for _, f in ipairs(files) do
		file.Delete(images_path .. f)
	end

	for _, d in ipairs(dirs) do
		for _, f in ipairs(file.Find(images_path .. d .. "/*", "DATA")) do
			file.Delete(images_path .. (d .. "/" .. f))
		end
		file.Delete(images_path .. d)
	end

	table.Empty(SUI.materials)
	table.Empty(cached_files)

	hook.Call(NAME .. "ImagesCleared")

	for k, v in ipairs(images_panels) do
		if v.url then
			v:SetImage(v.url)
		end
	end
end
--PATH addons/sui/lua/sui/vgui/sui_property_sheet.lua:
local draw = draw
local surface = surface
local vgui = vgui

local TYPE_MATERIAL = TYPE_MATERIAL

local RealFrameTime = RealFrameTime
local IsValid = IsValid
local Lerp = Lerp
local pairs = pairs
local TypeID = TypeID

local TDLib_Classes = sui.TDLib.LibClasses
local TextColor = TDLib_Classes.TextColor
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local PROPERTY_SHEET_FONT = SUI.CreateFont("PropertySheet", "Roboto Regular", 18)

local PANEL = {}

AccessorFunc(PANEL, "m_FontName", "Font", FORCE_STRING)

function PANEL:Init()
	self.tabs = {}

	self:SetFont(PROPERTY_SHEET_FONT)

	local tab_scroller = self:Add("DHorizontalScroller")
	tab_scroller:Dock(TOP)

	self.tabs_tall = 26
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self.tab_scroller:SetTall(SUI.Scale(self.tabs_tall))

	for k, v in pairs(self.tab_scroller.Panels) do
		if v:IsValid() then
			if v.Material then
				v:SetWide(self.tab_scroller:GetTall())
			else
				v:SizeToContentsX()
			end
		end
	end

	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, self.tab_scroller:GetTall(), SUI.GetColor("property_sheet_bg"))
end

function PANEL:PaintOver(w, h)
	local active_tab = self:GetActiveTab()
	if not IsValid(active_tab) then return end

	local tab_scroller = self.tab_scroller
	local offset = tab_scroller:GetTall() - SUI.Scale(1)

	local x = active_tab:LocalToScreen(0) - self:LocalToScreen(0)

	if not self.activeTabX then
		self.activeTabX = x
		self.activeTabW = active_tab:GetWide()
	end

	local delta = RealFrameTime() * 6
	if delta then
		self.activeTabX = Lerp(delta, self.activeTabX, x)
		self.activeTabW = Lerp(delta, self.activeTabW, active_tab:GetWide())
	end

	self:RoundedBox("Background2", 1, self.activeTabX, tab_scroller.y + offset, self.activeTabW, SUI.Scale(1), SUI.GetColor("property_sheet_tab_active"))
end

local tab_Paint = function(s, w, h)
	s.circle_click_color = SUI.GetColor("property_sheet_tab_click")
	if s.property_sheet:GetActiveTab() == s then
		TextColor(s, SUI.GetColor("property_sheet_tab_active"))
	else
		TextColor(s, SUI.GetColor("property_sheet_tab"))
	end
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local image_paint = function(s, w, h)
	surface.SetDrawColor(color_white)
	surface.SetMaterial(s.Material)
	surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, w - 10, h - 10, 0)
end

function PANEL:AddSheet(name, load_func)
	local tab = vgui.Create("DButton")
	if TypeID(name) == TYPE_MATERIAL then
		tab:SetText("")
		tab.Material = name
		tab.Paint = image_paint
		tab:SetWide(self.tab_scroller:GetTall())
	else
		tab:SetFont(self:GetFont())
		tab:SetText(name)
		tab:SetTextInset(10, 0)
		tab:SizeToContentsX()

		tab.Paint = tab_Paint
	end

	tab.parent = self
	tab.DoClick = tab_DoClick

	tab.load_func = load_func
	tab.property_sheet = self

	tab.On = TDLib_Classes.On
	TDLib_Classes.CircleClick(tab)

	self.tab_scroller:AddPanel(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function PANEL:GetActiveTab()
	return self.active_tab
end

function PANEL:SetActiveTab(new_tab)
	if IsValid(new_tab) and not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	if self.active_tab and IsValid(self.active_tab.panel) then
		self.active_tab.panel:SetVisible(false)
	end

	if IsValid(new_tab) then
		new_tab.panel:SetVisible(true)
	end

	self.active_tab = new_tab
end

sui.register("PropertySheet", PANEL, "EditablePanel")
--PATH addons/sui/lua/sui/vgui/sui_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_bValue", "Value", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMin", "Min", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMax", "Max", FORCE_NUMBER)
AccessorFunc(Panel, "m_bDecimals", "Decimals", FORCE_NUMBER)


AccessorFunc(Panel, "m_fSlideX", "SlideX")
AccessorFunc(Panel, "m_fSlideY", "SlideY")

AccessorFunc(Panel, "m_iLockX", "LockX")
AccessorFunc(Panel, "m_iLockY", "LockY")

AccessorFunc(Panel, "Dragging", "Dragging")

function Panel:Init()
	self:ScaleInit()

	self:SetSlideX(0.5)
	self:SetSlideY(0.5)

	self:SetMouseInputEnabled(true)
	self:SetMin(0)
	self:SetMax(10)
	self:SetValue(1)
	self:SetDecimals(1)

	self:SetSize(100, 12)

	self.rounded_box = {}

	self.Knob = vgui.Create("DButton", self)
	self.Knob:SetText("")
	self.Knob:SetSize(15, 15)
	self.Knob:NoClipping(true)
	self.Knob.Paint = self.KnobPaint
	self.Knob.OnCursorMoved = function(panel, x, y)
		x, y = panel:LocalToScreen(x, y)
		x, y = self:ScreenToLocal(x, y)
		self:OnCursorMoved(x, y)
	end
	self.Knob.circle = {}

	self:SetLockY(0.5)
end

function Panel:IsEditing()
	return self.Dragging or self.Knob.Depressed
end

function Panel:SetEnabled(b)
	self.Knob:SetEnabled(b)
	FindMetaTable("Panel").SetEnabled(self, b) -- There has to be a better way!
end

function Panel:OnCursorMoved(x, y)
	if (not self.Dragging and not self.Knob.Depressed) then return end

	local w, h = self:GetSize()
	local iw, ih = self.Knob:GetSize()

	w = w - iw
	h = h - ih

	x = x - iw * 0.5
	y = y - ih * 0.5

	x = math.Clamp(x, 0, w) / w
	y = math.Clamp(y, 0, h) / h

	if self.m_iLockX then x = self.m_iLockX end
	if self.m_iLockY then y = self.m_iLockY end

	x, y = self:TranslateValues(x, y)

	self:SetSlideX(x)
	self:SetSlideY(y)

	self:InvalidateLayout()
end

function Panel:OnMousePressed(mcode)
	if not self:IsEnabled() then return true end

	-- When starting dragging with not pressing on the knob.
	self.Knob.Hovered = true

	self:SetDragging(true)
	self:MouseCapture(true)

	local x, y = self:CursorPos()
	self:OnCursorMoved(x, y)
end

function Panel:OnMouseReleased(mcode)
	-- This is a hack. Panel.Hovered is not updated when dragging a panel (Source's dragging, not Lua Drag'n'drop)
	self.Knob.Hovered = vgui.GetHoveredPanel() == self.Knob

	self:SetDragging(false)
	self:MouseCapture(false)
end

function Panel:SetMinMax(min, max)
	self:SetMin(min)
	self:SetMax(max)
end

function Panel:TranslateValues(x, y)
	self:SetValue(self:GetMin() + (x * self:GetRange()))
	return self:GetFraction(), y
end

function Panel:GetFraction()
	return (self:GetValue() - self:GetMin()) / self:GetRange()
end

function Panel:SetValue(val)
	val = math.Clamp(val, self:GetMin(), self:GetMax())
	val = math.Round(val, self:GetDecimals())

	self.m_bValue = val
	self:SetSlideX((val - self:GetMin()) / self:GetRange())

	self:OnValueChanged(val)
end

function Panel:OnValueChanged(val)
end

function Panel:GetRange()
	return self:GetMax() - self:GetMin()
end

function Panel:Paint(w, h)
	local _h = SUI.Scale(2)
	TDLib.RoundedBox(self.rounded_box, 3, 0, h / 2 - _h / 2, w, _h, SUI.GetColor("slider_track"))
end

function Panel:KnobPaint(w, h)
	if self.Depressed then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_pressed"))
	elseif self.Hovered then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_hover"))
	end

	TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 2, SUI.GetColor("slider_knob"))
end

function Panel:PerformLayout(w, h)
	local knob_size = SUI.Scale(12)
	self.Knob:SetSize(knob_size, knob_size)

	w = w - knob_size
	h = h - knob_size
	self.Knob:SetPos((self.m_fSlideX or 0) * w, (self.m_fSlideY or 0) * h)
end

function Panel:SetSlideX(i)
	self.m_fSlideX = i
	self:InvalidateLayout()
end

function Panel:SetSlideY(i)
	self.m_fSlideY = i
	self:InvalidateLayout()
end

function Panel:GetDragging()
	return self.Dragging or self.Knob.Depressed
end

sui.register("Slider", Panel, "Panel")

--PATH addons/sui/lua/sui/vgui/sui_toggle_button.lua:
local Lerp = Lerp
local FrameTime = FrameTime

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

function Panel:Init()
	self:ScaleInit()

	local rounded_box = {}
	local switch_circle = {}
	function self:Paint(w, h)
		local is_checked = self:GetChecked()

		local _h = SUI.Scale(14)
		TDLib.RoundedBox(rounded_box, _h, 0, h / 2 - _h / 2, w, _h, is_checked and SUI.GetColor("toggle_button_active") or SUI.GetColor("toggle_button"))

		local size = h - 2
		do
			local pos = is_checked and (w - (size / 2)) or (h / 2 - 1)
			if self.pos then
				self.pos = Lerp(FrameTime() * 12, self.pos, pos)
			else
				self.pos = pos
			end
		end

		TDLib.DrawCircle(switch_circle, self.pos, h / 2, size / 2, is_checked and SUI.GetColor("toggle_button_switch_active") or SUI.GetColor("toggle_button_switch"))
	end

	self:SetSize(34, 20)
end

sui.register("ToggleButton", Panel, "DCheckBox")
--PATH addons/sl_util_atm/lua/batm_scenes/cursor.lua:
--[[-------------------------------------------------------------------------
Draws the cursor
---------------------------------------------------------------------------]]

local scene = {}
local cursor = Material("bluesatm/cursor.png","noclamp smooth")

--Called when the scene is loaded
function scene.Load(ent)
 
end
  
--Draw code
function scene.Draw(ent, ScrW, ScrH) 
	surface.SetMaterial(cursor)
	surface.SetDrawColor(Color(40, 40, 40, 150))
	surface.DrawTexturedRect(ent.cursor.x + 8, ent.cursor.y + 8, 64, 64)
	surface.SetDrawColor(Color(200, 200, 200))
	surface.DrawTexturedRect(ent.cursor.x, ent.cursor.y, 64, 64)
end

--Think code (dt = FrameTime())
function scene.Think(ent, dt)

end

--Called when a the scene is unloaded
function scene.Unload(ent, newSceneName)

end

--Register the scene
BATM.RegisterScene(scene, "cursor")


--PATH addons/sl_util_atm/lua/batm_scenes/loading.lua:
--[[-------------------------------------------------------------------------
This scene should be set before anything that requires waiting on networking
---------------------------------------------------------------------------]]


surface.CreateFont( "batm_loading_text", {
	font = "Coolvetica",
	extended = false,
	size = 75,
	weight = 300,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

local scene = {}

local loading = Material("bluesatm/loading.png", "noclamp smooth")

--Called when the scene is loaded
function scene.Load(ent)

end 

--Draw code
function scene.Draw(ent, ScrW, ScrH)
 
	--Draw the background
	BATM.Scenes["background"].Draw(ent, ScrW, ScrH) 

	--Draw background
	--draw.RoundedBox(0, 0, 100, ScrW, ScrH - 100, Color(231, 126, 34,255))

	--Draw logo
	surface.SetDrawColor(Color(255,255,255,50))
	surface.SetMaterial(loading)
	surface.DrawTexturedRectRotated(ScrW/2, ScrH/2, 256, 256, CurTime() * -100)

	--Draw text
	draw.SimpleText(BATM.Lang["Loading..."], "batm_done_text", ScrW/2, ScrH - 150, Color(255,255,255,100), 1)

	--Draw the cursor
	BATM.Scenes["cursor"].Draw(ent, ScrW, ScrH)

end 

--Think code (dt = FrameTime())
function scene.Think(ent, dt)

end

--Called when the scene is unloaded
function scene.Unload(ent, newSceneName)

end

--Register the scene
BATM.RegisterScene(scene, "loading")
--PATH addons/sl_util_atm/lua/batm_scenes/withdraw.lua:
--[[-------------------------------------------------------------------------
Draws the withdraw screen
---------------------------------------------------------------------------]]

surface.CreateFont( "batm_withdraw_title", {
	font = "Coolvetica",
	extended = false,
	size = 100,
	weight = 300,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "batm_withdraw_text", {
	font = "Coolvetica",
	extended = false,
	size = 65,
	weight = 300,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

local scene = {}
scene.enteredAmount = 0
local ScrW = 1024
local ScrH = 676
--Called when the scene is loaded
function scene.Load(ent)
	scene.enteredAmount = 0 --Reset it

	--done button
	ent:AddButton(ScrW/2 - 300, ScrH / 2 + 110, 600, 90, 
		function() --On pressed
			if BATM.VerifyNumber(scene.enteredAmount) then
				ent:SetScene("loading")
				BATM.Withdraw(ent, scene.enteredAmount or 0)
			end
		end
	)

	--back button
	ent:AddButton(35, 135, 64, 64, 
		function() --On pressed
			if BATM.SelectedAccount == "personal" then
				ent:SetScene("personalaccount")
			else
				ent:SetScene("groupaccount")
			end
		end
	)


end

--Called when a user presses a button on the
function scene.OnKeypadPressed(ent, button)
	--Now lets make sure its not zero
	if isnumber(button) then
		--Append it
		local stringAmount = tostring(scene.enteredAmount)
		if string.len(stringAmount) > 13 then return end --Prevent overflow
		stringAmount = stringAmount..button

		if tonumber(stringAmount) == 0 then return end

		scene.enteredAmount = tonumber(stringAmount)

		return
	end

	if button == "clear" then
		if scene.enteredAmount ~= 0 then
			local stringAmount = tostring(scene.enteredAmount)
			stringAmount = string.sub(stringAmount, 1, string.len(stringAmount) - 1)
			if tonumber(stringAmount) == nil or tonumber(stringAmount) < 0 then
				stringAmount = "0"
			end
			scene.enteredAmount = tonumber(stringAmount)
			return
		end
	end
		
	if button == "enter" then
		if BATM.VerifyNumber(scene.enteredAmount) then
			ent:SetScene("loading")
			BATM.Withdraw(ent, scene.enteredAmount or 0)
		end
	end
end

local back = Material("bluesatm/back.png", "noclamp smooth")

--Draw code
function scene.Draw(ent, ScrW, ScrH)

	--Draw the background
	BATM.Scenes["background"].Draw(ent, ScrW, ScrH)

	--Draw back button
	surface.SetDrawColor(Color(255,255,255,100))
	surface.SetMaterial(back)
	surface.DrawTexturedRect(35, 135, 64, 64)

	--Draw title
	draw.SimpleText(BATM.Lang["Withdraw"], "batm_withdraw_title", ScrW/2, 155, Color(233,233,233,255), 1)

	--Deposite box
	draw.RoundedBox(0, ScrW/2 - 300, ScrH / 2, 600, 90, Color(255,255,255,255))
	if scene.enteredAmount == 0 then
		draw.SimpleText(BATM.Lang["Enter Amount"], "batm_withdraw_text", ScrW/2, (ScrH/2) + 45, Color(194,194,194,255), 1, 1)
	else
		draw.SimpleText(BATM.Lang["$"]..CBLib.Helper.CommaFormatNumber(scene.enteredAmount), "batm_withdraw_text", ScrW/2, (ScrH/2) + 45, Color(194,194,194,255), 1, 1)
	end

	--Draw done button
	draw.RoundedBox(0, ScrW/2 - 300, ScrH / 2 + 110, 600, 90, Color(231, 126, 34,255))
	draw.SimpleText(BATM.Lang["Done"], "batm_withdraw_text", ScrW/2, (ScrH/2) + 110 + 45, Color(255,255,255,255), 1, 1)

	--Draw the cursor
	BATM.Scenes["cursor"].Draw(ent, ScrW, ScrH)

end

--Think code (dt = FrameTime())
function scene.Think(ent, dt)

end

--Called when the scene is unloaded
function scene.Unload(ent, newSceneName)

end

--Register the scene
BATM.RegisterScene(scene, "withdraw")

--PATH lua/autorun/sh_catmullromcams.lua:
--[[
	Planetfall: Catmull-Rom Cutscene Camera Track System
	by Olivier 'LuaPineapple' Hamel
	
	I'll be nice and release a stand alone version for you guys.
	BUT I EXECPT A GODS AWFUL AMOUNT OF COOKIES!
	
	If I don't I'll get annoyed and when I get annoyed I become irritable and when I become irritable people DIE! [/quote_dr_evil]
--]]

--[[
	5:52 PM - Firgof Umbra: I worry about your sense of perception sometimes.
	5:52 PM - LuaPineapple: I AM GOD!
	5:52 PM - LuaPineapple: WORSHIP ME!
	5:52 PM - Firgof Umbra: ...
	5:53 PM - LuaPineapple: INSECT!
--]]



local function AddLua(filename)
	local tmp = string.Explode("/", string.lower(filename))
	local parts = string.Explode("_", tmp[#tmp])
	
	if SERVER then
		if (parts[1] == "sh") or (parts[1] == "shared.lua") then
			include(filename)
			return AddCSLuaFile(filename)
		elseif parts[1] == "cl" then
			return AddCSLuaFile(filename)
		elseif (parts[1] == "sv") or (parts[1] == "init.lua") then
			return include(filename)
		end
		
		ErrorNoHalt("Unknown file: ",filename,"\n")
		PrintTable(tmp)
		PrintTable(parts)
		Error("Unable to determine if shared, serverside, or clientside.\n")
	elseif CLIENT then
		if (parts[1] == "sh") or (parts[1] == "cl") or (parts[1] == "shared.lua") then
			return include(filename)
		elseif (parts[1] == "sv") or (parts[1] == "init.lua") then //others, just to keep the system happy
			return
		end
		
		ErrorNoHalt("Unknown file: ",filename,"\n")
		PrintTable(tmp)
		PrintTable(parts)
		Error("Unable to determine if shared, serverside, or clientside.\n")
	else
		return Error("Apparently we're God as we're not the client or the server.\n")
	end
end

if SERVER then AddCSLuaFile("sh_CatmullRomCams.lua") end

CatmullRomCams = CatmullRomCams or {}

CatmullRomCams.AddLua   = AddLua
CatmullRomCams.FilePath = "CatmullRomCameraTracks/"

CatmullRomCams.SV = CatmullRomCams.SV or {}
CatmullRomCams.SH = CatmullRomCams.SH or {}
CatmullRomCams.CL = CatmullRomCams.CL or {}

CatmullRomCams.SToolMethods = {}

function CatmullRomCams.SH.UnitsToMeters(dist)
	return (dist * 0.0254)
end

function CatmullRomCams.SH.MetersToUnits(dist)
	return (dist * 39.3700787)
end

function CatmullRomCams.SToolMethods.ValidTrace(trace)
	return (trace and trace.Entity and trace.Entity.GetClass and trace.Entity.IsValid and trace.Entity:IsValid() and (trace.Entity:GetClass() == "sent_catmullrom_camera"))
end

CatmullRomCams.Tracks = CatmullRomCams.Tracks or {}

local files = file.Find("CatmullRomCams/*.lua", "LUA")

for _, v in pairs(files) do
	AddLua("CatmullRomCams/" .. v)
end

local files_stools = file.Find("CatmullRomCams/STools/*.lua", "LUA")

for _, v in pairs(files_stools) do
	AddLua("CatmullRomCams/STools/" .. v)
end
---FREEZEBUG: You forgot client tool data.
local files_stools_client = file.Find("weapons/gmod_tool/stools/*.lua", "LUA")
for _, v in pairs(files_stools_client) do
	AddCSLuaFile("weapons/gmod_tool/stools/" .. v)
end
--[[

CatmullRomCams = CatmullRomCams or {}
CatmullRomCams.AddLua   = AddLua
CatmullRomCams.FilePath = "CatmullRomCameraTracks/"
local function AddLua(filename)
	local tmp = string.Explode("/", string.lower(filename))
	local parts = string.Explode("_", tmp[#tmp])
	
	if SERVER then
		if (parts[1] == "sh") or (parts[1] == "shared.lua") then
			include(filename)
			return AddCSLuaFile(filename)
		elseif parts[1] == "cl" then
			return AddCSLuaFile(filename)
		elseif (parts[1] == "sv") or (parts[1] == "init.lua") then
			return include(filename)
		end
		
		ErrorNoHalt("Unknown file: ",filename,"\n")
		PrintTable(tmp)
		PrintTable(parts)
		Error("Unable to determine if shared, serverside, or clientside.\n")
	elseif CLIENT then
		if (parts[1] == "sh") or (parts[1] == "cl") or (parts[1] == "shared.lua") then
			return include(filename)
		elseif (parts[1] == "sv") or (parts[1] == "init.lua") then //others, just to keep the system happy
			return
		end
		
		ErrorNoHalt("Unknown file: ",filename,"\n")
		PrintTable(tmp)
		PrintTable(parts)
		Error("Unable to determine if shared, serverside, or clientside.\n")
	else
		return Error("Apparently we're God as we're not the client or the server.\n")
	end
end
--[[
if SERVER then AddCSLuaFile("sh_CatmullRomCams.lua") end

CatmullRomCams = CatmullRomCams or {}

CatmullRomCams.AddLua   = AddLua
CatmullRomCams.FilePath = "CatmullRomCameraTracks/"

CatmullRomCams.SV = CatmullRomCams.SV or {}
CatmullRomCams.SH = CatmullRomCams.SH or {}
CatmullRomCams.CL = CatmullRomCams.CL or {}

CatmullRomCams.SToolMethods = {}

function CatmullRomCams.SH.UnitsToMeters(dist)
	return (dist * 0.0254)
end

function CatmullRomCams.SH.MetersToUnits(dist)
	return (dist * 39.3700787)
end

function CatmullRomCams.SToolMethods.ValidTrace(trace)
	return (trace and trace.Entity and trace.Entity.GetClass and trace.Entity.IsValid and trace.Entity:IsValid() and (trace.Entity:GetClass() == "sent_catmullrom_camera"))
end

CatmullRomCams.Tracks = CatmullRomCams.Tracks or {}

if SERVER then
AddCSLuaFile("CatmullRomCams/Stools/sh_duration_editor.lua")
AddCSLuaFile("CatmullRomCams/Stools/sh_hitchcock_effect.lua")
AddCSLuaFile("CatmullRomCams/Stools/sh_layout.lua")
AddCSLuaFile("CatmullRomCams/Stools/sh_linker.lua")
AddCSLuaFile("CatmullRomCams/Stools/sh_map_io_editor.lua")
AddCSLuaFile("CatmullRomCams/Stools/sh_numpad_trigger.lua")
AddCSLuaFile("CatmullRomCams/Stools/sh_smart_look.lua")
AddCSLuaFile("CatmullRomCams/cl_calcview_hook.lua")
AddCSLuaFile("CatmullRomCams/cl_edit_lock_display.lua")
AddCSLuaFile("CatmullRomCams/cl_tab.lua")
AddCSLuaFile("CatmullRomCams/cl_language_defs.lua")
AddCSLuaFile("CatmullRomCams/sh_catmullrom_spline_controller.lua")
AddCSLuaFile("CatmullRomCams/sh_cleanup.lua")
AddCSLuaFile("CatmullRomCams/sh_gc_booster.lua")
AddCSLuaFile("CatmullRomCams/sh_general_hooks.lua")
AddCSLuaFile("CatmullRomCams/sh_Quaternions.lua")
AddCSLuaFile("CatmullRomCams/sh_save_load.lua")
include("CatmullRomCams/sv_icon_resource.lua")
include("CatmullRomCams/sv_adv_dup_paste.lua")
include("CatmullRomCams/sv_saverestore.lua")
end
include("CatmullRomCams/sh_catmullrom_spline_controller.lua")
include("CatmullRomCams/sh_cleanup.lua")
include("CatmullRomCams/sh_gc_booster.lua")
include("CatmullRomCams/sh_general_hooks.lua")
include("CatmullRomCams/sh_Quaternions.lua")
include("CatmullRomCams/sh_save_load.lua")
include("CatmullRomCams/Stools/sh_duration_editor.lua") --
include("CatmullRomCams/Stools/sh_hitchcock_effect.lua") --
include("CatmullRomCams/Stools/sh_layout.lua") --
include("CatmullRomCams/Stools/sh_linker.lua") --
include("CatmullRomCams/Stools/sh_map_io_editor.lua") --
include("CatmullRomCams/Stools/sh_numpad_trigger.lua") --
include("CatmullRomCams/Stools/sh_smart_look.lua") --

if CLIENT then
include("CatmullRomCams/cl_language_defs.lua")
include("CatmullRomCams/cl_calcview_hook.lua")
include("CatmullRomCams/cl_edit_lock_display.lua")
include("CatmullRomCams/cl_tab.lua")

end
]]--

--PATH lua/catmullromcams/sh_save_load.lua:
-- I REALLLY don't feel like working through this mess of networking
-- so saving/loading in multiplayer is only possible if you're the listen host.

CatmullRomCams.SH.SaveLoad = {}

function CatmullRomCams.SH.SaveLoad.RequestSpawn(filename)
	if (not filename) or SERVER or (LocalPlayer() ~= player.GetByID(1)) then return end
	
	return RunConsoleCommand("~CatmullRomCams_RequestSpawn", filename)
end

function CatmullRomCams.SH.SaveLoad.Spawn_CCmd(ply, cmd, args)
	local filename = args[1] or ""
	
	if not file.Exists(CatmullRomCams.FilePath .. filename) then return ErrorNoHalt("Attempted to load non-existant track named '", filename, "'\n") end
	
	local data = util.KeyValuesToTable(file.Read(CatmullRomCams.FilePath .. filename) or "") or {}
	
	if not data[1] then return ErrorNoHalt("Invalid load track table given.\n") end
	
	for k, v in ipairs(data[1]) do
		
	end
end
concommand.Add("~CatmullRomCams_RequestSpawn", CatmullRomCams.SH.SaveLoad.Spawn_CCmd)


--PATH addons/sl_utils/lua/autorun/sh_newera.lua:
local PLAYER = FindMetaTable("Player")

function PLAYER:IsSeefox()
    return self:SteamID64() == "76561198306115597"
end

if CLIENT then
    surface.CreateFont("Seefox:CrashScreen", {
        font = "Montserrat Bold",
        size = 22,
        weight = 700,
        extended = true
    })

    local materials = {
        ["bg"] = Material("seefox/newera/crashscreen/background.png"),
        ["loading"] = Material("seefox/newera/crashscreen/loading.png"),
    }

    local colWhite = Color(255, 255, 255)
    local colOutline = Color(13, 17, 60)
    
    local timeoutMin = 8 -- timeout seconds before the menu is displayed
    local reconnectMax = 100
    local lerpLoading = 0
    local loadingBgW = 800
    local loadingBgH = 38
    local loadingFillW = 784
    local loadingFillH = 22

    hook.Add("HUDShouldDraw", "Seefox:CrashScreen", function()
        local timeout = select(2, GetTimeoutInfo())
    
        if timeout < timeoutMin then return end
    
        timeout = timeout - timeoutMin -- to not display the menu with already x seconds elapsed
        local reconnect = reconnectMax-timeout
    
        if reconnect < 0 then RunConsoleCommand("retry") return end

        local w, h = ScrW(), ScrH()
        local midW = w/2

        surface.SetDrawColor(colWhite)

        surface.SetMaterial(materials.bg)
        surface.DrawTexturedRect(0, 0, w, h)

        lerpLoading = Lerp(FrameTime() * 10, lerpLoading, math.Clamp(reconnect/reconnectMax, 0, 1))
        surface.SetMaterial(materials.loading)
        surface.DrawTexturedRect(midW-loadingBgW/2+loadingBgW/2-loadingFillW/2, h*0.7375+loadingBgH/2-loadingFillH/2, loadingFillW*lerpLoading, loadingFillH)
        
        draw.SimpleTextOutlined("Reconnexion dans: "..math.Round(reconnect).." secondes", "Seefox:CrashScreen", midW, h*0.79, colWhite, 1, 1, 2, colOutline)
    end)
    
    local oldTimeout = GetConVarNumber("cl_timeout")
    
    RunConsoleCommand("cl_timeout", 900)
    
    hook.Add("Shutdown", "Seefox:CrashScreen", function()
        RunConsoleCommand("cl_timeout", oldTimeout)
    end)
end
--PATH addons/squad_reborn/lua/autorun/sh_squad_loader.lua:

//Utils
AddCSLuaFile("squads/sh_squad_utils.lua")
include("squads/sh_squad_utils.lua")
//Config with g table
AddCSLuaFile("squads/sh_squad_config.lua")
include("squads/sh_squad_config.lua")
//System as it
AddCSLuaFile("squads/sh_squad_system.lua")
include("squads/sh_squad_system.lua")

//CS Files
AddCSLuaFile("squads/client/cl_squad_gfx.lua")
AddCSLuaFile("squads/client/cl_squad.lua")

if CLIENT then
    include("squads/client/cl_squad_gfx.lua")
    include("squads/client/cl_squad.lua")
else
    include("squads/server/sv_squad.lua")
    include("squads/server/sv_squad_db.lua")
end

--PATH addons/tlib/lua/tlib/client/derma/frame.lua:
local draw = draw
local surface = surface

local PANEL = {}

--[[

    PANEL:Init

]]--

function PANEL:Init()
    self.iMargin, self.iRoundness = TLib:ScaleVGUI()

    self.tBgColor = TLib:C( 0 )
    self.tHeaderColor = TLib:C( 1 )
    self.tTextColor = TLib:C( 5 )
    self.tShadowColor = TLib:C( 7 )

    self.bBgBlur = true
    self.bBgShadow = true
    self.iHeaderH = math.ceil( ScrH() * .04 )
    self.fSysTime = SysTime()

    self.bInitialized = true

    self:ShowCloseButton( true )
end

--[[

    PANEL:GetHeaderHeight
        Return: Panel's header height

]]--

function PANEL:GetHeaderHeight()
    return ( self.iHeaderH or 0 )
end

--[[

    PANEL:SetBgBlur
        Params: Enable background blur (boolean) {default: true} 

]]--

function PANEL:SetBgBlur( bBgBlur )
    self.bBgBlur = tobool( bBgBlur )
end

--[[

    PANEL:SetDrawShadow
        Params: Enable background shadow (boolean) {default: true} 

]]--

function PANEL:SetBgShadow( bShadow )
    self.bBgShadow = tobool( bShadow )
end

--[[

    PANEL:SetHeader
        Params: Header title (string) {nil to disable header} [, Header height (number) {default: Auto}, Title font (string) {default: "TLib.Subtitle"}]

]]--

function PANEL:SetHeader( sTitle, sSubtitle, sTitleFont, sSubtitleFont )
    if not sTitle then
        self.sTitle = nil

        if IsValid( self.dHeader ) then
            self.dHeader:Remove()
            self.dHeader = nil
        end

        if IsValid( self.dClose ) then
            self:ShowCloseButton( true )
        end

        return
    end

    self.sTitle = sTitle
    self.sSubtitle = ( sSubtitle and sSubtitle or nil )

    local dPanel = self
    local sTitleFont = ( sTitleFont or "TLib.Title" )
    local sSubtitleFont = ( sSubtitleFont or "TLib.Standard" )

    surface.SetFont( sTitleFont )
    local _, iTextH = surface.GetTextSize( sTitle )
    self.iHeaderH = ( iTextH + self.iMargin )

    if self.sSubtitle then
        surface.SetFont( sSubtitleFont )
        _, iTextH = surface.GetTextSize( sSubtitleFont )

        self.iHeaderH = ( self.iHeaderH + iTextH )
    end

    self.dHeader = vgui.Create( "DPanel", self )
    self.dHeader:SetSize( self:GetWide(), self.iHeaderH )    
    self.dHeader:SetZPos( 50 )

    local iShadowH = math.ceil( self.iHeaderH - ( self.iMargin * .5 ) )
    local iMargin, iRoundness = dPanel.iMargin, dPanel.iRoundness

    function self.dHeader:Paint( iW, iH )
        if not dPanel.bInitialized then
            return
        end

        draw.RoundedBoxEx( iRoundness, 0, 0, iW, iH, dPanel.tHeaderColor, true, true, false, false )

        surface.SetDrawColor( dPanel.tShadowColor )
        surface.SetMaterial( TLib.Mat[ 3 ] )
        surface.DrawTexturedRect( 0, ( iH - iShadowH - 1 ), iW, iShadowH )

        if dPanel.sSubtitle then
            draw.SimpleText( dPanel.sTitle, sTitleFont, iMargin, ( iH * .35 ), dPanel.tTextColor, 0, 1 )
            draw.SimpleText( dPanel.sSubtitle, sSubtitleFont, iMargin, ( iH * .65 ), dPanel.tTextColor, 0, 1 )
        else
            draw.SimpleText( dPanel.sTitle, sTitleFont, iMargin, ( iH * .5 ), dPanel.tTextColor, 0, 1 )
        end
    end

    if IsValid( self.dClose ) then
        self:ShowCloseButton( true )
    end
end

--[[

    PANEL:ShowCloseButton
        Params: Enable close button (boolean) {default: true}

]]--

function PANEL:ShowCloseButton( bShow )
    if IsValid( self.dClose ) then
        self.dClose:Remove()
        self.dClose = nil
    end

    if not bShow then
        return
    end

    local dPanel = self
    local dParent = ( IsValid( self.dHeader ) and self.dHeader or self )

    self.dClose = vgui.Create( "DButton", dParent )
    self.dClose:SetSize( self.iHeaderH, self.iHeaderH )
    self.dClose:SetPos( ( dParent:GetWide() - self.dClose:GetWide() ) - self.iMargin, 0 )
    self.dClose:SetText( "✖" )
    self.dClose:SetFont( "TLib.Small" )
    self.dClose:SetTextColor( TLib:C( 2 ) )
    self.dClose:SetTextInset( -1, 0 )
    self.dClose:SetContentAlignment( 6 )
    self.dClose:SetZPos( 49 )
    self.dClose.Paint = nil

    -- Close button: On start hover
    function self.dClose:OnCursorEntered()
        self:SetTextColor( TLib:C( 4 ) )
    end

    -- Close button: On stop hover
    function self.dClose:OnCursorExited()
        self:SetTextColor( TLib:C( 2 ) )
    end

    -- Close button: On click
    function self.dClose:DoClickInternal()
        TLib:Play2DSound( "tlib/click_02.mp3" )

        local iX, iY = dPanel:GetPos()
        dPanel:MoveTo( iX, ScrH(), .3, 0, .3, function()
            if IsValid( dPanel ) then
                dPanel:Remove()
            end
        end )
    end
end

--[[

    PANEL:Paint

]]--

function PANEL:Paint( iW, iH )  
    if not self.bInitialized then
        return
    end

    -- Background shadow
    if self.bBgShadow then
        DisableClipping( true )
            draw.RoundedBox( self.iRoundness, 1, 1, iW, iH, self.tShadowColor )
        DisableClipping( false )
    end

    -- Background blue
    if self.bBgBlur then
        Derma_DrawBackgroundBlur( self, self.fSysTime )
    end

    draw.RoundedBox( self.iRoundness, 0, 0, iW, iH, self.tBgColor )
end

-- Register VGUI element
vgui.Register( "TLFrame", PANEL, "DFrame" )
PANEL = nil
--PATH addons/tlib/lua/tlib/client/derma/test.lua:
--[[

    TLib:FrameTest
        Descr: VGUI elements exemple 

]]--

function TLib:FrameTest( bRemove )
    if IsValid( self.dTest ) then
        self.dTest:Remove()
        if bRemove then
            self.dTest = nil
            return
        end
    end

    local iMargin, iRoundness = self:ScaleVGUI()

    self.dTest = vgui.Create( "TLFrame" )
    self.dTest:SetSize( math.ceil( ScrH() * .5 ), math.ceil( ScrH() * .52 ) )
    self.dTest:Center()
    self.dTest:MakePopup()
    self.dTest:ShowCloseButton( true )
    self.dTest:SetHeader( "UI Title" )--, "This is a subtitle", "TLib.Title", "TLib.Subtitle" )

    -- function self.dTest:OnCloseClick()
    --     if IsValid( self ) then
    --         self:Remove()
    --     end
    -- end

    local iCBoxW = math.ceil( ScrH() * .036 )
    local iCBoxH = math.ceil( ScrH() * .015 )
    local iCBoxX = ( self.dTest:GetWide() - iCBoxW - iMargin )
    local iCBoxY = ( self.dTest:GetHeaderHeight() + iMargin )

    for i = 1, 18 do
        local dCheckbox = vgui.Create( "TLCheckBox", self.dTest )
        dCheckbox:SetSize( iCBoxW, iCBoxH )
        dCheckbox:SetPos( iCBoxX, iCBoxY + ( ( iCBoxH + iMargin ) * ( i - 1 ) ) )

        if ( i == 15 ) then
            dCheckbox:SetCheckedColor( TLib:C( 3 ) )
            dCheckbox:SetUncheckedColor( TLib:C( 4 ) )
        elseif ( i < 4 ) then
            dCheckbox:SetCheckedColor( TLib:C( 2 ) )
        elseif ( i > 10 ) then
            dCheckbox:SetCheckedColor( TLib:C( 4 ) )
        end
    end

    local dTextEntry = vgui.Create( "TLTextEntry", self.dTest )
    dTextEntry:SetSize( self.dTest:GetWide() * .6, ( self.dTest:GetTall() * .06 ) )
    dTextEntry:SetPos( iMargin, ( self.dTest:GetHeaderHeight() + iMargin ) )
    dTextEntry:SetPlaceholderText( "This is a placeholder" )

    local dScroll = vgui.Create( "TLScroll", self.dTest )
    dScroll:SetSize( self.dTest:GetWide() - iCBoxW - ( iMargin * 3 ), ( self.dTest:GetTall() * .6 ) )
    dScroll:AlignLeft( iMargin )
    dScroll:AlignBottom( iMargin )

    local iBtnW = ( dScroll:GetWide() - dScroll:GetVBar():GetWide() - 1 )
    for i = 1, 22 do
        local dBtn = dScroll:Add( "TLButton" )
        dBtn:SetSize( iBtnW, ( self.dTest:GetTall() * .06 ) )
        dBtn:SetText( "Default TLButton" )

        if ( i > 20 ) then
            dBtn:SetBgColor( TLib:C( 3 ) )
            dBtn:SetBgHoverColor( TLib:C( 4 ) )
            dBtn:SetTitleColor( TLib:C( 5 ) )
            dBtn:SetFontHover( "TLib.Standard" )
        end
    end

    dScroll:AlignContents( 6 )

    local dCBox = vgui.Create( "TLComboBox", self.dTest )
    dCBox:SetSize( self.dTest:GetWide() - iCBoxW - ( iMargin * 3 ), ( self.dTest:GetTall() * .06 ) )
    dCBox:AlignLeft( iMargin )
    dCBox:AlignBottom( dScroll:GetTall() + ( iMargin * 2 ) )

    for i = 1, 12 do
        dCBox:AddChoice( i, i )
    end
end


local function createTLToast()
    local dToast = vgui.Create( "TLToast" )
    dToast:SetSize( ( ScrH() * .32 ), ( ScrH() * .2 ) )
    dToast:Center()
    dToast:MakePopup()
    dToast:SetHeader( "VENDOR", "What would you like to do?" )
    dToast:AddChoice( "Sell wine", function( dChoice )  print( dChoice ) end )
    dToast:AddChoice( "Visit shop", function( dChoice )  print( dChoice ) end )
    -- function dToast:OnChoiceClicked( dChoice )
    --     if IsValid( dToast.dClose ) then
    --         dToast.dClose:DoClickInternal()
    --     end
    -- end

    print( dToast:GetHeaderHeight() )
end

--[[

    OnPlayerChat

]]--

hook.Add( "OnPlayerChat", "TLib_OnPlayerChat", function( pPlayer, sText, bTeam, bDead )
    if ( pPlayer ~= LocalPlayer() ) then
        return
    end

    if ( string.lower( sText ) == "/tlib" ) then
        TLib:FrameTest()    
    end

    if ( string.lower( sText ) == "/tltoast" ) then
        createTLToast()
    end
end )

--DEBUG
    -- if IsValid( TLib.dTest ) then
    --     TLib.dTest:Remove()
    --     if bRemove then
    --         TLib.dTest = nil
    --         return
    --     end
    -- end
--PATH addons/simplistic_presentation/lua/simplistic_presentation/config.lua:
SimplisticPresentation.Config = {}

-- Choose the addon language (en, fr)
SimplisticPresentation.Config.sLanguage = "fr"

-- Which prefix should be displayed in front of addon messages in chat ?
SimplisticPresentation.Config.sChatPrefix = "[Simplistic Presentation]"

-- Customize the chat command to open the manage panel (prefix is set by default to ! or /)
SimplisticPresentation.Config.sManagePanelCommand = "spr"

-- Draw the over head hud without pressing any key
SimplisticPresentation.Config.bDrawOverHeadDefaulty = false

-- Draw the over head hud & buttons in the context menu
SimplisticPresentation.Config.bDrawInContextMenu = true

-- Hide the job name if the player is unknown
SimplisticPresentation.Config.bHideJobIfUnknown = true

-- Draw the over head hud & buttons while pressing a specific key (set false to disable or select a key over here: https://wiki.facepunch.com/gmod/Enums/IN)
SimplisticPresentation.Config.kDrawWhilePressingKey = IN_USE

-- Distance to see the over head hud & buttons (don't set it too high !)
SimplisticPresentation.Config.iRenderDistance = 10000

-- Customize the console command to toggle the admin view mode
SimplisticPresentation.Config.sAdminModeConsoleCommand = "spr_adminmode"

-- Customize the chat command to open the admin panel (prefix is set by default to ! or /)
SimplisticPresentation.Config.sAdminPanelCommand = "sprpanel"

-- Specify the usergroups who have access to the admin panel/mode !
SimplisticPresentation.Config.tAdminModeGroups = {
    ["superadmin"] = true,
    ["admin"] = true,
    ["moderator"] = true,
}

-- Do you use a moderation job ? If yes, setup the configuration below !
SimplisticPresentation.Config.bAdminModeJobs = true

-- Specify the job(s) name(s) over here ! (they will automatically see every players name)
SimplisticPresentation.Config.tAdminModeJobs = {
    ["Staff en Service"] = true,
}

--[[
    Specify in tables which professions can see each other's names. 

    · Example:

    ["A unique id (ex: Crazy Gangsters)"] = {
        ["Gangster"] = true,
        ["Mob boss"] = true
    },

    -> In this example, players in Gangster & Mob boss job will be able to see their names correctly without interacting !
--]]

SimplisticPresentation.Config.tJobsKnowEachOther = {
    ["Crazy Gangsters"] = {
        ["Mob boss"] = true,
        ["Gangster"] = true,
    }
}

--[[
    Specify jobs with player names or job names know by everyone !

    · Example:

    ["Team Name (ex: Mayor)"] = {
        ["bName"] = true, -- If set to true, everyone will be able to see player name in the job job (ex: John Doe)
        ["bJobName"] = true, -- If set to true, everyone will be able to see player jobname (ex: Mayor)
    },

    -> In this example, everyone will be able to see the player name and job name of the Mayor without interacting !
--]]

SimplisticPresentation.Config.tJobsKnowByEveryone = {
    ["Mayor"] = {
        ["bName"] = true,
        ["bJobName"] = true,
    },
    ["Civil Protection"] = {
        ["bName"] = true,
        ["bJobName"] = true,
    },
}
--PATH addons/simplistic_presentation/lua/simplistic_presentation/constants.lua:
SimplisticPresentation.Constants = SimplisticPresentation.Constants or {}

SimplisticPresentation.Constants["mUi"] = {

    ["mClipboard"] = Material('simplistic_presentation/clipboard.png'),
    ["mSearch"] = Material('simplistic_presentation/search.png'),
    ["mUser"] = Material('simplistic_presentation/user.png'),
    ["mGradient"] = Material('gui/gradient'),

    ["mIcon"] = 'simplistic_presentation/cicon.png',

}

SimplisticPresentation.Constants['cColors'] = {
    ["cHeader"] = Color(49, 54, 63, 255),
    ["cBackground"] = Color(34, 40, 49, 255),
    ["cText"] = Color(118, 171, 174, 255)
}
--PATH addons/sl_main_system/lua/autorun/sl_config_skills.lua:
-- sh

-- type : "corpsacorps" == arme poings
-- type : "sword" == arme epeiste
-- type : "marteau" == arme tank
-- type : "magie" == arme poings && baton

game.AddParticles("particles/union_sololeveling_mage21.pcf")
game.AddParticles("particles/union_sololeveling_mage22.pcf")
game.AddParticles("particles/union_sololeveling_mage13.pcf")

game.AddParticles("particles/[sl-nw].pcf")

PrecacheParticleSystem("[NE]PortailBleue")
PrecacheParticleSystem("[NE]PortailRouge")
PrecacheParticleSystem("[NW]MoineHeal")
PrecacheParticleSystem("[NW]MoinePuri")
PrecacheParticleSystem("[NW]MoineDGT")
PrecacheParticleSystem("[NW]MoineBoostDGT")
PrecacheParticleSystem("[NW]MoineResistance")
PrecacheParticleSystem("[NW]MoineBoostRST")
PrecacheParticleSystem("[NW]MoineFrappeDivine")
PrecacheParticleSystem("[NW]MoinePunch")

local particlename = {
    "[mad_union]_lightning_sphere_impacta",
	"[union_mage]_light_projectile",
    "[tenebre]_lonelymoon",
    "[tenebre]_moon_vortex",
}

for _, v in ipairs(particlename) do PrecacheParticleSystem(v) end

local timer_Simple = timer.Simple
local ents_FindInSphere = ents.FindInSphere

local hitjoueur = {
	"mad_sfx_sololeveling/punch/se_Punch_FaceHit.ogg",
	"mad_sfx_sololeveling/punch/se_Punch_Hit01.ogg",
	"mad_sfx_sololeveling/punch/se_Punch_Hit02.ogg"
}

local swing_attack = {
	"mad_sfx_sololeveling/punch/chopper_Punch01.ogg",
	"mad_sfx_sololeveling/punch/chopper_Punch02.ogg",
	"mad_sfx_sololeveling/punch/chopper_Punch03.ogg"
}

local dash_sfx = "mad_sfx_sololeveling/normal/xiangze_dashatk.ogg"

SKILLS_SL = {
    ["attaque1"] = {
        stam = 50,
        name = "Attaque Rapide",
        level = 1,
        icon = "mad_sololeveling/skills/icons/punch1.png",
        classe = {["bagarreur"] = true,} ,
        coldown = 5,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_soryu1erattaque" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.2, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.4, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(1.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(10, 65, 25)
            end)

        end,
    },

    ["epeiste1"] = {
        stam = 50,
        name = "Slash Rapide",
        level = 2,
        icon = "mad_sololeveling/skills/icons/slashrapide.png",
        classe = {
            ["guerrier"] = true,
            ["guerrier_lourd"] = true,
        },
        coldown = 5,
        type = "sword",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_foudreattaquesimple2" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(20, 65, 25)
            end)

        end,
    },

    ["epeiste2"] = {
        stam = 100,
        name = "Cassage",
        level = 10,
        icon = "mad_sololeveling/skills/icons/attack20.png",
        classe = {
            ["guerrier"] = true,
            ["guerrier_lourd"] = true,
        },
        coldown = 5,
        type = "sword",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_eauattaquelourde3" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(35, 65, 35)
            end)

        end,
    },

    ["epeiste3"] = {
        stam = 150,
        name = "Revers de Lame",
        level = 15,
        icon = "mad_sololeveling/skills/icons/attack17.png",
        classe = {
            ["guerrier"] = true,
            ["guerrier_lourd"] = true,
        },
        coldown = 5,
        type = "sword",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_soleilattaquelourde3" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end
    
            timer_Simple(0.5,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(80, 65, 35)
            end)

        end,
    },

    ["epeiste4"] = {
        stam = 200,
        name = "Tempête",
        level = 20,
        icon = "mad_sololeveling/skills/icons/attack14.png",
        classe = {
            ["guerrier"] = true,
            ["guerrier_lourd"] = true,
        },
        coldown = 9,
        type = "sword",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_flammeattaquelourde3" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end

            timer_Simple(0.15,function()
                ply:GetActiveWeapon():DamageAttaque(75, 65, 35)
            end)
    
            timer_Simple(0.8,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(75, 65, 35)
            end)

        end,
    },

    ["epeiste5"] = {
        stam = 250,
        name = "Groundcrack",
        level = 25,
        icon = "mad_sololeveling/skills/icons/attack18.png",
        classe = {
            ["guerrier"] = true,
            ["guerrier_lourd"] = true,
        },
        coldown = 9,
        type = "sword",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_eau6ememouvement" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end
    
            timer_Simple(1,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(190, 65, 35)

                ParticleEffect( "[union]_rock_smash", ply:GetPos()+ply:GetForward()*75, ply:GetAngles() )
            end)

        end,
    },

    ["epeiste6"] = {
        stam = 300,
        name = "Aura Slash",
        level = 30,
        icon = "mad_sololeveling/skills/icons/attack25.png",
        classe = {
            ["guerrier"] = true,
            ["guerrier_lourd"] = true,
        },
        coldown = 5,
        type = "sword",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_flamme3ememouvement" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect1", effectdata, true, true )

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            timer_Simple(0.4,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(250, 65, 35)
                timer_Simple(0.001, function() ParticleEffect( "[2]_fog_slash_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*35, ply:GetAngles() + Angle(-120,90,90), ply ) end)
            end)

        end,
    },

    ["epeiste7"] = {
        stam = 350,
        name = "Transcendent Slash",
        level = 35,
        icon = "mad_sololeveling/skills/icons/attack26.png",
        classe = {
            ["guerrier"] = true,
            ["guerrier_lourd"] = true,
        },
        coldown = 15,
        type = "sword",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_foudre5ememouvement" )
            

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffectAttach("[mad_sl] epeiste1", 4, ply, 0)
            end)

            timer.Simple(0.2, function()
                timer.Create("Attack_TranscendentSlash_Epeiste"..ply:SteamID(), 0.2, 9, function()
                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                    ply:GetActiveWeapon():DamageAttaque(44, 65, 35)
                end)
            end)

        end,
    },


    ["porteur1"] = {
        stam = 50,
        name = "Slash Rapide",
        level = 2,
        icon = "mad_sololeveling/skills/icons/slashrapide.png",
        classe = {["porteur"] = true},
        coldown = 5,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_foudreattaquesimple2" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(20, 65, 25)
            end)

        end,
    },

    ["porteur2"] = {
        stam = 100,
        name = "Cassage",
        level = 10,
        icon = "mad_sololeveling/skills/icons/attack20.png",
        classe = {["porteur"] = true},
        coldown = 5,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_eauattaquelourde3" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(35, 65, 35)
            end)

        end,
    },

    ["porteur3"] = {
        stam = 150,
        name = "Revers de Lame",
        level = 15,
        icon = "mad_sololeveling/skills/icons/attack17.png",
        classe = {["porteur"] = true},
        coldown = 5,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_soleilattaquelourde3" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end
    
            timer_Simple(0.5,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(80, 65, 35)
            end)

        end,
    },

    ["porteur4"] = {
        stam = 200,
        name = "Tempête",
        level = 20,
        icon = "mad_sololeveling/skills/icons/attack14.png",
        classe = {["porteur"] = true},
        coldown = 9,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_flammeattaquelourde3" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end

            timer_Simple(0.15,function()
                ply:GetActiveWeapon():DamageAttaque(75, 65, 35)
            end)
    
            timer_Simple(0.8,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(75, 65, 35)
            end)

        end,
    },

    ["porteur5"] = {
        stam = 250,
        name = "Groundcrack",
        level = 25,
        icon = "mad_sololeveling/skills/icons/attack18.png",
        classe = {["porteur"] = true},
        coldown = 9,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_eau6ememouvement" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end
    
            timer_Simple(1,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(190, 65, 35)
            end)

        end,
    },

    ["tank1"] = {
        stam = 50,
        name = "Slam",
        level = 2,
        icon = "mad_sololeveling/skills/icons/tank3.png",
        classe = {
            ["tank"] = true,
            ["gardien"] = true,
        },
        coldown = 5,
        type = "marteau",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_an_hero_asta_combat_grim_skill_01 retarget" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
            end)

            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end
    
            timer_Simple(0.8,function()
                ply:EmitSound( "mad_sfx_sololeveling/punch/sakazuki_LavaPunch01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(20, 65, 35)

                ParticleEffect( "[union]_rock_smash", ply:GetPos()+ply:GetForward()*75, ply:GetAngles() )
            end)

        end,
    },

    ["tank2"] = {
        stam = 100,
        name = "Earth Quake",
        level = 10,
        icon = "mad_sololeveling/skills/icons/tank1.png",
        classe = {
            ["tank"] = true,
            ["gardien"] = true,
        },
        coldown = 10,
        type = "marteau",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_an_hero_siren_combat_grim_skill_02_end retarget" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffectAttach("[19]_rock_circle", 4, ply, 0)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end
    
            timer_Simple(1.2,function()
                ply:EmitSound( "mad_sfx_sololeveling/punch/sakazuki_LavaPunch01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(35, 65, 35)

                ply:StopParticles()
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
                ParticleEffect( "[union]_rock_smash", ply:GetPos()+ply:GetForward()*75, ply:GetAngles() )
            end)

        end,
    },

    ["tank3"] = {
        stam = 150,
        name = "Protection",
        level = 15,
        icon = "mad_sololeveling/skills/icons/tank2.png",
        classe = {
            ["tank"] = true,
            ["gardien"] = true,
        },
        coldown = 10,
        type = "marteau",
        ismagie = false,
        element = "none",
        code = function(ply)

            

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "tank_buff", effectdata, true, true )

            timer_Simple(0.0001, function()
                ply:SetNWBool("BuffTank", true)
                util.ScreenShake( ply:GetPos(), 3, 50, 0.5, 150 )
                ply:EmitSound( dash_sfx, 75, math.random(90, 100), 1.7, CHAN_AUTO )  
            end)
    
            timer_Simple(6, function()
                ply:SetNWBool("BuffTank", false)
                hook.Remove("EntityTakeDamage", "BuffTank"..ply:SteamID())
            end)
    
            hook.Add("EntityTakeDamage", "BuffTank"..ply:SteamID(), function(target, dmginfo) 
                if target:IsPlayer() and target:GetNWBool("BuffTank") == true then
                    dmginfo:ScaleDamage( 0.5 ) // Damage is now half of what you would normally take.
                end
            end)

        end,
    },

    ["tank4"] = {
        stam = 200,
        name = "Hammer Enchancement",
        level = 20,
        icon = "mad_sololeveling/skills/icons/tank4.png",
        classe = {
            ["tank"] = true,
            ["gardien"] = true,
        },
        coldown = 8,
        type = "marteau",
        ismagie = false,
        element = "none",
        code = function(ply)

            

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "tank_enchancement", effectdata, true, true )

            ply:Mad_SetAnim( "mad_an_hero_siren_combat_skill_01 retarget" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end

            timer_Simple(0.75, function() ParticleEffect( "[19]_rock_slash_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*35, ply:GetAngles() + Angle(-120,90,90), ply ) end)
            timer_Simple(0.75, function() ParticleEffect( "[19]_rock_slash_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*35, ply:GetAngles() + Angle(120,90,90), ply ) end)

            timer_Simple(0.8,function()
                ply:EmitSound( "mad_sfx_sololeveling/punch/sakazuki_LavaPunch03.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(150, 80, 45)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
                ParticleEffect( "[union]_rock_smash", ply:GetPos()+ply:GetForward()*75, ply:GetAngles() )
            end)

        end,
    },

    ["tank5"] = {
        stam = 250,
        name = "Dome Protection",
        level = 25,
        icon = "mad_sololeveling/skills/icons/tank5.png",
        classe = {
            ["tank"] = true,
            ["gardien"] = true,
        },
        coldown = 20,
        type = "marteau",
        ismagie = false,
        element = "none",
        code = function(ply)

            

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "tank_enchancement", effectdata, true, true )

            ply:Mad_SetAnim( "mad_flammeconcentration" )

            ply:EmitSound( "mad_sfx_sololeveling/sword/mihawknew_S7_swordwind.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	

            ply.dome = ents.Create("prop_dynamic")
            ply.dome:SetModel("models/props_phx/construct/glass/glass_dome360.mdl")
            ply.dome:SetModelScale(4, 2)
            ply.dome:SetMaterial("models/debug/debugwhite")
            ply.dome:SetRenderMode( RENDERMODE_TRANSCOLOR ) -- You need to set the render mode on some entities in order for the color to change
            ply.dome:SetColor( Color(127,255,255,100) )
            ply.dome:SetPos(ply:GetPos())
            ply.dome:Spawn()

            ply:Freeze(true)
            timer.Simple(3, function()
                ply:Freeze(false)
            end)

            local effectdata = EffectData()
			effectdata:SetOrigin( ply.dome:GetPos() )
			effectdata:SetEntity( ply.dome )
		    util.Effect( "sl_effect2", effectdata, true, true )

            timer.Create("TankDefense"..ply:SteamID64(), 0.2, 25, function()
                if not IsValid(ply.dome) then timer.Remove("TankDefense"..ply:SteamID64()) return end
                for k, v in ipairs( ents.FindInSphere( ply.dome:GetPos(), 250 ) ) do

                    if v:IsNPC() or v:IsNextBot() then
                        v:SetVelocity(v:GetForward()*-450)
                    end

                    if v:IsPlayer() then
                        if v:Health() < v:GetMaxHealth() then
                            if v:Health() < v:GetMaxHealth() - 2 then
                                v:SetHealth(v:Health()+2)
                            else
                                v:SetHealth(v:GetMaxHealth())
                            end
                        end

                        local effectdata = EffectData()
                        effectdata:SetOrigin( v:GetPos() )
                        effectdata:SetEntity( v )
                        util.Effect( "sl_effect3", effectdata, true, true )

                    end
                end
            end)

            timer.Simple(12, function()
                if IsValid(ply.dome) then ply.dome:Remove() end
            end)

        end,
    },

    ["tank6"] = {
        stam = 300,
        name = "Meteor",
        level = 30,
        icon = "mad_sololeveling/skills/icons/tank6.png",
        classe = {
            ["tank"] = true,
            ["gardien"] = true,
        },
        coldown = 12,
        type = "marteau",
        ismagie = false,
        element = "none",
        code = function(ply)

            
            
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_roche3ememouvement" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[26]_snake_catch", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
            ply:SetMoveType(MOVETYPE_NONE)

            timer_Simple(2,function()

                ParticleEffect( "[8]_howl", ply:GetPos(), ply:GetAngles() + Angle(0,90,0), ply ) 
                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/normal/Punch_Explosion_02.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				

                for i=1,10 do 
                    
                    ParticleEffect( "[union]_rock_smash", ply:GetPos()+ply:GetForward()*75*i, ply:GetAngles() )
                    util.ScreenShake(ply:GetPos()+ply:GetForward()*75*i, 3, 50, 0.5, 250)

                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
                            tr.Entity:SetVelocity(aim*1500 + tr.Entity:GetUp()*350)
                        end
                    end
                end

                ply:SetMoveType(MOVETYPE_WALK)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(250, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)

        end,
    },

    ["tank7"] = {
        stam = 350,
        name = "Hangeki",
        level = 35,
        icon = "mad_sololeveling/skills/icons/tank7.png",
        classe = {
            ["tank"] = true,
            ["gardien"] = true,
        },
        coldown = 10,
        type = "marteau",
        ismagie = false,
        element = "none",
        code = function(ply)

            
            
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_an_hero_asta_combat_skill_01 retarget" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[19]_rock_circle", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[9]_swirl_add_3", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[5]_ash_dash", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)

            timer_Simple(0.5, function() 
                ply:StopParticles()
                ply:ViewPunch(Angle(0, 0, 10)) 
                ply:GetActiveWeapon():DamageAttaque(50, 350, 35)
            end)

            timer_Simple(1.2, function()
                ParticleEffect( "[5]_ash_catch", ply:GetPos(), ply:GetAngles() + Angle(0,-90,0), ply ) 
                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/normal/Punch_Explosion_02.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				

                for i=1,3 do 
                    
                    ParticleEffect( "[union]_rock_smash", ply:GetPos()+ply:GetForward()*75*i, ply:GetAngles() )
                    util.ScreenShake(ply:GetPos()+ply:GetForward()*75*i, 3, 50, 0.5, 250)

                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
                            tr.Entity:SetVelocity(aim*1500 + tr.Entity:GetUp()*350)
                        end
                    end
                end

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(350, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)

        end,
    },

    ["feu1"] = {
        stam = 50,
        name = "Fire Ball",
        level = 2,
        icon = "mad_sololeveling/skills/icons/magie18.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "feu",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.5, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(20, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[sl_mage]_fire_tiger_projectile", "[sl_mage]_fireball"}, 750)
            end)

        end,
    },

    ["feu2"] = {
        stam = 100,
        name = "Fire Railgun",
        level = 10,
        icon = "mad_sololeveling/skills/icons/magie17.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "feu",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
            
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(5, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[sl_mage]_fire_tiger_projectile", "[sl_mage]_fireball"}, 750)
            end)

            timer_Simple(0.6, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(5, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[sl_mage]_fire_tiger_projectile", "[sl_mage]_fireball"}, 750)
            end)

            timer_Simple(0.8, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(5, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[sl_mage]_fire_tiger_projectile", "[sl_mage]_fireball"}, 750)
            end)

        end,
    },

    ["feu3"] = {
        stam = 150,
        name = "Fire Circle",
        level = 15,
        icon = "mad_sololeveling/skills/icons/magie16.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "feu",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquelourde3" )
            
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(80, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[10]_spin_dash"}, 750)
            end)

        end,
    },

    ["feu4"] = {
        stam = 200,
        name = "Fire Eruption",
        level = 20,
        icon = "mad_sololeveling/skills/icons/magie15.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "feu",
        code = function(ply)

            
            
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_fils3emeattaque" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
            ply:SetMoveType(MOVETYPE_NONE)

            timer_Simple(2,function()

                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/normal/Punch_Explosion_02.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				

                for i=1,4 do 
                    
                    ParticleEffect( "[10]_fire_blast", ply:GetPos()+ply:GetForward()*75*i, ply:GetAngles() )
                    util.ScreenShake(ply:GetPos()+ply:GetForward()*75*i, 3, 50, 0.5, 250)

                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
                            tr.Entity:SetVelocity(aim*1500 + tr.Entity:GetUp()*350)
                            tr.Entity:Ignite(3, 4)
                        end
                    end
                end

                ply:SetMoveType(MOVETYPE_WALK)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(150, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)

        end,
    },

    ["feu5"] = {
        stam = 250,
        name = "Fire Concentration",
        level = 25,
        icon = "mad_sololeveling/skills/icons/magie13.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "feu",
        code = function(ply)

            

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(190, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[10]_unknowing_fire", "[10]_blazing_universe"}, 750)
            end)

        end,
    },

    ["feu6"] = {
        stam = 300,
        name = "Fire Warp",
        level = 30,
        icon = "mad_sololeveling/skills/icons/magie12.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "feu",
        code = function(ply)

        
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_filseveil" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[10]_fire_tiger_sword", ply:GetPos()+ply:GetForward()*75+ply:GetUp()*75, ply:GetAngles()+Angle(0,90,0), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[sl_mage_feu]_nezuko_ground_small", ply:GetPos(), ply:GetAngles(), ply ) 
            end)

            timer_Simple(2, function()

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_Fire01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()
                ParticleEffect( "[10]_rengoku_start", ply:GetPos(), ply:GetAngles(), ply ) 

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(125, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[sl_mage]_fire_tiger_projectile", "[sl_mage]_fireball", "[10]_unknowing_add_2", "[3]_blue_sky", "[sl_mage_feu]_nezuko_projectile"}, 750)
                timer_Simple(1.6,function()
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_Fire01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		

                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                    ply:GetActiveWeapon():DamageLaunch(125, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[sl_mage]_fire_tiger_projectile", "[sl_mage]_fireball", "[10]_unknowing_add_2", "[3]_blue_sky", "[sl_mage_feu]_nezuko_projectile"}, 750)
                end)
            end)

        end,
    },

    ["feu7"] = {
        stam = 350,
        name = "Fire Tornado",
        level = 35,
        icon = "mad_sololeveling/skills/icons/magie9.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "feu",
        code = function(ply)

            

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_fl??che5emeattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ply:EmitSound( "mad_sfx_sololeveling/fire/Margo_fire.ogg", 75, math.random(60, 75), 1, CHAN_AUTO ) 		
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[10]_fire_tiger_sword", ply:GetPos()+ply:GetForward()*75+ply:GetUp()*75, ply:GetAngles()+Angle(0,90,0), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[sl_mage_feu]_nezuko_ground_small", ply:GetPos(), ply:GetAngles(), ply ) 
            end)

            timer_Simple(2, function()

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_Fire01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                ply:EmitSound( "mad_sfx_sololeveling/fire/hong_skillW_fire.ogg", 85, math.random(70, 130), 1.5, CHAN_AUTO ) 		
                ply:EmitSound( "mad_sfx_sololeveling/fire/LavaFIreBoiling.ogg", 85, math.random(60, 75), 1, CHAN_AUTO ) 		

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()

                
            ply.feu7 = ents.Create("prop_dynamic")
            ply.feu7:SetModel("models/props_phx/construct/glass/glass_dome360.mdl")
            ply.feu7:SetRenderMode( RENDERMODE_TRANSCOLOR ) -- You need to set the render mode on some entities in order for the color to change
            ply.feu7:SetColor( Color(127,255,255,0) )
            ply.feu7:SetPos(ply:GetPos())
            ply.feu7:Spawn()

            timer_Simple(0.001,function()
                ParticleEffect( "[10]_rengoku_tornado", ply:GetPos(), ply:GetAngles(), ply ) 
            end)

            timer.Create("Feu7Attack"..ply:SteamID64(), 0.2, 25, function()
                if not IsValid(ply.feu7) then timer.Remove("Feu7Attack"..ply:SteamID64()) return end
                for k, v in ipairs( ents.FindInSphere( ply.feu7:GetPos(), 500 ) ) do
                    if v != ply and v != ply.feu7 then
                        v:TakeDamage(16+ply:GetActiveWeapon().BonusDegats, ply)
                    end
                end
            end)

            timer.Simple(5, function()
                if IsValid(ply.feu7) then ply.feu7:Remove() end
                ply:StopParticles()
            end)

            end)

        end,
    },

    ["eau1"] = {
        stam = 50,
        name = "Water Ball",
        level = 2,
        icon = "mad_sololeveling/skills/icons/eau1.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "eau",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.5, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/water/jinbe_Water02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(20, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/water/se_waterhit4.ogg", 60, 80, false, 0, {"[union_mage]_water_projectile"}, 750)
            end)

        end,
    },

    ["eau2"] = {
        stam = 100,
        name = "Water Jet",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (250).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "eau",
        code = function(ply)

            ply:Mad_SetAnim( "mad_an_hero_william_combat_skill_02_end retarget" )
            

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.1, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/water/jinbe_Water02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                
                ply:GetActiveWeapon():DamageAttaque(35, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
                timer.Simple(0.001,function() ParticleEffect( "[4]_water_jet", ply:GetPos()+ply:GetForward()*35+ply:GetUp()*45, ply:GetAngles(), ply ) end)
                timer_Simple(1,function() ply:StopParticles() end)
            end)

        end,
    },

    ["eau3"] = {
        stam = 150,
        name = "Water Wave",
        level = 15,
        icon = "mad_sololeveling/skills/icons/magie16.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "eau",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquelourde3" )
            

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/water/jinbe_Water02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                ply:GetActiveWeapon():DamageLaunch(80, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/water/se_waterhit4.ogg", 60, 80, false, 0, {"[union_mage]_water_projectile", "[mage_union]_water_circle"}, 750)	
            end)

        end,
    },

    ["eau4"] = {
        stam = 200,
        name = "Water Eruption",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (245).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "eau",
        code = function(ply)

            
            
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_fils3emeattaque" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
            ply:SetMoveType(MOVETYPE_NONE)

            timer_Simple(2,function()

                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/water/jinbe_Water06.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				

                for i=1,4 do 
                    
                    ParticleEffect( "[9]_water_tornado", ply:GetPos()+ply:GetForward()*95*i, ply:GetAngles(), ply )
                    util.ScreenShake(ply:GetPos()+ply:GetForward()*75*i, 3, 50, 0.5, 250)

                    timer_Simple(0.9, function() ply:StopParticles() end)

                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
                            tr.Entity:SetVelocity(aim*1500 + tr.Entity:GetUp()*350)
                        end
                    end
                end

                ply:SetMoveType(MOVETYPE_WALK)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(150, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)

        end,
    },

    ["eau5"] = {
        stam = 250,
        name = "Water Concentration",
        level = 25,
        icon = "mad_sololeveling/skills/icons/a (170).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "eau",
        code = function(ply)

            

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/water/jinbe_Water06.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                
                timer_Simple(0.001, function() 
                    ParticleEffect( "[9]_shtil", ply:GetPos(), ply:GetAngles(), ply ) 
                    ParticleEffect( "[9]_water_trap", ply:GetPos(), ply:GetAngles(), ply ) 
                    util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
                    timer_Simple(0.5,function()
                        ply:StopParticles()
                    end)

                    for k, v in ipairs( ents.FindInSphere( ply:GetPos(), 350 ) ) do
                        if v != ply then
                            if v:IsPlayer() or v:IsNPC() or v:IsNextBot() then
                                v:TakeDamage(190+ply:GetActiveWeapon().BonusDegats, ply)
                            end
                        end
                    end
                end)

            end)

        end,
    },

    ["eau6"] = {
        stam = 300,
        name = "Water Warp",
        level = 30,
        icon = "mad_sololeveling/skills/icons/magie12.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "eau",
        code = function(ply)

            

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_filseveil" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[mage_union]_water_circle", ply:GetPos()+ply:GetForward()*75+ply:GetUp()*75, ply:GetAngles()+Angle(0,0,0), ply ) 
                ParticleEffect( "[9]_shtil", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[9]_water_trap", ply:GetPos(), ply:GetAngles(), ply ) 
                ply:EmitSound( "mad_sfx_sololeveling/water/jinbe_Water06.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            end)

            timer_Simple(2, function()

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()
                ParticleEffect( "[4]_compass_impact", ply:GetPos(), ply:GetAngles(), ply ) 

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/water/se_waterhit4.ogg", 60, 80, false, 0, {"[union_mage]_water_projectile", "[sl_mage]_waterball", "[mage_union]_water_circle", "[20]_forward_dash_main"}, 750)
                timer_Simple(1.6,function()
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_Fire01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		

                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                    ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/water/se_waterhit4.ogg", 60, 80, false, 0, {"[union_mage]_water_projectile", "[sl_mage]_waterball", "[mage_union]_water_circle", "[20]_forward_dash_main"}, 750)
                end)
            end)

        end,
    },

    
    ["eau7"] = {
        stam = 350,
        name = "Water Whirlwind",
        level = 35,
        icon = "mad_sololeveling/skills/icons/a (246).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "eau",
        code = function(ply)

            

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_fl??che5emeattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[mage_union]_water_circle", ply:GetPos()+ply:GetForward()*75+ply:GetUp()*75, ply:GetAngles()+Angle(0,0,0), ply ) 
                ParticleEffect( "[9]_shtil", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[9]_water_trap", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[9]_swirl", ply:GetPos(), ply:GetAngles(), ply ) 
                ply:EmitSound( "mad_sfx_sololeveling/water/jinbe_Water06.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 		
            end)

            timer_Simple(2, function()

                ply:EmitSound( "mad_sfx_sololeveling/water/se_waterexplosion.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                ply:EmitSound( "mad_sfx_sololeveling/water/jinbe_Water06.ogg", 85, math.random(70, 130), 1.5, CHAN_AUTO ) 		
                ply:EmitSound( "mad_sfx_sololeveling/water/se_WaterBurst01.ogg", 85, math.random(60, 75), 1, CHAN_AUTO ) 		

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()

                
            ply.eau7 = ents.Create("prop_dynamic")
            ply.eau7:SetModel("models/props_phx/construct/glass/glass_dome360.mdl")
            ply.eau7:SetRenderMode( RENDERMODE_TRANSCOLOR ) -- You need to set the render mode on some entities in order for the color to change
            ply.eau7:SetColor( Color(127,255,255,0) )
            ply.eau7:SetPos(ply:GetPos())
            ply.eau7:Spawn()

            timer_Simple(0.001,function()
                ParticleEffect( "[9]_urokodaki_special", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[9]_bubble_explosion", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[0]_rain", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[0]_rain_main", ply:GetPos()+ply:GetUp()*1000, ply:GetAngles(), ply ) 
            end)

            timer.Create("Eau7Attack"..ply:SteamID64(), 0.2, 25, function()
                if not IsValid(ply.eau7) then timer.Remove("Eau7Attack"..ply:SteamID64()) return end
                for k, v in ipairs( ents.FindInSphere( ply.eau7:GetPos(), 500 ) ) do
                    if v != ply and v != ply.eau7 then
                        v:TakeDamage(16+ply:GetActiveWeapon().BonusDegats, ply)
                    end
                end
            end)

            timer.Simple(5, function()
                if IsValid(ply.eau7) then ply.eau7:Remove() end
                ply:StopParticles()
            end)

            end)

        end,
    },

    ["vent1"] = {
        stam = 50,
        name = "Wind Cutter",
        level = 2,
        icon = "mad_sololeveling/skills/icons/a (230).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "air",
        code = function(ply)
            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.5, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/wind/hancocknewMagicwind_1.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(20, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/wind/nami_Wind_Push.ogg", 60, 80, false, 0, {"[5]_jumelles", "[4]_brice_add_3", "[5]_trombe_prepar_add_2"}, 750)
            end)

        end,
    },

    ["vent2"] = {
        stam = 100,
        name = "Wind Jet",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (250).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "air",
        code = function(ply)

            

            ply:Mad_SetAnim( "mad_an_hero_william_combat_skill_02_end retarget" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.1, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/wind/hancocknewMagicwind_1.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                ply:GetActiveWeapon():DamageAttaque(35, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
                timer.Simple(0.001,function() ParticleEffect( "[5]_trombe", ply:GetPos()+ply:GetForward()*35+ply:GetUp()*45, ply:EyeAngles()+Angle(0,100,0), ply ) end)
                timer_Simple(1,function() ply:StopParticles() end)
            end)

        end,
    },

    ["vent3"] = {
        stam = 150,
        name = "Air Shockwave",
        level = 15,
        icon = "mad_sololeveling/skills/icons/magie16.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "air",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquelourde3" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/wind/hancocknewMagicwind_1.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageLaunch(80, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/wind/nami_Wind_Push.ogg", 60, 80, false, 0, {"[5]_jumelles", "[4]_brice_add_3", "[5]_trombe_prepar_add_2", "[union_mad]_wind_circle"}, 750)	
            end)

        end,
    },

    ["vent4"] = {
        stam = 200,
        name = "Wind Eruption",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (345).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "air",
        code = function(ply)

            
            
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_fils3emeattaque" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
            ply:SetMoveType(MOVETYPE_NONE)

            timer_Simple(2,function()

                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/wind/hancocknewMagicwind_1.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/wind/kid_Wind01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	

                for i=1,4 do 
                    
                    ParticleEffect( "[5]_trombe", ply:GetPos()+ply:GetForward()*125*i, ply:GetAngles()+Angle(0,0,-90), ply )
                    ParticleEffect( "[4]_brice_add_3", ply:GetPos()+ply:GetForward()*125*i, ply:GetAngles()+Angle(0,0,0), ply )
                    util.ScreenShake(ply:GetPos()+ply:GetForward()*125*i, 3, 50, 0.5, 250)

                    timer_Simple(0.9, function() ply:StopParticles() end)

                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
                            tr.Entity:SetVelocity(aim*1500 + tr.Entity:GetUp()*350)
                        end
                    end
                end

                ply:SetMoveType(MOVETYPE_WALK)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(150, 450, 50)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)

        end,
    },

    ["vent5"] = {
        stam = 250,
        name = "Wind Concentration",
        level = 25,
        icon = "mad_sololeveling/skills/icons/a (170).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "air",
        code = function(ply)

            

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/wind/hancocknewMagicwind_1.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/wind/kid_Wind01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/wind/nami_WindBuff.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                
                timer_Simple(0.001, function() 
                    ParticleEffect( "[4]_brice", ply:GetPos(), ply:GetAngles(), ply ) 
                    ParticleEffect( "[5]_flash", ply:GetPos(), ply:GetAngles(), ply ) 
                    util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
                    timer_Simple(0.5,function()
                        ply:StopParticles()
                    end)

                    for k, v in ipairs( ents.FindInSphere( ply:GetPos(), 350 ) ) do
                        if v != ply then
                            if v:IsPlayer() or v:IsNPC() or v:IsNextBot() then
                                v:TakeDamage(190+ply:GetActiveWeapon().BonusDegats, ply)
                            end
                        end
                    end
                end)

            end)

        end,
    },

    ["wind6"] = {
        stam = 300,
        name = "Wind Warp",
        level = 30,
        icon = "mad_sololeveling/skills/icons/magie12.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "air",
        code = function(ply)

            

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_filseveil" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[union_mad]_wind_circle", ply:GetPos()+ply:GetForward()*75+ply:GetUp()*75, ply:GetAngles()+Angle(0,0,0), ply ) 
                ParticleEffect( "[4]_brice", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[18]_wins_slashes_around", ply:GetPos(), ply:GetAngles(), ply ) 

                ply:EmitSound( "mad_sfx_sololeveling/wind/hancocknewMagicwind_1.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/wind/kid_Wind01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/wind/nami_WindBuff.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            end)

            timer_Simple(2, function()

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()
                ParticleEffect( "[4]_compass_impact", ply:GetPos(), ply:GetAngles(), ply ) 

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/wind/nami_Wind_Push.ogg", 60, 80, false, 0, {"[5]_jumelles", "[4]_brice_add_3", "[5]_trombe_prepar_add_2", "[union_mad]_wind_circle", "[18]_wind_vortex"}, 750)
                timer_Simple(1.6,function()
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_Fire01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		

                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                    ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/wind/nami_Wind_Push.ogg", 60, 80, false, 0, {"[5]_jumelles", "[4]_brice_add_3", "[5]_trombe_prepar_add_2","[union_mad]_wind_circle", "[18]_wind_vortex"}, 750)
                end)
            end)

        end,
    },

        
    ["wind7"] = {
        stam = 350,
        name = "Wind Tornado",
        level = 35,
        icon = "mad_sololeveling/skills/icons/a (351).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "air",
        code = function(ply)

            

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_fl??che5emeattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[union_mad]_wind_circle", ply:GetPos()+ply:GetForward()*75+ply:GetUp()*75, ply:GetAngles()+Angle(0,0,0), ply ) 
                ParticleEffect( "[4]_brice", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[18]_wins_slashes_around", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[18]_wind_tornado", ply:GetPos(), ply:GetAngles(), ply ) 

                ply:EmitSound( "mad_sfx_sololeveling/wind/hancocknewMagicwind_1.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/wind/kid_Wind01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/wind/nami_WindBuff.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 	
            end)

            timer_Simple(2, function()

                ply:EmitSound( "mad_sfx_sololeveling/wind/hancocknewMagicwind_1.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/wind/kid_Wind01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/wind/nami_WindBuff.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 		

                ply:EmitSound( "mad_sfx_sololeveling/wind/crocodile_CircleWind.ogg", 105, math.random(40, 50), 1, CHAN_AUTO ) 		

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()

                
            ply.vent7 = ents.Create("prop_dynamic")
            ply.vent7:SetModel("models/props_phx/construct/glass/glass_dome360.mdl")
            ply.vent7:SetRenderMode( RENDERMODE_TRANSCOLOR ) -- You need to set the render mode on some entities in order for the color to change
            ply.vent7:SetColor( Color(127,255,255,0) )
            ply.vent7:SetPos(ply:GetPos())
            ply.vent7:Spawn()

            timer_Simple(0.001,function()
                ParticleEffect( "[5]_jumelles_explosion", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[5]_flash", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[4]_brice", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[18]_wins_slashes_around", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[18]_wind_tornado", ply:GetPos(), ply:GetAngles(), ply ) 
            end)

            timer.Create("vent7Attack"..ply:SteamID64(), 0.2, 25, function()
                if not IsValid(ply.vent7) then timer.Remove("vent7Attack"..ply:SteamID64()) return end
                for k, v in ipairs( ents.FindInSphere( ply.vent7:GetPos(), 500 ) ) do
                    if v != ply and v != ply.vent7 then
                        v:TakeDamage(16+ply:GetActiveWeapon().BonusDegats, ply)
                    end
                end
            end)

            timer.Simple(5, function()
                if IsValid(ply.vent7) then ply.vent7:Remove() end
                ply:StopParticles()
            end)

            end)

        end,
    },

    ["terre1"] = {
        stam = 50,
        name = "Earth Spades",
        level = 2,
        icon = "mad_sololeveling/skills/icons/a (110).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "terre",
        code = function(ply)

            

            timer_Simple(0.001,function()
                ParticleEffect( "dust_dash_mudrock", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "dust_dash_smoke", ply:GetPos(), ply:GetAngles(), ply ) 
            end)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.5, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/earth/hancocknewRockbreak.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch2(20, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/earth/moria_GroundImpact.ogg", 60, 80, false, 0, {"[12]_rock"}, 2500, "models/hunter/misc/sphere025x025.mdl", 1, "models/props_pipes/GutterMetal01a", 55)
            end)

        end,
    },

    ["terre2"] = {
        stam = 100,
        name = "Earth Rafale",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (112).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "terre",
        code = function(ply)

            

            timer_Simple(0.001,function()
                ParticleEffect( "dust_dash_mudrock", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "dust_roll", ply:GetPos(), ply:GetAngles(), ply ) 
            end)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.2,function()
                timer.Create("Terre2Atk"..ply:SteamID64(), 0.2, 3, function()
                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                    ply:EmitSound( "mad_sfx_sololeveling/earth/hancocknewRockbreak.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                    ply:GetActiveWeapon():DamageLaunch2(5, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/earth/moria_GroundImpact.ogg", 60, 80, false, 0, {"[12]_rock"}, 2500, "models/hunter/misc/sphere025x025.mdl", 1.2, "models/props_pipes/GutterMetal01a", 55)
                end)
            end)

        end,
    },

    ["terre3"] = {
        stam = 150,
        name = "Ground Spike",
        level = 15,
        icon = "mad_sololeveling/skills/icons/a (111).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "terre",
        code = function(ply)

            timer_Simple(0.001,function()
                ParticleEffect( "dust_dash_mudrock", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "dust_roll", ply:GetPos(), ply:GetAngles(), ply ) 
            end)

            ply:Mad_SetAnim( "mad_an_hero_william_combat_skill_01 retarget" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.2,function()
                ply:EmitSound( "mad_sfx_sololeveling/earth/hancocknewRockbreak.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/earth/bltrmo_jumprock.ogg", 95, math.random(70, 130), 1, CHAN_AUTO ) 
                timer_Simple(0.001,function()
                    ParticleEffect( "[unionmage]_rock_aaa", ply:GetPos()+ply:GetForward()*250, ply:GetAngles(), ply ) 
                    ply:GetActiveWeapon():DamageAttaque(80, 300, 65)
                    util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
                end)
            end)

        end,
    },

    ["terre4"] = {
        stam = 200,
        name = "Row of Spike",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (109).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "terre",
        code = function(ply)


            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_fils3emeattaque" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "dust_dash_mudrock", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "dust_roll", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
            ply:SetMoveType(MOVETYPE_NONE)

            timer_Simple(2,function()

                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/earth/hancocknewRockbreak.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/earth/bltrmo_jumprock.ogg", 95, math.random(70, 130), 1, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/earth/perona_GroundHit.ogg", 95, math.random(70, 130), 1, CHAN_AUTO ) 

                for i=1,4 do 
                    
                    ParticleEffect( "dust_conquer_sharp", ply:GetPos()+ply:GetForward()*345*i, ply:GetAngles()+Angle(0,0,0), ply )
                    ParticleEffect( "[unionmage]_rock_aaa", ply:GetPos()+ply:GetForward()*315*i, ply:GetAngles()+Angle(0,0,0), ply )

                    util.ScreenShake(ply:GetPos()+ply:GetForward()*125*i, 3, 50, 0.5, 250)

                    timer_Simple(0.9, function() ply:StopParticles() end)

                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
                            tr.Entity:SetVelocity(aim*1500 + tr.Entity:GetUp()*350)
                        end
                    end
                end

                ply:SetMoveType(MOVETYPE_WALK)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(150, 550, 65)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)


        end,
    },

    
    ["terre5"] = {
        stam = 250,
        name = "Earth Quake",
        level = 25,
        icon = "mad_sololeveling/skills/icons/a (144).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "terre",
        code = function(ply)


            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_fl??che4emeattaque" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "dust_dash_mudrock", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "dust_roll", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[19]_rock_circle", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
            ply:SetMoveType(MOVETYPE_NONE)

            timer_Simple(0.9,function()

                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/earth/hancocknewRockbreak.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/earth/bltrmo_jumprock.ogg", 95, math.random(70, 130), 1, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/earth/perona_GroundHit.ogg", 95, math.random(70, 130), 1, CHAN_AUTO ) 

                for i=1,4 do 
                    
                    ParticleEffect( "dust_conquer_sharp", ply:GetPos()+ply:GetForward()*100*i, ply:GetAngles()+Angle(0,0,0), ply )
                    ParticleEffect( "[union]_rock_smash", ply:GetPos()+ply:GetForward()*100*i, ply:GetAngles()+Angle(0,0,0), ply )

                    util.ScreenShake(ply:GetPos()+ply:GetForward()*100*i, 3, 50, 0.5, 250)

                    timer_Simple(0.9, function() ply:StopParticles() end)

                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
                            tr.Entity:SetVelocity(aim*1500 + tr.Entity:GetUp()*350)
                        end
                    end
                end

                ply:SetMoveType(MOVETYPE_WALK)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(190, 550, 65)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)


        end,
    },

    ["terre6"] = {
        stam = 300,
        name = "Earth Dome",
        level = 30,
        icon = "mad_sololeveling/skills/icons/a (164).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "terre",
        code = function(ply)

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "mage_enchancement", effectdata, true, true )

            ply:Mad_SetAnim( "mad_flammeconcentration" )
            
            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "dust_dash_mudrock", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "dust_roll", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "dust_fear", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            ply:ViewPunch(Angle(0, 0, 30))
            ply:EmitSound( "mad_sfx_sololeveling/earth/hancocknewRockbreak.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
            ply:EmitSound( "mad_sfx_sololeveling/earth/bltrmo_jumprock.ogg", 95, math.random(70, 130), 1, CHAN_AUTO ) 
            ply:EmitSound( "mad_sfx_sololeveling/earth/perona_GroundHit.ogg", 95, math.random(70, 130), 1, CHAN_AUTO ) 

            ply.dome = ents.Create("prop_dynamic")
            ply.dome:SetModel("models/props_phx/construct/glass/glass_dome360.mdl")
            ply.dome:SetModelScale(3.5, 2)
            ply.dome:SetMaterial("models/props_pipes/GutterMetal01a")
            ply.dome:SetColor( Color(255,255,255,255) )
            ply.dome:SetPos(ply:GetPos())
            ply.dome:Spawn()

            timer_Simple(0.001,function()
                ParticleEffectAttach("mudrock_subjugate", 4, ply.dome, 0)
                ParticleEffectAttach("[unionmage]_earth_area", 4, ply.dome, 0)
            end)

            ply:Freeze(true)
            timer.Simple(3, function()
                ply:Freeze(false)
            end)

            timer.Create("DefenseTerre6"..ply:SteamID64(), 0.2, 25, function()
                if not IsValid(ply.dome) then timer.Remove("DefenseTerre6"..ply:SteamID64()) return end
                for k, v in ipairs( ents.FindInSphere( ply.dome:GetPos(), 250 ) ) do

                    if v:IsNextBot() or v:IsNPC() or v:IsPlayer() and v != ply or v:IsScripted() then
                        v:SetVelocity(v:GetForward()*-450)
                    end

                    if v:IsPlayer() and v == ply then
                        v:GodEnable()
                        timer_Simple(0.19,function()
                            v:GodDisable()
                        end)
                    end
                end
            end)

            timer.Simple(12, function()
                ply:StopParticles()
                if IsValid(ply.dome) then ply.dome:Remove() end
                ply:GodDisable()
            end)

        end,
    },

    ["terre7"] = {
        stam = 350,
        name = "Seismic",
        level = 35,
        icon = "mad_sololeveling/skills/icons/a (161).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "terre",
        code = function(ply)

            ply:Mad_SetAnim( "mad_an_hero_william_combat_skill_01 retarget" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_fl??che5emeattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_dash_mudrock", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "dust_roll", ply:GetPos(), ply:GetAngles(), ply ) 		
                ParticleEffect( "[19]_rock_circle", ply:GetPos(), ply:GetAngles(), ply ) 		
                ParticleEffect( "dust_conquer_sharp", ply:GetPos(), ply:GetAngles(), ply )
                ParticleEffect( "[union]_rock_smash", ply:GetPos(), ply:GetAngles(), ply ) 		
                ParticleEffect( "mudrock_subjugate", ply:GetPos(), ply:GetAngles(), ply ) 		
                ply:EmitSound( "mad_sfx_sololeveling/earth/hancocknewRockbreak.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/earth/bltrmo_jumprock.ogg", 95, math.random(70, 130), 1, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/earth/perona_GroundHit.ogg", 95, math.random(70, 130), 1, CHAN_AUTO )  	
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)

            timer_Simple(2, function()
        
                ply:SetMoveType(MOVETYPE_WALK)

                ply.terre7 = ents.Create("prop_dynamic")
                ply.terre7:SetModel("models/props_phx/construct/glass/glass_dome360.mdl")
                ply.terre7:SetModelScale(3.5, 2)
                ply.terre7:SetMaterial("models/props_pipes/GutterMetal01a")
                ply.terre7:SetRenderMode( RENDERMODE_TRANSCOLOR ) -- You need to set the render mode on some entities in order for the color to change
                ply.terre7:SetColor( Color(255,255,255,0) )
                ply.terre7:SetPos(ply:GetPos())
                ply.terre7:Spawn()

                timer.Create("Terre7Atk", 0.2, 20, function()

                if not IsValid(ply.terre7) then timer.Remove("Terre7Atk"..ply:SteamID64()) return end
                for k, v in ipairs( ents.FindInSphere( ply.terre7:GetPos(), 500 ) ) do
                    if v != ply and v != ply.terre7 then
                        v:TakeDamage(20+ply:GetActiveWeapon().BonusDegats, ply)
                    end
                end

                ply.terre7:EmitSound( "mad_sfx_sololeveling/earth/hancocknewRockbreak.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply.terre7:EmitSound( "mad_sfx_sololeveling/earth/bltrmo_jumprock.ogg", 95, math.random(70, 130), 1, CHAN_AUTO ) 
                ply.terre7:EmitSound( "mad_sfx_sololeveling/earth/perona_GroundHit.ogg", 95, math.random(70, 130), 1, CHAN_AUTO ) 
                timer_Simple(0.001,function()
                    util.ScreenShake(ply.terre7:GetPos(), 3, 50, 0.5, 250)
                end)
                ply:StopParticles()

                timer_Simple(0.001,function()
                    ParticleEffect( "[unionmage]_seisme", ply.terre7:GetPos(), ply.terre7:GetAngles(), ply.terre7 )
                    ParticleEffect( "[unionmage]_seisme_annihilation_type", ply.terre7:GetPos(), ply.terre7:GetAngles()+Angle(0,180,0), ply.terre7 )
                    ParticleEffect( "[unionmage]_seisme_cast_blast", ply.terre7:GetPos(), ply.terre7:GetAngles()+Angle(0,180,0), ply.terre7 )

                    for i=1,4 do 
                        util.ScreenShake(ply.terre7:GetPos(), 3+10*i, 50+10*i, 0.5, 500*i)
                    end

                end)

                timer_Simple(4,function()
                    ply.terre7:Remove()
                end)

            end)


            end)
        end,
    },

    ["foudre1"] = {
        stam = 50,
        name = "Elec Ball",
        level = 2,
        icon = "mad_sololeveling/skills/icons/a (279).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "foudre",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.5, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/electric/nami_Electric01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(20, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/electric/nami_Electric03.ogg", 60, 80, false, 0, {"[mad_union]_lightning_sphere_impacta"}, 750)
            end)

        end,
    },

    ["foudre2"] = {
        stam = 100,
        name = "Elec Railgun",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (190).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "foudre",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/electric/nami_Electric01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(5, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/electric/nami_Electric03.ogg", 60, 80, false, 0, {"[mad_union]_lightning_sphere_impacta"}, 750)
            end)

            timer_Simple(0.6, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/electric/nami_Electric01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(5, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/electric/nami_Electric03.ogg", 60, 80, false, 0, {"[mad_union]_lightning_sphere_impacta"}, 750)
            end)

            timer_Simple(0.8, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/electric/nami_Electric01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(5, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/electric/nami_Electric03.ogg", 60, 80, false, 0, {"[mad_union]_lightning_sphere_impacta"}, 750)
            end)

        end,
    },

    ["foudre3"] = {
        stam = 150,
        name = "Elec Distortion",
        level = 15,
        icon = "mad_sololeveling/skills/icons/a (183).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "foudre",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquelourde3" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/electric/nami_Electric01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(80, false, 0, true, 1, false, "", true, "mad_sfx_sololeveling/electric/nami_Electric03.ogg", 60, 80, false, 0, {"[14]_lightning_dash_add_2", "[14]_lightning_child"}, 750)
            end)

        end,
    },

    ["foudre4"] = {
        stam = 200,
        name = "Elec Shockground",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (184).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "foudre",
        code = function(ply)

            
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect6", effectdata, true, true )

            ply:Mad_SetAnim( "mad_fils3emeattaque" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffectAttach("[elec_mage]_dissolve", 4, ply, 0)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
            ply:SetMoveType(MOVETYPE_NONE)

            timer_Simple(2,function()

                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/electric/enel_ElectricPose.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				

                for i=1,5 do 
                    
                    ParticleEffect( "[14]_lightning_dash_sphere", ply:GetPos()+ply:GetForward()*75*i, ply:EyeAngles(), ply )
                    ParticleEffect( "[14]_lightning_dash_sphere_add_2", ply:GetPos()+ply:GetForward()*75*i, ply:EyeAngles(), ply )
                    ParticleEffect( "[14]_lightning_dash_sphere_add_2_trail", ply:GetPos()+ply:GetForward()*75*i, ply:EyeAngles(), ply )
                    ParticleEffect( "[14]_lightning_dash_glow", ply:GetPos()+ply:GetForward()*75*i, ply:EyeAngles(), ply )
                    timer_Simple(0.7, function()
                        ply:StopParticles()
                    end)
                    util.ScreenShake(ply:GetPos()+ply:GetForward()*75*i, 3, 50, 0.5, 250)

                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() then
                            tr.Entity:Freeze(true)
                            timer_Simple(0.5,function()
                                tr.Entity:Freeze(false)
                            end)
                        end
                    end
                end

                ply:SetMoveType(MOVETYPE_WALK)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(150, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)

        end,
    },

    ["foudre5"] = {
        stam = 250,
        name = "Elec Concentration",
        level = 25,
        icon = "mad_sololeveling/skills/icons/magie13.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "foudre",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[14]_lightning_dash_sphere_add", ply:GetPos()+ply:GetForward()*75+ply:GetUp()*75, ply:GetAngles()+Angle(0,0,0), ply ) 
                ParticleEffect( "[14]_lightning_dash_base", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[14]_lightning_dash", ply:GetPos(), ply:GetAngles(), ply ) 
                ply:EmitSound( "mad_sfx_sololeveling/water/jinbe_Water06.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 		
            end)

            timer_Simple(0.4, function()
                ply:StopParticles()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/electric/nami_Electric01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(190, false, 0, true, 1, false, "", true, "mad_sfx_sololeveling/electric/nami_Electric03.ogg", 60, 80, false, 0, {"[14]_lightning_dash_sphere", "[14]_lightning_dash_add_2", "[14]_lightning_child", "[14]_lightning_dash_glow"}, 750)
            end)

        end,
    },


    ["foudre6"] = {
        stam = 300,
        name = "Elec Warp",
        level = 30,
        icon = "mad_sololeveling/skills/icons/a (189).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "foudre",
        code = function(ply)

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_filseveil" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[14]_lightning_dash_base", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[14]_lightning_explosion", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[elec_mage_union]_aura", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffectAttach("[elec_mage]_dissolve", 4, ply, 0)
                ply:EmitSound( "mad_sfx_sololeveling/electric/nami_elec01.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                ply:EmitSound( "mad_sfx_sololeveling/electric/enel_ElectricDragon.ogg", 85, math.random(70, 130), 1.2, CHAN_AUTO ) 	 				
            end)

            timer_Simple(2, function()

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/eletric/enel_ElectricHit01.ogg", 60, 80, false, 0, {"[elec_mage_union]_projectile", "[14]_lightning_dash_sphere_add"}, 750)
                timer_Simple(1.6,function()
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_Fire01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		

                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                    ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/electric/enel_ElectricHit01.ogg", 60, 80, false, 0, {"[elec_mage_union]_projectile", "[14]_lightning_dash_sphere_add"}, 750)
                end)
            end)

        end,
    },

    ["foudre7"] = {
        stam = 350,
        name = "ThunderStorm",
        level = 35,
        icon = "mad_sololeveling/skills/icons/magie9.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "foudre",
        code = function(ply)

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_fl??che5emeattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[14]_lightning_dash_sphere_add", ply:GetPos()+ply:GetForward()*75+ply:GetUp()*75, ply:GetAngles()+Angle(0,0,0), ply ) 
                ParticleEffect( "[14]_lightning_dash_base", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[14]_lightning_dash", ply:GetPos(), ply:GetAngles(), ply ) 
                ply:EmitSound( "mad_sfx_sololeveling/electric/nami_elec01.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                ply:EmitSound( "mad_sfx_sololeveling/electric/enel_ElectricDragon.ogg", 85, math.random(70, 130), 1.2, CHAN_AUTO ) 		
            end)

            timer_Simple(2, function()

                ply:EmitSound( "mad_sfx_sololeveling/electric/enel_ElectricThunder02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                ply:EmitSound( "mad_sfx_sololeveling/eletrice/enel_ElectricThunder03.ogg", 85, math.random(70, 130), 1.5, CHAN_AUTO ) 		
                ply:EmitSound( "mad_sfx_sololeveling/electric/enel_ElectricThunder05.ogg", 85, math.random(60, 75), 1, CHAN_AUTO ) 		

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()
                
            ply.foudre7 = ents.Create("prop_dynamic")
            ply.foudre7:SetModel("models/props_phx/construct/glass/glass_dome360.mdl")
            ply.foudre7:SetRenderMode( RENDERMODE_TRANSCOLOR ) -- You need to set the render mode on some entities in order for the color to change
            ply.foudre7:SetColor( Color(127,255,255,0) )
            ply.foudre7:SetPos(ply:GetPos())
            ply.foudre7:Spawn()

            timer.Create("foudre7Attack"..ply:SteamID64(), 0.2, 25, function()
                if not IsValid(ply.foudre7) then timer.Remove("foudre7Attack"..ply:SteamID64()) return end
                for k, v in ipairs( ents.FindInSphere( ply.foudre7:GetPos(), 500 ) ) do
                    if v != ply and v != ply.foudre7 and v:IsPlayer() or v:IsNextBot() or v:IsNPC() then
                        v:TakeDamage(6+ply:GetActiveWeapon().BonusDegats, ply)
                        timer_Simple(0.001,function()
                            ParticleEffect( "[14]_lightning_explosion", v:GetPos(), v:GetAngles(), v ) 
                        end)
                    end
                end
            end)

            timer.Simple(5, function()
                if IsValid(ply.foudre7) then ply.foudre7:Remove() end
                ply:StopParticles()
            end)

            end)

        end,
    },
    
    ["glace1"] = {
        stam = 50,
        name = "Ice Breath",
        level = 2,
        icon = "mad_sololeveling/skills/icons/a (9).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "glace",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.5, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/ice/hong_skillE_ice.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(20, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/ice/shouji_ice01.ogg", 60, 80, false, 0, {"[4]_dash_ice"}, 750)
            end)

        end,
    },

    ["glace2"] = {
        stam = 100,
        name = "Ice Jet",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (250).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "glace",
        code = function(ply)

            ply:Mad_SetAnim( "mad_an_hero_william_combat_skill_02_end retarget" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.1, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/ice/hong_skillE_ice.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                ply:GetActiveWeapon():DamageAttaque(35, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
                timer.Simple(0.001,function() ParticleEffect( "[22]_icerush", ply:GetPos()+ply:GetForward()*35+ply:GetUp()*55, ply:GetAngles()+Angle(0,90,0), ply ) end)
                timer_Simple(1,function() ply:StopParticles() end)
            end)

        end,
    },

    ["glace3"] = {
        stam = 150,
        name = "Fresh Rush",
        level = 15,
        icon = "mad_sololeveling/skills/icons/magie16.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "glace",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquelourde3" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.1, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/ice/hong_skillE_ice.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                ply:GetActiveWeapon():DamageAttaque(80, 400, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
                timer.Simple(0.001,function() ParticleEffect( "[4]_ice_wave_main", ply:GetPos()+ply:GetForward()*35, ply:GetAngles()+Angle(0,-90,0), ply ) end)
                timer_Simple(1,function() ply:StopParticles() end)
            end)

        end,
    },


    ["glace4"] = {
        stam = 200,
        name = "Ice Warp",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (245).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "glace",
        code = function(ply)

            
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_fils3emeattaque" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
            ply:SetMoveType(MOVETYPE_NONE)

            timer_Simple(2,function()

                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/ice/hong_skillW_ice03.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				

                for i=1,4 do 
                    
                    ParticleEffect( "[4]_frozen_dragon_add_2", ply:GetPos()+ply:GetForward()*95*i, ply:GetAngles(), ply )
                    util.ScreenShake(ply:GetPos()+ply:GetForward()*75*i, 3, 50, 0.5, 250)

                    timer_Simple(0.9, function() ply:StopParticles() end)

                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
                            tr.Entity:SetVelocity(aim*1500 + tr.Entity:GetUp()*350)
                        end
                    end
                end

                ply:SetMoveType(MOVETYPE_WALK)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(150, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)

        end,
    },

    ["glace5"] = {
        stam = 250,
        name = "Ice Overflow",
        level = 25,
        icon = "mad_sololeveling/skills/icons/a (153).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "glace",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/ice/hong_skillE_ice.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                
                timer_Simple(0.001, function() 
                    ParticleEffect( "[4]_frozen_dragon_hitmark", ply:GetPos(), ply:GetAngles(), ply ) 
                    util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
                    timer_Simple(0.5,function()
                        ply:StopParticles()
                    end)

                    for k, v in ipairs( ents.FindInSphere( ply:GetPos(), 350 ) ) do
                        if v != ply then
                            if v:IsPlayer() or v:IsNPC() or v:IsNextBot() then
                                v:TakeDamage(190+ply:GetActiveWeapon().BonusDegats, ply)
                            end
                        end
                    end
                end)

            end)

        end,
    },

    ["glace6"] = {
        stam = 300,
        name = "Ice Warp",
        level = 30,
        icon = "mad_sololeveling/skills/icons/a (305).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "glace",
        code = function(ply)

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_filseveil" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[4]_frozen_aura", ply:GetPos(), ply:GetAngles(), ply ) 
                ply:EmitSound( "mad_sfx_sololeveling/ice/hong_skillW_ice03.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            end)

            timer_Simple(2, function()

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()
                timer_Simple(0.001,function()
                    ParticleEffect( "[4]_frozen_dragon_hitmark", ply:GetPos(), ply:GetAngles(), ply ) 
                end)

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/ice/hong_skillW_ice01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/ice/shouji_ice02.ogg", 60, 80, false, 0, {"[mad_union]_loze_around"}, 750)
                timer_Simple(1.6,function()
                    ply:EmitSound( "mad_sfx_sololeveling/ice/hong_skillW_ice01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		

                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                    ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/ice/shouji_ice02.ogg", 60, 80, false, 0, {"[mad_union]_loze_around"}, 750)
                end)
            end)

        end,
    },

    ["glace7"] = {
        stam = 350,
        name = "Ice Torture",
        level = 35,
        icon = "mad_sololeveling/skills/icons/a (323).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "glace",
        code = function(ply)

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_fl??che5emeattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[4]_frozen_dragon", ply:GetPos(), ply:GetAngles(), ply ) 
                ply:EmitSound( "mad_sfx_sololeveling/ice/hong_ability_ice.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 		
            end)

            timer_Simple(2, function()

                ply:EmitSound( "mad_sfx_sololeveling/ice/hong_skillE_ice.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                ply:EmitSound( "mad_sfx_sololeveling/ice/hong_skillQ_ice.ogg", 85, math.random(70, 130), 1.5, CHAN_AUTO ) 		
                ply:EmitSound( "mad_sfx_sololeveling/ice/hong_skillW_ice01.ogg", 85, math.random(60, 75), 1, CHAN_AUTO ) 		

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()

                
            ply.glace7 = ents.Create("prop_dynamic")
            ply.glace7:SetModel("models/props_phx/construct/glass/glass_dome360.mdl")
            ply.glace7:SetRenderMode( RENDERMODE_TRANSCOLOR ) -- You need to set the render mode on some entities in order for the color to change
            ply.glace7:SetColor( Color(127,255,255,0) )
            ply.glace7:SetPos(ply:GetPos())
            ply.glace7:Spawn()

            timer_Simple(0.001,function()
                ParticleEffect( "[4]_ice_judgmentcut_sphere_add_3", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[4]_ice_judgmentcut_sphere_add_3", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[4]_frozen_aura", ply.glace7:GetPos(), ply.glace7:GetAngles(), ply.glace7 ) 
            end)

            timer.Create("glace7Attack"..ply:SteamID64(), 0.2, 25, function()
                if not IsValid(ply.glace7) then timer.Remove("glace7Attack"..ply:SteamID64()) return end
                for k, v in ipairs( ents.FindInSphere( ply.glace7:GetPos(), 500 ) ) do
                    if v != ply and v != ply.glace7 and v:IsPlayer() or v:IsNPC() or v:IsNextBot() then
                        v:TakeDamage(16+ply:GetActiveWeapon().BonusDegats, ply)

                        timer_Simple(0.001,function()
                            ParticleEffect( "[4]_frozen_dragon_hitmark", v:GetPos(), v:GetAngles(), ply ) 
                        end)

                    end
                end
            end)

            timer.Simple(5, function()
                if IsValid(ply.glace7) then ply.glace7:Remove() end
                ply:StopParticles()
                ply.glace7:StopParticles()
            end)

            end)

        end,
    },
    
    ["lumiere1"] = {
        stam = 50,
        name = "Light Ball",
        level = 2,
        icon = "mad_sololeveling/skills/icons/a (31).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "lumiere",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.5, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(20, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[union_mage]_light_projectile"}, 1500)
            end)

        end,
    },

    ["lumiere2"] = {
        stam = 100,
        name = "Light Railgun",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (33).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "lumiere",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
            
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(7, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[union_mage]_light_projectile"}, 1500)
            end)

            timer_Simple(0.6, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(7, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[union_mage]_light_projectile"}, 1000)
            end)

            timer_Simple(0.8, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(7, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[union_mage]_light_projectile"}, 750)
            end)

        end,
    },

    ["lumiere3"] = {
        stam = 150,
        name = "Illumination",
        level = 15,
        icon = "mad_sololeveling/skills/icons/a (64).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "lumiere",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquelourde3" )
            

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                ply:GetActiveWeapon():DamageLaunch(80, true, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[union_mage]_light_flash", "[union_mage]_light_projectile", "[1]_light_groundfire_hitmark_impact"}, 1250)	
            end)

        end,
    },

    ["lumiere4"] = {
        stam = 200,
        name = "Light Eruption",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (78).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "lumiere",
        code = function(ply)
            
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_fils3emeattaque" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
            ply:EmitSound( "mad_sfx_sololeveling/fire/040_swg_fire1.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 			
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
            ply:SetMoveType(MOVETYPE_NONE)

            timer_Simple(2,function()

                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/fire/040_swg_fire1.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                ply:EmitSound( "mad_sfx_sololeveling/fire/Fireball_Lava_Launch3.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				

                for i=1,4 do 
                    
                    ParticleEffect( "[1]_light_groundfire_hitmark", ply:GetPos()+ply:GetForward()*125*i, ply:GetAngles(), ply )
                    util.ScreenShake(ply:GetPos()+ply:GetForward()*125*i, 3, 50, 0.5, 250)

                    timer_Simple(0.9, function() ply:StopParticles() end)

                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
                            tr.Entity:SetVelocity(aim*1500 + tr.Entity:GetUp()*350)
                        end
                    end
                end

                ply:SetMoveType(MOVETYPE_WALK)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(150, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)

        end,
    },

    ["lumiere5"] = {
        stam = 250,
        name = "Light Zone",
        level = 25,
        icon = "mad_sololeveling/skills/icons/a (164).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "lumiere",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/water/jinbe_Water06.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                
                timer_Simple(0.001, function() 
                    ParticleEffect( "[1]_light_sphere", ply:GetPos(), ply:GetAngles(), ply ) 
                    ParticleEffect( "[1]_light_groundcircle_add", ply:GetPos(), ply:GetAngles(), ply ) 
                    util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
                    timer_Simple(1.4,function()
                        ply:StopParticles()
                    end)

                    for k, v in ipairs( ents.FindInSphere( ply:GetPos(), 350 ) ) do
                        if v != ply then
                            if v:IsPlayer() or v:IsNPC() or v:IsNextBot() then
                                v:TakeDamage(190+ply:GetActiveWeapon().BonusDegats, ply)
                            end
                        end
                    end
                end)

            end)

        end,
    },

    ["lumiere6"] = {
        stam = 300,
        name = "Light Warp",
        level = 30,
        icon = "mad_sololeveling/skills/icons/magie12.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "lumiere",
        code = function(ply)

            

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_filseveil" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[1]_light_flash", ply:GetPos()+ply:GetForward()*75+ply:GetUp()*75, ply:GetAngles()+Angle(0,0,0), ply ) 
                ParticleEffect( "[1]_light_groundcircle", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[1]_light_sphere", ply:GetPos(), ply:GetAngles(), ply ) 
                ply:EmitSound( "mad_sfx_sololeveling/fire/040_swg_fire1.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                ply:EmitSound( "mad_sfx_sololeveling/fire/Fireball_Lava_Launch3.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 					
            end)

            timer_Simple(2, function()

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()
                ParticleEffect( "[1]_light_sphere_bloom", ply:GetPos(), ply:GetAngles(), ply ) 

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[union_mage]_light_flash", "[union_mage]_light_projectile", "[1]_light_groundfire_hitmark_impact"}, 750)
                timer_Simple(1.6,function()
                    ply:StopParticles()
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_Fire01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		

                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                    ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[union_mage]_light_flash", "[union_mage]_light_projectile", "[1]_light_groundfire_hitmark_impact"}, 750)
                end)
            end)

        end,
    },

    ["lumiere7"] = {
        stam = 350,
        name = "Sun Light",
        level = 35,
        icon = "mad_sololeveling/skills/icons/a (174).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "lumiere",
        code = function(ply)
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_fl??che5emeattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[1]_light_flash", ply:GetPos()+ply:GetForward()*75+ply:GetUp()*75, ply:GetAngles()+Angle(0,0,0), ply ) 
                ParticleEffect( "[1]_light_groundcircle", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[1]_light_sphere", ply:GetPos(), ply:GetAngles(), ply ) 
                ply:EmitSound( "mad_sfx_sololeveling/fire/040_swg_fire1.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                ply:EmitSound( "mad_sfx_sololeveling/fire/Fireball_Lava_Launch3.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 		
            end)

            timer_Simple(2, function()

                ply:EmitSound( "mad_sfx_sololeveling/light/borsalino_LightAppear01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                ply:EmitSound( "mad_sfx_sololeveling/light/borsalino_LightShining02.ogg", 85, math.random(70, 130), 1.5, CHAN_AUTO ) 	
                timer_Simple(0.7,function()	
                    ply.lumiere7:EmitSound( "mad_sfx_sololeveling/light/nami_Lightning03.ogg", 105, math.random(60, 60), 1, CHAN_AUTO ) 	
                    ply.lumiere7:EmitSound( "mad_sfx_sololeveling/light/borsalino_LightBlink01.ogg", 105, math.random(60, 60), 1, CHAN_AUTO ) 		
                end)
                timer_Simple(1.4,function()
                    ply.lumiere7:EmitSound( "mad_sfx_sololeveling/fire/Ace_Fire01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                    ply.lumiere7:EmitSound( "mad_sfx_sololeveling/fire/hong_skillW_fire.ogg", 85, math.random(70, 130), 1.5, CHAN_AUTO ) 
                end)

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()

                
            ply.lumiere7 = ents.Create("prop_dynamic")
            ply.lumiere7:SetModel("models/props_phx/construct/glass/glass_dome360.mdl")
            ply.lumiere7:SetRenderMode( RENDERMODE_TRANSCOLOR ) -- You need to set the render mode on some entities in order for the color to change
            ply.lumiere7:SetColor( Color(127,255,255,0) )
            ply.lumiere7:SetPos(ply:GetPos())
            ply.lumiere7:Spawn()

            timer_Simple(0.001,function()
                ParticleEffect( "[3]_supreme_sun_main", ply.lumiere7:GetPos(), ply.lumiere7:GetAngles(), ply ) 
            end)

            timer.Create("lumiere7Attack"..ply:SteamID64(), 0.2, 15, function()
                if not IsValid(ply.lumiere7) then timer.Remove("lumiere7Attack"..ply:SteamID64()) return end
                for k, v in ipairs( ents.FindInSphere( ply.lumiere7:GetPos(), 500 ) ) do
                    if v != ply and v != ply.lumiere7 then
                        v:TakeDamage(27+ply:GetActiveWeapon().BonusDegats, ply)
                    end
                end
            end)

            timer.Simple(3, function()
                if IsValid(ply.lumiere7) then ply.lumiere7:Remove() end
                ply:StopParticles()
            end)

            end)

        end,
    },

    ["tenebre1"] = {
        stam = 50,
        name = "Dark Ball",
        level = 2,
        icon = "mad_sololeveling/skills/icons/a (31).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "tenebre",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.5, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(20, false, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[union_dark_mage3]__projectile"}, 1500)
            end)

        end,
    },

    ["tenebre2"] = {
        stam = 100,
        name = "Dark Railgun",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (76).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "tenebre",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
            
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(7, false, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[union_dark_mage3]__projectile"}, 1500)
            end)

            timer_Simple(0.6, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(7, false, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[union_dark_mage3]__projectile"}, 1000)
            end)

            timer_Simple(0.8, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(7, false, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[union_dark_mage3]__projectile"}, 750)
            end)

        end,
    },

    ["tenebre3"] = {
        stam = 150,
        name = "Dark Tornado",
        level = 15,
        icon = "mad_sololeveling/skills/icons/a (77).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "tenebre",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquelourde3" )
            

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                ply:GetActiveWeapon():DamageLaunch(80, false, 2, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[3]_dark_tornado", "[3]_dark_tornado"}, 1250)	
            end)

        end,
    },

    ["tenebre4"] = {
        stam = 200,
        name = "Dark Eruption",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (100).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "tenebre",
        code = function(ply)
            
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_fils3emeattaque" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
            ply:EmitSound( "mad_sfx_sololeveling/fire/040_swg_fire1.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 			
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[20]_beast_feeling", ply:GetPos(), ply:GetAngles(), ply ) 
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
            ply:SetMoveType(MOVETYPE_NONE)

            timer_Simple(2,function()

                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/fire/040_swg_fire1.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                ply:EmitSound( "mad_sfx_sololeveling/fire/Fireball_Lava_Launch3.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 		

                ParticleEffect( "[tenebre]_lonelymoon", ply:GetPos()+ply:GetForward()*125, ply:GetAngles(), ply )
                util.ScreenShake(ply:GetPos()+ply:GetForward()*125, 3, 50, 0.5, 250)

                timer_Simple(0.9, function() ply:StopParticles() end)

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
                            tr.Entity:SetVelocity(aim*1500 + tr.Entity:GetUp()*350)
                        end
                    end
                end

                ply:SetMoveType(MOVETYPE_WALK)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(150, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)

        end,
    },

    ["tenebre5"] = {
        stam = 250,
        name = "Dark Zone",
        level = 25,
        icon = "mad_sololeveling/skills/icons/a (153).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "tenebre",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.4, function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                ply:EmitSound( "mad_sfx_sololeveling/water/jinbe_Water06.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                
                timer_Simple(0.001, function() 
                    ParticleEffect( "[tenebre]_moon_vortex", ply:GetPos(), ply:GetAngles(), ply ) 
                    util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
                    timer_Simple(1.4,function()
                        ply:StopParticles()
                    end)

                    for k, v in ipairs( ents.FindInSphere( ply:GetPos(), 350 ) ) do
                        if v != ply then
                            if v:IsPlayer() or v:IsNPC() or v:IsNextBot() then
                                v:TakeDamage(190+ply:GetActiveWeapon().BonusDegats, ply)
                            end
                        end
                    end
                end)

            end)

        end,
    },

    ["tenebre6"] = {
        stam = 300,
        name = "Dark Warp",
        level = 30,
        icon = "mad_sololeveling/skills/icons/magie12.png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 8,
        type = "magie",
        ismagie = true,
        element = "tenebre",
        code = function(ply)
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_filseveil" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[tenebre]_moon_vortex", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[3]_buff_aura", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[3]_dark_tornado", ply:GetPos(), ply:GetAngles(), ply ) 
                ply:EmitSound( "mad_sfx_sololeveling/fire/040_swg_fire1.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                ply:EmitSound( "mad_sfx_sololeveling/fire/Fireball_Lava_Launch3.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 					
            end)

            timer_Simple(2, function()

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[3]_dark_tornado", "[3]_dark_tornado"}, 750)
                timer_Simple(1.6,function()
                    ply:StopParticles()
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_Fire01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		

                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                    ply:EmitSound( "mad_sfx_sololeveling/fire/Ace_FireShoot02.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 			
                    ply:GetActiveWeapon():DamageLaunch(125, false, 0, false, 0, false, "", true, "mad_sfx_sololeveling/fire/Ace_FireBoom.ogg", 60, 80, false, 0, {"[3]_dark_tornado", "[3]_dark_tornado"}, 750)
                end)
            end)

        end,
    },

    ["tenebre7"] = {
        stam = 350,
        name = "Dark World",
        level = 35,
        icon = "mad_sololeveling/skills/icons/a (233).png",
        classe = {
            ["mage"] = true,
            ["sage"] = true,
            ["archi_mage"] = true,
        },
        coldown = 40,
        type = "magie",
        ismagie = true,
        element = "tenebre",
        code = function(ply)
            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:SetMoveType(MOVETYPE_NONE)

            ply:Mad_SetAnim( "mad_fl??che5emeattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

            timer_Simple(0.001, function()
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[tenebre]_moon_vortex", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[3]_buff_aura", ply:GetPos(), ply:GetAngles(), ply ) 
                ParticleEffect( "[3]_dark_tornado", ply:GetPos(), ply:GetAngles(), ply ) 
                ply:EmitSound( "mad_sfx_sololeveling/dark/blackbear_DarkOut02.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                ply:EmitSound( "mad_sfx_sololeveling/dark/blackbear_DarkOut03.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 		
            end)

            timer_Simple(2, function()

                ply:EmitSound( "mad_sfx_sololeveling/dark/blackbear_DarkOut02.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                ply:EmitSound( "mad_sfx_sololeveling/dark/blackbear_DarkOut03.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                timer_Simple(0.7,function()	
                    ply.tenebre7:EmitSound( "mad_sfx_sololeveling/dark/blackbear_DarkIn01.ogg", 105, math.random(60, 60), 1, CHAN_AUTO ) 	
                    ply.tenebre7:EmitSound( "mad_sfx_sololeveling/dark/blackbear_DarkIn02.ogg", 105, math.random(60, 60), 1, CHAN_AUTO ) 		
                end)
                timer_Simple(1.4,function()
                    ply.tenebre7:EmitSound( "mad_sfx_sololeveling/dark/blackbear_DarkExplo.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		
                    ply.tenebre7:EmitSound( "mad_sfx_sololeveling/dark/blackbear_DarkIn04.ogg", 85, math.random(70, 130), 1.5, CHAN_AUTO ) 
                end)

                ply:SetMoveType(MOVETYPE_WALK)

                ply:StopParticles()

                
            ply.tenebre7 = ents.Create("prop_dynamic")
            ply.tenebre7:SetModel("models/props_phx/construct/glass/glass_dome360.mdl")
            ply.tenebre7:SetRenderMode( RENDERMODE_TRANSCOLOR ) -- You need to set the render mode on some entities in order for the color to change
            ply.tenebre7:SetColor( Color(127,255,255,0) )
            ply.tenebre7:SetPos(ply:GetPos())
            ply.tenebre7:Spawn()

            timer_Simple(0.001,function()
                ParticleEffect( "[3]_cursed_ground", ply.tenebre7:GetPos(), ply.tenebre7:GetAngles(), ply ) 
            end)

            timer.Create("tenebre7Attack"..ply:SteamID64(), 0.5, 15, function()
                if not IsValid(ply.tenebre7) then timer.Remove("tenebre7Attack"..ply:SteamID64()) return end
                for k, v in ipairs( ents.FindInSphere( ply.tenebre7:GetPos(), 500 ) ) do
                    if v != ply and v != ply.tenebre7 then
                        v:TakeDamage(17+ply:GetActiveWeapon().BonusDegats, ply)
                    end
                end
            end)

            timer.Simple(3, function()
                if IsValid(ply.tenebre7) then ply.tenebre7:Remove() end
                ply:StopParticles()
            end)

            end)

        end,
    },

    ["assassin1"] = {
        stam = 50,
        name = "Deadly Slash",
        level = 2,
        icon = "mad_sololeveling/skills/icons/slashrapide.png",
        classe = {
            ["assassin"] = true,
            ["exécuteur"] = true,
        },
        coldown = 5,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_son6ememouvement" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(20, 65, 25)
            end)

        end,
    },

    ["assassin2"] = {
        stam = 100,
        name = "Kick Defense",
        level = 10,
        icon = "mad_sololeveling/skills/icons/attack20.png",
        classe = {
            ["assassin"] = true,
            ["exécuteur"] = true,
        },
        coldown = 5,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_sonattaquesimple2" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 65 + 50
                local radius = 65 + 20
            
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(-radius, -radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply) then
                            tr.Entity:SetMoveType(MOVETYPE_NONE)
                            timer.Simple(0.3, function()
                                tr.Entity:SetMoveType(MOVETYPE_WALK)
                            end)
                        end
                    end
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(35, 65, 35)
            end)

        end,
    },

    ["assassin3"] = {
        stam = 150,
        name = "Invisibilité",
        level = 15,
        icon = "mad_sololeveling/skills/icons/a (107).png",
        classe = {
            ["assassin"] = true,
            ["exécuteur"] = true,
        },
        coldown = 120,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)

            if not ply.Invisi == true then 

                ply:SetRenderMode(RENDERMODE_TRANSCOLOR)
    
                ply.i = 255
                ply.Invisi = true

                timer.Create("StaminaInvisi"..ply:SteamID64(), 1, 0, function()
                    ply:Mad_TakeStam(3)
                    if ply:GetStamina() <= 0 then
                        ply:DrawWorldModel( true )
                        ply:SetNoDraw( false )
                        ply:DrawShadow( true )
                        ply:SetColor(Color(255,255,255,255))
                        return
                    end
                end)
                
                timer.Create("InvisiCoagulation"..ply:SteamID(), 0.1, 25.5, function()
                    ply.i = ply.i - 10
                    if ply.i < 10 then
                        if ply.Invisi == true then
                            ply:DrawWorldModel( false )
                            ply:SetNoDraw( true )
                            ply:DrawShadow( false )
                        else
                            ply:DrawWorldModel( true )
                            ply:SetNoDraw( false )
                            ply:DrawShadow( true )
                            ply:SetColor(Color(255,255,255,255))
                        end
                        return end
                    ply:SetColor(Color(255,255,255,ply.i))
                end)
            
            end
    
        end,
    },

    ["assassin4"] = {
        stam = 200,
        name = "Accrochage",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (4).png",
        classe = {
            ["assassin"] = true,
            ["exécuteur"] = true,
        },
        coldown = 9,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_bete1ermouvement" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end

            timer_Simple(0.15,function()
                ply:GetActiveWeapon():DamageAttaque(70, 65, 35)
            end)
    
            timer_Simple(0.5,function()
                ply:SetFOV(90, 0.3)
                timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(70, 65, 35)
            end)

            timer_Simple(1.3,function()
                ply:SetFOV(90, 0.3)
                timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(10, 65, 35)
            end)

        end,
    },

    ["assassin5"] = {
        stam = 250,
        name = "Empoignement",
        level = 25,
        icon = "mad_sololeveling/skills/icons/a (1).png",
        classe = {
            ["assassin"] = true,
            ["exécuteur"] = true,
        },
        coldown = 9,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_bete2ememouvement" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() if ply:IsOnGround() then ply:SetVelocity(ply:GetForward()*500+ply:GetUp()*250) ply:ViewPunch(Angle(0, 0, 10)) end end)
            end
    
            timer_Simple(0.3,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(190, 65, 35)
            end)

        end,
    },

    ["assassin6"] = {
        stam = 300,
        name = "Quick Slash",
        level = 30,
        icon = "mad_sololeveling/skills/icons/a (140).png",
        classe = {
            ["assassin"] = true,
            ["exécuteur"] = true,
        },
        coldown = 5,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_son1ermouvement" )

            timer_Simple(0.2, function()

                local effectdata = EffectData()
                effectdata:SetOrigin( ply:GetPos() )
                effectdata:SetEntity( ply )
                util.Effect( "sl_effect1", effectdata, true, true )
    
                local effectdata = EffectData()
                effectdata:SetOrigin( ply:GetPos() )
                effectdata:SetEntity( ply )
                util.Effect( "sl_effect4", effectdata, true, true )

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
                timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

                ply:ConCommand("+forward")
                ply:ConCommand("+speed")
                ply:SetLaggedMovementValue(1.5)
            end)   
            
            timer_Simple(1, function()
                ply:ConCommand("-forward")
                ply:ConCommand("-speed")
                ply:SetLaggedMovementValue(1)

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
                timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
                timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
        
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                local effectdata = EffectData()
                effectdata:SetOrigin( ply:GetPos() )
                effectdata:SetEntity( ply )
                util.Effect( "sl_effect1", effectdata, true, true )
    
                local effectdata = EffectData()
                effectdata:SetOrigin( ply:GetPos() )
                effectdata:SetEntity( ply )
                util.Effect( "sl_effect4", effectdata, true, true )
    
                timer_Simple(0.1,function()
                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                    ply:GetActiveWeapon():DamageAttaque(250/2, 65, 35)
                    timer_Simple(0.001, function() ParticleEffect( "[2]_fog_slash_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*35, ply:GetAngles() + Angle(135,90,90), ply ) end)
                end)

                timer_Simple(0.4,function()
                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                    ply:GetActiveWeapon():DamageAttaque(250/2, 65, 35)
                    timer_Simple(0.001, function() ParticleEffect( "[2]_fog_slash_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*35, ply:GetAngles() + Angle(20,90,90), ply ) end)
                end)
            
            end)  

        end,
    },

    ["assassin7"] = {
        stam = 350,
        name = "Spin Slash",
        level = 35,
        icon = "mad_sololeveling/skills/icons/a (72).png",
        classe = {
            ["assassin"] = true,
            ["exécuteur"] = true,
        },
        coldown = 15,
        type = "dague",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_soneveil" )

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            timer.Simple(0.9, function()
                ply:GetActiveWeapon():DamageAttaque(350, 65, 35)
            end)

            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end
		
            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            local pos = ply:GetShootPos()
            local aim = ply:GetAimVector()
            local vector = 200 + 50
            local radius = 35 + 20
        
            local slash = {}
            slash.start = ply:GetShootPos()
            slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
            slash.filter = ply
            slash.mins = Vector(-radius, -radius, 0)
            slash.maxs = Vector(radius, radius, 0)
            local tr = util.TraceHull(slash)
        
            if tr.Hit then
                if IsValid(tr.Entity) then
                    if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply or IsValid(tr.Entity) and tr.Entity:IsPlayer() or IsValid(tr.Entity) and tr.Entity:IsNextBot()) then
                        timer.Simple(0.001, function() ParticleEffect("klkdash_up", ply:GetPos(), ply:GetAngles(), ply) end)
                        timer.Simple(0.002, function()
                            ply:SetPos(tr.Entity:GetPos()+tr.Entity:GetForward()*-50)
                            ply:SetEyeAngles(tr.Entity:EyeAngles())
                            tr.Entity:SetLaggedMovementValue(0.5)
                            timer.Simple(5, function()
                                tr.Entity:SetLaggedMovementValue(1)
                            end)

                            timer.Create("PoisonAttack7_Assassin".. ply:SteamID(), 0.5, 10, function()
                                tr.Entity:TakeDamage(1)
                                tr.Entity:ScreenFade( SCREENFADE.IN, Color( 127, 255, 159, 50 ), 0.3, 0 )
                            end)

                        end)
                    end
                end
            end

        end,
    },

    ["healer1"] = {
        stam = 50,
        name = "Soin",
        level = 2,
        icon = "mad_sololeveling/skills/icons/a (61).png",
        classe = {
            ["healer"] = true,
            ["pretre"] = true,
            ["pretre_de_la_déesse"] = true,
        },
        coldown = 5,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 150
                local radius = 20

                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply ) then

                            local bonushealth = ( 20 + ply:GetActiveWeapon().BonusDegats ) * ply.sl_data2["force"]/2

                            if tr.Entity:Health() < tr.Entity:GetMaxHealth() then
                                if ply.LastPlayerHit != tr.Entity then
                                    -- ply:addXP(bonushealth/10)
                                    ply:addXP(100)
                                end
                            end

                            if tr.Entity:Health() + bonushealth > tr.Entity:GetMaxHealth() then
                                tr.Entity:SetHealth(tr.Entity:GetMaxHealth())
                            else
                                tr.Entity:SetHealth(tr.Entity:Health() + bonushealth)
                            end

                            tr.Entity:EmitSound("mad_sfx_sololeveling/heal/heal4.mp3", 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
                            timer.Simple(0.001, function() ParticleEffectAttach("utaunt_glowyplayer_green_parent", 4, tr.Entity, 0) end)
                            timer.Simple(1, function()
                                tr.Entity:StopParticles()
                            end)
                        end
                    end
                end

            end)

        end,
    },

    ["healer2"] = {
        stam = 100,
        name = "Soin Extreme",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (50).png",
        classe = {
            ["healer"] = true,
            ["pretre"] = true,
            ["pretre_de_la_déesse"] = true,
        },
        coldown = 15,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 150
                local radius = 35

                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply ) then

                            local bonushealth = ( 35 + ply:GetActiveWeapon().BonusDegats ) * ply.sl_data2["force"]/2

                            if tr.Entity:Health() < tr.Entity:GetMaxHealth() then
                                if ply.LastPlayerHit != tr.Entity then
                                    -- ply:addXP(bonushealth/10)
                                    ply:addXP(100)
                                end
                            end

                            if tr.Entity:Health() + bonushealth > tr.Entity:GetMaxHealth() then
                                tr.Entity:SetHealth(tr.Entity:GetMaxHealth())
                            else
                                tr.Entity:SetHealth(tr.Entity:Health() + bonushealth)
                            end

                            tr.Entity:EmitSound("mad_sfx_sololeveling/heal/heal4.mp3", 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
                            timer.Simple(0.001, function() ParticleEffectAttach("utaunt_runeprison_green_parent", 4, tr.Entity, 0) end)
                            timer.Simple(3, function()
                                tr.Entity:StopParticles()
                            end)
                        end
                    end
                end

            end)

        end,
    },

    ["healer3"] = {
        stam = 150,
        name = "Protect",
        level = 15,
        icon = "mad_sololeveling/skills/icons/a (60).png",
        classe = {
            ["healer"] = true,
            ["pretre"] = true,
            ["pretre_de_la_déesse"] = true,
        },
        coldown = 15,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 150
                local radius = 35

                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply ) then

                            local bonushealth = ( 80 + ply:GetActiveWeapon().BonusDegats ) * ply.sl_data2["force"]/2

                            tr.Entity:GodEnable()

                            -- ply:addXP(bonushealth/10)
                            if not ply.healCooldowns then
                                ply.healCooldowns = {}
                            end

                            if CurTime() > (ply.healCooldowns[tr.Entity:SteamID()] or 0) then
                                ply.healCooldowns[tr.Entity:SteamID()] = CurTime() + 60
                                if ply.LastPlayerHit != tr.Entity then
                                    -- ply:addXP(bonushealth/10)
                                    ply:addXP(25)
                                end
                            end

                            tr.Entity:EmitSound("mad_sfx_sololeveling/heal/heal4.mp3", 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
                            timer.Simple(0.001, function() ParticleEffectAttach("utaunt_marigoldritual_blue_orbit_holder", 4, tr.Entity, 0) end)
                            timer.Simple(5, function()
                                tr.Entity:GodDisable()
                                tr.Entity:StopParticles()
                            end)
                        end
                    end
                end

            end)

        end,
    },

    ["healer4"] = {
        stam = 200,
        name = "Regeneration",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (147).png",
        classe = {
            ["healer"] = true,
            ["pretre"] = true,
            ["pretre_de_la_déesse"] = true,
        },
        coldown = 15,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 150
                local radius = 35

                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply ) then

                            local bonushealth = ( 150 + ply:GetActiveWeapon().BonusDegats ) * ply.sl_data2["force"]/2
                            
                            if tr.Entity:Health() < tr.Entity:GetMaxHealth() then
                                if ply.LastPlayerHit != tr.Entity then
                                    -- ply:addXP(bonushealth/10)
                                    ply:addXP(100)
                                end
                            end

                            timer.Create("Heal_Regeneration4"..tr.Entity:SteamID64(), 0.7, 10, function()
                                if tr.Entity:Health() + bonushealth/10 > tr.Entity:GetMaxHealth() then
                                    tr.Entity:SetHealth(tr.Entity:GetMaxHealth())
                                else
                                    tr.Entity:SetHealth(tr.Entity:Health() + bonushealth/10)
                                end
                            end)

                            tr.Entity:EmitSound("mad_sfx_sololeveling/heal/heal4.mp3", 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
                            timer.Simple(0.001, function() ParticleEffectAttach("utaunt_arcane_green_parent", 4, tr.Entity, 0) end)
                            timer.Simple(7, function()
                                tr.Entity:StopParticles()
                            end)
                        end
                    end
                end

            end)

        end,
    },

    ["healer5"] = {
        stam = 250,
        name = "Heal Zone",
        level = 25,
        icon = "mad_sololeveling/skills/icons/a (151).png",
        classe = {
            ["healer"] = true,
            ["pretre"] = true,
            ["pretre_de_la_déesse"] = true,
        },
        coldown = 30,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "amphora_splash_heal", ply:GetPos(), ply:GetAngles(), ply ) end)
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	

                for k, v in pairs(ents.FindInSphere(ply:GetPos(), 600)) do
                    if v:IsPlayer() then

                        local bonushealth = ( 190 + ply:GetActiveWeapon().BonusDegats ) * ply.sl_data2["force"]/2

                        if v:Health() < v:GetMaxHealth() then
                            if ply.LastPlayerHit != tr.Entity then
                                -- ply:addXP(bonushealth/10)
                                ply:addXP(50)
                            end
                        end

                        timer.Create("Heal_Regeneration5"..v:SteamID64(), 0.7, 10, function()
                            if v:Health() + bonushealth/20 > v:GetMaxHealth() then
                                v:SetHealth(v:GetMaxHealth())
                            else
                                v:SetHealth(v:Health() + bonushealth/20)
                            end
                        end)

                        v:EmitSound("mad_sfx_sololeveling/heal/heal4.mp3", 75, math.random(70, 130), 0.8, CHAN_AUTO)
                        timer.Simple(0.001, function() ParticleEffectAttach("utaunt_arcane_green_parent", 4, v, 0) end)
                        timer.Simple(7, function()
                            v:StopParticles()
                        end)

                    end
                end                

            end)

        end,
    },

    ["healer6"] = {
        stam = 300,
        name = "Buff Zone",
        level = 30,
        icon = "mad_sololeveling/skills/icons/a (213).png",
        classe = {
            ["healer"] = true,
            ["pretre"] = true,
            ["pretre_de_la_déesse"] = true,
        },
        coldown = 30,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fl??che5emeattaque" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()

                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
                timer_Simple(0.001, function() ParticleEffect( "amphora_splash_heal", ply:GetPos(), ply:GetAngles(), ply ) end)

                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	

                for k, v in pairs(ents.FindInSphere(ply:GetPos(), 350)) do
                    if v:IsPlayer() then

                        if v:GetActiveWeapon().BonusDegats then
                            v.BonusDegats = v:GetActiveWeapon().BonusDegats
                            v:GetActiveWeapon().BonusDegats = v.BonusDegats*1.5
                        end
                        v:SetLaggedMovementValue(1.5)

                        local bonushealth = ( 250 + ply:GetActiveWeapon().BonusDegats ) * ply.sl_data2["force"]/2

                        if v:Health() < v:GetMaxHealth() then
                            if ply.LastPlayerHit != tr.Entity then
                                -- ply:addXP(bonushealth/10)
                                ply:addXP(100)
                            end
                        end


                        timer.Create("Heal_Regeneration6"..v:SteamID64(), 0.7, 10, function()
                            if v:Health() + bonushealth/50 > v:GetMaxHealth() then
                                v:SetHealth(v:GetMaxHealth())
                            else
                                v:SetHealth(v:Health() + bonushealth/50)
                            end
                        end)

                        v:EmitSound("mad_sfx_sololeveling/heal/heal2.mp3", 75, math.random(70, 130), 0.8, CHAN_AUTO)
                        timer.Simple(0.001, function() ParticleEffectAttach("utaunt_arcane_yellow_parent", 4, v, 0) end)
                        timer.Simple(0.001, function() ParticleEffectAttach("utaunt_runeprison_teamcolor_red", 4, v, 0) end)
                        timer.Simple(0.001, function() ParticleEffectAttach("utaunt_auroraglow_orange_parent", 4, v, 0) end)
                        timer.Simple(7, function()
                            v:StopParticles()
                            if v:GetActiveWeapon().BonusDegats then
                                v:GetActiveWeapon().BonusDegats = v.BonusDegats
                            end
                            v:SetLaggedMovementValue(1)
                        end)

                    end
                end                

            end)

        end,
    },

    ["healer7"] = {
        stam = 50,
        name = "Ressurection",
        level = 35,
        icon = "mad_sololeveling/skills/icons/a (210).png",
        classe = {
            ["healer"] = true,
            ["pretre"] = true,
            ["pretre_de_la_déesse"] = true,
        },
        coldown = 50,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	

                for k, v in ipairs( ents.FindInSphere( ply:GetPos(), 1000 ) ) do
                    if IsValid(v) then
                        if (IsValid(v) and v:IsPlayer() and v != ply ) then

                            print(v:Nick())
                            if not v:Alive() then
                                v:Spawn()
                                v:SetPos(ply:GetPos() + ply:GetForward()*150)
                                ParticleEffectAttach("utaunt_hands_green_parent", 4, v, 0)
                                ParticleEffectAttach("capfx_parent", 4, v, 0)
                                v:EmitSound("mad_sfx_sololeveling/heal/heal3.mp3", 75, math.random(70, 130), 0.8, CHAN_AUTO)
                                timer_Simple(3,function()
                                    v:StopParticles()
                                    v:SetHealth(v:Health()/5)
                                end)
                            end

                        end
                    end
                end

            end)

        end,
    },

    ["invocateur1"] = {
        stam = 50,
        name = "Goblin",
        level = 2,
        icon = "mad_sololeveling/skills/icons/a (140).png",
        classe = {["invocateur"] = true},
        coldown = 5,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            local pos = ply:GetShootPos()
            local aim = ply:GetAimVector()
            local vector = 190
            local radius = 45
        
            local slash = {}
            slash.start = ply:GetShootPos()
            slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
            slash.filter = ply
            slash.mins = Vector(-radius, -radius, 0)
            slash.maxs = Vector(radius, radius, 0)
            local tr = util.TraceHull(slash)        

            ply.goblin = ents.Create("prop_dynamic")
            ply.goblin:SetMaterial("models/shiny")
            ply.goblin:SetModel("models/mad_goblin.mdl")
            ply.goblin:SetModelScale(1.5)
            ply.goblin:SetOwner(ply)
            ply.goblin:SetPos(ply:GetPos() + ply:GetForward() * 50)
            ply.goblin:SetAngles(ply:GetAngles())
            ply.goblin:Spawn()
            ply.goblin:ResetSequence("attack"..math.random(2))
            ply.goblin:SetSequence("attack"..math.random(2))
            ply.goblin:DrawShadow(false)
            ply.goblin:SetRenderMode(RENDERMODE_TRANSALPHA)
            ply.goblin:SetColor(Color(0, 0, 0, 0))

            timer.Simple(0.001, function()
                ParticleEffectAttach("utaunt_wispy_parent_g", 4, ply.goblin, 0)
            end)
 
            for i = 0, 255, 5 do
                timer.Simple(i * 0.004, function()
                    if IsValid(ply.goblin) then
                        ply.goblin:SetColor(Color(0, 0, 0, i))
                    end
                end)
            end
            
			timer.Simple(1, function()
				for i = 0, 255, 5 do
					timer.Simple(i * 0.004, function()
						if IsValid(ply.goblin) then
							ply.goblin:SetColor(Color(0, 0, 0, 255 - i))
						end
					end)
				end
				timer.Simple(1.2, function()
					if IsValid(ply.goblin) then
						ply.goblin:Remove()
					end
				end)
			end)

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply or tr.Entity:IsNPC() and IsValid(tr.Entity)) or tr.Entity:IsNextBot() and IsValid(tr.Entity) then
                            tr.Entity:TakeDamage(20+ply:GetActiveWeapon().BonusDegats, ply, ply:GetActiveWeapon())
                            tr.Entity:EmitSound(hitjoueur[math.random(1, 3)], 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
                            local torsoAttachID = tr.Entity:LookupAttachment("chest")
                            if torsoAttachID == 0 then
                                timer.Simple(0.001, function() ParticleEffect( "mudrock", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_flash_2", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_helper_3", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                            else
                                timer.Simple(0.001, function() ParticleEffectAttach("mudrock", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_flash_2", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_helper_3", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                            end
                        end
                    end
                end

            end)

        end,
    },

    ["invocateur2"] = {
        stam = 100,
        name = "Goblin Mage",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (150).png",
        classe = {["invocateur"] = true},
        coldown = 5,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply.goblinmage = ents.Create("prop_dynamic")
            ply.goblinmage:SetModel("models/mad_goblinmage.mdl")
            ply.goblinmage:SetMaterial("models/shiny")
            ply.goblinmage:SetModelScale(1.5)
            ply.goblinmage:SetOwner(ply)
            ply.goblinmage:SetPos(ply:GetPos() + ply:GetForward() * 50)
            ply.goblinmage:SetAngles(ply:GetAngles())
            ply.goblinmage:Spawn()
            ply.goblinmage:ResetSequence("attack"..math.random(2))
            ply.goblinmage:SetSequence("attack"..math.random(2))
            ply.goblinmage:DrawShadow(false)
            ply.goblinmage:SetRenderMode(RENDERMODE_TRANSALPHA)
            ply.goblinmage:SetColor(Color(0, 0, 0, 0))

            timer.Simple(0.001, function()
                ParticleEffectAttach("utaunt_wispy_parent_g", 4, ply.goblinmage, 0)
            end)

            timer.Simple(0.7, function()
                ply.goblinmage.shot = ents.Create("ent_config_launch")
                --------------------------------------------------------------------------
                ply.goblinmage.shot.Damage = ( 35 + ply:GetActiveWeapon().BonusDegats )
                ply.goblinmage.shot.Burn = true
                ply.goblinmage.shot.BurnTime = 1
                --------------------------------------------------------------------------
                ply.goblinmage.shot.Freeze = false
                ply.goblinmage.shot.FreezeTimer = 0
                ply.goblinmage.shot.HaveFreezeEffect = false
                ply.goblinmage.shot.FreezeEffect = ""
                --------------------------------------------------------------------------
                ply.goblinmage.shot.HaveHitSound = true
                ply.goblinmage.shot.HitSound = hitjoueur[math.random(1,3)]
                ply.goblinmage.shot.MinSound = 70
                ply.goblinmage.shot.MaxSound = 130
                ply.goblinmage.shot.HaveRepeat = false
                ply.goblinmage.shot.RepeatTime = 0
                --------------------------------------------------------------------------
                ply.goblinmage.shot:SetPos(ply.goblinmage:GetPos() + Vector(0,0,50) + ply.goblinmage:GetForward()*75)
                ply.goblinmage.shot:SetOwner(ply)
                ply.goblinmage.shot:SetAngles(ply.goblinmage:GetAngles())
                ply.goblinmage.shot:Spawn()
                ply.goblinmage.shot:GetPhysicsObject():EnableMotion(true)
                ply.goblinmage.shot:SetRenderMode( RENDERMODE_TRANSCOLOR )
                ply.goblinmage.shot:SetColor(Color(0,0,0,0))
                ply.goblinmage.shot:SetModel("models/hunter/misc/sphere175x175.mdl")
    
                timer.Simple(0.001, function()
                    ParticleEffectAttach("[1]_fire_goblinmage_projectile", 4, ply.goblinmage.shot, 0)
                end)
    
                local phys = ply.goblinmage.shot:GetPhysicsObject()
                phys:EnableGravity(false)
                phys:SetVelocity( ply.goblinmage.shot:GetForward() * 750 )
            end)

            timer.Simple(0.001, function()
                ParticleEffectAttach("utaunt_wispy_parent_g", 4, ply.goblin, 0)
            end)
 
            for i = 0, 255, 5 do
                timer.Simple(i * 0.004, function()
                    if IsValid(ply.goblinmage) then
                        ply.goblinmage:SetColor(Color(0, 0, 0, i))
                    end
                end)
            end
            
			timer.Simple(1, function()
				for i = 0, 255, 5 do
					timer.Simple(i * 0.004, function()
						if IsValid(ply.goblinmage) then
							ply.goblinmage:SetColor(Color(0, 0, 0, 255 - i))
						end
					end)
				end
				timer.Simple(1.2, function()
					if IsValid(ply.goblinmage) then
						ply.goblinmage:Remove()
					end
				end)
			end)

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
            end)

        end,
    },

    ["invocateur3"] = {
        stam = 150,
        name = "Wolf",
        level = 15,
        icon = "mad_sololeveling/skills/icons/a (30).png",
        classe = {["invocateur"] = true},
        coldown = 5,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            local pos = ply:GetShootPos()
            local aim = ply:GetAimVector()
            local vector = 190
            local radius = 45
        
            local slash = {}
            slash.start = ply:GetShootPos()
            slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
            slash.filter = ply
            slash.mins = Vector(-radius, -radius, 0)
            slash.maxs = Vector(radius, radius, 0)
            local tr = util.TraceHull(slash)      

            ply.wolf = ents.Create("prop_dynamic")
            ply.wolf:SetMaterial("models/shiny")
            ply.wolf:SetModel("models/mad_loupevo.mdl")
            ply.wolf:SetModelScale(1.5)
            ply.wolf:SetOwner(ply)
            ply.wolf:SetPos(ply:GetPos() + ply:GetForward() * 125)
            ply.wolf:SetAngles(ply:GetAngles())
            ply.wolf:Spawn()
            ply.wolf:ResetSequence("attack"..math.random(2))
            ply.wolf:SetSequence("attack"..math.random(2))
            ply.wolf:DrawShadow(false)
            ply.wolf:SetRenderMode(RENDERMODE_TRANSALPHA)
            ply.wolf:SetColor(Color(0, 0, 0, 0))

            timer.Simple(0.001, function()
                ParticleEffectAttach("utaunt_wispy_parent_g", 4, ply.wolf, 0)
            end)
 
            for i = 0, 255, 5 do
                timer.Simple(i * 0.004, function()
                    if IsValid(ply.wolf) then
                        ply.wolf:SetColor(Color(0, 0, 0, i))
                    end
                end)
            end
            
			timer.Simple(1, function()
				for i = 0, 255, 5 do
					timer.Simple(i * 0.004, function()
						if IsValid(ply.wolf) then
							ply.wolf:SetColor(Color(0, 0, 0, 255 - i))
						end
					end)
				end
				timer.Simple(1.2, function()
					if IsValid(ply.wolf) then
						ply.wolf:Remove()
					end
				end)
			end)

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply or tr.Entity:IsNPC() and IsValid(tr.Entity)) or tr.Entity:IsNextBot() and IsValid(tr.Entity) then
                            tr.Entity:TakeDamage(80+ply:GetActiveWeapon().BonusDegats, ply, ply:GetActiveWeapon())
                            tr.Entity:EmitSound(hitjoueur[math.random(1, 3)], 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
                            local torsoAttachID = tr.Entity:LookupAttachment("chest")
                            if torsoAttachID == 0 then
                                timer.Simple(0.001, function() ParticleEffect( "mudrock", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_flash_2", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_helper_3", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                            else
                                timer.Simple(0.001, function() ParticleEffectAttach("mudrock", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_flash_2", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_helper_3", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                            end
                        end
                    end
                end
                
            end)

        end,
    },

    ["invocateur4"] = {
        stam = 200,
        name = "Undead",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (256).png",
        classe = {["invocateur"] = true},
        coldown = 5,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            local pos = ply:GetShootPos()
            local aim = ply:GetAimVector()
            local vector = 190
            local radius = 45
        
            local slash = {}
            slash.start = ply:GetShootPos()
            slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
            slash.filter = ply
            slash.mins = Vector(-radius, -radius, 0)
            slash.maxs = Vector(radius, radius, 0)
            local tr = util.TraceHull(slash)      

            ply.undead = ents.Create("prop_dynamic")
            ply.undead:SetMaterial("models/shiny")
            ply.undead:SetModel("models/mad_undeadmob.mdl")
            ply.undead:SetModelScale(1.5)
            ply.undead:SetOwner(ply)
            ply.undead:SetPos(ply:GetPos() + ply:GetForward() * 85)
            ply.undead:SetAngles(ply:GetAngles())
            ply.undead:Spawn()
            ply.undead:ResetSequence("attack"..math.random(2))
            ply.undead:SetSequence("attack"..math.random(2))
            ply.undead:DrawShadow(false)
            ply.undead:SetRenderMode(RENDERMODE_TRANSALPHA)
            ply.undead:SetColor(Color(0, 0, 0, 0))

            timer.Simple(0.001, function()
                ParticleEffectAttach("utaunt_wispy_parent_g", 4, ply.undead, 0)
            end)
 
            for i = 0, 255, 5 do
                timer.Simple(i * 0.004, function()
                    if IsValid(ply.undead) then
                        ply.undead:SetColor(Color(0, 0, 0, i))
                    end
                end)
            end
            
			timer.Simple(1, function()
				for i = 0, 255, 5 do
					timer.Simple(i * 0.004, function()
						if IsValid(ply.undead) then
							ply.undead:SetColor(Color(0, 0, 0, 255 - i))
						end
					end)
				end
				timer.Simple(1.2, function()
					if IsValid(ply.undead) then
						ply.undead:Remove()
					end
				end)
			end)

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply or tr.Entity:IsNPC() and IsValid(tr.Entity)) or tr.Entity:IsNextBot() and IsValid(tr.Entity) then
                            tr.Entity:TakeDamage(150+ply:GetActiveWeapon().BonusDegats, ply, ply:GetActiveWeapon())
                            tr.Entity:EmitSound(hitjoueur[math.random(1, 3)], 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
                            local torsoAttachID = tr.Entity:LookupAttachment("chest")
                            if torsoAttachID == 0 then
                                timer.Simple(0.001, function() ParticleEffect( "mudrock", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_flash_2", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_helper_3", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                            else
                                timer.Simple(0.001, function() ParticleEffectAttach("mudrock", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_flash_2", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_helper_3", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                            end
                        end
                    end
                end

                local vector = 150
                local radius = 45
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if not tr.Entity:IsPlayer() and tr.Entity == ply then return end
                        timer.Create("PoisonDamageInvoc".. ply:SteamID64(), 0.2, 10, function()
                            -- if not tr.Entity:Alive() then return end
                            tr.Entity:TakeDamage(5)
                        end)
                    end
                end
                
            end)

        end,
    },

    ["invocateur5"] = {
        stam = 250,
        name = "Undead King",
        level = 25,
        icon = "mad_sololeveling/skills/icons/a (257).png",
        classe = {["invocateur"] = true},
        coldown = 5,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            local pos = ply:GetShootPos()
            local aim = ply:GetAimVector()
            local vector = 400
            local radius = 60
        
            local slash = {}
            slash.start = ply:GetShootPos()
            slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
            slash.filter = ply
            slash.mins = Vector(-radius, -radius, 0)
            slash.maxs = Vector(radius, radius, 0)
            local tr = util.TraceHull(slash)      

            ply.undeadking = ents.Create("prop_dynamic")
            ply.undeadking:SetMaterial("models/shiny")
            ply.undeadking:SetModel("models/mad_undeadboss.mdl")
            ply.undeadking:SetModelScale(1.5)
            ply.undeadking:SetOwner(ply)
            ply.undeadking:SetPos(ply:GetPos() + ply:GetForward() * 85)
            ply.undeadking:SetAngles(ply:GetAngles())
            ply.undeadking:Spawn()
            ply.undeadking:ResetSequence("attack"..math.random(2))
            ply.undeadking:SetSequence("attack"..math.random(2))
            ply.undeadking:DrawShadow(false)
            ply.undeadking:SetRenderMode(RENDERMODE_TRANSALPHA)
            ply.undeadking:SetColor(Color(0, 0, 0, 0))

            timer.Simple(0.001, function()
                ParticleEffectAttach("utaunt_wispy_parent_g", 4, ply.undeadking, 0)
            end)
 
            for i = 0, 255, 5 do
                timer.Simple(i * 0.004, function()
                    if IsValid(ply.undeadking) then
                        ply.undeadking:SetColor(Color(0, 0, 0, i))
                    end
                end)
            end
            
			timer.Simple(1, function()
				for i = 0, 255, 5 do
					timer.Simple(i * 0.004, function()
						if IsValid(ply.undeadking) then
							ply.undeadking:SetColor(Color(0, 0, 0, 255 - i))
						end
					end)
				end
				timer.Simple(1.2, function()
					if IsValid(ply.undeadking) then
						ply.undeadking:Remove()
					end
				end)
			end)

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.9,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/punch/sakazuki_LavaPunch01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply or tr.Entity:IsNPC() and IsValid(tr.Entity)) or tr.Entity:IsNextBot() and IsValid(tr.Entity) then
                            tr.Entity:TakeDamage(190+ply:GetActiveWeapon().BonusDegats, ply, ply:GetActiveWeapon())
                            tr.Entity:EmitSound(hitjoueur[math.random(1, 3)], 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
                            local torsoAttachID = tr.Entity:LookupAttachment("chest")
                            if torsoAttachID == 0 then
                                timer.Simple(0.001, function() ParticleEffect( "mudrock", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_flash_2", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_helper_3", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                            else
                                timer.Simple(0.001, function() ParticleEffectAttach("mudrock", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_flash_2", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_helper_3", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                            end
                        end
                    end
                end

                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
                ParticleEffect( "[union]_rock_smash", ply.undeadking:GetPos()+ply:GetForward()*200, ply.undeadking:GetAngles() )

                local vector = 150
                local radius = 45
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if not tr.Entity:IsPlayer() and tr.Entity == ply then return end
                        timer.Create("PoisonDamageInvoc2".. ply:SteamID64(), 0.2, 10, function()
                            -- if not tr.Entity:Alive() then return end
                            tr.Entity:TakeDamage(25)
                        end)
                    end
                end
                
            end)

        end,
    },

    ["invocateur6"] = {
        stam = 250,
        name = "Werewolf King",
        level = 30,
        icon = "mad_sololeveling/skills/icons/a (79).png",
        classe = {["invocateur"] = true},
        coldown = 5,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            local pos = ply:GetShootPos()
            local aim = ply:GetAimVector()
            local vector = 400
            local radius = 60
        
            local slash = {}
            slash.start = ply:GetShootPos()
            slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
            slash.filter = ply
            slash.mins = Vector(-radius, -radius, 0)
            slash.maxs = Vector(radius, radius, 0)
            local tr = util.TraceHull(slash)      

            ply.werewolfking = ents.Create("prop_dynamic")
            ply.werewolfking:SetMaterial("models/shiny")
            ply.werewolfking:SetModel("models/mad_werewolfboss.mdl")
            ply.werewolfking:SetModelScale(1.5)
            ply.werewolfking:SetOwner(ply)
            ply.werewolfking:SetPos(ply:GetPos() + ply:GetForward() * 85)
            ply.werewolfking:SetAngles(ply:GetAngles())
            ply.werewolfking:Spawn()
            ply.werewolfking:ResetSequence("attack"..math.random(2))
            ply.werewolfking:SetSequence("attack"..math.random(2))
            ply.werewolfking:DrawShadow(false)
            ply.werewolfking:SetRenderMode(RENDERMODE_TRANSALPHA)
            ply.werewolfking:SetColor(Color(0, 0, 0, 0))

            timer.Simple(0.001, function()
                ParticleEffectAttach("utaunt_wispy_parent_g", 4, ply.werewolfking, 0)
            end)
 
            for i = 0, 255, 5 do
                timer.Simple(i * 0.004, function()
                    if IsValid(ply.werewolfking) then
                        ply.werewolfking:SetColor(Color(0, 0, 0, i))
                    end
                end)
            end
            
			timer.Simple(1, function()
				for i = 0, 255, 5 do
					timer.Simple(i * 0.004, function()
						if IsValid(ply.werewolfking) then
							ply.werewolfking:SetColor(Color(0, 0, 0, 255 - i))
						end
					end)
				end
				timer.Simple(1.2, function()
					if IsValid(ply.werewolfking) then
						ply.werewolfking:Remove()
					end
				end)
			end)

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.4,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/punch/sakazuki_LavaPunch01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply or tr.Entity:IsNPC() and IsValid(tr.Entity)) or tr.Entity:IsNextBot() and IsValid(tr.Entity) then
                            tr.Entity:TakeDamage(190+ply:GetActiveWeapon().BonusDegats, ply, ply:GetActiveWeapon())
                            tr.Entity:EmitSound(hitjoueur[math.random(1, 3)], 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
                            local torsoAttachID = tr.Entity:LookupAttachment("chest")
                            if torsoAttachID == 0 then
                                timer.Simple(0.001, function() ParticleEffect( "mudrock", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_flash_2", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_helper_3", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                            else
                                timer.Simple(0.001, function() ParticleEffectAttach("mudrock", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_flash_2", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_helper_3", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                            end
                        end
                    end
                end

                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
                ParticleEffect( "[union]_rock_smash", ply.werewolfking:GetPos()+ply:GetForward()*200, ply.werewolfking:GetAngles() )

                local vector = 150
                local radius = 45
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if not tr.Entity:IsPlayer() and tr.Entity == ply then return end
                        timer.Create("PoisonDamageInvoc3".. ply:SteamID64(), 0.2, 10, function()
                            -- if not tr.Entity:Alive() then return end
                            tr.Entity:TakeDamage(25)
                        end)
                    end
                end
                
            end)

        end,
    },

    ["invocateur7"] = {
        stam = 250,
        name = "Centipede",
        level = 35,
        icon = "mad_sololeveling/skills/icons/a (94).png",
        classe = {["invocateur"] = true},
        coldown = 5,
        type = "magie",
        ismagie = false,
        element = "none",
        code = function(ply)

            local pos = ply:GetShootPos()
            local aim = ply:GetAimVector()
            local vector = 400
            local radius = 60
        
            local slash = {}
            slash.start = ply:GetShootPos()
            slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
            slash.filter = ply
            slash.mins = Vector(-radius, -radius, 0)
            slash.maxs = Vector(radius, radius, 0)
            local tr = util.TraceHull(slash)      

            ply.centipede = ents.Create("prop_dynamic")
            ply.centipede:SetMaterial("models/shiny")
            ply.centipede:SetModel("models/mad_centipedeboss.mdl")
            ply.centipede:SetModelScale(1.5)
            ply.centipede:SetOwner(ply)
            ply.centipede:SetPos(ply:GetPos() + ply:GetForward() * 85)
            ply.centipede:SetAngles(ply:GetAngles())
            ply.centipede:Spawn()
            ply.centipede:ResetSequence("attack"..math.random(2))
            ply.centipede:SetSequence("attack"..math.random(2))
            ply.centipede:DrawShadow(false)
            ply.centipede:SetRenderMode(RENDERMODE_TRANSALPHA)
            ply.centipede:SetColor(Color(0, 0, 0, 0))

            timer.Simple(0.001, function()
                ParticleEffectAttach("utaunt_wispy_parent_g", 4, ply.centipede, 0)
            end)
 
            for i = 0, 255, 5 do
                timer.Simple(i * 0.004, function()
                    if IsValid(ply.centipede) then
                        ply.centipede:SetColor(Color(0, 0, 0, i))
                    end
                end)
            end
            
			timer.Simple(1, function()
				for i = 0, 255, 5 do
					timer.Simple(i * 0.004, function()
						if IsValid(ply.centipede) then
							ply.centipede:SetColor(Color(0, 0, 0, 255 - i))
						end
					end)
				end
				timer.Simple(1.2, function()
					if IsValid(ply.centipede) then
						ply.centipede:Remove()
					end
				end)
			end)

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)
    
            timer_Simple(0.4,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:EmitSound( "mad_sfx_sololeveling/punch/sakazuki_LavaPunch01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 

                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply or tr.Entity:IsNPC() and IsValid(tr.Entity)) or tr.Entity:IsNextBot() and IsValid(tr.Entity) then
                            tr.Entity:TakeDamage(190+ply:GetActiveWeapon().BonusDegats, ply, ply:GetActiveWeapon())
                            tr.Entity:EmitSound(hitjoueur[math.random(1, 3)], 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
                            local torsoAttachID = tr.Entity:LookupAttachment("chest")
                            if torsoAttachID == 0 then
                                timer.Simple(0.001, function() ParticleEffect( "mudrock", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_flash_2", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                                timer.Simple(0.001, function() ParticleEffect( "slashhit_helper_3", tr.Entity:GetPos()+tr.Entity:GetUp()*40, Angle(0,0,0), tr.Entity ) end)
                            else
                                timer.Simple(0.001, function() ParticleEffectAttach("mudrock", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_flash_2", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                                timer.Simple(0.001, function() ParticleEffectAttach("slashhit_helper_3", PATTACH_POINT_FOLLOW, tr.Entity, torsoAttachID) end)
                            end
                        end
                    end
                end

                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
                ParticleEffect( "[union]_rock_smash", ply.centipede:GetPos()+ply:GetForward()*200, ply.centipede:GetAngles() )

                local vector = 150
                local radius = 45
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if not tr.Entity:IsPlayer() and tr.Entity == ply then return end
                        ParticleEffectAttach("utaunt_spider_green_parent", 4, tr.Entity, 0)
                        timer.Simple(2, function()
                            tr.Entity:StopParticles()
                        end)
                        timer.Create("PoisonDamageInvoc3".. ply:SteamID64(), 0.2, 10, function()
                            -- if not tr.Entity:Alive() then return end
                            tr.Entity:TakeDamage(25)
                        end)
                    end
                end
                
            end)

        end,
    },

    ["bestial1"] = {
        stam = 50,
        name = "Attaque Rapide",
        level = 2,
        icon = "mad_sololeveling/skills/icons/a (29).png",
        classe = {["bestial"] = true},
        coldown = 5,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fl??cheattaquesimple2" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
                timer_Simple(0.001, function() ParticleEffect( "[2]_fog_slash_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*35, ply:GetAngles() + Angle(30,90,90), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(20, 65, 25)
            end)

        end,
    },

    ["bestial2"] = {
        stam = 100,
        name = "Enchainement",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (225).png",
        classe = {["bestial"] = true},
        coldown = 5,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)
    
            ply:Mad_SetAnim( "mad_fl??cheattaquelourde1" )
            
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO )
            
            ply:GetActiveWeapon():DamageAttaque(25/2, 65, 35)
            
            timer_Simple(0.001, function() ParticleEffect( "[2]_fog_slash_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*35, ply:GetAngles() + Angle(-30,90,90), ply ) end)
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
                timer_Simple(0.001, function() ParticleEffect( "[2]_fog_slash_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*35, ply:GetAngles() + Angle(30,90,90), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(25/2, 65, 35)
            end)
    
        end,
    },

    ["bestial3"] = {
        stam = 150,
        name = "Slam",
        level = 15,
        icon = "mad_sololeveling/skills/icons/a (340).png",
        classe = {["bestial"] = true},
        coldown = 5,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_tambourattaquelourde1" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				

            timer_Simple(0.001, function() 
                ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) 
            end)

            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end
    
            timer_Simple(0.4,function()
                ply:EmitSound( "mad_sfx_sololeveling/punch/sakazuki_LavaPunch01.ogg", 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(80, 65, 35)

                ParticleEffect( "[union]_rock_smash", ply:GetPos()+ply:GetForward()*75, ply:GetAngles() )
            end)

        end,
    },

    ["bestial4"] = {
        stam = 200,
        name = "Ravage",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (318).png",
        classe = {["bestial"] = true},
        coldown = 9,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_soryu4emeattaque" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end

            timer_Simple(0.15,function()
                ply:GetActiveWeapon():DamageAttaque(75, 65, 35)
            end)
    
            timer_Simple(0.8,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                ply:GetActiveWeapon():DamageAttaque(75/6, 65, 35)	

                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end

                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
                timer.Create("Bestial4Atk".. ply:SteamID(), 0.15, 5, function()
                    timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
                    ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
                    ply:GetActiveWeapon():DamageAttaque(75/6, 65, 35)

                    if ply:IsOnGround() then
                        timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                    end

                end)
            end)

        end,
    },

    ["bestial5"] = {
        stam = 250,
        name = "Eye Attack",
        level = 25,
        icon = "mad_sololeveling/skills/icons/a (278).png",
        classe = {["bestial"] = true},
        coldown = 9,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_rui_a_p1007_v00_c00_atkcmbw02" )
            
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
            ply:GetActiveWeapon():DamageAttaque(190/2, 65, 35)				

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
            timer_Simple(0.1, function() ParticleEffect( "[2]_fog_slash_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*35, ply:GetAngles() + Angle(130,90,90), ply ) end)
            timer_Simple(0.2, function() ParticleEffect( "[2]_fog_slash_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*35, ply:GetAngles() + Angle(40,90,90), ply ) end)

            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end
    
            timer_Simple(0.2,function()
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end

                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(190/2, 65, 35)

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 65 + 50
                local radius = 35 + 20
            
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(-radius, -radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply) then
                            tr.Entity:ScreenFade( SCREENFADE.IN, Color( 0, 0, 0, 255 ), 5, 1 )
                            ply:ChatPrint("[UNION] Vous avez aveuglé quelqu'un" )
                            ply:ChatPrint("[UNION] La cible possède actuellement : ".. tr.Entity:Health() .. " HP" )
                        end
                    end
                end

               
            end)

        end,
    },

    ["bestial6"] = {
        stam = 300,
        name = "Shockwave",
        level = 30,
        icon = "mad_sololeveling/skills/icons/a (320).png",
        classe = {["bestial"] = true},
        coldown = 60,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_soryueveil" )

            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 		

            ply:SetMoveType(MOVETYPE_NONE)

            timer_Simple(1, function()
                ply:EmitSound( "mad_sfx_sololeveling/bestial/roar2.mp3", 100, math.random(70, 80), 0.8, CHAN_AUTO ) 
            end)

            timer_Simple(1.2,function()
                timer_Simple(0.001, function() ParticleEffect( "dust_conquer_charge", ply:GetPos(), ply:GetAngles(), ply ) end)
                timer_Simple(0.001, function() ParticleEffect( "dust_sharp_shockwave", ply:GetPos(), ply:GetAngles(), ply ) end)
                timer_Simple(0.001, function() ParticleEffect( "auraburst_sharp", ply:GetPos(), ply:GetAngles(), ply ) end)
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)

                for k, v in ipairs( ents.FindInSphere( ply:GetPos(), 500 ) ) do
                    if v:IsPlayer() and v != ply then
                        v:Mad_SetAnim("mad_eaufear")
                        v:Freeze(true)
                        v:ChatPrint("[UNION] Vous êtes paralysé de peur.")
                        v:ViewPunch(Angle(0, 0, 50))
                        timer.Simple(4.3, function()
                            v:Freeze(false)
                        end)
                    elseif v:IsNPC() or v:IsNextBot() then
                        v:TakeDamage(250)
                    end
                end

            end)
            
            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)
            end

            timer_Simple(2, function()
                ply:SetMoveType(MOVETYPE_WALK)
            end)

        end,
    },

    ["bestial7"] = {
        stam = 350,
        name = "Earth Shock",
        level = 35,
        icon = "mad_sololeveling/skills/icons/a (315).png",
        classe = {["bestial"] = true},
        coldown = 10,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            ply:Mad_SetAnim( "mad_soryu6emeattaque" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO )

            util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 150)
            timer_Simple(0.001, function() ParticleEffect( "dust_conquer_charge", ply:GetPos(), ply:GetAngles(), ply ) end)
            timer_Simple(0.001, function() ParticleEffect( "dust_sharp_shockwave", ply:GetPos(), ply:GetAngles(), ply ) end)
            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)

            timer_Simple(0.1, function() ply:ViewPunch(Angle(0, 0, 10)) end)

            timer_Simple(0.5, function() 
                ply:StopParticles()
            end)


            timer_Simple(0.7,function()

                ParticleEffect( "[bestial]_forward_dash", ply:GetPos()+Vector(0,0,15), ply:GetAngles() + Angle(0,0,0), ply ) 
                ply:ViewPunch(Angle(0, 0, 30))
                ply:EmitSound( "mad_sfx_sololeveling/normal/Punch_Explosion_02.ogg", 105, math.random(70, 130), 0.8, CHAN_AUTO ) 				

                for i=1,5 do 
                    
                    ParticleEffect( "[union]_rock_smash", ply:GetPos()+ply:GetForward()*75*i, ply:GetAngles() )
                    util.ScreenShake(ply:GetPos()+ply:GetForward()*75*i, 3, 50, 0.5, 250)

                end

                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 35
        
                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
                            tr.Entity:SetVelocity(aim*1500 + tr.Entity:GetUp()*350)
                        end
                    end
                end

                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(400, 350, 35)
                util.ScreenShake(ply:GetPos(), 3, 50, 0.5, 250)
            end)

        end,
    },

    ["vampire1"] = {
        stam = 50,
        name = "Aura Vampirique",
        level = 2,
        icon = "mad_sololeveling/skills/icons/a (29).png",
        classe = {["vampire"] = true},
        coldown = 30,
        type = "faux",
        ismagie = false,
        element = "none",
        code = function(ply)
    
            timer_Simple(0.1,function()
                ParticleEffectAttach( "[SL-NW]AuraSanglante", 4, ply, 0 )
                ply:SetNWBool("Aura_vampire",true)
                
                timer_Simple(10,function()
                    ply:SetNWBool("Aura_vampire",false)
                    ply:StopParticles()
                end)
            end)

        end,
    },
    ["vampire2"] = {
        stam = 100,
        name = "Faux de Sang",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (29).png",
        classe = {["vampire"] = true},
        coldown = 10,
        type = "faux",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fl??cheattaquesimple2" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
    
            timer_Simple(0.2,function()
    
                timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
                -- timer_Simple(0.001, function() ParticleEffect( "[16]_projectile_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*150, ply:GetAngles() + Angle(30,90,90), ply ) end)
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(20, 65, 25)
                BuLifeSteal(ply,0.3,ply:GetActiveWeapon().BonusDegats,100)
                timer_Simple(1.5, function()
                    ply:StopParticles()
                end)
            end)

        end,
    },
    ["vampire3"]= {
        stam = 150,
        name = "Lance sanguinaire",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (28).png",
        classe = {["vampire"] = true},
        coldown = 10,
        type = "faux",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
            ply:StopParticles()	
            ply.shot = ents.Create("ent_config_launch")
            ply.shot.Damage = 200
            ply.shot:SetPos(ply:GetPos() + Vector(0,0,50) + ply:GetForward()*60)
            ply.shot:SetOwner(ply)
            ply.shot:SetAngles(ply:EyeAngles())
            ply.shot:Spawn()
            ply.shot:GetPhysicsObject():EnableMotion(true)
            ply.shot:SetRenderMode( RENDERMODE_TRANSCOLOR )
            ply.shot:SetColor(Color(0,0,0,0))
            ply.shot:SetModel("models/hunter/misc/sphere175x175.mdl")
            BuLifeSteal(ply,0.3,ply:GetActiveWeapon().BonusDegats,100)
            timer_Simple(0.0001, function()
                ParticleEffectAttach("[SL-NW]LanceSanglante", 4, ply.shot, 0)
            end)
        
            local phys = ply.shot:GetPhysicsObject()
            phys:EnableGravity(false)
            phys:SetVelocity( ply.shot:GetForward() * 500 )
            timer.Simple(1.5, function()
                if IsValid(ply.shot) then
                    ply.shot:Remove()
                end
            end)
        end,
    },

    ["moine1"]= {
        stam = 50,
        name = "Priere",
        level = 5,
        icon = "mad_sololeveling/skills/icons/a (29).png",
        classe = {["moine"] = true},
        coldown = 10,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
    
            timer_Simple(0.2,function()
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 10

                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply ) then

                            local bonushealth = ( 75  * ply.sl_data2["force"])/2
                            ply:SetRunSpeed(1)
                            ply:SetWalkSpeed(1)
                            if tr.Entity:Health() < tr.Entity:GetMaxHealth() then
                                if ply.LastPlayerHit != tr.Entity then
                                    -- ply:addXP(bonushealth/10)
                                    ply:addXP(100)
                                end
                            end

                            if tr.Entity:Health() + bonushealth > tr.Entity:GetMaxHealth() then
                                tr.Entity:SetHealth(tr.Entity:GetMaxHealth())
                            else
                                tr.Entity:SetHealth(tr.Entity:Health() + bonushealth)
                            end

                            tr.Entity:EmitSound("mad_sfx_sololeveling/heal/heal4.mp3", 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
                            timer.Simple(0.001, function() ParticleEffectAttach("[NW]MoineHeal", 4, ply, 0) end)
                            timer.Simple(0.001, function() ParticleEffectAttach("[NW]MoinePuri", 4, tr.Entity, 0) end)
                            timer.Simple(3, function()
                                ply:SetWalkSpeed(160)
                                ply:SetRunSpeed(ply.Runspeed)
                                tr.Entity:StopParticles()
                                ply:StopParticles()
                            end)
                        end
                    end
                end
            end)

        end,
    },
    ["moine2"]= {
        stam = 100,
        name = "Priére de Force",
        level = 10,
        icon = "mad_sololeveling/skills/icons/a (29).png",
        classe = {["moine"] = true},
        coldown = 30,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
    
            timer_Simple(0.2,function()
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 10

                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply ) then

                            tr.Entity.bonusDGT = 1.3
                            timer.Simple(0.001, function() ParticleEffectAttach("[NW]MoineDGT", 4, ply, 0) end)
                            timer.Simple(0.001, function() ParticleEffectAttach("[NW]MoineBoostDGT", 4, tr.Entity, 0) end)
                            timer.Simple(3, function()
                                ply:StopParticles()
                            end)
                            timer.Simple(10, function()
                                tr.Entity:StopParticles()
                                tr.Entity.bonusDGT = nil
                            end)

                            tr.Entity:EmitSound("mad_sfx_sololeveling/heal/heal4.mp3", 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
          
                        end
                    end
                end
            end)

        end,
    },
    ["moine3"]= {
        stam = 150,
        name = "Priére de Resistance",
        level = 15,
        icon = "mad_sololeveling/skills/icons/a (29).png",
        classe = {["moine"] = true},
        coldown = 30,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_filsattaquesimple1" )
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
    
            timer_Simple(0.2,function()
    
                if ply:IsOnGround() then
                    timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
                end
    
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                
                local pos = ply:GetShootPos()
                local aim = ply:GetAimVector()
                local vector = 350
                local radius = 10

                local slash = {}
                slash.start = ply:GetShootPos()
                slash.endpos = ply:GetShootPos() + (ply:GetAimVector() * vector)
                slash.filter = ply
                slash.mins = Vector(- radius, - radius, 0)
                slash.maxs = Vector(radius, radius, 0)
                local tr = util.TraceHull(slash)
            
                if tr.Hit then
                    if IsValid(tr.Entity) then
                        if (IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity != ply ) then

                            tr.Entity.bonusREST = 0.8
                            timer.Simple(0.001, function() ParticleEffectAttach("[NW]MoineResistance", 4, ply, 0) end)
                            timer.Simple(0.001, function() ParticleEffectAttach("[NW]MoineBoostRST", 4, tr.Entity, 0) end)
                            timer.Simple(3, function()
                                ply:StopParticles()
                            end)
                            timer.Simple(10, function()
                                tr.Entity:StopParticles()
                                tr.Entity.bonusREST = nil
                            end)

                            tr.Entity:EmitSound("mad_sfx_sololeveling/heal/heal4.mp3", 75, math.random(70, 130), 0.8, CHAN_AUTO)
                            util.ScreenShake(pos, 3, 50, 0.5, 150)
          
                        end
                    end
                end
            end)

        end,
    },
    ["moine4"]= {
        stam = 200,
        name = "Frappe Divine",
        level = 20,
        icon = "mad_sololeveling/skills/icons/a (29).png",
        classe = {["moine"] = true},
        coldown = 50,
        type = "corpsacorps",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_fils1erattaque" )
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 
            timer.Simple(0.001, function() ParticleEffectAttach("[NW]MoineFrappeDivine", 4, ply, 7) end)

            timer_Simple(1.5, function()
                ply:StopParticles()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO )
                timer_Simple(0.0001, function()
                    ParticleEffect("[NW]MoinePunch",ply:GetPos() + ply:GetUp() * 45, ply:GetAngles(), ply)
                end)
                ply:GetActiveWeapon():DamageAttaque(80, 400, 60)
            end)
        end,
    },
    
    ["chevalier1"] = {
        stam = 50,
        name = "Revers de Lame",
        level = 5,
        icon = "mad_sololeveling/skills/icons/attack17.png",
        classe = {
            ["chevalier"] = true,
        },
        coldown = 5,
        type = "sword",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_soleilattaquelourde3" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end
    
            timer_Simple(0.5,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(80, 65, 35)
            end)

        end,
    },
    ["chevalier2"] = {
        stam = 100,
        name = "Protection",
        level = 10,
        icon = "mad_sololeveling/skills/icons/tank2.png",
        classe = {
            ["chevalier"] = true,
        },
        coldown = 10,
        type = "sword",
        ismagie = false,
        element = "none",
        code = function(ply)

            

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "tank_buff", effectdata, true, true )

            timer_Simple(0.0001, function()
                ply:SetNWBool("BuffTank", true)
                util.ScreenShake( ply:GetPos(), 3, 50, 0.5, 150 )
                ply:EmitSound( dash_sfx, 75, math.random(90, 100), 1.7, CHAN_AUTO )  
            end)
    
            timer_Simple(6, function()
                ply:SetNWBool("BuffTank", false)
                hook.Remove("EntityTakeDamage", "BuffTank"..ply:SteamID())
            end)
    
            hook.Add("EntityTakeDamage", "BuffTank"..ply:SteamID(), function(target, dmginfo) 
                if target:IsPlayer() and target:GetNWBool("BuffTank") == true then
                    dmginfo:ScaleDamage( 0.5 ) // Damage is now half of what you would normally take.
                end
            end)

        end,
    },
    ["chevalier3"] = {
        stam = 150,
        name = "Tempête",
        level = 15,
        icon = "mad_sololeveling/skills/icons/attack14.png",
        classe = {
            ["chevalier"] = true,
        },
        coldown = 9,
        type = "sword",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_flammeattaquelourde3" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end

            timer_Simple(0.15,function()
                ply:GetActiveWeapon():DamageAttaque(75, 65, 35)
            end)
    
            timer_Simple(0.8,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(75, 65, 35)
            end)

        end,
    },
    ["chevalier4"] = {
        stam = 200,
        name = "Aura Slash",
        level = 20,
        icon = "mad_sololeveling/skills/icons/attack25.png",
        classe = {
            ["chevalier"] = true,
        },
        coldown = 5,
        type = "sword",
        ismagie = false,
        element = "none",
        code = function(ply)

            ply:Mad_SetAnim( "mad_flamme3ememouvement" )
            
		
            ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 				
            timer_Simple(0.05, function() ply:SetFOV(90, 0.3) end)
            timer_Simple(0.15, function() ply:SetFOV(ply:GetNWInt("FOV"), 0.5) end)

            timer_Simple(0.001, function() ParticleEffect( "dust_block", ply:GetPos(), ply:GetAngles(), ply ) end)
    
            if ply:IsOnGround() then
                timer_Simple(0.1, function() ply:SetVelocity(ply:GetForward()*250) ply:ViewPunch(Angle(0, 0, 10)) end)
            end

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect1", effectdata, true, true )

            local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		    util.Effect( "sl_effect4", effectdata, true, true )

            timer_Simple(0.4,function()
                ply:EmitSound( swing_attack[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO ) 	
                ply:GetActiveWeapon():DamageAttaque(250, 65, 35)
                timer_Simple(0.001, function() ParticleEffect( "[2]_fog_slash_add", ply:GetPos()+ply:GetUp()*35+ply:GetForward()*35, ply:GetAngles() + Angle(-120,90,90), ply ) end)
            end)

        end,
    },
}
--PATH addons/sl_main_system/lua/autorun/sl_config_titre.lua:
-- sh

TITRE_SL = {
    
    ["TueurGoblin"] = {
        name = "Tueur de Goblin",
        bonus_vie = 50,
        bonus_vitesse = 1,
        bonus_degat = 0,
    },

    ["TueurLoup"] = {
        name = "Tueur de Loup",
        bonus_vie = 50,
        bonus_vitesse = 50,
        bonus_degat = 10,
    },

    ["TueurMortVivant"] = {
        name = "Tueur de Mort Vivant",
        bonus_vie = 50,
        bonus_vitesse = 50,
        bonus_degat = 25,
    },

    ["TueurLezard"] = {
        name = "Tueur de Lézard",
        bonus_vie = 50,
        bonus_vitesse = 50,
        bonus_degat = 30,
    },

    ["TueurOurs"] = {
        name = "Tueur d'Ours",
        bonus_vie = 65,
        bonus_vitesse = 65,
        bonus_degat = 35,
    },

    ["TueurCentipede"] = {
        name = "Tueur de Centipede",
        bonus_vie = 75,
        bonus_vitesse = 75,
        bonus_degat = 50,
    },

    ["TueurOrc"] = {
        name = "Tueur d'Orc",
        bonus_vie = 100,
        bonus_vitesse = 100,
        bonus_degat = 55,
    },

    ["TueurDemon"] = {
        name = "Tueur de Démon",
        bonus_vie = 125,
        bonus_vitesse = 125,
        bonus_degat = 65,
    },

}

--PATH addons/slib_stromic_s_library/lua/slib/vgui/cl_stextentry.lua:
local PANEL = {}

local accentcolor, textcolor, textcolor_30, textcolor_80 = slib.getTheme("accentcolor"), slib.getTheme("textcolor"), slib.getTheme("textcolor", -30), slib.getTheme("textcolor", -80)

function PANEL:Init()
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "SetNumeric", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTextColor", nil, function() return self end, true)
    slib.wrapFunction(self, "SetDrawLanguageID", nil, function() return self end, true)
    slib.wrapFunction(self, "SetFont", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
    slib.wrapFunction(self, "SetValue", nil, function() return self end, true)

    self.font = slib.createFont("Roboto", 15)
    self.placeholder = "Search..."

    self:SetDrawLanguageID(false)
    :SetTall(slib.getScaledSize(25, "y"))
    :SetFont(self.font)
    :SetTextColor(textcolor_80)
    :SetValue(self.placeholder)
end

function PANEL:Paint(w,h)
    local val = self:GetValue()
    local wantedcolor = accentcolor
    wantedcolor.a = self:HasFocus() and 120 or 20

    if self.bg then
        surface.SetDrawColor(self.bg)
        surface.DrawRect(0, 0, w, h)
    end
    
    if !self.sideline then
        surface.SetDrawColor(slib.lerpColor(self, wantedcolor))
        surface.DrawRect(0, !self.accentlinetop and h - 1 or 0, w, 1)
    end

    self:DrawTextEntryText(val == self.placeholder and textcolor_30 or textcolor, accentcolor, textcolor)
end

function PANEL:OnGetFocus()
    local val = self:GetValue()
    if val == self.placeholder then
        self:SetValue("")
    end
end

function PANEL:AccentLineTop(bool)
    self.accentlinetop = bool
end

function PANEL:SetRefreshRate(rate)
    self.refreshrate = rate
end

function PANEL:AccentSideLine(bool)
    self.sideline = bool
end

function PANEL:OnTextChanged()
    local newvalue = self:GetValue()

    timer.Create(tostring(self), self.refreshrate or .3, 1, function()
        if !IsValid(self) then return end
        if isfunction(self.onValueChange) then
            self.onValueChange(newvalue)
        end
    end)
end

function PANEL:SetPlaceholder(str)
    self.placeholder = str
    self:SetValue(self.placeholder)

    return self
end

function PANEL:OnLoseFocus()
    timer.Simple(.1, function()
        if !IsValid(self) then return end
        local val = self:GetValue()
        if !val or val == "" then
            self:SetValue(self.placeholder)
        end
    end)
end

vgui.Register("STextEntry", PANEL, "DTextEntry")
--PATH addons/gprotect_1.15.101/lua/g_protect/languages/sh_english.lua:
if SERVER then
	slib.setLang("gprotect", "en", "colliding-too-much", "%s's entities are colliding too much, the trigger has a class of '%s' with %s collisions!")
	slib.setLang("gprotect", "en", "props-colliding-too-much", "%s's props are colliding too much with a total of %s collisions!")
	slib.setLang("gprotect", "en", "too-many-obstructs", "%s's entity is obstructing too many bad entities!")
	slib.setLang("gprotect", "en", "blacklisted-multiple", "You have successfully added %s models to the blocked models!")
	slib.setLang("gprotect", "en", "unblacklisted-multiple", "You have successfully removed %s models from the blocked models!")
	slib.setLang("gprotect", "en", "blacklisted-multiple-ent", "You have successfully added %s ents to the blacklisted entities!")
	slib.setLang("gprotect", "en", "unblacklisted-multiple-ent", "You have successfully removed %s ents from the blacklisted entities!")
	slib.setLang("gprotect", "en", "added-blacklist", "You have successfully added %s to the blocked models!")
	slib.setLang("gprotect", "en", "removed-blacklist", "You have successfully removed %s from the blocked models!")
	slib.setLang("gprotect", "en", "added-blacklist-ent", "You have successfully added %s to the entity blacklist!")
	slib.setLang("gprotect", "en", "removed-blacklist-ent", "You have successfully removed %s from the entity blacklist!")
	slib.setLang("gprotect", "en", "attempted-unfreeze-all", "%s has tried to unfreeze all after spawning a dupe!")
	slib.setLang("gprotect", "en", "attempted-upscaled-ent", "%s has tried to spawn an upscaled entity with adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-rope-spawning", "%s has tried to spawn ropes using adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-no-gravity", "%s has tried to spawn props with no gravity using adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-trail", "%s has tried to spawn props with trails using adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-advdupe-out-of-bounds", "%s has tried to spawn entities out of bounds using adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-advdupe-weird-angles", "%s has tried to spawn entities with weird angles using adv dupe 2!")
	slib.setLang("gprotect", "en", "attempted-instacrash-server", "%s may have attempted to insta-crash the server!")

	slib.setLang("gprotect", "en", "model-restricted", "This model has been restricted!")
	slib.setLang("gprotect", "en", "classname-restricted", "This entity class has been restricted!")
	slib.setLang("gprotect", "en", "attempted-blacklistedmaterial", "%s has attempted to use a blacklisted material with fading door!")
	slib.setLang("gprotect", "en", "spam-spawning", "%s is trying to spam spawning of entites/props.")

	slib.setLang("gprotect", "en", "too-complex-model", "This model has been restricted, it's too complex!")
	slib.setLang("gprotect", "en", "too-big-prop", "Your prop is too big so we removed it!")
	slib.setLang("gprotect", "en", "successfull-fpp-blockedmodels", "You have successfully transferred the blockedmodels from FPP to gProtect!")
	slib.setLang("gprotect", "en", "successfull-fpp-grouptools", "You have successfully transferred the grouptools from FPP to gProtect!")
	slib.setLang("gprotect", "en", "unsuccessfull-transfer", "There seems to be an issue while transferring the data over! (MySQL isnt supported)")

	slib.setLang("gprotect", "en", "blocked-secondaryusergroup", "Blocked due to secondary usergroup!")
	slib.setLang("gprotect", "en", "blocked-usergroup", "Blocked due to usergroup!")
	slib.setLang("gprotect", "en", "blocked-teamname", "Blocked due to team name!")
	slib.setLang("gprotect", "en", "blocked-sid", "Blocked due to SteamID!")

	slib.setLang("gprotect", "en", "you-ghosted-props", "You have ghosted %s's props!")
	slib.setLang("gprotect", "en", "you-frozen-props", "You have frozen %s's props!")
	slib.setLang("gprotect", "en", "you-removed-props", "You have removed %s's props!")
	slib.setLang("gprotect", "en", "you-removed-ents", "You have removed %s's entities!")

	slib.setLang("gprotect", "en", "props-ghosted", "Your props has been ghosted!")
	slib.setLang("gprotect", "en", "props-frozen", "Your props has been frozen!")
	slib.setLang("gprotect", "en", "props-removed", "Your props has been removed!")
	slib.setLang("gprotect", "en", "ents-removed", "Your entities has been removed!")

	slib.setLang("gprotect", "en", "everyones-props-ghosted", "Someone has ghosted everyones props!")
	slib.setLang("gprotect", "en", "everyones-props-frozen", "Someone has frozen everyones props!")
	slib.setLang("gprotect", "en", "disconnected-ents-removed", "You have removed every disconnected players entities!")

	slib.setLang("gprotect", "en", "spawn-to-close", "Your prop cannot be spawned inside someone!")
	slib.setLang("gprotect", "en", "entity-ghosted", "Your entity has been ghosted!")

	slib.setLang("gprotect", "en", "ratelimited_toolgun", "This tool has a ratelimit, please wait!")
	slib.setLang("gprotect", "en", "too_many_obstructs_purchase", "We have removed the entity and refunded you, there are too many obstructs!")

	slib.setLang("gprotect", "en", "mysql_successfull", "We have successfully connected to the database!")
    slib.setLang("gprotect", "en", "mysql_failed", "We have failed connecting to the database!")
elseif CLIENT then
	slib.setLang("gprotect", "en", "title", "gProtect - Settings")
	slib.setLang("gprotect", "en", "buddies-title", "gProtect - Buddies")

	slib.setLang("gprotect", "en", "world", "World")
	slib.setLang("gprotect", "en", "disconnected", "Disconnected")
	slib.setLang("gprotect", "en", "toolgun-name", "Blacklist Props")
	slib.setLang("gprotect", "en", "toolgun-desc", "Manage blocked models")
	slib.setLang("gprotect", "en", "toolgun-leftclick", "Add to blacklisted models")
	slib.setLang("gprotect", "en", "toolgun-rightclick", "Remove from blacklisted models")
	slib.setLang("gprotect", "en", "toolgun-help", "Shoot on a prop with the tool")
	slib.setLang("gprotect", "en", "remove-on-blacklist", "Remove prop on blacklist")
	slib.setLang("gprotect", "en", "player-list", "Player List")

	slib.setLang("gprotect", "en", "submit", "Submit")
	slib.setLang("gprotect", "en", "input_number", "Input number")

	slib.setLang("gprotect", "en", "toolgun", "Toolgun")
	slib.setLang("gprotect", "en", "physgun", "Physgun")
	slib.setLang("gprotect", "en", "gravity-gun", "Gravity Gun")
	slib.setLang("gprotect", "en", "canproperty", "Can Property")
	slib.setLang("gprotect", "en", "canuse", "Can Use")

	slib.setLang("gprotect", "en", "add-blocked-models", "Add to blocked models")
	slib.setLang("gprotect", "en", "remove-blocked-models", "Remove from blocked models")

	slib.setLang("gprotect", "en", "add-blacklisted-ents", "Add to blacklisted entities")
	slib.setLang("gprotect", "en", "remove-blacklisted-ents", "Remove from blacklisted entities")
	slib.setLang("gprotect", "en", "copy-clipboard", "Copy to clipboard")

	slib.setLang("gprotect", "en", "general", "General")
	slib.setLang("gprotect", "en", "ghosting", "Ghosting")
	slib.setLang("gprotect", "en", "damage", "Damage")
	slib.setLang("gprotect", "en", "anticollide", "Anti Collide")
	slib.setLang("gprotect", "en", "spamprotection", "Spam Protection")
	slib.setLang("gprotect", "en", "spawnrestriction", "Spawn Restriction")
	slib.setLang("gprotect", "en", "toolgunsettings", "Toolgun Settings")
	slib.setLang("gprotect", "en", "physgunsettings", "Physgun Settings")
	slib.setLang("gprotect", "en", "gravitygunsettings", "Gravgun Settings")
	slib.setLang("gprotect", "en", "canpropertysettings", "Can Property Settings")
	slib.setLang("gprotect", "en", "canusesettings", "Can Use Settings")
	slib.setLang("gprotect", "en", "advdupe2", "Adv Dupe 2")
	slib.setLang("gprotect", "en", "miscs", "Miscs")

	slib.setLang("gprotect", "en", "ghost-props", "Ghost Props")
	slib.setLang("gprotect", "en", "remove-props", "Remove Props")
	slib.setLang("gprotect", "en", "freeze-props", "Freeze Props")
	slib.setLang("gprotect", "en", "remove-entities", "Remove Entities")
	slib.setLang("gprotect", "en", "highlight-ents", "Highlight Entities")
	slib.setLang("gprotect", "en", "unhighlight-ents", "Unhighlight Entities")

	slib.setLang("gprotect", "en", "ghost-everyones-props", "Ghost everyones props")
	slib.setLang("gprotect", "en", "freeze-everyones-props", "Freeze everyones props")
	slib.setLang("gprotect", "en", "remove-disconnected-entities", "Remove disconnected players entities")

	slib.setLang("gprotect", "en", "general_remDiscPlyEnt", "Remove disconnect players entities")
	slib.setLang("gprotect", "en", "general_remDiscPlyEnt_tooltip", "This removes disconnected players entities on timer (If -1 it will be disabled)")
	slib.setLang("gprotect", "en", "general_remDiscPlyEntSpecific", "Remove disconnected players entities specific")
	slib.setLang("gprotect", "en", "general_remDiscPlyEntSpecific_tooltip", "Specific time for removal of entities, if nothing specified it will use the default one specified above. Making it -1 for classname will ignore it fully")

	slib.setLang("gprotect", "en", "general_remOutOfBounds", "Remove out of bounds timer")
	slib.setLang("gprotect", "en", "general_remOutOfBounds_tooltip", "This will remove entities that are outside of the map (If -1 it will be disabled)")
	slib.setLang("gprotect", "en", "general_remOutOfBoundsWhitelist", "Remove out of bounds whitelist")
	slib.setLang("gprotect", "en", "general_remOutOfBoundsWhitelist_tooltip", "Entities in this list will be removed if out of bounds.")

	slib.setLang("gprotect", "en", "general_blacklist", "Blacklist")
	slib.setLang("gprotect", "en", "general_blacklist_tooltip", "This is where add classnames that should be protected by generally all the modules.")
	slib.setLang("gprotect", "en", "general_protectedFrozenEnts", "Protected frozen entities")
	slib.setLang("gprotect", "en", "general_protectedFrozenEnts_tooltip", "This is the list of entities to protect whilst frozen")
	slib.setLang("gprotect", "en", "general_protectedFrozenGroup", "Protected frozen group")
	slib.setLang("gprotect", "en", "general_protectedFrozenGroup_tooltip", "This is the collision group to put frozen entities in!")

	slib.setLang("gprotect", "en", "ghosting_enabled", "Enabled")
	slib.setLang("gprotect", "en", "ghosting_enabled_tooltip", "Enable the ghosting module?")
	slib.setLang("gprotect", "en", "ghosting_ghostColor", "Ghosting color")
	slib.setLang("gprotect", "en", "ghosting_ghostColor_tooltip", "Select a color for ghosted entities")
	slib.setLang("gprotect", "en", "ghosting_antiObscuring", "Anti-obscuring")
	slib.setLang("gprotect", "en", "ghosting_antiObscuring_tooltip", "This will prevent the props from being unghosted while they obscure an object, Simply add entities that shouldnt be obscured!")
	slib.setLang("gprotect", "en", "ghosting_obscureOffset", "Anti-obscuring offset")
	slib.setLang("gprotect", "en", "ghosting_obscureOffset_tooltip", "This offset is used to add a gap outside of the bounding box that will trigger obscuring.")
	slib.setLang("gprotect", "en", "ghosting_onPhysgun", "Ghost on physgun?")
	slib.setLang("gprotect", "en", "ghosting_onPhysgun_tooltip", "This will ghost entities while being physgunned.")
	slib.setLang("gprotect", "en", "ghosting_useBlacklist", "Use blacklist")
	slib.setLang("gprotect", "en", "ghosting_useBlacklist_tooltip", "This option will ghost the blacklisted items from the blacklist if the module is enabled.")
	slib.setLang("gprotect", "en", "ghosting_entities", "Entities")
	slib.setLang("gprotect", "en", "ghosting_entities_tooltip", "Classnames in this list will be ghosted, this wont modify the blacklist usable by other modules.")
	slib.setLang("gprotect", "en", "ghosting_forceUnfrozen", "Force ghost unfrozen ents")
	slib.setLang("gprotect", "en", "ghosting_forceUnfrozen_tooltip", "This will force ghost entities that arent frozen.")
	slib.setLang("gprotect", "en", "ghosting_forceUnfrozenEntities", "Force ghost unfrozen ents whitelist")
	slib.setLang("gprotect", "en", "ghosting_forceUnfrozenEntities_tooltip", "The entities in this list will be ghosted if not frozen.")
	slib.setLang("gprotect", "en", "ghosting_enableMotion", "Enable motion while ghosted")
	slib.setLang("gprotect", "en", "ghosting_fenableMotion_tooltip", "If enabled ghosting will not disable motion for entities.")

	slib.setLang("gprotect", "en", "damage_enabled", "Enabled")
	slib.setLang("gprotect", "en", "damage_enabled_tooltip", "Enable the damage module?")
	slib.setLang("gprotect", "en", "damage_useBlacklist", "Use blacklist")
	slib.setLang("gprotect", "en", "damage_useBlacklist_tooltip", "This option will consider the general blacklist as a blacklisted ent in this module!")
	slib.setLang("gprotect", "en", "damage_entities", "Blacklisted Entities")
	slib.setLang("gprotect", "en", "damage_entities_tooltip", "Classnames in this list wont deal damage if the disable damage is ticked, this wont modify the blacklist usable by other modules.")
	slib.setLang("gprotect", "en", "damage_blacklistedEntPlayerDamage", "Disable blacklisted ents damage")
	slib.setLang("gprotect", "en", "damage_blacklistedEntPlayerDamage_tooltip", "If this is ticked then players wont receive damage from blacklisted entities.")
	slib.setLang("gprotect", "en", "damage_vehiclePlayerDamage", "Disable vehicle damage")
	slib.setLang("gprotect", "en", "damage_vehiclePlayerDamage_tooltip", "If this is ticked then players wont receive damage by vehicles.")
	slib.setLang("gprotect", "en", "damage_worldPlayerDamage", "Disable world damage")
	slib.setLang("gprotect", "en", "damage_worldPlayerDamage_tooltip", "If this is ticked then players wont receive damage from 'world', this can break certain addons unless they set damage to come from an entity.")
	slib.setLang("gprotect", "en", "damage_immortalEntities", "Immortal Entities")
	slib.setLang("gprotect", "en", "damage_immortalEntities_tooltip", "Classnames in this list wont take damage, except if the player is in the bypass group!")
	slib.setLang("gprotect", "en", "damage_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "damage_bypassGroups_tooltip", "Add usergroups in this list to bypass do damage restrictions, '*' means everyone!")
	slib.setLang("gprotect", "en", "damage_canDamageWorldEntities", "Can damage world entities")
	slib.setLang("gprotect", "en", "damage_canDamageWorldEntities_tooltip", "The groups that are in this list can damage world entities, '*' means everyone!")

	slib.setLang("gprotect", "en", "anticollide_enabled", "Enabled")
	slib.setLang("gprotect", "en", "anticollide_enabled_tooltip", "Enable the anticollide module?")
	slib.setLang("gprotect", "en", "anticollide_notifyStaff", "Notify staff")
	slib.setLang("gprotect", "en", "anticollide_notifyStaff_tooltip", "Should detections notify staff? NB:This can be used to piss staff.")
	slib.setLang("gprotect", "en", "anticollide_protectDarkRPEntities", "Protect DarkRP Entities")
	slib.setLang("gprotect", "en", "anticollide_protectDarkRPEntities_tooltip", "Should we protect DarkRP Entities? (0 = Disabled, 1 = Ghost, 2 = Freeze, 3 = Remove, 4 = Remove & Refund)")
	slib.setLang("gprotect", "en", "anticollide_DRPentitiesThreshold", "DRP entities threshold")
	slib.setLang("gprotect", "en", "anticollide_DRPentitiesThreshold_tooltip", "How many collisions can a prop have before being triggered within 1 second?")
	slib.setLang("gprotect", "en", "anticollide_DRPentitiesException", "DRP entities exception")
	slib.setLang("gprotect", "en", "anticollide_DRPentitiesException_tooltip", "Which collisions do we ignore? (0 = None, 1 = Not Same Owner, 2 = No Owner)")
	slib.setLang("gprotect", "en", "anticollide_protectSpawnedEntities", "Protect Spawned Entities")
	slib.setLang("gprotect", "en", "anticollide_protectSpawnedEntities_tooltip", "Should we protect Spawned Entities? (0 = Disabled, 1 = Ghost, 2 = Freeze, 3 = Remove)")
	slib.setLang("gprotect", "en", "anticollide_entitiesThreshold", "Spawned entities threshold")
	slib.setLang("gprotect", "en", "anticollide_entitiesThreshold_tooltip", "How many collisions can a prop have before being triggered within 1 second?")
	slib.setLang("gprotect", "en", "anticollide_entitiesException", "Spawned entities exception")
	slib.setLang("gprotect", "en", "anticollide_entitiesException_tooltip", "Which collisions do we ignore? (0 = None, 1 = Not Same Owner, 2 = No Owner)")
	slib.setLang("gprotect", "en", "anticollide_protectSpawnedProps", "Protect Spawned Props")
	slib.setLang("gprotect", "en", "anticollide_protectSpawnedProps_tooltip", "Should we protect Spawned Props? (0 = Disabled, 1 = Ghost, 2 = Freeze, 3 = Remove, 4 = Ghost & Unghost)")
	slib.setLang("gprotect", "en", "anticollide_propsThreshold", "Spawned props threshold")
	slib.setLang("gprotect", "en", "anticollide_propsThreshold_tooltip", "How many collisions can a prop have before being triggered within 1 second?")
	slib.setLang("gprotect", "en", "anticollide_propsException", "Spawned props exception")
	slib.setLang("gprotect", "en", "anticollide_propsException_tooltip", "Which collisions do we ignore? (0 = None, 1 = Not Same Owner, 2 = No Owner)")
	slib.setLang("gprotect", "en", "anticollide_playerPropAction", "Player specific props action")
	slib.setLang("gprotect", "en", "anticollide_playerPropAction_tooltip", "What action do we do once threshold is reached? (0 = Disabled, 1 = Ghost, 2 = Freeze, 3 = Remove, 4 = Ghost & Unghost)")
	slib.setLang("gprotect", "en", "anticollide_playerPropThreshold", "Player specific props threshold")
	slib.setLang("gprotect", "en", "anticollide_playerPropThreshold_tooltip", "This is the max collisions a player's props can have per second this will target all of their props! This only registers their own props as a collision.")
	slib.setLang("gprotect", "en", "anticollide_useBlacklist", "Use blacklist")
	slib.setLang("gprotect", "en", "anticollide_useBlacklist_tooltip", "The blacklisted entities will be ghosted if the collide to much if this is enabled.")
	slib.setLang("gprotect", "en", "anticollide_ghostEntities", "Entities")
	slib.setLang("gprotect", "en", "anticollide_ghostEntities_tooltip", "Classnames in this list will be ghosted if they collide to much.")
	slib.setLang("gprotect", "en", "anticollide_specificEntities", "Specific entities")
	slib.setLang("gprotect", "en", "anticollide_specificEntities_tooltip", "Add classnames in here to make specific rules for them, meaning that the number here will be their threshold anything below 0 will count them as bypass.")
	slib.setLang("gprotect", "en", "anticollide_squaredPhysicsMaxSize", "Squared physics max size")
	slib.setLang("gprotect", "en", "anticollide_squaredPhysicsMaxSize_tooltip", "This is a global protection which will automatically make complex and smaller collsionboxes into squares, this is effective at prventing mid sized spheres from causing lag.")
	slib.setLang("gprotect", "en", "anticollide_squaredPhysicsEnts", "Squared physics ents")
	slib.setLang("gprotect", "en", "anticollide_squaredPhysicsEnts_tooltip", "This is a global anti collide feature, which makes entities sleep after they hit the defined threshold (Threshold is cleared every 1 secound)")

	slib.setLang("gprotect", "en", "spamprotection_enabled", "Enabled")
	slib.setLang("gprotect", "en", "spamprotection_enabled_tooltip", "Enable the spamprotection module?")
	slib.setLang("gprotect", "en", "spamprotection_threshold", "Threshold")
	slib.setLang("gprotect", "en", "spamprotection_threshold_tooltip", "If you spawn these many props at once then it will kick in unless the delay defined below has cleared.")
	slib.setLang("gprotect", "en", "spamprotection_delay", "Delay")
	slib.setLang("gprotect", "en", "spamprotection_delay_tooltip", "This timer will clear the threshold above.")
	slib.setLang("gprotect", "en", "spamprotection_action", "Punishment")
	slib.setLang("gprotect", "en", "spamprotection_action_tooltip", "This will decide how to deal with spammers! (1 = disallow spawning, 2 = ghost entity/prop)")
	slib.setLang("gprotect", "en", "spamprotection_notifyStaff", "Notify staff")
	slib.setLang("gprotect", "en", "spamprotection_notifyStaff_tooltip", "Should detections notify staff? NB:This can be used to piss staff.")
	slib.setLang("gprotect", "en", "spamprotection_protectProps", "Protect Props")
	slib.setLang("gprotect", "en", "spamprotection_protectProps_tooltip", "This will protect props from being spam spawned.")
	slib.setLang("gprotect", "en", "spamprotection_protectEntities", "Protect Entities")
	slib.setLang("gprotect", "en", "spamprotection_protectEntities_tooltip", "This will protect entities from being spam spawned.")

	slib.setLang("gprotect", "en", "spawnrestriction_enabled", "Enabled")
	slib.setLang("gprotect", "en", "spawnrestriction_enabled_tooltip", "Enable the spawnrestriction module?")
	slib.setLang("gprotect", "en", "spawnrestriction_propSpawnPermission", "Prop spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_propSpawnPermission_tooltip", "This will limit spawning props totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_SENTSpawnPermission", "SENT spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_SENTSpawnPermission_tooltip", "This will limit spawning SENTS totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_SWEPSpawnPermission", "SWEP spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_SWEPSpawnPermission_tooltip", "This will limit spawning SWEP totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_vehicleSpawnPermission", "Vehicle spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_vehicleSpawnPermission_tooltip", "This will limit spawning vehicle totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_NPCSpawnPermission", "NPC spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_NPCSpawnPermission_tooltip", "This will limit spawning NPC totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_ragdollSpawnPermission", "Ragdoll spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_ragdollSpawnPermission_tooltip", "This will limit spawning ragdoll totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_effectSpawnPermission", "Effect spawn permissions")
	slib.setLang("gprotect", "en", "spawnrestriction_effectSpawnPermission_tooltip", "This will limit spawning effects totally! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedEntities", "Blocked entities")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedEntities_tooltip", "Place classnames of entities that should never be spawned in here, this also works for SWEPs!")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedEntitiesIsBlacklist", "Blocked entities is a blacklist")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedEntitiesIsBlacklist_tooltip", "If ticked it will make the classes in the list blocked from being spawned, otherwise you can only spawn those classes.")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModels", "Blocked models")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModels_tooltip", "Place model names so props with the model name wont spawn!")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModelsisBlacklist", "Blocked models is a blacklist")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModelsisBlacklist_tooltip", "If ticked it will make the models in the list blocked from being spawned, otherwise you can only spawn those models.")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModelsVehicleBypass", "Spawn vehicle bypass blocked models")
	slib.setLang("gprotect", "en", "spawnrestriction_blockedModelsVehicleBypass_tooltip", "If ticked vehicles will ignore the blocked models list.")
	slib.setLang("gprotect", "en", "spawnrestriction_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "spawnrestriction_bypassGroups_tooltip", "These groups will be able to bypass the blocked sents and models.")
	slib.setLang("gprotect", "en", "spawnrestriction_maxPropModelComplexity", "Max prop model complexity")
	slib.setLang("gprotect", "en", "spawnrestriction_maxPropModelComplexity_tooltip", "This will prevent from spawning models with complex shapes, recommended value is 10. (0 = Disabled)")
	slib.setLang("gprotect", "en", "spawnrestriction_maxModelSize", "Max model size")
	slib.setLang("gprotect", "en", "spawnrestriction_maxModelSize_tooltip", "If this is above 0 it will remove bigger props right after they are spawned.")

	slib.setLang("gprotect", "en", "toolgunsettings_enabled", "Enabled")
	slib.setLang("gprotect", "en", "toolgunsettings_enabled_tooltip", "Enable the toolgunsettings module?")
	slib.setLang("gprotect", "en", "toolgunsettings_targetWorld", "Can target world entities")
	slib.setLang("gprotect", "en", "toolgunsettings_targetWorld_tooltip", "This means that they can target world entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "toolgunsettings_targetPlayerOwned", "Can target player owned entities")
	slib.setLang("gprotect", "en", "toolgunsettings_targetPlayerOwned_tooltip", "This means that they can target players entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "toolgunsettings_targetPlayerOwnedProps", "Can target player owned props")
	slib.setLang("gprotect", "en", "toolgunsettings_targetPlayerOwnedProps_tooltip", "This means that they can target players props! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "toolgunsettings_targetVehiclePermission", "Target vehicle permission")
	slib.setLang("gprotect", "en", "toolgunsettings_targetVehiclePermission_tooltip", "If people are in the usergroups in this list they can use toolgun on vehicles!")

	slib.setLang("gprotect", "en", "toolgunsettings_restrictTools", "Restricted tools")
	slib.setLang("gprotect", "en", "toolgunsettings_restrictTools_tooltip", "The tools in here wont be usable by anyone but the ones in the bypassGroups option below.")
	slib.setLang("gprotect", "en", "toolgunsettings_groupToolRestrictions", "Group tool restrictions")
	slib.setLang("gprotect", "en", "toolgunsettings_groupToolRestrictions_tooltip", "Configure tool restrictions by tool, you can define with the following types: SteamID, Usergroup & Job name! (Whitelists has privlege over blacklists)")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassGroups_tooltip", "Groups in here will bypass the tool restrictions from the lists above!")
	slib.setLang("gprotect", "en", "toolgunsettings_entityTargetability", "Entity targetability")
	slib.setLang("gprotect", "en", "toolgunsettings_entityTargetability_tooltip", "This is neat to make it so people can only use the toolgun on their props for example!")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassTargetabilityTools", "Bypass targetability tools")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassTargetabilityTools_tooltip", "The tools in this list will bypass the targetability settings!")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassTargetabilityGroups", "Bypass targetability groups")
	slib.setLang("gprotect", "en", "toolgunsettings_bypassTargetabilityGroups_tooltip", "The groups in this list will bypass the targetability settings!")
	slib.setLang("gprotect", "en", "toolgunsettings_antiSpam", "Anti spam")
	slib.setLang("gprotect", "en", "toolgunsettings_antiSpam_tooltip", "Add tools in here and specify how many times they can use the tool per second!")

	slib.setLang("gprotect", "en", "physgunsettings_enabled", "Enabled")
	slib.setLang("gprotect", "en", "physgunsettings_enabled_tooltip", "Enable the physgun settings module?")
	slib.setLang("gprotect", "en", "physgunsettings_targetWorld", "Can target world entities")
	slib.setLang("gprotect", "en", "physgunsettings_targetWorld_tooltip", "This means that they can target world entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwned", "Can target player owned entities")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwned_tooltip", "This means that they can target players entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwnedProps", "Can target player owned props")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwnedProps_tooltip", "This means that they can target players props! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwnedPropsGroupLevel", "Group target level player owned props")
	slib.setLang("gprotect", "en", "physgunsettings_targetPlayerOwnedPropsGroupLevel_tooltip", "Set the group level for each usergroup, this will determine if you can target someones prop based on the usergroup. Higher level means more immunity.")
	slib.setLang("gprotect", "en", "physgunsettings_DisableReloadUnfreeze", "Disable reload unfreeze")
	slib.setLang("gprotect", "en", "physgunsettings_DisableReloadUnfreeze_tooltip", "This will prevent people from unfreezing props using reload.")
	slib.setLang("gprotect", "en", "physgunsettings_PickupVehiclePermission", "Pickup vehicle permission")
	slib.setLang("gprotect", "en", "physgunsettings_PickupVehiclePermission_tooltip", "If people are in the usergroups in this list they can pickup vehicles!")
	slib.setLang("gprotect", "en", "physgunsettings_StopMotionOnDrop", "Stop motion on drop")
	slib.setLang("gprotect", "en", "physgunsettings_StopMotionOnDrop_tooltip", "This will prevent proppushing/propkilling.")
	slib.setLang("gprotect", "en", "physgunsettings_blockMultiplePhysgunning", "Block multiple physgunning")
	slib.setLang("gprotect", "en", "physgunsettings_blockMultiplePhysgunning_tooltip", "This will block an entity that is being physgunned from being physgunned by someone else!")
	slib.setLang("gprotect", "en", "physgunsettings_maxDropObstructs", "Max obstruct threshold")
	slib.setLang("gprotect", "en", "physgunsettings_maxDropObstructs_tooltip", "This is the threshold of how many obsctructs from blacklisted entities till it triggers!")
	slib.setLang("gprotect", "en", "physgunsettings_maxDropObstructsAction", "Max obstruct trigger action")
	slib.setLang("gprotect", "en", "physgunsettings_maxDropObstructsAction_tooltip", "This is the how to threat triggers (1 = Ghost, 2 = Freeze, 3 = Remove)")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbing", "Prevent prop climbing")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbing_tooltip", "This is a feature ment to make it more difficult to prop climb with a single prop.")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbingThreshold", "Prop climbing threshold")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbingThreshold_tooltip", "How many triggers should we allow per 10 seconds?")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbingAction", "Prop climbing trigger action")
	slib.setLang("gprotect", "en", "physgunsettings_preventPropClimbingAction_tooltip", "This is the how to threat triggers (1 = Ghost, 2 = Remove)")
	slib.setLang("gprotect", "en", "physgunsettings_blockedEntities", "Blocked entities")
	slib.setLang("gprotect", "en", "physgunsettings_blockedEntities_tooltip", "Add entities into this and it wont be physgunable by anyone that isnt in the bypass group.")
	slib.setLang("gprotect", "en", "physgunsettings_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "physgunsettings_bypassGroups_tooltip", "Add usergroups in this list to bypass the blocked entities, '*' means everyone!")

	slib.setLang("gprotect", "en", "gravitygunsettings_enabled", "Enabled")
	slib.setLang("gprotect", "en", "gravitygunsettings_enabled_tooltip", "Enable the gravity gun settings module?")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetWorld", "Can target world entities")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetWorld_tooltip", "This means that they can target world entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetPlayerOwned", "Can target player owned entities")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetPlayerOwned_tooltip", "This means that they can target players entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetPlayerOwnedProps", "Can target player owned props")
	slib.setLang("gprotect", "en", "gravitygunsettings_targetPlayerOwnedProps_tooltip", "This means that they can target players props! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "gravitygunsettings_DisableGravityGunPunting", "Disable gravity gun punting")
	slib.setLang("gprotect", "en", "gravitygunsettings_DisableGravityGunPunting_tooltip", "This is the throwing attack of the gravity gun.")
	slib.setLang("gprotect", "en", "gravitygunsettings_blockedEntities", "Blocked entities")
	slib.setLang("gprotect", "en", "gravitygunsettings_blockedEntities_tooltip", "Add entities into this and it cant be picked up by anyone that isnt in the bypass group.")
	slib.setLang("gprotect", "en", "gravitygunsettings_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "gravitygunsettings_bypassGroups_tooltip", "Add usergroups in this list to bypass the blocked entities, '*' means everyone!")

	slib.setLang("gprotect", "en", "canpropertysettings_enabled", "Enabled")
	slib.setLang("gprotect", "en", "canpropertysettings_enabled_tooltip", "Enable the can property settings module?")
	slib.setLang("gprotect", "en", "canpropertysettings_targetWorld", "Can target world entities")
	slib.setLang("gprotect", "en", "canpropertysettings_targetWorld_tooltip", "This means that they can target world entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canpropertysettings_targetPlayerOwned", "Can target player owned entities")
	slib.setLang("gprotect", "en", "canpropertysettings_targetPlayerOwned_tooltip", "This means that they can target players entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canpropertysettings_targetPlayerOwnedProps", "Can target player owned props")
	slib.setLang("gprotect", "en", "canpropertysettings_targetPlayerOwnedProps_tooltip", "This means that they can target players props! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedProperties", "Blocked properties")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedProperties_tooltip", "Add properties to this list")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedPropertiesisBlacklist", "Blocked properties is blacklist")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedPropertiesisBlacklist_tooltip", "If ticked it will block the properties in the list from being used, otherwise you can only use those properties.")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedEntities", "Blocked entities")
	slib.setLang("gprotect", "en", "canpropertysettings_blockedEntities_tooltip", "Add entities into this and it wont be targetable by anyone except for people in the bypass group!")
	slib.setLang("gprotect", "en", "canpropertysettings_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "canpropertysettings_bypassGroups_tooltip", "Groups in here will bypass the can property restriction list from above!")

	slib.setLang("gprotect", "en", "canusesettings_enabled", "Enabled")
	slib.setLang("gprotect", "en", "canusesettings_enabled_tooltip", "Enable the can use settings module?")
	slib.setLang("gprotect", "en", "canusesettings_targetWorld", "Can target world entities")
	slib.setLang("gprotect", "en", "canusesettings_targetWorld_tooltip", "This means that they can target world entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canusesettings_targetPlayerOwned", "Can target player owned entities")
	slib.setLang("gprotect", "en", "canusesettings_targetPlayerOwned_tooltip", "This means that they can target players entities! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canusesettings_targetPlayerOwnedProps", "Can target player owned props")
	slib.setLang("gprotect", "en", "canusesettings_targetPlayerOwnedProps_tooltip", "This means that they can target players props! (Add usergroups in here to allow them, * means everyone!)")
	slib.setLang("gprotect", "en", "canusesettings_blockedEntities", "Blocked entities")
	slib.setLang("gprotect", "en", "canusesettings_blockedEntities_tooltip", "Add entities into this and it cant be used by anyone that isnt in the bypass group.")
	slib.setLang("gprotect", "en", "canusesettings_blockedEntitiesisBlacklist", "Blocked entities is blacklist")
	slib.setLang("gprotect", "en", "canusesettings_blockedEntitiesisBlacklist_tooltip", "If ticked it will block the entities in the list from being used, otherwise you can only use those entities.")
	slib.setLang("gprotect", "en", "canusesettings_bypassGroups", "Bypass groups")
	slib.setLang("gprotect", "en", "canusesettings_bypassGroups_tooltip", "Add usergroups in this list to bypass the blocked entities, '*' means everyone!")

	slib.setLang("gprotect", "en", "advdupe2_enabled", "Enabled")
	slib.setLang("gprotect", "en", "advdupe2_enabled_tooltip", "Should detections notify staff? NB:This can be used to piss staff.")
	slib.setLang("gprotect", "en", "advdupe2_notifyStaff", "Notify staff")
	slib.setLang("gprotect", "en", "advdupe2_notifyStaff_tooltip", "Should detections notify staff? NB:This can be used to piss staff.")
	slib.setLang("gprotect", "en", "advdupe2_PreventRopes", "Prevent rope spawning")
	slib.setLang("gprotect", "en", "advdupe2_PreventRopes_tooltip", "Prevent ropes from spawning! (1 = Prevent Spawning, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "en", "advdupe2_PreventScaling", "Prevent scaling")
	slib.setLang("gprotect", "en", "advdupe2_PreventScaling_tooltip", "Prevent Upscaled Props from spawning. (1 = Prevent Spawning, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "en", "advdupe2_PreventNoGravity", "Prevent no gravity")
	slib.setLang("gprotect", "en", "advdupe2_PreventNoGravity_tooltip", "Prevent spawning props with no gravity. (1 = Prevent Spawning, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "en", "advdupe2_PreventTrail", "Prevent trails")
	slib.setLang("gprotect", "en", "advdupe2_PreventTrail_tooltip", "Prevent spawning props with trails. (1 = Prevent Spawning, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "en", "advdupe2_PreventUnreasonableValues", "Prevent unreasonable values")
	slib.setLang("gprotect", "en", "advdupe2_PreventUnreasonableValues_tooltip", "Prevent entities with unreasonable values, this means position and or angles.")
	slib.setLang("gprotect", "en", "advdupe2_PreventUnfreezeAll", "Prevent unfreeze all")
	slib.setLang("gprotect", "en", "advdupe2_PreventUnfreezeAll_tooltip", "Prevent people from unfreezing all props.")
	slib.setLang("gprotect", "en", "advdupe2_BlacklistedCollisionGroups", "Blacklisted collision groups")
	slib.setLang("gprotect", "en", "advdupe2_BlacklistedCollisionGroups_tooltip", "This protects from props that you cannot target. NB:Values has to be collision ENUMs")
	slib.setLang("gprotect", "en", "advdupe2_WhitelistedConstraints", "Whitelisted constraints")
	slib.setLang("gprotect", "en", "advdupe2_WhitelistedConstraints_tooltip", "This is to prevent any unwanted constraints from being spawned.")
	slib.setLang("gprotect", "en", "advdupe2_whitelistedClasses", "Whitelisted entities")
	slib.setLang("gprotect", "en", "advdupe2_whitelistedClasses_tooltip", "This is a whitelist for SENTs to be spawned.")
	slib.setLang("gprotect", "en", "advdupe2_DelayBetweenUse", "Delay between use")
	slib.setLang("gprotect", "en", "advdupe2_DelayBetweenUse_tooltip", "This will prevent the people from spamming the tool, preventing lag. (0 = Disabled)")

	slib.setLang("gprotect", "en", "miscs_enabled", "Enabled")
	slib.setLang("gprotect", "en", "miscs_enabled_tooltip", "Enable the miscs module?")
	slib.setLang("gprotect", "en", "miscs_ClearDecals", "Clear decals timer")
	slib.setLang("gprotect", "en", "miscs_ClearDecals_tooltip", "Timer in seconds this will clear the decals for all the players on a timer :)")
	slib.setLang("gprotect", "en", "miscs_blacklistedFadingDoorMats_punishment", "Punishment blacklisted fading door mats")
	slib.setLang("gprotect", "en", "miscs_blacklistedFadingDoorMats_punishment_tooltip", "Int this will punish people for trying to use blacklisted mats (0 = Nothing, 1 = Notify, 2 = kick, 3 = ban).")
	slib.setLang("gprotect", "en", "miscs_blacklistedFadingDoorMats", "Blacklisted fading door mats")
	slib.setLang("gprotect", "en", "miscs_blacklistedFadingDoorMats_tooltip", "Add bad materials into this list, 'pp/copy' and 'dev/upscale' for example.")
	slib.setLang("gprotect", "en", "miscs_FadingDoorLag", "Prevent fading door lag")
	slib.setLang("gprotect", "en", "miscs_FadingDoorLag_tooltip", "This will prevent people from crashing the server with fading door tool.")
	slib.setLang("gprotect", "en", "miscs_DisableMotion", "Disable motion")
	slib.setLang("gprotect", "en", "miscs_DisableMotion_tooltip", "This will disable the motion for all blacklisted entities.")
	slib.setLang("gprotect", "en", "miscs_DisableMotionEntities", "Disable motion entities")
	slib.setLang("gprotect", "en", "miscs_DisableMotionEntities_tooltip", "Entities in this list cannot be unfrozen.")
	slib.setLang("gprotect", "en", "miscs_freezeOnSpawn", "Freeze on spawn")
	slib.setLang("gprotect", "en", "miscs_freezeOnSpawn_tooltip", "This will freeze props on spawn")
	slib.setLang("gprotect", "en", "miscs_preventFadingDoorAbuse", "Prevent fading door abuse")
	slib.setLang("gprotect", "en", "miscs_preventFadingDoorAbuse_tooltip", "This will prevent obscuring people in fading doors")
	slib.setLang("gprotect", "en", "miscs_precisionMoveFix", "Prevent precision move abuse")
	slib.setLang("gprotect", "en", "miscs_precisionMoveFix_tooltip", "Prevents the move mode from being abused, could be used to bypass anti-obscuring and such.")
	slib.setLang("gprotect", "en", "miscs_preventSpawnNearbyPlayer", "Prevent spawn nearby player")
	slib.setLang("gprotect", "en", "miscs_preventSpawnNearbyPlayer_tooltip", "If someone are closer to the spawn position than this value it wont spawn the prop (0 Means disabled)")
	slib.setLang("gprotect", "en", "miscs_DRPEntForceOwnership", "Force ownership on DarkRP Entities")
	slib.setLang("gprotect", "en", "miscs_DRPEntForceOwnership_tooltip", "This will force the ownership of entities bought in the F4 Menu")
	slib.setLang("gprotect", "en", "miscs_DRPMaxObstructsOnPurchaseEnts", "Max obstructs on purchase for DarkRP Ents")
	slib.setLang("gprotect", "en", "miscs_DRPMaxObstructsOnPurchaseEnts_tooltip", "This will prevent spawning alot of DRP Entities inside of eachother!")
	slib.setLang("gprotect", "en", "miscs_DRPObstructsFilter", "Max obstructs filter DarkRP entities")
	slib.setLang("gprotect", "en", "miscs_DRPObstructsFilter_tooltip", "This is the filter for the max obstructs(1 = DRP Entitities, 2 = Props)")
end

slib.setLang("gprotect", "en", "insufficient-permission", "You do not have the privilege to do this!")
--PATH addons/gprotect_1.15.101/lua/g_protect/client/cl_blockedmodels.lua:
local deleteNames = {
	["#spawnmenu.menu.delete"] = true,
	["#collision_off"] = true,
	["#spawnmenu.menu.spawn_with_toolgun"] = true
}

local function addOptions(menu, type, tbl, copy, prespacer, postspacer)
	tbl = util.TableToJSON(tbl)
	if prespacer then
		menu:AddSpacer()
	end

	menu:AddOption( gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, type == "model" and "add-blocked-models" or "add-blacklisted-ents"), function()
		net.Start("gP:Networking")
		net.WriteUInt(2,2)
		net.WriteUInt(type == "model" and 1 or 2, 2)
		net.WriteString(tbl)
		net.WriteBool(true)
		net.SendToServer()
	end ):SetIcon("icon16/add.png")

	menu:AddOption( gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, type == "model" and "remove-blocked-models" or "remove-blacklisted-ents"), function()
		net.Start("gP:Networking")
		net.WriteUInt(2,2)
		net.WriteUInt(type == "model" and 1 or 2, 2)
		net.WriteString(tbl)
		net.WriteBool(false)
		net.SendToServer()
	end ):SetIcon("icon16/delete.png")

	if copy then
		menu:AddOption( gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, "copy-clipboard"), function()
			SetClipboardText(copy)
		end ):SetIcon("icon16/page_copy.png")
	end

	if postspacer then
		menu:AddSpacer()
	end
end

local function HandleMenuOptions(state, menu, name)
	local hovered = vgui.GetHoveredPanel()
	local data = IsValid(hovered) and hovered:GetTable() or {}
	local ply = LocalPlayer()
	if IsValid(hovered) and deleteNames[name] then
		if state == "pre" then
			if data.m_strModelName and name ~= "#spawnmenu.menu.spawn_with_toolgun" then
				addOptions(menu, "model", {[data.m_strModelName] = true}, data.m_strModelName, false, true)
			end
		else
			if data.m_Type == "entity" then
				addOptions(menu, "entity", {[data.m_SpawnName] = true}, data.m_SpawnName, true, true)
			end

			if hovered.ClassName == "ContextMenu" then
				local ent = ply:GetEyeTrace().Entity
				if IsValid(ent) then
					if string.find(ent:GetClass(), "prop_") then
						local mdl = ent:GetModel()
						addOptions(menu, "model", {[mdl] = true}, mdl, true)
					else
						local classname = ent:GetClass()
						addOptions(menu, "entity", {[classname] = true}, classname, true, true)
					end
				end
			end
		end
	end
end

hook.Add("gP:PreAddedDMenuOption", "gP:OverrideMenuOptions", HandleMenuOptions)
hook.Add("gP:PostAddedDMenuOption", "gP:OverrideMenuOptions", HandleMenuOptions)

timer.Simple(1, function()
	local dmenu = baseclass.Get("DMenu")
	slib.wrapFunction(dmenu, "AddOption", function(menu, str) hook.Run("gP:PreAddedDMenuOption", "pre", menu, str) end, function(menu, str) hook.Run("gP:PostAddedDMenuOption", "post", menu, str) end)

	hook.Add( "SpawnlistOpenGenericMenu", "DragAndDropSelectionMenu", function( canvas )

		local selected = canvas:GetSelectedChildren()
		local allow = {}

		for k, v in pairs(selected) do
			if !IsValid(v) then continue end
			local data = v:GetTable()
			if data.m_Type == "entity" then allow["entity"] = true end
			if data.m_strModelName then allow["prop"] = true break end
		end

		local menu = DermaMenu()
	
		-- This is less than ideal
		local spawnicons = 0
		local icon = nil
		for id, pnl in pairs( selected ) do
			if ( pnl.InternalAddResizeMenu ) then
				spawnicons = spawnicons + 1
				icon = pnl
			end
		end
	
		if ( spawnicons > 0 ) then
			icon:InternalAddResizeMenu( menu, function( w, h )
	
				for id, pnl in pairs( selected ) do
					if ( !pnl.InternalAddResizeMenu ) then continue end
					pnl:SetSize( w, h )
					pnl:InvalidateLayout( true )
					pnl:GetParent():OnModified()
					pnl:GetParent():Layout()
					pnl:SetModel( pnl:GetModelName(), pnl:GetSkinID(), pnl:GetBodyGroup() )
				end
	
			end, language.GetPhrase( "spawnmenu.menu.resizex" ):format( spawnicons ) )
	
			menu:AddOption( language.GetPhrase( "spawnmenu.menu.rerenderx" ):format( spawnicons ), function()
				for id, pnl in pairs( selected ) do
					if ( !pnl.RebuildSpawnIcon ) then continue end
					pnl:RebuildSpawnIcon()
				end
			end ):SetIcon( "icon16/picture.png" )
		end

		if allow["prop"] and gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") then
			local models = {}
			for k, v in pairs( selected ) do
				if !IsValid(v) then continue end
				local data = v:GetTable()
				if !data.m_strModelName then continue end
				models[data.m_strModelName] = true
			end

			addOptions(menu, "model", models, false, true, true)
		end

		if allow["entity"] and gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") then
			local entities = {}
			for k, v in pairs( selected ) do
				if !IsValid(v) then continue end
				local data = v:GetTable()
				if !data.m_SpawnName then continue end
				entities[data.m_SpawnName] = true
			end

			addOptions(menu, "entity", entities, false, true, true)
		end

		menu:AddOption( language.GetPhrase( "spawnmenu.menu.deletex" ):format( #selected ), function()

			for k, v in pairs( selected ) do
				v:Remove()
			end
	
			hook.Run( "SpawnlistContentChanged" )
	
		end ):SetIcon( "icon16/bin_closed.png" )

		menu:Open()

	end )
end)
--PATH lua/sqlworkbench/networking.lua:
if (SERVER) then

	for _,v in ipairs({
		"SQLWorkbench_OpenMenu",
		"SQLWorkbench_MenuClosed",
		"SQLWorkbench_MenuMinimized",
		"SQLWorkbench_NoPermission",
		
		"SQLWorkbench_GetTables",
		"SQLWorkbench_GetTableStructure",
		"SQLWorkbench_Query",
		"SQLWorkbench_QueryError",
		"SQLWorkbench_QueryNoResults",
		"SQLWorkbench_QueryResults",
		"SQLWorkbench_DeleteRow",
		"SQLWorkbench_DeleteRow_Failed",
		"SQLWorkbench_UpdateRow",
		"SQLWorkbench_UpdateRow_Failed",
		"SQLWorkbench_DeleteTable",
		"SQLWorkbench_EmptyTable",
		"SQLWorkbench_ViewSQL",

		"SQLWorkbench_No_MySQLOO",
		"SQLWorkbench_MySQL_StartConnection",
		"SQLWorkbench_MySQL_ConnectionError",
		"SQLWorkbench_MySQL_AbortConnection",
	}) do util.AddNetworkString(v) end

else
	
	net.Receive("SQLWorkbench_NoPermission", function()
		chat.AddText(Color(255,0,0), "[SQLWorkbench] ", Color(255,255,255), "You must be a super admin to access SQLWorkbench")
	end)

	net.Receive("SQLWorkbench_No_MySQLOO", function()
		Derma_Query("You do not have MySQLOO installed on your server!\nThis module must be installed before you can connect to MySQL servers", "SQLWorkbench", "Install", function()
			gui.OpenURL("https://github.com/FredyH/MySQLOO")
		end, "Dismiss")
	end)
	
	net.Receive("SQLWorkbench_DeleteRow_Failed", function()
		Derma_Message("Failed to delete row for some reason!", "SQLWorkbench", "OK")
	end)
	
	net.Receive("SQLWorkbench_UpdateRow_Failed", function()
		Derma_Message("Failed to update row for some reason!", "SQLWorkbench", "OK")
	end)
	
end
--PATH addons/tadminsystem/lua/t_adminsystem/config.lua:
TAS.Config = {}

TAS.Config.AdminRanks = { // all staff ranks
	["superadmin"] = true,	
    ["moderateur"] = true,
    ["superviseur"] = true,
    ["gerant"] = true,
	["admin"] = true	
}

TAS.Config.Colors = {
	["background"] = Color(30, 30, 40, 240),
	["error"] = Color(155,40,40),
	["success"] = Color(40,120,50),
	["secondary"] = Color(33,115,172),
}

TAS.Config.Commands = {
	["staff"] = "!staff",
}

TAS.Config.HUDPosY = "bottom" // top, bottom

TAS.Config.TicketMax = 10 // maximum number of tickets 

TAS.Config.TicketRequireStaffMode = false

TAS.Config.TicketTimeBeforeDelete = 999999 // maximum time before a ticket is deleted

TAS.Config.TicketActions = { // commands available in a ticket
    ["Spectate"] = function(ply)
        RunConsoleCommand("FSpectate", ply:Nick())
    end,
    ["Téléporter"] = function(ply)
        RunConsoleCommand("sam", "bring", ply:Nick())
    end,
    ["Se téléporter"] = function(ply)
        RunConsoleCommand("sam", "goto", ply:Nick())
    end,
    ["Freeze"] = function(ply)
        RunConsoleCommand("sam", "freeze", ply:Nick())
    end,
    ["Unfreeze"] = function(ply)
        RunConsoleCommand("usamlx", "unfreeze", ply:Nick())
    end,
}
--PATH addons/talk-modes/lua/talk_modes/language/sh_languages.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to GLeaks.Space
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
TalkModes = TalkModes || {}
TalkModes.Languages = TalkModes.Languages || {}
TalkModes.Languages.Available = TalkModes.Languages.Available || {}
TalkModes.Languages.Active = TalkModes.Languages.Active || "English" -- Don't touch this line, change language using the in-game admin menu

function TalkModes.Languages:Register(strLanguage, tblPhrases)
    self.Available[strLanguage] = tblPhrases
end

function TalkModes.Languages:GetPhrase(strPhrase)
    return self.Available[TalkModes.Config:GetSetting("General", "Language")][strPhrase] || "phrase_not_found"
end
--PATH addons/talk-modes/lua/talk_modes/language/sh_english.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to GLeaks.Space
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
local LANGUAGE = {}
LANGUAGE["General"] = "Principal"
LANGUAGE["Theme"] = "Thème"
LANGUAGE["Modes"] = "Modes"
LANGUAGE["Whisper"] = "Chuchotement"
LANGUAGE["Whisper_Desc"] = "Parler doucement"
LANGUAGE["Yell"] = "Crier"
LANGUAGE["Yell_Desc"] = "Parler Fort"
LANGUAGE["Talk"] = "Parler" 
LANGUAGE["Talk_Desc"] = "Parler normalement"
LANGUAGE["3D Voice"] = "Voix 3D"
LANGUAGE["3D Voice_Desc"] = "Faut-il activer le système 3D Voice ?"
LANGUAGE["Language"] = "Langue"
LANGUAGE["Language_Desc"] = "Quelle langue doit-on utiliser ?"
LANGUAGE["Selection Key"] = "Bouton de sélection"
LANGUAGE["Selection Key_Desc"] = "Quel bouton doit ouvrir le menu de sélection ?"
LANGUAGE["Talking Dead"] = "La voix du mort"
LANGUAGE["Talking Dead_Desc"] = "Les morts doivent-ils parler ?"
LANGUAGE["Selection Menu Position"] = "Position du menu de sélection"
LANGUAGE["Selection Menu Position_Desc"] = "Où doit se trouver le menu sur l'écran ?"
LANGUAGE["Save"] = "Sauvegarder"
LANGUAGE["Reset"] = "Réinitialiser"
LANGUAGE["Preview"] = "Prévisualisation"
LANGUAGE["PreviewHeader"] = "CLIQUEZ SUR [%f] POUR FERMER LE PRESET"
LANGUAGE["PreviewText"] = "DISTANCE PRESET actuelle : %s UNITES"
LANGUAGE["Background"] = "Fond d'écran"
LANGUAGE["Background_Desc"] = "Sélectionnez la couleur de fond"
LANGUAGE["Foreground"] = "Premier plan"
LANGUAGE["Foreground_Desc"] = "Sélectionnez la couleur de premier plan"
LANGUAGE["Hover"] = "Accentuation"
LANGUAGE["Hover_Desc"] = "Sélectionnez la couleur du texte en surbrillance"
LANGUAGE["White"] = "Blanc"
LANGUAGE["White_Desc"] = "Choisissez une couleur au lieu du blanc"
LANGUAGE["Gray"] = "Gris"
LANGUAGE["Gray_Desc"] = "Choisissez une couleur au lieu du gris"
LANGUAGE["WelcomeMessage"] = "Ce serveur utilise le script Talk Modes, maintenez %s pour changer les modes de conversation ! Choisissez une couleur au lieu du gris"
LANGUAGE["Turn Off"] = "Désactiver"
LANGUAGE["Using Mode"] = "Mode d'utilisation"
LANGUAGE["Auto-Hide"] = "Masquer automatiquement"
LANGUAGE["Auto-Hide_Desc"] = "Masquer automatiquement le menu de sélection s'il n'est pas utilisé ?"
LANGUAGE["Mode Change Message"] = "Mode de notification"
LANGUAGE["Mode Change Message_Desc"] = "Notifier les joueurs d'un changement de mode de conversation ?"

TalkModes.Languages:Register("English", LANGUAGE)
--PATH addons/talk-modes/lua/talk_modes/core/cl_core.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to GLeaks.Space
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
TalkModes = TalkModes || {}
TalkModes.Client = TalkModes.Client || {}

function TalkModes.Client:CreateFont(name, size)
	surface.CreateFont(name, {
		font = "Montserrat Medium",
		size = size,
		weight = 500,
        extended = true,
        antialias = true
	})
end

local tblTalkModes = {
    [1] = {
        strMode = "Whisper",
        matImage = Material("talkmodes/whisper.png")
    },
    [2] = {
        strMode = "Talk",
        matImage = Material("talkmodes/normal.png")
    },  
    [3] = {
        strMode = "Yell",
        matImage = Material("talkmodes/yell.png")
    }
}

local tblPositions = {
    ["Top Left"] = {6, 6},
    ["Top Center"] = {ScrW()/2 - 120/2, 6},
    ["Top Right"] = {ScrW() - 120 - 6, 6},
    ["Center Left"] = {6, ScrH()/2 - 44/2},
    ["Center Right"] = {ScrW() - 120 - 6, ScrH()/2 - 44/2},
    ["Bottom Left"] = {6, ScrH() - 44 - 6},
    ["Bottom Center"] = {ScrW()/2 - 120/2, ScrH() - 44 - 6},
    ["Bottom Right"] = {ScrW() - 120 - 6, ScrH() - 44 - 6}
}

TalkModes.Client:CreateFont("TalkModes:Small", 20)
TalkModes.Client:CreateFont("TalkModes:Medium", 26)
TalkModes.Client:CreateFont("TalkModes:Big", 32)
TalkModes.Client:CreateFont("TalkModes:Huge", 48)

local selectionMenu
function TalkModes.Client.InitMenu()
    if (selectionMenu) then
        selectionMenu:Remove()
    end
    selectionMenu = vgui.Create("TalkModes.PlayerMenu")
    local intW, intH = tblPositions[TalkModes.Config:GetSetting("General", "Selection Menu Position")][1], tblPositions[TalkModes.Config:GetSetting("General", "Selection Menu Position")][2]
    selectionMenu:SetPos(intW, intH)
end
net.Receive("TalkModes.InitMenu", TalkModes.Client.InitMenu)


local intCurrentTalkMode = 2
local intCooldown = CurTime()
local intPanelTime = CurTime() + 3
local bFadingOut = false
local bPlayingPiano = false
function TalkModes.Client.MenuControl()
    local bCamera = (LocalPlayer():GetActiveWeapon():IsValid() && LocalPlayer():GetActiveWeapon():GetClass() == "gmod_camera") && true || false

    if (bCamera) then
        if (selectionMenu:IsVisible()) then
            selectionMenu:SetAlpha(0)
            selectionMenu:SetVisible(false)
            print(selectionMenu:IsVisible())
        end
    else
        if (!selectionMenu:IsVisible() && !TalkModes.Config:GetSetting("General", "Auto-Hide")) then
            selectionMenu:SetVisible(true)
            selectionMenu:SetAlpha(255)
        end
    end

    if (TalkModes.Config:GetSetting("General", "Auto-Hide")) then
        if (!input.IsKeyDown(TalkModes.Config:GetSetting("General", "Selection Key") || 18)) then
            if (CurTime() > intPanelTime && !bFadingOut && selectionMenu:IsVisible()) then
                bFadingOut = true
                selectionMenu:AlphaTo(0, 0.5, 0, function(_, self)
                    self:SetVisible(!(CurTime() > intPanelTime))
                    bFadingOut = false
                end)
            end
        end
    end

    if (input.IsKeyDown(TalkModes.Config:GetSetting("General", "Selection Key") || 18) && TM_ADMIN_PREVIEW.bActive) then 
        net.Start("TalkModes.AttemptPreview")
        net.SendToServer()
        return
    end

    bPianoPlaying = LocalPlayer().Instrument && LocalPlayer().Instrument:GetClass() == "gmt_instrument_piano" && true || false // Playable piano support
    
    if (!input.IsKeyDown(TalkModes.Config:GetSetting("General", "Selection Key") || 18) || vgui.CursorVisible() || intCooldown > CurTime() || bPianoPlaying) then return end

    if (TalkModes.Config:GetSetting("General", "Auto-Hide") && !bCamera) then
        selectionMenu:SetVisible(true)
        selectionMenu:AlphaTo(255, 0.25)
        intPanelTime = CurTime() + 3 + 0.75
    end

    for k, v in ipairs(tblTalkModes) do
        if (v.strMode == LocalPlayer():GetTalkMode()) then
            intCurrentTalkMode = k
            break
        end
    end
    
    intCurrentTalkMode = intCurrentTalkMode < 3 && intCurrentTalkMode + 1 || 1
    net.Start("TalkModes.ChangeMode")
        net.WriteString(tblTalkModes[intCurrentTalkMode].strMode)
    net.SendToServer()
    intCooldown = CurTime() + 0.5
end
hook.Add("Think", "TalkModes.Client.MenuControl", TalkModes.Client.MenuControl)
--PATH addons/talk-modes/lua/talk_modes/networking/cl_net.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to GLeaks.Space
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------
TalkModes.Client = TalkModes.Client || {}
TalkModes.Client.ActiveTheme = TalkModes.Client.ActiveTheme || {
    ["Background"] = Color(30, 30, 30), 
    ["Foreground"] = Color(40, 40, 40),
    ["Gray"] = Color(160, 160, 160),
    ["Hover"] = Color(192, 57, 43),
    ["White"] = Color(230, 230, 230)
}

function TalkModes.Client.OpenAdminMenu()
    local pMenu = vgui.Create("TalkModes.AdminMenu")
    pMenu:SetAlpha(0)
    pMenu:AlphaTo(255, 0.2)
end
net.Receive("TalkModes.OpenAdminMenu", TalkModes.Client.OpenAdminMenu)

net.Receive("TalkModes.Notify", function()  
    local strMessage = net.ReadString()

    chat.AddText(TalkModes.Client.ActiveTheme["Hover"] || Color(255, 0, 0), "[Talk Modes] ", color_white, strMessage)
end)

net.Receive("TalkModes.WelcomeMessage", function()
    chat.AddText(TalkModes.Client.ActiveTheme["Hover"] || Color(255, 0, 0), "[Talk Modes] ", color_white, string.format(TalkModes.Languages:GetPhrase("WelcomeMessage"), string.upper(input.GetKeyName(TalkModes.Config:GetSetting("General", "Selection Key")))))
end)

net.Receive("TalkModes.Config.Network", function()
	local tblConfig = net.ReadTable()

	TalkModes.Config.Client = tblConfig || {}

    -- This will convert the color values to a color vector. 
    -- It'll make it much easier for the UI. 
    if TalkModes.Client.ActiveTheme != tblConfig["UI"] then 
        for i, v in pairs(tblConfig["UI"]) do 
            TalkModes.Client.ActiveTheme[i] = Color(v.r, v.g, v.b, v.a)
        end
    end
end)

--PATH addons/talk-modes/lua/talk_modes/vgui/cl_preview.lua:
include("talk_modes/vgui/libs/cl_spheres.lua")

-- This is global which allows us to interact with it anywhere, cl_selection in particular. 
TM_ADMIN_PREVIEW = TM_ADMIN_PREVIEW || {bActive = false, intRange = 300}
local THEME = TalkModes.Client.ActiveTheme

function TalkModes.Client.HUDPaint()
    if TM_ADMIN_PREVIEW.bActive == false then return end
    if TM_ADMIN_PREVIEW.intRange == 0 then return end

    surface.SetFont("TalkModes:Medium")
    local intTextW, intTextH = surface.GetTextSize(string.format(TalkModes.Languages:GetPhrase("PreviewText"), TM_ADMIN_PREVIEW.intRange))
    draw.RoundedBox(6, ScrW()/2 - (intTextW + 24)/2, ScrH() - intTextH + 8 - 24 , intTextW + 24, intTextH + 8, Color(THEME["Hover"].r, THEME["Hover"].g, THEME["Hover"].b, 200))
    draw.SimpleText(string.format(TalkModes.Languages:GetPhrase("PreviewText"), TM_ADMIN_PREVIEW.intRange), "TalkModes:Medium", ScrW()/2, ScrH() - 24, THEME["White"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    surface.SetFont("TalkModes:Small")
    local intTextWw, intTextHh = surface.GetTextSize(TalkModes.Languages:GetPhrase("PreviewHeader"))
    draw.RoundedBoxEx(6, ScrW()/2 - (intTextWw + 24)/2, ScrH() - intTextH + 8 - 24 - intTextHh, intTextWw + 24, intTextHh, Color(THEME["Hover"].r, THEME["Hover"].g, THEME["Hover"].b, 200), true, true, false, false )
    draw.SimpleText(string.format(TalkModes.Languages:GetPhrase("PreviewHeader"), string.upper(input.GetKeyName(TalkModes.Config:GetSetting("General", "Selection Key")))), "TalkModes:Small", ScrW()/2, ScrH() - intTextH + 8 - 24 - intTextHh/2, THEME["White"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end
hook.Add("HUDPaint", "TalkModes.Client.HUDPaint", TalkModes.Client.HUDPaint)

function TalkModes.Client.PostDrawTranslucentRenderables()
    if TM_ADMIN_PREVIEW.bActive == false then return end
    if TM_ADMIN_PREVIEW.intRange == 0 then return end

    render.StartWorldRings()
        render.AddWorldRing(LocalPlayer():GetPos(), TM_ADMIN_PREVIEW.intRange, 10, 50)
    render.FinishWorldRings(THEME["Hover"])
end
hook.Add("PostDrawTranslucentRenderables", "TalkModes.Client.PostDrawTranslucentRenderables", TalkModes.Client.PostDrawTranslucentRenderables)

net.Receive("TalkModes.TriggerPreview", function(_)
    local intRange = net.ReadUInt(12)

    if TM_ADMIN_PREVIEW.bActive == true then 
        TM_ADMIN_PREVIEW.bActive = false
        TM_ADMIN_PREVIEW.intRange = 0
    else 
        TM_ADMIN_PREVIEW.bActive = true 
        TM_ADMIN_PREVIEW.intRange = intRange
    end
end)
--PATH addons/talk-modes/lua/talk_modes/vgui/elements/cl_navbar.lua:
local THEME = TalkModes.Client.ActiveTheme

local PANEL = {}
AccessorFunc(PANEL, "page", "Page")
AccessorFunc(PANEL, "button_text", "ButtonText")
AccessorFunc(PANEL, "mat", "Mat")
AccessorFunc(PANEL, "active", "Active", FORCE_BOOL)

function PANEL:Init()
    self.base = self:GetParent():GetParent()
    self.nav = self:GetParent()
    self:Dock(TOP)
    self:DockMargin(0, 8, 0, 0)
    self:SetHeight(42)
    self:SetText("")
    self.intOffset = 0
    self.colActive = Color(255, 255, 255)
end

function PANEL:Paint(intW, intH)
    self.intOffset = Lerp(FrameTime() * 8, self.intOffset, (self:IsHovered() || self:GetActive()) && 12 || 0)
    self.colActive.r = Lerp(FrameTime() * 16, self.colActive.r, (self:IsHovered() || self:GetActive()) && THEME["Hover"].r || THEME["White"].r )
    self.colActive.g = Lerp(FrameTime() * 16, self.colActive.g, (self:IsHovered() || self:GetActive()) && THEME["Hover"].g || THEME["White"].g )
    self.colActive.b = Lerp(FrameTime() * 16, self.colActive.b, (self:IsHovered() || self:GetActive()) && THEME["Hover"].b || THEME["White"].b )
    
    surface.SetDrawColor(Color(self.colActive.r, self.colActive.g, self.colActive.b))
    surface.SetMaterial(self:GetMat())
    surface.DrawTexturedRect(self.intOffset + 18, (42-32)/2, 32, 32)
    draw.SimpleText(TalkModes.Languages:GetPhrase(self:GetButtonText()), "TalkModes:Medium", self.intOffset + 18 + 32 + 12, intH/2, THEME["White"], TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

function PANEL:DoClick()
    if (self:GetActive() or self.base.docker.bChanging) then return end
    for _,btn in ipairs(self.nav.tblButtons) do
        btn:SetActive(false)
    end
    self:SetActive(true)
    self.base.docker:ChangePage(self:GetPage(), true)
end
vgui.Register("TalkModes.NavbarButton", PANEL, "DButton")

local PANEL = {}
function PANEL:Init()
    self.tblButtons = {}
end
function PANEL:Paint(intW, intH)
    draw.RoundedBoxEx(8, 0, 0, intW, intH, THEME["Background"], false, false, true, false)
end

function PANEL:AddButton(strPage, mMat, strText)
    self.btn = self:Add("TalkModes.NavbarButton")
    self.btn:SetPage(strPage)
    self.btn:SetMat(mMat)
    self.btn:SetButtonText(strText)

    self.tblButtons[#self.tblButtons + 1] = self.btn
    if (self.tblButtons[1] == self.btn) then
        self.btn:SetActive(true)
    end
end
vgui.Register("TalkModes.Navbar", PANEL, "DPanel")


--PATH addons/talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
local _R = debug.getregistry()
if (_R.Circles) then return _R.Circles end

local BlurMat = Material("pp/blurscreen")

local rad = math.rad
local cos = math.cos
local sin = math.sin
local min = math.min
local max = math.max

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local function New(type, radius, x, y, ...)
	local circle = setmetatable({}, CIRCLE)

	circle:SetType(tonumber(type))
	circle:SetRadius(tonumber(radius))
	circle:SetPos(tonumber(x), tonumber(y))

	if (type == CIRCLE_OUTLINED) then
		local outline_width = ({...})[1]
		circle:SetOutlineWidth(tonumber(outline_width))
	elseif (type == CIRCLE_BLURRED) then
		local blur_density, blur_quality = unpack({...})
		circle:SetBlurDensity(tonumber(blur_density))
		circle:SetBlurQuality(tonumber(blur_quality))
	end

	return circle
end

local function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
	rotation = rad(rotation)

	local c = cos(rotation)
	local s = sin(rotation)

	for i = 1, #vertices do
		local vertex = vertices[i]
		local vx, vy = vertex.x, vertex.y

		vx = vx - ox
		vy = vy - oy

		vertex.x = ox + (vx * c - vy * s)
		vertex.y = oy + (vx * s + vy * c)

		if (not rotate_uv) then
			local u, v = vertex.u, vertex.v
			u, v = u - 0.5, v - 0.5

			vertex.u = 0.5 + (u * c - v * s)
			vertex.v = 0.5 + (u * s + v * c)
		end
	end
end

local function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
	x = tonumber(x) or 0
	y = tonumber(y) or 0
	radius = tonumber(radius) or 16
	rotation = tonumber(rotation) or 0
	start_angle = tonumber(start_angle) or 0
	end_angle = tonumber(end_angle) or 360
	distance = tonumber(distance) or 10

	if (start_angle > end_angle) then
		local tmp = start_angle
		start_angle = end_angle
		end_angle = tmp
	end

	local vertices = {}
	local step = (distance * 360) / (2 * math.pi * radius)

	for a = start_angle, end_angle + step, step do
		a = max(start_angle, min(end_angle, a))
		a = rad(a)

		local c = cos(a)
		local s = sin(a)

		local vertex = {
			x = x + c * radius,
			y = y + s * radius,

			u = 0.5 + c / 2,
			v = 0.5 + s / 2,
		}

		table.insert(vertices, vertex)
	end

	if (end_angle - start_angle ~= 360) then
		table.insert(vertices, 1, {
			x = x, y = y,
			u = 0.5, v = 0.5,
		})
	else
		table.remove(vertices)
	end

	if (rotation ~= 0) then
		RotateVertices(vertices, x, y, rotation, rotate_uv)
	end

	return vertices
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:Calculate()
	local rotate_uv = self:GetRotateMaterial()
	local x, y = self:GetPos()
	local radius = self:GetRadius()
	local rotation = self:GetRotation()
	local start_angle = self:GetStartAngle()
	local end_angle = self:GetEndAngle()
	local distance = self:GetDistance()

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if (self:GetType() == CIRCLE_OUTLINED) then
		local inner = self:GetChildCircle() or self:Copy()

		inner:SetType(CIRCLE_FILLED)
		inner:SetRadius(self:GetRadius() - self:GetOutlineWidth())
		inner:SetAngles(0, 360)

		inner:SetColor(false)
		inner:SetMaterial(false)
		inner:SetDisableClipping(false)

		self:SetChildCircle(inner)
	end

	self:SetDirty(false)
end

function CIRCLE:__call()
	if (self:GetDirty()) then
		self:Calculate()
	end

	if (IsColor(self:GetColor())) then surface.SetDrawColor(self:GetColor()) end
	if (TypeID(self:GetMaterial()) == TYPE_MATERIAL) then surface.SetMaterial(self:GetMaterial()) end

	local clip = self:GetDisableClipping()
	if (clip) then surface.DisableClipping(true) end

	if (self:GetType() == CIRCLE_OUTLINED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			self:GetChildCircle()()

			render.SetStencilCompareFunction(STENCIL_GREATER)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.DrawPoly(self:GetVertices())
		render.SetStencilEnable(false)
	elseif (self:GetType() == CIRCLE_BLURRED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			surface.DrawPoly(self:GetVertices())

			render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.SetMaterial(BlurMat)

			local sw, sh = ScrW(), ScrH()

			for i = 1, self:GetBlurQuality() do
				BlurMat:SetFloat("$blur", (i / self:GetBlurQuality()) * self:GetBlurDensity())
				BlurMat:Recompute()

				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect(0, 0, sw, sh)
			end
		render.SetStencilEnable(false)
	else
		surface.DrawPoly(self:GetVertices())
	end

	if (clip) then surface.DisableClipping(false) end
end

function CIRCLE:Translate(x, y)
	self.m_X = self:GetX() + x
	self.m_Y = self:GetY() + y

	if (self:GetDirty()) then return end

	x = tonumber(x) or 0
	y = tonumber(y) or 0

	for i, v in ipairs(self:GetVertices()) do
		v.x = v.x + x
		v.y = v.y + y
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Translate(x, y)
	end
end

function CIRCLE:Scale(scale)
	self.m_Radius = self:GetRadius() * scale

	if (self:GetDirty()) then return end

	local x, y = self:GetPos()
	scale = tonumber(scale) or 1

	for i, vertex in ipairs(self:GetVertices()) do
		vertex.x = x + ((vertex.x - x) * scale)
		vertex.y = y + ((vertex.y - y) * scale)
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Scale(scale)
	end
end

function CIRCLE:Rotate(degrees)
	self.m_Rotation = self:GetRotation() + degrees

	if (self:GetDirty()) then return end

	local vertices = self:GetVertices()
	local x, y = self:GetPos()
	local rotate_uv = self:GetRotateMaterial()
	degrees = tonumber(degrees) or 0

	RotateVertices(vertices, x, y, degrees, rotate_uv)

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Rotate(degrees)
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if (default ~= nil and value == nil) then
				value = default
			end

			if (self[varname] ~= value) then
				if (dirty) then
					self[dirty] = true
				end

				if (isfunction(callback)) then
					value = callback(self, self[varname], value) or value
				end
			end

			self[varname] = value
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.x = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesX(circle:GetChildCircle(), old, new)
		end
	end

	local function OffsetVerticesY(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.y = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesY(circle:GetChildCircle(), old, new)
		end
	end

	local function UpdateRotation(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		local vertices = circle:GetVertices()
		local x, y = circle:GetPos()
		local rotation = new - old
		local rotate_uv = circle:GetRotateMaterial()

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if (circle:GetType() == CIRCLE_OUTLINED) then
			UpdateRotation(circle:GetChildCircle(), old, new)
		end
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)

	AccessorFunc("Color", false)						-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)						-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)				-- Sets whether or not the circle's UV points should be rotated with the vertices.
	AccessorFunc("DisableClipping", false)				-- Sets whether or not to disable clipping when the circle is rendered. Useful for circles that go out of the render bounds.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty") 		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX) 		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY) 		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty") 				-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty") 			-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")			-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")				-- The maximum distance between each of the circle's vertices. Set to false to use segments instead. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurDensity", 3)						-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurQuality", 2)						-- The circle's blur quality if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")			-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		self:SetX(x)
		self:SetY(y)
	end

	function CIRCLE:SetAngles(s, e)
		self:SetStartAngle(s)
		self:SetEndAngle(e)
	end

	function CIRCLE:GetPos()
		return self:GetX(), self:GetY()
	end

	function CIRCLE:GetAngles()
		return self:GetStartAngle(), self:GetEndAngle()
	end
end

_R.Circles = {
	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles

--PATH addons/talk-modes/lua/talk_modes/vgui/elements/cl_slider.lua:
local circles = include("talk_modes/vgui/libs/cl_circles.lua")
local THEME = TalkModes.Client.ActiveTheme

local PANEL = {}
AccessorFunc(PANEL, "color", "Color")  
function PANEL:Init()
    self:SetSize(260, 12)
    self:SetDecimals(0)
    self.Wang:SetVisible(false)
    self.Label:SetVisible(false)
    self.TextArea:SetFont("TalkModes:Small")
    self.TextArea:SetDrawLanguageID(false)
--  self.TextArea:SetEditable(false)
    self.Circle = circles.New(CIRCLE_FILLED, 6, 6, 6)
    self.Circle:SetDistance(2)
    self.TextArea:SetTextColor(THEME["White"])
    self.Slider.Knob.Paint = function(this)
        draw.NoTexture()
        surface.SetDrawColor(self:GetColor() || THEME["White"])
        self.Circle()
    end
    self.Slider.Paint = nil
end

function PANEL:Paint(intW, intH)
    draw.RoundedBox(6, 0, 0, intW - self.TextArea:GetSize() - 4, 12, THEME["Background"])
end
vgui.Register("TalkModes.Slider", PANEL, "DNumSlider")

--PATH addons/talk-modes/lua/talk_modes/vgui/elements/cl_switch.lua:
local THEME = TalkModes.Client.ActiveTheme
local circles = include("talk_modes/vgui/libs/cl_circles.lua")

local PANEL = {}
AccessorFunc(PANEL, "Value", "Value", FORCE_BOOL)

function PANEL:Init()
    self:SetSize(100, 32)
    self:SetText("")
    self:SetValue(false)

    self.circle = self:Add("DButton")
    self.circle:SetSize(20, 20)
    self.circle:SetPos(0, 5)
    self.circle:SetText("")
    self.circle.func = circles.New(CIRCLE_FILLED, 10, 10, 10)
    self.circle.func:SetDistance(2)
    self.circle.Paint = function()
        draw.NoTexture()
        surface.SetDrawColor((self:GetValue() && self.colGreen) || self.colRed)
        self.circle.func()
    end

    self.circle.DoClick = function()
        self:SetValue(!self:GetValue())
    end

    self.colGreen = Color(39, 174, 96)
    self.colRed = Color(192, 57, 43)
    self.intOffsetX = 0
end

function PANEL:Paint(intW, intH)
    draw.RoundedBox(10, 0, 6, 60, 20, THEME["Background"])
    draw.SimpleText(self:GetValue() && "ON" || "OFF", "TalkModes:Small", intW, intH/2, THEME["White"], TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

    self.intOffsetX = Lerp(FrameTime() * 10, self.intOffsetX, self:GetValue() && 60 - 20 || 0)
    self.circle:SetPos(self.intOffsetX, 5)
end

vgui.Register("TalkModes.Switch", PANEL, "EditablePanel")

--PATH addons/tebexgmod/lua/autorun/tebex_init.lua:
-- Short and sweet
if SERVER then
	include( "tebex/init.lua" )
end

--PATH addons/the_perfect_training_system/lua/diablos_training/languages/training_dutch.lua:
Diablos.TS.Languages.AvailableLanguages["dutch"] = {

	-- Global data
	lbs = "lbs",
	kg = "kg",
	yes = "JA",
	no = "NEE",
	andStr = "en",
	active = "ACTIEF",
	training = "TRAINING",
	beginning = "Begin:",
	ending = "Einde:",
	leaveTraining = "Stop de training:",
	second = "seconde",
	seconds = "seconden",
	minute = "minuut",
	minutes = "minuten",
	hour = "uur",
	hours = "uur",
	day = "dag",
	days = "dagen",
	week = "week",
	weeks = "weken",
	month = "maand",
	months = "maanden",
	year = "jaar",
	years = "jaren",
	key = "rep",
	keys = "reps",
	free = "GRATIS",

	-- Home tips
	home = "Thuis",
	trainingStatistics = "TRAININGS STATISTIEKEN",
	levelProgression = "Level voortgang",
	captionFine = "Spierscheur",
	captionShouldTrain = "Tijd om te trainen",
	captionMuscleLoss = "Verlies van spiermassa",
	staminaBenefit = "Uithoudingsvermogen",
	staminaMuscle = "Dij",
	runningspeedBenefit = "Maximale loopsnelheid",
	runningspeedMuscle = "Kuit",
	strengthBenefit = "Kracht",
	strengthMuscle = "Schouder, Trapezius & Bovenarm",
	attackspeedBenefit = "Aanvalssnelheid",
	attackspeedMuscle = "Voorarm",

	-- Personal statistics

	currentLevel = "Level %u",
	xpPoint = "XP: %u",

	-- Global statistics

	globalStatistics = "Algemene statistieken",
	onlineStatistics = "Statistieken voor online spelers",
	updateSelection = "VERNIEUW (%u geselecteerd)",
	resetPlayerData = "SPELER GEGEVENS RESETTEN",
	resetEntityData = "ENTITY GEGEVENS RESETTEN",
	peopleSelected = "Geselecteerde personen: %s",
	peopleSelectedTip = "Je kan enkele trainingsparameters instellen voor personen die je geslecteerd hebt.",


	-- Training times part

	trainingTimes = "TRAININGS MOMENTEN",
	trainingAdv = "Soms moet je je spieren laten rusten, maar te lang wachten kan verlies aan spiermassa veroorzaken.",
	muscleRest = "Rust",
	losingMuscle = "Spierverlies",
	waitUntil = "Je wacht best tot",
	secondsRemaining = "%d seconden over",
	needTrainBeforeLosingMuscle = "Je moet trainen voor:",
	neverTrained = "Nog nooit getraind",
	freeToWorkout = "Je mag deze spier trainen!",
	currentlyLosing = "Je bent spiermassa aan het verliezen!",
	yourChoice = "Jouw keuze",
	trainNow = "Start de training",


	-- XP/Level table

	levels = "Levels",
	level = "Level",
	xp = "XP",
	percentage = "Percentage",
	undefined = "Onbepaald",
	lastTraining = "Laatste training",

	-- Global trainings

	trainingWillBegin = "De training begint binnen %u seconden",
	trainingEndsIn = "De training stopt binnen %u seconden",
	currentlyUsingMachine = "Iemand is deze machine al aan het gebruiken!",
	leftMachine = "Je bent gestopt met trainen. Je kan vanaf nu opnieuw proberen!",
	farFromMachine = "Je bent te ver van de machine weg om te trainen!",
	notAllowedJob = "Dit job tillader dig ikke at træne!",

	-- Admin data

	setTo = "Set %s op",
	confirmationBox = "BEVESTIGINGSVAK",
	areYouSure = "Ben je zeker dat je dit wilt doen?",

	-- Weigh balance data


	weighBalanceUse = "Druk USE om informatie te krijgen",
	weighBalanceCantSee = "Statistieken zijn vertrouwlijk",
	weighBalanceTipL1 = "GELIEVE OP DE",
	weighBalanceTipL2 = "WEEGSCHAAL TE STAAN",
	weighBalanceTipL3 = "VOOR STATISTIEKEN",

	-- Turnstile data

	turnstileNeedBadge = "Je moet je pas gebruiken om toegang te krijgen!",

	-- Badge data

	activebadge = "Actieve pas",
	neverSubscribed = "Nog nooit geabonneerd",
	badgeSubscription = "Pas abonnement",
	expirationDate = "Vervaldatum",
	expired = "Vervallen",
	previousSub = "Vorig abonnement",

	-- Stamina data

	stamina = "Conditie",
	runSpeed = "Loopsnelheid",
	timeMaxSpeed = "Uithoudingsvermogen",

	-- Running speed data

	runningspeed = "Loopsnelheid",

	-- Treadmill data

	treadmillDrawLeft = "%u seconden over",
	treadmillDrawSomeone = "Iemand is aan het trainen!",
	treadmillDrawCanUse = "GEBRUIKSVRIJ",
	treadmillCurSpeed = "Huidige snelheid",
	treadmillFrameTitle = "LOOPBAND",
	treadmillChooseExerciceTip1 = "Spam de vooruit-toets om sneller te lopen",
	treadmillChooseExerciceTip2 = "De punten die je op het einde verdient zijn afhankelijk van de snelheid waaraan je loopt",
	quickExerciceSpeed = "Snelle oefening gebaseerd op snelheid",
	longExerciceStamina = "Lange oefening gebaseerd op conditie",
	runningTime = "Tijd",
	increaseSpeed = "Verhoog snelheid",
	decreaseSpeed = "Verlaag snelhied",
	needFasterTreadmill = "Je moet sneller op de vooruit-toets drukken",

	-- Strength data

	strength = "Kracht",

	-- Dumbbell data

	dumbbellDraw = "Halter",
	dumbbellFrameTitle = "HALTER",
	dumbbellChooseExerciceTip1 = "Druk op de juiste knop op het juiste moment",
	dumbbellChooseExerciceTip2 = "De punten die je op het einde verdient zijn afhankelijk van het aantal juist getimede drukken",

	-- Attack speed data

	attackspeed = "Attack speed",

	-- Punching ball data

	punchingHitDamage = "%u rode punten geraakt",
	punchingFrameTitle = "BOXBAL",
	punchingChooseExerciceTip1 = "Sla op de rode punten",
	punchingChooseExerciceTip2 = "De punten die je op het einde verdient zijn afhankelijk van het aantal geraakte rode punten",

	-- Card reader data

	cardReaderTitle = "KAARTLEZER",
	approachBadge = "Je moet de terminal naderen met je fitness pas!",
	becomeOwner = "Je bent de eigenaar van de terminal geworden!",
	someoneElseOwner = "Iemand anders is al de eigenaar van deze terminal!",

	cardReaderOwnerAdd = "TOEVOEGEN",
	cardReaderOwnerRemove = "VERWIJDEREN",
	cardReaderApply = "WIJZIGINGEN OPSLAAN",
	cardReaderBadgePrice = "Prijs van de pas",
	cardReaderPurchaseSub = "KOOP EEN ABONNEMENT",
	cardReaderPurchaseSubTip1 = "Met een abonnement kan je je pas gebruiken bij de ingang.",
	cardReaderFullyRecharged = "Je abonnement is al volledig herladen! Vervalt om %s",

	cardReaderGiveCredit = "GEEF EEN PUNT",
	cardReaderGiveCreditTip1 = "Je staat op het punt de speler voor jou een punt te geven",
	cardReaderGiveCreditTip2 = "Hierdoor kan de speler éénmaal binnen.",
	cardReaderGiveCreditBtn = "GEEF PUNT",
	cardReaderGiveAlreadyCredit = "Je kan geen punt geven aan iemand die al een punt heeft!",
	cardReaderGiveAlreadySubscribed = "Je kan geen punt geven aan iemand die al een geldig abonnement heeft!",


	cardReaderEditTerminal = "BEWERKT DE TERMINAL",
	cardReaderEditTerminalTip1 = "Je kan sommige parameters van de terminal wijzigen, zoals de prijs van een abonnement of de mede-eigenaars.",
	cardReaderEditTerminalTip2 = "Mede-eigenaars zijn er om het geld te delen dat je verdient van abonnementen", "Diablos:Font:TS:25",
	cardReaderEditTerminalSetPrice = "De prijs kan variëren van %s tot %s",


	-- Notify player

	alreadyTrained = "Je hebt deze spieren onlangs getraint, gelieve terug te komen binnen %s",
	needMoreLevel = "Je moet minstens level %u zijn om dit te kunnen gebruiken!",
	tooEasy = "Deze machine is te gemakkelijk voor jouw level!",
	endTraining = "De training is beëindigd.",
	xpAdded = "Je hebt %u punten gewonnen!",
	newLevel = "Je bent nu level %u!",
	lossOfTraining = "Je verliest spiermassa door een tekort aan training van deze spiergroep: %s",
	sportBadgeVerified = "Je abonnement is gecheckt",
	sportBadgeInvalid = "Je abonnement is ongeldig.",
	subDataUpdated = "Je hebt de gegevens van je pas abonnement vernieuwt",
	subPurchased = "Je hebt %s gekregen omdat %s een abonnement gekocht heeft!",
	subRenewed = "Je hebt je abonnement vernieuwt!",
	subNotEnoughMoney = "Je hebt niet genoeg geld om een abonnement te kopen!",
	creditGiven = "Je hebt een punt gegeven!",
	creditReceived = "Je hebt een punt gekregen!",
	entitiesUpdated = "Training entity gegevens zijn vernieuwd!",
	entitiesRemoved = "De entities zijn verwijderd en de gegevens zijn gewist!",
	playerDataRemoved = "De gegevens van de spelers zijn gewist!",
	playerDataUpdated = "Gegevens vernieuwt met jouw waarde!",

}
--PATH addons/the_perfect_training_system/lua/diablos_training/client/cl_keys.lua:
/*---------------------------------------------------------------------------
	Get the bind name from:
        - inEnum: the IN enumeration
---------------------------------------------------------------------------*/

function Diablos.TS:GetBindReference(inEnum)
    local bindResult
    if inEnum == IN_ATTACK then
        bindResult = "attack"
    elseif inEnum == IN_JUMP then
        bindResult = "jump"
    elseif inEnum == IN_DUCK then
        bindResult = "duck"
    elseif inEnum == IN_FORWARD then
        bindResult = "forward"
    elseif inEnum == IN_BACK then
        bindResult = "back"
    elseif inEnum == IN_USE then
        bindResult = "use"
    elseif inEnum == IN_CANCEL then
        bindResult = ""
    elseif inEnum == IN_LEFT then
        bindResult = "left"
    elseif inEnum == IN_RIGHT then
        bindResult = "right"
    elseif inEnum == IN_MOVELEFT then
        bindResult = "moveleft"
    elseif inEnum == IN_MOVERIGHT then
        bindResult = "moveright"
    elseif inEnum == IN_ATTACK2 then
        bindResult = "attack2"
    elseif inEnum == IN_RUN then
        bindResult = "speed"
    elseif inEnum == IN_RELOAD then
        bindResult = "reload"
    elseif inEnum == IN_ALT1 then
        bindResult = "alt1"
    elseif inEnum == IN_ALT2 then
        bindResult = "alt2"
    elseif inEnum == IN_SCORE then
        bindResult = "showscores"
    elseif inEnum == IN_SPEED then
        bindResult = "speed"
    elseif inEnum == IN_WALK then
        bindResult = "walk"
    elseif inEnum == IN_ZOOM then
        bindResult = "zoom"
    elseif inEnum == IN_WEAPON1 then
        bindResult = ""
    elseif inEnum == IN_WEAPON2 then
        bindResult = ""
    elseif inEnum == IN_BULLRUSH then
        bindResult = ""
    elseif inEnum == IN_GRENADE1 then
        bindResult = "grenade1"
    elseif inEnum == IN_GRENADE2 then
        bindResult = "grenade2"
    end

    return bindResult
end

/*---------------------------------------------------------------------------
    Get the key name from:
        - inEnum: the IN enumeration

    This will check the bind reference from inEnum, then get the first key found with that binding for the client
    
    | Example usage:Diablos.TS:GetKeyNameReference(IN_USE)
        | Calls Diablos.TS:GetBindReference(IN_USE) and returns "use"
        | Calls input.LookupBinding("use") and returns "e"
        | Returns "e"
---------------------------------------------------------------------------*/

function Diablos.TS:GetKeyNameReference(inEnum)
    local keyNameResult = input.LookupBinding(Diablos.TS:GetBindReference(inEnum))
    return keyNameResult
end


/*---------------------------------------------------------------------------
    Get the KEY_ enumeration from a keyname

	| Example usage: Diablos.TS:GetKeyReference(Diablos.TS:GetKeyNameReference(IN_RELOAD))
		| Calls Diablos.TS:GetKeyNameReference(IN_RELOAD) and returns "reload"
		| Calls input.LookupBinding("reload") and returns "r"
		| Calls Diablos.TS:GetKeyReference("r")
		| In the keyRef table, r has a value of KEY_R
		| Returns KEY_R
---------------------------------------------------------------------------*/

local keyRef = {
	["0"] = KEY_0,
	["1"] = KEY_1,
	["2"] = KEY_2,
	["3"] = KEY_3,
	["4"] = KEY_4,
	["5"] = KEY_5,
	["6"] = KEY_6,
	["7"] = KEY_7,
	["8"] = KEY_8,
	["9"] = KEY_9,
	["a"] = KEY_A,
	["b"] = KEY_B,
	["c"] = KEY_C,
	["d"] = KEY_D,
	["e"] = KEY_E,
	["f"] = KEY_F,
	["g"] = KEY_G,
	["h"] = KEY_H,
	["i"] = KEY_I,
	["j"] = KEY_J,
	["k"] = KEY_K,
	["l"] = KEY_L,
	["m"] = KEY_M,
	["n"] = KEY_N,
	["o"] = KEY_O,
	["p"] = KEY_P,
	["q"] = KEY_Q,
	["r"] = KEY_R,
	["s"] = KEY_S,
	["t"] = KEY_T,
	["u"] = KEY_U,
	["v"] = KEY_V,
	["w"] = KEY_W,
	["x"] = KEY_X,
	["y"] = KEY_Y,
	["z"] = KEY_Z,
}

function Diablos.TS:GetKeyReference(keyName)
	keyName = string.lower(keyName)
	return keyRef[keyName]
end
--PATH addons/the_perfect_training_system/lua/diablos_training/vgui/cl_cardreader.lua:
function Diablos.TS:OpenCardReaderPlayerPanel(ply, ent, subPrice)

	local frame = vgui.Create("DFrame")
	frame:SetSize(800, 350)
	frame:DockPadding(0, 0, 0, 0)
	frame:Center()
	frame:SetTitle("")
	frame:SetDraggable(false)
	frame:ShowCloseButton(false)
	frame.Paint = function(s, w, h)
		if Diablos.TS.Colors.Blurs then Derma_DrawBackgroundBlur(s, 1) end
		surface.SetDrawColor(Diablos.TS.Colors.Frame) surface.DrawRect(0, 0, w, h)
	end

	frame:MakePopup()

	local header = vgui.Create("DPanel", frame)
	header:Dock(TOP)
	header:DockMargin(0, 0, 0, 0)
	header:SetTall(40)
	header.Paint = function(s, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.FrameLeft) surface.DrawRect(0, 0, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.Header) surface.DrawRect(0, h - 4, w, 4)

		draw.SimpleText(string.format("%s - %s", Diablos.TS:GetLanguageString("cardReaderTitle"), Diablos.TS:GetLanguageString("cardReaderPurchaseSub")), "Diablos:Font:TS:30", 5, (h - 4) / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end


	local closeButton = vgui.Create("DButton", header)
	closeButton:Dock(RIGHT)
	closeButton:SetText("")
	closeButton:SetWide(40)
	closeButton.Paint = function(s, w, h)
		local size = h * 0.8
		local curColor = Diablos.TS:PaintFunctions(s, color_white, Diablos.TS.Label, Diablos.TS.LabelHovered)
		surface.SetDrawColor(curColor)
		surface.SetMaterial(Diablos.TS.Materials.close)
		surface.DrawTexturedRect(w / 2 - size / 2, (h - 4) / 2 - size / 2, size, size)
	end

	closeButton.DoClick = function(s)
		frame:Close()
	end

	local docker = vgui.Create("DPanel", frame)
	docker:Dock(FILL)
	docker:DockPadding(10, 10, 10, 10)
	docker:DockMargin(0, 0, 0, 0)
	docker.Paint = function(s, w, h) end

	local subDate = ply:TSGetTrainingSubscription()

	local explanationPanel = vgui.Create("DPanel", docker)
	explanationPanel:Dock(TOP)
	explanationPanel:DockPadding(0, 0, 0, 0)
	explanationPanel:DockMargin(0, 0, 0, 10)
	explanationPanel:SetTall(240)
	explanationPanel.Paint = function(s, w, h)
		draw.SimpleText(Diablos.TS:GetLanguageString("cardReaderPurchaseSubTip1"), "Diablos:Font:TS:30", w / 2, 0, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

		local sizeIcon = 60
		local priceText = Diablos.TS:GetCurrencyFormatType(subPrice)
		if priceText == 0 then
			priceText = Diablos.TS:GetLanguageString("free")
		end

		surface.SetFont("Diablos:Font:TS:45:B")
		local sizexprice = surface.GetTextSize(priceText)
		local sizetotal = sizeIcon + sizexprice

		draw.SimpleText(priceText, "Diablos:Font:TS:45:B", w / 2 - sizetotal / 2 + sizeIcon + 5, 40 + sizeIcon / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)


		surface.SetDrawColor(color_white)
		surface.SetMaterial(Diablos.TS.Materials.price)
		surface.DrawTexturedRect(w / 2 - sizetotal / 2, 40, sizeIcon, sizeIcon)

		sizeIcon = 100 -- Middle arrow size

		-- Left side
		local dateText
		if subDate == 0 then
			dateText = Diablos.TS:GetLanguageString("neverSubscribed")
		else
			dateText = os.date(Diablos.TS:GetOSFormat(), math.max(subDate, os.time()))
			if not ply:TSHasTrainingSubscription() then
				local previousSubText = string.format("%s:", Diablos.TS:GetLanguageString("previousSub"))
				surface.SetFont("Diablos:Font:TS:25:I")
				local sizexprevioussub = surface.GetTextSize(previousSubText)

				draw.SimpleText(previousSubText, "Diablos:Font:TS:25:I", 10, 160 + sizeIcon / 2 + 5, Diablos.TS.Colors.bl, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
				draw.SimpleText(os.date(Diablos.TS:GetOSFormat(), subDate), "Diablos:Font:TS:25:I", 10 + sizexprevioussub + 5, 160 + sizeIcon / 2 + 5 + 1, Diablos.TS.Colors.rl, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			end
		end

		draw.SimpleText(dateText, "Diablos:Font:TS:45", 10, 160, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

		-- Right side
		local timeAdded = Diablos.TS.SubTime * 60 * 60
		local niceTimeAdded = Diablos.TS:NiceTimeFormat(timeAdded)
		local newDate = os.date(Diablos.TS:GetOSFormat(), math.max(os.time(), subDate) + timeAdded)
		draw.SimpleText(newDate, "Diablos:Font:TS:45", w - 10, 160, Diablos.TS.Colors.Label, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)


		-- Middle arrow

		surface.SetMaterial(Diablos.TS.Materials.rightArrow)
		surface.DrawTexturedRect(w / 2 - sizeIcon / 2, 160 - sizeIcon / 2, sizeIcon, sizeIcon)


		draw.SimpleText(niceTimeAdded, "Diablos:Font:TS:30:I", w / 2, 160 + sizeIcon / 2 + 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end

	if ply:TSCanPurchaseTrainingSubscription() then

		local apply = vgui.Create("DButton", docker)
		apply:Dock(TOP)
		apply:DockMargin(0, 0, 0, 0)
		apply:SetText(Diablos.TS:GetLanguageString("cardReaderPurchaseSub"))
		apply:SetFont("Diablos:Font:TS:35")
		apply:SetTall(40)
		apply.Paint = function(s, w, h)
			local curColor = Diablos.TS:PaintFunctions(s, Diablos.TS.Label, Diablos.TS.LabelHovered, Diablos.TS.LabelDown)
			s:SetTextColor(curColor)
			surface.SetDrawColor(Diablos.TS.Colors.g) surface.DrawRect(0, 0, w, h)
		end
		apply.DoClick = function()
			net.Start("TPTSA:PurchaseSub")
				net.WriteEntity(ent)
			net.SendToServer()
			frame:Close()
		end

	end
end

/*---------------------------------------------------------------------------
	Give a credit
---------------------------------------------------------------------------*/

function Diablos.TS:OpenCardReaderGivePanel(ply, otherPlayer)

	local frame = vgui.Create("DFrame")
	frame:SetSize(700, 370)
	frame:DockPadding(0, 0, 0, 0)
	frame:Center()
	frame:SetTitle("")
	frame:SetDraggable(false)
	frame:ShowCloseButton(false)
	frame.Paint = function(s, w, h)
		if Diablos.TS.Colors.Blurs then Derma_DrawBackgroundBlur(s, 1) end
		surface.SetDrawColor(Diablos.TS.Colors.Frame) surface.DrawRect(0, 0, w, h)
	end

	frame:MakePopup()

	local header = vgui.Create("DPanel", frame)
	header:Dock(TOP)
	header:DockMargin(0, 0, 0, 0)
	header:SetTall(40)
	header.Paint = function(s, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.FrameLeft) surface.DrawRect(0, 0, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.Header) surface.DrawRect(0, h - 4, w, 4)

		draw.SimpleText(string.format("%s - %s", Diablos.TS:GetLanguageString("cardReaderTitle"), Diablos.TS:GetLanguageString("cardReaderGiveCredit")), "Diablos:Font:TS:30", 5, (h - 4) / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end


	local closeButton = vgui.Create("DButton", header)
	closeButton:Dock(RIGHT)
	closeButton:SetText("")
	closeButton:SetWide(40)
	closeButton.Paint = function(s, w, h)
		local size = h * 0.8
		local curColor = Diablos.TS:PaintFunctions(s, color_white, Diablos.TS.Label, Diablos.TS.LabelHovered)
		surface.SetDrawColor(curColor)
		surface.SetMaterial(Diablos.TS.Materials.close)
		surface.DrawTexturedRect(w / 2 - size / 2, (h - 4) / 2 - size / 2, size, size)
	end

	closeButton.DoClick = function(s)
		frame:Close()
	end

	local docker = vgui.Create("DPanel", frame)
	docker:Dock(FILL)
	docker:DockPadding(10, 10, 10, 10)
	docker:DockMargin(0, 0, 0, 0)
	docker.Paint = function(s, w, h) end

	local explanationPanel = vgui.Create("DPanel", docker)
	explanationPanel:Dock(TOP)
	explanationPanel:DockPadding(0, 0, 0, 0)
	explanationPanel:DockMargin(0, 0, 0, 10)
	explanationPanel:SetTall(260)
	explanationPanel.Paint = function(s, w, h)
		draw.SimpleText(Diablos.TS:GetLanguageString("cardReaderGiveCreditTip1"), "Diablos:Font:TS:30", w / 2, 0, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		draw.SimpleText(Diablos.TS:GetLanguageString("cardReaderGiveCreditTip2"), "Diablos:Font:TS:25", w / 2, 30, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

		local sizey = 150
		local sizex = sizey * 742 / 529
		local posx = 0
		local posy = 80

		surface.SetDrawColor(color_white)

		-- Left side
		surface.SetMaterial(Diablos.TS.Materials.sportbadgeRecto)
		surface.DrawTexturedRect(posx, posy, sizex, sizey)

		surface.SetMaterial(Diablos.TS.Materials.zero)
		surface.DrawTexturedRect(posx + sizex - 30, posy + sizey - 30, 60, 60)

		-- Right side
		posx = w - sizex - 30

		surface.SetMaterial(Diablos.TS.Materials.sportbadgeRecto)
		surface.DrawTexturedRect(posx, posy, sizex, sizey)

		surface.SetMaterial(Diablos.TS.Materials.one)
		surface.DrawTexturedRect(posx + sizex - 30, posy + sizey - 30, 60, 60)

		-- Middle arrow
		sizex = 80
		sizey = 80
		posx = w / 2 - sizex / 2
		posy = posy + sizey / 2

		surface.SetMaterial(Diablos.TS.Materials.rightArrow)
		surface.DrawTexturedRect(posx, posy, sizex, sizey)
	end


	local apply = vgui.Create("DButton", docker)
	apply:Dock(TOP)
	apply:DockMargin(0, 0, 0, 0)
	apply:SetText(Diablos.TS:GetLanguageString("cardReaderGiveCreditBtn"))
	apply:SetFont("Diablos:Font:TS:35")
	apply:SetTall(40)
	apply.Paint = function(s, w, h)
		local curColor = Diablos.TS:PaintFunctions(s, Diablos.TS.Label, Diablos.TS.LabelHovered, Diablos.TS.LabelDown)
		s:SetTextColor(curColor)
		surface.SetDrawColor(Diablos.TS.Colors.g) surface.DrawRect(0, 0, w, h)
	end
	apply.DoClick = function()
		net.Start("TPTSA:GiveCreditSub")
			net.WriteEntity(otherPlayer)
		net.SendToServer()
		frame:Close()
	end
end


/*---------------------------------------------------------------------------
	Edit terminal data
---------------------------------------------------------------------------*/

function Diablos.TS:OpenCardReaderEditPanel(ply, ent, subPrice, owners)

	local frame = vgui.Create("DFrame")
	frame:SetSize(900, 360)
	frame:DockPadding(0, 0, 0, 0)
	frame:Center()
	frame:SetTitle("")
	frame:SetDraggable(false)
	frame:ShowCloseButton(false)
	frame.Paint = function(s, w, h)
		if Diablos.TS.Colors.Blurs then Derma_DrawBackgroundBlur(s, 1) end
		surface.SetDrawColor(Diablos.TS.Colors.Frame) surface.DrawRect(0, 0, w, h)
	end

	frame:MakePopup()

	local header = vgui.Create("DPanel", frame)
	header:Dock(TOP)
	header:DockMargin(0, 0, 0, 0)
	header:SetTall(40)
	header.Paint = function(s, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.FrameLeft) surface.DrawRect(0, 0, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.Header) surface.DrawRect(0, h - 4, w, 4)

		draw.SimpleText(string.format("%s - %s", Diablos.TS:GetLanguageString("cardReaderTitle"), Diablos.TS:GetLanguageString("cardReaderEditTerminal")), "Diablos:Font:TS:30", 5, (h - 4) / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end


	local closeButton = vgui.Create("DButton", header)
	closeButton:Dock(RIGHT)
	closeButton:SetText("")
	closeButton:SetWide(40)
	closeButton.Paint = function(s, w, h)
		local size = h * 0.8
		local curColor = Diablos.TS:PaintFunctions(s, color_white, Diablos.TS.Label, Diablos.TS.LabelHovered)
		surface.SetDrawColor(curColor)
		surface.SetMaterial(Diablos.TS.Materials.close)
		surface.DrawTexturedRect(w / 2 - size / 2, (h - 4) / 2 - size / 2, size, size)
	end

	closeButton.DoClick = function(s)
		frame:Close()
	end

	local docker = vgui.Create("DPanel", frame)
	docker:Dock(FILL)
	docker:DockPadding(10, 10, 10, 10)
	docker:DockMargin(0, 0, 0, 0)
	docker.Paint = function(s, w, h) end

	local explanationPanel = vgui.Create("DPanel", docker)
	explanationPanel:Dock(TOP)
	explanationPanel:DockPadding(0, 0, 0, 0)
	explanationPanel:DockMargin(0, 0, 0, 10)
	explanationPanel:SetTall(70)
	explanationPanel.Paint = function(s, w, h)
		draw.SimpleText(Diablos.TS:GetLanguageString("cardReaderEditTerminalTip1"), "Diablos:Font:TS:30", w / 2, 0, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		draw.SimpleText(Diablos.TS:GetLanguageString("cardReaderEditTerminalTip2"), "Diablos:Font:TS:25", w / 2, 30, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end

	-- [[ Sub price ]] --

	local subPricePanel = vgui.Create("DPanel", docker)
	subPricePanel:Dock(TOP)
	subPricePanel:DockPadding(0, 0, 0, 0)
	subPricePanel:DockMargin(0, 0, 0, 10)
	subPricePanel:SetTall(40)
	subPricePanel.Paint = function(s, w, h)
	end

	local subBadgePrice = vgui.Create("DLabel", subPricePanel)
	subBadgePrice:Dock(LEFT)
	subBadgePrice:SetText(Diablos.TS:GetLanguageString("cardReaderBadgePrice"))
	subBadgePrice:SetFont("Diablos:Font:TS:35")
	subBadgePrice:SetWidth(200)

	local subCurrency = vgui.Create("DLabel", subPricePanel)
	subCurrency:Dock(LEFT)
	subCurrency:DockMargin(175, 0, 10, 0)
	subCurrency:SetText(Diablos.TS:GetCurrencySymbol())
	subCurrency:SetFont("Diablos:Font:TS:30")
	subCurrency:SetWidth(20)


	local subPriceEntry = vgui.Create("DNumberWang", subPricePanel)
	subPriceEntry:Dock(LEFT)
	subPriceEntry:DockMargin(0, 0, 0, 0)
	subPriceEntry:SetMinMax(Diablos.TS.SubMinPrice, Diablos.TS.SubMaxPrice)
	subPriceEntry:SetValue(subPrice)
	subPriceEntry:SetFont("Diablos:Font:TS:35")
	subPriceEntry:SetWide(100)
	subPriceEntry.Paint = function(s, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.g)
		surface.DrawRect(0, 0, w, h)
		s:DrawTextEntryText(Diablos.TS.Colors.Label, Diablos.TS.Colors.LabelHovered, Diablos.TS.Colors.LabelDown)
	end
	subPriceEntry.OnValueChanged = function(s, val)

	end

	local subMinPrice = Diablos.TS:GetCurrencyFormatType(Diablos.TS.SubMinPrice)
	local subMaxPrice = Diablos.TS:GetCurrencyFormatType(Diablos.TS.SubMaxPrice)

	-- If there is a "paid" system
	if subMinPrice != "" and subMaxPrice != "" then
		local subPriceInfo = vgui.Create("DLabel", subPricePanel)
		subPriceInfo:Dock(RIGHT)
		subPriceInfo:SetText(string.format(Diablos.TS:GetLanguageString("cardReaderEditTerminalSetPrice"), subMinPrice, subMaxPrice))
		subPriceInfo:SetFont("Diablos:Font:TS:20:I")
		subPriceInfo:SizeToContents()
	end


	-- [[ Owner panel ]] -- 

	local nbCoach = 0

	local ownerPanel = vgui.Create("DScrollPanel", docker)
	ownerPanel:Dock(TOP)
	ownerPanel:DockPadding(0, 0, 0, 0)
	ownerPanel:DockMargin(0, 0, 0, 10)
	ownerPanel:SetTall(120)
	ownerPanel.Paint = function(s, w, h) end
	local ownerPanelVBar = ownerPanel:GetVBar()
	ownerPanelVBar.Paint = function(s, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.barBackground)
		surface.DrawRect(5, 0, w - 5, h)
	end
	ownerPanelVBar.btnGrip.Paint = function(s, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.barFill)
		surface.DrawRect(5, 0, w - 5, h)
	end
	ownerPanelVBar.btnUp.Paint = function(s, w, h) end
	ownerPanelVBar.btnDown.Paint = function(s, w, h) end

	local plypos = ply:GetPos()

	local playerLine

	for k,v in ipairs(player.GetAll()) do
		if not v:TSIsSportCoach() then continue end
		local isOwner = owners[v]

		if not isOwner and plypos:DistToSqr(v:GetPos()) > 20000 then continue end

		if nbCoach % 4 == 0 then
			playerLine = vgui.Create("DPanel", ownerPanel)
			playerLine:Dock(TOP)
			playerLine:DockMargin(0, 0, 0, 10)
			-- playerLine:DockPadding(10, 10, 10, 10)
			playerLine:SetTall(120)
			playerLine.Paint = function(s, w, h)

			end
		end

		local owner = vgui.Create("DPanel", playerLine)
		owner:Dock(LEFT)
		owner:DockMargin(0, 0, 10, 0)
		owner:SetWide(213)
		owner.Paint = function(s, w, h)
			surface.SetDrawColor(Diablos.TS.Colors.Panel)
			surface.DrawRect(0, 0, w, h)
		end

		local iconSpace = vgui.Create("DPanel", owner)
		iconSpace:Dock(TOP)
		iconSpace:DockPadding(5, 5, 5, 5)
		iconSpace:DockMargin(0, 0, 0, 0)
		iconSpace:SetTall(100)
		iconSpace.Paint = function(s, w, h)
			if IsValid(v) then
				draw.SimpleText(v:Nick(), "Diablos:Font:TS:25", w - 5, h / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
			end
		end

		local icon = vgui.Create("DModelPanel", iconSpace)
		icon:Dock(LEFT)
		icon:SetModel(v:GetModel())
		Diablos.TS:UpdateRenderBounds(icon, 30)

		local ownerButton = vgui.Create("DButton", owner)
		ownerButton:Dock(BOTTOM)
		ownerButton:DockMargin(0, 0, 0, 0)
		ownerButton:SetTall(25)
		if isOwner then
			ownerButton:SetText(Diablos.TS:GetLanguageString("cardReaderOwnerRemove"))
		else
			ownerButton:SetText(Diablos.TS:GetLanguageString("cardReaderOwnerAdd"))
		end
		ownerButton:SetFont("Diablos:Font:TS:25")
		ownerButton.Paint = function(s, w, h)
			local curColor = Diablos.TS:PaintFunctions(s, Diablos.TS.Label, Diablos.TS.LabelHovered, Diablos.TS.LabelDown)
			s:SetTextColor(curColor)

			local colorRedGreen = Diablos.TS.Colors.g
			if owners[v] then
				colorRedGreen = Diablos.TS.Colors.r
			end
			surface.SetDrawColor(colorRedGreen)
			surface.DrawRect(0, 0, w, h)
		end
		ownerButton.DoClick = function(s)
			if owners[v] then
				owners[v] = nil
				ownerButton:SetText(Diablos.TS:GetLanguageString("cardReaderOwnerAdd"))
			else
				owners[v] = true
				ownerButton:SetText(Diablos.TS:GetLanguageString("cardReaderOwnerRemove"))
			end
		end
		nbCoach = nbCoach + 1
	end


	local apply = vgui.Create("DButton", docker)
	apply:Dock(TOP)
	apply:DockMargin(0, 0, 0, 0)
	apply:SetText(Diablos.TS:GetLanguageString("cardReaderApply"))
	apply:SetFont("Diablos:Font:TS:35")
	apply:SetTall(40)
	apply.Paint = function(s, w, h)
		local curColor = Diablos.TS:PaintFunctions(s, Diablos.TS.Label, Diablos.TS.LabelHovered, Diablos.TS.LabelDown)
		s:SetTextColor(curColor)
		surface.SetDrawColor(Diablos.TS.Colors.g) surface.DrawRect(0, 0, w, h)
	end
	apply.DoClick = function()
		local countOwner = table.Count(owners)
		-- Send the new terminal data to the server
		net.Start("TPTSA:SaveSubData")
			net.WriteEntity(ent)
			net.WriteUInt(subPriceEntry:GetValue(), 16)
			net.WriteUInt(countOwner, 8)
			for pl, _ in pairs(owners) do
				net.WriteEntity(pl)
			end
		net.SendToServer()
		frame:Close()
	end
end

/*---------------------------------------------------------------------------
	Called when a player is about to purchase a subscription
	i.e. when taking the training badge and pointing a card reader
---------------------------------------------------------------------------*/

net.Receive("TPTSA:CardReaderPurchase", function(len, _)
	local ply = LocalPlayer()
	local ent = net.ReadEntity()
	if IsValid(ent) then
		local subPrice = net.ReadUInt(16)

		Diablos.TS:OpenCardReaderPlayerPanel(ply, ent, subPrice)
	end
end)

/*---------------------------------------------------------------------------
	Called when a coach is about to edit terminal data
	i.e. when pressing +USE on a card reader
---------------------------------------------------------------------------*/

net.Receive("TPTSA:CardReaderEdit", function(len, _)
	local ply = LocalPlayer()
	local ent = net.ReadEntity()
	if IsValid(ent) then
		local subPrice = net.ReadUInt(16)
		local ownerCount = net.ReadUInt(8)
		local owners = {}
		for i = 1, ownerCount do
			owners[net.ReadEntity()] = true
		end

		Diablos.TS:OpenCardReaderEditPanel(ply, ent, subPrice, owners)
	end
end)

/*---------------------------------------------------------------------------
	Called when a coach is about to give a credit to a player
	i.e. when pressing +USE in front of a player
---------------------------------------------------------------------------*/

net.Receive("TPTSA:CardReaderGive", function(len, _)
	local ply = LocalPlayer()
	local otherPlayer = net.ReadEntity()
	if IsValid(otherPlayer) then
		Diablos.TS:OpenCardReaderGivePanel(ply, otherPlayer)
	end
end)
--PATH addons/the_perfect_training_system/lua/diablos_training/vgui/cl_punchingball.lua:
function Diablos.TS:OpenPunchingPanel(ply, ent)

	local trainingWeight = ent:GetWeight()
	local trainingData = Diablos.TS.PunchingBallSizeEquivalence[trainingWeight]

	local frame = vgui.Create("DFrame")
	frame:SetSize(800, 500)
	frame:DockPadding(0, 0, 0, 0)
	frame:Center()
	frame:SetTitle("")
	frame:SetDraggable(false)
	frame:ShowCloseButton(false)
	frame.Paint = function(s, w, h)
		if Diablos.TS.Colors.Blurs then Derma_DrawBackgroundBlur(s, 1) end
		surface.SetDrawColor(Diablos.TS.Colors.Frame) surface.DrawRect(0, 0, w, h)
	end

	frame:MakePopup()

	local header = vgui.Create("DPanel", frame)
	header:Dock(TOP)
	header:DockMargin(0, 0, 0, 0)
	header:SetTall(40)
	header.Paint = function(s, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.FrameLeft) surface.DrawRect(0, 0, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.Header) surface.DrawRect(0, h - 4, w, 4)

		draw.SimpleText(Diablos.TS:GetLanguageString("punchingFrameTitle"), "Diablos:Font:TS:30", 5, (h - 4) / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end


	local closeButton = vgui.Create("DButton", header)
	closeButton:Dock(RIGHT)
	closeButton:SetText("")
	closeButton:SetWide(40)
	closeButton.Paint = function(s, w, h)
		local size = h * 0.8
		local curColor = Diablos.TS:PaintFunctions(s, color_white, Diablos.TS.Label, Diablos.TS.LabelHovered)
		surface.SetDrawColor(curColor)
		surface.SetMaterial(Diablos.TS.Materials.close)
		surface.DrawTexturedRect(w / 2 - size / 2, (h - 4) / 2 - size / 2, size, size)
	end

	closeButton.DoClick = function(s)
		frame:Close()
	end

	local docker = vgui.Create("DPanel", frame)
	docker:Dock(FILL)
	docker:DockPadding(10, 10, 10, 10)
	docker:DockMargin(0, 0, 0, 0)
	docker.Paint = function(s, w, h)

	end


	local trainingInfo = vgui.Create("DPanel", docker)
	trainingInfo:Dock(TOP)
	trainingInfo:DockPadding(0, 0, 0, 0)
	trainingInfo:DockMargin(0, 0, 0, 10)
	trainingInfo:SetTall(60)
	trainingInfo.Paint = function(s, w, h)
		draw.SimpleText(Diablos.TS:GetLanguageString("punchingChooseExerciceTip1"), "Diablos:Font:TS:30", w / 2, 0, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		draw.SimpleText(Diablos.TS:GetLanguageString("punchingChooseExerciceTip2"), "Diablos:Font:TS:25", w / 2, h, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
	end

	local SIZE_HEIGHT = 310

	local buttonPanel = vgui.Create("DPanel", docker)
	buttonPanel:Dock(TOP)
	buttonPanel:DockPadding(0, 0, 0, 0)
	buttonPanel:DockMargin(0, 0, 0, 10)
	buttonPanel:SetTall(SIZE_HEIGHT)
	buttonPanel.Paint = function(s, w, h) end

	local punchingType = vgui.Create("DPanel", buttonPanel)
	punchingType:Dock(LEFT)
	punchingType:DockMargin(0, 0, 0, 0)
	punchingType:DockPadding(10, 10, 10, 10)
	punchingType:SetWide(200)
	punchingType.Paint = function(s, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.FrameLeft) surface.DrawRect(0, 0, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.Header) surface.DrawRect(0, h - 4, w, 4)

		draw.SimpleText(Diablos.TS:GetLanguageString("yourChoice"), "Diablos:Font:TS:35", w / 2, 5, Diablos.TS.Colors.bl, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

		local weightValue = trainingData.kg
		if Diablos.TS.IsLbs then
			weightValue = trainingData.lbs
		end
		draw.SimpleText(string.format("%u %s", weightValue, Diablos.TS:GetWeightText()), "Diablos:Font:TS:35", w / 2, h - 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)

		local dataSecText = string.format("%u %s", trainingData.time, Diablos.TS:GetLanguageString("seconds"))
		draw.SimpleText(dataSecText, "Diablos:Font:TS:20", w / 2, 45, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end

	local icon = vgui.Create("DModelPanel", punchingType)
	icon:Dock(TOP)
	icon:SetTall(SIZE_HEIGHT)
	icon:SetModel("models/tptsa/punching_ball/punching_ball.mdl")
	icon.Entity:SetBodygroup(2, trainingWeight - 1)
	Diablos.TS:UpdateRenderBounds(icon, 30)

	local otherChoices = vgui.Create("DPanel", buttonPanel)
	otherChoices:Dock(RIGHT)
	otherChoices:DockMargin(0, 0, 0, 0)
	otherChoices:DockPadding(0, 0, 0, 0)
	otherChoices:SetWide(500)
	otherChoices.Paint = function(s, w, h) end


	local horizontalPanel

	local i = 0
	local amountEntitiesShown = 0
	for k,v in ipairs(Diablos.TS.PunchingBallSizeEquivalence) do
		if k == trainingWeight then continue end
		amountEntitiesShown = amountEntitiesShown + 1

		local marginLeft = 80
		if amountEntitiesShown % 3 == 1 then
			horizontalPanel = vgui.Create("DPanel", otherChoices)
			horizontalPanel:Dock(TOP)
			horizontalPanel:DockPadding(0, 0, 0, 0)
			horizontalPanel:DockMargin(0, 0, 0, 0)
			horizontalPanel:SetTall(SIZE_HEIGHT)
			horizontalPanel.Paint = function(s, w, h) end

			i = i + 1
			marginLeft = 0
		end


		local otherPunchingType = vgui.Create("DPanel", horizontalPanel)
		otherPunchingType:Dock(LEFT)
		otherPunchingType:DockPadding(10, 10, 10, 10)
		otherPunchingType:DockMargin(marginLeft, 0, 0, 0)
		otherPunchingType:SetWide(115)
		otherPunchingType:SetTall(SIZE_HEIGHT)
		otherPunchingType.Paint = function(s, w, h)
			surface.SetDrawColor(Diablos.TS.Colors.FrameLeft) surface.DrawRect(0, 0, w, h)
			surface.SetDrawColor(Diablos.TS.Colors.rl) surface.DrawRect(0, h - 4, w, 4)

			local weightValue = v.kg
			if Diablos.TS.IsLbs then
				weightValue = v.lbs
			end
			draw.SimpleText(string.format("%u %s", weightValue, Diablos.TS:GetWeightText()), "Diablos:Font:TS:35", w / 2, h - 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)

			local dataSecText = string.format("%u %s", v.time, Diablos.TS:GetLanguageString("seconds"))
			draw.SimpleText(dataSecText, "Diablos:Font:TS:20", w / 2, 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		end

		local otherIcon = vgui.Create("DModelPanel", otherPunchingType)
		otherIcon:Dock(TOP)
		otherIcon:SetTall(SIZE_HEIGHT)
		otherIcon:SetModel("models/tptsa/punching_ball/punching_ball.mdl")
		otherIcon.Entity:SetBodygroup(2, k - 1)
		Diablos.TS:UpdateRenderBounds(otherIcon, 15)
	end

	local startTraining = vgui.Create("DButton", docker)
	startTraining:Dock(TOP)
	startTraining:DockMargin(0, 0, 0, 0)
	startTraining:SetText(Diablos.TS:GetLanguageString("trainNow"))
	startTraining:SetFont("Diablos:Font:TS:35")
	startTraining:SetTall(50)
	startTraining.Paint = function(s, w, h)
		local curColor = Diablos.TS:PaintFunctions(s, Diablos.TS.Label, Diablos.TS.LabelHovered, Diablos.TS.LabelDown)
		s:SetTextColor(curColor)
		surface.SetDrawColor(Diablos.TS.Colors.g) surface.DrawRect(0, 0, w, h)
	end
	startTraining.DoClick = function(s)
		net.Start("TPTSA:BeginTraining")
			net.WriteEntity(ent)
		net.SendToServer()
		frame:Close()
	end

end


--PATH addons/the_perfect_training_system/lua/diablos_training/vgui/cl_training_stats.lua:
local reliefMaterials = {
	["strength"] = Diablos.TS.Materials.humanBodyReliefStrength,
	["stamina"] = Diablos.TS.Materials.humanBodyReliefStamina,
	["runningspeed"] = Diablos.TS.Materials.humanBodyReliefRunningSpeed,
	["attackspeed"] = Diablos.TS.Materials.humanBodyReliefAttackSpeed,
}

net.Receive("TPTSA:OpenTrainingPanel", function(len, _)
	local ply = LocalPlayer()
	ply.trainingDerma = true
	local idopen

	local frame = vgui.Create("DFrame")
	frame:SetSize(1200, 700)
	frame:DockPadding(0, 0, 0, 0)
	frame:Center()
	frame:SetTitle("")
	frame:SetDraggable(false)
	frame:ShowCloseButton(false)
	frame.Paint = function(s, w, h)
		if Diablos.TS.Colors.Blurs then Derma_DrawBackgroundBlur(s, 1) end
		surface.SetDrawColor(Diablos.TS.Colors.Frame) surface.DrawRect(0, 0, w, h)
	end

	local header = vgui.Create("DPanel", frame)
	header:Dock(TOP)
	header:DockMargin(0, 0, 0, 0)
	header:SetTall(40)
	header.Paint = function(s, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.FrameLeft) surface.DrawRect(0, 0, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.Header) surface.DrawRect(0, h - 4, w, 4)

		draw.SimpleText(Diablos.TS:GetLanguageString("trainingStatistics"), "Diablos:Font:TS:30", 5, (h - 4) / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

	local closeButton = vgui.Create("DButton", header)
	closeButton:Dock(RIGHT)
	closeButton:SetText("")
	closeButton:SetWide(40)
	closeButton.Paint = function(s, w, h)
		local size = h * 0.8
		local curColor = Diablos.TS:PaintFunctions(s, color_white, Diablos.TS.Label, Diablos.TS.LabelHovered)
		surface.SetDrawColor(curColor)
		surface.SetMaterial(Diablos.TS.Materials.close)
		surface.DrawTexturedRect(w / 2 - size / 2, (h - 4) / 2 - size / 2, size, size)
	end

	closeButton.DoClick = function(s)
		frame:Close()
		ply.trainingDerma = false
	end

	local bodies = {}

	local docker = vgui.Create("DPanel", frame)
	docker:Dock(FILL)
	docker:DockPadding(10, 10, 10, 10)
	docker.Paint = function(s, w, h)
	end


	local function changePanel(numPanel)
		docker:Clear()

		local trainings = Diablos.TS:GetTrainings()

		if numPanel == 1 then

			docker.Paint = function(s, w, h)
				draw.SimpleText(Diablos.TS:GetLanguageString("trainingAdv"), "Diablos:Font:TS:25", w / 2, 0, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

				surface.SetDrawColor(color_white)

				local posY = 10 + 60 + 75

				-- Strength lines
				if Diablos.TS:IsTrainingEnabled("strength") then
					surface.DrawLine(250, posY, 460, posY)
				end

				posY = posY + 150 + 30

				-- Stamina lines
				if Diablos.TS:IsTrainingEnabled("stamina") then
					surface.DrawLine(250, posY, 475, posY)
				end

				posY = 10 + 150 + 75

				-- Attack speed lines
				if Diablos.TS:IsTrainingEnabled("attackspeed") then
					surface.DrawLine(w - 250 - 10, posY, 610, posY)
				end

				posY = posY + 150 + 60

				-- Running speed lines
				if Diablos.TS:IsTrainingEnabled("runningspeed") then
					surface.DrawLine(w - 250 - 10, posY, 572, posY)
				end
			end


			local trainingButtonLeft = vgui.Create("DPanel", docker)
			trainingButtonLeft:Dock(LEFT)
			trainingButtonLeft:DockMargin(0, 0, 0, 0)
			trainingButtonLeft:SetWide(250)
			trainingButtonLeft.Paint = function(s, w, h)

			end

			local trainingButtonRight = vgui.Create("DPanel", docker)
			trainingButtonRight:Dock(RIGHT)
			trainingButtonRight:DockMargin(0, 0, 0, 0)
			trainingButtonRight:SetWide(250)
			trainingButtonRight.Paint = function(s, w, h)

			end

			for i = 1, #trainings do
				local typeTraining = string.lower(trainings[i])
				local trainingData = ply:TSGetTrainingInfo(typeTraining)
				local trainingLevel = Diablos.TS:GetTrainingLevel(typeTraining, trainingData.xp)

				local strings = {}
				local parent, marginTop

				table.insert(bodies, {name = typeTraining, date = trainingData.date})

				strings.training = Diablos.TS:GetLanguageString(typeTraining)
				typeTraining = string.lower(typeTraining)
				if typeTraining == "stamina" then
					strings.result = string.format("%u %s", ply:TSGetStaminaTimeDuration(), Diablos.TS:GetLanguageString("seconds"))
					parent = trainingButtonLeft
					marginTop = 30
					if not Diablos.TS:IsTrainingEnabled("strength") then
						marginTop = marginTop + 60 + 150
					end
				elseif typeTraining == "runningspeed" then
					strings.result = string.format("%4.2f %s", Diablos.TS:GetSpeedFromUnit(ply:GetRunSpeed()), Diablos.TS:GetSpeedText())
					parent = trainingButtonRight
					marginTop = 60
					if not Diablos.TS:IsTrainingEnabled("attackspeed") then
						marginTop = marginTop + 150 + 150
					end
				elseif typeTraining == "strength" then
					strings.result = string.format("+%u%%", ply:TSGetStrengthDamage())
					parent = trainingButtonLeft
					marginTop = 60
				elseif typeTraining == "attackspeed" then
					strings.result = string.format("+%u%%", ply:TSGetAttackSpeed())
					parent = trainingButtonRight
					marginTop = 150
				end
				strings.muscle = Diablos.TS:GetLanguageString(typeTraining .. "Muscle")
				strings.benefit = Diablos.TS:GetLanguageString(typeTraining .. "Benefit")

				local trainingPanel = vgui.Create("DButton", parent)
				trainingPanel:Dock(TOP)
				trainingPanel:DockMargin(0, marginTop, 0, 0)
				trainingPanel:SetText("")
				trainingPanel:SetTall(150)
				trainingPanel.Paint = function(s, w, h)
					local curColor = Diablos.TS:PaintFunctions(s, Diablos.TS.Colors.bl, Diablos.TS.Colors.bl2, Diablos.TS.Colors.bl3, true)
					surface.SetDrawColor(curColor)
					surface.DrawRect(0, 0, w, h)

					draw.SimpleText(strings.training, "Diablos:Font:TS:30:B", w / 2, 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
					draw.SimpleText(string.format(Diablos.TS:GetLanguageString("currentLevel"), trainingLevel), "Diablos:Font:TS:25", w / 2, 35, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
					draw.SimpleText(strings.muscle, "Diablos:Font:TS:20:I", w / 2, h / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					draw.SimpleText(strings.benefit, "Diablos:Font:TS:25:I", w / 2, h - 35, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
					draw.SimpleText(strings.result, "Diablos:Font:TS:35:B", w / 2, h - 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
				end
				trainingPanel.DoClick = function(s)
					changePanel(i + 1) -- the first one is home
				end
			end

			local bodyInfos = vgui.Create("DPanel", docker)
			bodyInfos:Dock(FILL)
			bodyInfos:DockMargin(0, 0, 0, 0)
			bodyInfos:SetWide(500)
			bodyInfos.Paint = function(s, w, h)

				local SIZE_BODY_Y = h - 15 - 10
				local SIZE_BODY_X = SIZE_BODY_Y * 1097 / 2246

				surface.SetDrawColor(color_white)
				surface.SetMaterial(Diablos.TS.Materials.humanBody)
				surface.DrawTexturedRect(w / 2 - SIZE_BODY_X / 2, 20, SIZE_BODY_X, SIZE_BODY_Y)

				for _, body in ipairs(bodies) do
					local name = body.name
					if not reliefMaterials[name] then continue end
					local date = body.date

					local nextTrain = date - os.time()
					local losingMuscle = (date + Diablos.TS.RetroTime * 24 * 60 * 60) - os.time()

					local cosTime = math.abs(math.cos(CurTime())) * 255
					local curColor
					-- if this is <= 0 it means you've already lose some muscle
					if (losingMuscle <= 0) then
						curColor = Diablos.TS.Colors.rl
					elseif (nextTrain <= 0) then
						curColor = Diablos.TS.Colors.bl
					elseif nextTrain > 0 then
						curColor = Diablos.TS.Colors.gl
					end
					surface.SetDrawColor(Color(curColor.r, curColor.g, curColor.b, cosTime))
					surface.SetMaterial(reliefMaterials[name])
					surface.DrawTexturedRect(w / 2 - SIZE_BODY_X / 2, 20, SIZE_BODY_X, SIZE_BODY_Y)
				end
			end

			local trainingDataBottom = vgui.Create("DPanel", docker)
			trainingDataBottom:Dock(BOTTOM)
			trainingDataBottom:DockMargin(0, 0, 0, 0)
			trainingDataBottom:DockPadding(10, 0, 10, 0)
			trainingDataBottom:SetTall(120)
			trainingDataBottom.Paint = function(s, w, h)

			end

			local badgeSubPanel = vgui.Create("DPanel", trainingDataBottom)
			badgeSubPanel:Dock(LEFT)
			badgeSubPanel:DockMargin(0, 0, 0, 0)
			badgeSubPanel:SetWide(250)
			badgeSubPanel.Paint = function(s, w, h)
				surface.SetDrawColor(Diablos.TS.Colors.drawColor)
				surface.DrawRect(0, 0, w, h)

				draw.SimpleText(Diablos.TS:GetLanguageString("badgeSubscription"), "Diablos:Font:TS:30:B", w / 2, 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

				local sub = ply:TSGetTrainingSubscription()

				local subDate, subColor
				if sub == 0 then
					subDate = Diablos.TS:GetLanguageString("neverSubscribed")
					subColor = Diablos.TS.Colors.bl
				else
					subDate = os.date(Diablos.TS:GetOSFormat(), sub)
					local expirationDate
					if sub < os.time() then
						subColor = Diablos.TS.Colors.rl
						expirationDate = "expired"
					else
						subColor = Diablos.TS.Colors.gl
						expirationDate = "expirationDate"
					end
					draw.SimpleText(Diablos.TS:GetLanguageString(expirationDate), "Diablos:Font:TS:25:I", w / 2, 45, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
				end

				draw.SimpleText(subDate, "Diablos:Font:TS:25", w / 2, h - 5, subColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
			end
			badgeSubPanel.DoClick = function(s)
				changePanel(i + 1) -- the first one is home
			end

			local captionPanel = vgui.Create("DPanel", trainingDataBottom)
			captionPanel:Dock(RIGHT)
			captionPanel:DockMargin(0, 0, 0, 0)
			captionPanel:SetWide(250)
			captionPanel.Paint = function(s, w, h)
				surface.SetDrawColor(Diablos.TS.Colors.FrameLeft)
				surface.DrawRect(0, 0, w, h)



				local captionPosX = w - 200
				local captionPosY


				captionPosY = 10
				surface.SetDrawColor(Diablos.TS.Colors.gl) surface.DrawRect(captionPosX, captionPosY, 20, 10)
				draw.SimpleText(Diablos.TS:GetLanguageString("captionFine"), "Diablos:Font:TS:25:I", captionPosX + 25, captionPosY + 5, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

				captionPosY = h / 2 - 5
				surface.SetDrawColor(Diablos.TS.Colors.bl) surface.DrawRect(captionPosX, captionPosY, 20, 10)
				draw.SimpleText(Diablos.TS:GetLanguageString("captionShouldTrain"), "Diablos:Font:TS:25:I", captionPosX + 25, captionPosY + 5, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

				captionPosY = h - 10 - 10
				surface.SetDrawColor(Diablos.TS.Colors.rl) surface.DrawRect(captionPosX, captionPosY, 20, 10)
				draw.SimpleText(Diablos.TS:GetLanguageString("captionMuscleLoss"), "Diablos:Font:TS:25:I", captionPosX + 25, captionPosY + 5, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			end

		elseif (numPanel >= 2 and numPanel <= 5) then

			docker.Paint = function(s, w, h)

			end

			local strings = {}
			local typeTraining = trainings[numPanel - 1]

			strings.increase = Diablos.TS:GetLanguageString(typeTraining .. "Benefit")

			local specificAbilities = ply:TSGetSpecificAbilities(typeTraining)
			local trainingTable = Diablos.TS:GetTrainingLevelTable(typeTraining)
			local trainingData = ply:TSGetTrainingInfo(typeTraining)
			local trainingLevel = Diablos.TS:GetTrainingLevel(typeTraining, trainingData.xp)
			local trainingPercentage = Diablos.TS:GetTrainingPercentage(typeTraining, trainingData.xp)

			local trainingTableCount = #trainingTable

			local timeOnPanel = CurTime()

			local trainingPercent = vgui.Create("DPanel", docker)
			trainingPercent:Dock(TOP)
			trainingPercent:DockMargin(50, 0, 50, 10)
			trainingPercent:SetTall(150)
			trainingPercent.time = CurTime()
			trainingPercent.Paint = function(s, w, h)

				-- Body draw

				local SIZE_BODY_Y = h
				local SIZE_BODY_X = SIZE_BODY_Y * 1097 / 2246
				local SIZE_TITLE = 0

				surface.SetDrawColor(color_white)
				surface.SetMaterial(Diablos.TS.Materials.humanBody)
				surface.DrawTexturedRect(w - SIZE_BODY_X, SIZE_TITLE, SIZE_BODY_X, SIZE_BODY_Y)

				for _, body in ipairs(bodies) do
					local name = body.name
					if name != typeTraining then continue end
					if not reliefMaterials[name] then continue end

					surface.SetDrawColor(Diablos.TS.Colors.navbarSelection)
					surface.SetMaterial(reliefMaterials[name])
					surface.DrawTexturedRect(w - SIZE_BODY_X, SIZE_TITLE, SIZE_BODY_X, SIZE_BODY_Y)
				end

				local BAR_SIZE = 500

				draw.SimpleText(Diablos.TS:GetLanguageString("levelProgression"), "Diablos:Font:TS:30", w / 2 - BAR_SIZE / 2 - 20, h / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

				local barPercentWithTime = math.Clamp(0, CurTime() - timeOnPanel, 1)
				Diablos.TS:WriteProgressBar(w / 2 - BAR_SIZE / 2, h / 2, BAR_SIZE, 30, trainingPercentage / 100 * barPercentWithTime)
				draw.SimpleText(string.format("%u%%", math.Round(trainingPercentage, 2)), "Diablos:Font:TS:30", w / 2 + BAR_SIZE / 2 + 30, h / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

				local nextLevel = trainingLevel + 1
				local isLastLevel = false
				if nextLevel > trainingTableCount then
					nextLevel = trainingTableCount
					isLastLevel = true
				end
				if trainingData.xp < trainingTable[1].xp then
					nextLevel = nextLevel - 1
				end

				draw.SimpleText(trainingTable[trainingLevel].xp, "Diablos:Font:TS:30:B", w / 2 - BAR_SIZE / 2, h / 2 + 15 + 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
				if not isLastLevel then
					draw.SimpleText(trainingTable[nextLevel].xp, "Diablos:Font:TS:30:B", w / 2 + BAR_SIZE / 2, h / 2 + 15 + 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
				end

				if s.time + 1 < CurTime() then
					draw.SimpleText(trainingData.xp, "Diablos:Font:TS:30:B", w / 2 - BAR_SIZE / 2 + BAR_SIZE * (trainingPercentage / 100), h / 2 + 15 + 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
				end
			end

			local trainingTabTime = vgui.Create("DPanel", docker)
			trainingTabTime:Dock(TOP)
			trainingTabTime:DockMargin(0, 0, 0, 10)
			trainingTabTime:SetTall(150)

			trainingTabTime.Paint = function(s, w, h)

				-- If you already trained
				if trainingData.date != 0 then

					local diffTimeRest = trainingData.date - os.time()

					local sideCenter = w / 2 - w / 2 / 2

					surface.SetDrawColor(Diablos.TS.Colors.FrameLeft)
					surface.DrawRect(0, 0, w / 2 - 5, h)

					draw.SimpleText(Diablos.TS:GetLanguageString("muscleRest"), "Diablos:Font:TS:30:B", sideCenter, 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)



					if diffTimeRest > 0 then
						draw.SimpleText(Diablos.TS:GetLanguageString("waitUntil"), "Diablos:Font:TS:25", sideCenter, h / 2, Diablos.TS.Colors.gl, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
						draw.SimpleText(os.date(Diablos.TS:GetOSFormat(), trainingData.date), "Diablos:Font:TS:25", sideCenter, h - 30, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
						draw.SimpleText(Diablos.TS:NiceTimeFormat(trainingData.date - os.time(), true), "Diablos:Font:TS:20", sideCenter, h - 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
					else
						draw.SimpleText(Diablos.TS:GetLanguageString("freeToWorkout"), "Diablos:Font:TS:25", sideCenter, h / 2, Diablos.TS.Colors.gl, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					end

					sideCenter = sideCenter + w / 2

					surface.SetDrawColor(Diablos.TS.Colors.FrameLeft)
					surface.DrawRect(w / 2 + 5, 0, w / 2 - 5, h)

					draw.SimpleText(Diablos.TS:GetLanguageString("losingMuscle"), "Diablos:Font:TS:30:B", sideCenter, 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)


					local muscleLossDate = trainingData.date + Diablos.TS.RetroTime * 60 * 60
					local diffTimeLoss = muscleLossDate - os.time()

					if diffTimeLoss > 0 then

						draw.SimpleText(Diablos.TS:GetLanguageString("needTrainBeforeLosingMuscle"), "Diablos:Font:TS:25", sideCenter, h / 2, Diablos.TS.Colors.gl, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
						draw.SimpleText(os.date(Diablos.TS:GetOSFormat(), muscleLossDate), "Diablos:Font:TS:25", sideCenter, h - 30, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
						draw.SimpleText(Diablos.TS:NiceTimeFormat(muscleLossDate - os.time(), true), "Diablos:Font:TS:20", sideCenter, h - 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)

					else
						draw.SimpleText(Diablos.TS:GetLanguageString("currentlyLosing"), "Diablos:Font:TS:25", sideCenter, h / 2, Diablos.TS.Colors.rl, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					end
				else

					surface.SetDrawColor(Diablos.TS.Colors.FrameLeft)
					surface.DrawRect(0, 0, w, h)

					draw.SimpleText(Diablos.TS:GetLanguageString("neverTrained"), "Diablos:Font:TS:40:B", w / 2, h / 2, Diablos.TS.Colors.rl, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				end
			end

			local trainingTabLevels = vgui.Create("DScrollPanel", docker)
			trainingTabLevels:Dock(TOP)
			trainingTabLevels:DockMargin(0, 0, 0, 10)
			trainingTabLevels:SetTall(330)
			trainingTabLevels:GetCanvas():DockPadding(0, 0, 0, 10)
			-- trainingTabLevels:SetVerticalScrollbarEnabled(false)
			local trainingTabLevelsVBar = trainingTabLevels:GetVBar()
			trainingTabLevelsVBar.Paint = function(s, w, h)
				surface.SetDrawColor(Diablos.TS.Colors.barBackground)
				surface.DrawRect(5, 0, w - 5, h)
			end
			trainingTabLevelsVBar.btnGrip.Paint = function(s, w, h)
				surface.SetDrawColor(Diablos.TS.Colors.barFill)
				surface.DrawRect(5, 0, w - 5, h)
			end
			trainingTabLevelsVBar.btnUp.Paint = function(s, w, h) end
			trainingTabLevelsVBar.btnDown.Paint = function(s, w, h) end
			local levelData = "76561198298484274"

			trainingTabLevels.Paint = function(s, w, h)
			end

			local trainingLevelLine

			for k, info in ipairs(trainingTable) do


				if (k - 1) % 4 == 0 then
					trainingLevelLine = vgui.Create("DPanel", trainingTabLevels)
					trainingLevelLine:Dock(TOP)
					trainingLevelLine:DockPadding(0, 0, 0, 0)
					trainingLevelLine:DockMargin(0, 0, 0, 10)
					trainingLevelLine:SetTall(155)
					trainingLevelLine.Paint = function(s, w, h)

					end
				end

				local trainingLevelElem = vgui.Create("DPanel", trainingLevelLine)
				trainingLevelElem:Dock(LEFT)
				trainingLevelElem:DockMargin(0, 0, 10, 0)
				trainingLevelElem:SetWide(250)
				trainingLevelElem.Paint = function(s, w, h)

					if k != trainingLevel then
						surface.SetDrawColor(Diablos.TS.Colors.Panel)
						surface.DrawRect(0, 0, w, h)
					else
						surface.SetDrawColor(Diablos.TS.Colors.bl)
						surface.DrawRect(0, 0, w, h)

						surface.SetDrawColor(Diablos.TS.Colors.Panel)
						for _ = 1, 4 do
							surface.DrawRect(2, 2, w - 4, h - 4)
						end
					end


					local benefitValue
					if typeTraining == "stamina" then
						if specificAbilities then
							info.timeduration = specificAbilities[k].timeduration
						end
						benefitValue = string.format("%u %s", info.timeduration, Diablos.TS:GetLanguageString("seconds"))
					elseif typeTraining == "runningspeed" then
						if specificAbilities then
							info.runspeed = specificAbilities[k].runspeed
						end
						local unitSpeed = ply.TS_JOB_RUN_SPEED + info.runspeed
						benefitValue = string.format("%4.2f %s", Diablos.TS:GetSpeedFromUnit(unitSpeed), Diablos.TS:GetSpeedText())
					elseif typeTraining == "strength" then
						if specificAbilities then
							info.damage = specificAbilities[k].damage
						end
						benefitValue = string.format("%u%%", 100 + info.damage)
					elseif typeTraining == "attackspeed" then
						if specificAbilities then
							info.attackspeed = specificAbilities[k].attackspeed
						end
						benefitValue = string.format("%u%%", 100 + info.attackspeed)
					end
					draw.SimpleText(string.format(Diablos.TS:GetLanguageString("currentLevel"), k), "Diablos:Font:TS:25:B", w / 2, 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
					draw.SimpleText(string.format(Diablos.TS:GetLanguageString("xpPoint"), info.xp), "Diablos:Font:TS:20:I", w / 2, 40, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

					draw.SimpleText(strings.increase, "Diablos:Font:TS:25", w / 2, h - 35, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
					draw.SimpleText(benefitValue, "Diablos:Font:TS:25:B", w / 2, h - 5, Diablos.TS.Colors.Label, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)

				end

			end
		end

		idopen = numPanel

	end

	changePanel(1) -- default panel

	-- Left panel for buttons

	local leftPanel = vgui.Create("DPanel", frame)
	leftPanel:Dock(LEFT)
	leftPanel:SetWide(150)
	leftPanel:DockPadding(0, 10, 0, 0)
	leftPanel:DockMargin(0, 0, 0, 0)
	leftPanel.Paint = function(s, w, h)
		surface.SetDrawColor(Diablos.TS.Colors.FrameLeft) surface.DrawRect(0, 0, w, h)
	end

	-- Assign buttons to the left panel

	local num = 1
	for k, v in ipairs(Diablos.TS.DermaButtons) do
		if k > 1 and not Diablos.TS:IsTrainingEnabled(v.str) then continue end
		local time_anim, end_anim = 0, 0

		local new_k = num

		local panel = vgui.Create("DPanel", leftPanel)
		panel:Dock(TOP)
		panel:DockMargin(0, 0, 0, 0)
		panel:SetTall(50)
		panel.Paint = function(s, w, h)
			if idopen == new_k then
				surface.SetDrawColor(Diablos.TS.Colors.navbarSelection) surface.DrawRect(0, 0, 2, h)
			else
				local curtime = CurTime()
				surface.SetDrawColor(Diablos.TS.Colors.navbarSelection)

				if end_anim != 0 then
					local val = curtime - end_anim
					surface.DrawRect(0, 0, 2 - 8 * val, h)
					if val >= 0.25 then time_anim, end_anim = 0, 0 end
				elseif time_anim != 0 then
					local val = math.min(curtime - time_anim, 1) * 2
					surface.DrawRect(0, 0, math.min(8 * val, 2), h)
				end
			end
		end

		local button = vgui.Create("DButton", panel)
		button:Dock(FILL)
		button:SetText("")
		button.Paint = function(s, w, h)
			local size = 20
			surface.SetDrawColor(color_white)
	        surface.SetMaterial(v.icon)
	        surface.DrawTexturedRect(10, h / 2 - size / 2, size, size)

			local isBold = false
			local font = "Diablos:Font:TS:20"
			if idopen == new_k then
				font = "Diablos:Font:TS:20:B"
				isBold = true
			end

			surface.SetFont(font)
			local textSize = surface.GetTextSize(Diablos.TS:GetLanguageString(v.str))
			if textSize > w - 40 then
				if isBold then
					font = "Diablos:Font:TS:15:B"
				else
					font = "Diablos:Font:TS:15"
				end
			end


			draw.SimpleText(Diablos.TS:GetLanguageString(v.str), font, 40, h / 2, Diablos.TS.Colors.Label, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end
		button.OnCursorEntered = function(s)
			time_anim = CurTime()
		end
		button.OnCursorExited = function(s)
			end_anim = CurTime()
		end
		button.DoClick = function(s)
			if idopen == new_k then return end
			changePanel(new_k)
		end

		num = num + 1
	end

	frame:MakePopup()
end)
--PATH addons/warning_system/lua/warning_system_7452/languages/pl.lua:
WarningSystem7452em.Lang["pl"] = {
	tabs = {
		my_warnings = "Moje ostrzeżenia",
		offline_players = "Wylogowani gracze",
		online_players = "Zalogowani gracze",
		settings = "Opcje",
		statistics = "Statystyki",
	},

	settings_tabs = {
		preset_reasons = "Powów nadania",
		thresholds = "Próg punktowy",
		permissions = "Permisje",
		theme = "Motyw",
		other = "Inne",

		add_this_reason = "Dodaj powód",
		penalty_points_to_reach = "Punkty kary do osiągnięcia",
		add_this_threshold = "Dodaj wagę (próg)",
		save_those_permissions = "Zapisz permisje",
		save_this_theme = "Zapisz motyw dla każdego",
		save_this_config = "Zapisz konfigurację",
	},

	webhooks = {
		new_warning = "Nowe ostrzeżenie",
		warning_removed = "Rozszerzenie usunięte",

		user = "Gracz",
		admin = "Administrator",
		more_info = "Więcej informacji",
	},

	errors = {
		no_access = "Nie masz do tego dostępu",
		reason_too_short = "Zbyt krótki powód",
		reason_too_long = "Zbyt długi powód",
		invalid_key = "Niepoprawny klucz",
	},

	notifs = {
		success = "Sukces",
		error = "Błąd",
		warning = "Ostrzeżenie",
	},

	youve_been_warned = "Dostałeś ostrzeżenie",
	player_been_warned = "Gracz dostał ostrzeżenie",
	player_been_unwarned = "Usunąłeś ostrzeżenie",

	settings_updated = "Zmieniłeś ustawienia",

	awarn_imported = "Ostrzeżenia z AWarn3 załadowane",

	by = "Od",
	reason = "Powód",
	penalty = "Kara",
	date = "Data",
	expiration = "Wygasa",
	duration = "Trwanie",
	preset = "Ustawienie",

	none = "Bral",

	warn = "Ostrzeżenie",

	custom_warning = "Własne ostrzeżenie",

	penalty_points = "Punkty karne",

	warn_this_player = "Nadaj ostrzeżenie",

	search_player_sid64 = "Wyszukaj gracza przez SteamID x64 (7656...)",
	search_player = "Znajdź gracza...",

	x_displayed = "%i pokazani",
	x_online_players = "%i Aktywni gracze",

	total_warnings = "Wszystkie ostrzeżenia",
	total_penalty_points = "Wszystkie punkty karne",
	monthly_warnings = "Miesięczne ostrzeżenie",
	last_warnings = "Ostatnie ostrzeżenie",
	most_warned = "Najczęściej karany",
	staff_leaderboard = "Tabela administracji",
	active_warnings = "Aktywne ostrzeżenia",

	view_more = "Pokaż więcej",

	joins_with_x = "%s dołącza na serwer z %s ostrzeżeniami",

	set_api_key = "Musisz ustawić Steam API key",

	months = {"Sty", "Lut", "Mar", "Kwi", "Maj", "Cze", "Lip", "Sie", "Wrz", "Paź", "Lis", "Gru"}
}

--PATH addons/warning_system/lua/warning_system_7452/shared/networking.lua:
if SERVER then util.AddNetworkString("WarningSystem7452em:7452") end

WarningSystem7452em.NetsList = WarningSystem7452em.NetsList or {}

function WarningSystem7452em:NetReceive(strName, fnCallback)
	WarningSystem7452em.NetsList[strName] = fnCallback
end

function WarningSystem7452em:NetStart(strName, tblToSend, pTo)
	local tbl, iLen = WarningSystem7452em:Compress(tblToSend)

	net.Start("WarningSystem7452em:7452")
		net.WriteString(strName)
		net.WriteUInt(iLen, 32)
		net.WriteData(tbl, iLen)
	if SERVER then
		if pTo and IsValid(pTo) then
			net.Send(pTo)
		else
			net.Broadcast()
		end
	else
		net.SendToServer()
	end
end

net.Receive("WarningSystem7452em:7452", function(_, pSender)
	local strName = net.ReadString()

	-- net delay
	if SERVER then
		pSender.WarningSystem7452emNets = pSender.WarningSystem7452emNets or {}
		if (pSender.WarningSystem7452emNets[strName] or 0) > CurTime() then return end
		pSender.WarningSystem7452emNets[strName] = CurTime() + 0.1
	end

	local iLen = net.ReadUInt(32)
	local tCompressed = net.ReadData(iLen)
	local tblToSend = WarningSystem7452em:Decompress(tCompressed)

	if not WarningSystem7452em.NetsList[strName] then return end

	if SERVER then
		WarningSystem7452em.NetsList[strName](pSender, tblToSend)
	else
		WarningSystem7452em.NetsList[strName](tblToSend)
	end
end)

--PATH addons/warning_system/lua/warning_system_7452/shared/thresholds/chat_mute.lua:
if( not ulx or not FAdmin ) then return end

local THRESHOLD = {}

THRESHOLD.Name = "Chat Mute"

THRESHOLD.Params = {
    { name = "duration", type = "time" },
}

function THRESHOLD:Can()
    return ulx or FAdmin 
end

function THRESHOLD:Execute(pPlayer, ...)
    if( not self:Can() ) then return end

    local tParams = {...}
    local iDuration = tParams[1]

    if( ulx ) then
        RunConsoleCommand("ulx", "mute", "$" .. pPlayer:SteamID(), iDuration)
    
        timer.Create("WarningSystem7452em:Mute:" .. pPlayer:SteamID(), iDuration, 1, function()
            if( not IsValid(pPlayer) ) then return end

            RunConsoleCommand("ulx", "unmute", "$" .. pPlayer:SteamID())
        end)
    elseif ( FAdmin ) then
        RunConsoleCommand("_FAdmin", "mute", pPlayer:UserID(), iDuration)
        
        timer.Create("WarningSystem7452em:Mute:" .. pPlayer:SteamID(), iDuration, 1, function()
            if( not IsValid(pPlayer) ) then return end

            RunConsoleCommand("_FAdmin", "unmute", "$" .. pPlayer:SteamID())
        end)
    end
end

WarningSystem7452em:RegisterThreshold("chat_mute", THRESHOLD)
--PATH addons/warning_system/lua/warning_system_7452/client/hooks.lua:
hook.Add( "OnScreenSizeChanged", "WarningSystem7452em:OnScreenSizeChanged", function()
    if IsValid(WarningSystem7452em.Menu) then
        WarningSystem7452em.Menu:Remove()
    end
end)
--PATH addons/warning_system/lua/warning_system_7452/client/categories/offline_players.lua:
local CATEGORY = {}

CATEGORY.Order = 3
CATEGORY.title = WarningSystem7452em:__("tabs.offline_players")
CATEGORY.icon = Material("materials/warning_system/search.png", "noclamp smooth")

function CATEGORY:isAllowed(pPlayer)
    self.title = WarningSystem7452em:__("tabs.offline_players")

    return WarningSystem7452em:Can(pPlayer, "view_others_warnings")
end

function CATEGORY:onOpen(pnlContent, ...)
    function pnlContent:Paint(iW, iH)
        draw.SimpleText(WarningSystem7452em:__("search_player_sid64"), "WarningSystem7452em:30M", iW * 0.5, iH * 0.47, WarningSystem7452em.CFG.theme.Texts2, 1, 1)
    end

    local txtSearch = vgui.Create("WarningSystem7452em:DTextEntry", pnlContent)
    txtSearch:SetSize(pnlContent:GetWide() * 0.64, pnlContent:GetTall() * 0.07)
    txtSearch:SetPos(pnlContent:GetWide() * 0.15, pnlContent:GetTall() * 0.51)
    txtSearch.txt:SetPlaceholderText("7656...")
    txtSearch.txt:SetNumeric(true)

    local btnSearch = vgui.Create("WarningSystem7452em:DImageButton", pnlContent)
    btnSearch:SetImage("materials/warning_system/arrow_forward.png")
    btnSearch:SetSize(pnlContent:GetTall() * 0.07, pnlContent:GetTall() * 0.07)
    btnSearch:SetPos(pnlContent:GetWide() * 0.8, pnlContent:GetTall() * 0.51)

    local function search()
        if IsValid(WarningSystem7452em.Menu) then
            WarningSystem7452em.Menu:LoadContent("my_warnings", txtSearch:GetText())
        end
    end

    function btnSearch:DoClick()
        search()
    end
    function txtSearch:OnEnter()
        search()
    end
end

WarningSystem7452em:AddCategory("offline_players", CATEGORY)
--PATH lua/wos/anim_extension/loader/loader.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Register:
		A simple register to keep track of all wiltOS extensions installed
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS = wOS or {}
wOS.AnimExtension = wOS.AnimExtension or {}
wOS.AnimExtension.Mounted = wOS.AnimExtension.Mounted or {}

local string = string
local file = file

local function _AddCSLuaFile( lua )

	if SERVER then
		AddCSLuaFile( lua )
	end
	
end

local function _include( load_type, lua )

	if load_type then
		include( lua )
	end
	
end

function wOS.AnimExtension:Autoloader()
	
	for _,source in pairs( file.Find( "wos/anim_extension/extensions/*", "LUA"), true ) do
		local lua = "wos/anim_extension/extensions/" .. source
		_AddCSLuaFile( lua )
		_include( SERVER, lua )
		_include( CLIENT, lua )
	end
	
	_AddCSLuaFile( "wos/anim_extension/vgui/wiltos_anim_viewer.lua" )
	_include( CLIENT, "wos/anim_extension/vgui/wiltos_anim_viewer.lua" )
	
	_AddCSLuaFile( "wos/anim_extension/core/sh_metatable.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_metatable.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_metatable.lua" )
	
	_AddCSLuaFile( "wos/anim_extension/core/sh_holdtypes.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_holdtypes.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_holdtypes.lua" )

	_AddCSLuaFile( "wos/anim_extension/core/sh_prone_support.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_prone_support.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_prone_support.lua" )
	
	for _,source in pairs( file.Find( "wos/anim_extension/holdtypes/*", "LUA"), true ) do
		local lua = "wos/anim_extension/holdtypes/" .. source
		_AddCSLuaFile( lua )
		_include( SERVER, lua )
		_include( CLIENT, lua )
	end
	
end

wOS.AnimExtension:Autoloader()
--PATH lua/wos/anim_extension/core/sh_metatable.lua:
--[[-------------------------------------------------------------------
	wiltOS Hold Type Meta Tables:
		Creating functions for your Hold Types since 2017
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS = wOS or {}
wOS.AnimExtension.HoldTypeMeta = wOS.AnimExtension.HoldTypeMeta or {}

local HOLDTYPE = {}

HOLDTYPE.GetName = function( self ) 
	return self.Name or nil
end

HOLDTYPE.GetID = function( self )
	return self.HoldType or "wos-custom"
end

HOLDTYPE.GetActivityList = function( self )
	local index = wOS.AnimExtension.ActIndex[ self:GetBaseHoldType() ]
	return {
		[ACT_MP_STAND_IDLE] 				= index,
	    [ACT_MP_WALK] 						= index+1,
		[ACT_MP_RUN] 						= index+2,
		[ACT_MP_CROUCH_IDLE] 				= index+3,
		[ACT_MP_CROUCHWALK] 				= index+4,
		[ACT_MP_ATTACK_STAND_PRIMARYFIRE] 	= index+5,
		[ACT_MP_ATTACK_CROUCH_PRIMARYFIRE] = index+5,
		[ACT_MP_RELOAD_STAND]		 		= index+6,
		[ACT_MP_RELOAD_CROUCH]		 		= index+6,
		[ACT_MP_JUMP] 						= index+7,
		[ACT_RANGE_ATTACK1] 				= index+8,
		[ACT_MP_SWIM] 						= index+9,	
	}
end

HOLDTYPE.GetBaseHoldType = function( self )
	return self.BaseHoldType or "normal"
end

HOLDTYPE.SetBaseHoldType = function( self, newtype )
	self.BaseHoldType = newtype
end

//This is a god damn mess mostly because of legacy support, I need to redo this part for sure.
//OR at least make the old hold-types switch over to the new one
HOLDTYPE.GetActData = function( self, act ) 

	local base = self.Translations[ act ]
	local tbl
	
	if base then
		tbl = {}
		if istable( base ) then
			if base.Sequence then
				tbl.Sequence = base.Sequence
				tbl.Weight = base.Weight or 1
			else
				local seed = ( game.SinglePlayer() and math.random( 1, #base ) ) or util.SharedRandom( "wOS.AnimExtension." .. self:GetName() .. "[" .. act .. "]", 1, #base )
				local key = math.Round( seed )
				local innerbase = base[key]
				if istable( innerbase ) then
					tbl = innerbase
				elseif isstring( innerbase ) then
					tbl.Sequence = innerbase
					tbl.Weight = 1
				end
			end
		elseif isstring( base ) then
			tbl.Sequence = base
		end
	end

	return tbl
	
end

HOLDTYPE.__index = HOLDTYPE

function wOS.AnimExtension.HoldTypeMeta:CreateMetaType( tbl )
	setmetatable( tbl, HOLDTYPE )
end
--PATH lua/autorun/client/brs_cl_autorun.lua:
--[[ Global Variables/Tables ]]--
BRICKS_SERVER = BRICKS_SERVER or {}
BRICKS_SERVER.Func = BRICKS_SERVER.Func or {}
BRICKS_SERVER.TEMP = BRICKS_SERVER.TEMP or {}

--[[ Modules Prep ]]--
BRICKS_SERVER.Modules = {}
local moduleMeta = {
	GetFolderName = function( self )
		return self.FolderName
	end,
	AddSubModule = function( self, folderName, name )
		BRICKS_SERVER.Modules[self:GetFolderName()][3][folderName] = name
	end
}

moduleMeta.__index = moduleMeta

function BRICKS_SERVER.Func.AddModule( folderName, name, icon, version )
	BRICKS_SERVER.Modules[folderName] = { name, icon, {}, version }
	
	local module = {
		FolderName = folderName
	}
	
	setmetatable( module, moduleMeta )
	
	return module
end

--[[ Autorun files ]]--
for k, v in pairs( file.Find( "bricks_server/*.lua", "LUA" ) ) do
	if( string.StartWith( v, "bricks_server_autorun_" ) ) then
		AddCSLuaFile( "bricks_server/" .. v )
		include( "bricks_server/" .. v )
	end
end

--[[ CONFIG LOADER ]]--
for k, v in pairs( file.Find( "bricks_server/*.lua", "LUA" ) ) do
	if( string.StartWith( v, "bricks_server_luacfg_" ) ) then
		AddCSLuaFile( "bricks_server/" .. v )
		include( "bricks_server/" .. v )
	end
end

BRICKS_SERVER.BASECONFIG = {}
AddCSLuaFile( "bricks_server/bricks_server_basecfg_main.lua" )
include( "bricks_server/bricks_server_basecfg_main.lua" )
hook.Run( "BRS.Hooks.BaseConfigLoad" )

BRICKS_SERVER.CONFIG = table.Copy( BRICKS_SERVER.BASECONFIG )

function BRICKS_SERVER.Func.AddLanguageStrings( languageKey, stringTable )
	if( not BRICKS_SERVER.Languages[languageKey] ) then
		BRICKS_SERVER.Languages[languageKey] = stringTable
	else
		table.Merge( BRICKS_SERVER.Languages[languageKey], stringTable )
	end
end

function BRICKS_SERVER.Func.LoadLanguages()
	BRICKS_SERVER.Languages = {}
	local files, directories = file.Find( "bricks_server/languages/*", "LUA" )
	for k, v in pairs( directories ) do
		for key, val in pairs( file.Find( "bricks_server/languages/" .. v .. "/*", "LUA" ) ) do
			AddCSLuaFile( "bricks_server/languages/" .. v .. "/" .. val )
			include( "bricks_server/languages/" .. v .. "/" .. val )
		end
	end
end
BRICKS_SERVER.Func.LoadLanguages()

function BRICKS_SERVER.Func.L( languageKey, ... )
	local languageTable = BRICKS_SERVER.Languages[BRICKS_SERVER.CONFIG.LANGUAGE.Language or "english"] or BRICKS_SERVER.Languages["english"]

	local languageString = ((languageTable or {})[languageKey] or BRICKS_SERVER.Languages["english"][languageKey]) or "MISSING LANGUAGE"

	local configLanguageTable = (BRICKS_SERVER.CONFIG.LANGUAGE.Languages or {})[BRICKS_SERVER.CONFIG.LANGUAGE.Language or "english"]

	if( configLanguageTable and configLanguageTable[2] and configLanguageTable[2][languageKey] ) then
		languageString = configLanguageTable[2][languageKey]
	end

	return (not ... and languageString) or string.format( languageString, ... )
end

function BRICKS_SERVER.Func.GetTheme( key, alpha )
	local color = Color( 0, 0, 0 )
	if( BRICKS_SERVER.BASECONFIG.THEME[key] ) then
		if( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).THEME[key] ) then
			color = (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).THEME[key]
		else
			color = BRICKS_SERVER.BASECONFIG.THEME[key]
		end
	end

	if( alpha ) then
		color = Color( color.r, color.g, color.b, alpha )
	end

	return color
end

function BRICKS_SERVER.Func.IsModuleEnabled( moduleName )
	if( BRICKS_SERVER.Modules[moduleName] ) then
		return BRICKS_SERVER.CONFIG.MODULES[moduleName] and BRICKS_SERVER.CONFIG.MODULES[moduleName][1] == true
	end
	
	return false
end

function BRICKS_SERVER.Func.IsSubModuleEnabled( moduleName, subModuleName )
	if( BRICKS_SERVER.Modules[moduleName] ) then
		return BRICKS_SERVER.Func.IsModuleEnabled( moduleName ) and BRICKS_SERVER.CONFIG.MODULES[moduleName][2][subModuleName]
	end
	
	return false
end

local function LoadClientConfig()
	BRICKS_SERVER.BASECLIENTCONFIG = BRICKS_SERVER.BASECLIENTCONFIG or {}
	hook.Run( "BRS.Hooks.ClientConfigLoad" )
end

local function LoadDevConfig()
	BRICKS_SERVER.DEVCONFIG = BRICKS_SERVER.DEVCONFIG or {}
	AddCSLuaFile( "bricks_server/bricks_server_devcfg_main.lua" )
	include( "bricks_server/bricks_server_devcfg_main.lua" )
	hook.Run( "BRS.Hooks.DevConfigLoad" )
end

LoadClientConfig()
LoadDevConfig()

--[[ Automatic autoruns ]]--
local AutorunTable = {}
AutorunTable[1] = {
	Location = "bricks_server/core/shared/",
	Type = "Shared"
}
AutorunTable[2] = {
	Location = "bricks_server/core/client/",
	Type = "Client"
}
AutorunTable[3] = {
	Location = "bricks_server/vgui/",
	Type = "Client"
}

for key, val in ipairs( AutorunTable ) do
	for k, v in ipairs( file.Find( val.Location .. "*.lua", "LUA" ) ) do
		if( val.Type == "Shared" ) then
			include( val.Location .. v )
		elseif( val.Type == "Client" ) then	
			include( val.Location .. v )
		end
	end
end

hook.Run( "BRS.Hooks.CoreLoaded" )

--[[ MODULES AUTORUN ]]--
local function loadModuleFiles( filePath )
	local moduleFiles, moduleDirectories = file.Find( filePath .. "/*", "LUA" )

	if( not moduleDirectories ) then return end

	for key, val in pairs( moduleDirectories ) do
		for key2, val2 in pairs( file.Find( filePath .. "/" .. val .. "/*.lua", "LUA" ) ) do
			if( val == "shared" ) then
				include( filePath .. "/" .. val .. "/" .. val2 )
			elseif( val == "client" or val == "vgui" ) then
				include( filePath .. "/" .. val .. "/" .. val2 )
			end
		end
	end
end

if( not BRICKS_SERVER.CONFIG.MODULES["default"] or not BRICKS_SERVER.CONFIG.MODULES["default"][1] ) then
	BRICKS_SERVER.CONFIG.MODULES["default"] = { true, {} }
end

for k, v in pairs( BRICKS_SERVER.CONFIG.MODULES or {} ) do
	if( BRICKS_SERVER.Modules[k] and v[1] == true ) then
		loadModuleFiles( "bricks_server/modules/" .. k )
	else
		continue
	end

	if( table.Count( v[2] ) > 0 ) then
		for key, val in pairs( v[2] ) do
			if( BRICKS_SERVER.Modules[k][3][key] and val == true ) then
				loadModuleFiles( "bricks_server/modules/" .. k .. "/submodules/" .. key )
			end
		end
	end
end

hook.Add( "InitPostEntity", "BRS.InitPostEntity.Loaded", function()
	BRICKS_SERVER.INITPOSTENTITY_LOADED = true
end )

hook.Add( "Initialize", "BRS.Initialize.Loaded", function()
	BRICKS_SERVER.INITIALIZE_LOADED = true
end )

--[[ CLIENT REQUEST CONFIG ]]--
hook.Add( "BRS.Hooks.ConfigReceived", "BRS.Hooks.ConfigReceived.ConfigWait", function()
	LoadClientConfig()
	LoadDevConfig()

	hook.Remove( "BRS.Hooks.ConfigReceived", "BRS.Hooks.ConfigReceived.ConfigWait" )
end )

BRICKS_SERVER.TEMP.ReceivedConfig = false
BRICKS_SERVER.TEMP.LastConfigRequest = 0
hook.Add( "Think", "BRS.Think.RequestConfig", function()
	if( not BRICKS_SERVER.TEMP.ReceivedConfig and CurTime() >= BRICKS_SERVER.TEMP.LastConfigRequest ) then
		net.Start( "BRS.Net.RequestConfig" )
		net.SendToServer()
		BRICKS_SERVER.TEMP.LastConfigRequest = CurTime()+10
	end
end )

hook.Add( "BRS.Hooks.ConfigReceived", "BRS.Hooks.ConfigReceived.RequestConfigRemover", function()
	if( not BRICKS_SERVER.TEMP.ReceivedConfig ) then
		BRICKS_SERVER.TEMP.ReceivedConfig = true
		hook.Remove( "Think", "BRS.Think.RequestConfig" )
		hook.Remove( "BRS.Hooks.ConfigReceived", "BRS.Hooks.ConfigReceived.RequestConfigRemover" )
	end
end )
--PATH lua/bricks_server/bricks_server_autorun_default.lua:
local module = BRICKS_SERVER.Func.AddModule( "default", "Brick's Server", "materials/bricks_server/essentials.png" )
module:AddSubModule( "currencies", "Currencies" )
--PATH lua/bricks_server/languages/bricks_server/french.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "french", {
    ["search"] = "Rechercher",
    ["invalidPlayerProfile"] = "Profil de joueur invalide",
    ["unbound"] = "NON ASSIGNER",
    ["themes"] = "Thèmes",
    ["groups"] = "Groupes",
    ["general"] = "General",
    ["itemWhitelisting"] = "Whitelist d'items",
    ["rarities"] = "Rareté",
    ["languages"] = "Langues",
    ["disabled"] = "Désactivé",
    ["enabled"] = "Activé",
    ["purchase"] = "Acheter",
    ["profile"] = "Profil",
    ["view"] = "Inspecter",
    ["admin"] = "Admin",
    ["noToolPermission"] = "Vous n'avez pas la permission d'utiliser cet outil.",
    ["settings"] = "Paramètres",
    ["players"] = "Joueurs",
    ["modules"] = "Modules",

    ["userGroupEditor"] = "Éditeur de groupes",
    ["addNewGroup"] = "Ajouter un groupe",
    ["newUserGroup"] = "Quel devrait être le nouveau groupe?",
    ["groupName"] = "GroupName",

    ["custom"] = "Custom",
    ["addNew"] = "Ajouter un nouveau",
    ["material"] = "Material",
    ["directImage"] = "Entrez une URL d'image directe ci-dessous.",
    ["default"] = "Default",
    ["selectMaterial"] = "Vous devez choisir un material",

    ["errorNoText"] = "ERREUR: AUCUN TEXT",
    ["selectOption"] = "Sélectionnez une option",
    ["selectValue"] = "Veuillez sélectionner une valeur.",
    ["selectColor"] = "Veuillez choisir une couleur.",
    ["configSaved"] = "Config sauvegardé!",
    ["cmdNoPermission"] = "Vous n'avez pas la permission d'utiliser cette commande.",
    ["entityPosUpdated"] = "Positions des entités mise à jour!",
    ["noEntitiesSpawned"] = "Aucune entité sauvée n'a été spawn.",
    ["xEntitiesSpawned"] = "%d entités sauvées ont été spawn.",
    ["error"] = "ERREUR",

    ["seconds"] = "%d secondes",
    ["second"] = "%d seconde",
    ["minutes"] = "%d minutes",
    ["minute"] = "%d minute",
    ["hours"] = "%d heures",
    ["hour"] = "%d heure",

    ["noRarity"] = "Aucune rareté",

    ["config"] = "Config",
    ["edit"] = "Modifier",
    ["editColor"] = "Changer la couleur",
    ["editName"] = "Changer le nom",
    ["remove"] = "Supprimer",
    ["name"] = "Nom",
    ["description"] = "Description",
    ["model"] = "Model",
    ["icon"] = "Icon",
    ["type"] = "Type",
    ["price"] = "Prix",
    ["group"] = "Group",
    ["category"] = "Categorie",
    ["color"] = "Couleur",
    ["invalidType"] = "Type invalide.",
    ["invalidOption"] = "Option invalide .",
    ["invalidChoice"] = "Choix invalide.",
    ["invalidGroup"] = "Group invalide.",
    ["invalidPlayer"] = "Joueur invalide.",
    ["true"] = "TRUE",
    ["false"] = "FALSE",
    ["noDescription"] = "Aucune description",
    ["other"] = "Autres",
    ["completed"] = "Achevé",
    ["close"] = "Fermer",
    ["main"] = "Main",
    
    ["valueQuery"] = "Que devrait être le %s ?",
    ["dataValueQuery"] = "Qu'est ce que cela devrait être ?",
    ["newNameQuery"] = "Quel devrait être le nouveau nom ?",
    ["newDescriptionQuery"] = "Quelle devrait être la nouvelle description ?",
    ["newModelQuery"] = "Quel devrait être le nouveau modèle ?",
    ["newIconQuery"] = "Que devrait être la nouvelle icône ?",
    ["newColorQuery"] = "Quelle devrait être la nouvelle couleur?",
    ["npcTypeQuery"] = "Quel doit être le type de ce NPC ?",
    ["newTypeQuery"] = "Que devrait être le nouveau type",
    ["groupRequirementQuery"] = "Quelle devrait être les conditions de groupe ?",
    ["levelRequirementQuery"] = "Quelle devrait être les conditions de level ?",
    ["newPriceQuery"] = "Quel devrait être le nouveau prix ?",
    ["newCategoryQuery"] = "Quelle devrait être la nouvelle catégorie ?",

    ["npcEditor"] = "Editeur de NPC",
    ["addNPC"] = "Ajouter un NPC",
    ["newNPC"] = "Nouveau NPC",

    ["ok"] = "OK",
    ["cancel"] = "Annuler",
    ["save"] = "Sauvegarder",
    ["confirm"] = "Confirmer",
    ["nil"] = "NIL",
    ["none"] = "Aucun",
    ["selected"] = "Sélectionné",
    ["unselected"] = "Désélectionnée",
    ["add"] = "Ajouter",

    ["shootyStick"] = "Un bâton qui tire!",
    ["permanent"] = "Permanent",
    ["tierX"] = "(Tier %d)",
    ["someDescription"] = "Une description.",
    ["invalidNPC"] = "ERREUR : NPC invalide",

    ["disconnected"] = "Déconnecté",
    ["profileView"] = "Profil",
    ["loading"] = "Chargement",
    ["statistics"] = "Statistiques",
    ["steamID64"] = "SteamID64",
    ["donationRank"] = "Donation Rank",
    ["staffRank"] = "Staff Rank",
    ["currentJob"] = "Emploi actuel",
    ["wallet"] = "Portefeuille",
    ["level"] = "Level",
    ["levelX"] = "Level %d",
    ["experience"] = "Experience",
    ["exp"] = "EXP",
    ["money"] = "Argent",
    ["playerLogs"] = "Player Logs",
    ["deleteLogs"] = "Delete logs",
    ["xLogs"] = "%d logs",
    ["xAdminGroups"] = "%d Admin Groups",
    ["noUserGroups"] = "No user groups",
    ["userGroups"] = "User groups: %s",
    ["editUserGroups"] = "Modifier les  user groups",
    ["newGroupColor"] = "Quelle devrait être la nouvelle couleur du groupe?",
    ["newGroupName"] = "Quel devrait être le nouveau nom du groupe?",
    ["groupAlreadyExists"] = "Ce groupe existe déjà !",
    ["whitelist"] = "Whitelist",
    ["unWhitelist"] = "UnWhitelist",
    ["addCustom"] = "Add custom",
    ["entClassWhitelist"] = "Quelle classe d'entité souhaitez-vous mettre sur la whitelist ?",
    ["entClassAlreadyOnList"] = "Cette classe d'entités figure déjà sur la liste!",
    ["changesServerRestart"] = "Certains changements ne prendront pas effet tant que le serveur ne sera pas redémarré !",
    ["comingSoon"] = "Coming Soon!",
    ["features"] = "FEATURES",
    ["addNewRarity"] = "Ajouter une nouvelle rareté",
    ["newRarity"] = "Nouvelle rareté",
    ["needToAddRarity"] = "Vous devez d'abord ajouter un type de rareté !",
    ["whatRarityItem"] = "Quelle devrait être la rareté de cet objet ?",
    ["invalidRarity"] = "Rareté invalide.",
    ["rarityAlreadyExists"] = "Une rareté avec ce nom existe déjà!",
    ["themeColorX"] = "Theme - Color %d",
    ["themeTextColor"] = "Theme - Text Color",
    ["presetAccents"] = "Accents prédéfinis",
    ["presetBackgrounds"] = "Arrière-plan prédéfini",
    ["resetToBaseThemes"] = "Rétablir le thème de bases",
    ["resetToCurrentThemes"] = "Rétablir le thèmes actuels",
    ["toggle"] = "Activer",
    ["menu"] = "Menu",
    ["emptyValue"] = "EMPTY VALUE",
    ["newValueQuery"] = "Quelle devrait être la nouvelle valeur ?",
    ["pressKey"] = "APPUYEZ SUR UNE TOUCHE",

    ["entityPlacer"] = "Entity Placer",
    ["invalidEntityType"] = "Type d'entité invalide, choisissez un type d'entité valide dans le menu d'outils.",
    ["entityPlaced"] = "Entité placée avec succès.",
    ["entityRemoved"] = "Entité retirée avec succès.",
    ["canOnlyUseToolEntity"] = "Vous ne pouvez utiliser cet outil que pour supprimer/créer une entité.",
    ["entityType"] = "Type d'entité",
    ["entityPlacerDescription"] = "Place et retire des entités du serveur et enregistre leurs positions. Clic gauche - placer. Clic droit - supprimer.",
    ["entityPlacerDescriptionSmall"] = "Placement et déplacement d'entités",
    ["entityPlacerInstructions"] = "Clic gauche - placer, Clic droit - supprimer.",

    ["npcPlacer"] = "NPC Placer",
    ["npcPlaced"] = "NPC placé avec succès.",
    ["invalidNPCType"] = "Type de NPC invalide, choisissez un NPC valide dans le menu d'outils.",
    ["npcRemoved"] = "Le NPC a été supprimé avec succès.",
    ["errorNotNPC"] = "Vous ne pouvez utiliser cet outil que pour supprimer/créer un NPC.",
    ["npcPlacerDescription"] = "Place et retire les NPCs du serveur , Clic gauche - placer, Clic droit - retirer.",
    ["npcPlacerDescriptionSmall"] = "Placer et retirer des NPCs.",

    ["inventory"] = "Inventaire",
    ["player"] = "Joueur",
    ["drop"] = "Lâcher",
    ["use"] = "Utiliser",
    ["dropAll"] = "Tout lâcher",
    ["delete"] = "Supprimer",
} )
--PATH lua/bricks_server/vgui/bricks_server_colsheet_icon.lua:

local PANEL = {}

AccessorFunc( PANEL, "ActiveButton", "ActiveButton" )

function PANEL:Init()

	self.Navigation = vgui.Create( "bricks_server_scrollpanel", self )
	self.Navigation:Dock( LEFT )
	self.Navigation:SetWidth( 65 )
	self.Navigation:DockMargin( 0, 0, 0, 0 )
	self.Navigation.Paint = function( self2, w, h )
		draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, false, true, false )
	end

	self.Content = vgui.Create( "Panel", self )
	self.Content:Dock( FILL )

	self.Items = {}

end

function PANEL:UseButtonOnlyStyle()
	self.ButtonOnly = true
end

function PANEL:AddSheet( panel, onLoad, icon, dontShow )

	if ( !IsValid( panel ) ) then return end

	local Sheet = {}
	Sheet.Button = vgui.Create( "DButton", self.Navigation )
	Sheet.Button.Target = panel
	Sheet.Button:Dock( TOP )
	Sheet.Button:SetText( "" )
	Sheet.Button:SetTall( (not dontShow and 65) or 0 )
	local changeAlpha = 0
	local iconMat
	BRICKS_SERVER.Func.GetImage( icon or "", function( mat ) iconMat = mat end )
	Sheet.Button.Paint = function( self2, w, h )
		if( self2:IsHovered() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.DrawRect( 0, 0, 5, h )
		surface.SetAlphaMultiplier( 1 )

		if( iconMat ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 75 ) )
			surface.SetMaterial( iconMat )
			local iconSize = 32
			surface.DrawTexturedRect( (w/2)-(iconSize/2), (h/2)-(iconSize/2), iconSize, iconSize )
		end
	end

	Sheet.Button.DoClick = function()
		if( not Sheet.Button.m_bSelected ) then
			changeAlpha = 0
		end

		self:SetActiveButton( Sheet.Button )
	end

	Sheet.Panel = panel
	Sheet.Panel:SetParent( self.Content )
	Sheet.Panel:SetAlpha( 0 )
	Sheet.Panel:SetVisible( false )

	if( onLoad ) then
		Sheet.Button.onLoad = onLoad
	end

	if ( self.ButtonOnly ) then
		Sheet.Button:SizeToContents()
	end

	table.insert( self.Items, Sheet )

	if ( !IsValid( self.ActiveButton ) ) then
		self:SetActiveButton( Sheet.Button )
	end
	
	return Sheet
end

function PANEL:Think()
	for k, v in pairs( self.Items ) do
		if( v.Think ) then
			v.Think()
		end
	end
end

function PANEL:SetActiveButton( active )
	if ( self.ActiveButton == active ) then return end

	if ( self.ActiveButton && self.ActiveButton.Target ) then
		local targetPanel = self.ActiveButton.Target
		targetPanel:SetVisible( false )
		targetPanel:SetAlpha( 0 )
		self.ActiveButton:SetSelected( false )
		self.ActiveButton:SetToggle( false )
	end

	self.ActiveButton = active
	active.Target:SetVisible( true )
	active.Target:AlphaTo( 255, 0.2, 0, function() end )
	active:SetSelected( true )
	active:SetToggle( true )

	if( active.onLoad and not active.loaded ) then
		active.onLoad()
		active.loaded = true
	end

	self.Content:InvalidateLayout()
end

derma.DefineControl( "bricks_server_colsheet_icon", "", PANEL, "Panel" )

--PATH lua/bricks_server/vgui/bricks_server_config_languages.lua:
local PANEL = {}

function PANEL:Init()
    self.margin = 0

    local panelWide = ScrW()*0.6-BRICKS_SERVER.DEVCONFIG.MainNavWidth
    local panelTall = (ScrH()*0.65)-40

    local function CreateEditPopout( languageKey )
        if( IsValid( self.popout ) ) then
            self.popout:Remove()
        end

        local popoutClose = vgui.Create( "DPanel", self )
        popoutClose:SetSize( panelWide, panelTall )
        popoutClose:SetAlpha( 0 )
        popoutClose:AlphaTo( 255, 0.2 )
        popoutClose.Paint = function( self2, w, h )
            surface.SetDrawColor( 0, 0, 0, 150 )
            surface.DrawRect( 0, 0, w, h )
            BRICKS_SERVER.Func.DrawBlur( self2, 2, 2 )
        end

        local popoutWide, popoutTall = panelWide-panelWide*0.1, panelTall-panelWide*0.1

        self.popout = vgui.Create( "DPanel", self )
        self.popout:SetSize( 0, 0 )
        self.popout:SizeTo( popoutWide, popoutTall, 0.2 )
        self.popout.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        end
        self.popout.OnSizeChanged = function( self2 )
            self2:SetPos( (panelWide/2)-(self2:GetWide()/2), (panelTall/2)-(self2:GetTall()/2) )
        end
        self.popout.ClosePopout = function()
            if( IsValid( self.popout ) ) then
                self.popout:SizeTo( 0, 0, 0.2, 0, -1, function()
                    if( IsValid( self.popout ) ) then
                        self.popout:Remove()
                    end
                end )
            end

            popoutClose:AlphaTo( 0, 0.2, 0, function()
                if( IsValid( popoutClose ) ) then
                    popoutClose:Remove()
                end
            end )
        end

        local popoutCloseButton = vgui.Create( "DButton", self.popout )
        popoutCloseButton:Dock( BOTTOM )
        popoutCloseButton:SetTall( 40 )
        popoutCloseButton:SetText( "" )
        popoutCloseButton:DockMargin( 25, 0, 25, 25 )
        local changeAlpha = 0
        popoutCloseButton.Paint = function( self2, w, h )
            if( not self2:IsDown() and self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            surface.SetAlphaMultiplier( 1 )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            
            draw.SimpleText( BRICKS_SERVER.Func.L( "cancel" ), "BRICKS_SERVER_Font20", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        popoutCloseButton.DoClick = self.popout.ClosePopout

        local originalLanguageTable = table.Copy( BRICKS_SERVER.Languages[languageKey] or {} )

        local topBar = vgui.Create( "DPanel", self.popout )
        topBar:Dock( TOP )
        topBar:SetTall( 40 )
        topBar:DockMargin( 25, 25, 25, 0 )
        topBar.Paint = function( self2, w, h ) end

        local buttons = {
            {
                Title = "Auto Fill",
                Color = Color( 46, 204, 113 ),
                DoClick = function()
                    local options = { 
                        ["af"] = "Afrikaans",
                        ["ga"] = "Irish",
                        ["sq"] = "Albanian",
                        ["it"] = "Italian",
                        ["ja"] = "Japanese",
                        ["az"] = "Azerbaijani",
                        ["kn"] = "Kannada",
                        ["eu"] = "Basque",
                        ["ko"] = "Korean",
                        ["bn"] = "Bengali",
                        ["la"] = "Latin",
                        ["be"] = "Belarusian",
                        ["lv"] = "Latvian",
                        ["bg"] = "Bulgarian",
                        ["ca"] = "Catalan",
                        ["mk"] = "Macedonian",
                        ["zh-CN"] = "Chinese Simplified",
                        ["ms"] = "Malay",
                        ["zh-TW"] = "Chinese Traditional",
                        ["mt"] = "Maltese",
                        ["hr"] = "Croatian",
                        ["no"] = "Norwegian",
                        ["cs"] = "Czech",
                        ["fa"] = "Persian",
                        ["da"] = "Danish",
                        ["pl"] = "Polish",
                        ["nl"] = "Dutch",
                        ["ro"] = "Romanian",
                        ["eo"] = "Esperanto",
                        ["ru"] = "Russian",
                        ["et"] = "Estonian",
                        ["sr"] = "Serbian",
                        ["tl"] = "Filipino",
                        ["sk"] = "Slovak",
                        ["fi"] = "Finnish",
                        ["sl"] = "Slovenian",
                        ["fr"] = "French",
                        ["es"] = "Spanish",
                        ["gl"] = "Galician",
                        ["sw"] = "Swahili",
                        ["ka"] = "Georgian",
                        ["de"] = "German",
                        ["ta"] = "Tamil",
                        ["el"] = "Greek",
                        ["te"] = "Telugu",
                        ["gu"] = "Gujarati",
                        ["th"] = "Thai",
                        ["ht"] = "Haitian Creole",
                        ["tr"] = "Turkish",
                        ["iw"] = "Hebrew",
                        ["uk"] = "Ukrainian",
                        ["hi"] = "Hindi",
                        ["ur"] = "Urdu",
                        ["hu"] = "Hungarian",
                        ["vi"] = "Vietnamese",
                        ["is"] = "Icelandic",
                        ["cy"] = "Welsh",
                        ["id"] = "Indonesian",
                        ["yi"] = "Yiddish"
                    }
                    for k, v in pairs( {} ) do
                        options[k] = k
                    end
                    
                    BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), "What language would you like to auto fill?", "None", options, function( value, data ) 
                        if( options[data] ) then
                            local stringsToTranslate = {}
                            for k, v in pairs( BRICKS_SERVER.Languages["english"] ) do
                                local textEntry = self.popout.textEntries[k]
        
                                if( not IsValid( textEntry ) ) then continue end
        
                                table.insert( stringsToTranslate, { k, v, textEntry } )
                            end
        
                            local function translateNext()
                                if( not IsValid( self ) or not self:IsVisible() ) then return end
        
                                if( #stringsToTranslate <= 0 ) then return end
        
                                local nextStringTable = stringsToTranslate[1]
        
                                if( not nextStringTable ) then return end
        
                                if( not IsValid( nextStringTable[3] ) ) then
                                    table.remove( stringsToTranslate, 1 )
                                    translateNext()
                                    return
                                end
        
                                nextStringTable[3]:GetParent().translating = true
        
                                BRICKS_SERVER.Func.GetTranslatedString( data, nextStringTable[2], function( translatedString, errorMsg )
                                    if( not translatedString or errorMsg or not IsValid( nextStringTable[3] ) ) then
                                        print( "TRANSLATING ERROR: " .. (errorMsg or "UNKNOWN") )
        
                                        BRICKS_SERVER.Func.Message( "Your IP has been temporarily blocked by Google, please try again later.", BRICKS_SERVER.Func.L( "admin" ), "Confirm" )
        
                                        nextStringTable[3]:GetParent().translating = nil
                                        return
                                    else
                                        nextStringTable[3]:SetValue( translatedString )
                                    end
        
                                    table.remove( stringsToTranslate, 1 )
        
                                    timer.Simple( 0.5, function() 
                                        if( IsValid( nextStringTable[3] ) ) then
                                            nextStringTable[3]:GetParent().translating = nil
                                        end
        
                                        translateNext() 
                                    end )
                                end )
                            end
                            translateNext()
                        else
                            notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidType" ), 1, 3 )
                        end
                    end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
                end
            },
            {
                Title = "Reset Changes",
                Color = Color( 231, 76, 60 ),
                DoClick = function()
                    if( not BS_ConfigCopyTable.LANGUAGE.Languages or not BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] ) then return end
        
                    BS_ConfigCopyTable.LANGUAGE.Languages[languageKey][2] = {}
        
                    BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
                    self.popout.RefreshLanguageStrings()
                end
            },
        }

        if( isnumber( languageKey ) ) then
            table.insert( buttons, {
                Title = "Delete",
                Color = Color( 231, 76, 60 ),
                DoClick = function()
                    if( not BS_ConfigCopyTable.LANGUAGE.Languages or not BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] ) then return end
        
                    if( isnumber( languageKey ) ) then
                        BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] = nil
                    end
        
                    BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
                    self.popout.ClosePopout()

                    self.RefreshPanel()
                end
            } )

            table.insert( buttons, {
                Title = "Edit Name",
                Color = Color( 127, 140, 141 ),
                DoClick = function()
                    if( not BS_ConfigCopyTable.LANGUAGE.Languages or not BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] ) then return end
        
                    if( isnumber( languageKey ) ) then
                        BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newNameQuery" ), (BS_ConfigCopyTable.LANGUAGE.Languages[languageKey][1] or ""), function( text ) 
                            BS_ConfigCopyTable.LANGUAGE.Languages[languageKey][1] = text
                            self.RefreshPanel()
                            BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
                        end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
                    end
                end
            } )
        end

        for k, v in ipairs( buttons ) do
            surface.SetFont( "BRICKS_SERVER_Font20" )
            local textX, textY = surface.GetTextSize( v.Title )
    
            local button = vgui.Create( "DButton", topBar )
            button:Dock( RIGHT )
            button:DockMargin( 5, 0, 0, 0 )
            button:SetText( "" )
            button:SetWide( textX+20 )
            local changeAlpha = 0
            button.Paint = function( self2, w, h )
                if( self2:IsDown() or self2.m_bSelected ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 5, 50 )
                elseif( self2:IsHovered() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 5, 25 )
                else
                    changeAlpha = math.Clamp( changeAlpha-10, 5, 50 )
                end
        
                surface.SetAlphaMultiplier( changeAlpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, v.Color or BRICKS_SERVER.Func.GetTheme( 4 ) )
                surface.SetAlphaMultiplier( 1 )
        
                draw.SimpleText( v.Title, "BRICKS_SERVER_Font20", 10, h/2, (v.Color or BRICKS_SERVER.Func.GetTheme( 5 )), 0, TEXT_ALIGN_CENTER )
            end
            button.DoClick = v.DoClick
        end

        local searchBarBack = vgui.Create( "DPanel", topBar )
        searchBarBack:Dock( FILL )
        local search = Material( "materials/bricks_server/search.png" )
        local Alpha = 0
        local Alpha2 = 20
        local color1 = BRICKS_SERVER.Func.GetTheme( 2 )
        local searchBar
        searchBarBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
    
            if( searchBar:IsEditing() ) then
                Alpha = math.Clamp( Alpha+5, 0, 100 )
                Alpha2 = math.Clamp( Alpha2+20, 20, 255 )
            else
                Alpha = math.Clamp( Alpha-5, 0, 100 )
                Alpha2 = math.Clamp( Alpha2-20, 20, 255 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )
        
            surface.SetDrawColor( 255, 255, 255, Alpha2 )
            surface.SetMaterial(search)
            local size = 24
            surface.DrawTexturedRect( w-size-(h-size)/2, (h-size)/2, size, size )
        end
    
        searchBar = vgui.Create( "bricks_server_search", searchBarBack )
        searchBar:Dock( FILL )
        searchBar:SetFont( "BRICKS_SERVER_Font20" )

        local scrollPanel = vgui.Create( "bricks_server_scrollpanel_bar", self.popout )
        scrollPanel:Dock( FILL )
        scrollPanel:DockMargin( 25, 10, 25, 10 )

        function self.popout.RefreshLanguageStrings()
            scrollPanel:Clear()

            self.popout.textEntries = {}

            local languageTable = {}
            if( (BS_ConfigCopyTable.LANGUAGE.Languages or {})[languageKey] ) then
                table.Merge( languageTable, (BS_ConfigCopyTable.LANGUAGE.Languages or {})[languageKey][2] or {} )
            end

            local count = 0
            local languageStringCount = table.Count( BRICKS_SERVER.Languages["english"] )
            for k, v in pairs( BRICKS_SERVER.Languages["english"] ) do
                if( (searchBar:GetValue() or "") != "" and not string.find( string.lower( v ), string.lower( searchBar:GetValue() or "" ) ) and not string.find( string.lower( languageTable[k] or v ), string.lower( searchBar:GetValue() or "" ) ) ) then
                    continue
                end

                count = count+1

                local currentCount = count

                local languageBack = vgui.Create( "DPanel", scrollPanel )
                languageBack:Dock( TOP )
                languageBack:DockMargin( 0, 0, 10, 0 )
                languageBack:SetTall( 40 )
                languageBack.Paint = function( self2, w, h )
                    if( currentCount == 1 ) then
                        draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ), true, true, false, false )
                    elseif( currentCount >= languageStringCount ) then
                        draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ), false, false, true, true )
                    else
                        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 1 ) )
                        surface.DrawRect( 0, 0, w, h )
                    end

                    if( self2.translating ) then
                        if( currentCount == 1 ) then
                            draw.RoundedBoxEx( 5, w/2+1, 0, w/2-1, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, true, false, false )
                        elseif( currentCount >= languageStringCount ) then
                            draw.RoundedBoxEx( 5, w/2+1, 0, w/2-1, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, false, false, true )
                        else
                            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                            surface.DrawRect( w/2+1, 0, w/2-1, h )
                        end
                    end

                    if( currentCount < languageStringCount ) then
                        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 0 ) )
                        surface.DrawRect( 0, h-1, w, 1 )
                    end

                    surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 0 ) )
                    surface.DrawRect( w/2, 0, 1, h )
        
                    draw.SimpleText( v, "BRICKS_SERVER_Font20", 10, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
                end

                local languageTextEntry = vgui.Create( "bricks_server_textentry", languageBack )
                languageTextEntry:Dock( RIGHT )
                languageTextEntry:DockMargin( 0, 0, 10, 0 )
                languageTextEntry:SetWide( (popoutWide-50-20-30)/2 )
                languageTextEntry:SetValue( languageTable[k] or v )
                languageTextEntry:SetFont( "BRICKS_SERVER_Font20" )
                languageTextEntry:SetUpdateOnType( true )
                languageTextEntry.OnValueChange = function( self2, value )
                    if( not BS_ConfigCopyTable.LANGUAGE.Languages ) then
                        BS_ConfigCopyTable.LANGUAGE.Languages = {}
                    end

                    if( not BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] ) then
                        BS_ConfigCopyTable.LANGUAGE.Languages[languageKey] = { false, {} }
                    end

                    if( languageTextEntry:GetValue() != originalLanguageTable[k] ) then
                        BS_ConfigCopyTable.LANGUAGE.Languages[languageKey][2][k] = languageTextEntry:GetValue()
                    else
                        BS_ConfigCopyTable.LANGUAGE.Languages[languageKey][2][k] = nil
                    end
        
                    BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
                end

                self.popout.textEntries[k] = languageTextEntry
            end
        end
        self.popout.RefreshLanguageStrings()

        searchBar.OnChange = function()
            self.popout.RefreshLanguageStrings()
        end
    end

    local scrollPanel = vgui.Create( "bricks_server_scrollpanel", self )
    scrollPanel:Dock( FILL )
    scrollPanel:DockMargin( 10, 10, 10, 10 )

    local languageSpacing = 10
    local gridWide = (ScrW()*0.6)-BRICKS_SERVER.DEVCONFIG.MainNavWidth-20
    local slotSize = 320
    local slotsWide = math.floor( gridWide/slotSize )
    local actualSlotSize = (gridWide-((slotsWide-1)*languageSpacing))/slotsWide

    local slotTall = 125
    local languageGrid = vgui.Create( "DIconLayout", scrollPanel )
    languageGrid:Dock( TOP )
    languageGrid:SetSpaceY( languageSpacing )
    languageGrid:SetSpaceX( languageSpacing )
    languageGrid:SetTall( slotTall )

    function self.RefreshPanel()
        languageGrid:Clear()

        local languages = {}
        for k, v in pairs( BRICKS_SERVER.Languages ) do
            local key = table.insert( languages, { k, table.Copy( v ) } )

            if( (BS_ConfigCopyTable.LANGUAGE.Languages or {})[k] ) then
                table.Merge( languages[key][2], (BS_ConfigCopyTable.LANGUAGE.Languages or {})[k][2] )
            end
        end

        for k, v in pairs( BS_ConfigCopyTable.LANGUAGE.Languages or {} ) do
            if( not v[1] ) then continue end

            table.insert( languages, { k, v[2], v[1] } )
        end

        for k, v in pairs( languages ) do
            languageGrid.slots = (languageGrid.slots or 0)+1
            local slots = languageGrid.slots
            local slotsTall = math.ceil( slots/slotsWide )
            languageGrid:SetTall( (slotsTall*slotTall)+((slotsTall-1)*languageSpacing) )

            local missingLanguageStrings = math.max( 0, table.Count( BRICKS_SERVER.Languages["english"] or {} ) - table.Count( v[2] ) )

            local languageBack = vgui.Create( "DPanel", languageGrid )
            languageBack:SetSize( actualSlotSize, slotTall )
            languageBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

                draw.SimpleText( string.upper( v[3] or v[1] ), "BRICKS_SERVER_Font25", w/2, h/3, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

                if( missingLanguageStrings > 0 ) then
                    draw.SimpleText( missingLanguageStrings .. " missing language strings", "BRICKS_SERVER_Font20", w/2, h/3, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red, TEXT_ALIGN_CENTER, 0 )
                else
                    draw.SimpleText( missingLanguageStrings .. " missing language strings", "BRICKS_SERVER_Font20", w/2, h/3, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green, TEXT_ALIGN_CENTER, 0 )
                end
            end

            local languageEditButton = vgui.Create( "DButton", languageBack )
            languageEditButton:SetSize( 36, 36 )
            languageEditButton:SetPos( actualSlotSize-10-languageEditButton:GetWide(), 10 )
            languageEditButton:SetText( "" )
            local alpha = 0
            local editMat = Material( "materials/bricks_server/edit.png" )
            languageEditButton.Paint = function( self2, w, h )
                if( not self2:IsDown() and self2:IsHovered() ) then
                    alpha = math.Clamp( alpha+10, 0, 95 )
                else
                    alpha = math.Clamp( alpha-10, 0, 95 )
                end

                surface.SetAlphaMultiplier( alpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
                surface.SetAlphaMultiplier( 1 )

                BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

                surface.SetMaterial( editMat )
                local size = 24
                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
                surface.DrawTexturedRect( (h-size)/2, (h-size)/2, size, size )
            end
            languageEditButton.DoClick = function()
                CreateEditPopout( v[1] )
            end

            local languageButton = vgui.Create( "DButton", languageBack )
            languageButton:Dock( BOTTOM )
            languageButton:DockMargin( 10, 10, 10, 10 )
            languageButton:SetTall( 40 )
            languageButton:SetText( "" )
            local alpha = 0
            languageButton.Paint = function( self2, w, h )
                local buttonText, buttonColor, buttonDownColor = BRICKS_SERVER.Func.L( "unselected" ), BRICKS_SERVER.Func.GetTheme( 2 ), BRICKS_SERVER.Func.GetTheme( 1 )

                if( (BS_ConfigCopyTable.LANGUAGE.Language or "english") == v[1] ) then
                    buttonText, buttonColor, buttonDownColor = BRICKS_SERVER.Func.L( "selected" ), BRICKS_SERVER.Func.GetTheme( 5 ), BRICKS_SERVER.Func.GetTheme( 4 )
                end

                if( not self2:IsDown() and self2:IsHovered() ) then
                    alpha = math.Clamp( alpha+5, 0, 200 )
                else
                    alpha = math.Clamp( alpha-5, 0, 255 )
                end

                draw.RoundedBox( 5, 0, 0, w, h, buttonColor )

                surface.SetAlphaMultiplier( alpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, buttonDownColor )
                surface.SetAlphaMultiplier( 1 )

                BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, buttonDownColor )

                draw.SimpleText( buttonText, "BRICKS_SERVER_Font20", w/2, h/2-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
            languageButton.DoClick = function()
                if( (BS_ConfigCopyTable.LANGUAGE.Language or "") == v[1] ) then return end

                BS_ConfigCopyTable.LANGUAGE.Language = v[1]
                BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
            end
        end

        -- Create new
        languageGrid.slots = (languageGrid.slots or 0)+1
        local slots = languageGrid.slots
        local slotsTall = math.ceil( slots/slotsWide )
        languageGrid:SetTall( (slotsTall*slotTall)+((slotsTall-1)*languageSpacing) )

        local createNewBack = vgui.Create( "DPanel", languageGrid )
        createNewBack:SetSize( actualSlotSize, slotTall )
        createNewBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

            draw.SimpleText( BRICKS_SERVER.Func.L( "createNew" ), "BRICKS_SERVER_Font25", w/2, h/3, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

            draw.SimpleText( BRICKS_SERVER.Func.L( "createNewLanguage" ), "BRICKS_SERVER_Font20", w/2, h/3, BRICKS_SERVER.Func.GetTheme( 5 ), TEXT_ALIGN_CENTER, 0 )
        end

        local createNewButton = vgui.Create( "DButton", createNewBack )
        createNewButton:Dock( BOTTOM )
        createNewButton:DockMargin( 10, 10, 10, 10 )
        createNewButton:SetTall( 40 )
        createNewButton:SetText( "" )
        local alpha = 0
        createNewButton.Paint = function( self2, w, h )
            if( not self2:IsDown() and self2:IsHovered() ) then
                alpha = math.Clamp( alpha+5, 0, 200 )
            else
                alpha = math.Clamp( alpha-5, 0, 255 )
            end

            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )

            surface.SetAlphaMultiplier( alpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            surface.SetAlphaMultiplier( 1 )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )

            draw.SimpleText( BRICKS_SERVER.Func.L( "create" ), "BRICKS_SERVER_Font20", w/2, h/2-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        createNewButton.DoClick = function()
            if( not BS_ConfigCopyTable.LANGUAGE.Languages ) then
                BS_ConfigCopyTable.LANGUAGE.Languages = {}
            end

            table.insert( BS_ConfigCopyTable.LANGUAGE.Languages, { "New Language", {} } )
            self.RefreshPanel()

            BRICKS_SERVER.Func.ConfigChange( "LANGUAGE" )
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_config_languages", PANEL, "DPanel" )
--PATH lua/bricks_server/vgui/bricks_server_dcategorylist.lua:

local PANEL = {}

function PANEL:Init()

	self.pnlCanvas:DockPadding( 0, 0, 0, 0 )

end

function PANEL:AddItem( item )

	item:Dock( TOP )
	DScrollPanel.AddItem( self, item )
	self:InvalidateLayout()

end

function PANEL:Add( name, backColor, fillBackColor )

	local Category = vgui.Create( "bricks_server_dcollapsiblecategory", self )
	Category:SetLabel( "" )
	Category:SetList( self )
	Category.backColor = backColor
	Category.headerText = name
	Category.fillBackColor = fillBackColor

	self:AddItem( Category )

	return Category

end

function PANEL:Paint( w, h )

end

function PANEL:UnselectAll()

	for k, v in pairs( self:GetChildren() ) do

		if ( v.UnselectAll ) then
			v:UnselectAll()
		end

	end

end

derma.DefineControl( "bricks_server_dcategorylist", "", PANEL, "bricks_server_scrollpanel" )

--PATH lua/bricks_server/vgui/bricks_server_menu.lua:
local PANEL = {}

function PANEL:Init()
    self:SetSize( ScrW()*0.6, ScrH()*0.65 )
    self:Center()
    self:SetHeader( BRICKS_SERVER.CONFIG.GENERAL["Server Name"] )
    self.removeOnClose = false
    self.centerOnSizeChanged = true

    self.onCloseFunc = function()
        if( BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then
            BRICKS_SERVER.Func.SendAdminConfig()
        end
    end

    if( BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then
		BS_ConfigCopyTable = table.Copy( BRICKS_SERVER.CONFIG )
	end
end

function PANEL:FillTabs()
    if( IsValid( self.sheet ) ) then
        if( IsValid( self.sheet.ActiveButton ) ) then
            self.previousSheet = self.sheet.ActiveButton.label
        end
        self.sheet:Remove()
    end

    local originalW, originalH = ScrW()*0.6, ScrH()*0.65 
    local newW = originalW+200

    self.sheet = vgui.Create( "bricks_server_colsheet", self )
    self.sheet:Dock( FILL )
    self.sheet.OnSheetChange = function( active )
        if( active.label == BRICKS_SERVER.Func.L( "config" ) and (self:GetWide() != newW or self:GetTall() != originalH) ) then
            self:SizeTo( newW, originalH, 0.2 )
        elseif( active.label != BRICKS_SERVER.Func.L( "config" ) and (self:GetWide() != originalW or self:GetTall() != originalH) ) then
            self:SizeTo( originalW, originalH, 0.2 )
        end
    end

    local donationRank
    for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
        if( BRICKS_SERVER.Func.IsInGroup( LocalPlayer(), v[1] ) ) then
            donationRank = k
            break
        end
    end

    local height = 55
    local avatarBackSize = height
    local textStartPos = 65
    
    local avatarBack = vgui.Create( "DPanel", self.sheet.Navigation )
    avatarBack:Dock( TOP )
    avatarBack:DockMargin( 10, 10, 0, 10 )
    avatarBack:SetTall( height )
    avatarBack.Paint = function( self2, w, h )
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
        draw.NoTexture()
        BRICKS_SERVER.Func.DrawCircle( (h-avatarBackSize)/2+(avatarBackSize/2), h/2, avatarBackSize/2, 45 )

        draw.SimpleText( LocalPlayer():Nick(), "BRICKS_SERVER_Font23", textStartPos, h/2+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )

        if( BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank] ) then
            draw.SimpleText( BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank][1], "BRICKS_SERVER_Font20", textStartPos, h/2-2, (BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank][3] or BRICKS_SERVER.Func.GetTheme( 5 )), 0, 0 )
        else
            draw.SimpleText( BRICKS_SERVER.Func.GetAdminGroup( LocalPlayer() ), "BRICKS_SERVER_Font20", textStartPos, h/2-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
        end
    end

    local distance = 2

    local avatarIcon = vgui.Create( "bricks_server_circle_avatar" , avatarBack )
    avatarIcon:SetPos( (height-avatarBackSize)/2+distance, (height-avatarBackSize)/2+distance )
    avatarIcon:SetSize( avatarBackSize-(2*distance), avatarBackSize-(2*distance) )
    avatarIcon:SetPlayer( LocalPlayer(), 64 )

    local profilePage = vgui.Create( "bricks_server_profile", self.sheet )
    profilePage:Dock( FILL )
    profilePage:DockMargin( 10, 10, 10, 10 )
    profilePage:FillPanel( self )
    profilePage.Paint = function( self, w, h ) end 
    self.sheet:AddSheet( BRICKS_SERVER.Func.L( "profile" ), profilePage, false, "profile_24.png" )

    local settingsPage = vgui.Create( "bricks_server_settings", self.sheet )
    settingsPage:Dock( FILL )
    settingsPage:DockMargin( 10, 10, 10, 10 )
    settingsPage.Paint = function( self, w, h ) end 
    self.sheet:AddSheet( BRICKS_SERVER.Func.L( "settings" ), settingsPage, false, "settings_24.png" )

    self.adminCreated = nil
    
    function self.RefreshAdminPerms()
        if( BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) and not self.adminCreated ) then
            self.sheet:AddLinebreak()
            
            -- PLAYERS PAGE --
            local adminPlayersPanelBack = vgui.Create( "bricks_server_admin", self.sheet )
            adminPlayersPanelBack:Dock( FILL )
            adminPlayersPanelBack.Paint = function( self, w, h ) end 
            self.sheet:AddSheet( BRICKS_SERVER.Func.L( "players" ), adminPlayersPanelBack, false, "players_24.png" )

            -- MODULES PAGE --
            local adminModulesPanel = vgui.Create( "bricks_server_config_modules", self.sheet )
            adminModulesPanel:Dock( FILL )
            adminModulesPanel.Paint = function( self, w, h ) end 
            self.sheet:AddSheet( BRICKS_SERVER.Func.L( "modules" ), adminModulesPanel, function()
                adminModulesPanel:FillPanel() 
            end, "modules_24.png" )

            -- CONFIG PAGE --
            local adminConfigPanel = vgui.Create( "bricks_server_config", self.sheet )
            adminConfigPanel:Dock( FILL )
            adminConfigPanel.Paint = function( self, w, h ) end 
            self.sheet:AddSheet( BRICKS_SERVER.Func.L( "config" ), adminConfigPanel, function()
                adminConfigPanel:FillPanel() 
            end, "admin_24.png" )

            self.adminCreated = true
        end
    end
    self.RefreshAdminPerms()

    if( self.previousSheet ) then
        self.sheet:SetActiveSheet( self.previousSheet )
    end
end

vgui.Register( "bricks_server_menu", PANEL, "bricks_server_dframe" )
--PATH lua/bricks_server/vgui/bricks_server_navcategorycollapse.lua:

local PANEL = {}

function PANEL:Init()
	self:SetContentAlignment( 4 )
	self:SetTextInset( 5, 0 )
	self:SetFont( "DermaDefaultBold" )

	self.changeAlpha = 0
end

function PANEL:DoClick()
	self:GetParent():Toggle()
	
	if( self:GetParent().OnNavCollapse ) then
		self:GetParent().OnNavCollapse( self.headerText, not self:GetParent():GetExpanded() )
	end
end

function PANEL:Paint( w, h )
	if( self:IsDown() ) then
		self.changeAlpha = 100
	elseif( self:IsHovered() ) then
		self.changeAlpha = math.Clamp( self.changeAlpha+10, 50, 75 )
	else
		self.changeAlpha = math.Clamp( self.changeAlpha-10, 50, 100 )
	end

	surface.SetAlphaMultiplier( self.changeAlpha/255 )
		surface.SetDrawColor( self.backColor or BRICKS_SERVER.Func.GetTheme( 4 ) )
		surface.DrawRect( 0, 0, w, h )
	surface.SetAlphaMultiplier( 1 )

	draw.SimpleText( (self.headerText or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font20", 10, h/2, (self.backColor or BRICKS_SERVER.Func.GetTheme( 5 )), 0, TEXT_ALIGN_CENTER )
end

derma.DefineControl( "bricks_server_navcategoryheader", "Category Header", PANEL, "DButton" )

local PANEL = {}

AccessorFunc( PANEL, "m_bSizeExpanded",		"Expanded", FORCE_BOOL )
AccessorFunc( PANEL, "m_iContentHeight",	"StartHeight" )
AccessorFunc( PANEL, "m_fAnimTime",			"AnimTime" )
AccessorFunc( PANEL, "m_bDrawBackground",	"PaintBackground", FORCE_BOOL )
AccessorFunc( PANEL, "m_bDrawBackground",	"DrawBackground", FORCE_BOOL ) -- deprecated
AccessorFunc( PANEL, "m_iPadding",			"Padding" )
AccessorFunc( PANEL, "m_pList",				"List" )

function PANEL:Init()
	self.Header = vgui.Create( "bricks_server_navcategoryheader", self )
	self.Header:Dock( TOP )
	self.Header:SetSize( 20, 30 )
	self.Header:SetText( "" )

	self:SetSize( 16, 16 )
	self:SetExpanded( true )
	self:SetMouseInputEnabled( true )

	self:SetAnimTime( 0.2 )
	self.animSlide = Derma_Anim( "Anim", self, self.AnimSlide )

	self:SetPaintBackground( true )
	self:DockPadding( 0, 0, 0, 5 )
end

function PANEL:UnselectAll()

	local children = self:GetChildren()
	for k, v in pairs( children ) do

		if ( v.SetSelected ) then
			v:SetSelected( false )
		end

	end

end

function PANEL:UpdateAltLines()

	local children = self:GetChildren()
	for k, v in pairs( children ) do
		v.AltLine = k % 2 != 1
	end

end

function PANEL:Think()

	self.animSlide:Run()

end

function PANEL:SetLabel( strLabel )
	self.Header.headerText = strLabel
end

function PANEL:GetLabel()
	return self.Header.headerText or ""
end

function PANEL:SetBackColor( color )
	self.Header.backColor = color
end

function PANEL:Paint( w, h )

end

function PANEL:SetContents( pContents )

	self.Contents = pContents
	self.Contents:SetParent( self )
	self.Contents:Dock( FILL )

	if ( !self:GetExpanded() ) then

		self.OldHeight = self:GetTall()

	elseif ( self:GetExpanded() && IsValid( self.Contents ) && self.Contents:GetTall() < 1 ) then

		self.Contents:SizeToChildren( false, true )
		self.OldHeight = self.Contents:GetTall()
		self:SetTall( self.OldHeight )

	end

	self:InvalidateLayout( true )

end

function PANEL:SetExpanded( expanded )
	self.m_bSizeExpanded = tobool( expanded )

	if ( !self:GetExpanded() ) then
		if ( !self.animSlide.Finished && self.OldHeight ) then return end
		self.OldHeight = self:GetTall()
	end
end

function PANEL:Toggle()
	self:SetExpanded( !self:GetExpanded() )

	self.animSlide:Start( self:GetAnimTime(), { From = self:GetTall() } )

	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

	local open = "1"
	if ( !self:GetExpanded() ) then open = "0" end
	self:SetCookie( "Open", open )

	self:OnToggle( self:GetExpanded() )
end

function PANEL:OnToggle( expanded )

	-- Do nothing / For developers to overwrite

end

function PANEL:DoExpansion( b )

	if ( self:GetExpanded() == b ) then return end
	self:Toggle()

end

function PANEL:PerformLayout()

	if ( IsValid( self.Contents ) ) then

		if ( self:GetExpanded() ) then
			self.Contents:InvalidateLayout( true )
			self.Contents:SetVisible( true )
		else
			self.Contents:SetVisible( false )
		end

	end

	if ( self:GetExpanded() ) then

		if ( IsValid( self.Contents ) && #self.Contents:GetChildren() > 0 ) then self.Contents:SizeToChildren( false, true ) end
		self:SizeToChildren( false, true )

	else

		if ( IsValid( self.Contents ) && !self.OldHeight ) then self.OldHeight = self.Contents:GetTall() end
		self:SetTall( self.Header:GetTall() )

	end

	-- Make sure the color of header text is set
	self.Header:ApplySchemeSettings()

	self.animSlide:Run()
	self:UpdateAltLines()

end

function PANEL:OnMousePressed( mcode )

	if ( !self:GetParent().OnMousePressed ) then return end

	return self:GetParent():OnMousePressed( mcode )

end

function PANEL:AnimSlide( anim, delta, data )

	self:InvalidateLayout()
	self:InvalidateParent()

	if ( anim.Started ) then
		if ( !IsValid( self.Contents ) && ( self.OldHeight || 0 ) < self.Header:GetTall() ) then
			-- We are not using self.Contents and our designated height is less
			-- than the header size, something is clearly wrong, try to rectify
			self.OldHeight = 0
			for id, pnl in pairs( self:GetChildren() ) do
				self.OldHeight = self.OldHeight + pnl:GetTall()
			end
		end

		if ( self:GetExpanded() ) then
			data.To = math.max( self.OldHeight, self:GetTall() )
		else
			data.To = self:GetTall()
		end
	end

	if ( IsValid( self.Contents ) ) then self.Contents:SetVisible( true ) end

	self:SetTall( Lerp( delta, data.From, data.To ) )

end

function PANEL:LoadCookies()

	local Open = self:GetCookieNumber( "Open", 1 ) == 1

	self:SetExpanded( Open )
	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

end

derma.DefineControl( "bricks_server_navcategorycollapse", "Collapsable Category Panel", PANEL, "Panel" )

--PATH addons/sl_main_system/lua/autorun/client/cl_net.lua:
-- cl

net.Receive("SL:Anim_Play", function()
    local ply = net.ReadEntity()
    local seq = net.ReadString()
	if ( IsValid( ply ) ) then
		ply:AddVCDSequenceToGestureSlot( 6, ply:LookupSequence( seq ), 0, true)
	end
end)

net.Receive("SL:PO:ParticleEffectAttach", function(ply)
    local particletable = net.ReadTable()
    local attachType = net.ReadFloat()
    local entity = net.ReadEntity()
    local attachmentID = net.ReadInt()

    for _, particle in ipairs(particletable) do
        ParticleEffectAttach(particle, attachType, entity, attachmentID)
    end
end)

net.Receive("SL:PO:ParticleEffectPosPlayer", function()
    local particletable = net.ReadTable()
    local entity = net.ReadEntity()

    for _, particle in ipairs(particletable) do
        ParticleEffect(particle, entity:GetPos(), entity:GetAngles(), entity) 
    end
end)

net.Receive("SL:sendservertoclientdata_inv_equip", function(ply) 

    sl_data5 = net.ReadTable()

end)

net.Receive("SL:sendservertoclientdata_inv_banque", function(ply) 

    sl_data7 = net.ReadTable()

end)

net.Receive("SL:sendservertoclientdata", function(ply) 

    sl_data = net.ReadTable()

end)

net.Receive("SL:sendservertoclientdata_stats", function(ply) 

    sl_data2 = initsl_data2 or {}

    sl_data2["pts"] = net.ReadFloat()
    sl_data2["rerollstats"] = net.ReadFloat()
    sl_data2["force"] = net.ReadFloat()
    sl_data2["agilite"] = net.ReadFloat()
    sl_data2["sens"] = net.ReadFloat()
    sl_data2["vitalite"] = net.ReadFloat()
    sl_data2["intelligence"] = net.ReadFloat()

end)

net.Receive("SL:sendservertoclientdata_rerolls", function(ply) 

    sl_data3 = initsl_data3 or {}

    sl_data3["classe"] = net.ReadInt(32)
    sl_data3["magie"] = net.ReadInt(32)
    sl_data3["rang"] = net.ReadInt(32)

end)

net.Receive("SL:sendservertoclientdata_skills", function(ply) 

    sl_data4 = net.ReadTable()

end)

net.Receive("SL:sendservertoclientdata_classe", function(ply) 
    
    Classe1 = net.ReadString()

end)

net.Receive("SL:sendservertoclientdata_rang", function(ply) 
    
    Rang = net.ReadString()

end)

net.Receive("SL:sendservertoclientdata_magie", function(ply) 
    
    Magie = net.ReadString()

end)


local hook_Add = hook.Add
local surface_PlaySound = surface.PlaySound
local status_frame = Material("seefox/newera/status/background.png")
local status_barre = Material("sl_Barre.png")
local status_ligne = Material("sl_ligne.png")
local statusBT = {
    [1] = "force",
    [2] = "agilite",
    [3] = "intelligence",
    [4] = "vitalite"
}
local function W(s)
    return ScrW() / 1920 * s
end

local function H(s)
    return ScrH() / 1080 * s
end

-- Table pour stocker les options
local options = {
    { type = "keybind", label = "Bind - Attaque 1", convar = "sl_attaque1", default = "1" },
	{ type = "keybind", label = "Bind - Attaque 2", convar = "sl_attaque2", default = "2" },
	{ type = "keybind", label = "Bind - Attaque 3", convar = "sl_attaque3", default = "3" },
	{ type = "keybind", label = "Bind - Attaque 4", convar = "sl_attaque4", default = "4" },
}

-- Crée les ConVars selon la table options
for _, option in ipairs(options) do
    if option.type == "checkbox" then
        CreateClientConVar(option.convar, option.default, true, true)
    elseif option.type == "keybind" then
        CreateClientConVar(option.convar, option.default, true, true)
    end
end
local binds_frame = Material("binds_menu.png")
local bindsBtn = Material("SetBindsBTN.png")
local function OpenOptionsMenu()
    surface_PlaySound("buttons/button15.wav")

    local Frame_Options = vgui.Create("DFrame")
    Frame_Options:SetSize(W(699), H(351))
    Frame_Options:SetTitle("")
    Frame_Options:MakePopup()
    Frame_Options:ShowCloseButton(false)
    Frame_Options:SetDraggable(false)
    Frame_Options:Center()
    Frame_Options:SetAlpha(0)
    Frame_Options:AlphaTo(255, 1, 0)
    Frame_Options.Paint = function(s, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(binds_frame)
        surface.DrawTexturedRect(W(0), H(0), w, h)
    end

    local CloseButton = vgui.Create("DButton", Frame_Options)
    CloseButton:SetText("")
    CloseButton:SetPos(W(635), H(15))
    CloseButton:SetSize(W(50), H(50))
    CloseButton.DoClick = function()
        if IsValid(Frame_Options) then
            Frame_Options:Remove()
        end
    end
    CloseButton.Paint = function(s, w, h)
        draw.SimpleText('X', "B_Font6", w/2, 0, Color(255, 255, 255), TEXT_ALIGN_CENTER)
    end

    -- PrintTable(options[1])
    local KeyBindBinder = vgui.Create("DBinder", Frame_Options)
    KeyBindBinder:SetPos(W(240), H(200))
    KeyBindBinder:SetSize(W(61), H(34))
    KeyBindBinder:SetConVar(options[1].convar)
    KeyBindBinder:SetFont("M_Font5")
    KeyBindBinder:SetTextColor( Color(235,235,235) )
    KeyBindBinder.Paint = function(self,w,h)
        -- draw.RoundedBox(2, 0, 0, w, h, Color(44,59,105,255))
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(bindsBtn)
        surface.DrawTexturedRect(W(0), H(0), w, h)
    end
    local KeyBindBinder = vgui.Create("DBinder", Frame_Options)
    KeyBindBinder:SetPos(W(240), H(270))
    KeyBindBinder:SetSize(W(61), H(34))
    KeyBindBinder:SetConVar(options[2].convar)
    KeyBindBinder:SetFont("M_Font5")
    KeyBindBinder:SetTextColor( Color(235,235,235) )
    KeyBindBinder.Paint = function(self,w,h)
        -- draw.RoundedBox(2, 0, 0, w, h, Color(44,59,105,255))
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(bindsBtn)
        surface.DrawTexturedRect(W(0), H(0), w, h)
    end
    local KeyBindBinder = vgui.Create("DBinder", Frame_Options)
    KeyBindBinder:SetPos(W(401), H(200))
    KeyBindBinder:SetSize(W(61), H(34))
    KeyBindBinder:SetConVar(options[3].convar)
    KeyBindBinder:SetFont("M_Font5")
    KeyBindBinder:SetTextColor( Color(235,235,235) )
    KeyBindBinder.Paint = function(self,w,h)
        -- draw.RoundedBox(2, 0, 0, w, h, Color(44,59,105,255))
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(bindsBtn)
        surface.DrawTexturedRect(W(0), H(0), w, h)
    end
    local KeyBindBinder = vgui.Create("DBinder", Frame_Options)
    KeyBindBinder:SetPos(W(401), H(270))
    KeyBindBinder:SetSize(W(61), H(34))
    KeyBindBinder:SetConVar(options[4].convar)
    KeyBindBinder:SetFont("M_Font5")
    KeyBindBinder:SetTextColor( Color(235,235,235) )
    KeyBindBinder.Paint = function(self,w,h)
        -- draw.RoundedBox(2, 0, 0, w, h, Color(44,59,105,255))
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(bindsBtn)
        surface.DrawTexturedRect(W(0), H(0), w, h)
    end
end

hook_Add("OnPlayerChat", "OpenOptionsMenuOnChat", function(ply, strText, bTeam, bDead)
    if ply ~= LocalPlayer() then
        return
    end
    strText = string.lower(strText)
    if strText == "!options" then
        OpenOptionsMenu()
        return true
    end
end)
local mainMenu = Material("cmenu_main.png")
local classeBtn = Material("classe_btn.png")
local skillsBtn = Material("skills_btn.png")
local statusBtn = Material("status_btn.png")
local invBtn = Material("invBtn.png")
local bindsBtn = Material("BindsBTN.png")
local close_Btn = Material("leave_Btn.png")
local discord_btn = Material("discordBtn.png")

-- net.Receive("SL:MainMenu", function( len, ply )
function SL_MainMenu()
    local ply = LocalPlayer()

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(0), H(0))
    Frame_Status:SetSize(W(1920), H(1080))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(mainMenu)
		surface.DrawTexturedRect(W(1920-655),H(0),W(655),H(1080))

        draw.SimpleText(LocalPlayer():Nick(), "B_Font7", W(1430), H(50), Color(255, 255, 255), TEXT_ALIGN_LEFT)
        draw.SimpleText(LocalPlayer():SteamID64(), "B_Font1", W(1430), H(90), Color(255, 186, 0), TEXT_ALIGN_LEFT)
        draw.SimpleText("LV. "..LocalPlayer():getDarkRPVar("level"), "B_Font5", W(1362), H(140), Color(255, 255, 255), TEXT_ALIGN_CENTER)
    end
    local closeBtn = vgui.Create("DButton", Frame_Status)
    closeBtn:SetText("")
    closeBtn:SetPos(W(1851), H(31))
    closeBtn:SetSize(W(41), H(64))
    closeBtn.DoClick = function()
        if IsValid(Frame_Status) then
            Frame_Status:Remove()
        end
    end
    closeBtn.Paint = function(s, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(close_Btn)
        surface.DrawTexturedRect(W(0), H(0), W(w), H(h))
    end
    local discordBtn = vgui.Create("DButton", Frame_Status)
    discordBtn:SetText("")
    discordBtn:SetPos(W(1846), H(176))
    discordBtn:SetSize(W(50), H(50))
    discordBtn.DoClick = function()
        gui.OpenURL("https://discord.gg/nwsl")
    end
    discordBtn.Paint = function(s, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(discord_btn)
        surface.DrawTexturedRect(W(0), H(0), W(w), H(h))
    end
    local Btn_Options = vgui.Create( "DButton", Frame_Status )
	Btn_Options:SetText( "" )
	Btn_Options:SetPos( W(1522), H(1001) )
	Btn_Options:SetSize( W(140), H(63) )
	Btn_Options.DoClick = function()
        OpenOptionsMenu()
        if IsValid(Frame_Status) then Frame_Status:Remove() end
	end
    Btn_Options.Paint = function( self, w, h )
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(bindsBtn)
        surface.DrawTexturedRect(W(0),H(0),W(w),H(h))
    end

    local Btn_Inventaire = vgui.Create( "DButton", Frame_Status )
	Btn_Inventaire:SetText( "" )
	Btn_Inventaire:SetPos( W(1328), H(452) )
	Btn_Inventaire:SetSize( W(453), H(107) )
	Btn_Inventaire.DoClick = function()
        OpenInventaire()
        if IsValid(Frame_Status) then Frame_Status:Remove() end
	end
    Btn_Inventaire.Paint = function( self, w, h )
        surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(invBtn)
		surface.DrawTexturedRect(W(0),H(0),W(453),H(107))
    end

    local Btn_Skills = vgui.Create( "DButton", Frame_Status )
	Btn_Skills:SetText( "" )
	Btn_Skills:SetPos( W(1328), H(644) )
	Btn_Skills:SetSize( W(453), H(107) )
	Btn_Skills.DoClick = function()
        OpenSkillsMenu()
        if IsValid(Frame_Status) then Frame_Status:Remove() end
	end
    Btn_Skills.Paint = function( self, w, h )
        surface.SetDrawColor(255, 255, 255)
		surface.SetMaterial(skillsBtn)
		surface.DrawTexturedRect(W(0),H(0),W(453),H(107))
    end

    local Btn_Classe = vgui.Create( "DButton", Frame_Status )
	Btn_Classe:SetText( "" )
	Btn_Classe:SetPos( W(1328), H(836) )
	Btn_Classe:SetSize( W(453), H(107) )
	Btn_Classe.DoClick = function()
        OpenClasseMenu()
        if IsValid(Frame_Status) then Frame_Status:Remove() end
	end
    Btn_Classe.Paint = function( self, w, h )
        surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(classeBtn)
		surface.DrawTexturedRect(W(0),H(0),W(453),H(107))
    end

    -- local Btn_Rang = vgui.Create( "DButton", Frame_Status )
	-- Btn_Rang:SetText( "" )
	-- Btn_Rang:SetPos( W(1052), H(568) )
	-- Btn_Rang:SetSize( W(99), H(152) )
	-- Btn_Rang.DoClick = function()
    --     OpenRangMenu()
    --     if IsValid(Frame_Status) then Frame_Status:Remove() end
	-- end
    -- Btn_Rang.Paint = function( s, self, w, h )
    -- end

    local Btn_Status = vgui.Create( "DButton", Frame_Status )
	Btn_Status:SetText( "" )
	Btn_Status:SetPos( W(1328), H(279) )
	Btn_Status:SetSize( W(453), H(107) )
	Btn_Status.DoClick = function()
        OpenStatus()
        if IsValid(Frame_Status) then Frame_Status:Remove() end
	end
    Btn_Status.Paint = function(self, w, h )
        surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(statusBtn)
		surface.DrawTexturedRect(W(0),H(0),W(453),H(107))
    end

end
-- end)
local reset_stats_icon = Material("resetstatssl.png")
function OpenStatus()
    surface_PlaySound("buttons/button15.wav")

	local health = LocalPlayer():Health()
	local maxHp = LocalPlayer():GetMaxHealth()

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetSize(W(1390.5), H(787.5))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:Center()
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function(self, w, h )
		surface.SetDrawColor(255, 255, 255,240)
		surface.SetMaterial(status_frame)
		surface.DrawTexturedRect(W(0),H(0),w,h)

        -- draw.DrawText( ""..LocalPlayer():Nick(), "MNew_Font6", W(735+105), H(323-5), Color(255,255,255), TEXT_ALIGN_LEFT )
        if LocalPlayer():GetNWString("Classe") != "Aucune" then
            draw.DrawText(LocalPlayer():GetNWString("Classe"), "B_Font1", W(772), H(235), Color(255,255,255) )
        else
            draw.DrawText( "Aucune", "B_Font1", W(772), H(235), Color(255,255,255), TEXT_ALIGN_LEFT )
        end

        /*if LocalPlayer():GetNWString("Titre") != "RIEN" then
            draw.DrawText( LocalPlayer():GetNWString("Titre"), "B_Font1", W(787), H(265), Color(255,255,255), TEXT_ALIGN_LEFT )
        else
            draw.DrawText( "Aucun", "B_Font1", W(787), H(265), Color(255,255,255), TEXT_ALIGN_LEFT )
        end*/

        if LocalPlayer():GetNWInt("Rang") != "Aucune" then
            draw.DrawText( LocalPlayer():GetNWInt("Rang"), "B_Font1", W(787), H(265), Color(255,255,255), TEXT_ALIGN_LEFT )
        else
            draw.DrawText( "Non Evalué", "B_Font1", W(787), H(265), Color(255,255,255), TEXT_ALIGN_LEFT )
        end

        draw.DrawText( LocalPlayer():getDarkRPVar("level"), "B_Font2", W(655), H(210), Color(255,255,255), TEXT_ALIGN_CENTER )

        local vie_largeur = (LocalPlayer():Health() / LocalPlayer():GetMaxHealth()) * W(139)
        if vie_largeur > W(139) then
            vie_largeur = W(139)
        end
        surface.SetDrawColor( 255, 255, 255, 255 ) 
        surface.SetMaterial( status_ligne ) 
        surface.DrawTexturedRect( W(501), H(358), vie_largeur, H(10) )

        surface.SetDrawColor(255, 255, 255)
		surface.SetMaterial(status_barre)
		surface.DrawTexturedRect(W(501),H(358),W(141),H(10))

        draw.DrawText( health.. " / "..maxHp, "B_Font3", W(595), H(373), Color(255,255,255), TEXT_ALIGN_CENTER )

        local mana_largeur = (LocalPlayer():GetNWInt("mad_stamina") / LocalPlayer():GetNWInt("mana")) * W(139)
        if mana_largeur > W(139) then
            mana_largeur = W(139)
        end

        surface.SetDrawColor( 255, 255, 255, 255 ) 
        surface.SetMaterial( status_ligne ) 
        surface.DrawTexturedRect( W(701), H(358), mana_largeur, H(10) )

        surface.SetDrawColor(255, 255, 255)
		surface.SetMaterial(status_barre)
		surface.DrawTexturedRect(W(701),H(358),W(141),H(10))

        draw.DrawText( LocalPlayer():GetNWInt("mad_stamina").. " / "..LocalPlayer():GetNWInt("mana"), "B_Font3", W(785), H(373), Color(255,255,255), TEXT_ALIGN_LEFT )

        -- draw.DrawText( "0", "B_Font1", W(939), H(372), Color(255,255,255), TEXT_ALIGN_LEFT )

        draw.DrawText( sl_data2["force"], "B_Font1", W(620), H(475), Color(255,255,255), TEXT_ALIGN_LEFT ) -- FORCE
        draw.DrawText( sl_data2["agilite"], "B_Font1", W(620), H(511), Color(255,255,255), TEXT_ALIGN_LEFT ) -- AGILITE
        draw.DrawText( sl_data2["intelligence"], "B_Font1", W(620), H(547), Color(255,255,255), TEXT_ALIGN_LEFT ) -- INTELLIGENCE
        draw.DrawText( sl_data2["vitalite"], "B_Font1", W(620), H(585), Color(255,255,255), TEXT_ALIGN_LEFT ) -- VITALITE

        draw.DrawText( sl_data2["pts"], "B_Font2", W(915), H(575), Color(255,255,255), TEXT_ALIGN_CENTER ) -- POINTS RESTANT
        draw.DrawText( sl_data2["rerollstats"], "B_Font6", W(945), H(448), Color(255,255,255), TEXT_ALIGN_LEFT ) -- REROLLSTATS RESTANT
    end

    local ResetStats_Button = vgui.Create( "DButton", Frame_Status )
	ResetStats_Button:SetText( "" )
	ResetStats_Button:SetPos( W(915), H(450) )
	ResetStats_Button:SetSize( W(25), H(25) )
	ResetStats_Button.DoClick = function()
		if IsValid(Frame_Status) then
            net.Start("SL:Mad - Stats:ResetStats")
            net.SendToServer()
		end
	end
	ResetStats_Button.Paint = function( self, w, h )
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(reset_stats_icon)
        surface.DrawTexturedRect(W(0),H(0),W(w),H(h))
	end
    local hauteur = H(476)
    for i = 1, 4 do
        local Up_Stats = vgui.Create( "DButton", Frame_Status )
        Up_Stats:SetText( "" )
        Up_Stats:SetPos( W(665), hauteur )
        Up_Stats:SetSize( W(20), H(20) )
        Up_Stats.Paint = function( self, w, h )
            draw.RoundedBox(5,0,0,w,h, Color(49,65,85))
            if Up_Stats:IsHovered() then
                draw.SimpleText("+", "B_Font5", w/2,0, Color(22,116,42),TEXT_ALIGN_CENTER)
            else
                draw.SimpleText("+", "B_Font5", w/2,0, color_white,TEXT_ALIGN_CENTER)
            end
        end
        local amount = vgui.Create("DTextEntry",Frame_Status)
        amount:SetSize(W(30),H(30))
        amount:SetPos(W(700),H(hauteur) - H(15))
        amount:SetPaintBackground(false)
        amount:SetTextColor(color_white)
        amount:SetNumeric(true)
        amount:SetFont('B_Font1')
        amount:SetText('1')
        amount:SetDrawLanguageID(false)
        amount:SetCursorColor(Color(255,255,255))
        Up_Stats.DoClick = function()
            if IsValid(Frame_Status) then
                if amount:GetValue() == nil then 
                    amount_stats = 1
                else
                    amount_stats = amount:GetValue()
                end
                net.Start("SL:Mad - Stats:Up")
                net.WriteString(statusBT[i])
                net.WriteFloat(amount_stats)
                net.SendToServer()
            end
        end
        hauteur = hauteur + H(37)
    end

    local CloseB = vgui.Create( "DButton", Frame_Status )
	CloseB:SetText( "" )
	CloseB:SetPos( W(1065), H(111) )
	CloseB:SetSize( W(40), H(40) )
	CloseB.DoClick = function()
        Frame_Status:AlphaTo(0, 0.5, 0)
        timer.Simple(0.5, function()
            if IsValid(Frame_Status) then
                Frame_Status:Remove()
            end
        end)
	end
	CloseB.Paint = function(self, w, h )
        if CloseB:IsHovered() then
            draw.SimpleText("X", "B_Font4", W(0),H(0),Color(105,23,23))
        else
            draw.SimpleText("X", "B_Font4", W(0),H(0),Color(255,255,255))
        end
	end
end

concommand.Add("openstatus", function() OpenStatus() end)

net.Receive("SL:OpenStatus", function( len, ply )
    OpenStatus()
end)

net.Receive("SL:OpenSell", function( len, ply )

    local achat_selec = ""

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(0), H(0))
    Frame_Status:SetSize(H(1920), H(1080))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/magasin.png"))
		surface.DrawTexturedRect(W(0),H(0),W(1920),H(1080))
    end

    local CloseB = vgui.Create( "DButton", Frame_Status )
	CloseB:SetText( "" )
	CloseB:SetPos( W(1490), H(195) )
	CloseB:SetSize( W(30), H(25) )
	CloseB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
	end
	CloseB.Paint = function( s, self, w, h )
	end
    local ScrollPanel = vgui.Create("DScrollPanel", Frame_Status)
    ScrollPanel:SetPos(W(409), H(360))
    ScrollPanel:SetSize(W(1109), H(560))
    
    local InvGrid = vgui.Create("DGrid", ScrollPanel)
    InvGrid:SetPos(0, 0)
    InvGrid:SetSize(W(80), H(80))
    InvGrid:SetCols(10)
    InvGrid:SetColWide(W(110))
    InvGrid:SetRowHeight(H(120))

    InvGrid.Paint = function( s, self, w, h )
    end

    for k, v in pairs(INV_SL) do
        if INV_SL[k].type == "item" then

            local InvBut = vgui.Create("DModelPanel")
            local InvBut2 = vgui.Create("DModelPanel", InvBut)

            if string.StartWith(v.type, "item") then
                InvButCrystal = vgui.Create("DImage", InvBut)
                InvButCrystal:SetSize(W(87), H(87))
    
                if v.name == "Crystal Blanc" then
                    InvButCrystal:SetImage("mad_sololeveling/crystal_icon.png")
                elseif v.name == "Crystal Bleu" then
                    InvButCrystal:SetImage("mad_sololeveling/crystal_icon2.png")
                elseif v.name == "Crystal Rouge" then
                    InvButCrystal:SetImage("mad_sololeveling/crystal_icon3.png")
                elseif v.name == "Crystal Violet" then
                    InvButCrystal:SetImage("mad_sololeveling/crystal_icon4.png")
                elseif v.name == "Minerai de Mana" then
                    InvBut:SetImage("mad_sololeveling/minerai.png")
                else
                    InvButCrystal:SetImage("mad_sololeveling/crystal_icon.png")
                end

                InvBut:MoveToFront()
                InvBut2:MoveToFront()

                InvBut2:SetModel("")
                InvBut:SetModel("")
                
            else

                InvBut2:SetModel(v.model)
                InvBut:SetModel(v.model)

                InvBut:SetLookAt(InvBut:GetEntity():GetPos())
                InvBut:GetEntity():SetAngles(Angle(0, 0, 0))
                InvBut:GetEntity():SetModelScale(v.scale * 2)

                InvBut2:SetLookAt(InvBut:GetEntity():GetPos())
                InvBut2:GetEntity():SetAngles(Angle(0, 0, 0))
                InvBut2:GetEntity():SetModelScale(v.scale * 2)
            end

            local breen_img = vgui.Create("DImage", InvBut)
            breen_img:SetPos(InvBut:GetX(), InvBut:GetY())
            breen_img:SetSize(W(87), H(87))
            breen_img:SetImage("mad_sololeveling/menu/new/casse")
            breen_img.Paint = function( s, self, w, h )
                surface.SetDrawColor(255, 255, 255, 255)
                surface.SetMaterial(Material("mad_sololeveling/menu/new/casse.png"))
                surface.DrawTexturedRect(W(0),H(0),W(87), H(87))
            end
            
            InvBut:SetSize(ScrW() * 0.046875, ScrH() * 0.08333333333)
            InvBut:SetModel(v.model)

            InvBut2:SetFOV(80)
            InvBut:SetFOV(80)

            InvBut:SetText(formatMoney(v.sellprice))
            InvBut:SetTooltip(v.name)
            InvBut:SetTextColor(Color(255, 255, 255))
            InvBut:SetContentAlignment(2)
            InvBut:SetFont("M_Font3")
            InvBut.InternalValue = k

            function InvBut:LayoutEntity(ent)
            end

            InvBut.Paint = function( s, self, w, h )
            end

            InvBut2:SetSize(ScrW() * 0.046875, ScrH() * 0.08333333333)
            InvBut2:SetFOV(80)

            InvBut2:SetText(formatMoney(v.sellprice))
            InvBut2:SetTooltip(v.name)
            InvBut2:SetTextColor(Color(255, 255, 255))
            InvBut2:SetFont("M_Font3")
            InvBut2:SetContentAlignment(2)
            InvBut2.InternalValue = k

            function InvBut:LayoutEntity(ent)
            end

            function InvBut2:LayoutEntity(ent)
            end
        
            InvBut2.DoClick = function(self)
                achat_selec = k
                net.Start("SL:Mad - Shop:Vendre")
                net.WriteString(achat_selec)
                net.SendToServer()
                print(achat_selec)

                if IsValid(Frame_Status) then Frame_Status:Remove() end
            end
        
                InvGrid:AddItem(InvBut)
            end
    end
    
end)

net.Receive("SL:OpenShop", function( len, ply )

    local achat_selec = ""

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(0), H(0))
    Frame_Status:SetSize(H(1920), H(1080))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/magasin.png"))
		surface.DrawTexturedRect(W(0),H(0),w,h)
    end

    local CloseB = vgui.Create( "DButton", Frame_Status )
	CloseB:SetText( "" )
	CloseB:SetPos( W(1490), H(195) )
	CloseB:SetSize( W(30), H(25) )
	CloseB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
	end
	CloseB.Paint = function( s, self, w, h )
	end
    local ScrollPanel = vgui.Create("DScrollPanel", Frame_Status)
    ScrollPanel:SetPos(W(409), H(360))
    ScrollPanel:SetSize(W(1109), H(560))
    
    local InvGrid = vgui.Create("DGrid", ScrollPanel)
    InvGrid:SetPos(0, 0)
    InvGrid:SetSize(W(80), H(80))
    InvGrid:SetCols(10)
    InvGrid:SetColWide(W(110))
    InvGrid:SetRowHeight(H(120))

    InvGrid.Paint = function( s, self, w, h )
    end

    -- Créer une table temporaire pour stocker les éléments triés par prix
    local sortedItems = {}

    -- Remplir la table temporaire avec des éléments triés par prix
    for k, v in pairs(INV_SL) do
        -- if INV_SL[k].canbebuy == false then return end
        if INV_SL[k].type != "item" then
            if INV_SL[k].canbebuy == false then
            else
                if INV_SL[k].teambuy == false then
                    if INV_SL[k].isforaspecialclass == true then
                        if INV_SL[k].classe[LocalPlayer():GetNWString("Classe")] then table.insert(sortedItems, { key = k, price = v.price }) end
                    else
                        table.insert(sortedItems, { key = k, price = v.price })
                    end
                else

                    if LocalPlayer():Team() == INV_SL[k].theteam then
                        table.insert(sortedItems, { key = k, price = v.price })
                    end

                end
            end
        end
    end

    -- Triez la table temporaire par prix de manière décroissante
    table.sort(sortedItems, function(a, b) return a.price < b.price end)
    
    for _, entry in ipairs(sortedItems) do
        local k = entry.key
        local v = INV_SL[k]

        local InvBut = vgui.Create("DModelPanel")
        InvBut:SetAnimated(false)

        local breen_img = vgui.Create("DImage", InvBut)
        breen_img:SetPos(InvBut:GetX(), InvBut:GetY())
        breen_img:SetSize(W(87), H(87))
        breen_img:SetImage("mad_sololeveling/menu/new/casse")
        breen_img.Paint = function( self, w, h )
            surface.SetDrawColor(255, 255, 255, 255)
            surface.SetMaterial(Material("mad_sololeveling/menu/new/casse.png"))
            surface.DrawTexturedRect(W(0),H(0),W(87), H(87))

            if v.type == "accessoire" then
                surface.SetDrawColor(255, 255, 255, 255)
                surface.SetMaterial(Material(v.img))
                surface.DrawTexturedRect(W(18.5),H(18.5),W(50), H(50))
            end
            if v.type == "sac" or v.type == "botte"  or v.type == "casque" or v.type == "plastron" or v.type == "pantalon" or v.type == "bague" then
                surface.SetDrawColor(255, 255, 255, 255)
                surface.SetMaterial(Material(v.img))
                surface.DrawTexturedRect(W(18.5),H(18.5),W(50), H(50))
            end

            draw.SimpleText(formatMoney(v.price), "M_Font5", w/2, h*.8, color_white, 1, 1)
        end
        
        InvBut:SetSize(ScrW() * 0.046875, ScrH() * 0.08333333333)
        if v.type == "armure" && LocalPlayer():GetNWInt("Genre") == "male" then
            InvBut:SetModel(v.playermodel_male)
        elseif v.type == "armure" and LocalPlayer():GetNWInt("Genre") == "female" then
            InvBut:SetModel(v.playermodel_female)
        elseif v.type == "accessoire" then
            InvBut:SetModel("models/price.mdl")
        elseif v.type == "sac" or v.type == "botte"  or v.type == "casque" or v.type == "plastron" or v.type == "pantalon" or v.type == "bague"then
            InvBut:SetModel("models/price.mdl")
        else

            InvBut:SetModel(v.model)
        end
        -- PrintTable(v)
        if v.type == "armure" then
            InvBut:SetFOV(20)
        else
            InvBut:SetFOV(50)
        end

        -- InvBut:SetText(formatMoney(v.price))
        InvBut:SetTooltip(v.name)
        InvBut:SetTextColor(Color(255, 255, 255))
        InvBut:SetContentAlignment(2)
        InvBut:SetFont("M_Font5")
        InvBut:SetLookAt(InvBut:GetEntity():GetPos())
        InvBut:GetEntity():SetAngles(Angle(0, 0, 0))
        InvBut:GetEntity():SetModelScale(v.scale * 2)
        InvBut.InternalValue = k

        function InvBut:LayoutEntity(ent)
        end

        InvBut.Paint = function( s, self, w, h )
        end

        local InvBut2 = vgui.Create("DModelPanel", InvBut)
        InvBut2:SetSize(ScrW() * 0.046875, ScrH() * 0.08333333333)
        InvBut2:SetAnimated(false)
        if v.type == "armure" && LocalPlayer():GetNWInt("Genre") == "male" then
            InvBut2:SetModel(v.playermodel_male)
        elseif v.type == "armure" and LocalPlayer():GetNWInt("Genre") == "female" then
            InvBut2:SetModel(v.playermodel_female)
        elseif v.type == "accessoire" then
            InvBut2:SetModel("models/buellost/crystal_grey.mdl")
        elseif v.type == "sac" or v.type == "botte"  or v.type == "casque" or v.type == "plastron" or v.type == "pantalon" or v.type == "bague"then
            InvBut2:SetModel("models/price.mdl")
        else
            InvBut2:SetModel(v.model)
        end

        if v.type == "armure" then
            InvBut2:SetFOV(20)
        else
            InvBut2:SetFOV(50)
        end

        InvBut2:SetText("")
        InvBut2:SetTooltip(v.name)
        InvBut2:SetTextColor(Color(255, 255, 255))
        InvBut2:SetFont("M_Font3")
        InvBut2:SetLookAt(InvBut2:GetEntity():GetPos() + Vector(0, 0, 5))
        InvBut2:GetEntity():SetAngles(Angle(0, 90, 0))
        InvBut2:GetEntity():SetModelScale(v.scale * 2.2)
        InvBut2.InternalValue = k
        
        InvBut2:SetAnimated(true)

        local dance = InvBut2:GetEntity():LookupSequence("idle")
        InvBut2:GetEntity():SetSequence(dance)

        function InvBut:LayoutEntity(ent)
        end

        function InvBut2:LayoutEntity(ent)
        end
    
        InvBut2.DoClick = function(self)
            achat_selec = k
            net.Start("SL:Mad - Shop:Acheter")
            net.WriteString(achat_selec)
            net.SendToServer()
            print(achat_selec)

            if IsValid(Frame_Status) then Frame_Status:Remove() end
        end
    
            InvGrid:AddItem(InvBut)
        end
    
end)

local reroll_frameimg = Material("reroll_frame.png")
local reroll_back = Material("reroll_back.png")
local default_pos = {
    ["main"] = 0,
    ["left"] = 257,
    ["half-left"] = 514,
    ["r"] = 771,
    ["hr"] = 1028,
}

function OpenClasseMenu()
    LocalPlayer():ConCommand("seefox_reroll")
    if true then return end

    surface_PlaySound("buttons/button15.wav")

    LocalPlayer():ConCommand("actu_client")

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(552), H(232))
    Frame_Status:SetSize(H(814), H(611))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(true)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/classe2.png"))
		surface.DrawTexturedRect(W(0),H(0),W(814),H(611))
        draw.DrawText( sl_data3["classe"], "MNew_Font6", W(295), H(421), Color(255,255,255), TEXT_ALIGN_LEFT ) -- POINTS RESTANT
    end

    local CloseB = vgui.Create( "DButton", Frame_Status )
	CloseB:SetText( "" )
	CloseB:SetPos( W(1289-552), H(330-280) )
	CloseB:SetSize( W(31), H(35) )
	CloseB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
	end
    CloseB.Paint = function( s, self, w, h )
    end

    local RerollB = vgui.Create( "DImageButton", Frame_Status )
    RerollB:SetImage( "mad_sololeveling/menu/new/rerollbutton.png" )	-- Set the material - relative to /materials/ directory
	RerollB:SetPos( W(734-552), H(598-250) )
	RerollB:SetSize( W(179), H(60) )
    RerollB:SetColor(Color(255, 255, 255, 255))
    
    local function SetButtonColor(r, g, b, a)
        RerollB:SetColor(Color(r, g, b, a))
    end
    
    local function ResetButtonColor()
        SetButtonColor(255, 255, 255, 255)
    end

    RerollB.OnCursorEntered = function(self)
        self:MoveTo(W(719-552), H(590-250), 0.2) -- Déplacer progressivement vers la nouvelle position
        self:SizeTo(W(220), H(80), 0.2) -- Redimensionner progressivement vers la nouvelle taille
    end
    
    RerollB.OnCursorExited = function(self)
        self:MoveTo(W(734-552), H(598-250), 0.2) -- Déplacer progressivement vers la nouvelle position
        self:SizeTo(W(179), H(60), 0.2) -- Redimensionner progressivement vers la nouvelle taille
    end
    
    
    RerollB.DoClick = function(self)

        timer.Simple(0.25, function()
            if IsValid(Frame_Status) then
                Frame_Status:Remove()
            end
    
            net.Start("SL:Mad - Classe:Start")
            net.SendToServer()
    
            MenuClasse2()
    
        end)

        SetButtonColor(100, 100, 100, 255)

        timer.Simple(0.2, function()
            ResetButtonColor()
        end)
    end
end

net.Receive("SL:OpenClasseMenu", function( len, ply )
    OpenClasseMenu()
end)


net.Receive("SL:OpenRevendeur", function( len, ply )

    local achat_selec = ""

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(0), H(0))
    Frame_Status:SetSize(H(1920), H(1080))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/magasin.png"))
		surface.DrawTexturedRect(W(0),H(0),W(1920),H(1080))
    end

    local CloseB = vgui.Create( "DButton", Frame_Status )
	CloseB:SetText( "" )
	CloseB:SetPos( W(1490), H(195) )
	CloseB:SetSize( W(30), H(25) )
	CloseB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
	end
	CloseB.Paint = function( s, self, w, h )
	end
    local ScrollPanel = vgui.Create("DScrollPanel", Frame_Status)
    ScrollPanel:SetPos(W(409), H(360))
    ScrollPanel:SetSize(W(1109), H(560))
    
    local InvGrid = vgui.Create("DGrid", ScrollPanel)
    InvGrid:SetPos(0, 0)
    InvGrid:SetSize(W(80), H(80))
    InvGrid:SetCols(10)
    InvGrid:SetColWide(W(110))
    InvGrid:SetRowHeight(H(120))

    InvGrid.Paint = function( s, self, w, h )
    end

    -- Créer une table temporaire pour stocker les éléments triés par prix
    local sortedItems = {}

    -- Remplir la table temporaire avec des éléments triés par prix
    for k, v in pairs(INV_SL) do

        if sl_data[k] != nil and sl_data[k] > 0 then

            if INV_SL[k].type != "item" then
                if INV_SL[k].isforaspecialclass == true then
                    table.insert(sortedItems, { key = k, price = v.price })
                else
                    table.insert(sortedItems, { key = k, price = v.price })
                end
            end

        end
    end

    -- Triez la table temporaire par prix de manière décroissante
    table.sort(sortedItems, function(a, b) return a.price < b.price end)
    
    for _, entry in ipairs(sortedItems) do
        local k = entry.key
        local v = INV_SL[k]

        local InvBut = vgui.Create("DModelPanel")

        local breen_img = vgui.Create("DImage", InvBut)
        breen_img:SetPos(InvBut:GetX(), InvBut:GetY())
        breen_img:SetSize(W(87), H(87))
        breen_img:SetImage("mad_sololeveling/menu/new/casse")
        breen_img.Paint = function( s, self, w, h )
            surface.SetDrawColor(255, 255, 255, 255)
            surface.SetMaterial(Material("mad_sololeveling/menu/new/casse.png"))
            surface.DrawTexturedRect(W(0),H(0),W(87), H(87))
            if v.type == "accessoire" then
                surface.SetDrawColor(255, 255, 255, 255)
                surface.SetMaterial(Material(v.img))
                surface.DrawTexturedRect(W(18.5),H(18.5),W(50), H(50))
            end
            if v.type == "sac" or v.type == "botte"  or v.type == "casque" or v.type == "plastron" or v.type == "pantalon" or v.type == "bague" then
                surface.SetDrawColor(255, 255, 255, 255)
                surface.SetMaterial(Material(v.img))
                surface.DrawTexturedRect(W(18.5),H(18.5),W(50), H(50))
            end
        end
        
        InvBut:SetSize(ScrW() * 0.046875, ScrH() * 0.08333333333)
        if v.type == "armure" && LocalPlayer():GetNWInt("Genre") == "male" then
            InvBut:SetModel(v.playermodel_male)
        elseif v.type == "armure" and LocalPlayer():GetNWInt("Genre") == "female" then
            InvBut:SetModel(v.playermodel_female)
        elseif v.type == "accessoire" then
            InvBut:SetModel("models/price.mdl")
        elseif v.type == "sac" or v.type == "botte"  or v.type == "casque" or v.type == "plastron" or v.type == "pantalon" or v.type == "bague"then
            InvBut:SetModel("models/price.mdl")
        else
            InvBut:SetModel(v.model)
        end

        if v.type == "armure" then
            InvBut:SetFOV(20)
        else
            InvBut:SetFOV(50)
        end

        InvBut:SetText(formatMoney(v.price/2))
        InvBut:SetTooltip(v.name)
        InvBut:SetTextColor(Color(255, 255, 255))
        InvBut:SetContentAlignment(2)
        InvBut:SetFont("M_Font3")
        InvBut:SetLookAt(InvBut:GetEntity():GetPos())
        InvBut:GetEntity():SetAngles(Angle(0, 0, 0))
        InvBut:GetEntity():SetModelScale(v.scale * 2)
        InvBut.InternalValue = k

        function InvBut:LayoutEntity(ent)
        end

        InvBut.Paint = function( s, self, w, h )
        end

        local InvBut2 = vgui.Create("DModelPanel", InvBut)
        InvBut2:SetSize(ScrW() * 0.046875, ScrH() * 0.08333333333)
        if v.type == "armure" && LocalPlayer():GetNWInt("Genre") == "male" then
            InvBut2:SetModel(v.playermodel_male)
        elseif v.type == "armure" and LocalPlayer():GetNWInt("Genre") == "female" then
            InvBut2:SetModel(v.playermodel_female)
        elseif v.type == "accessoire" then
            InvBut2:SetModel("models/buellost/crystal_grey.mdl")
        elseif v.type == "sac" or v.type == "botte"  or v.type == "casque" or v.type == "plastron" or v.type == "pantalon" or v.type == "bague"then
            InvBut2:SetModel("models/price.mdl")
        else
            InvBut2:SetModel(v.model)
        end

        if v.type == "armure" then
            InvBut2:SetFOV(20)
        else
            InvBut2:SetFOV(50)
        end

        InvBut2:SetText("")
        InvBut2:SetTooltip(v.name)
        InvBut2:SetTextColor(Color(255, 255, 255))
        InvBut2:SetFont("M_Font3")
        InvBut2:SetLookAt(InvBut2:GetEntity():GetPos())
        InvBut2:GetEntity():SetAngles(Angle(0, 0, 0))
        InvBut2:GetEntity():SetModelScale(v.scale * 2)
        InvBut2.InternalValue = k

        function InvBut:LayoutEntity(ent)
        end

        function InvBut2:LayoutEntity(ent)
        end
    
        InvBut2.DoClick = function(self)
            achat_selec = k
            net.Start("SL:Mad - Shop:Revendre")
            net.WriteString(achat_selec)
            net.SendToServer()
            print(achat_selec)

            if IsValid(Frame_Status) then Frame_Status:Remove() end
        end
    
            InvGrid:AddItem(InvBut)
        end
    
end)
rarity_img = {
    ["commun"] = "mad_sololeveling/menu/new/classe2/commun.png",
    ["rare"] = "mad_sololeveling/menu/new/classe2/rare.png",
    ["epique"] = "mad_sololeveling/menu/new/classe2/epic.png",
    ["legendaire"] = "mad_sololeveling/menu/new/classe2/legendaire.png",
    ["mythique"] = "mad_sololeveling/menu/new/classe2/mythique.png",
    ["unique"] = "mad_sololeveling/menu/new/classe2/unique.png",
}
function MenuClasse2()

    if sl_data3["classe"] < 1 then return end

    -- Fonction pour obtenir les bodygroups du joueur
	local function GetPlayerBodygroups(player)
		local bodygroups = {}
		for i = 0, player:GetNumBodyGroups() - 1 do
			bodygroups[i] = player:GetBodygroup(i)
		end
		return bodygroups
	end

    local playerBodygroups = GetPlayerBodygroups(LocalPlayer())

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(0), H(0))
    Frame_Status:SetSize(H(1920), H(1080))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/classe4.png"))
		surface.DrawTexturedRect(W(0),H(0),W(1920),H(1080))
    end

    B1 = vgui.Create( "DButton", Frame_Status )
    B1:SetText( "" )
    B1:SetPos(W(460), H(360))
    B1:SetSize( W(300), H(500) )
    B1.Paint = function( s, self, w, h )
    end
    timer.Simple(0.6, function()
        B1.Paint = function( s, self, w, h )
            if IsValid(B1) then
                surface.SetDrawColor(255, 255, 255, 255)
                surface.SetMaterial(Material(rarity_img[CLASSES_SL[Classe1].rarete]))
                surface.DrawTexturedRect(0, 0, W(300), H(500))
                draw.DrawText( CLASSES_SL[Classe1].name, "MNew_Font6", W(150), H(40), Color(255,255,255), TEXT_ALIGN_CENTER ) -- POINTS RESTANT
                if IsValid(iconB1) then
                    iconB1:SetModel( CLASSES_SL[Classe1].mdl )
                end
            end
        end  

        iconB1.DoClick = function()
            if IsValid(Frame_Status) then
                surface.PlaySound( "buttons/button15.wav" )
                Frame_Status:Remove()
                OpenClasseMenu()
                net.Start("SL:Mad - Classe:Choix")
                net.WriteFloat(1)
                net.SendToServer()
            end
        end
    end)

    iconB1 = vgui.Create( "DModelPanel", Frame_Status )
    iconB1:SetSize(W(300),H(500))
    iconB1:SetPos(W(460),H(360))
    iconB1:SetFOV(45)
    timer.Simple(0.6, function()
        if IsValid(iconB1) then
            iconB1:SetModel( CLASSES_SL[Classe1].mdl )
            -- Appliquer les bodygroups au modèle
            for index, value in pairs(playerBodygroups) do
                iconB1.Entity:SetBodygroup(index, value)
            end
            function iconB1.Entity:GetPlayerColor() return (LocalPlayer():GetPlayerColor()) end --we need to set it to a Vector not a Color, so the values are normal RGB values divided by 255.
        end
    end)    
end

function OpenRangMenu()
    if true then return end

    surface_PlaySound("buttons/button15.wav")

    LocalPlayer():ConCommand("actu_client")

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(552), H(232))
    Frame_Status:SetSize(H(814), H(611))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(true)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/rang5.png"))
		surface.DrawTexturedRect(W(0),H(0),W(814),H(611))
        draw.DrawText( sl_data3["rang"], "MNew_Font6", W(295), H(421), Color(255,255,255), TEXT_ALIGN_LEFT ) -- POINTS RESTANT
    end

    local CloseB = vgui.Create( "DButton", Frame_Status )
	CloseB:SetText( "" )
	CloseB:SetPos( W(1289-552), H(330-280) )
	CloseB:SetSize( W(31), H(35) )
	CloseB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
	end
    CloseB.Paint = function( s, self, w, h )
    end

    local RerollB = vgui.Create( "DImageButton", Frame_Status )
    RerollB:SetImage( "mad_sololeveling/menu/new/rerollbutton.png" )	-- Set the material - relative to /materials/ directory
	RerollB:SetPos( W(734-552), H(598-250) )
	RerollB:SetSize( W(179), H(60) )
    RerollB:SetColor(Color(255, 255, 255, 255))
    
    local function SetButtonColor(r, g, b, a)
        RerollB:SetColor(Color(r, g, b, a))
    end
    
    local function ResetButtonColor()
        SetButtonColor(255, 255, 255, 255)
    end

    RerollB.OnCursorEntered = function(self)
        self:MoveTo(W(719-552), H(590-250), 0.2) -- Déplacer progressivement vers la nouvelle position
        self:SizeTo(W(220), H(80), 0.2) -- Redimensionner progressivement vers la nouvelle taille
    end
    
    RerollB.OnCursorExited = function(self)
        self:MoveTo(W(734-552), H(598-250), 0.2) -- Déplacer progressivement vers la nouvelle position
        self:SizeTo(W(179), H(60), 0.2) -- Redimensionner progressivement vers la nouvelle taille
    end
    
    
    RerollB.DoClick = function(self)

        timer.Simple(0.25, function()
            if IsValid(Frame_Status) then
                Frame_Status:Remove()
            end
    
            net.Start("SL:Mad - Rang:Start")
            net.SendToServer()
    
            MenuRang2()
    
        end)

        SetButtonColor(100, 100, 100, 255)

        timer.Simple(0.2, function()
            ResetButtonColor()
        end)
    end
end

net.Receive("SL:OpenRangMenu", function( len, ply )
    OpenRangMenu()
end)

function CL_RandomRang()
    local totalPourcent = 0
    for _, rang in pairs(RANG_SL) do
        totalPourcent = totalPourcent + rang.pourcent
    end

    local randomValue = math.random() * totalPourcent
    local cumulative = 0

    for rank, data in pairs(RANG_SL) do
        cumulative = cumulative + data.pourcent
        if randomValue <= cumulative then
            return rank
        end
    end
end

function MenuRang2()

    if sl_data3["rang"] < 1 then return end

    timer.Create("RdmRangRoulette", 0.2, 20, function()
        random_rank = CL_RandomRang()
    end)
    timer.Simple(5, function()
        random_rank = LocalPlayer():GetNWInt("Rang_Reroll")
    end)

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(552), H(232))
    Frame_Status:SetSize(H(814), H(611))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/rang5.png"))
		surface.DrawTexturedRect(W(0),H(0),W(814),H(611))
        draw.DrawText( sl_data3["rang"], "MNew_Font6", W(295), H(421), Color(255,255,255), TEXT_ALIGN_LEFT ) -- POINTS RESTANT

        if random_rank and RANG_SL[random_rank] and RANG_SL[random_rank].color then
            draw.SimpleTextOutlined(RANG_SL[random_rank].name, "M_Font2", W(734-460), H(598-220), Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1,RANG_SL[random_rank].color )        
        end
        
    end

    local RerollB = vgui.Create( "DImageButton", Frame_Status )
    RerollB:SetImage( "mad_sololeveling/menu/new/button.png" )	-- Set the material - relative to /materials/ directory
	RerollB:SetPos( W(734-552), H(598-250) )
	RerollB:SetSize( W(179), H(60) )
    RerollB:SetColor(Color(255, 255, 255, 255))

    timer.Simple(7, function()
        Frame_Status:Remove()

        OpenRangMenu()

        LocalPlayer():ChatPrint("Vous avez obtenu : ".. LocalPlayer():GetNWInt("Rang_Reroll"))

    end)

end
local skillsFrame = Material("skills_frame.png")
local skillsSlotsIcon = Material("skills_slots_icon.png")
local skillsBg = Material("skills_bg.png")
function OpenSkillsMenu()
    surface_PlaySound("buttons/button15.wav")

    local inv_selec = ""

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetSize(H(1044), H(556))
    Frame_Status:Center()
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function(self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(skillsFrame)
		surface.DrawTexturedRect(W(0),H(0),w,h)
    end
    
    local CloseB = vgui.Create( "DButton", Frame_Status )
	CloseB:SetText( "" )
	CloseB:SetPos( W(765), H(105) )
	CloseB:SetSize( W(20), H(16) )
	CloseB.DoClick = function()
		if IsValid(Frame_Status) then
            timer.Destroy("IconUpdate"..LocalPlayer():SteamID64())
			Frame_Status:Remove()
		end
	end
	CloseB.Paint = function( s, self, w, h )
        surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/x.png"))
		surface.DrawTexturedRect(W(0),H(0),W(20),H(16))
	end

    local A = vgui.Create( "DButton", Frame_Status )
	A:SetText( "" )
	A:SetPos( W(1044/2 - 200), H(200) )
	A:SetSize( W(400), H(245) )
    A.Paint = function( self, w, h )
	end

    local DScrollPanel = vgui.Create( "DScrollPanel", A )
    DScrollPanel:Dock( FILL )

    -- Créer une table temporaire pour stocker les éléments triés par prix
    local sortedItems = {}

    -- Remplir la table temporaire avec des éléments triés par prix
    for k, v in pairs(SKILLS_SL) do
        v.level = v.level or 0 -- Assurez-vous que le prix est défini, au cas où certaines entrées n'en ont pas
        if SKILLS_SL[k].ismagie == true then
            if SKILLS_SL[k].element == LocalPlayer():GetNWInt("Magie") then table.insert(sortedItems, { key = k, level = v.level }) end
        else
            table.insert(sortedItems, { key = k, level = v.level })
        end
    end

    -- Triez la table temporaire par prix de manière décroissante
    table.sort(sortedItems, function(a, b) return a.level > b.level end)
    
    for _, entry in ipairs(sortedItems) do
        local k = entry.key
        local v = SKILLS_SL[k]
        if sl_data4[k] and sl_data4[k] >= 1 and SKILLS_SL[k].classe[LocalPlayer():GetNWInt("Classe")] then

            local Skill_IMG = DScrollPanel:Add( "DButton" )
            Skill_IMG:SetText( "" )
            Skill_IMG:SetSize( W(400), H(73) )
            Skill_IMG:Dock( TOP )
            Skill_IMG:DockMargin( 0, 0, 0, 10 )
            Skill_IMG.Paint = function( self, w, h )
                surface.SetDrawColor(255, 255, 255, 255)
                surface.SetMaterial(skillsSlotsIcon)
                surface.DrawTexturedRect(W(0),H(0),W(72),H(73))
                surface.SetMaterial(Material(v.icon))
                surface.DrawTexturedRect(W(10),H(10),W(50),H(50))

                surface.SetMaterial(skillsBg)
                surface.DrawTexturedRect(W(85),H(0),W(290),H(73))
                draw.SimpleText(v.name, "B_Font5", W(120), H(10), Color(0,0,0), TEXT_ALIGN_LEFT)
                draw.SimpleText("Niveau : "..sl_data4[k], "B_Font5", W(120), H(40), Color(0,0,0), TEXT_ALIGN_LEFT)
                -- draw.RoundedBox(0, 0, 0, w, h, Color(44,59,105,255))
            end

            function Skill_IMG:DoClick()

                if IsValid(Bind1) then Bind1:Remove() end
                if IsValid(Bind2) then Bind2:Remove() end
                if IsValid(Bind3) then Bind3:Remove() end
                if IsValid(Bind4) then Bind4:Remove() end
                if IsValid(Close) then Close:Remove() end

                Bind1 = vgui.Create( "DButton", DScrollPanel )
                Bind1:SetText( "" )
                Bind1:SetPos(W(Skill_IMG:GetX() + 250), H(Skill_IMG:GetY()))
                Bind1:SetText("1")
                Bind1:SetFont("M_Font1")
                Bind1:SetSize( W(50), H(50) )
                Bind1.DoClick = function()
                end
                Bind1.Paint = function(self,w,h)
                    draw.RoundedBox(2, 0, 0, w, h, Color(44,59,105,255))
                end
                function Bind1:DoClick()
                    net.Start("SL:Mad - Skills:Bind")
                    net.WriteFloat(1)
                    net.WriteString(k)
                    net.SendToServer()

                    if IsValid(Bind1) then Bind1:Remove() end
                    if IsValid(Bind2) then Bind2:Remove() end
                    if IsValid(Bind3) then Bind3:Remove() end
                    if IsValid(Bind4) then Bind4:Remove() end
                    if IsValid(Close) then Close:Remove() end

                end

                Bind2 = vgui.Create( "DButton", DScrollPanel )
                Bind2:SetText( "" )
                Bind2:SetPos(W(Skill_IMG:GetX() + 250), H(Skill_IMG:GetY() + 65))
                Bind2:SetText("2")
                Bind2:SetFont("M_Font1")
                Bind2:SetSize( W(50), H(50) )
                Bind2.DoClick = function()
                end
                Bind2.Paint = function(self,w,h)
                    draw.RoundedBox(2, 0, 0, w, h, Color(44,59,105,255))
                end
                function Bind2:DoClick()
                    net.Start("SL:Mad - Skills:Bind")
                    net.WriteFloat(2)
                    net.WriteString(k)
                    net.SendToServer()

                    if IsValid(Bind1) then Bind1:Remove() end
                    if IsValid(Bind2) then Bind2:Remove() end
                    if IsValid(Bind3) then Bind3:Remove() end
                    if IsValid(Bind4) then Bind4:Remove() end
                    if IsValid(Close) then Close:Remove() end

                end

                Bind3 = vgui.Create( "DButton", DScrollPanel )
                Bind3:SetText( "" )
                Bind3:SetPos(W(Skill_IMG:GetX() + 250), H(Skill_IMG:GetY() + 65 + 65))
                Bind3:SetText("3")
                Bind3:SetFont("M_Font1")
                Bind3:SetSize( W(50), H(50) )
                Bind3.DoClick = function()
                end
                Bind3.Paint = function(self,w,h)
                    draw.RoundedBox(2, 0, 0, w, h, Color(44,59,105,255))
                end
                function Bind3:DoClick()
                    net.Start("SL:Mad - Skills:Bind")
                    net.WriteFloat(3)
                    net.WriteString(k)
                    net.SendToServer()

                    if IsValid(Bind1) then Bind1:Remove() end
                    if IsValid(Bind2) then Bind2:Remove() end
                    if IsValid(Bind3) then Bind3:Remove() end
                    if IsValid(Bind4) then Bind4:Remove() end
                    if IsValid(Close) then Close:Remove() end

                end

                Bind4 = vgui.Create( "DButton", DScrollPanel )
                Bind4:SetText( "" )
                Bind4:SetPos(W(Skill_IMG:GetX() + 250), H(Skill_IMG:GetY() + 65 + 65 + 65))
                Bind4:SetText("4")
                Bind4:SetFont("M_Font1")
                Bind4:SetSize( W(50), H(50) )
                Bind4.DoClick = function()
                end
                Bind4.Paint = function(self,w,h)
                    draw.RoundedBox(2, 0, 0, w, h, Color(44,59,105,255))
                end
                function Bind4:DoClick()
                    net.Start("SL:Mad - Skills:Bind")
                    net.WriteFloat(4)
                    net.WriteString(k)
                    net.SendToServer()

                    if IsValid(Bind1) then Bind1:Remove() end
                    if IsValid(Bind2) then Bind2:Remove() end
                    if IsValid(Bind3) then Bind3:Remove() end
                    if IsValid(Bind4) then Bind4:Remove() end
                    if IsValid(Close) then Close:Remove() end

                end

                Close = vgui.Create( "DButton", DScrollPanel )
                Close:SetText( "" )
                Close:SetPos(W(Skill_IMG:GetX() + 310), H(Skill_IMG:GetY()))
                Close:SetText("X")
                Close:SetFont("M_Font1")
                Close:SetSize( W(50), H(50) )
                Close.DoClick = function()
                end
                Close.Paint = function(self,w,h)
                    draw.RoundedBox(2, 0, 0, w, h, Color(44,59,105,255))
                end
                function Close:DoClick()

                    if IsValid(Bind1) then Bind1:Remove() end
                    if IsValid(Bind2) then Bind2:Remove() end
                    if IsValid(Bind3) then Bind3:Remove() end
                    if IsValid(Bind4) then Bind4:Remove() end
                    if IsValid(Bind5) then Bind5:Remove() end
                    if IsValid(Bind6) then Bind6:Remove() end
                    if IsValid(Close) then Close:Remove() end

                end

            end
        end
    end
end

net.Receive("SL:OpenSkillsMenu", function( len, ply )
    OpenSkillsMenu()
end)

local activeNotifications = {}

-- Fonction pour ajuster les positions des notifications
local function UpdateNotificationPositions()
    local yPos = H(84)
    for _, panel in ipairs(activeNotifications) do
        panel:SetPos(W(1545), yPos)
        yPos = yPos + panel:GetTall() + 5
    end
end
local notifsl = Material("notif_sl_nw.png")
-- Fonction pour créer et afficher une notification
function DisplayNotification(message)
    -- Durée d'affichage de la notification en secondes
    local duration = 7

    -- Création du rectangle
    local notificationPanel = vgui.Create("DPanel")
    notificationPanel:SetSize(W(375), H(180))

    -- Position de la notification
    notificationPanel:SetPos(W(1545), H(84))

    notificationPanel.Paint = function(self, w, h)
        -- Dessiner l'image en tant que fond
        surface.SetMaterial(notifsl)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawTexturedRect(0, 0, w, h)

        -- Texte de la notification
        draw.SimpleText(message, "M_Font5", w / 2, h / 1.6, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    -- Ajouter la nouvelle notification à la liste des notifications actives
    table.insert(activeNotifications, notificationPanel)

    -- Mettre à jour les positions des notifications
    UpdateNotificationPositions()

    timer.Simple(duration-1, function()
        notificationPanel:AlphaTo(1, 1, 0)
    end)

    -- Fonction pour faire disparaître la notification après un certain délai
    timer.Simple(duration, function()
        if IsValid(notificationPanel) then
            notificationPanel:Remove()

            -- Retirer la notification de la liste des notifications actives
            for i, panel in ipairs(activeNotifications) do
                if panel == notificationPanel then
                    table.remove(activeNotifications, i)
                    break
                end
            end

            -- Mettre à jour les positions des notifications restantes
            UpdateNotificationPositions()
        end
    end)
end

-- Fonction pour créer et afficher une notification
function DisplayNotification2(message, txt)
    -- Durée d'affichage de la notification en secondes
    local duration = 7

    -- Création du rectangle
    local notificationPanel = vgui.Create("DPanel")
    notificationPanel:SetSize(W(388*1.2), H(125*1.2))

    -- Position de la notification
    notificationPanel:SetPos(W(1485), H(84))

    notificationPanel.Paint = function(self, w, h)
        -- Dessiner l'image en tant que fond
        surface.SetMaterial(Material("materials/mad_sololeveling/menu/notif1.png"))
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawTexturedRect(0, 0, w, h)

        -- Texte de la notification
        draw.SimpleText(message, "M_Font1", w / 2, h / 2.2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText(message, "M_Font1", w / 2, h / 1.6, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    -- Ajouter la nouvelle notification à la liste des notifications actives
    table.insert(activeNotifications, notificationPanel)

    -- Mettre à jour les positions des notifications
    UpdateNotificationPositions()

    timer.Simple(duration-1, function()
        notificationPanel:AlphaTo(1, 1, 0)
    end)

    -- Fonction pour faire disparaître la notification après un certain délai
    timer.Simple(duration, function()
        if IsValid(notificationPanel) then
            notificationPanel:Remove()

            -- Retirer la notification de la liste des notifications actives
            for i, panel in ipairs(activeNotifications) do
                if panel == notificationPanel then
                    table.remove(activeNotifications, i)
                    break
                end
            end

            -- Mettre à jour les positions des notifications restantes
            UpdateNotificationPositions()
        end
    end)
end

-- Réception du net message pour afficher une notification
net.Receive("SL:Notification", function()
    local message = net.ReadString()
    DisplayNotification(message)
end)

net.Receive("SL:Notification2", function()
    local message = net.ReadString()
    local txt = net.ReadFloat()
    DisplayNotification2(message, txt)
end)

function OpenMagieMenu_Choisir()
    surface_PlaySound("buttons/button15.wav")
    if sl_data3["magie"] < 1 then return end

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(0), H(0))
    Frame_Status:SetSize(H(1920), H(1080))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/new_magie2.png"))
		surface.DrawTexturedRect(W(0),H(0),W(1920),H(1080))
        draw.DrawText( "Rerolls restant : ".. sl_data3["magie"], "M_Font2", W(500), H(829), Color(255,255,255), TEXT_ALIGN_LEFT ) -- POINTS RESTANT
    end

    local FeuB = vgui.Create( "DButton", Frame_Status )
	FeuB:SetText( "" )
	FeuB:SetPos( W(638), H(480) )
	FeuB:SetSize( W(93), H(133) )
	FeuB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
        net.Start("SL:Mad - Magie:Choisir")
        net.WriteString(1)
        net.SendToServer()
	end
	FeuB.Paint = function( s, self, w, h )
	end

    local EauB = vgui.Create( "DButton", Frame_Status )
	EauB:SetText( "" )
	EauB:SetPos( W(802), H(483) )
	EauB:SetSize( W(121), H(132) )
	EauB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
        net.Start("SL:Mad - Magie:Choisir")
        net.WriteString(2)
        net.SendToServer()
	end
	EauB.Paint = function( s, self, w, h )
	end

    local TerreB = vgui.Create( "DButton", Frame_Status )
	TerreB:SetText( "" )
	TerreB:SetPos( W(993), H(500) )
	TerreB:SetSize( W(140), H(86) )
	TerreB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
        net.Start("SL:Mad - Magie:Choisir")
        net.WriteString(3)
        net.SendToServer()
	end
	TerreB.Paint = function( s, self, w, h )
	end

    local VentB = vgui.Create( "DButton", Frame_Status )
	VentB:SetText( "" )
	VentB:SetPos( W(1201), H(483) )
	VentB:SetSize( W(115), H(125) )
	VentB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
        net.Start("SL:Mad - Magie:Choisir")
        net.WriteString(4)
        net.SendToServer()
	end
	VentB.Paint = function( s, self, w, h )
	end

    local CloseB = vgui.Create( "DButton", Frame_Status )
	CloseB:SetText( "" )
	CloseB:SetPos( W(1433), H(221) )
	CloseB:SetSize( W(32), H(32) )
	CloseB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
	end
	CloseB.Paint = function( _, w, h )
        draw.SimpleText( "X", "M_Font2", w/2, h/2, Color(255,255,255), 1, 1 )
	end

end

function OpenMagieAleatoireMenu()
    surface_PlaySound("buttons/button15.wav")

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(552), H(232))
    Frame_Status:SetSize(H(814), H(611))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(true)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/1new_magie3.png"))
		surface.DrawTexturedRect(W(0),H(0),W(814),H(611))
        draw.DrawText( sl_data3["magie"], "MNew_Font6", W(295), H(421), Color(255,255,255), TEXT_ALIGN_LEFT ) -- POINTS RESTANT
    end

    local CloseB = vgui.Create( "DButton", Frame_Status )
	CloseB:SetText( "" )
	CloseB:SetPos( W(1289-552), H(330-280) )
	CloseB:SetSize( W(31), H(35) )
	CloseB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
	end
    CloseB.Paint = function( s, self, w, h )
    end

    local RerollB = vgui.Create( "DImageButton", Frame_Status )
    RerollB:SetImage( "mad_sololeveling/menu/new/rerollbutton.png" )	-- Set the material - relative to /materials/ directory
	RerollB:SetPos( W(734-552), H(598-250) )
	RerollB:SetSize( W(179), H(60) )
    RerollB:SetColor(Color(255, 255, 255, 255))
    
    local function SetButtonColor(r, g, b, a)
        if not IsValid(RerollB) then return end
        RerollB:SetColor(Color(r, g, b, a))
    end
    
    local function ResetButtonColor()
        SetButtonColor(255, 255, 255, 255)
    end

    RerollB.OnCursorEntered = function(self)
        self:MoveTo(W(719-552), H(590-250), 0.2) -- Déplacer progressivement vers la nouvelle position
        self:SizeTo(W(220), H(80), 0.2) -- Redimensionner progressivement vers la nouvelle taille
    end
    
    RerollB.OnCursorExited = function(self)
        self:MoveTo(W(734-552), H(598-250), 0.2) -- Déplacer progressivement vers la nouvelle position
        self:SizeTo(W(179), H(60), 0.2) -- Redimensionner progressivement vers la nouvelle taille
    end
    
    RerollB.DoClick = function(self)

        timer.Simple(0.25, function()
            if IsValid(Frame_Status) then
                Frame_Status:Remove()
            end

            net.Start("SL:Mad - Magie:Start")
            net.SendToServer()

            MenuMagie2()
        end)

        SetButtonColor(100, 100, 100, 255)

        timer.Simple(0.2, function()
            ResetButtonColor()
        end)
    end
    

end


MAGIE_RARITY_CHANCES = {
    ["commun"] = 75,
    ["rare"] = 20,
    ["legendaire"] = 5,
}

function GetRandomRarity_Magie()
    local totalChances = 0
    for rarity, chance in pairs(MAGIE_RARITY_CHANCES) do
        totalChances = totalChances + chance
    end

    local randNum = math.random(1, totalChances)

    local cumulativeChance = 0
    for rarity, chance in pairs(MAGIE_RARITY_CHANCES) do
        cumulativeChance = cumulativeChance + chance
        if randNum <= cumulativeChance then
            return rarity
        end
    end

    return "commun" -- Au cas où il y aurait une erreur dans les chances, retourne commun par défaut
end

function GetRandomMagieByRarity(rarity)
    local possibleMagies = {}

    for magieName, classData in pairs(MAGIE_SL) do
        if classData.rarete == rarity then
            table.insert(possibleMagies, magieName)
        end
    end

    if #possibleMagies > 0 then
        local randomMagieName = table.Random(possibleMagies)
        return randomMagieName
    else
        return "feu"
    end
end

function MenuMagie2()

    if sl_data3["magie"] < 1 then return end

    timer.Create("RdmMagieRoulette", 0.2, 20, function()
        random_magie = GetRandomMagieByRarity(GetRandomRarity_Magie())
    end)
    timer.Simple(4.2, function()
        random_magie = Magie
    end)

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(552), H(232))
    Frame_Status:SetSize(H(814), H(611))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/1new_magie3.png"))
		surface.DrawTexturedRect(W(0),H(0),W(814),H(611))
        draw.DrawText( sl_data3["magie"], "MNew_Font6", W(295), H(421), Color(255,255,255), TEXT_ALIGN_LEFT ) -- POINTS RESTANT

        if random_magie and MAGIE_SL[random_magie] and MAGIE_SL[random_magie].color then
            draw.SimpleTextOutlined(MAGIE_SL[random_magie].name, "M_Font2", W(734-460), H(598-220), Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1,MAGIE_SL[random_magie].color )        
        end
        
    end

    local RerollB = vgui.Create( "DImageButton", Frame_Status )
    RerollB:SetImage( "mad_sololeveling/menu/new/button.png" )	-- Set the material - relative to /materials/ directory
	RerollB:SetPos( W(734-552), H(598-250) )
	RerollB:SetSize( W(179), H(60) )
    RerollB:SetColor(Color(255, 255, 255, 255))

    timer.Simple(7, function()
        Frame_Status:Remove()

        LocalPlayer():ChatPrint("Vous avez obtenu : "..MAGIE_SL[random_magie].name)

    end)

end

function OpenMagieMenu()
    surface_PlaySound("buttons/button15.wav")

    LocalPlayer():ConCommand("actu_client")

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(0), H(0))
    Frame_Status:SetSize(H(1920), H(1080))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/magie1.png"))
		surface.DrawTexturedRect(W(0),H(0),W(1920),H(1080))
        draw.DrawText( "Rerolls restant : ".. sl_data3["magie"], "M_Font2", W(500), H(829), Color(255,255,255), TEXT_ALIGN_LEFT ) -- POINTS RESTANT
    end

    local CloseB = vgui.Create( "DButton", Frame_Status )
	CloseB:SetText( "" )
	CloseB:SetPos( W(1433), H(221) )
	CloseB:SetSize( W(26), H(26) )
	CloseB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
	end
	CloseB.Paint = function( s, self, w, h )
	end

    local ChoisirB = vgui.Create( "DButton", Frame_Status )
	ChoisirB:SetText( "" )
	ChoisirB:SetPos( W(709.54), H(679.21) )
	ChoisirB:SetSize( W(222.64), H(75.34) )
	ChoisirB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
        OpenMagieMenu_Choisir()
	end
	ChoisirB.Paint = function( s, self, w, h )
	end

    local AleatoireB = vgui.Create( "DButton", Frame_Status )
	AleatoireB:SetText( "" )
	AleatoireB:SetPos( W(993.83), H(676.73) )
	AleatoireB:SetSize( W(222.64), H(75.34) )
	AleatoireB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end

        OpenMagieAleatoireMenu()
	end
	AleatoireB.Paint = function( s, self, w, h )
	end

end

net.Receive("SL:OpenMagieMenu", function( len, ply )
    OpenMagieMenu()
end)

concommand.Add("openmagiemenu", function()
    OpenMagieMenu()
end)
local ColorButton = Material("colorButton.png")

function OpenCoiffeurMenu(entity)
    surface_PlaySound("buttons/button15.wav")

    local Frame_Status = vgui.Create("DFrame")
    Frame_Status:SetPos(W(0), H(0))
    Frame_Status:SetSize(H(1920), H(1080))
    Frame_Status:SetTitle("")
    Frame_Status:MakePopup()
    Frame_Status:SetDraggable(false)
    Frame_Status:ShowCloseButton(false)
    Frame_Status:SetAlpha(0)
    Frame_Status:AlphaTo(255, 1, 0)
    Frame_Status.Paint = function( s, self, w, h )
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(Material("mad_sololeveling/menu/new/menu_coiffeur.png"))
		surface.DrawTexturedRect(W(0),H(0),W(1920),H(1080))

        draw.DrawText( "Cheveux : ", "MNew_Font6", W(563), H(449), Color(255,255,255), TEXT_ALIGN_CENTER ) -- POINTS RESTANT
        draw.DrawText( "Prix : 20.000 ₩", "MNew_Font6", W(563), H(800), Color(255,255,255), TEXT_ALIGN_CENTER ) -- POINTS RESTANT
    end

    local CloseB = vgui.Create( "DButton", Frame_Status )
	CloseB:SetText( "" )
	CloseB:SetPos( W(1433), H(221) )
	CloseB:SetSize( W(26), H(26) )
	CloseB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
	end
	CloseB.Paint = function( s, self, w, h )
	end

    mdl = vgui.Create("DModelPanel", Frame_Status)
    mdl:SetSize(W(346), H(439))
    mdl:SetPos(W(1080), H(411))
    mdl:SetFOV(50)
    function mdl:LayoutEntity(Entity)
        -- désactive la rotation par défaut
        return
    end

    if LocalPlayer():GetNWInt("Genre") == "male" then

        mdl:SetModel("models/mad_models/mad_sl_male_civil1.mdl")

        CharacterCreator_SliderCheveux = vgui.Create( "DNumSlider", Frame_Status )
        CharacterCreator_SliderCheveux:SetPos( W(380), H(457) )				-- Set the position
        CharacterCreator_SliderCheveux:SetSize( W(600), H(18) )			-- Set the size
        CharacterCreator_SliderCheveux:SetText( "" )	-- Set the text above the slider
        CharacterCreator_SliderCheveux:SetMin( 0 )				 	-- Set the minimum number you can slide to
        CharacterCreator_SliderCheveux:SetMax( 42 )				-- Set the maximum number you can slide to
        CharacterCreator_SliderCheveux:SetDecimals( 0 )				-- Decimal places - zero for whole number
        CharacterCreator_SliderCheveux:SetValue( LocalPlayer():GetBodygroup(3) )
        mdl.Entity:SetBodygroup(3, LocalPlayer():GetBodygroup(3))

        CharacterCreator_SliderCheveux.OnValueChanged = function( self, value )
            mdl.Entity:SetBodygroup(3, value)
            LocalPlayer():SetNWInt("Coiffeur_Cheveux", value)
        end
    else

        mdl:SetModel("models/mad_models/mad_sl_female1.mdl")

        CharacterCreator_SliderCheveux = vgui.Create( "DNumSlider", Frame_Status )
        CharacterCreator_SliderCheveux:SetPos( W(380), H(457) )				-- Set the position
        CharacterCreator_SliderCheveux:SetSize( W(600), H(18) )			-- Set the size
        CharacterCreator_SliderCheveux:SetText( "" )	-- Set the text above the slider
        CharacterCreator_SliderCheveux:SetMin( 0 )				 	-- Set the minimum number you can slide to
        CharacterCreator_SliderCheveux:SetMax( 18 )				-- Set the maximum number you can slide to
        CharacterCreator_SliderCheveux:SetDecimals( 0 )				-- Decimal places - zero for whole number
        CharacterCreator_SliderCheveux:SetValue( LocalPlayer():GetBodygroup(2) )
        mdl.Entity:SetBodygroup(2, LocalPlayer():GetBodygroup(2))
    
        CharacterCreator_SliderCheveux.OnValueChanged = function( self, value )
            mdl.Entity:SetBodygroup(2, value)
            LocalPlayer():SetNWInt("Coiffeur_Cheveux", value)
        end
    end
    function mdl.Entity:GetPlayerColor() return LocalPlayer():GetPlayerColor() end

    local headpos = mdl.Entity:GetBonePosition(mdl.Entity:LookupBone("ValveBiped.Bip01_Head1"))
    mdl:SetLookAt(headpos)

    mdl:SetCamPos(headpos-Vector(-30, 0, 0))	-- Move cam in front of face

    local CoifferB = vgui.Create( "DButton", Frame_Status )
	CoifferB:SetText( "" )
	CoifferB:SetPos( W(600), H(562) )
	CoifferB:SetSize( W(222), H(75) )
	CoifferB.DoClick = function()
		if IsValid(Frame_Status) then
			Frame_Status:Remove()
		end
        net.Start("SL:Mad - Coiffeur:Change")
        net.WriteUInt(math.Round(LocalPlayer():GetNWInt("Coiffeur_Cheveux")), 16)
        net.WriteVector(LocalPlayer():GetPlayerColor())
        -- net.WriteFloat(LocalPlayer():GetNWInt("Coiffeur_Cheveux"))
        -- net.WriteEntity(entity)
        net.SendToServer()
	end
	CoifferB.Paint = function( s, self, w, h )
	end

    local CharacterCreator_Colorpickerbutton = vgui.Create("DButton", Frame_Status)
    CharacterCreator_Colorpickerbutton:SetPos(W(1000), H(457))
    CharacterCreator_Colorpickerbutton:SetSize( W(50), H(50) )
    CharacterCreator_Colorpickerbutton:SetText("")	
    CharacterCreator_Colorpickerbutton.Paint = function(self,w,h)
    surface.SetDrawColor(255, 255, 255)
        surface.SetMaterial(ColorButton)
        surface.DrawTexturedRect(0,0,w,h)
    end
    CharacterCreator_Colorpickerbutton.DoClick = function()
        if IsValid(CharacterCreator_Colorpickermenu) then return end
        CharacterCreator_Colorpickermenu = vgui.Create("DFrame", Frame_Status)
        CharacterCreator_Colorpickermenu:SetSize(W(341), H(361))
        CharacterCreator_Colorpickermenu:Center()
        local ColorPicker = vgui.Create("DColorMixer", CharacterCreator_Colorpickermenu)
        ColorPicker:SetSize(W(341), H(341))
        ColorPicker:SetPos(W(0), H(20))      
        ColorPicker.ValueChanged = function(picker, color)
            LocalPlayer():SetPlayerColor(Vector(color.r / 255, color.g / 255, color.b / 255))
            function mdl.Entity:GetPlayerColor() return (Vector(color.r / 255, color.g / 255, color.b / 255)) end
        end
    end

end

net.Receive("SL:Mad - Coiffeur:Menu", function( len, ply )
    -- local entity = net.ReadEntity()

    OpenCoiffeurMenu(entity)
end)

--------------------------------------------------------------------------------------
------------------------ ADMIN -------------------------------------------------------

local function OpenMenu()
    if not LocalPlayer():IsAdmin() then return end

    local frame = vgui.Create( "TLFrame" )
    frame:SetSize(400, 400)
    frame:ShowCloseButton( true )
    frame:SetHeader( "Menu - Give Item" )
    frame:Center()
    frame:MakePopup()
        
    frame.OnRemove = function(self)
        if LocalPlayer():GetNWBool("IsAdminMode") == false then
            --net.Start("SimplisticPresentation:AdminMode_Off")
            --net.SendToServer()
        end
    end

    --net.Start("SimplisticPresentation:AdminMode_On")
    --net.SendToServer()

    timer.Simple(0.25, function()
        -- Liste des joueurs
        playerList = vgui.Create("DListView", frame)
        playerList:SetPos(50, 50)
        playerList:SetSize(300, 150)
        playerList:AddColumn("Joueurs")

        for _, ply in ipairs(player.GetAll()) do
            playerList:AddLine(ply:Nick()).player = ply
        end
    end)

    -- Liste déroulante des items
    local itemList = vgui.Create("DComboBox", frame)
    itemList:SetPos(50, 220)
    itemList:SetSize(300, 30)
    itemList:SetValue("Sélectionnez un item")

    -- Stocker les éléments dans une table temporaire
    local temp = {}
    for k, v in pairs(INV_SL) do
        table.insert(temp, v.name)
    end

    -- Trier la table temporaire par ordre alphabétique
    table.sort(temp)

    -- Table pour suivre les noms déjà imprimés
    local printed = {}

    -- Afficher les éléments triés sans doublon
    for _, name in ipairs(temp) do
        if not printed[name] then
            itemList:AddChoice(name)
            printed[name] = true
        end
    end

    local CatoList = vgui.Create("DComboBox", frame)
    CatoList:SetPos(W(50), H(270))
    CatoList:SetSize(300, 30)
    CatoList:SetValue("Sélectionnez une catégorie")

    local categories = {}

    -- Afficher les types triés sans doublon dans CatoList
    for k, v in pairs(INV_SL) do
        if not categories[v.type] then
            CatoList:AddChoice(v.type)
            categories[v.type] = true
        end
    end

    local function updateItemList(selectedCategory)
        itemList:Clear()
        itemList:SetValue("Sélectionnez un item")
        local printed = {}
    
        for k, v in pairs(INV_SL) do
            if v.type == selectedCategory and not printed[v.name] then
                itemList:AddChoice(v.name)
                printed[v.name] = true
            end
        end
    end
    
    -- Ajouter un écouteur d'événement pour changer le contenu de itemList lorsque CatoList change
    CatoList.OnSelect = function(panel, index, value)
        updateItemList(value)
    end

    local sendButton = vgui.Create("TLButton", frame)
    sendButton:SetPos(W(50), H(350))
    sendButton:SetSize(300, 30)
    sendButton:SetText("Give Item")

    sendButton.DoClick = function()
        local selectedLine = playerList:GetSelectedLine()
        local selectedItem = itemList:GetValue()

        print(selectedItem)
        print(playerList:GetLine(selectedLine).player)

        if selectedLine and selectedItem then

            net.Start("SL:Mad - Admin:GiveItem")
            net.WriteEntity(playerList:GetLine(selectedLine).player)
            net.WriteString(selectedItem)
            net.SendToServer()
        else
            print("Veuillez sélectionner un joueur et un item.")
        end
    end
end

concommand.Add("open_item_menu", OpenMenu)

local function OpenMenuRerollsAdmin()
    if not LocalPlayer():IsAdmin() then return end

    local frame = vgui.Create( "TLFrame" )
    frame:SetSize(400, 400)
    frame:ShowCloseButton( true )
    frame:SetHeader( "Menu - Give Rerolls/Pts" )
    frame:Center()
    frame:MakePopup()

    frame.OnRemove = function(self)
        if LocalPlayer():GetNWBool("IsAdminMode") == false then
            --net.Start("SimplisticPresentation:AdminMode_Off")
            --net.SendToServer()
        end
    end

    --net.Start("SimplisticPresentation:AdminMode_On")
    --net.SendToServer()

    timer.Simple(0.25, function()
        -- Liste des joueurs
        playerList = vgui.Create("DListView", frame)
        playerList:SetPos(50, 50)
        playerList:SetSize(300, 150)
        playerList:AddColumn("Joueurs")

        for _, ply in ipairs(player.GetAll()) do
            playerList:AddLine(ply:Nick()).player = ply
        end
    end)

    -- Liste déroulante des items
    local itemList = vgui.Create("DComboBox", frame)
    itemList:SetPos(50, 220)
    itemList:SetSize(300, 30)
    itemList:SetValue("Sélectionnez l'action")

    itemList:AddChoice("Ajout de Pts Skills")
    itemList:AddChoice("Ajout de Reset Stats")
    itemList:AddChoice("Ajout de Reroll Magie")
    itemList:AddChoice("Ajout de Reroll Rang")
    itemList:AddChoice("Ajout de Reroll Classe")
    itemList:AddChoice("Suppression de Pts Skills")
    itemList:AddChoice("Suppression de Reset Stats")
    itemList:AddChoice("Suppression de Reroll Magie")
    itemList:AddChoice("Suppression de Reroll Rang")
    itemList:AddChoice("Suppression de Reroll Classe")
    
    -- Slider pour le nombre de rerolls
    local rerollAmountSlider = vgui.Create("DNumSlider", frame)
    rerollAmountSlider:SetPos(50, 270)
    rerollAmountSlider:SetSize(300, 30)
    rerollAmountSlider:SetText("Nombre")
    rerollAmountSlider:SetMin(1)
    rerollAmountSlider:SetMax(100)
    rerollAmountSlider:SetDecimals(0)
    rerollAmountSlider:SetValue(1)

    local sendButton = vgui.Create("TLButton", frame)
    sendButton:SetPos(50, 310)
    sendButton:SetSize(300, 30)
    sendButton:SetText("Give")

    sendButton.DoClick = function()
        local selectedLine = playerList:GetSelectedLine()
        local selectedItem = itemList:GetValue()
        local rerollAmount = rerollAmountSlider:GetValue()  -- Récupère la valeur du slider

        if selectedLine and selectedItem then
            local ply = playerList:GetLine(selectedLine).player

            net.Start("SL:Mad - Admin:AddRerolls")
            net.WriteEntity(ply)
            net.WriteString(selectedItem)
            net.WriteFloat(rerollAmount)  -- Envoie le nombre de rerolls spécifié
            net.SendToServer()
        else
            print("Veuillez sélectionner un joueur et une action.")
        end
    end
end

concommand.Add("open_reroll_menu", OpenMenuRerollsAdmin)

local function OpenPortailMenu()
    if not LocalPlayer():IsAdmin() then return end
    local frame = vgui.Create("TLFrame")
    frame:SetSize(400, 400)
    frame:ShowCloseButton(true)
    frame:SetHeader("Menu - Portails SL")
    frame:Center()
    frame:MakePopup()

    -- Liste des portails
    local portalList = vgui.Create("DListView", frame)
    portalList:SetPos(50, 50)
    portalList:SetSize(300, 300)
    portalList:AddColumn("Portails SL")

    for _, ent in ipairs(ents.FindByClass("portail_sl")) do
        portalList:AddLine("Portail de Rang : ".. ent:GetNWInt("Rang")).entity = ent
    end

    -- Ajout du menu contextuel pour les portails
    portalList.OnRowRightClick = function(panel, line)
        local menu = DermaMenu()

        menu:AddOption("Se téléporter", function()
            local ent = portalList:GetLine(line).entity
            net.Start("SL:Portail:Teleport")
            net.WriteEntity(ent)
            net.SendToServer()
        end):SetIcon("icon16/arrow_right.png")

        menu:AddOption("Ouvrir", function()
            local ent = portalList:GetLine(line).entity
            net.Start("SL:Portail:Open")
            net.WriteEntity(ent)
            net.SendToServer()
        end):SetIcon("icon16/door_open.png")

        menu:AddOption("Fermer", function()
            local ent = portalList:GetLine(line).entity
            net.Start("SL:Portail:Close")
            net.WriteEntity(ent)
            net.SendToServer()
        end):SetIcon("icon16/door.png")

        menu:AddOption("Supprimer", function()
            local ent = portalList:GetLine(line).entity
            net.Start("SL:Portail:Delete")
            net.WriteEntity(ent)
            net.SendToServer()
        end):SetIcon("icon16/cross.png")

        menu:AddOption("Dungeon Break", function()
            local ent = portalList:GetLine(line).entity
            net.Start("SL:Portail:DungeonBreak")
            net.WriteEntity(ent)
            net.SendToServer()
        end):SetIcon("icon16/bomb.png")

        menu:AddOption("Doubler", function()
            local ent = portalList:GetLine(line).entity
            net.Start("SL:Portail:Double")
            net.WriteEntity(ent)
            net.SendToServer()
        end):SetIcon("icon16/add.png")

        menu:Open()
    end
end

concommand.Add("open_portail_menu", OpenPortailMenu)

local function OpenGeneralMenu()
    if not LocalPlayer():IsAdmin() then return end
    local frame = vgui.Create("TLFrame")
    frame:SetSize(400, 400)
    frame:ShowCloseButton(true)
    frame:SetHeader("Menu - Admin")
    frame:Center()
    frame:MakePopup()

    -- Bouton 1
    local button1 = vgui.Create("TLButton", frame)
    button1:SetText("Menu - Give Item")
    button1:SetPos(50, 50+25)
    button1:SetSize(300, 50)
    button1.DoClick = function()
        RunConsoleCommand("open_item_menu")
        frame:Remove()
    end

    -- Bouton 2
    local button2 = vgui.Create("TLButton", frame)
    button2:SetText("Menu - Give Rerolls/Pts")
    button2:SetPos(50, 120+25)
    button2:SetSize(300, 50)
    button2.DoClick = function()
        RunConsoleCommand("open_reroll_menu")
        frame:Remove()
    end

    -- Bouton 3
    local button3 = vgui.Create("TLButton", frame)
    button3:SetText("Menu - Portails SL")
    button3:SetPos(50, 190+25)
    button3:SetSize(300, 50)
    button3.DoClick = function()
        RunConsoleCommand("open_portail_menu")
        frame:Remove()
    end
end

concommand.Add("open_general_menu", OpenGeneralMenu)

----------------------------------------------------

-- cl_menu.lua

net.Receive("ASSO:OpenMenu", function()

    local frame = vgui.Create("TLFrame")
    frame:SetSize(400, 200)  -- Augmente la taille du cadre
    frame:ShowCloseButton(true)
    frame:SetHeader("Menu - Message Asso")
    frame:Center()
    frame:MakePopup()

    local textEntry = vgui.Create("DTextEntry", frame)
    textEntry:SetPos(25, 75)  -- Repositionne l'entrée de texte
    textEntry:SetSize(350, 30)  -- Augmente la taille de l'entrée de texte

    local button = vgui.Create("TLButton", frame)
    button:SetText("ENVOYER")
    button:SetPos(150, 125)  -- Repositionne le bouton
    button:SetSize(100, 40)  -- Augmente la taille du bouton
    button.DoClick = function()
        local text = textEntry:GetValue()
        net.Start("ASSO:EnvoieTxt")
        net.WriteString(text)
        net.SendToServer()
        frame:Close()
    end
end)

-----------------------------------------------------------------------------------------------

local function OpenPortalMenu()
    local frame = vgui.Create("DFrame")
    frame:SetTitle("Portal Spawn Menu")
    frame:SetSize(400, 600)
    frame:Center()
    frame:MakePopup()

    local scrollPanel = vgui.Create("DScrollPanel", frame)
    scrollPanel:Dock(FILL)

    local rankList = {}
    for k, v in pairs(PORTAIL_SL) do
        rankList[v.rang] = rankList[v.rang] or {}
        table.insert(rankList[v.rang], v)
    end

    for rank, portals in pairs(rankList) do
        local button = scrollPanel:Add("DButton")
        button:SetText("Spawn Portal - Rank " .. rank)
        button:Dock(TOP)
        button:DockMargin(0, 0, 0, 5)

        button.DoClick = function()
            local portalID = portals[math.random(#portals)].id
            net.Start("SpawnPortal")
            net.WriteString(portalID)
            net.SendToServer()
        end
    end
end

concommand.Add("open_portal_menu", OpenPortalMenu)

hook.Add("PlayerButtonDown", "SL:MainMenu", function(ply, button)
    if not IsFirstTimePredicted() then return end
    if button != KEY_M then return end

    RunConsoleCommand("actu_client")

    SL_MainMenu()
end)
--PATH addons/sl_utils/lua/permaprops/cl_drawent.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/

local function PermaPropsViewer()

	if not LocalPlayer().DrawPPEnt or not istable(LocalPlayer().DrawPPEnt) then return end

    local pos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 10
    local ang = LocalPlayer():EyeAngles()

    ang = Angle(ang.p + 90, ang.y, 0)

    for k, v in pairs(LocalPlayer().DrawPPEnt) do

    	if not v or not v:IsValid() then LocalPlayer().DrawPPEnt[k] = nil continue end

	    render.ClearStencil()
	    render.SetStencilEnable(true)
	        render.SetStencilWriteMask(255)
	        render.SetStencilTestMask(255)
	        render.SetStencilReferenceValue(15)
	        render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilZFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilPassOperation(STENCILOPERATION_KEEP)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
	        render.SetBlend(0)
	        v:DrawModel()
	        render.SetBlend(1)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	        cam.Start3D2D(pos, ang, 1)
	                surface.SetDrawColor(255, 0, 0, 255)
	                surface.DrawRect(-ScrW(), -ScrH(), ScrW() * 2, ScrH() * 2)
	        cam.End3D2D()
	        v:DrawModel()
	    render.SetStencilEnable(false)

	end

end
hook.Add("PostDrawOpaqueRenderables", "PermaPropsViewer", PermaPropsViewer)
--PATH lua/vgui/bvgui/columnlayout.lua:
local PANEL = {}

bVGUI.COLUMN_LAYOUT_COLUMN_GROW = 0
bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK = 1
bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN = 2

function PANEL:Init()
	self.Columns = {}
	self.Rows = {}
	self.ColumnPadding = 0
	self.RowPadding = 0

	function self.pnlCanvas:PerformLayout()
		self:GetParent():ColumnLayout()
		self:InvalidateParent(true)
	end
end

function PANEL:SetPaddings(column_padding, row_padding)
	self.ColumnPadding = column_padding
	self.RowPadding = row_padding
end

function PANEL:SetColumns(...)
	self.Columns = {...}
	self.GrowColumnCount = 0
	for _,v in ipairs(self.Columns) do
		if (v == bVGUI.COLUMN_LAYOUT_COLUMN_GROW or v == bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
			self.GrowColumnCount = self.GrowColumnCount + 1
		end
	end
end

function PANEL:AddRow(...)
	local i = table.insert(self.Rows, {...})
	self.pnlCanvas:InvalidateLayout(true)
	return i
end

function PANEL:RemoveRow(row_index)
	for _,element in ipairs(self.Rows[row_index]) do
		element:Remove()
	end
	table.remove(self.Rows, row_index)
	self.pnlCanvas:InvalidateLayout(true)
end

function PANEL:ColumnLayout()
	local column_widths = {}
	local row_heights = {}
	for row_i, elements in ipairs(self.Rows) do
		for column_i, element in ipairs(elements) do
			if (self.Columns[column_i] == bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK) then
				local element_w = element:GetWide()
				local column_w = column_widths[column_i]
				if (not column_w or element_w > column_w) then
					column_widths[column_i] = element_w
				end
			end
			local element_h = element:GetTall()
			local row_h = row_heights[row_i]
			if (not row_h or element_h > row_h) then
				row_heights[row_i] = element_h
			end
		end
	end
	local grow_column_width = 0
	for i,v in pairs(column_widths) do
		grow_column_width = grow_column_width - v - self.ColumnPadding
	end
	grow_column_width = ((grow_column_width + self:GetWide()) / self.GrowColumnCount) - 4

	local row_y = 0
	for row_i, elements in ipairs(self.Rows) do
		local column_x = 0
		for column_i, element in ipairs(elements) do
			local column_sizing = self.Columns[column_i]
			if (column_sizing == bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK) then
				element:SetWide(column_widths[column_i])
				element:SetPos(column_x, row_y)
				column_x = column_x + column_widths[column_i] + self.ColumnPadding
			elseif (column_sizing == bVGUI.COLUMN_LAYOUT_COLUMN_GROW or column_sizing == bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
				if (bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
					element:SetWide(grow_column_width)
				else
					element:SetSize(grow_column_width, row_heights[row_i])
				end
				element:SetPos(column_x, row_y)
				column_x = column_x + grow_column_width + self.ColumnPadding
			end
		end
		row_y = row_y + row_heights[row_i] + self.RowPadding
	end
end

derma.DefineControl("bVGUI.ColumnLayout", nil, PANEL, "bVGUI.ScrollPanel")
--PATH lua/vgui/bvgui/option_selector.lua:
local PANEL = {}

function PANEL:Init()
	self.Color = bVGUI.BUTTON_COLOR_BLUE
	self.DarkColor = bVGUI.DarkenColor(self.Color, 0.5)

	self.SelectedX = bVGUI.Lerp(0,0,.5)
	self.SelectedWidth = bVGUI.Lerp(0,0,.5)

	self.ButtonLabels = {}
	self.TotalWidth = 0
	self.ButtonCount = 0
	self.Selected = 1

	self.ClickableArea = vgui.Create("bVGUI.BlankPanel", self)
	self.ClickableArea:SetMouseInputEnabled(true)
	self.ClickableArea:SetCursor("hand")
	function self.ClickableArea:OnMouseReleased(m)
		self:GetParent():OnMouseReleased(m)
	end
end

function PANEL:SetColor(col)
	self.Color = col
	self.DarkColor = bVGUI.DarkenColor(self.Color, 0.5)
end

local grey_col = Color(150,150,150)
local dark_grey_col = bVGUI.DarkenColor(grey_col, 0.5)
function PANEL:Paint(w,h)
	if (IsValid(self.HelpLabel)) then
		h = 26
	end

	self.SelectedX:DoLerp()
	self.SelectedWidth:DoLerp()

	draw.RoundedBoxEx(4,0,0,self.TotalWidth,h - 4,grey_col,true,true)
	draw.RoundedBoxEx(4,0,h - 4,self.TotalWidth,4,grey_col,false,false,true,true)

	if (self.LerpedColor == nil) then
		self.LerpedColor = Color(self.Color.r, self.Color.g, self.Color.b)
	else
		self.LerpedColor.r = Lerp(FrameTime() * 10, self.LerpedColor.r, self.Color.r)
		self.LerpedColor.g = Lerp(FrameTime() * 10, self.LerpedColor.g, self.Color.g)
		self.LerpedColor.b = Lerp(FrameTime() * 10, self.LerpedColor.b, self.Color.b)
	end

	if (self.LerpDarkColor == nil) then
		self.LerpDarkColor = Color(self.DarkColor.r, self.DarkColor.g, self.DarkColor.b)
	else
		self.LerpDarkColor.r = Lerp(FrameTime() * 10, self.LerpDarkColor.r, self.DarkColor.r)
		self.LerpDarkColor.g = Lerp(FrameTime() * 10, self.LerpDarkColor.g, self.DarkColor.g)
		self.LerpDarkColor.b = Lerp(FrameTime() * 10, self.LerpDarkColor.b, self.DarkColor.b)
	end

	draw.RoundedBoxEx(4, self.SelectedX:GetValue(), 0, self.SelectedWidth:GetValue(), h, self.LerpedColor, self.Selected == 1, self.Selected == self.ButtonCount, false, false)

	surface.SetDrawColor(dark_grey_col)
	surface.DrawRect(0,h - 4,self.TotalWidth,4)

	surface.SetDrawColor(self.LerpDarkColor)
	surface.DrawRect(self.SelectedX:GetValue(), h - 4, self.SelectedWidth:GetValue(), 4)
end

function PANEL:AddButton(text, col)
	self.ButtonCount = self.ButtonCount + 1
	local btn = vgui.Create("DLabel", self)
	btn.BtnIndex = table.insert(self.ButtonLabels, btn)
	btn.BtnColor = col
	btn:SetTextColor(bVGUI.COLOR_WHITE)
	btn:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	btn:SetContentAlignment(5)
	btn:SetText(text)
	self:InvalidateLayout(true)
end

function PANEL:PerformLayout(w,h)
	local x = 5
	for i,v in ipairs(self.ButtonLabels) do
		if (i == self.Selected) then
			self.SelectedX:SetTo((v:GetPos()) - 5)
			self.SelectedWidth:SetTo(v:GetWide() + 10)
		end
		v:SizeToContentsX()
		if (IsValid(self.HelpLabel)) then
			v:SetTall(26 - 4)
		else
			v:SetTall(h - 4)
		end
		v:AlignLeft(x)
		x = x + v:GetWide() + 10
	end
	self.TotalWidth = x - 5
	if (IsValid(self.Label)) then
		self.Label:AlignLeft(self.TotalWidth + 10)
	end
	if (IsValid(self.HelpLabel)) then
		local h = self.HelpLabel:GetTall() + 30
		if (self:GetTall() ~= h) then
			self:SetTall(h)
		end
	end
	self.ClickableArea:SetSize(self.TotalWidth, 26)
end

function PANEL:SetSelectedButton(index)
	self.Selected = index
	self:InvalidateLayout(true)
end
function PANEL:GetSelectedButton()
	return self.ButtonLabels[self.Selected]:GetText(), self.ButtonLabels[self.Selected]
end

function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		local x,y = self:ScreenToLocal(gui.MousePos())
		for i,v in ipairs(self.ButtonLabels) do
			local btn_x, btn_y, btn_w = v:GetBounds()
			if (y <= 25 and x >= btn_x - 5 and x <= btn_x + btn_w + 5) then
				self:SetSelectedButton(i)
				if (v.BtnColor ~= nil) then
					self:SetColor(v.BtnColor)
				end
				if (self.OnChange) then
					self:OnChange()
				end
				break
			end
		end
	end
end

function PANEL:SetText(text)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(text)
	self.Label:SizeToContentsX()
	self.Label:SetTall(21)
end

function PANEL:SetHelpText(text)
	self.HelpLabel = vgui.Create("DLabel", self)
	self.HelpLabel:SetContentAlignment(4)
	self.HelpLabel:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.HelpLabel:SetTextColor(bVGUI.COLOR_WHITE)
	self.HelpLabel:SetText(text)
	self.HelpLabel:SetWide(500)
	self.HelpLabel:SetWrap(true)
	self.HelpLabel:SetAutoStretchVertical(true)
	self.HelpLabel:AlignTop(30)
	self.HelpLabel:SetTextColor(Color(200,200,200))
	function self.HelpLabel:PerformLayout()
		self:InvalidateParent(true)
	end
end

function PANEL:GetValue()
	return self.ButtonLabels[self.Selected]:GetText()
end
function PANEL:SetValue(val)
	for i,v in ipairs(self.ButtonLabels) do
		if (v:GetText() == val) then
			self:SetSelectedButton(i)
			self.SelectedX:SetValue(self.SelectedX.to)
			self.SelectedWidth:SetValue(self.SelectedWidth.to)
			break
		end
	end
end

function PANEL:SizeToButtons()
	local w = 0
	for i,v in ipairs(self.ButtonLabels) do
		w = w + v:GetWide() + 10
	end
	self:SetWide(w)
end

derma.DefineControl("bVGUI.OptionSelector", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/dparticle.lua:
local PANEL = {}
PANEL.Zoom = 100
DEFINE_BASECLASS( "ContentIcon")

function PANEL:Init()
    self:SetPaintBackground( false )
	self:SetSize( 128, 128 )
	self:SetText( "" )
end

function PANEL:Setup(name, part)
    self.partName = name
    self:SetName(self.partName)

    PrecacheParticleSystem(self.partName)
    self.Particle = CreateParticleSystemNoEntity(self.partName, Vector(0, 0, 0), Angle(0, 0, 0))
    if not self.Particle then
        self:SetName("-Invalid particle system-")
        return
    end
    self.Particle:SetShouldDraw(false)
end

PANEL.WasValid = false
function PANEL:Paint(w, h)
    baseclass.Get("ContentIcon").Paint(self, w, h)
    if not self.Particle then return end
    if self.Particle:IsValid() then
        for k = 1, self.Particle:GetHighestControlPoint() do
            self.Particle:SetControlPoint(k, Vector(0, 0, k * 4))
        end
        self.Particle:SetControlPointEntity(0, LocalPlayer())
        self.WasValid = true
        local x, y = self:LocalToScreen(0, 0)
        local origin = Vector(45, 45, self.Zoom / 40)
        local ang = origin:Angle()
        ang:RotateAroundAxis(ang:Up(), 90)
        cam.Start3D(origin, -ang, self.Zoom, x + 8, y + 8, w - 16, h - 16, 0, 1024)
        self.Particle:Render()
        cam.End3D()
    elseif not self.Particle:IsValid() and self.WasValid then
        self.Particle = CreateParticleSystemNoEntity(self.partName, Vector(0, 0, 0), Angle(0, 0, 0))
        self.Particle:SetShouldDraw(false)
    end
end

function PANEL:OnMousePressed(m)
    if m == MOUSE_RIGHT then
        local menu = DermaMenu()
        menu:AddOption("Spawn Particle", function()
            RunConsoleCommand("gparticles_particle", self.partName)
            spawnmenu.ActivateTool( "gparticles" )
        end):SetIcon("icon16/fire.png")
        menu:AddOption("+Zoom", function()
            self.Zoom = self.Zoom - self.Zoom / 4
        end):SetIcon("icon16/add.png")
        menu:AddOption("-Zoom", function()
            self.Zoom = self.Zoom + self.Zoom / 4
        end):SetIcon("icon16/delete.png")
        menu:AddOption("Copy name", function()
            SetClipboardText(self.partName)
        end):SetIcon("icon16/help.png")
        menu:AddOption("Copy path", function()
            SetClipboardText("game.AddParticles(\"particles/" .. self.partName .. ".pcf\")")
        end):SetIcon("icon16/house_link.png")
        menu:AddOption("Cancel")
        menu:Open()
        return
    elseif m == MOUSE_LEFT then
        RunConsoleCommand("gparticles_particle", self.partName)
    end

    self:DoClick()
end

function PANEL:OnRemove()
    if self.Particle and self.Particle:IsValid() then
        self.Particle:StopEmissionAndDestroyImmediately()
    end
end

vgui.Register("ParticleControllerUI", PANEL, "ContentIcon")

spawnmenu.AddContentType( "particles", function( container, obj )

	if ( !obj.name ) then return end
	if ( !obj.part ) then return end

	local icon = vgui.Create( "ParticleControllerUI", container )
	icon:Setup( obj.name, obj.part )

	container:Add( icon )

end )

--PATH lua/vgui/openpermissions_horizontaldivider.lua:
local PANEL = {}

function PANEL:SetRightWidth(width)
	self.InitialRightWidth = width

	local oldpaint = self.Paint
	self.Paint = function(self, w, h)
		self:SetLeftWidth(w - self.InitialRightWidth)
		self.Paint = oldpaint
	end
end

function PANEL:BalanceWidths()
	local oldpaint = self.Paint
	self.Paint = function(self, w, h)
		self:SetLeftWidth((w - self:GetDividerWidth()) / 2)
		self.Paint = oldpaint
	end
end

derma.DefineControl("OpenPermissions.HorizontalDivider", nil, PANEL, "DHorizontalDivider")
--PATH addons/sl_utils/lua/vgui/stackercontrolpresets.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:OpenPresetEditor()
--
--]]--
function PANEL:OpenPresetEditor()
	if ( not self.m_strPreset ) then return end
	self.Window = vgui.Create( "StackerPresetEditor" )
	self.Window:MakePopup()
	self.Window:Center()
	self.Window:SetType( self.m_strPreset )
	self.Window:SetConVars( self.ConVars )
	self.Window:SetPresetControl( self )
end

vgui.Register( "StackerControlPresets", PANEL, "ControlPresets" )
--PATH gamemodes/mangarp/gamemode/libraries/simplerr.lua:
local CompileFile = CompileFile
local CompileString = CompileString
local debug = debug
local error = error
local file = file
local hook = hook
local include = include
local isfunction = isfunction
local isstring = isstring
local math = math
local os = os
local string = string
local table = table
local tonumber = tonumber
local unpack = unpack
local xpcall = xpcall

-- Template for syntax errors
-- The [ERROR] start of it cannot be removed, because that would make the
-- error mechanism remove all square brackets. Only Garry can make that bullshit up.
local synErrTranslation = [=[[ERROR] Lua is unable to understand file "%s" because its author made a mistake around line number %i.
The best help I can give you is this:

%s

Hints:
%s

------- End of Simplerr error -------
]=] -- The end is a special string by which simplerr errors are internally recognised

-- Template for runtime errors
local runErrTranslation = [=[[ERROR] A runtime error has occurred in "%s" on line %i.
The best help I can give you is this:

%s

Hints:
%s

The responsibility for the error above lies with (the authors of) one (or more) of these files:
%s
------- End of Simplerr error -------
]=]

-- Structure that contains syntax errors and their translations. Catches only the most common errors.
-- Order is important: the structure with the first match is taken.
local synErrs = {
    {
        match = "'=' expected near '(.*)'",
        text = "Right before the '%s', Lua expected to read an '='-sign, but it didn't.",
        format = function(m) return m[1] end,
        hints = {
            "Did you simply forget the '='-sign?",
            "Did you forget a comma?",
            "Is this supposed to be a local variable?"
        }
    },
    {
        match = "'.' expected [(]to close '([{[(])' at line ([0-9-]+)[)] near '(.*)'",
        text = "There is an opening '%s' bracket at line %i, but this bracket is never closed or not closed in time. It was expected to be closed before the '%s' at line %i.",
        format = function(m, l) return m[1], m[2], m[3], l end,
        hints = {
            "Did you forget a comma?",
            "All open brackets ({, (, [) must have a matching closing bracket. Are you sure it's there?",
            "Brackets must be opened and closed in the right order. This will work: ({}), but this won't: ({)}."
        }
    },
    {
        match = "'end' expected [(]to close '(.*)' at line ([0-9-]+)[)] near '(.*)'",
        text = "An '%s' was started on line %i, but it was never ended or not ended in time. It was expected to be ended before the '%s' at line %i",
        format = function(m, l) return m[1], m[2], m[3], l end,
        hints = {
            "For every if/for/do/while/function there must be an 'end' that closes it."
        }
    },
    {
        match = "unfinished string near '(.*)'",
        text = "The string '%s' at line %i is opened, but not closed.",
        format = function(m, l) return m[1], l end,
        hints = {
            "A string is a different word for literal text.",
            "Strings must be in single or double quotation marks (e.g. 'example', \"example\")",
            "A third option for strings is for them to be in double square brackets.",
            "Whatever you use (quotations or square brackets), you must not forget that strings are enclosed within a pair of quotation marks/square brackets."
        }
    },
    {
        match = "unfinished long string near '(.*)'",
        text = "Lua expected to see the end of a multiline string somewhere before the '%s' at line %i.",
        format = function(m, l) return m[1], l end,
        hints = {
            "A string is a different word for literal text.",
            "Multiline strings are strings that span over multiple lines.",
            "Multiline strings must be enclosed by double square brackets.",
            "Whatever you use (quotations or square brackets), you must not forget that strings are enclosed within a pair of quotation marks/square brackets.",
            "If you used brackets, the source of the mistake may be somewhere above the reported line."
        }
    },
    {
        match = "unfinished long comment near '(.*)'",
        text = "Lua expected to see the end of a multiline comment somewhere before the '%s' at line %i.",
        format = function(m, l) return m[1], l end,
        hints = {
            "A comment is text ignored by Lua.",
            "Multiline comments are ones that span multiple lines.",
            "Multiline comments must be enclosed by either /* and */ or double square brackets.",
            "Whatever you use (/**/ or square brackets), you must not forget that once you start a comment, you must end it.",
            "The source of the mistake may be somewhere above the reported line."
        }
    },
    -- Generic error messages
    {
        match = "function arguments expected near '(.*)'",
        text = "A function is being called right before '%s', but its arguments are not given.",
        format = function(m) return m[1] end,
        hints = {
            "Did you write 'something:otherthing'? Try changing it to 'something:otherthing()'"
        }
    },
    {
        match = "unexpected symbol near '(.*)'",
        text = "Right before the '%s', Lua encountered something it could not make sense of.",
        format = function(m) return m[1] end,
        hints = {"Did you forget something here? (Perhaps a closing bracket)", "Is it a typo?"}
    },
    {
        match = "'(.*)' expected near '(.*)'",
        text = "Right before the '%s', Lua expected to read a '%s', but it didn't.",
        format = function(m) return m[2], m[1] end,
        hints = {"Did you forget a keyword?", "Did you forget a comma?"}
    },
    {
        match = "malformed number near '(.*)'",
        text = "Lua attempted to read '%s' as a number, but failed to do so.",
        format = function(m) return m[1] end,
        hints = {
            "Numbers starting with '0x' are hexidecimal.",
            "Lua can get confused when doing '<number>..\"some text\"'. Try inserting a space between the number and the '..'."
        }
    },
}

-- Similar structure for runtime errors. Catches only the most common errors.
-- Order is important: the structure with the first match is taken
local runErrs = {
    {
        match = "table index is nil",
        text = "A table is being indexed by something that does not exist (table index is nil).", -- Requires improvement
        format = function() end,
        hints = {
            "The thing between square brackets does not exist (is nil)."
        }
    },
    {
        match = "table index is NaN",
        text = "A table is being indexed by something that is not really a number (table index is NaN).",
        format = function() end,
        hints = {
            "Did you divide zero by zero thinking it would be funny?"
        }
    },
    {
        match = "attempt to index global '(.*)' [(]a nil value[)]",
        text = "'%s' is being indexed like it is a table, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You either have 'something.somethingElse', 'something[somethingElse]' or 'something:somethingElse(more)'. The 'something' here does not exist."
        }
    },
    {
        match = "attempt to index global '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being indexed like it is a table, but in reality it is a %s value.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You either have 'something.somethingElse' or 'something:somethingElse(more)'. The 'something' here is not a table."
        }
    },
    {
        match = "attempt to index a nil value",
        text = "Something is being indexed like it is a table, but in reality does not exist (is nil).",
        format = function() end,
        hints = {
            "You either have 'something.somethingElse', 'something[somethingElse]' or 'something:somethingElse(more)'. The 'something' here does not exist."
        }
    },
    {
        match = "attempt to index a (.*) value",
        text = "Something is being indexed like it is a table, but in reality it is a %s value.",
        format = function(m) return m[1] end,
        hints = {
            "You either have 'something.somethingElse', 'something[somethingElse]' or 'something:somethingElse(more)'. The 'something' here is not a table."
        }
    },
    {
        match = "attempt to call global '(.*)' [(]a nil value[)]",
        text = "'%s' is being called like it is a function, but in reality does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here does not exist."
        }
    },
    {
        match = "attempt to call a nil value",
        text = "Something is being called like it is a function, but in reality it does not exist (is nil).",
        format = function() end,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here does not exist."
        }
    },
    {
        match = "attempt to call global '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being called like it is a function, but in reality it is a %s.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here is not a function."
        }
    },
    {
        match = "attempt to call a (.*) value",
        text = "Something is being called like it is a function, but in reality it is a %s.",
        format = function(m) return m[1] end,
        hints = {
            "You are doing something(<otherstuff>). The 'something' here is not a function."
        }
    },
    {
        match = "attempt to call field '(.*)' [(]a nil value[)]",
        text = "'%s' is being called like it is a function, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing either stuff.something(<otherstuff>) or stuff:something(<otherstuff>). The 'something' here does not exist."
        }
    },
    {
        match = "attempt to call field '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being called like it is a function, but in reality it is a %s.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You are doing either stuff.something(<otherstuff>) or stuff:something(<otherstuff>). The 'something' here is not a function."
        }
    },
    {
        match = "attempt to concatenate global '(.*)' [(]a nil value[)]",
        text = "'%s' is being concatenated to something else, but '%s' does not exist (is nil).",
        format = function(m) return m[1], m[1] end,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing does not exist."
        }
    },
    {
        match = "attempt to concatenate global '(.*)' [(]a (.*) value[)]",
        text = "'%s' is being concatenated to something else, but %s values cannot be concatenated.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing is neither string nor number."
        }
    },
    {
        match = "attempt to concatenate a nil value",
        text = "Two (or more) things are being concatenated and one of them does not exist (is nil).",
        format = function() end,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing does not exist."
        }
    },
    {
        match = "attempt to concatenate a (.*) value",
        text = "Two (or more) things are being concatenated and one of them is neither string nor number, but a %s.",
        format = function(m) return m[1] end,
        hints = {
            "Concatenation looks like this: something .. otherThing. Either something or otherThing is neither string nor number."
        }
    },
    {
        match = "stack overflow",
        text = "The stack of function calls has overflowed",
        format = function() end,
        hints = {
            "Most likely infinite recursion.",
            "Do you have a function calling itself?"
        }
    },
    {
        match = "attempt to compare two (.*) values",
        text = "A comparison is being made between two %s values. They cannot be compared.",
        format = function(m) return m[1] end,
        hints = {
            "This error usually occurs when two incompatible things are being compared.",
            "'comparison' in this context means one of <, >, <=, >= (smaller than, greater than, etc.)"
        }
    },
    {
        match = "attempt to compare (.*) with (.*)",
        text = "A comparison is being made between a %s and a %s. This is not possible.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "This error usually occurs when two incompatible things are being compared.",
            "'Comparison' in this context means one of <, >, <=, >= (smaller than, greater than, etc.)"
        }
    },
    {
        match = "attempt to perform arithmetic on a (.*) value",
        text = "Arithmetic operations are being performed on a %s. This is not possible.",
        format = function(m) return m[1] end,
        hints = {
            "'Arithmetic' in this context means adding, multiplying, dividing, etc."
        }
    },
    {
        match = "attempt to get length of global '(.*)' [(]a nil value[)]",
        text = "The length of '%s' is requested as if it is a table, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing #something. The 'something' here is does not exist."
        }
    },
    {
        match = "attempt to get length of global '(.*)' [(]a (.*) value[)]",
        text = "The length of '%s' is requested as if it is a table, but in reality it is a %s.",
        format = function(m) return m[1], m[2] end,
        hints = {
            "You are doing #something. The 'something' here is not a table."
        }
    },
    {
        match = "attempt to get length of a nil value",
        text = "The length of something is requested as if it is a table, but in reality it does not exist (is nil).",
        format = function(m) return m[1] end,
        hints = {
            "You are doing #something. The 'something' here is does not exist."
        }
    },
    {
        match = "attempt to get length of a (.*) value",
        text = "The length of something is requested as if it is a table, but in reality it is a %s.",
        format = function(m) return m[1] end,
        hints = {
            "You are doing #something. The 'something' here is not a table."
        }
    },
}

module("simplerr")

-- Get a nicely formatted stack trace. Start is where to start numbering
-- stackMod allows the caller to modify the stack before it is numbered
local function getStack(i, start, stackMod)
    i = i or 1
    start = start or 1
    local stack = {}

    -- Invariant: stack level (i + count) >= 2 and <= last stack item
    for count = 1, math.huge do -- user visible count
        local info = debug.getinfo(i + count, "Sln")
        if not info then break end

        local line = info.currentline or "unknown"
        if line == -1 and info.name then
            table.insert(stack, string.format("function '%s'", info.name))
        else
            table.insert(stack, string.format("%s on line %s", info.short_src, line))
        end
    end

    -- Allow modification of the stack
    if stackMod then stack = stackMod(stack) end

    -- add the numbering
    for count = 1, #stack do
        local stackLevel = start + count - 1
        stack[count] = string.format("\t%i. %s", stackLevel, stack[count])
    end

    return table.concat(stack, "\n")
end

-- Translate a runtime error to simplerr format.
-- Decorate with e.g. wrapError to have it actually throw the error.
function runError(msg, stackNr, hints, path, line, stack)
    stackNr = stackNr or 1
    hints = hints or {"No hints, sorry."}
    hints = "\t- " .. table.concat(hints, "\n\t- ")

    if not path and not line then
        local info = debug.getinfo(stackNr + 1, "Sln") or debug.getinfo(stackNr, "Sln")
        path = info.short_src
        line = info.currentline
    end

    return false, string.format(runErrTranslation, path, line, msg, hints, stack or getStack(stackNr + 1))
end

-- Translate the message of an error
local function translateMsg(msg, path, line, errs)
    local res
    local hints = {"No hints, sorry."}

    for i = 1, #errs do
        local trans = errs[i]
        if not string.find(msg, trans.match) then continue end

        -- translate <eof>
        msg = string.Replace(msg, "<eof>", "end of the file")

        res = string.format(trans.text, trans.format({string.match(msg, trans.match)}, line, path))
        hints = trans.hints

        break
    end

    return res or msg, "\t- " .. table.concat(hints, "\n\t- ")
end

-- Translate an error into a language understandable by non-programmers
local function translateError(path, line, err, translation, errs, stack)
    -- Using .* instead of path because path may be wrong when error is called
    local msg, hints = translateMsg(string.match(err, ".*:[0-9-]+: (.*)"), path, line, errs)
    local res = string.format(translation, path, line, msg, hints, stack)
    return res
end


-- Trims the [C] functions at the beginning of the stack
local function trimStart(stack)
    while true do
        if string.StartWith(stack[1], "function ") then
            table.remove(stack, 1)
        else
            break
        end
    end

    return stack
end

-- safeCall uses xpcall, which has the downside that both xpcall and
-- the safeCall function itself end up in the stack trace.
-- This function removes them from the stack trace
local function removeXpcall(stack)
    for i = #stack - 1, 1, -1 do
        if stack[i] == "function 'xpcall'" and string.find(stack[i + 1], "simplerr") then
            table.remove(stack, i)
            table.remove(stack, i) -- also remove the simplerr safeCall call

            return stack
        end
    end

    return stack
end

-- Combines the two above functions
local function stackModAggregate(stack)
    stack = trimStart(stack)
    return removeXpcall(stack)
end

-- Used as the error handler in safeCall
local function errorHandler(err, func)
    -- Investigate the stack. Not using err matching because calls to error can give a different path and line
    local stack = getStack(func and 1 or 2, 1, stackModAggregate) -- add called func to stack

    -- Fetch the path and line number from the top of the stack
    local firstLine = string.sub(stack, 1, string.match(stack, "()\n") - 1)
    local path, line = string.match(firstLine, "\t[0-9-]+%. (.*) on line ([0-9-]+)")
    line = tonumber(line)

    return {err, path, line, stack}
end

-- Call a function and catch immediate runtime errors
function safeCall(f, ...)
    -- Use xpcall so fetching of debug info is in the stack of the error rather than after it is unwound
    local res = {xpcall(f, errorHandler, ...)}

    local succ, errInfo = res[1], res[2]

    if succ then return unpack(res) end

    -- This will only happen if the error is "not enough memory" or "error in error handling".
    -- The former tends to crash the game and the latter will mean it'll probably error in the next line.
    -- But we will try anyway.
    -- Note: stack trace will be less accurate.
    if isstring(errInfo) then errInfo = errorHandler(errInfo, f) end

    -- Skip translation if the error is already a simplerr error
    -- This prevents nested simplerr errors when runError is called by a file loaded by runFile
    local mustTranslate = not string.find(errInfo[1], "------- End of Simplerr error -------")
    return false, mustTranslate and translateError(errInfo[2], errInfo[3], errInfo[1], runErrTranslation, runErrs, errInfo[4]) or errInfo[1]
end

-- Run a file or explain its syntax errors in layman's terms
-- Returns bool succeed, [string error]
-- Do NOT use this on clientside files.
-- Clientside files sent by the server cannot be read using file.Read unless you're the host of a listen server
function runFile(path)
    if not file.Exists(path, "LUA") then error(string.format("Could not run file '%s' (file not found)", path)) end
    local contents = file.Read(path, "LUA")

    -- Files can make a comment containing #NoSimplerr# to disable simplerr (and thus enable autorefresh)
    if string.find(contents, "#NoSimplerr#") then include(path) return true end

    -- Catch syntax errors with CompileString
    local err = CompileString(contents, path, false)

    -- CompileString returns the following string whenever a file is empty: Invalid script - or too short.
    -- It also prints: Not running script <path> - it's too short.
    -- If so, do nothing.
    if err == "Invalid script - or too short." then return true end

    -- No syntax errors, check for immediate runtime errors using CompileFile
    -- Using the function CompileString returned leads to relative path trouble
    if isfunction(err) then return safeCall(CompileFile(path), path) end

    -- Fetch the line number from the error
    local line = string.match(err, ".*:([0-9-]+): .*")
    line = tonumber(line)

    return false, translateError(path, line, err, synErrTranslation, synErrs)
end

-- Error wrapper: decorator for runFile and safeCall that throws an error on failure.
-- Breaks execution. Must be the last decorator.
function wrapError(succ, err, ...)
    if succ then return succ, err, ... end

    error(err)
end

-- Hook wrapper: Calls a hook on error
function wrapHook(succ, err, ...)
    if not succ then hook.Call("onSimplerrError", nil, err) end

    return succ, err, ...
end

-- Logging wrapper: decorator for runFile and safeCall that logs failures.
local log = {}
function wrapLog(succ, err, ...)
    if succ then return succ, err, ... end

    local data = {
        err = err,
        time = os.time()
    }

    table.insert(log, data)

    return succ, err, ...
end

-- Retrieve the log
function getLog() return log end

-- Clear the log
function clearLog() log = {} end

--PATH gamemodes/mangarp/gamemode/modules/workarounds/sh_interface.lua:
DarkRP.getAvailableVehicles = DarkRP.stub{
    name = "getAvailableVehicles",
    description = "Get the available vehicles that DarkRP supports.",
    parameters = {
    },
    returns = {
        {
            name = "vehicles",
            description = "Names, models and classnames of all supported vehicles.",
            type = "table"
        }
    },
    metatable = DarkRP
}

--PATH gamemodes/mangarp/gamemode/modules/chatindicator/cl_interface.lua:
DarkRP.hookStub{
    name = "DrawChatIndicator",
    description = "Call when the Chat Indicator is drawn. Return to overwrite.",
    parameters = {
        {
            name = "ply",
            description = "The player the indicator should be drawn for.",
            type = "Player"
        }
    },
    returns = {
        {
            name = "override",
            description = "Return true in your hook to disable the default drawing.",
            type = "boolean"
        }
    }
}

--PATH gamemodes/mangarp/gamemode/modules/base/sh_interface.lua:
DarkRP.registerDarkRPVar = DarkRP.stub{
    name = "registerDarkRPVar",
    description = "Register a DarkRPVar by name. You should definitely register DarkRPVars. Registering DarkRPVars will make networking much more efficient.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        },
        {
            name = "writeFn",
            description = "The function that writes a value for this DarkRPVar. Examples: net.WriteString, function(val) net.WriteUInt(val, 8) end.",
            type = "function",
            optional = false
        },
        {
            name = "readFn",
            description = "The function that reads and returns a value for this DarkRPVar. Examples: net.ReadString, function() return net.ReadUInt(8) end.",
            type = "function",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.writeNetDarkRPVar = DarkRP.stub{
    name = "writeNetDarkRPVar",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when sending DarkRPVar net messages. This function writes the net data for a specific DarkRPVar.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        },
        {
            name = "value",
            description = "The value of the DarkRPVar.",
            type = "any",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.writeNetDarkRPVarRemoval = DarkRP.stub{
    name = "writeNetDarkRPVarRemoval",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when sending DarkRPVar net messages. This function sets a DarkRPVar to nil.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.readNetDarkRPVar = DarkRP.stub{
    name = "readNetDarkRPVar",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when reading DarkRPVar net messages. This function reads the net data for a specific DarkRPVar.",
    parameters = {
    },
    returns = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string"
        },
        {
            name = "value",
            description = "The value of the DarkRPVar.",
            type = "any"
        }
    },
    metatable = DarkRP
}

DarkRP.readNetDarkRPVarRemoval = DarkRP.stub{
    name = "readNetDarkRPVarRemoval",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when reading DarkRPVar net messages. This function the removal of a DarkRPVar.",
    parameters = {
    },
    returns = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.findPlayer = DarkRP.stub{
    name = "findPlayer",
    description = "Find a single player based on vague information.",
    parameters = {
        {
            name = "info",
            description = "The information of the player (UserID, SteamID, name).",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "found",
            description = "The player that matches the description.",
            type = "Player"
        }
    },
    metatable = DarkRP
}

DarkRP.findPlayers = DarkRP.stub{
    name = "findPlayers",
    description = "Find a list of players based on vague information.",
    parameters = {
        {
            name = "info",
            description = "The information of the player (UserID, SteamID, name).",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "found",
            description = "Table of players that match the description.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.nickSortedPlayers = DarkRP.stub{
    name = "nickSortedPlayers",
    description = "A table of players sorted by RP name.",
    parameters = {},
    returns = {
        {
            name = "players",
            description = "The list of players sorted by RP name.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.explodeArg = DarkRP.stub{
    name = "explodeArg",
    description = "String arguments exploded into a table. It accounts for substrings in quotes, which makes it more intelligent than string.Explode",
    parameters = {
        {
            name = "arg",
            description = "The full string of the argument",
            type = "string",
            optional = false
        },
    },
    returns = {
        {
            name = "args",
            description = "The table of arguments",
            type = "table"
        }
    },
    metatable = DarkRP
}


DarkRP.formatMoney = DarkRP.stub{
    name = "formatMoney",
    description = "Format a number as a money value. Includes currency symbol.",
    parameters = {
        {
            name = "amount",
            description = "The money to format, e.g. 100000.",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "money",
            description = "The money as a nice string, e.g. \"$100,000\".",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.getJobByCommand = DarkRP.stub{
    name = "getJobByCommand",
    description = "Get the job table and number from the command of the job.",
    parameters = {
        {
            name = "command",
            description = "The command of the job, without preceding slash (e.g. 'medic' for medic)",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "tbl",
            description = "A table containing all information about the job.",
            type = "table"
        },
        {
            name = "jobindex",
            description = "The index of the job (for 'medic' it's the value of TEAM_MEDIC).",
            type = "number"
        }
    },
    metatable = DarkRP
}

DarkRP.simplerrRun = DarkRP.stub{
    name = "simplerrRun",
    description = "Run a function with the given parameters and send any runtime errors to admins.",
    parameters = {
        {
            name = "f",
            description = "The function to be called.",
            type = "function",
            optional = false
        },
        {
            name = "args",
            description = "The arguments to be given to f.",
            type = "vararg",
            optional = true
        },
    },
    returns = {
        {
            name = "retVals",
            description = "The return values of f.",
            type = "vararg"
        }
    },
    metatable = DarkRP
}

DarkRP.error = DarkRP.stub{
    name = "error",
    description = "Throw a simplerr formatted error. Also halts the stack, which means that statements after calling this function will not execute.",
    parameters = {
        {
            name = "message",
            description = "The message of the error.",
            type = "string",
            optional = false
        },
        {
            name = "stack",
            description = "From which point in the function call stack to report the error. 1 to include the function that called DarkRP.error, 2 to exclude it, etc. The default value is 1.",
            type = "number",
            optional = true
        },
        {
            name = "hints",
            description = "Table containing hint strings. Use these hints to explain the error, describe possible causes or provide help to solve the problem.",
            type = "table",
            optional = true
        },
        {
            name = "path",
            description = "Override the path of the error. Will be shown in the error message. By default this is determined by the stack level.",
            type = "string",
            optional = true
        },
        {
            name = "line",
            description = "Override the line number of the error. By default this is determined by the stack level.",
            type = "number",
            optional = true
        },

    },
    returns = {
        {
            name = "succeed",
            description = "Simplerr return value: whether the calculation succeeded. Always false. This return value will never be reached.",
            type = "boolean"
        },
        {
            name = "msg",
            description = "Simplerr return value: nicely formatted error message. This return value will never be reached.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.errorNoHalt = DarkRP.stub{
    name = "errorNoHalt",
    description = "Throw a simplerr formatted error. Unlike DarkRP.error, this does not halt the stack. This means that statements after calling this function will be executed like normal.",
    parameters = {
        {
            name = "message",
            description = "The message of the error.",
            type = "string",
            optional = false
        },
        {
            name = "stack",
            description = "From which point in the function call stack to report the error. 1 to include the function that called DarkRP.error, 2 to exclude it, etc. The default value is 1.",
            type = "number",
            optional = true
        },
        {
            name = "hints",
            description = "Table containing hint strings. Use these hints to explain the error, describe possible causes or provide help to solve the problem.",
            type = "table",
            optional = true
        },
        {
            name = "path",
            description = "Override the path of the error. Will be shown in the error message. By default this is determined by the stack level.",
            type = "string",
            optional = true
        },
        {
            name = "line",
            description = "Override the line number of the error. By default this is determined by the stack level.",
            type = "number",
            optional = true
        },

    },
    returns = {
        {
            name = "succeed",
            description = "Simplerr return value: whether the calculation succeeded. Always false.",
            type = "boolean"
        },
        {
            name = "msg",
            description = "Simplerr return value: nicely formatted error message.",
            type = "string"
        }
    },
    metatable = DarkRP
}

-- This function is one of the few that's already defined before the stub is created
DarkRP.stub{
    name = "SteamName",
    description = "Retrieve a player's real (steam) name.",
    parameters = {

    },
    returns = {
        {
            name = "name",
            description = "The player's steam name.",
            type = "string"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getJobTable = DarkRP.stub{
    name = "getJobTable",
    description = "Get the job table of a player.",
    parameters = {
    },
    returns = {
        {
            name = "job",
            description = "Table with the job information.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getDarkRPVar = DarkRP.stub{
    name = "getDarkRPVar",
    description = "Get the value of a DarkRPVar, which is shared between server and client.",
    parameters = {
        {
            name = "var",
            description = "The name of the variable.",
            type = "string",
            optional = false
        },
        {
            name = "fallback",
            description = "The value to return if the DarkRPVar doesn't exist.",
            type = "any",
            optional = true
        }
    },
    returns = {
        {
            name = "value",
            description = "The value of the DarkRP var.",
            type = "any"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getAgenda = DarkRP.stub{
    name = "getAgenda",
    description = "Get the agenda a player manages.",
    deprecated = "Use ply:getAgendaTable() instead.",
    parameters = {
    },
    returns = {
        {
            name = "agenda",
            description = "The agenda.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getAgendaTable = DarkRP.stub{
    name = "getAgendaTable",
    description = "Get the agenda a player can see. Note: when a player is not the manager of an agenda, it returns the agenda of the manager.",
    parameters = {
    },
    returns = {
        {
            name = "agenda",
            description = "The agenda.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.hasDarkRPPrivilege = DarkRP.stub{
    name = "hasDarkRPPrivilege",
    description = "Whether the player has a certain privilege.",
    parameters = {
        {
            name = "priv",
            description = "The name of the privilege.",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether the player has the privilege.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getEyeSightHitEntity = DarkRP.stub{
    name = "getEyeSightHitEntity",
    description = "Get the entity that is closest to a player's line of sight and its distance.",
    parameters = {
        {
            name = "searchDistance",
            description = "How far to look. You usually don't want this function to return an entity millions of units away. The default is 100 units.",
            type = "number",
            optional = true
        },
        {
            name = "hitDistance",
            description = "The maximum distance between the player's line of sight and the object. Basically how far the player can be 'looking away' from the object. The default is 15 units.",
            type = "number",
            optional = true
        },
        {
            name = "filter",
            description = "The filter for which entities to look for. By default it only looks for players.",
            type = "function",
            optional = true
        }
    },
    returns = {
        {
            name = "closestEnt",
            description = "The entity that is closest to the player's line of sight. Returns nil when not found.",
            type = "Entity"
        },
        {
            name = "distance",
            description = "The (minimum) distance between the player's line of sight and the object.",
            type = "number"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.VECTOR.isInSight = DarkRP.stub{
    name = "isInSight",
    description = "Decides whether the vector could be seen by the player if they were to look at it.",
    parameters = {
        {
            name = "filter",
            description = "Trace filter that decides what the player can see through.",
            type = "table",
            optional = false
        },
        {
            name = "ply",
            description = "The player for whom the vector may or may not be visible.",
            type = "Player",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether the player can see the position.",
            type = "boolean"
        },
        {
            name = "HitPos",
            description = "The position of the thing that blocks the player's sight.",
            type = "Vector"
        }
    },
    metatable = DarkRP.VECTOR
}

DarkRP.hookStub{
    name = "UpdatePlayerSpeed",
    description = "Change a player's walking and running speed.",
    deprecated = "Use GMod's SetupMove and Move hooks instead.",
    parameters = {
        {
            name = "ply",
            description = "The player for whom the speed changes.",
            type = "Player"
        }
    },
    returns = {
    }
}

--[[---------------------------------------------------------------------------
Creating custom items
---------------------------------------------------------------------------]]
DarkRP.createJob = DarkRP.stub{
    name = "createJob",
    description = "Create a job for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the job.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the job.",
            type = "table",
            optional = false
        }
    },
    returns = {
        {
            name = "team",
            description = "The team number of the job you've created.",
            type = "number"
        }
    },
    metatable = DarkRP
}
AddExtraTeam = DarkRP.createJob

DarkRP.removeJob = DarkRP.stub{
    name = "removeJob",
    description = "Remove a job from DarkRP.",
    parameters = {
        {
            name = "i",
            description = "The TEAM_ number of the job. Also the index of the job in RPExtraTeams.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeShipment = DarkRP.stub{
    name = "removeShipment",
    description = "Remove a shipment from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeVehicle = DarkRP.stub{
    name = "removeVehicle",
    description = "Remove a vehicle from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeEntity = DarkRP.stub{
    name = "removeEntity",
    description = "Remove an entity from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeGroupChat = DarkRP.stub{
    name = "removeGroupChat",
    description = "Remove a groupchat from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeAmmoType = DarkRP.stub{
    name = "removeAmmoType",
    description = "Remove an ammotype from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeEntityGroup = DarkRP.stub{
    name = "removeEntityGroup",
    description = "Remove an entitygroup from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeAgenda = DarkRP.stub{
    name = "removeAgenda",
    description = "Remove a agenda from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeDemoteGroup = DarkRP.stub{
    name = "removeDemoteGroup",
    description = "Remove an demotegroup from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.createEntityGroup = DarkRP.stub{
    name = "createEntityGroup",
    description = "Create a entity group for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the entity group.",
            type = "string",
            optional = false
        },
        {
            name = "teamNrs",
            description = "Vararg team numbers.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddDoorGroup = DarkRP.createEntityGroup

DarkRP.createShipment = DarkRP.stub{
    name = "createShipment",
    description = "Create a shipment for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the shipment.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the shipment.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomShipment = DarkRP.createShipment

DarkRP.createVehicle = DarkRP.stub{
    name = "createVehicle",
    description = "Create a vehicle for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the vehicle.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the vehicle.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomVehicle = DarkRP.createVehicle

DarkRP.createEntity = DarkRP.stub{
    name = "createEntity",
    description = "Create a entity for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the entity.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the entity.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomVehicle = DarkRP.createEntity

DarkRP.createAgenda = DarkRP.stub{
    name = "createAgenda",
    description = "Create an agenda for groups of jobs to communicate.",
    parameters = {
        {
            name = "title",
            description = "The name of the agenda.",
            type = "string",
            optional = false
        },
        {
            name = "manager",
            description = "The team numer of the manager of the agenda (the one who can set the agenda).",
            type = "number",
            optional = false
        },
        {
            name = "listeners",
            description = "The jobs that can see this agenda.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddAgenda = DarkRP.createAgenda

DarkRP.getAgendas = DarkRP.stub{
    name = "getAgendas",
    description = "Get all agendas. Note: teams that share an agenda use the exact same agenda table. E.g. when you change the agenda of the CP, the agenda of the Chief will automatically be updated as well. Make sure this property is maintained when modifying the agenda table. Not maintaining that property will lead to players not seeing the right agenda text.",
    parameters = {

    },
    returns = {
        {
            name = "agendas",
            description = "Table in which the keys are team numbers and the values agendas.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.createGroupChat = DarkRP.stub{
    name = "createGroupChat",
    description = "Create a group chat.",
    parameters = {
        {
            name = "functionOrJob",
            description = "A function that returns whether the person can see the group chat, or a team number.",
            type = "any",
            optional = false
        },
        {
            name = "teamNr",
            description = "VarArg team number.",
            type = "number",
            optional = true
        }
    },
    returns = {
    },
    metatable = DarkRP
}
GM.AddGroupChat = DarkRP.createGroupChat

DarkRP.createAmmoType = DarkRP.stub{
    name = "createAmmoType",
    description = "Create an ammo type.",
    parameters = {
        {
            name = "name",
            description = "The name of the ammo.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the ammo.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.createDemoteGroup = DarkRP.stub{
    name = "createDemoteGroup",
    description = "Create a demote group. When you get banned (demoted) from one of the jobs in this group, you will be banned from every job in this group.",
    parameters = {
        {
            name = "name",
            description = "The name of the demote group.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table consisting of a list of job.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getDemoteGroup = DarkRP.stub{
    name = "getDemoteGroup",
    description = "Get the demote group of a team. Every team in the same group will return the same object.",
    parameters = {
        {
            name = "teamNr",
            description = "Table consisting of a list of job.",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "set",
            description = "The demote group identifier.",
            type = "Disjoint-Set"
        }
    },
    metatable = DarkRP
}

DarkRP.getGroupChats = DarkRP.stub{
    name = "getGroupChats",
    description = "Get all group chats.",
    parameters = {

    },
    returns = {
        {
            name = "set",
            description = "Table with functions that decide who can hear who.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.getDemoteGroups = DarkRP.stub{
    name = "getDemoteGroups",
    description = "Get all demote groups Every team in the same group will return the same object.",
    parameters = {

    },
    returns = {
        {
            name = "set",
            description = "Table in which the keys are team numbers and the values Disjoint-Set.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.createCategory = DarkRP.stub{
    name = "createCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "tbl",
            description = "Table describing the category.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.addToCategory = DarkRP.stub{
    name = "addToCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "item",
            description = "Table of the custom entity/job/etc.",
            type = "table",
            optional = false
        },
        {
            name = "kind",
            description = "The kind of the category (e.g. 'jobs' for job stuff).",
            type = "string",
            optional = false
        },
        {
            name = "cat",
            description = "The name of the category. Note that the category must exist. Defaults to 'Other'.",
            type = "string",
            optional = true
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeFromCategory = DarkRP.stub{
    name = "removeFromCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "item",
            description = "Table of the custom entity/job/etc.",
            type = "table",
            optional = false
        },
        {
            name = "kind",
            description = "The kind of the category (e.g. 'jobs' for job stuff).",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getCategories = DarkRP.stub{
    name = "getCategories",
    description = "Get all categories for all F4 menu tabs.",
    parameters = {
    },
    returns = {
        {
            name = "tbl",
            description = "all categories.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.ValidatedPhysicsInit = DarkRP.stub{
    name = "ValidatedPhysicsInit",
    description = "Initialise the physics of an entity, throw a discriptive error when this fails.",
    parameters = {
        {
            name = "ent",
            description = "Entity for which to create the PhysObj.",
            type = "entity",
            optional = false
        },
        {
            name = "kind",
            description = "The SOLID_ enum type. By default this is SOLID_VPHYSICS",
            type = "number",
            optional = true
        },
        {
            name = "hint",
            description = "Optional hint for the error message.",
            type = "string",
            optional = true
        }
    },
    returns = {
        {
            name = "success",
            description = "Whether creating the PhysObj succeeded",
            type = "boolean"
        }
    },
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "DarkRPVarChanged",
    description = "Called when a DarkRPVar was changed.",
    parameters = {
        {
            name = "ply",
            description = "The player for whom the DarkRPVar changed.",
            type = "Player"
        },
        {
            name = "varname",
            description = "The name of the variable that has changed.",
            type = "string"
        },
        {
            name = "oldValue",
            description = "The old value of the DarkRPVar.",
            type = "any"
        },
        {
            name = "newvalue",
            description = "The new value of the DarkRPVar.",
            type = "any"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "canBuyPistol",
    description = "Whether a player can buy a pistol.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "shipmentTable",
            description = "The table, as defined in the shipments file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyShipment",
    description = "Whether a player can buy a shipment.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "shipmentTable",
            description = "The table, as defined in the shipments file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyVehicle",
    description = "Whether a player can buy a vehicle.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "vehicleTable",
            description = "The table, as defined in the vehicles file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyAmmo",
    description = "Whether a player can buy ammo.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "ammoTable",
            description = "The table, as defined in the a ammo file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyCustomEntity",
    description = "Whether a player can a certain custom entity.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "entTable",
            description = "The table, as defined by the user.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "onJobRemoved",
    description = "Called when a job was removed.",
    parameters = {
        {
            name = "num",
            description = "The TEAM_ number of the job.",
            type = "number"
        },
        {
            name = "jobbtable",
            description = "The table containing all the job info.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onShipmentRemoved",
    description = "Called when a shipment was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onVehicleRemoved",
    description = "Called when a vehicle was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onEntityRemoved",
    description = "Called when a buyable entity was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onGroupChatRemoved",
    description = "Called when a groupchat was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onAmmoTypeRemoved",
    description = "Called when a ammotype was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onEntityGroupRemoved",
    description = "Called when an entity group was removed.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onAgendaRemoved",
    description = "Called when an agenda was removed.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onDemoteGroupRemoved",
    description = "Called when a job was demotegroup.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "loadCustomDarkRPItems",
    description = "Runs right after the scripts from the DarkRPMod are run. You can add custom jobs, entities, shipments and whatever in this hook.",
    parameters = {
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "postLoadCustomDarkRPItems",
    description = "Runs right after loadCustomDarkRPItems. All custom DarkRP content will be loaded by this time.",
    parameters = {
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "DarkRPStartedLoading",
    description = "Runs at the very start of loading DarkRP. Not even sandbox has loaded here yet.",
    parameters = {
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "DarkRPFinishedLoading",
    description = "Runs right after DarkRP itself has loaded. All DarkRPMod stuff (except for disabled_defaults) is loaded during this hook. NOTE! NO CUSTOM STUFF WILL BE AVAILABLE DURING THIS HOOK. USE `loadCustomDarkRPItems` INSTEAD IF YOU WANT THAT!",
    parameters = {
    },
    returns = {
    }
}

--PATH gamemodes/mangarp/gamemode/modules/voting/sh_chatcommands.lua:
DarkRP.declareChatCommand{
    command = "forcecancelvote",
    description = "Forcefully cancel a vote.",
    delay = 0.5
}

--PATH gamemodes/mangarp/gamemode/modules/fpp/pp/client/menu.lua:
local AdminPanel
local EditGroupTools
local RetrieveRestrictedTool
local RetrieveBlockedModels
local BlockedLists = {}
local CatsOpened = {}
local ShowBlockedModels
FPP = FPP or {}

FPP.Groups = {}
FPP.GroupMembers = {}

net.Receive("FPP_Settings_Update", function()
    local skipK, skipS, value = net.ReadUInt(8), net.ReadUInt(8), net.ReadDouble()
    local K, S = 0, 0

    FPP.ForAllSettings(function(k, s)
        K = K + 1
        if K ~= skipK then return true end
        K, S = K - 1, S + 1
        if S ~= skipS then return end

        FPP.Settings[k][s] = value
    end)
end)

net.Receive("FPP_Settings", function()
    FPP.ForAllSettings(function(k, s, v)
        FPP.Settings[k][s] = net.ReadDouble()
    end)
end)

local canEditSettings = false
local canCleanup = false

local function updatePrivs()
    CAMI.PlayerHasAccess(LocalPlayer(), "FPP_Settings", function(b, _)
        canEditSettings = b
    end)

    CAMI.PlayerHasAccess(LocalPlayer(), "FPP_Cleanup", function(b, _)
        canCleanup = b
    end)
end
hook.Add("InitPostEntity", "FPP_Menu", updatePrivs)

local function nickSortedPlayers()
    local plys = player.GetAll()
    table.sort(plys, function(a,b) return a:Nick() < b:Nick() end)
    return plys
end

function FPP.AdminMenu(Panel)
    updatePrivs()
    AdminPanel = Panel
    AdminPanel:SetSize(100, 400)
    AdminPanel:Clear(true)

    AdminPanel.contents = AdminPanel.contents or vgui.Create("DListLayout")
    AdminPanel.contents:Clear()

    if not canEditSettings then
        AdminPanel.contents:Add(Label("You are not a superadmin\nThe changes you make will not have any effect."))
        local AmAdmin = AdminPanel.contents:Add("DButton")
        AmAdmin:SetText("Unlock buttons anyway")
        AmAdmin:SetTooltip("If you're REALLY not an admin it won't work")

        function AmAdmin:DoClick()
            AmAdmin:SetText("Buttons unlocked")
            AmAdmin:SetTooltip("The changes you make now DO have effect unless you're really not an admin")
            canEditSettings = true
        end
    end

    local function MakeOption(Name)
        local cat = AdminPanel.contents:Add("DCollapsibleCategory")
        cat:SetLabel(Name)
        cat:SetExpanded(CatsOpened[Name])
        cat.oldtoggle = cat.Toggle
        function cat:Toggle()
            self:oldtoggle()
            CatsOpened[Name] = cat:GetExpanded()
            AdminPanel:Toggle()
            timer.Simple(0, function() AdminPanel:Toggle() end)
        end

        local pan = vgui.Create("DListLayout")
        cat:SetContents(pan)
        return cat, pan
    end

    local function addchk(label, command, plist)
        local box = plist:Add("DCheckBoxLabel")
        box:SetText(label)
        box:SetDark(true)
        box:SetValue(tobool(FPP.Settings[command[1]][command[2]]))
        box.Button.Toggle = function()
            if not canEditSettings then return end--Hehe now you can't click it anymore non-admin!
            if box.Button:GetChecked() == nil or not box.Button:GetChecked() then
                box.Button:SetValue( true )
            else
                box.Button:SetValue( false )
            end
            local tonum = {}
            tonum[false] = "0"
            tonum[true] = "1"
            RunConsoleCommand("FPP_Setting", command[1], command[2], tonum[box.Button:GetChecked()])
        end
    end

    local function addblock(pan, Type)
        local label = pan:Add("DLabel")
        label:SetText("\n" .. Type .. " black/whitelist entities:")
        label:SetTextColor(Color(0, 0, 0, 255))
        label:SizeToContents()

        local lview = pan:Add("DListView")
        lview:AddColumn("Entity")

        BlockedLists[string.lower(Type)] = lview
        RunConsoleCommand("FPP_sendblocked", Type)

        local RemoveSelected = pan:Add("DButton")
        RemoveSelected:SetText("Remove Selected items from the list")
        RemoveSelected:SetDisabled(not canEditSettings)
        RemoveSelected.DoClick = function()
            for k, v in pairs(lview.Lines) do
                if v:IsLineSelected() then
                    local text = v.text
                    timer.Simple(k / 10, function() RunConsoleCommand("FPP_RemoveBlocked", Type, text) end)
                    lview:RemoveLine(k)
                    lview:SetTall(17 + #lview:GetLines() * 17)
                    pan:InvalidateLayout()
                    pan:GetParent():GetParent():InvalidateLayout()
                end
            end
        end

        local AddLA = pan:Add("DButton")
        AddLA:SetText("Add the entity you're looking at")
        AddLA:SetDisabled(not canEditSettings)
        AddLA.DoClick = function()
            local ent = LocalPlayer():GetEyeTraceNoCursor().Entity
            if not IsValid(ent) then return end
            for _, v in pairs(lview.Lines) do
                if v.text == string.lower(ent:GetClass()) then return end
            end
            RunConsoleCommand("FPP_AddBlocked", Type, ent:GetClass())

            lview:AddLine(ent:GetClass()).text = ent:GetClass()
            lview:SetTall(17 + #lview:GetLines() * 17)
            pan:InvalidateLayout()
            pan:GetParent():GetParent():InvalidateLayout()
        end

        local AddManual = pan:Add("DButton")
        AddManual:SetText("Add entity manually")
        AddManual:SetDisabled(not canEditSettings)
        AddManual.DoClick = function()
            Derma_StringRequest("Enter entity manually", "Enter the classname of the entity you would like to add.", nil,
            function(a)
            RunConsoleCommand("FPP_AddBlocked", Type, a)
            end, function() end )
        end
    end

    local function addsldr(max, command, text, plist, decimals)
        local label = plist:Add("DLabel")
        label:SetText(text)
        label:SetTextColor(Color(0, 0, 0, 255))
        label:SizeToContents()

        local sldr = plist:Add("DNumSlider")
        sldr.Label:SetVisible(false)
        sldr:SetMinMax(0, max)
        decimals = decimals or 1
        sldr:SetDecimals(decimals)
        sldr:SetDark(true)
        sldr:SetValue(FPP.Settings[command[1]][command[2]])
        function sldr.Slider:OnMouseReleased()
            self:SetDragging(false)
            self:MouseCapture(false)
            if not canEditSettings then
                sldr:SetValue(FPP.Settings[command[1]][command[2]])
                return
            end
            RunConsoleCommand("FPP_Setting", command[1], command[2], sldr:GetValue())
        end

        function sldr.TextArea:OnEnter()
            if not canEditSettings then
                sldr:SetValue(FPP.Settings[command[1]][command[2]])
                return
            end
            RunConsoleCommand("FPP_Setting", command[1], command[2], sldr:GetValue())
        end

        local KnobMouseReleased = sldr.Slider.Knob.OnMouseReleased
        function sldr.Slider.Knob:OnMouseReleased(...)
            KnobMouseReleased(self, ...)
            sldr.Slider:OnMouseReleased()
        end
    end

    local _, general = MakeOption("General options")
    addchk("Freeze disconnected players's entities", {"FPP_GLOBALSETTINGS1", "freezedisconnected"}, general)
    addchk("Cleanup disconnected players's entities", {"FPP_GLOBALSETTINGS1", "cleanupdisconnected"}, general)
    addchk("Cleanup admin's entities on disconnect", {"FPP_GLOBALSETTINGS1", "cleanupadmin"}, general)
    addsldr(600, {"FPP_GLOBALSETTINGS1", "cleanupdisconnectedtime"}, "Deletion time", general, 0)
    addchk("Anti E2 mingery (mass killing with E2)", {"FPP_GLOBALSETTINGS1", "antie2minge"}, general)

    local delnow = general:Add("DButton")
    delnow:SetText("Delete disconnected players' entities")
    delnow:SetConsoleCommand("FPP_cleanup", "disconnected")
    delnow:SetDisabled(not canCleanup)

    local other = general:Add(Label("\nDelete player's entities:"))
    other:SizeToContents()
    other:SetTextColor(Color(0, 0, 0, 255))

    local areplayers = false
    for _, v in ipairs(nickSortedPlayers()) do
        if not IsValid(v) then continue end
        areplayers = true
        local rm = general:Add("DButton")
        rm:SetText(v:Nick())
        rm:SetConsoleCommand("FPP_Cleanup", v:UserID())
        rm:SetDisabled(not canCleanup)
    end
    if not areplayers then
        local nope = general:Add(Label("<No players available>"))
        nope:SizeToContents()
    end

    local _, antispam = MakeOption("Antispam options")
    addchk("Spam protection enabled on/off", {"FPP_ANTISPAM1", "toggle"}, antispam)
    addchk("Prevent spawning a prop in a prop", {"FPP_ANTISPAM1", "antispawninprop"}, antispam)
    addchk("Big prop spam protection", {"FPP_ANTISPAM1", "bigpropantispam"}, antispam)
    addsldr(10, {"FPP_ANTISPAM1", "bigpropwait"}, "Time (seconds) between spawning two big props", antispam)
    addsldr(10, {"FPP_ANTISPAM1", "smallpropdowngradecount"}, "Spawn delay (in fraction) to consider spam", antispam)
    addsldr(10, {"FPP_ANTISPAM1", "smallpropghostlimit"}, "How many props to spam before ghosting", antispam)
    addsldr(20, {"FPP_ANTISPAM1", "smallpropdenylimit"}, "How many props to spam before blocking", antispam)
    addsldr(10, {"FPP_ANTISPAM1", "duplicatorlimit"}, "How many duplications to spam before blocking", antispam)

    local _, physgun = MakeOption("Physgun options")
    addchk("Physgun protection enabled", {"FPP_PHYSGUN1", "toggle"}, physgun)
    addchk("Privileged users can physgun all entities", {"FPP_PHYSGUN1", "adminall"}, physgun)
    addchk("People can physgun world entities", {"FPP_PHYSGUN1", "worldprops"}, physgun)
    addchk("Admins can physgun world entities", {"FPP_PHYSGUN1", "adminworldprops"}, physgun)
    addchk("People can physgun blocked entities", {"FPP_PHYSGUN1", "canblocked"}, physgun)
    addchk("Admins can physgun blocked entities", {"FPP_PHYSGUN1", "admincanblocked"}, physgun)
    addchk("Physgun reload protection enabled", {"FPP_PHYSGUN1", "reloadprotection"}, physgun)
    addchk("The blocked list is a white list", {"FPP_PHYSGUN1", "iswhitelist"}, physgun)
    addblock(physgun, "Physgun1")

    local _, gravgun = MakeOption("Gravity gun options")
    addchk("Gravity gun protection enabled", {"FPP_GRAVGUN1", "toggle"}, gravgun)
    addchk("Privileged users can gravgun all entities", {"FPP_GRAVGUN1", "adminall"}, gravgun)
    addchk("People can gravgun world entities", {"FPP_GRAVGUN1", "worldprops"}, gravgun)
    addchk("Admins can gravgun world entities", {"FPP_GRAVGUN1", "adminworldprops"}, gravgun)
    addchk("People can gravgun blocked entities", {"FPP_GRAVGUN1", "canblocked"}, gravgun)
    addchk("Admins can gravgun blocked entities", {"FPP_GRAVGUN1", "admincanblocked"}, gravgun)
    addchk("People can't punt props", {"FPP_GRAVGUN1", "noshooting"}, gravgun)
    addchk("The blocked list is a white list", {"FPP_GRAVGUN1", "iswhitelist"}, gravgun)
    addblock(gravgun, "Gravgun1")

    local _, toolgun = MakeOption("Toolgun options")
    addchk("Toolgun protection enabled", {"FPP_TOOLGUN1", "toggle"}, toolgun)
    addchk("Admins can use tool all entities", {"FPP_TOOLGUN1", "adminall"}, toolgun)
    addchk("People can use tool on world entities", {"FPP_TOOLGUN1", "worldprops"}, toolgun)
    addchk("Admins can use tool on world entities", {"FPP_TOOLGUN1", "adminworldprops"}, toolgun)
    addchk("People can use tool on blocked entities", {"FPP_TOOLGUN1", "canblocked"}, toolgun)
    addchk("Admins can use tool on blocked entities", {"FPP_TOOLGUN1", "admincanblocked"}, toolgun)
    addchk("The blocked list is a white list", {"FPP_TOOLGUN1", "iswhitelist"}, toolgun)
    addblock(toolgun, "Toolgun1")

    addchk("Duplicator restriction (blocked list)", {"FPP_TOOLGUN1", "duplicatorprotect"}, toolgun)
    addchk("People can't duplicate weapons", {"FPP_TOOLGUN1", "duplicatenoweapons"}, toolgun)
    addchk("Duplicator blocked list is a white list", {"FPP_TOOLGUN1", "spawniswhitelist"}, toolgun)
    addchk("Admins can spawn blocked weapons", {"FPP_TOOLGUN1", "spawnadmincanweapon"}, toolgun)
    addchk("Admins can spawn blocked entities", {"FPP_TOOLGUN1", "spawnadmincanblocked"}, toolgun)
    addblock(toolgun, "Spawning1")

    local _, playeruse = MakeOption("Player use options")
    addchk("Use protection enabled", {"FPP_PLAYERUSE1", "toggle"}, playeruse)
    addchk("Privileged users can use all entities", {"FPP_PLAYERUSE1", "adminall"}, playeruse)
    addchk("People can use world entities", {"FPP_PLAYERUSE1", "worldprops"}, playeruse)
    addchk("Admins can use world entities", {"FPP_PLAYERUSE1", "adminworldprops"}, playeruse)
    addchk("People can use blocked entities", {"FPP_PLAYERUSE1", "canblocked"}, playeruse)
    addchk("Admins can use blocked entities", {"FPP_PLAYERUSE1", "admincanblocked"}, playeruse)
    addchk("The blocked list is a white list", {"FPP_PLAYERUSE1", "iswhitelist"}, playeruse)
    addblock(playeruse, "PlayerUse1")

    local _, damage = MakeOption("Entity damage options")
    local antiDMGLabel = Label("Prevents players from damaging other players' props")
    antiDMGLabel:SetTextColor(Color(0, 0, 0, 255))
    damage:Add(antiDMGLabel)

    addchk("Damage protection enabled", {"FPP_ENTITYDAMAGE1", "toggle"}, damage)
    addchk("Protect against damage by props", {"FPP_ENTITYDAMAGE1", "protectpropdamage"}, damage)
    addchk("Privileged users can damage all entities", {"FPP_ENTITYDAMAGE1", "adminall"}, damage)
    addchk("People can damage world entities", {"FPP_ENTITYDAMAGE1", "worldprops"}, damage)
    addchk("Admins can damage world entities", {"FPP_ENTITYDAMAGE1", "adminworldprops"}, damage)
    addchk("People can damage blocked entities", {"FPP_ENTITYDAMAGE1", "canblocked"}, damage)
    addchk("Admins can damage blocked entities", {"FPP_ENTITYDAMAGE1", "admincanblocked"}, damage)
    addchk("The blocked list is a white list", {"FPP_ENTITYDAMAGE1", "iswhitelist"}, damage)
    addblock(damage, "EntityDamage1")

    local _, blockedmodels = MakeOption("Blocked models options")
    local BlockedModelsLabel = blockedmodels:Add("DLabel")
    BlockedModelsLabel:SetText("\nTo add a model in the blocked models list:\nOpen the spawn menu, right click a prop and\nadd it to the blocked list")
    BlockedModelsLabel:SetTextColor(Color(0, 0, 0, 255))
    BlockedModelsLabel:SizeToContents()

    addchk("Blocked models enabled", {"FPP_BLOCKMODELSETTINGS1", "toggle"}, blockedmodels)
    addchk("Apply to props only", {"FPP_BLOCKMODELSETTINGS1", "propsonly"}, blockedmodels)
    addchk("The blocked models list is a white list", {"FPP_BLOCKMODELSETTINGS1", "iswhitelist"}, blockedmodels)

    local BlockedModelsAddLA = blockedmodels:Add("DButton")
    BlockedModelsAddLA:SetText("Add model of entity you're looking at")
    function BlockedModelsAddLA:DoClick()
        if not IsValid(LocalPlayer():GetEyeTraceNoCursor().Entity) then return end
        RunConsoleCommand("FPP_AddBlockedModel", LocalPlayer():GetEyeTraceNoCursor().Entity:GetModel(), LocalPlayer():GetEyeTraceNoCursor().Entity:EntIndex())
    end

    local BlockedModelsList = blockedmodels:Add("DButton")
    BlockedModelsList:SetText("Show blocked models")
    BlockedModelsList:SetTooltip("If there are no models in the list THIS BUTTON WON'T DO ANYTHING")
    function BlockedModelsList:DoClick()
        RunConsoleCommand("FPP_sendblockedmodels")

        local frame = vgui.Create("DFrame")
        frame:MakePopup()
        frame:SetVisible(true)
        frame:SetSize(math.Min(1280, ScrW() - 100), math.Min(720, ScrH() - 100))
        frame:Center()
        frame:SetTitle(((tobool(FPP.Settings.FPP_BLOCKMODELSETTINGS1.iswhitelist) and "Allowed") or "Blocked") .. " models list")
        function frame:Close()
            ShowBlockedModels = nil
            self:Remove()
        end

        local Explanation = vgui.Create("DLabel", frame)
        Explanation:SetPos(5, 25)
        Explanation:SetText([[This is the list of props that are currently in the Blocked/Allowed props list.
        If this is a whitelist (set in settings), only the entities with the models in this list can be spawned
        If it's a blacklist, people will be able to spawn any model except for the ones in this list.

        To remove a model from the list, click the model in this list and click remove.
        To add a model to this list:
                - open your spawn menu (Q by default)
                - find the model in the props list
                - right click it
                - click "Add to blocked models"]])
        Explanation:SizeToContents()

        frame.pan = vgui.Create("DPanelList", frame)
        frame.pan:SetPos(5, 160)
        frame.pan:SetSize(frame:GetWide() - 10, frame:GetTall() - 165)
        frame.pan:EnableHorizontal(true)
        frame.pan:EnableVerticalScrollbar(true)
        frame.pan:SetSpacing(0)
        frame.pan:SetPadding(4)
        frame.pan:SetAutoSize(false)
        ShowBlockedModels = frame
    end

    local _, ToolRestrict = MakeOption("Tool restriction") --spawnmenu.GetTools()

    FPP.DtreeToolRestrict = ToolRestrict:Add(IsValid(FPP.DtreeToolRestrict) and FPP.DtreeToolRestrict or "DTree")
    FPP.multirestricttoollist = ToolRestrict:Add(IsValid(FPP.multirestricttoollist) and FPP.multirestricttoollist or "DListView")
    FPP.DtreeToolRestrict:SetVisible(true)
    FPP.DtreeToolRestrict:SetSize(0, 300)

    FPP.SELECTEDRESTRICTNODE = FPP.SELECTEDRESTRICTNODE or "weld"

    if not FPP.DtreeToolRestrict.Items then
        local nodeClick = function(self)
            FPP.SELECTEDRESTRICTNODE = self.Tool

            for k, v in pairs(weapons.Get("gmod_tool").Tool) do
                if not v.Mode or v.Mode ~= FPP.SELECTEDRESTRICTNODE then continue end
                --Add to DListView
                for a, b in pairs(FPP.multirestricttoollist:GetLines()) do
                    if b.Columns[1].Value == k then
                        return
                    end
                end
                FPP.multirestricttoollist:AddLine(k)
                return
            end
        end
        FPP.DtreeToolRestrict.Items = true
        for a, b in pairs(spawnmenu.GetTools()) do
            for c, d in pairs(spawnmenu.GetTools()[a].Items) do
                local addnodes = {}
                for _, f in pairs(spawnmenu.GetTools()[a].Items[c]) do
                    if istable(f) and string.find(f.Command or "", "gmod_tool") then
                        table.insert(addnodes, {f.Text, f.ItemName})
                    end
                end
                if #addnodes == 0 then continue end

                local node1 = FPP.DtreeToolRestrict:AddNode(d.ItemName)
                for _, f in pairs(addnodes) do
                    local node2 = node1:AddNode(f[1])
                    node2.Icon:SetImage("gui/silkicons/wrench")
                    node2.Tool = f[2]
                    node2.DoClick = nodeClick
                end
            end
        end
    end

    local SingleEditTool = ToolRestrict:Add("DButton")
    SingleEditTool:SetText("Edit/view selected tool restrictions")
    SingleEditTool:SetTooltip("Edit or view the restrictions of the selected tool!")
    SingleEditTool.DoClick = function()
        for k, v in pairs(weapons.Get("gmod_tool").Tool) do
            if v.Mode and v.Mode == FPP.SELECTEDRESTRICTNODE then
                RunConsoleCommand("FPP_SendRestrictTool", k)
                return
            end
        end
        SingleEditTool:SetText("No tool selected!")

        timer.Simple(1, function()
            if IsValid(SingleEditTool) then
                SingleEditTool:SetText("Edit/view selected tool's restrictions")
            end
        end)
    end

    local multiToolEditLabel = Label("\nMultiple tool editor.\nAdd tools in this list by clicking on them,\nthen click \"Edit multiple tools\"\nto edit multiple tools at once!")
    multiToolEditLabel:SetTextColor(Color(0, 0, 0, 255))
    local EditToolListLabel = ToolRestrict:Add(multiToolEditLabel)
    EditToolListLabel:SizeToContents()

    if #FPP.multirestricttoollist.Columns ~= 1 then
        FPP.multirestricttoollist:AddColumn("Tool names")
    end

    FPP.multirestricttoollist:SetTall(150)
    function FPP.multirestricttoollist:OnClickLine(line)
        line:SetSelected(true)
        FPP.multirestricttoollist:RemoveLine(FPP.multirestricttoollist:GetSelectedLine())
    end

    local StartEditMultiTool = ToolRestrict:Add("DButton")
    StartEditMultiTool:SetText("Edit multiple tools")
    StartEditMultiTool:SetTooltip("Start editing the tools in above list!")
    StartEditMultiTool:SetDisabled(not canEditSettings)
    StartEditMultiTool.DoClick = function()
        local lines = FPP.multirestricttoollist:GetLines()
        local EditTable = {}
        if #lines > 0 then
            for _, v in ipairs(lines) do
                table.insert(EditTable, v.Columns[1].Value)
            end
            RetrieveRestrictedTool(EditTable)

            return
        end

        StartEditMultiTool:SetText("List is empty!")


        timer.Simple(1, function()
            if IsValid(StartEditMultiTool) then
                StartEditMultiTool:SetText("Edit multiple tools")
            end
        end)
    end

    local _, GroupRestrict = MakeOption("Group tool restriction")

    local pressLoadFirstLabel = Label("Press \"Load groups and members\" first!")
    pressLoadFirstLabel:SetTextColor(Color(0, 0, 0, 255))
    local PressLoadFirst = GroupRestrict:Add(pressLoadFirstLabel)
    local  membersLabel = Label("Group Members: NOTE: People who have the\nusergroup that matches with this group\nare automatically in this group!")
    membersLabel:SizeToContents()
    membersLabel:SetTextColor(Color(0, 0, 0, 255))
    GroupRestrict:Add(membersLabel)

    local LoadGroups = GroupRestrict:Add("DButton")
    LoadGroups:SetText("Load groups and members")
    LoadGroups.DoClick = function()
        RunConsoleCommand("FPP_SendGroups")
        RunConsoleCommand("FPP_SendGroupMembers")
        PressLoadFirst:SetText("Groups loaded!")
    end

    local ChkAllowDefault
    local GroupList = GroupRestrict:Add("DListView")
    GroupList:AddColumn("Group names")
    GroupList:SetSize(0, 100)
    function GroupList:OnClickLine(line)
        self:ClearSelection()
        line:SetSelected(true)
        ChkAllowDefault:SetValue(FPP.Groups[GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue()].allowdefault)
    end

    ChkAllowDefault = GroupRestrict:Add("DCheckBoxLabel")
    ChkAllowDefault:SetText("Allow all tools by default")
    ChkAllowDefault:SetDark(true)
    ChkAllowDefault:SetTooltip([[Ticked: All tools are allowed, EXCEPT for the tools in the tool list
    Unticked: NO tools will be allowed, EXCEPT for the tools in the tool list]])
    if GroupList:GetSelectedLine() and FPP.Groups[GroupList:GetSelectedLine().Columns[1]:GetValue()] then
        ChkAllowDefault:SetValue(FPP.Groups[GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue()].allowdefault)
    end
    ChkAllowDefault.Button.Toggle = function()
        local line = GroupList:GetSelectedLine()
        if not line then return end
        local value = 0
        if not ChkAllowDefault.Button:GetChecked() then value = 1 end
        local lineObj = GroupList:GetLine(line)
        RunConsoleCommand("FPP_ChangeGroupStatus", lineObj.Columns[1]:GetValue(), value)
        ChkAllowDefault.Button:SetValue(not ChkAllowDefault.Button:GetChecked())
    end

    local AddGroupBtn = GroupRestrict:Add("DButton")
    AddGroupBtn:SetText("Add a group")
    AddGroupBtn.DoClick = function()
        Derma_StringRequest("Name of the group", "What will be the name of the group?\nNOTE: YOU WILL NOT BE ABLE TO CHANGE THIS AFTERWARDS", "", function(text)
            RunConsoleCommand("FPP_AddGroup", text)
        end)
    end

    local RemGroupBtn = GroupRestrict:Add("DButton")
    RemGroupBtn:SetText("Remove selected group")
    RemGroupBtn.DoClick = function()
        if not GroupList:GetLine(GroupList:GetSelectedLine()) or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns
        or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue() then
            LocalPlayer():ChatPrint("No item selected!")
            return
        end
        RunConsoleCommand("FPP_RemoveGroup", GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue())
        GroupList:RemoveLine(GroupList:GetSelectedLine())
        PressLoadFirst:SetText("List might be corrupted, reload is recommended")
    end

    local EditGroupBtn = GroupRestrict:Add("DButton")
    EditGroupBtn:SetText("Edit selected group's tools")
    EditGroupBtn.DoClick = function()
        if not GroupList:GetLine(GroupList:GetSelectedLine()) or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns
        or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue() then
            LocalPlayer():ChatPrint("No item selected!")
            return
        end
        EditGroupTools(GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue())
    end

    local groupMemLabel = Label("Group Members:")
    groupMemLabel:SetTextColor(Color(0, 0, 0, 255))
    GroupRestrict:Add(groupMemLabel)
    local GroupMembers = GroupRestrict:Add("DListView")
    GroupMembers:AddColumn("SteamID")
    GroupMembers:AddColumn("Name")
    GroupMembers:AddColumn("Member of")
    GroupMembers:SetSize(0, 150)

    local AddPerson = GroupRestrict:Add("DButton")
    AddPerson:SetText("Change group of this person to selected")
    AddPerson.DoClick = function()
        if not GroupList:GetLine(GroupList:GetSelectedLine()) or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns
        or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue() then
            LocalPlayer():ChatPrint("No item selected!")
            return
        end

        for k, v in pairs(GroupMembers:GetSelected()) do
            timer.Simple(k / 10, function() RunConsoleCommand("FPP_SetPlayerGroup", v.Columns[1]:GetValue(), GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue()) end)
        end
    end

    local AddPersonManual = GroupRestrict:Add("DButton")
    AddPersonManual:SetText("Add person/SteamID to selected group")
    AddPersonManual.DoClick = function()
        if not GroupList:GetLine(GroupList:GetSelectedLine()) or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns
        or not GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue() then
            LocalPlayer():ChatPrint("No item selected!")
            return
        end

        local menu = DermaMenu()
        menu:SetPos(gui.MouseX(), gui.MouseY())

        for _, b in ipairs(player.GetAll()) do
            if not IsValid(b) then continue end
            menu:AddOption(b:Nick(), function()
                RunConsoleCommand("FPP_SetPlayerGroup", b:UserID(), GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue())
                PressLoadFirst:SetText("List might be corrupted, reload is recommended")
            end)
        end

        menu:AddOption("other...", function()
            Derma_StringRequest("Enter steam ID", "Enter the Steam ID of the person you would like to add to this group.", "", function(text)
                RunConsoleCommand("FPP_SetPlayerGroup", text, GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue())
            end)
        end)
        menu:Open()
    end

    local function RetrieveGroups(len)
        FPP.Groups = net.ReadTable()
        GroupList:Clear()
        for k, _ in pairs(FPP.Groups) do
            GroupList:AddLine(k)
        end
        GroupList:SelectFirstItem()
        if #FPP.Groups == 0 then return end
        ChkAllowDefault:SetValue(FPP.Groups[GroupList:GetLine(GroupList:GetSelectedLine()).Columns[1]:GetValue()].allowdefault)
    end
    net.Receive("FPP_Groups", RetrieveGroups)

    local function RetrieveGroupMembers(len)
        FPP.GroupMembers = net.ReadTable()
        GroupMembers:Clear()
        for k, v in pairs(FPP.GroupMembers) do
            local name = "Unknown"
            for _, ply in ipairs(player.GetAll()) do
                if ply:SteamID() == k then
                    name = ply:Nick()
                    break
                end
            end
            GroupMembers:AddLine(k, name, v)
        end
        GroupMembers:SelectFirstItem()
    end
    net.Receive("FPP_GroupMembers", RetrieveGroupMembers)

    local lbl = Label("\nFalco's Prop Protection\nMade by Falco A.K.A. FPtje")
    lbl:SizeToContents()
    lbl:SetTextColor(Color(0, 0, 0, 255))
    AdminPanel.contents:Add(lbl)
    AdminPanel:SetContents(AdminPanel.contents)
    AdminPanel:Dock(FILL)
end

RetrieveBlockedModels = function(len)
    if not ShowBlockedModels then return end
    local data = net.ReadData(len)

    local models = string.Explode('\0', util.Decompress(data))

    for _, model in pairs(models) do
        local Icon = vgui.Create("SpawnIcon", ShowBlockedModels.pan)
        Icon:SetModel(model, 1)
        Icon:SetSize(64, 64)
        Icon.DoClick = function()
            local menu = DermaMenu()
            menu:AddOption("Remove from FPP blocked models list", function() -- I use a DMenu so people don't accidentally click the wrong icon and go FFFUUU
                RunConsoleCommand("FPP_RemoveBlockedModel", model)
                Icon:Remove()
                ShowBlockedModels.pan:InvalidateLayout()
            end)
            menu:Open()
        end
        ShowBlockedModels.pan:AddItem(Icon)
    end
end
net.Receive("FPP_BlockedModels", RetrieveBlockedModels)

RetrieveRestrictedTool = function(um)
    local tool, admin, Teams = um, 0, {}--Settings when it's not a usermessage
    if not istable(um) then
        tool = net.ReadString()
        admin = net.ReadUInt(2)
        local teamCount = net.ReadUInt(10)

        for i = 1, teamCount do
            Teams[net.ReadUInt(10)] = true
        end
    end

    local frame = vgui.Create("DFrame")
    if istable(tool) then
        frame:SetTitle("Edit multiple tools' restrictions")
    else
        frame:SetTitle("Edit/view " .. tool .. " restrictions")
    end
    frame:MakePopup()
    frame:SetVisible( true )
    frame:SetSize(250, 400)
    frame:Center()

    local pan = vgui.Create("DPanelList", frame)
    pan:SetPos(10, 30)
    pan:SetSize(230, 1)
    pan:SetSpacing(5)
    pan:EnableHorizontal(false)
    pan:EnableVerticalScrollbar(true)
    pan:SetAutoSize(true)

    local adminsCHKboxes = {}

    adminsCHKboxes[1] = vgui.Create("DCheckBoxLabel")
    adminsCHKboxes[1]:SetText("for everyone")
    adminsCHKboxes[1].GoodValue = 0
    if admin == 0 then
        adminsCHKboxes[1].Button:SetValue(1)
    end
    pan:AddItem(adminsCHKboxes[1])

    adminsCHKboxes[2] = vgui.Create("DCheckBoxLabel")
    adminsCHKboxes[2]:SetText("Admin only")
    adminsCHKboxes[2].GoodValue = 1
    if admin == 1 then
        adminsCHKboxes[2].Button:SetValue(1)
    end
    pan:AddItem(adminsCHKboxes[2])

    adminsCHKboxes[3] = vgui.Create("DCheckBoxLabel")
    adminsCHKboxes[3]:SetText("Superadmin only")
    adminsCHKboxes[3].GoodValue = 2
    if admin == 2 then
        adminsCHKboxes[3].Button:SetValue(1)
    end
    pan:AddItem(adminsCHKboxes[3])

    for k in pairs(adminsCHKboxes) do
        adminsCHKboxes[k].Button.Toggle = function()
            if adminsCHKboxes[k].Button:GetChecked() then
                return false -- You can't turn a checkbox off
            end
            for a in pairs(adminsCHKboxes) do
                adminsCHKboxes[a].Button:SetValue(false)
            end
            adminsCHKboxes[k].Button:SetValue(true)
            if not istable(tool) then
                RunConsoleCommand("FPP_restricttool", tool, "admin", adminsCHKboxes[k].GoodValue)
            else
                local i = 0
                for _, b in pairs(tool) do
                    i = i + 1
                    timer.Simple(i / 10, function() -- Timer to prevent lag of executing multiple commands at the same time.
                        RunConsoleCommand("FPP_restricttool", b, "admin", adminsCHKboxes[k].GoodValue)
                    end)
                end
            end
        end
    end

    local RestrictPlayerButton = vgui.Create("DButton", frame)
    RestrictPlayerButton:SetPos(10, #adminsCHKboxes * 20 + 35)
    RestrictPlayerButton:SetSize(230, 20)
    RestrictPlayerButton:SetText("Restrict per player")
    RestrictPlayerButton:SetTooltip[[Default: reset their privileges and let them use this/these tool(s) like anyone else
    Allow: Allow them to use this tool no matter what team/admin access the tool is restricted to
    Disallow: Disallow them to use this tool no matter what team/admin access the tool is restricted to]]

    RestrictPlayerButton.DoClick = function(self)
        local menu = DermaMenu(self)
        menu:SetPos(gui.MouseX(), gui.MouseY())

        for _, v in ipairs(player.GetAll()) do
            if not IsValid(v) then continue end
            local submenu = menu:AddSubMenu(v:Nick())


            submenu:AddOption( "Default", function()
                if not istable(tool) then
                    RunConsoleCommand("FPP_restricttoolplayer", tool, v:UserID(), 2)
                    return
                end
                for a, b in pairs(tool) do
                    timer.Simple(a / 10, function()
                        RunConsoleCommand("FPP_restricttoolplayer", b, v:UserID(), 2)
                    end)
                end
            end)


            submenu:AddOption( "Allow", function()
                if not istable(tool) then
                    RunConsoleCommand("FPP_restricttoolplayer", tool, v:UserID(), 1)
                    return
                end
                for a, b in pairs(tool) do
                    timer.Simple(a / 10, function()
                        RunConsoleCommand("FPP_restricttoolplayer", b, v:UserID(), 1)
                    end)
                end
            end)


            submenu:AddOption( "Disallow", function()
                if not istable(tool) then
                    RunConsoleCommand("FPP_restricttoolplayer", tool, v:UserID(), 0)
                end
                for a, b in pairs(tool) do
                    timer.Simple(a / 10, function()
                        RunConsoleCommand("FPP_restricttoolplayer", b, v:UserID(), 0)
                    end)
                end
            end)
        end
        menu:Open()
    end

    local Tpan = vgui.Create("DPanelList", frame)
    local count = #adminsCHKboxes
    Tpan:SetPos(10, count * 20 + 65)
    Tpan:SetSize(230, 325 - count * 20)
    Tpan:SetSpacing(5)
    Tpan:EnableHorizontal(false)
    Tpan:EnableVerticalScrollbar(true)

    for k, v in pairs(team.GetAllTeams()) do
        local chkbx = vgui.Create("DCheckBoxLabel")
        chkbx:SetText(v.Name)
        chkbx:SetDark(true)
        chkbx.Team = k
        chkbx.Button:SetValue(Teams[k])

        chkbx.Button.Toggle = function()
            if chkbx.Button:GetChecked() == nil or not chkbx.Button:GetChecked() then
                chkbx.Button:SetValue(true)
            else
                chkbx.Button:SetValue(false)
            end

            local tonum = {}
            tonum[false] = "0"
            tonum[true] = "1"
            if not istable(tool) then
                RunConsoleCommand("FPP_restricttool", tool, "team", chkbx.Team, tonum[chkbx.Button:GetChecked()] )
            else
                for a, b in pairs(tool) do
                    timer.Simple(a / 10, function()
                        RunConsoleCommand("FPP_restricttool", b, "team", chkbx.Team, tonum[chkbx.Button:GetChecked()])
                    end)
                end
            end
        end

        Tpan:AddItem(chkbx)
    end

end
net.Receive("FPP_RestrictedToolList", RetrieveRestrictedTool)

EditGroupTools = function(groupname)
    if not FPP.Groups[groupname] then return end
    local tools = FPP.Groups[groupname].tools
    local frame = vgui.Create("DFrame")
    frame:SetTitle("Edit tools of " .. groupname)
    frame:MakePopup()
    frame:SetVisible( true )
    frame:SetSize(640, 480)
    frame:Center()

    local GroupTools = vgui.Create("DListView", frame)
    GroupTools:SetPos(340, 25)
    GroupTools:SetSize(295, 450)
    GroupTools:AddColumn("Tools currently in " .. groupname)

    for _, v in pairs(tools or {}) do
        GroupTools:AddLine(v)
    end

    local SelectTool = Label("Select a tool or a folder", frame)
    SelectTool:SetPos(5, 25)
    SelectTool:SizeToContents()

    local ToolList = vgui.Create("DTree", frame)
    ToolList:SetPos(5, 45)
    ToolList:SetSize(300, 430)

    for a in pairs(spawnmenu.GetTools()) do
        for c,d in pairs(spawnmenu.GetTools()[a].Items) do
            local addnodes = {}
            for g, h in pairs(weapons.Get("gmod_tool").Tool) do
                if h.Category and h.Category == d.ItemName then
                    table.insert(addnodes, {h.Name, g})
                end
            end

            if #addnodes ~= 0 then
                local node1 = ToolList:AddNode(d.ItemName)
                node1.Tool = d.ItemName
                for _, f in pairs(addnodes) do
                    local node2 = node1:AddNode(f[1])
                    node2.Icon:SetImage("icon16/wrench.png")
                    node2.Tool = f[2]
                end
            end
        end
    end

    local AddTool = vgui.Create("DButton", frame)
    AddTool:SetPos(310, 45)
    AddTool:SetSize(25, 25)
    AddTool:SetText(">")
    AddTool.DoClick = function()

        if not ToolList.m_pSelectedItem then return end
        local SelectedTool = string.lower(ToolList.m_pSelectedItem.Tool)

        if not ToolList.m_pSelectedItem.ChildNodes then -- if it's not a folder
            for _, v in pairs(GroupTools:GetLines()) do
                if v.Columns[1]:GetValue() == SelectedTool then
                    return
                end
            end
            RunConsoleCommand("FPP_AddGroupTool", groupname, SelectedTool)
            GroupTools:AddLine(SelectedTool)
        else--if it's a folder:
            for k, v in pairs(ToolList.m_pSelectedItem.ChildNodes:GetChildren()) do
                local found = false
                for _, b in pairs(GroupTools:GetLines()) do
                    if b.Columns[1]:GetValue() == string.lower(v.Tool) then
                        found = true
                        break
                    end
                end
                if not found then
                    GroupTools:AddLine(string.lower(v.Tool))
                    timer.Simple(k / 10, function()
                        RunConsoleCommand("FPP_AddGroupTool", groupname, v.Tool)
                    end)
                end
            end
        end
    end

    local RemTool = vgui.Create("DButton", frame)
    RemTool:SetPos(310, 75)
    RemTool:SetSize(25, 25)
    RemTool:SetText("<")
    RemTool.DoClick = function()
        for k, v in pairs(GroupTools:GetSelected()) do
            local toolname = v.Columns[1]:GetValue()
            timer.Simple(k / 10, function()
                RunConsoleCommand("FPP_RemoveGroupTool", groupname, toolname)
            end)
            GroupTools:RemoveLine(v.m_iID)
        end
    end
end

local function retrieveblocked(um)
    local Type = string.lower(um:ReadString())
    if not BlockedLists[Type] then return end
    local text = um:ReadString()
    local line = BlockedLists[Type]:AddLine(text)
    line.text = text
    BlockedLists[Type]:SetTall(18 + #BlockedLists[Type]:GetLines() * 17)
end
usermessage.Hook("FPP_blockedlist", retrieveblocked)

local BuddiesPanel
function FPP.BuddiesMenu(Panel)
    BuddiesPanel = BuddiesPanel or Panel
    if not IsValid(BuddiesPanel) then return end

    Panel:ClearControls()
    BuddiesPanel:Clear()

    Panel:AddControl("Label", {Text = "\nBuddies menu\nNote: Your buddies are saved and will work in all servers with FPP\nThe buddies list includes players that aren't here\n\nYour buddies:"})
    local BuddiesList = vgui.Create("DListView")
    BuddiesList:AddColumn("Steam ID")
    BuddiesList:AddColumn("Name")
    BuddiesList:SetTall(150)
    BuddiesList:SetMultiSelect(false)
    BuddiesPanel:AddPanel(BuddiesList)
    for k, v in SortedPairsByMemberValue(FPP.Buddies, "name", false) do
        BuddiesList:AddLine(k, v.name)
    end
    BuddiesList:SelectFirstItem()

    local remove = vgui.Create("DButton")
    remove:SetText("Remove selected buddy")
    remove.DoClick = function()
        local line = BuddiesList:GetLine(BuddiesList:GetSelectedLine()) -- Select the only selected line
        if not line then return end
        FPP.SaveBuddy(line.Columns[1]:GetValue(), line.Columns[2]:GetValue(), "remove")
        FPP.BuddiesMenu(BuddiesPanel) -- Restart the entire menu
    end
    BuddiesPanel:AddPanel(remove)

    local edit = vgui.Create("DButton")
    edit:SetText("Edit selected buddy")
    edit.DoClick = function()
        local line = BuddiesList:GetLine(BuddiesList:GetSelectedLine()) -- Select the only selected line
        if not line then return end
        local tmp = FPP.Buddies[line.Columns[1]:GetValue()]
        if not tmp then return end
        local data = {tmp.physgun, tmp.gravgun, tmp.toolgun, tmp.playeruse, tmp.entitydamage}
        FPP.SetBuddyMenu(line.Columns[1]:GetValue(), line.Columns[2]:GetValue(), data)
    end
    BuddiesPanel:AddPanel(edit)

    local AddManual = vgui.Create("DButton")
    AddManual:SetText("Add steamID manually")
    AddManual.DoClick = function()
        Derma_StringRequest("Add buddy manually",
        "Please enter the SteamID of the player you want to add in your buddies list",
        "",
        function(ID)

            Derma_StringRequest("Name of buddy",
            "What is the name of this buddy? (You can enter any name, it will change the next time you meet in a server with FPP)",
            "",
            function(Name)
                FPP.SetBuddyMenu(ID, Name)
            end)
        end)
    end
    BuddiesPanel:AddPanel(AddManual)

    Panel:AddControl("Label", {Text = "\nAdd buddy:"})
    local AvailablePlayers = false
    for _, v in SortedPairs(player.GetAll(), function(a, b) return a:Nick() > b:Nick() end) do
        if not IsValid(v) then continue end
        local cantadd = false
        if v == LocalPlayer() then cantadd = true end
        for a in pairs(FPP.Buddies) do
            if a == v:SteamID() then
                cantadd = true
                break
            end
        end

        if not cantadd then
            local add = vgui.Create("DButton")
            add:SetText(v:Nick())
            add.DoClick = function()
                FPP.SetBuddyMenu(v:SteamID(), v:Nick())
            end
            BuddiesPanel:AddPanel(add)
            AvailablePlayers = true
        end
    end
    if not AvailablePlayers then
        Panel:AddControl("Label", {Text = "<No players available>"})
    end
end

function FPP.SetBuddyMenu(SteamID, Name, data)
    local frame = vgui.Create("DFrame")
    frame:SetTitle(Name)
    frame:MakePopup()
    frame:SetVisible( true )
    frame:SetSize(150, 130)
    frame:Center()

    local count = 1.5
    local function AddChk(name, Type, value)
        local box = vgui.Create("DCheckBoxLabel", frame)
        box:SetText(name .. " buddy")
        box:SetDark(true)

        box:SetPos(10, count * 20)
        count = count + 1
        box:SetValue(tobool(value))
        box.Button.Toggle = function()
            if box.Button:GetChecked() == nil or not box.Button:GetChecked() then
                box.Button:SetValue( true )
            else
                box.Button:SetValue( false )
            end
            local tonum = {}
            tonum[false] = 0
            tonum[true] = 1

            FPP.SaveBuddy(SteamID, Name, Type, tonum[box.Button:GetChecked()])
            FPP.BuddiesMenu(BuddiesPanel) -- Restart the entire menu
        end
        box:SizeToContents()
    end

    data = data or {0,0,0,0,0}
    AddChk("Physgun", "physgun", data[1])
    AddChk("Gravgun", "gravgun", data[2])
    AddChk("Toolgun", "toolgun", data[3])
    AddChk("Use", "playeruse", data[4])
    AddChk("Entity damage", "entitydamage", data[5])
end

local PrivateSettings = {
    ["touch my own entities"] = "OwnProps",
    ["touch world entities"] = "WorldProps",
    ["touch other people's entities"] = "OtherPlayerProps",
    ["touch blocked entities"] = "BlockedProps",
    ["see the owners of props"] = "HideOwner"
}

local privateSettingVars = {}
for _, v in pairs(PrivateSettings) do
    privateSettingVars[v] = CreateClientConVar("FPP_PrivateSettings_" .. v, 0, true, true)
end
CreateClientConVar("cl_pickupplayers", 1, true, true)

function FPP.getPrivateSetting(setting)
    return privateSettingVars[setting]:GetBool()
end

local PrivateSettingsPanel
function FPP.PrivateSettings(Panel)
    PrivateSettingsPanel = PrivateSettingsPanel or Panel

    Panel:ClearControls()
    PrivateSettingsPanel:Clear()

    Panel:AddControl("Label", {Text = "\nPrivate settings menu\nUse to set settings that override server settings\n\nThese settings can only restrict you further.\n"})
    for k, v in pairs(PrivateSettings) do
        local box = vgui.Create("DCheckBoxLabel")
        box:SetText("I don't want to " .. k)
        box:SetValue(GetConVar("FPP_PrivateSettings_" .. v):GetBool())
        box:SetDark(true)

        box.Button.Toggle = function(self)
            RunConsoleCommand("FPP_PrivateSettings_" .. v, self:GetChecked() and "0" or "1")
            self:SetValue(not self:GetChecked())
            RunConsoleCommand("_FPP_RefreshPrivatePlayerSettings")
        end

        box:SizeToContents()
        Panel:AddItem(box)
    end
    Panel:AddControl("CheckBox", {Label = "I want to pick up players", Command = "cl_pickupplayers"})

    local fallbackChoice = Panel:ComboBox("Fallback player")
    fallbackChoice:AddChoice("None", -1, true)

    for _, v in ipairs(player.GetAll()) do
        if v == LocalPlayer() then continue end
        fallbackChoice:AddChoice(v:Nick(), v:UserID(), PrivateSettingsPanel.FallbackSelected == v:UserID())
    end

    fallbackChoice.OnSelect = function(_, _, nick, uid)
        RunConsoleCommand("FPP_FallbackOwner", uid)
        PrivateSettingsPanel.FallbackSelected = uid
    end
end

local function makeMenus()
    spawnmenu.AddToolMenuOption( "Utilities", "Falco's prop protection", "Falco's prop protection admin settings", "Admin settings", "", "", FPP.AdminMenu)
    spawnmenu.AddToolMenuOption( "Utilities", "Falco's prop protection", "Falco's prop protection buddies", "Buddies", "", "", FPP.BuddiesMenu)
    spawnmenu.AddToolMenuOption( "Utilities", "Falco's prop protection", "Falco's prop protection Private settings", "Private Settings", "", "", FPP.PrivateSettings)
end
hook.Add("PopulateToolMenu", "FPPMenus", makeMenus)

local function UpdateMenus()
    if IsValid(AdminPanel) then
        FPP.AdminMenu(AdminPanel)
    end
    if IsValid(BuddiesPanel) then
        FPP.BuddiesMenu(BuddiesPanel)
    end
    if IsValid(PrivateSettingsPanel) then
        FPP.PrivateSettings(PrivateSettingsPanel)
    end
end
hook.Add("SpawnMenuOpen", "FPPMenus", UpdateMenus)

function FPP.SharedMenu(um)
    local ent = um:ReadEntity()
    local frame = vgui.Create("DFrame")
    if not IsValid(ent) then frame:Close() return end
    frame:SetTitle("Share " .. ent:GetClass())
    frame:MakePopup()
    frame:SetVisible( true )

    local count = 1.5
    local row = 1
    local function AddChk(name, Type, value)
        local box = vgui.Create("DCheckBoxLabel", frame)
        if isstring(name) then
            box:SetText(name .. " share this entity")
        elseif name:IsPlayer() and name:IsValid() then
            box:SetText(name:Nick() .. " can touch this")
        else
            return
        end

        if count * 20 - (row - 1) * ScrH() > ScrH() - 30 - (row - 1) * 50 then
            row = row + 1
        end

        box:SetPos(10 + (row - 1) * 155, count * 20 - (row - 1) * ScrH() + (row - 1) * 40)
        count = count + 1
        box:SetValue(value)
        box.Button.Toggle = function()
            if not IsValid(ent) then frame:Close() return end
            if box.Button:GetChecked() == nil or not box.Button:GetChecked() then
                box.Button:SetValue( true )
            else
                box.Button:SetValue( false )
            end
            local tonum = {}
            tonum[false] = "0"
            tonum[true] = "1"
            RunConsoleCommand("FPP_ShareProp", ent:EntIndex(), Type, tonum[box.Button:GetChecked()])
        end
        box:SizeToContents()
    end
    AddChk("Physgun", "SharePhysgun1", um:ReadBool())
    AddChk("Gravgun", "ShareGravgun1", um:ReadBool())
    AddChk("Use", "SharePlayerUse1", um:ReadBool())
    AddChk("Damage", "ShareEntityDamage1", um:ReadBool())
    AddChk("Toolgun", "ShareToolgun1", um:ReadBool())

    local long = um:ReadLong()
    local SharedWith = {}

    if long > 0 then
        for i = 1, long do
            table.insert(SharedWith, um:ReadEntity())
        end
    end

    if player.GetCount() ~= 1 then
        count = count + 1
    end
    for _, v in ipairs(player.GetAll()) do
        if IsValid(v) and v ~= LocalPlayer() then
            local IsShared = false
            if table.HasValue(SharedWith, v) then
                IsShared = true
            end
            AddChk(v, v:UserID(), IsShared)
        end
    end
    local height = count * 20
    if row > 1 then
        height = ScrH() - 20
    end
    frame:SetSize(math.Min(math.Max(165 + (row - 1) * 165, 165), ScrW()), height)
    frame:Center()
end
usermessage.Hook("FPP_ShareSettings", FPP.SharedMenu)

properties.Add("addFPPBlocked",
{
    MenuLabel   =   "Add to FPP blocked models",
    Order       =   2001,
    MenuIcon    =   "icon16/cross.png",

    Filter      =   function(self, ent, ply)
                        if not IsValid(ent) or ent:IsPlayer() then return false end
                        return ply:IsSuperAdmin()
                    end,

    Action      =   function(self, ent)
                        if not IsValid(ent) then return end
                        RunConsoleCommand("FPP_AddBlockedModel", ent:GetModel(), ent:EntIndex())
                    end
})

properties.Add("removeFPPBlocked",
{
    MenuLabel   =   "Remove from FPP blocked models",
    Order       =   2002,
    MenuIcon    =   "icon16/tick.png",

    Filter      =   function(self, ent, ply)
                        if not IsValid(ent) or ent:IsPlayer() then return false end
                        return ply:IsSuperAdmin()
                    end,

    Action      =   function(self, ent)
                        if not IsValid(ent) then return end
                        RunConsoleCommand("FPP_RemoveBlockedModel", ent:GetModel(), ent:EntIndex())
                    end
})

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/commands/sh_concommands.lua:
FAdmin.Commands = {}
FAdmin.Commands.List = {}

function FAdmin.Commands.AddCommand(name, callback, ...)
    FAdmin.Commands.List[string.lower(name)] = {callback = callback, ExtraArgs = {...}}
end

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/commands/cl_concommands.lua:
local function AutoComplete(command, args)
    local autocomplete = {}
    args = string.Explode(" ", args)
    table.remove(args, 1) --Remove the first space
    if args[1] == "" then
        for k in pairs(FAdmin.Commands.List) do
            table.insert(autocomplete, command .. " " .. k)
        end
    elseif not args[2] or args[3] then
        for k, v in pairs(FAdmin.Commands.List) do
            if string.sub(k, 1, string.len(args[1])) == args[1] then
                local ExtraArgs = table.concat(v.ExtraArgs, "    ")
                table.insert(autocomplete, command .. " " .. k .. "        " .. ExtraArgs)
            end
        end
    elseif not args[3] and FAdmin.Commands.List[string.lower(args[1])] and FAdmin.Commands.List[string.lower(args[1])].ExtraArgs[1] == "<Player>" then
        for _, v in ipairs(player.GetAll()) do
            if args[2] == "" or table.HasValue(FAdmin.FindPlayer(args[2]) or {}, v) then
                table.insert(autocomplete, command .. " " .. args[1] .. " " .. v:Nick())
            end
        end
    end
    table.sort(autocomplete)
    return autocomplete
end
concommand.Add("FAdmin", function(ply, cmd, args)
    RunConsoleCommand("_" .. cmd, unpack(args))
end, AutoComplete)

--PATH gamemodes/mangarp/gamemode/modules/fadmin/fadmin/playeractions/noclip/cl_init.lua:
local sbox_noclip = GetConVar("sbox_noclip")

local function EnableDisableNoclip(ply)
    return ply:FAdmin_GetGlobal("FADmin_CanNoclip") or
        ((FAdmin.Access.PlayerHasPrivilege(ply, "Noclip") or sbox_noclip:GetBool())
            and not ply:FAdmin_GetGlobal("FADmin_DisableNoclip"))
end

FAdmin.StartHooks["zz_Noclip"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "noclipenable",
        hasTarget = true,
        message = {"instigator", " enabled noclip for ", "targets"},
    }

    FAdmin.Messages.RegisterNotification{
        name = "noclipdisable",
        hasTarget = true,
        message = {"instigator", " disabled noclip for ", "targets"},
    }

    FAdmin.Access.AddPrivilege("Noclip", 2)
    FAdmin.Access.AddPrivilege("SetNoclip", 2)

    FAdmin.Commands.AddCommand("SetNoclip", nil, "<Player>", "<Toggle 1/0>")

    FAdmin.ScoreBoard.Player:AddActionButton(function(ply)
        if EnableDisableNoclip(ply) then
            return "Disable noclip"
        end
        return "Enable noclip"
    end, function(ply) return "fadmin/icons/noclip", EnableDisableNoclip(ply) and "fadmin/icons/disable" end, Color(0, 200, 0, 255),

    function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), "SetNoclip") end, function(ply, button)
        if EnableDisableNoclip(ply) then
            RunConsoleCommand("_FAdmin", "SetNoclip", ply:UserID(), 0)
        else
            RunConsoleCommand("_FAdmin", "SetNoclip", ply:UserID(), 1)
        end

        if EnableDisableNoclip(ply) then
            button:SetText("Enable noclip")
            button:SetImage2("null")
            button:GetParent():InvalidateLayout()
            return
        end
        button:SetText("Disable noclip")
        button:SetImage2("fadmin/icons/disable")
        button:GetParent():InvalidateLayout()
    end)
end

--PATH gamemodes/mangarp/gamemode/modules/f4menu/cl_init.lua:
local f4Frame

--[[---------------------------------------------------------------------------
Interface functions
---------------------------------------------------------------------------]]
function DarkRP.openF4Menu()
    if IsValid(f4Frame) then
        f4Frame:Show()
        f4Frame:InvalidateLayout()
    else
        f4Frame = vgui.Create("F4MenuFrame")
        f4Frame:generateTabs()
    end
end

function DarkRP.closeF4Menu()
    if f4Frame then
        f4Frame:Hide()
    end
end

function DarkRP.toggleF4Menu()
    if not IsValid(f4Frame) or not f4Frame:IsVisible() then
        DarkRP.openF4Menu()
    else
        DarkRP.closeF4Menu()
    end
end

function DarkRP.getF4MenuPanel()
    return f4Frame
end

function DarkRP.addF4MenuTab(name, panel, order)
    if not f4Frame then DarkRP.error("DarkRP.addF4MenuTab called at the wrong time. Please call in the F4MenuTabs hook.", 2) end

    return f4Frame:createTab(name, panel, order)
end

function DarkRP.removeF4MenuTab(name)
    if not f4Frame then DarkRP.error("DarkRP.removeF4MenuTab called at the wrong time. Please call in the F4MenuTabs hook.", 2) end

    f4Frame:removeTab(name)
end

function DarkRP.switchTabOrder(tab1, tab2)
    if not f4Frame then DarkRP.error("DarkRP.switchTabOrder called at the wrong time. Please call in the F4MenuTabs hook.", 2) end

    f4Frame:switchTabOrder(tab1, tab2)
end


--[[---------------------------------------------------------------------------
Hooks
---------------------------------------------------------------------------]]
function DarkRP.hooks.F4MenuTabs()
    DarkRP.addF4MenuTab(DarkRP.getPhrase("jobs"), vgui.Create("F4MenuJobs"))
    DarkRP.addF4MenuTab(DarkRP.getPhrase("F4entities"), vgui.Create("F4MenuEntities"))

    local shipments = fn.Filter(fn.Compose{fn.Not, fn.Curry(fn.GetValue, 2)("noship")}, CustomShipments)
    if not table.IsEmpty(shipments) then
        DarkRP.addF4MenuTab(DarkRP.getPhrase("Shipments"), vgui.Create("F4MenuShipments"))
    end

    local guns = fn.Filter(fn.Curry(fn.GetValue, 2)("separate"), CustomShipments)
    if not table.IsEmpty(guns) then
        DarkRP.addF4MenuTab(DarkRP.getPhrase("F4guns"), vgui.Create("F4MenuGuns"))
    end

    if not table.IsEmpty(GAMEMODE.AmmoTypes) then
        DarkRP.addF4MenuTab(DarkRP.getPhrase("F4ammo"), vgui.Create("F4MenuAmmo"))
    end

    if not table.IsEmpty(CustomVehicles) then
        DarkRP.addF4MenuTab(DarkRP.getPhrase("F4vehicles"), vgui.Create("F4MenuVehicles"))
    end
end

hook.Add("DarkRPVarChanged", "RefreshF4Menu", function(ply, varname)
    if ply ~= LocalPlayer() or varname ~= "money" or not IsValid(f4Frame) or not f4Frame:IsVisible() then return end

    f4Frame:InvalidateLayout()
end)

--[[---------------------------------------------------------------------------
Fonts
---------------------------------------------------------------------------]]
-- font is not found otherwise
surface.CreateFont("Roboto Light", {
        size = 19,
        weight = 300,
        antialias = true,
        shadow = false,
        font = "Roboto Light",
        extended = true,
    })

surface.CreateFont("F4MenuFont01", {
        size = 23,
        weight = 400,
        antialias = true,
        shadow = false,
        font = "Roboto Light",
        extended = true,
    })

surface.CreateFont("F4MenuFont02", {
        size = 30,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Roboto Light",
        extended = true,
    })

--PATH gamemodes/mangarp/gamemode/modules/base/sh_checkitems.lua:
--[[
The base elements are shared by every custom item
]]
local baseSchema = tc.checkTable{
    buttonColor =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber)),
            "The buttonColor must be a Color value."
        ),

    category =
        tc.addHint(
            tc.optional(isstring),
            "The category must be the name of an existing category!"
        ),

    customCheck =
        tc.addHint(
            tc.optional(isfunction),
            "The customCheck must be a function."
        ),

    CustomCheckFailMsg =
        tc.addHint(
            tc.optional(isstring, isfunction),
            "The CustomCheckFailMsg must be either a string or a function."
        ),

    sortOrder =
        tc.addHint(
            tc.optional(isnumber),
            "The sortOrder must be a number."
        ),

    label =
        tc.addHint(
            tc.optional(isstring),
            "The label must be a valid string."
        ),
}

--[[
Properties shared by anything buyable
]]
local buyableSchema = fn.FAnd{baseSchema, tc.checkTable{
    allowed =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber), isnumber),
            "The allowed field must be either an existing team or a table of existing teams.",
            {"Is there a job here that doesn't exist (anymore)?"}
        ),

    getPrice =
        tc.addHint(
            tc.optional(isfunction),
            "The getPrice must be a function."
        ),

    model =
        tc.addHint(
            isstring,
            "The model must be valid."
        ),

    price =
        tc.addHint(
            function(v, tbl) return isnumber(v) or isfunction(tbl.getPrice) end,
            "The price must be an existing number or (for advanced users) the getPrice field must be a function."
        ),

    spawn =
        tc.addHint(
            tc.optional(isfunction),
            "The spawn must be a function."
        ),
    allowPurchaseWhileDead =
        tc.addHint(
            tc.default(false),
            "The allowPurchaseWhileDead must be either true or false"
        )
}}

-- The command of an entity must be unique
local uniqueEntity = function(cmd, tbl)
    for _, v in pairs(DarkRPEntities) do
        if v.cmd ~= cmd then continue end

        return
            false,
            "This entity does not have a unique command.",
            {
                "There must be some other entity that has the same thing for 'cmd'.",
                "Fix this by changing the 'cmd' field of your entity to something else."
            }
    end

    return true
end

-- The command of a job must be unique
local uniqueJob = function(v, tbl)
    local job = DarkRP.getJobByCommand(v)

    if not job then return true end

    return
        false,
        "This job does not have a unique command.",
        {
            "There must be some other job that has the same command.",
            "Fix this by changing the 'command' of your job to something else."
        }
end

--[[
Validate jobs
]]
DarkRP.validateJob = fn.FAnd{baseSchema, tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name must be a valid string."
        ),

    color =
        tc.addHint(
            tc.tableOf(isnumber),
            "The color must be a Color value.",
            {"Color values look like this: Color(r, g, b, a), where r, g, b and a are numbers between 0 and 255."}
        ),

    model =
        tc.addHint(
            fn.FOr{isstring, tc.nonEmpty(tc.tableOf(isstring))},
            "The model must either be a table of correct model strings or a single correct model string.",
            {
                "This error could happens when the model does not exist on the server.",
                "Are you sure the model path is right?",
                "Is the model from an addon that is not properly installed?"
            }
        ),

    description =
        tc.addHint(
            isstring,
            "The description must be a string."
        ),

    weapons =
        tc.addHint(
            tc.optional(tc.tableOf(isstring)),
            "The weapons must be a valid table of strings.",
            {"Example: weapons = {\"med_kit\", \"weapon_bugbait\"},"}
        ),

    command =
        fn.FAnd
        {
            tc.addHint(
                isstring,
                "The command must be a string."
            ),
            uniqueJob
        },

    max =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}},
            "The max must be a number greater than or equal to zero.",
            {
                "Zero means infinite.",
                "A decimal between 0 and 1 is seen as a percentage."
            }
        ),

    salary =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}},
            "The salary must be a number and it must be greater than zero."
        ),

    admin =
        tc.default(0,
            tc.addHint(
                fn.FAnd{isnumber, fp{fn.Lte, 0}, fp{fn.Gte, 2}},
                "The admin value must be a number and it must be greater than or equal to zero and smaller than three."
            )
        ),

    vote =
        tc.addHint(
            tc.optional(isbool),
            "The vote must be either true or false."
        ),

    ammo =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber)),
            "The ammo must be a table containing numbers.",
            {"See example on https://darkrp.miraheze.org/wiki/DarkRP:CustomJobFields"}
        ),

    hasLicense =
        tc.addHint(
            tc.optional(isbool),
            "The hasLicense must be either true or false."
        ),

    NeedToChangeFrom =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber), isnumber),
            "The NeedToChangeFrom must be either an existing team or a table of existing teams",
            {"Is there a job here that doesn't exist (anymore)?"}
        ),

    modelScale =
        tc.addHint(
            tc.optional(isnumber),
            "The modelScale must be a number."
        ),

    maxpocket =
        tc.addHint(
            tc.optional(isnumber),
            "The maxPocket must be a number."
        ),

    maps =
        tc.addHint(
            tc.optional(tc.tableOf(isstring)),
            "The maps value must be a table of valid map names."
        ),

    candemote =
        tc.default(true,
            tc.addHint(
                isbool,
                "The candemote value must be either true or false."
            )
        ),

    mayor =
        tc.addHint(
            tc.optional(isbool),
            "The mayor value must be either true or false."
        ),

    chief =
        tc.addHint(
            tc.optional(isbool),
            "The chief value must be either true or false."
        ),

    medic =
        tc.addHint(
            tc.optional(isbool),
            "The medic value must be either true or false."
        ),

    cook =
        tc.addHint(
            tc.optional(isbool),
            "The cook value must be either true or false."
        ),

    hobo =
        tc.addHint(
            tc.optional(isbool),
            "The hobo value must be either true or false."
        ),

    playerClass =
        tc.addHint(
            tc.optional(isstring),
            "The playerClass must be a valid string."
        ),

    CanPlayerSuicide =
        tc.addHint(
            tc.optional(isfunction),
            "The CanPlayerSuicide must be a function."
        ),

    PlayerCanPickupWeapon =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerCanPickupWeapon must be a function."
        ),

    PlayerDeath =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerDeath must be a function."
        ),

    PlayerLoadout =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerLoadout must be a function."
        ),

    PlayerSelectSpawn =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSelectSpawn must be a function."
        ),

    PlayerSetModel =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSetModel must be a function."
        ),

    PlayerSpawn =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSpawn must be a function."
        ),

    PlayerSpawnProp =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSpawnProp must be a function."
        ),

    RequiresVote =
        tc.addHint(
            tc.optional(isfunction),
            "The RequiresVote must be a function."
        ),

    ShowSpare1 =
        tc.addHint(
            tc.optional(isfunction),
            "The ShowSpare1 must be a function."
        ),

    ShowSpare2 =
        tc.addHint(
            tc.optional(isfunction),
            "The ShowSpare2 must be a function."
        ),

    canStartVote =
        tc.addHint(
            tc.optional(isfunction),
            "The canStartVote must be a function."
        ),

    canStartVoteReason =
        tc.addHint(
            tc.optional(isstring, isfunction),
            "The canStartVoteReason must be either a string or a function."
        ),
}}

--[[
Validate shipments
]]
DarkRP.validateShipment = fn.FAnd{buyableSchema, tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name must be a valid string."
        ),

    entity =
        tc.addHint(
            isstring, "The entity of the shipment must be a string."
        ),

    amount =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}}, "The amount must be a number and it must be greater than zero."
        ),

    separate =
        tc.addHint(
            tc.optional(isbool), "the separate field must be either true or false."
        ),

    pricesep =
        tc.addHint(
            function(v, tbl) return not tbl.separate or isnumber(v) and v >= 0 end,
            "The pricesep must be a number and it must be greater than or equal to zero."
        ),

    noship =
        tc.addHint(
            tc.optional(isbool),
            "The noship must be either true or false."
        ),

    shipmodel =
        tc.addHint(
            tc.optional(isstring),
            "The shipmodel must be a valid model."
        ),

    weight =
        tc.addHint(
            tc.optional(isnumber),
            "The weight must be a number."
        ),

    spareammo =
        tc.addHint(
            tc.optional(isnumber),
            "The spareammo must be a number."
        ),

    clip1 =
        tc.addHint(
            tc.optional(isnumber),
            "The clip1 must be a number."
        ),

    clip2 =
        tc.addHint(
            tc.optional(isnumber),
            "The clip2 must be a number."
        ),

    shipmentClass =
        tc.addHint(
            tc.optional(isstring),
            "The shipmentClass must be a string."
        ),

    onBought =
        tc.addHint(
            tc.optional(isfunction),
            "The onBought must be a function."
        ),

}}

--[[
Validate vehicles
]]
DarkRP.validateVehicle = fn.FAnd{buyableSchema, tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name of the vehicle must be a string."
        ),

    distance =
        tc.addHint(
            tc.optional(isnumber),
            "The distance must be a number."
        ),

    angle =
        tc.addHint(
            tc.optional(isangle),
            "The distance must be a valid Angle."
        ),
}}

--[[
Validate Entities
]]
DarkRP.validateEntity = fn.FAnd{buyableSchema, tc.checkTable{
    ent =
        tc.addHint(
            isstring,
            "The ent field must be a string."
        ),

    max =
        tc.addHint(
            function(v, tbl) return isnumber(v) or isfunction(tbl.getMax) end,
            "The max must be an existing number or (for advanced users) the getMax field must be a function."
        ),

    cmd =
        fn.FAnd
        {
            tc.addHint(isstring, "The cmd must be a valid string."),
            uniqueEntity
        },

    name =
        tc.addHint(
            isstring,
            "The name must be a valid string."
        ),

    allowTools =
        tc.default(false,
            tc.addHint(
                tc.optional(isbool),
                "The allowTools must be either true or false."
            )
        ),

    delay =
        tc.addHint(
            tc.optional(isnumber),
            "The delay must be a number."
        ),
}}


-- Checks whether a team already has an agenda assigned.
-- Jobs cannot have multiple agendas.

local overlappingAgendaCheck = function(t, tbl)
    local agenda = DarkRP.getAgendas()[t]

    -- Team being -1 means the job is disabled
    if agenda == nil or t == -1 then return true end

    local teamName = team.GetName(t)
    local err = "At least one job has multiple agendas assigned to them"
    local hints = {
        string.format([[The problem lies with the job called "%s"]], teamName),
        string.format([[It is assigned to agendas "%s" and "%s"]], agenda.Title or "unknown", tbl.Title or "unknown"),
        [[A job can only have ONE agenda. Otherwise things would become confusing, since only ONE agenda is always drawn on the screen.]]
    }

    if agenda.Title == tbl.Title then
        table.insert(hints, "The titles of the two agendas are the same. It looks like perhaps you've made the same agenda more than once.")
        table.insert(hints, "Removing one of them should get rid of this error.")
    end

    return false, err, hints
end

--[[
Validate Agendas
]]
local managerNumberCheck = tc.addHint(
    isnumber,
    "The Manager must either be a single team or a non-empty table of existing teams.",
    {"Is there a job here that doesn't exist (anymore)?"}
)

DarkRP.validateAgenda = tc.checkTable{
    Title =
        tc.addHint(
            isstring,
            "The title must be a string."
        ),

    -- Custom function to ensure the right error message is thrown
    Manager = function(manager, tbl)
            -- Check whether the manager is an existing team
            -- that does not already have an agenda assigned
            if isnumber(manager) then
                return fn.FAnd{overlappingAgendaCheck}(manager, tbl)

            -- Check whether the manager is a table of existing teams
            -- and that none of the teams already have agendas assigned
            elseif istable(manager) then
                return tc.nonEmpty(
                    tc.tableOf(
                        fn.FAnd{managerNumberCheck, overlappingAgendaCheck}
                    )
                )(manager, tbl)
            end

            return managerNumberCheck(manager, tbl)
        end,
    Listeners =
        tc.default({}, -- Default to empty table
            -- Checks for a table of valid teams that do not already have an
            -- agenda assigned
            fn.FAnd{
                tc.addHint(
                    tc.tableOf(isnumber),
                    "The Listeners must be a table of existing teams.",
                    {
                        "Is there a job here that doesn't exist (anymore)?",
                        "Are you trying to have multiple manager jobs in this agenda? In that case you must put the list of manager jobs in curly braces.",
                        [[Like so: DarkRP.createAgenda("Some agenda", {TEAM_MANAGER1, TEAM_MANAGER2}, {TEAM_LISTENER1, TEAM_LISTENER2})]]
                    }
                ),
                tc.tableOf(overlappingAgendaCheck)
            }
        )
}

--[[
Validate Categories
]]
DarkRP.validateCategory = tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name must be a string."
        ),

    categorises =
        tc.addHint(
            tc.oneOf{"jobs", "entities", "shipments", "weapons", "vehicles", "ammo"},
            [[The categorises must be one of "jobs", "entities", "shipments", "weapons", "vehicles", "ammo"]],
            {
                "Mind that this is case sensitive.",
                "Also mind the quotation marks."
            }
        ),

    startExpanded =
        tc.addHint(
            isbool,
            "The startExpanded must be either true or false."
        ),

    color =
        tc.addHint(
            tc.tableOf(isnumber),
            "The color must be a Color value."
        ),

    canSee =
        tc.addHint(
            tc.optional(isfunction),
            "The canSee must be a function."
        ),

    sortOrder =
        tc.addHint(
            tc.optional(isnumber),
            "The sortOrder must be a number."
        ),
}

--PATH gamemodes/mangarp/gamemode/config/ammotypes.lua:

DarkRP.createCategory{
    name = "Other",
    categorises = "ammo",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

--PATH addons/leveling-system/lua/darkrp_modules/levels/cl_hud.lua:
// Love Manolis Vrondakis. @vrondakis

surface.CreateFont( "HeadBar", { // XP Bar font
	 font = "Tahoma",
	 size = 13,
	 weight = 500,
	 blursize = 0,
	 scanlines = 0,
} )

surface.CreateFont("LevelPrompt", { // Level prompt font
	font = "Francois One",
	size = 70,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
}) 


// I hate this fucking DrawDisplay function. Eurgh.
local function DrawDisplay()
local shouldDraw, players = hook.Call("HUDShouldDraw", GAMEMODE, "DarkRP_EntityDisplay")
	if shouldDraw == false then return end
	local shootPos = LocalPlayer():GetShootPos()
	local aimVec = LocalPlayer():GetAimVector()
	if(LevelSystemConfiguration.DisplayLevel) then
		for k, ply in pairs(players or player.GetAll()) do
			if not ply:Alive() then continue end
			if ply:GetRenderMode() == RENDERMODE_TRANSALPHA then continue end // player is cloaked (ULX)
			if ply == LocalPlayer() then continue end
			local hisPos = ply:GetShootPos()
			if GAMEMODE.Config.globalshow and ply ~= localplayer then
					local pos = ply:EyePos()
					pos.z = pos.z + 10 -- The position we want is a bit above the position of the eyes
					pos = pos:ToScreen()
					pos.y = pos.y-20
					draw.DrawText("Level: "..(ply:getDarkRPVar("level") or 0), "DarkRPHUD2", pos.x+1, pos.y -56, Color(0,0,0,255), 1)
					draw.DrawText("Level: "..(ply:getDarkRPVar("level") or 0), "DarkRPHUD2", pos.x, pos.y -55, Color(255,255,255,200), 1)
			elseif not GAMEMODE.Config.globalshow and hisPos:Distance(shootPos) < 250 then
				local pos = hisPos - shootPos
				local unitPos = pos:GetNormalized()
	
					local trace = util.QuickTrace(shootPos, pos, localplayer)
					if trace.Hit and trace.Entity ~= ply then return end
						local pos = ply:EyePos()
						pos.z = pos.z + 10 -- The position we want is a bit above the position of the eyes
						pos = pos:ToScreen()
						pos.y = pos.y-20
						draw.DrawText("Level: "..(ply:getDarkRPVar("level") or 0), "DarkRPHUD2", pos.x, pos.y -58, Color(0,0,0,255), 1)
						draw.DrawText("Level: "..(ply:getDarkRPVar("level") or 0), "DarkRPHUD2", pos.x+1, pos.y -57, Color(255,255,255,200), 1)
			end
		end
	end
 
	local tr = LocalPlayer():GetEyeTrace()

end
local OldXP = 0
local xp_bar = Material("vrondakis/xp_bar.png","noclamp smooth")
local function HUDPaint()
	if not LevelSystemConfiguration then return end
	local PlayerLevel = LocalPlayer():getDarkRPVar("level")
	local PlayerXP = LocalPlayer():getDarkRPVar("xp")
	
	local percent = ((PlayerXP or 0)/(((10+(((PlayerLevel or 1)*((PlayerLevel or 1)+1)*90))))*LevelSystemConfiguration.XPMult)) // Gets the accurate level up percentage
	
	local drawXP = Lerp(8*FrameTime(),OldXP,percent)
	OldXP = drawXP
	local percent2 = percent*100
	percent2 = math.Round(percent2)
	percent2 = math.Clamp(percent2, 0, 99) //Make sure it doesn't round past 100%
	
	if LevelSystemConfiguration.EnableBar then
		// Draw the XP Bar
		surface.SetDrawColor(0,0,0,200)
		surface.DrawRect(ScrW()/2-300,(LevelSystemConfiguration.XPBarYPos or 0),580,25)
	
		// Draw the XP Bar before the texture
		surface.SetDrawColor(LevelSystemConfiguration.LevelBarColor[1],LevelSystemConfiguration.LevelBarColor[2],LevelSystemConfiguration.LevelBarColor[3],255)
		surface.DrawRect(ScrW()/2-300,(LevelSystemConfiguration.XPBarYPos or 0),580*drawXP,25)

		//Render the texture
		surface.SetMaterial(xp_bar)
		surface.SetDrawColor(255,255,255,255)
		surface.DrawTexturedRect( ScrW()/2-371, 0+(LevelSystemConfiguration.XPBarYPos or 0),  742,46)
	end
	
	// Render the text
	if LevelSystemConfiguration.BarText then
		draw.DrawText("Level "..(LocalPlayer():getDarkRPVar("level") or 0).." - "..percent2 .."%", "HeadBar", ScrW()/2,7+(LevelSystemConfiguration.XPBarYPos or 0),(LevelSystemConfiguration.XPTextColor or Color(255,255,255,255)), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end
	
	if LevelSystemConfiguration.LevelText then
		draw.SimpleText("Level: " ..(LocalPlayer():getDarkRPVar("level") or 0), "LevelPrompt", LevelSystemConfiguration.LevelTextPos[1],ScrH()-LevelSystemConfiguration.LevelTextPos[2],((Color(0,0,0,255))), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT)
		draw.SimpleText("Level: " ..(LocalPlayer():getDarkRPVar("level") or 0), "LevelPrompt", LevelSystemConfiguration.LevelTextPos[1]+1,ScrH()-LevelSystemConfiguration.LevelTextPos[2]-1,(LevelSystemConfiguration.LevelColor or (Color(0,0,0,255))), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT)
	end
	
	DrawDisplay()
end
hook.Add("HUDPaint", "manolis:MVLevels:HUDPaintA", HUDPaint) // IS THAT UNIQUE ENOUGH FOR YOU, FUCKING GMOD HOOKING BULLSHIT.



--PATH addons/sl_bouffe/lua/darkrp_modules/barman_job_module/sh_job_modules.lua:
DarkRP.createCategory{
	name = "Barman", 
	categorises = "entities",
	startExpanded = true,
	color = Color(158, 38, 228),
	canSee = function(ply) return true end,
	sortOrder = 100,
}

DarkRP.createEntity("Beer (Master)", {
    ent = "sl_beer1",
    model = "models/FoodNHouseholdItems/beer_master.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_beer1",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Beer (Stoltz)", {
    ent = "sl_beer2",
    model = "models/FoodNHouseholdItems/beer_stoltz.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_beer2",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Beer (Duff)", {
    ent = "sl_beercan1",
    model = "models/FoodNHouseholdItems/beercan01.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_beercan1",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Beer (Pißwasser)", {
    ent = "sl_beercan2",
    model = "models/FoodNHouseholdItems/beercan02.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_beercan2",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Beer (Hop Knot)", {
    ent = "sl_beercan3",
    model = "models/FoodNHouseholdItems/beercan03.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_beercan3",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Champagne", {
    ent = "sl_champagne1",
    model = "models/FoodNHouseholdItems/champagne.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_champagne1",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Champagne (on plate)", {
    ent = "sl_champagne2",
    model = "models/FoodNHouseholdItems/champagneonplate.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_champagne2",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Champagne", {
    ent = "sl_champagne3",
    model = "models/FoodNHouseholdItems/champagne2.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_champagne3",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Champagne (open)", {
    ent = "sl_champagne4",
    model = "models/FoodNHouseholdItems/champagne2b.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_champagne4",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Champagne", {
    ent = "sl_champagne5",
    model = "models/FoodNHouseholdItems/champagne3.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_champagne5",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Coconut Cocktail", {
    ent = "sl_cocktailcoco",
    model = "models/FoodNHouseholdItems/coconut_drink.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_cocktailcoco",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Pineapple Cocktail", {
    ent = "sl_cocktailpine",
    model = "models/FoodNHouseholdItems/pineapple_drink.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_cocktailpine",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("McDonalds Soda", {
    ent = "sl_mcdsoda",
    model = "models/FoodNHouseholdItems/mcddrink.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_mcdsoda",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Soda (Coca Cola)", {
    ent = "sl_sodacan01",
    model = "models/FoodNHouseholdItems/Sodacan01.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacan01",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Soda (Coca Cola Cherry)", {
    ent = "sl_sodacan02",
    model = "models/FoodNHouseholdItems/Sodacan02.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacan02",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Soda (Coca Cola Life)", {
    ent = "sl_sodacan03",
    model = "models/FoodNHouseholdItems/Sodacan03.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacan03",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Soda (Pepsi)", {
    ent = "sl_sodacan04",
    model = "models/FoodNHouseholdItems/Sodacan04.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacan04",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Soda (Sprite)", {
    ent = "sl_sodacan05",
    model = "models/FoodNHouseholdItems/Sodacan05.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacan05",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Soda (Mountain Dew)", {
    ent = "sl_sodacan06",
    model = "models/FoodNHouseholdItems/Sodacan06.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacan06",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Monster Energy", {
    ent = "sl_sodacanb01",
    model = "models/FoodNHouseholdItems/Sodacanb01.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacanb01",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Monster Energy (Lo-Carb)", {
    ent = "sl_sodacanb02",
    model = "models/FoodNHouseholdItems/Sodacanb02.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacanb02",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Monster Energy (Assault)", {
    ent = "sl_sodacanb03",
    model = "models/FoodNHouseholdItems/Sodacanb03.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacanb03",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Volt Energy", {
    ent = "sl_sodacanb04",
    model = "models/FoodNHouseholdItems/Sodacanb04.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacanb04",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Red Bull", {
    ent = "sl_sodacanc01",
    model = "models/FoodNHouseholdItems/Sodacanc01.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacanc01",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Cola (Small)", {
    ent = "sl_sodacola",
    model = "models/FoodNHouseholdItems/cola.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacola",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Cola (Large)", {
    ent = "sl_sodacolalarge",
    model = "models/FoodNHouseholdItems/colabig.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodacolalarge",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Sprunk (Large)", {
    ent = "sl_sodasprunk1",
    model = "models/FoodNHouseholdItems/sprunk1.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodasprunk1",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Sprunk Light (Large)", {
    ent = "sl_sodasprunk2",
    model = "models/FoodNHouseholdItems/sprunk2.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_sodasprunk2",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Wine (Classic)", {
    ent = "sl_wineclassic1",
    model = "models/FoodNHouseholdItems/winebottle1.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_wineclassic1",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Wine (Classic) 2", {
    ent = "sl_wineclassic2",
    model = "models/FoodNHouseholdItems/winebottle2.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_wineclassic2",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Wine (Classic) 3", {
    ent = "sl_wineclassic3",
    model = "models/FoodNHouseholdItems/winebottle3.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_wineclassic3",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Wine (Classic) 4", {
    ent = "sl_wineclassic4",
    model = "models/FoodNHouseholdItems/winebottle4.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_wineclassic4",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Wine (Rose)", {
    ent = "sl_winerose1",
    model = "models/FoodNHouseholdItems/wine_rose1.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_winerose1",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Wine (Rose) 2", {
    ent = "sl_winerose2",
    model = "models/FoodNHouseholdItems/wine_rose2.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_winerose2",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Wine (White)", {
    ent = "sl_winewhite1",
    model = "models/FoodNHouseholdItems/wine_white1.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_winewhite1",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Wine (White) 2", {
    ent = "sl_winewhite2",
    model = "models/FoodNHouseholdItems/wine_white2.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_winewhite2",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})
DarkRP.createEntity("Wine (White) 3", {
    ent = "sl_winewhite3",
    model = "models/FoodNHouseholdItems/wine_white3.mdl",
    price = 1000,
    max = 10,
    cmd = "sl_winewhite3",
    allowed = {TEAM_BARNIGHTCLUB},
    category = "Barman",
})

--PATH addons/sl_main_system/lua/weapons/buellost_faux1/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH lua/weapons/gmod_tool/stools/drgbase_tool_omniscient.lua:
TOOL.Tab = "DrGBase"
TOOL.Category = "Tools"
TOOL.Name = "#tool.drgbase_tool_omniscient.name"
TOOL.BuildCPanel = function(panel)
	panel:Help("#tool.drgbase_tool_omniscient.desc")
	panel:Help("#tool.drgbase_tool_omniscient.0")
end

function TOOL:LeftClick(tr)
	if not IsValid(tr.Entity) then return false end
	if not tr.Entity.IsDrGNextbot then return false end
	if SERVER then tr.Entity:SetOmniscient(not tr.Entity:IsOmniscient()) end
	return true
end

if CLIENT then
	language.Add("tool.drgbase_tool_omniscient.name", "Toggle Omniscient")
	language.Add("tool.drgbase_tool_omniscient.desc", "Disable/enable omniscience for a nextbot.")
	language.Add("tool.drgbase_tool_omniscient.0", "Left click to toggle omniscience. (Green => Enabled / Red => Disabled)")

	hook.Add("PreDrawHalos", "DrGBaseToolOmniscientHalos", function()
		local wep = LocalPlayer():GetActiveWeapon()
		if not IsValid(wep) or wep:GetClass() ~= "gmod_tool" then return end
		local tool = LocalPlayer():GetTool()
		if tool == nil or tool.Mode ~= "drgbase_tool_omniscient" then return end
		local enabled = {}
		local disabled = {}
		for i, nextbot in ipairs(DrGBase.GetNextbots()) do
			if not IsValid(nextbot) then continue end
			if nextbot:IsOmniscient() then table.insert(enabled, nextbot)
			else table.insert(disabled, nextbot) end
		end
		halo.Add(enabled, DrGBase.CLR_GREEN)
		halo.Add(disabled, DrGBase.CLR_RED)
	end)
end

--PATH addons/precision_tool/lua/weapons/gmod_tool/stools/precision.lua:

TOOL.Category		= "Constraints"
TOOL.Name			= "#Precision"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "mode" ]	 			= "1"
TOOL.ClientConVar[ "user" ] 			= "1"

TOOL.ClientConVar[ "freeze" ]	 		= "1"
TOOL.ClientConVar[ "nocollide" ]		= "1"
TOOL.ClientConVar[ "nocollideall" ]		= "0"
TOOL.ClientConVar[ "rotation" ] 		= "15"
TOOL.ClientConVar[ "rotate" ] 			= "1"
TOOL.ClientConVar[ "offset" ]	 		= "0"
TOOL.ClientConVar[ "forcelimit" ]		= "0"
TOOL.ClientConVar[ "torquelimit" ] 		= "0"
TOOL.ClientConVar[ "friction" ]	 		= "0"
TOOL.ClientConVar[ "width" ]	 		= "1"
TOOL.ClientConVar[ "offsetpercent" ] 	= "1"
TOOL.ClientConVar[ "removal" ]	 		= "0"
TOOL.ClientConVar[ "move" ]	 			= "1"
TOOL.ClientConVar[ "physdisable" ]		= "0"
TOOL.ClientConVar[ "ShadowDisable" ]	= "0"
TOOL.ClientConVar[ "allowphysgun" ]		= "0"
TOOL.ClientConVar[ "autorotate" ]		= "0"
TOOL.ClientConVar[ "entirecontrap" ]	= "0"
TOOL.ClientConVar[ "nudge" ]			= "25"
TOOL.ClientConVar[ "nudgepercent" ]		= "1"
TOOL.ClientConVar[ "disablesliderfix" ]	= "0"

//adv ballsocket
TOOL.ClientConVar[ "XRotMin" ]		= "-180"
TOOL.ClientConVar[ "XRotMax" ]		= "180"
TOOL.ClientConVar[ "YRotMin" ]		= "-180"
TOOL.ClientConVar[ "YRotMax" ]		= "180"
TOOL.ClientConVar[ "ZRotMin" ]		= "-180"
TOOL.ClientConVar[ "ZRotMax" ]		= "180"
TOOL.ClientConVar[ "XRotFric" ]		= "0"
TOOL.ClientConVar[ "YRotFric" ]		= "0"
TOOL.ClientConVar[ "ZRotFric" ]		= "0"
TOOL.ClientConVar[ "FreeMov" ]		= "0"

//Removal
TOOL.ClientConVar[ "removal_nocollide" ]	= "1"
TOOL.ClientConVar[ "removal_weld" ]	 		= "1"
TOOL.ClientConVar[ "removal_axis" ]	 		= "1"
TOOL.ClientConVar[ "removal_ballsocket" ]	= "1"
TOOL.ClientConVar[ "removal_advballsocket" ]= "1"
TOOL.ClientConVar[ "removal_slider" ]	 	= "1"
TOOL.ClientConVar[ "removal_parent" ]	 	= "1"
TOOL.ClientConVar[ "removal_other" ]	 	= "1"


TOOL.ClientConVar[ "enablefeedback" ]	= "1"
TOOL.ClientConVar[ "chatfeedback" ]		= "1"
TOOL.ClientConVar[ "nudgeundo" ]		= "0"
TOOL.ClientConVar[ "moveundo" ]			= "1"
TOOL.ClientConVar[ "rotateundo" ]		= "1"

function TOOL:DoParent( Ent1, Ent2 )
	local TempEnt = Ent2
	if !(Ent1 && Ent1:IsValid() && Ent1:EntIndex() != 0) then
		self:SendMessage( "Oops, First Target was world or something invalid" )
		return
	end
	if !(Ent2 && Ent2:IsValid() && Ent2:EntIndex() != 0) then
		self:SendMessage( "Oops, Second Target was world or something invalid" )
		return
	end
	if ( Ent1 == Ent2 ) then
		self:SendMessage( "Oops, Can't parent something to itself" )
		return
	end
	Ent1:SetMoveType(MOVETYPE_NONE)
	local disablephysgun = self:GetClientNumber( "allowphysgun" ) == 0
	Ent1.PhysgunDisabled = disablephysgun
	Ent1:SetUnFreezable( disablephysgun )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( false )
	end
	while true do
		if ( !TempEnt:GetParent():IsValid() ) then
			Ent1:SetParent( Ent2 )
			if self:GetClientNumber( "entirecontrap" ) == 0 then self:SendMessage( "Parent Set." ) end
			Phys1:Wake()
			break
		elseif ( TempEnt:GetParent() == Ent1 ) then
			UndoParent( TempEnt )
			timer.Simple( 0.1, function()//delay to stop crash
				Ent1.SetParent( Ent1, Ent2)
			end)
			self:SendMessage( "Oops, Closed Parent Loop Detected; Broken loop and set parent." )
			break
		else
			TempEnt = TempEnt:GetParent()
		end
	end
	Phys1:Wake()
	//Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
end

function TOOL:UndoParent( Ent1 )
	Ent1:SetParent( nil )
	Ent1:SetMoveType(MOVETYPE_VPHYSICS)
	Ent1.PhysgunDisabled = false
	Ent1:SetUnFreezable( false )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( true )
		Phys1:Wake()
		//Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
	end
end

function TOOL:DoApply(CurrentEnt, FirstEnt, autorotate, nocollideall, ShadowDisable )
	local CurrentPhys = CurrentEnt:GetPhysicsObject()
	
	//local col = CurrentEnt:GetCollisionGroup()
	//col = 19
	//CurrentEnt:SetCollisionGroup(col)
	//self:SendMessage("New group: "..col)
	
	//if ( CurrentPhys:IsDragEnabled() ) then
	//end
	//CurrentPhys:SetAngleDragCoefficient(1.05)
	//CurrentPhys:SetDragCoefficient(1.05)
	
	if ( autorotate ) then
		if ( CurrentEnt == FirstEnt ) then//Snap-rotate original object first.  Rest needs to rotate around it.
			local angle = CurrentPhys:RotateAroundAxis( Vector( 0, 0, 1 ), 0 )
			self.anglechange = Vector( angle.p - (math.Round(angle.p/45))*45, angle.r - (math.Round(angle.r/45))*45, angle.y - (math.Round(angle.y/45))*45 )
			if ( table.Count(self.TaggedEnts) == 1 ) then
				angle.p = (math.Round(angle.p/45))*45
				angle.r = (math.Round(angle.r/45))*45//Only rotate on these axies if it's singular.
			end
			angle.y = (math.Round(angle.y/45))*45
			CurrentPhys:SetAngles( angle )
		else
			local distance = math.sqrt(math.pow((CurrentEnt:GetPos().X-FirstEnt:GetPos().X),2)+math.pow((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y),2))
			local theta = math.atan((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y) / (CurrentEnt:GetPos().X-FirstEnt:GetPos().X)) - math.rad(self.anglechange.Z)
			if (CurrentEnt:GetPos().X-FirstEnt:GetPos().X) < 0 then
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X - (distance*(math.cos(theta))), FirstEnt:GetPos().Y - (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			else
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X + (distance*(math.cos(theta))), FirstEnt:GetPos().Y + (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			end
			CurrentPhys:SetAngles( CurrentPhys:RotateAroundAxis( Vector( 0, 0, -1 ), self.anglechange.Z ) )
		end
	end

	CurrentPhys:EnableCollisions( !nocollideall )
	CurrentEnt:DrawShadow( !ShadowDisable )
	if physdis then
		CurrentEnt:SetMoveType(MOVETYPE_NONE)
		CurrentEnt.PhysgunDisabled = disablephysgun
		CurrentEnt:SetUnFreezable( disablephysgun )
	else
		CurrentEnt:SetMoveType(MOVETYPE_VPHYSICS)
		CurrentEnt.PhysgunDisabled = false
		CurrentEnt:SetUnFreezable( false )
	end
	CurrentPhys:Wake()
end

function TOOL:CreateUndo(constraint,undoname)
	if (constraint) then
		undo.Create(undoname)
		undo.AddEntity( constraint )
		undo.SetPlayer( self:GetOwner() )
		undo.Finish()
		self:GetOwner():AddCleanup( "constraints", constraint )
	end
end

function TOOL:UndoRepairToggle()
	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then//parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then //not a ragdoll
						if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
						elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
						end
						if ( speeddamp == 0 && angledamp == 0 ) then
							CurrentPhys:SetDamping( 5, 5 )
						elseif ( speeddamp == 5 && angledamp == 5 ) then
							CurrentPhys:SetDamping( 0, 0 )
						end
						CurrentPhys:Wake()
					end
				end
			end
		end
	end
	self.RepairTodo = false
end

function TOOL:DoConstraint(mode)
	self:SetStage(0)
	// Get information we're about to use
	local Ent1,  Ent2  = self:GetEnt(1),    self:GetEnt(2)

	if ( !Ent1:IsValid() || CLIENT ) then
		self:ClearObjects()
		return false//Something happened to original target, don't continue
	end
	// Get client's CVars
	local forcelimit 	= self:GetClientNumber( "forcelimit", 0 )
	local freeze		= util.tobool( self:GetClientNumber( "freeze", 1 ) )
	local nocollide		= self:GetClientNumber( "nocollide", 0 )
	local nocollideall	= util.tobool( self:GetClientNumber( "nocollideall", 0 ) )
	local torquelimit	= self:GetClientNumber( "torquelimit", 0 )
	local width			= self:GetClientNumber( "width", 1 )
	local friction		= self:GetClientNumber( "friction", 0 )
	local physdis		= util.tobool( self:GetClientNumber( "physdisable", 0 ) )
	local ShadowDisable = util.tobool( self:GetClientNumber( "ShadowDisable", 0 ) )
	local autorotate 	= util.tobool(self:GetClientNumber( "autorotate",1 ))
	local removal_nocollide 	= util.tobool(self:GetClientNumber( "removal_nocollide",1 ))
	local removal_weld 	= util.tobool(self:GetClientNumber( "removal_weld",1 ))
	local removal_axis 	= util.tobool(self:GetClientNumber( "removal_axis",1 ))
	local removal_ballsocket 	= util.tobool(self:GetClientNumber( "removal_ballsocket",1 ))
	local removal_advballsocket 	= util.tobool(self:GetClientNumber( "removal_advballsocket",1 ))
	local removal_slider 	= util.tobool(self:GetClientNumber( "removal_slider",1 ))
	local removal_parent 	= util.tobool(self:GetClientNumber( "removal_parent",1 ))
	local removal_other 	= util.tobool(self:GetClientNumber( "removal_other",1 ))
	local Bone1 = self:GetBone(1)
	local LPos1 = self:GetLocalPos(1)
	local Bone2 = nil
	local LPos2 = nil
	if ( Ent2 && (Ent2:IsValid() || Ent2:IsWorld()) ) then
		Bone2 = self:GetBone(2)
		LPos2 = self:GetLocalPos(2)
	end
	local Phys1 = self:GetPhys(1)
	
	local NumApp = 0
	

	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then//parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then //not a ragdoll
						if (  util.tobool( nocollide ) && (mode == 1 || mode == 3)) then // not weld/axis/ballsocket or single application
							local constraint = constraint.NoCollide(CurrentEnt, Ent2, 0, Bone2)
						end
						if ( mode == 1 ) then //Apply
							self:DoApply( CurrentEnt, Ent1, autorotate, nocollideall, ShadowDisable )
						elseif ( mode == 2 ) then //Rotate
							//self:SendMessage("Sorry, No entire contraption rotating... yet")
							//return false//TODO: Entire contrpation rotaton
						elseif ( mode == 3 ) then //move
							//self:SendMessage("Sorry, No entire contraption moving... yet")
							//return false//todo: entire contraption move/snap
						elseif ( mode == 4 ) then //weld
							local constr = constraint.Weld( CurrentEnt, Ent2, 0, Bone2, forcelimit,  util.tobool( nocollide ) )
							self:CreateUndo(constr,"Precision_Weld")
						elseif ( mode == 5 ) then //doaxis
							local constr = constraint.Axis( CurrentEnt, Ent2, Bone1, Bone2, LPos1, LPos2, forcelimit, torquelimit, friction, nocollide )
							self:CreateUndo(constr,"Precision_Axis")
						elseif ( mode == 6 ) then //ballsocket
							local constr = constraint.Ballsocket( CurrentEnt, Ent2, 0, Bone2, LPos2, forcelimit, torquelimit, nocollide )
							self:CreateUndo(constr,"Precision_Ballsocket")
						elseif ( mode == 7 ) then //adv ballsocket
							local constr = constraint.AdvBallsocket( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, forcelimit, torquelimit, self:GetClientNumber( "XRotMin", -180 ), self:GetClientNumber( "YRotMin", -180 ), self:GetClientNumber( "ZRotMin", -180 ), self:GetClientNumber( "XRotMax", 180 ), self:GetClientNumber( "YRotMax", 180 ), self:GetClientNumber( "ZRotMax", 180 ), self:GetClientNumber( "XRotFric", 0 ), self:GetClientNumber( "YRotFric", 0 ), self:GetClientNumber( "ZRotFric", 0 ), self:GetClientNumber( "FreeMov", 0 ), nocollide )
							self:CreateUndo(constr,"Precision_Advanced_Ballsocket")
						elseif ( mode == 8 ) then //slider
							local constraint0 = constraint.Slider( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, width )
							if (constraint0) then
								undo.Create("Precision_Slider")
								if ( self:GetClientNumber( "disablesliderfix" ) == 0 ) then
									local constraint2 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, 0, -180, -180, 0, 180, 180, 50, 0, 0, 1, 0 )
									if (constraint2) then
										undo.AddEntity( constraint2 )
									end
									local constraint3 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, 0, -180, 180, 0, 180, 0, 50, 0, 1, 0 )
									if (constraint3) then
										undo.AddEntity( constraint3 )
									end
									local constraint4 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, -180, 0, 180, 180, 0, 0, 0, 50, 1, 0 )
									if (constraint4) then
										undo.AddEntity( constraint4 )
									end
								end
								undo.AddEntity( constraint0 )
								undo.SetPlayer( self:GetOwner() )
								undo.Finish()
								self:GetOwner():AddCleanup( "constraints", constraint0 )
							end
						elseif ( mode == 9 ) then //Parent
							self:DoParent( CurrentEnt, Ent2 )
						elseif ( mode == 10 && !self.RepairTodo ) then//Repair spaz
							if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
								CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
							elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
								CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
							end
								//CurrentPhys:EnableGravity( !CurrentPhys:IsGravityEnabled() )//Can't disable gravity - sliders would go nuts and disappear.	
							local speeddamp,angledamp = CurrentPhys:GetDamping()
							if ( speeddamp == 0 && angledamp == 0 ) then
								CurrentPhys:SetDamping( 5, 5 )
							elseif ( speeddamp == 5 && angledamp == 5 ) then
								CurrentPhys:SetDamping( 0, 0 )
							end
							CurrentEnt:SetPos(CurrentEnt:GetPos())
							CurrentPhys:Wake()
						elseif ( mode == 11 ) then //Removal
							if ( CLIENT ) then return true end//? should probably be in more places
							if ( removal_nocollide ) then
								constraint.RemoveConstraints( CurrentEnt, "NoCollide" )
								CurrentPhys:EnableCollisions(true)
							end
							if ( removal_weld ) then
								constraint.RemoveConstraints( CurrentEnt, "Weld" )
							end
							if ( removal_axis ) then
								constraint.RemoveConstraints( CurrentEnt, "Axis" )
							end
							if ( removal_ballsocket ) then
								constraint.RemoveConstraints( CurrentEnt, "Ballsocket" )
							end
							if ( removal_advballsocket ) then
								constraint.RemoveConstraints( CurrentEnt, "AdvBallsocket" )
							end
							if ( removal_slider ) then
								constraint.RemoveConstraints( CurrentEnt, "Slider" )
							end
							if ( removal_parent) then
								if ( CurrentEnt:GetParent():IsValid() ) then
									self:UndoParent( CurrentEnt )
								end
							end
							if ( removal_other ) then
								constraint.RemoveConstraints( CurrentEnt, "Elastic" )
								constraint.RemoveConstraints( CurrentEnt, "Hydraulic" )
								constraint.RemoveConstraints( CurrentEnt, "Keepupright" )
								constraint.RemoveConstraints( CurrentEnt, "Motor" )
								constraint.RemoveConstraints( CurrentEnt, "Muscle" )
								constraint.RemoveConstraints( CurrentEnt, "Pulley" )
								constraint.RemoveConstraints( CurrentEnt, "Rope" )
								constraint.RemoveConstraints( CurrentEnt, "Winch" )
							end
						end
						if ( mode <= 8 ) then
							CurrentPhys:EnableMotion( !freeze )
							CurrentPhys:Wake()
						end
					end
				end
			end
		end
		NumApp = NumApp + 1
	end//Next
	if ( mode == 1 ) then
		self:SendMessage( NumApp .. " items targeted for apply." )
	elseif ( mode == 2 ) then
		self:SendMessage( NumApp .. " items targeted for rotate." )
	elseif ( mode == 3 ) then
		self:SendMessage( NumApp .. " items targeted for move." )
	elseif ( mode == 4 ) then
		self:SendMessage( NumApp .. " items targeted for weld." )
	elseif ( mode == 5 ) then
		self:SendMessage( NumApp .. " items targeted for axis." )
	elseif ( mode == 6 ) then
		self:SendMessage( NumApp .. " items targeted for ballsocket." )
	elseif ( mode == 7 ) then
		self:SendMessage( NumApp .. " items targeted for adv. ballsocket." )
	elseif ( mode == 8 ) then
		self:SendMessage( NumApp .. " items targeted for slider." )
	elseif ( mode == 9 ) then
		self:SendMessage( NumApp .. " items targeted for parenting." )
	elseif ( mode == 10 ) then
		self:SendMessage( NumApp .. " items targeted for repair." )
	elseif ( mode == 11 ) then
		self:SendMessage( NumApp .. " items targeted for constraint removal." )
	end
	
	
	if ( mode == 10 ) then
		self.RepairTodo = true
		timer.Simple( 1.0, function()
		self:ClearSelection()
		end)
	else
		self:ClearSelection()
	end
	// Clear the objects so we're ready to go again
	self:ClearObjects()
end

function TOOL:SendMessage( message )
	if ( self:GetClientNumber( "enablefeedback" ) == 0 ) then return end
	if ( self:GetClientNumber( "chatfeedback" ) == 1 ) then
		self:GetOwner():PrintMessage( HUD_PRINTTALK, "Tool: " .. message )
	else
		self:GetOwner():PrintMessage( HUD_PRINTCENTER, message )
	end
end

function TOOL:TargetValidity ( trace, Phys ) //TODO: Parented stuff should return 1
	if ( SERVER && (!util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) || !Phys:IsValid()) ) then
		local mode = self:GetClientNumber( "mode" )
		if ( trace.Entity:GetParent():IsValid() ) then
			return 2//Valid parent, but itself isn't
		else
			return 0//No valid phys
		end
	elseif ( trace.Entity:IsPlayer() ) then
		return 0// Don't attach players, or to players
	elseif ( trace.HitWorld ) then
		return 1// Only allow second click to be here...
	else
		return 3//Everything seems good
	end
end

function TOOL:StartRotate()
	local Ent = self:GetEnt(1)
	local Phys = self:GetPhys(1)
	local oldposu = Ent:GetPos()
	local oldangles = Ent:GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end
	
	if ( self:GetClientNumber( "rotateundo" )) then
		if SERVER then
			undo.Create("Precision_Rotate")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( MoveUndo, Ent, oldposu, oldangles )
			undo.Finish()
		end
	end
	
	if IsValid( Phys ) then
		Phys:EnableMotion( false ) //else it drifts
	end
	
	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	self.axis = self:GetNormal(1)
	self.axisY = self.axis:Cross(Ent:GetUp())
	if self:WithinABit( self.axisY, Vector(0,0,0) ) then
		self.axisY = self.axis:Cross(Ent:GetForward())
	end
	self.axisZ = self.axisY:Cross(self.axis)
	self.realdegrees = 0
	self.lastdegrees = -((rotation/2) % rotation)
	self.realdegreesY = 0
	self.lastdegreesY = -((rotation/2) % rotation)
	self.realdegreesZ = 0
	self.lastdegreesZ = -((rotation/2) % rotation)
	self.OldPos = self:GetPos(1)//trace.HitPos
end

function TOOL:DoMove()
	// Get information we're about to use
	local Norm1, Norm2 = self:GetNormal(1),   self:GetNormal(2)
	local Phys1, Phys2 = self:GetPhys(1),     self:GetPhys(2)
	
	local Ang1, Ang2 = Norm1:Angle(), (Norm2 * -1):Angle()
	if self:GetClientNumber( "autorotate" ) == 1 then
		Ang2.p = (math.Round(Ang2.p/45))*45
		Ang2.r = (math.Round(Ang2.r/45))*45
		Ang2.y = (math.Round(Ang2.y/45))*45
		Norm2 = Ang2:Forward() * -1
	end


	local oldposu = self:GetEnt(1):GetPos()
	local oldangles = self:GetEnt(1):GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end
	if self:GetClientNumber( "moveundo" ) == 1 then
	undo.Create("Precision Move")
		undo.SetPlayer(self:GetOwner())
		undo.AddFunction( MoveUndo, self:GetEnt(1), oldposu, oldangles )
	undo.Finish()
	end

	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	if ( (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2) then//Set axies for rotation mode directions
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
		self.realdegrees = 0
		self.lastdegrees = -((rotation/2) % rotation)
		self.realdegreesY = 0
		self.lastdegreesY = -((rotation/2) % rotation)
		self.realdegreesZ = 0
		self.lastdegreesZ = -((rotation/2) % rotation)
	else
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
	end



	local TargetAngle = Phys1:AlignAngles( Ang1, Ang2 )//Get angle Phys1 would be at if difference between Ang1 and Ang2 was added


	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end

	Phys1:SetAngles( TargetAngle )


	local NewOffset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )
	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	if ( offsetpercent ) then
		local  Ent2  = self:GetEnt(2)
		local glower = Ent2:OBBMins()
		local gupper = Ent2:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(Norm2,Ent2:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(Norm2,Ent2:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end
	Norm2 = Norm2 * (-0.0625 + NewOffset)
	local TargetPos = self:GetPos(2) + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
	//self:SetPos(2)

	// Set the position

	Phys1:SetPos( TargetPos )
	Phys1:EnableMotion( false )

	// Wake up the physics object so that the entity updates
	Phys1:Wake()
end

function TOOL:ToggleColor( CurrentEnt )
	color = CurrentEnt:GetColor()
	color["a"] = color["a"] - 128
	if ( color["a"] < 0 ) then
		color["a"] = color["a"] + 256
	end
	color["r"] = color["r"] - 128
	if ( color["r"] < 0 ) then
		color["r"] = color["r"] + 256
	end
	color["g"] = color["g"] - 128
	if ( color["g"] < 0 ) then
		color["g"] = color["g"] + 256
	end
	color["b"] = color["b"] - 128
	if ( color["b"] < 0 ) then
		color["b"] = color["b"] + 256
	end
	CurrentEnt:SetColor( color )
	if ( color["a"] == 255 ) then
		CurrentEnt:SetRenderMode( 0 )
	else
		CurrentEnt:SetRenderMode( 1 )
	end
end

function TOOL:ClearSelection()
	if ( self.RepairTodo ) then
		self:UndoRepairToggle()
	end
	if ( self.TaggedEnts ) then
		local color
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
		end
	end
	self.TaggedEnts = {}
end

function TOOL:SelectEnts(StartEnt, AllConnected)
	self:ClearSelection()
	if ( CLIENT ) then return end
	local color
	if ( AllConnected == 1 ) then
		local NumApp = 0
		EntsTab = {}
		ConstsTab = {}
		GetAllEnts(StartEnt, self.TaggedEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
			NumApp = NumApp + 1
		end
		self:SendMessage( NumApp .. " objects selected." )
	else
		if ( StartEnt and StartEnt:IsValid() ) then
			local CurrentPhys = StartEnt:GetPhysicsObject()
			if ( CurrentPhys:IsValid() ) then
				table.insert(self.TaggedEnts, StartEnt)
				self:ToggleColor(StartEnt)
			end
		end
	end
	
end

function TOOL:LeftClick( trace )
	local stage = self:GetStage()//0 = started, 1 = moving/second target, 2 = rotation?
	local mode = self:GetClientNumber( "mode" )
	local moving = ( mode == 3 || (self:GetClientNumber( "move" ) == 1 && mode >= 3 && mode <= 8 ) )
	local rotating = ( self:GetClientNumber( "rotate" ) == 1 )
	local Phys = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )

	
	if ( stage == 0 ) then//first click - choose a target.
		if ( self:TargetValidity(trace, Phys) <= 1 ) then
			return false//No phys or hit world
		end
		self:SetObject( 1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )
		
		if (self:GetClientNumber( "entirecontrap" ) == 1 || mode == 10 ) then
			self:SelectEnts(trace.Entity,1)
		else
			self:SelectEnts(trace.Entity,0)
		end
		if ( mode == 1 || mode == 10 || mode == 11 ) then //Don't care about stage, always apply.
			self:DoConstraint(mode)
		else
			if ( mode == 9 ) then
				self:SetStage(1)
			else
				if ( moving ) then//Moving
					self:StartGhostEntity( trace.Entity )
					self:SetStage(1)
				elseif ( mode == 2 ) then//Straight to rotate
					self:StartRotate()
					self:SetStage(2)
				else
					self:SetStage(1)
				end
			end
		end
	elseif ( stage == 1 ) then//Second click
		self:SetObject( 2, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )
		
		if ( self:GetEnt(1) == self:GetEnt(2) ) then
			SavedPos = self:GetPos(2)
		end
		if ( mode == 9 ) then
			self:DoConstraint(mode)
		else
			if ( moving ) then
				if ( CLIENT ) then
					self:ReleaseGhostEntity()
					return true
				end
				if ( SERVER && !game.SinglePlayer() ) then
					self:ReleaseGhostEntity()
					//return true
				end
				self:DoMove()
			end
			if ( rotating ) then
				self:StartRotate()
				self:SetStage(2)
			else
				self:DoConstraint(mode)
			end
		end
	elseif ( stage == 2 ) then//Done rotate
		self:DoConstraint(mode)
	end
	return true
end

function TOOL:WithinABit( v1, v2 )
	local tol = 0.1
	local da = v1.x-v2.x
	local db = v1.y-v2.y
	local dc = v1.z-v2.z
	if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
		return true
	else
		da = v1.x+v2.x
		db = v1.y+v2.y
		dc = v1.z+v2.z
		if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
			return true
		else
			return false
		end
	end
end

if ( SERVER ) then
	
	function GetAllEnts( Ent, OrderedEntList, EntsTab, ConstsTab )
		if ( Ent and Ent:IsValid() ) and ( !EntsTab[ Ent:EntIndex() ] ) then
			EntsTab[ Ent:EntIndex() ] = Ent
			table.insert(OrderedEntList, Ent)
			if ( !constraint.HasConstraints( Ent ) ) then return OrderedEntList end
			for key, ConstraintEntity in pairs( Ent.Constraints ) do
				if ( !ConstsTab[ ConstraintEntity ] ) then
					ConstsTab[ ConstraintEntity ] = true
					local ConstTable = ConstraintEntity:GetTable()
					for i=1, 6 do
						local e = ConstTable[ "Ent"..i ]
						if ( e and e:IsValid() ) and ( !EntsTab[ e:EntIndex() ] ) then
							GetAllEnts( e, OrderedEntList, EntsTab, ConstsTab )
						end
					end
				end
			end
		end
		return OrderedEntList
	end
	
	function GetAllConstraints( EntsTab )
		local ConstsTab = {}
		for key, Ent in pairs( EntsTab ) do
			if ( Ent and Ent:IsValid() ) then
				local MyTable = constraint.GetTable( Ent )
				for key, Constraint in pairs( MyTable ) do
					if ( !ConstsTab[ Constraint.Constraint ] ) then
						ConstsTab[ Constraint.Constraint ] = Constraint
					end
				end
			end
		end
		return ConstsTab
	end
end

function TOOL:UpdateCustomGhost( ghost, player, offset )
	
	// Ghost is identically buggy to that of easyweld...  welding two frozen props and two unfrozen props yields different ghosts even if identical allignment

	if (ghost == nil) then return end
	if (!ghost:IsValid()) then ghost = nil return end

	local tr = util.GetPlayerTrace( player, player:GetAimVector() )
	local trace = util.TraceLine( tr )
	if (!trace.Hit) then return end

	local Ang1, Ang2 = self:GetNormal(1):Angle(), (trace.HitNormal * -1):Angle()
	local TargetAngle = self:GetEnt(1):AlignAngles( Ang1, Ang2 )

	self.GhostEntity:SetPos( self:GetEnt(1):GetPos() )
	
	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end
	self.GhostEntity:SetAngles( TargetAngle )

	local TraceNormal = trace.HitNormal

	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(TraceNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x) -0.5
		elseif self:WithinABit(TraceNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y) -0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end

	local TranslatedPos = ghost:LocalToWorld( self:GetLocalPos(1) )
	local TargetPos = trace.HitPos + (self:GetEnt(1):GetPos() - TranslatedPos) + (TraceNormal*NewOffset)

	self.GhostEntity:SetPos( TargetPos )
end


function TOOL:Think()
	//if CLIENT then return end
	local pl = self:GetOwner()
	local wep = pl:GetActiveWeapon()
	if not wep:IsValid() or wep:GetClass() != "gmod_tool" or pl:GetInfo("gmod_toolmode") != "precision" then return end
		
	if (self:NumObjects() < 1) then return end
	local Ent1 = self:GetEnt(1)
	if ( SERVER ) then
		if ( !Ent1:IsValid() ) then
			self:ClearObjects()
			return
		end
	end
	local mode = self:GetClientNumber( "mode" )

	if self:NumObjects() == 1 && mode != 2 then
		if ( (self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
			if ( mode <= 8 ) then//no move = no ghost in parent mode
				local offset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )
				self:UpdateCustomGhost( self.GhostEntity, self:GetOwner(), offset )
			end
		end
	else
		local rotate = (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2
		if ( SERVER && rotate && mode <= 8 ) then
			local offset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )

			local Phys1 = self:GetPhys(1)

			local cmd = self:GetOwner():GetCurrentCommand()

			local rotation		= self:GetClientNumber( "rotation" )
			if ( rotation < 0.02 ) then rotation = 0.02 end
			local degrees = cmd:GetMouseX() * 0.02

			local newdegrees = 0
			local changedegrees = 0

			local angle = 0
			if( self:GetOwner():KeyDown( IN_RELOAD ) ) then
				self.realdegreesY = self.realdegreesY + degrees
				newdegrees =  self.realdegreesY - ((self.realdegreesY + (rotation/2)) % rotation)
				changedegrees = self.lastdegreesY - newdegrees
				self.lastdegreesY = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisY , changedegrees )
			elseif( self:GetOwner():KeyDown( IN_ATTACK2 ) ) then
				self.realdegreesZ = self.realdegreesZ + degrees
				newdegrees =  self.realdegreesZ - ((self.realdegreesZ + (rotation/2)) % rotation)
				changedegrees = self.lastdegreesZ - newdegrees
				self.lastdegreesZ = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisZ , changedegrees )
			else
				self.realdegrees = self.realdegrees + degrees
				newdegrees =  self.realdegrees - ((self.realdegrees + (rotation/2)) % rotation)
				changedegrees = self.lastdegrees - newdegrees
				self.lastdegrees = newdegrees
				angle = Phys1:RotateAroundAxis( self.axis , changedegrees )
			end
			Phys1:SetAngles( angle )

			if ( ( self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
				local WPos2 = self:GetPos(2)
				local Ent2 = self:GetEnt(2)
				// Move so spots join up
				local Norm2 = self:GetNormal(2)

				local NewOffset = offset
				local offsetpercent	= self:GetClientNumber( "offsetpercent" ) == 1
				if ( offsetpercent ) then
					local glower = Ent2:OBBMins()
					local gupper = Ent2:OBBMaxs()
					local height = math.abs(gupper.z - glower.z) -0.5
					if self:WithinABit(Norm2,Ent2:GetForward()) then
						height = math.abs(gupper.x - glower.x) -0.5
					elseif self:WithinABit(Norm2,Ent2:GetRight()) then
						height = math.abs(gupper.y - glower.y) -0.5
					end
					NewOffset = NewOffset / 100
					NewOffset = NewOffset * height
				end

				Norm2 = Norm2 * (-0.0625 + NewOffset)
				local TargetPos = Vector(0,0,0)
				if ( self:GetEnt(1) == self:GetEnt(2) ) then
	//////////////////////////////////////////
					TargetPos = SavedPos + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				else
					TargetPos = WPos2 + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				end
				Phys1:SetPos( TargetPos )
			else
				// Move so rotating on axis

				local TargetPos = (Phys1:GetPos() - self:GetPos(1)) + self.OldPos
				Phys1:SetPos( TargetPos )
			end
			Phys1:Wake()
		end
	end
end

function TOOL:Nudge( trace, direction )
	if (!trace.Entity:IsValid() || trace.Entity:IsPlayer() ) then return false end
	local Phys1 = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )
	local offsetpercent		= self:GetClientNumber( "nudgepercent" ) == 1
	local offset		= self:GetClientNumber( "nudge", 100 )
	local max = 8192
	if ( offsetpercent != 1 ) then
		if ( offset > max ) then
			offset = max
		elseif ( offset < -max ) then
			offset = -max
		end
	end
	//if ( offset == 0 ) then offset = 1 end
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(trace.HitNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(trace.HitNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		local cap = math.floor(max / height)//No more than max units.
		if ( NewOffset > cap ) then
			NewOffset = cap
		elseif ( NewOffset < -cap ) then
			NewOffset = -cap
		end
		NewOffset = NewOffset * height
	end

	if ( self:GetClientNumber( "entirecontrap" ) == 1 ) then
		local NumApp = 0
		local TargetEnts = {}
		local EntsTab = {}
		local ConstsTab = {}
		GetAllEnts(trace.Entity, TargetEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(TargetEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then

					/*if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
						local oldpos = CurrentPhys:GetPos()
						local function NudgeUndo( Undo, Entity, oldpos )
							if CurrentEnt:IsValid() then
								CurrentEnt:SetPos( oldpos )
							end
						end
						undo.Create("Nrecision Nudge")
							undo.SetPlayer(self:GetOwner())
							undo.AddFunction( NudgeUndo, CurrentEnt, oldpos )
						undo.Finish()
					end*/// todo: all in 1 undo for mass nudging

					local TargetPos = CurrentPhys:GetPos() + trace.HitNormal * NewOffset * direction
					CurrentPhys:SetPos( TargetPos )
					CurrentPhys:Wake()
					if (CurrentEnt:GetMoveType() == 0 ) then //phys disabled, so move manually
						CurrentEnt:SetPos( TargetPos )
					end

				end
			end
			NumApp = NumApp + 1
		end
		if ( direction == -1 ) then
			self:SendMessage( NumApp .. " items pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( NumApp .. " items pulled." )
		else
			self:SendMessage( NumApp .. " items nudged." )
		end
	else
		if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
			local oldpos = Phys1:GetPos()
			local function NudgeUndo( Undo, Entity, oldpos )
				if trace.Entity:IsValid() then
					trace.Entity:SetPos( oldpos )
				end
			end
			undo.Create("Precision PushPull")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( NudgeUndo, trace.Entity, oldpos )
			undo.Finish()
		end
		local TargetPos = Phys1:GetPos() + trace.HitNormal * NewOffset * direction
		Phys1:SetPos( TargetPos )
		Phys1:Wake()
		if ( trace.Entity:GetMoveType() == 0 ) then
			trace.Entity:SetPos( TargetPos )
		end
		if ( direction == -1 ) then
			self:SendMessage( "target pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( "target pulled." )
		else
			self:SendMessage( "target nudged." )
		end
	end
	return true
end

function TOOL:RightClick( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, -1 )
	end
end

function TOOL:Reload( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, 1 )
	end
end

if CLIENT then

	language.Add( "Tool.precision.name", "Precision Tool 0.98e" )
	language.Add( "Tool.precision.desc", "Accurately moves/constrains objects" )
	language.Add( "Tool.precision.0", "Primary: Move/Apply | Secondary: Push | Reload: Pull" )
	language.Add( "Tool.precision.1", "Target the second item. If enabled, this will move the first item.  (Swap weps to cancel)" )
	language.Add( "Tool.precision.2", "Rotate enabled: Turn left and right to rotate the object (Hold Reload or Secondary for other rotation directions!)" )


	language.Add("Undone.precision", "Undone Precision Constraint")
	language.Add("Undone.precision.nudge", "Undone Precision PushPull")
	language.Add("Undone.precision.rotate", "Undone Precision Rotate")
	language.Add("Undone.precision.move", "Undone Precision Move")
	language.Add("Undone.precision.weld", "Undone Precision Weld")
	language.Add("Undone.precision.axis", "Undone Precision Axis")
	language.Add("Undone.precision.ballsocket", "Undone Precision Ballsocket")
	language.Add("Undone.precision.advanced.ballsocket", "Undone Precision Advanced Ballsocket")
	language.Add("Undone.precision.slider", "Undone Precision Slider")

	local showgenmenu = 0//Seems to hide often, probably for the best

	local function AddDefControls( Panel )
		Panel:ClearControls()

		Panel:AddControl("ComboBox",
		{
			Label = "#Presets",
			MenuButton = 1,
			Folder = "precision",
			Options = {},
			CVars =
			{
				[0] = "precision_offset",
				[1] = "precision_forcelimit",
				[2] = "precision_freeze",
				[3] = "precision_nocollide",
				[4] = "precision_nocollideall",
				[5] = "precision_rotation",
				[6] = "precision_rotate",
				[7] = "precision_torquelimit",
				[8] = "precision_friction",
				[9] = "precision_mode",
				[10] = "precision_width",
				[11] = "precision_offsetpercent",
				[12] = "precision_removal",
				[13] = "precision_move",
				[14] = "precision_physdisable",
				[15] = "precision_advballsocket",
				[16] = "precision_XRotMin",
				[17] = "precision_XRotMax",
				[18] = "precision_YRotMin",
				[19] = "precision_YRotMax",
				[20] = "precision_ZRotMin",
				[21] = "precision_ZRotMax",
				[22] = "precision_XRotFric",
				[23] = "precision_YRotFric",
				[24] = "precision_ZRotFric",
				[25] = "precision_FreeMov",
				[26] = "precision_ShadowDisable",
				[27] = "precision_allowphysgun",
				[28] = "precision_autorotate",
				[29] = "precision_massmode",
				[30] = "precision_nudge",
				[31] = "precision_nudgepercent",
				[32] = "precision_disablesliderfix"
			}
		})

		//Panel:AddControl( "Label", { Text = "Secondary attack pushes, Reload pulls by this amount:", Description	= "Phx 1x is 47.45, Small tiled cube is 11.8625 and thin is 3 exact units" }  )
		Panel:AddControl( "Slider",  { Label	= "Push/Pull Amount",
					Type	= "Float",
					Min		= 1,
					Max		= 100,
					Command = "precision_nudge",
					Description = "Distance to push/pull props with altfire/reload"}	 ):SetDecimals( 4 )


		Panel:AddControl( "Checkbox", { Label = "Push/Pull as Percent (%) of target's depth", Command = "precision_nudgepercent", Description = "Unchecked = Exact units, Checked = takes % of width from target prop when pushing/pulling" } )


		local user = LocalPlayer():GetInfoNum( "precision_user", 0 )
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 0 )
		//Panel:AddControl( "Label", { Text = "Primary attack uses the tool's main mode.", Description	= "Select a mode and configure the options, be sure to try new things out!" }  )

		local list = vgui.Create("DListView")

		//17 per item + 16 for title
		local height = 203 //All 11 shown
		if ( user < 2 ) then
			height = 135 //7 shown
		elseif ( user < 3 ) then
			height = 170 //9 shown
		end
		

		list:SetSize(30,height)
		//list:SizeToContents()
		list:AddColumn("Tool Mode")
		list:SetMultiSelect(false)
		function list:OnRowSelected(LineID, line)
			if not (mode == LineID) then
				RunConsoleCommand("precision_setmode", LineID)
			end
		end

		if ( mode == 1 ) then
			list:AddLine(" 1 ->Apply<- (Directly apply settings to target)")
		else
			list:AddLine(" 1   Apply   (Directly apply settings to target)")
		end
		if ( mode == 2 ) then
			list:AddLine(" 2 ->Rotate<- (Turn an object without moving it)")
		else
			list:AddLine(" 2   Rotate   (Turn an object without moving it)")
		end
		if ( mode == 3 ) then
			list:AddLine(" 3 ->Move<- (Snap objects together - Great for building!)")
		else
			list:AddLine(" 3   Move   (Snap objects together - Great for building!)")
		end
		if ( mode == 4 ) then
			list:AddLine(" 4 ->Weld<-")
		else
			list:AddLine(" 4   Weld")
		end
		if ( mode == 5 ) then
			list:AddLine(" 5 ->Axis<-")
		else
			list:AddLine(" 5   Axis")
		end
		if ( mode == 6 ) then
			list:AddLine(" 6 ->Ballsocket<-")
		else
			list:AddLine(" 6   Ballsocket")
		end
		if ( user >= 2 ) then
			if ( mode == 7 ) then
				list:AddLine(" 7 ->Adv Ballsocket<-")
			else
				list:AddLine(" 7   Adv Ballsocket")
			end
			if ( mode == 8 ) then
				list:AddLine(" 8 ->Slider<-")
			else
				list:AddLine(" 8   Slider")
			end
		end
		if ( user >= 3 ) then
			if ( mode == 9 ) then
				list:AddLine(" 9 ->Parent<- (Like a solid weld, but without object collision)")
			else
				list:AddLine(" 9   Parent   (Like a solid weld, but without object collision)")
			end
			if ( mode == 10 ) then
				list:AddLine("10 ->Repair<- (Attempts to fix a flailing contraption)")
			else
				list:AddLine("10   Repair   (Attempts to fix a flailing contraption)")
			end
		end
		if ( mode == 11 ) then
			list:AddLine("11 ->Removal<- (Undoes constraints from target)")
		else
			list:AddLine("11   Removal   (Undoes constraints from target)")
		end
		list:SortByColumn(1)
		Panel:AddItem(list)

		if ( mode >= 4 && mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Move Target? ('Easy' constraint mode)", Command = "precision_move", Description = "Uncheck this to apply the constraint without altering positions." } )
		end
		if (  mode >= 3 && mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Rotate Target? (Rotation after moving)", Command = "precision_rotate", Description = "Uncheck this to remove the extra click for rotation. Handy for speed building." } )
			//Panel:AddControl( "Label", { Text = "This is the distance from touching of the targeted props after moving:", Description	= "Use 0 mostly, % takes the second prop's width." }  )
			Panel:AddControl( "Slider",  { Label	= "Snap Distance",
					Type	= "Float",
					Min		= 0,
					Max		= 10,
					Command = "precision_offset",
					Description = "Distance offset between joined props.  Type in negative to inset when moving."}	 )
			Panel:AddControl( "Checkbox", { Label = "Snap distance as Percent (%) of target's depth", Command = "precision_offsetpercent", Description = "Unchecked = Exact units, Checked = takes % of width from second prop" } )
		end
		if ( mode >= 2 && mode <= 8 ) then
			Panel:AddControl( "Slider",  { Label	= "Rotation Snap (Degrees)",
					Type	= "Float",
					Min		= 0.02,
					Max		= 90,
					Command = "precision_rotation",
					Description = "Rotation rotates by this amount at a time. No more guesswork. Min: 0.02 degrees "}	 ):SetDecimals( 4 )
		end
		if ( mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Freeze Target", Command = "precision_freeze", Description = "Freeze props when this tool is used" } )

			if ( mode >= 3 && mode <= 8 ) then
				Panel:AddControl( "Checkbox", { Label = "No Collide Targets", Command = "precision_nocollide", Description = "Nocollide pairs of props when this tool is used. Note: No current way to remove this constraint when used alone."  } )
			end
		end

		if ( user >= 2 || mode == 1 ) then
			if ( (mode >= 3 && mode <= 8) || mode == 1 ) then
				Panel:AddControl( "Checkbox", { Label = "Auto-align to world (nearest 45 degrees)", Command = "precision_autorotate", Description = "Rotates to the nearest world axis (similar to holding sprint and use with physgun)"  } )
			end

			if ( mode == 1 ) then
				Panel:AddControl( "Checkbox", { Label = "Disable target shadow", Command = "precision_ShadowDisable", Description = "Disables shadows cast from the prop"  } )
			end
		end

		if ( user >= 3 ) then
			if ( mode == 1 ) then //apply
				Panel:AddControl( "Checkbox", { Label = "Only Collide with Player", Command = "precision_nocollideall", Description = "Nocollides the first prop to everything and the world (except players collide with it). Warning: don't let it fall away through the world."  } )
				Panel:AddControl( "Checkbox", { Label = "Disable Physics on object", Command = "precision_physdisable", Description = "Disables physics on the first prop (gravity, being shot etc won't effect it)"  } )
				Panel:AddControl( "Checkbox", { Label = "Adv: Allow Physgun on PhysDisable objects", Command = "precision_allowphysgun", Description = "Disabled to stop accidents, use if you want to be able to manually move props after phyics disabling them (may break clipboxes)."  } )
				
				//Panel:AddControl( "Checkbox", { Label = "Drag", Command = "precision_drag", Description = ""  } )
			end
			if ( mode == 9 ) then //parent
				Panel:AddControl( "Checkbox", { Label = "Adv: Allow Physgun on Parented objects", Command = "precision_allowphysgun", Description = "Disabled to stop accidents, use this if you want to play with the parenting hierarchy etc."  } )
			end
		end
		if ( user >= 2 ) then
			if ( mode != 2 && mode != 3 && mode != 10 ) then //todo: entire contrap move/rotate support
				Panel:AddControl( "Checkbox", { Label = "Entire Contraption! (Everything connected to target)", Command = "precision_entirecontrap", Description = "For mass constraining or removal or nudging or applying of things. Yay generic."  } )
			end
		end

		if ( user >= 2 ) then
			if ( (mode >= 4 && mode <= 7) ) then //breakable constraint
				Panel:AddControl( "Slider",  { Label	= "Force Breakpoint",
						Type	= "Float",
						Min		= 0.0,
						Max		= 5000,
						Command = "precision_forcelimit",
						Description = "Applies to most constraint modes" }	 )
			end


			if ( mode == 5 || mode == 6 || mode == 7 ) then //axis or ballsocket
				Panel:AddControl( "Slider",  { Label	= "Torque Breakpoint",
						Type	= "Float",
						Min		= 0.0,
						Max		= 5000,
						Command = "precision_torquelimit",
						Description = "Breakpoint of turning/rotational force"}	 )
			end
		end

		if ( mode == 5 ) then //axis
			Panel:AddControl( "Slider",  { Label	= "Axis Friction",
					Type	= "Float",
					Min		= 0.0,
					Max		= 100,
					Command = "precision_friction",
					Description = "Turning resistance, this is best at 0 in most cases to conserve energy"}	 )
		end

		if ( mode ==7 ) then //adv ballsocket
			Panel:AddControl( "Slider",  { Label	= "X Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_XRotMin",
					Description = "Rotation minimum of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "X Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_XRotMax",
					Description = "Rotation maximum of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_YRotMin",
					Description = "Rotation minimum of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_YRotMax",
					Description = "Rotation maximum of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_ZRotMin",
					Description = "Rotation minimum of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_ZRotMax",
					Description = "Rotation maximum of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "X Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_XRotFric",
					Description = "Rotation friction of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_YRotFric",
					Description = "Rotation friction of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_ZRotFric",
					Description = "Rotation friction of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Checkbox", { Label = "Free Movement", Command = "precision_FreeMov", Description = "Only lock relative rotation, not position?"  } )
		end

		if ( mode == 8 ) then //slider
			Panel:AddControl( "Slider",  { Label	= "Slider Width",
					Type	= "Float",
					Min		= 0.0,
					Max		= 10,
					Command = "precision_width",
					Description = "Width of the slider black line (0 = invisible)"}	 )

			Panel:AddControl( "Checkbox", { Label = "Turn Off Minor Slider Stabilisation", Command = "precision_disablesliderfix", Description = "Fix being separate X/Y/Z advanced ballsocket locks between the props.  This stops most spaz caused by rotation, but not spaz caused by displacement." } )
			Panel:AddControl( "Label", { Text = "Stabilisation is separate X/Y/Z adv. ballsockets; it makes it far less prone to rotation triggered spaz, but the difference is only noticeable sometimes as it's still just as prone to spaz caused by drifting.", Description	= "Due to lack of working descriptions at time of coding" }  )
		end

		if ( mode == 9 ) then //parent
			Panel:AddControl( "Label", { Text = "Parenting Notes:", Description	= "Due to lack of working descriptions at time of coding" }  )
			Panel:AddControl( "Label", { Text = "Parenting objects is most similar to a very strong weld, but it stops most interaction on the first object when you attach it to the second.  Players can walk on it, but it will fall through players.  It will not collide with objects or the world.  It will also not cause any extra physics lag/spaz.  Try it out on a test object, and decide if it's useful to you!", Description	= "Due to lack of working descriptions at time of coding" }  )

			Panel:AddControl( "Label", { Text = "Parented objects are most useful for: Adding detail to moving objects without creating extra physics lag.  Things like houses that you want to move (though you can only safely walk on parented objects when they are still.)", Description	= "Due to lack of working descriptions at time of coding" }  )

			Panel:AddControl( "Label", { Text = "Possible issues:  Remove constraints first to avoid spaz. Duplicating or such may cause the collision model to become separated.  Best to test it if in doubt.", Description	= "Why must labels cause menu flicker? D:" }  )
		end
		
		if ( mode == 10 ) then //repair
			Panel:AddControl( "Label", { Text = "Repair mode", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "Usage: When a contraption is going crazy, colliding, making rubbing noises.", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "What it does: Temporarily toggles collisions, allowing things that are bent out of shape to pop back.", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "Warning: No guarantees.  This may turn things inside-out or make things worse depending on the situation.", Description	= "" }  )
		end
		if ( mode == 11 ) then //removal
			Panel:AddControl( "Label", { Text = "This mode will remove:", Description	= "" }  )
			Panel:AddControl( "Checkbox", { Label = "Nocollide", Command = "precision_removal_nocollide", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Weld", Command = "precision_removal_weld", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Axis", Command = "precision_removal_axis", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Ballsocket", Command = "precision_removal_ballsocket", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Adv. Ballsocket", Command = "precision_removal_advballsocket", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Slider", Command = "precision_removal_slider", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Parent", Command = "precision_removal_parent", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Other", Command = "precision_removal_other", Description = "" } )
			Panel:AddControl( "Label", { Text = "(Other = Rope/slider variants like winch/hydraulic, also motor/keepupright)", Description	= "" }  )
			Panel:AddControl( "Button", { Label = "Select All", Command = "precision_removal_all", Description = ""  } )
			Panel:AddControl( "Button", { Label = "Select None", Command = "precision_removal_none", Description = ""  } )

		end
		if ( showgenmenu == 1 ) then
			Panel:AddControl( "Button", { Label = "\\/ General Tool Options \\/", Command = "precision_generalmenu", Description = "Collapse menu"  } )




		local params = {Label = "User Level",Description = "Shows options appropriate to user experience level", MenuButton = "0", Height = 67, Options = {}}
		if ( user == 1 ) then
			params.Options[" 1 ->Normal<-"] = { precision_setuser = "1" }
		else
			params.Options[" 1   Normal"] = { precision_setuser = "1" }
		end
		if ( user == 2 ) then
			params.Options[" 2 ->Advanced<-"] = { precision_setuser = "2" }
		else
			params.Options[" 2   Advanced"] = { precision_setuser = "2" }
		end
		if ( user == 3 ) then
			params.Options[" 3 ->Experimental<-"] = { precision_setuser = "3" }
		else
			params.Options[" 3   Experimental"] = { precision_setuser = "3" }
		end

		Panel:AddControl( "ListBox", params )

			//Panel:AddControl( "Label", { Text = "General Tool Options:", Description	= "Note: These don't save with presets." }  )
			Panel:AddControl( "Checkbox", { Label = "Enable tool feedback messages?", Command = "precision_enablefeedback", Description = "Toggle for feedback messages incase they get annoying"  } )
			Panel:AddControl( "Checkbox", { Label = "On = Feedback in Chat, Off = Centr Scrn", Command = "precision_chatfeedback", Description = "Chat too cluttered? Can have messages centre screen instead"  } )
			//Panel:AddControl( "Checkbox", { Label = "Hide Menu Tips?", Command = "precision_hidehints", Description = "Streamline the menu once you're happy with using the tool."  } )
			Panel:AddControl( "Checkbox", { Label = "Add Push/Pull to Undo List", Command = "precision_nudgeundo", Description = "For if you're in danger of nudging somthing to where you can't reach it"  } )
			Panel:AddControl( "Checkbox", { Label = "Add Movement to Undo List", Command = "precision_moveundo", Description = "So you don't have to secondary fire with nocollide to undo mistakes"  } )
			Panel:AddControl( "Checkbox", { Label = "Add Rotation to Undo List", Command = "precision_rotateundo", Description = "So you can find the exact rotation value easier"  } )
			Panel:AddControl( "Button", { Label = "Restore Current Mode Default", Command = "precision_defaultrestore", Description = "Collapse menu"  } )
		else
			Panel:AddControl( "Button", { Label = "-- General Tool Options --", Command = "precision_generalmenu", Description = "Expand menu"  } )
			if ( user == 1 ) then
				Panel:AddControl( "Label", { Text = "(Note: For more modes and options like slider, use this options button and change the user level)", Description = "" }  )
			end
		end
	end



	local function precision_defaults()
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 3 )
		if mode  == 1 then
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_ShadowDisable", "0")
			RunConsoleCommand("precision_nocollideall", "0")
			RunConsoleCommand("precision_physdisable", "0")
			RunConsoleCommand("precision_allowphysgun", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 2 then
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 3 then
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 4 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
		elseif mode == 5 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
			RunConsoleCommand("precision_friction", "0")
		elseif mode == 6 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
		elseif mode == 7 then
			RunConsoleCommand("precision_move", "0")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
			RunConsoleCommand("precision_XRotMin", "0")
			RunConsoleCommand("precision_XRotMax", "0")
			RunConsoleCommand("precision_YRotMin", "0")
			RunConsoleCommand("precision_YRotMax", "0")
			RunConsoleCommand("precision_ZRotMin", "0")
			RunConsoleCommand("precision_ZRotMax", "0")
			RunConsoleCommand("precision_XRotFric", "0")
			RunConsoleCommand("precision_YRotFric", "0")
			RunConsoleCommand("precision_ZRotFric", "0")
			RunConsoleCommand("precision_FreeMov", "1")
		elseif mode == 8 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "0")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_width", "1")
			RunConsoleCommand("precision_disablesliderfix", "0")
		elseif mode == 9 then
			RunConsoleCommand("precision_allowphysgun", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_defaultrestore", precision_defaults )

	local function precision_genmenu()
		if ( showgenmenu == 1 ) then
			showgenmenu = 0
		else
			showgenmenu = 1
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_generalmenu", precision_genmenu )
	

	function precision_setmode( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_mode", 3 ) != args[1] then
			RunConsoleCommand("precision_mode", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setmode", precision_setmode )


	function precision_setuser( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_user", 3 ) != args[1] then
			RunConsoleCommand("precision_user", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setuser", precision_setuser )


	function precision_updatecpanel()
		local Panel = controlpanel.Get( "precision" )
		if (!Panel) then return end
		//custom panel building ( wtf does Panel:AddDefaultControls() get it's defaults from? )
		AddDefControls( Panel )
	end
	concommand.Add( "precision_updatecpanel", precision_updatecpanel )

	function TOOL.BuildCPanel( Panel )
		AddDefControls( Panel )
	end

	local function precision_removalall()
		RunConsoleCommand("precision_removal_nocollide", "1")
		RunConsoleCommand("precision_removal_weld", "1")
		RunConsoleCommand("precision_removal_axis", "1")
		RunConsoleCommand("precision_removal_ballsocket", "1")
		RunConsoleCommand("precision_removal_advballsocket", "1")
		RunConsoleCommand("precision_removal_slider", "1")
		RunConsoleCommand("precision_removal_parent", "1")
		RunConsoleCommand("precision_removal_other", "1")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_all", precision_removalall )
	local function precision_removalnone()
		RunConsoleCommand("precision_removal_nocollide", "0")
		RunConsoleCommand("precision_removal_weld", "0")
		RunConsoleCommand("precision_removal_axis", "0")
		RunConsoleCommand("precision_removal_ballsocket", "0")
		RunConsoleCommand("precision_removal_advballsocket", "0")
		RunConsoleCommand("precision_removal_slider", "0")
		RunConsoleCommand("precision_removal_parent", "0")
		RunConsoleCommand("precision_removal_other", "0")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_none", precision_removalnone )

	function TOOL:FreezeMovement()
		local stage = self:GetStage()
		if ( stage == 2 ) then
			return true
		//elseif ( iNum > 0 && self:GetClientNumber("mode") == 2 ) then
		//	return true
		end
		return false
	end
end

function TOOL:Holster()
	self:ClearObjects()
	self:SetStage(0)
	self:ClearSelection()
end
--PATH addons/sl_utils/lua/weapons/gmod_tool/stools/stacker_improved.lua:
--[[--------------------------------------------------------------------------
	Improved Stacker Tool

	Note:
		Please DO NOT reupload this tool (verbatim or small tweaks) to the workshop or other public file-sharing websites.
		I actively maintain this tool, so reuploading it may lead to people using outdated, buggy, or malicious copies.
		If there is an issue with the tool, LET ME KNOW via one of the following pages:
		
		- GitHub:    https://github.com/Mista-Tea/improved-stacker
		- Workshop:  http://steamcommunity.com/sharedfiles/filedetails/?id=264467687
		- Facepunch: https://facepunch.com/showthread.php?t=1399120
	
	Author:
		- Original            :: OverloadUT (STEAM_0:1:5250809)
		- Updated for GMod 13 :: Marii      (STEAM_0:1:16015332)
		- Rewritten           :: Mista Tea  (STEAM_0:0:27507323)
	
	Changelog:
		- May 27th, 2014 :: Added to GitHub 
		- May 28th, 2014 :: Added to Workshop 
		- Jun 5th,  2014 :: Massive overhaul 
		- Jul 24th, 2014 :: Large update 
		- Aug 12th, 2014 :: Optimizations 
		- Jun 30th, 2015 :: Bug fixes/features 
		- Jul 11th, 2015 :: Bug fixes 
		- Oct 26th, 2015 :: Bug fixes
		- Aug 3rd,  2016 :: Bug fixes
		- Aug 31st, 2016 :: Bug fixes
		- Sep 2nd,  2016 :: Added Bulgarian language support
		- Sep 26th, 2017 :: Added ability to toggle use of SHIFT key with LMB/RMB
		- Oct 27th, 2017 :: Small client optimization, reverted nocollide implementation back to original
		- Apr 14th, 2018 :: Added French language support
		- Oct 12th, 2018 :: Added Polish language support
		- Jul 21st, 2019 :: Added Russian language support
		- Jul 23rd, 2019 :: Added Simplified Chinese language support
		- May 10th, 2020 :: Fixed unstable clientside ghosts caused by ents.CreateClientProp changes
		- Jun 18th, 2020 :: Clientside performance improvement when tool is not selected
		- Apr 30th, 2021 :: Added German language support
		
		Fixes:
			- Prevented crash from players using very high X/Y/Z offset values.
			- Prevented crash from players using very high P/Y/R rotate values.
			- Prevented crash from very specific constraint settings.
			- Fixed the halo option for ghosted props not working.
			- Fixed massive FPS drop from halos being rendered in a Think hook instead of a PreDrawHalos hook.
			- Fixed materials and color saving when duping stacked props.
			- Fixed incorrect stack angles when trying to create a stack on an existing stack.
			
		Tweaks:
			- Added convenience functions to retrieve the client convars.
			- Added option to enable/disable automatically applying materials to the stacked props.
			- Added option to enable/disable automatically applying colors to the stacked props.
			- Added option to enable/disable automatically applying physical properties (gravity, physics material, weight) to the stacked props.
			- Added support for props with multiple skins.
			- Added support for external prop protections/anti-spam addons with the StackerEntity hook.
			- Modified NoCollide to actually no-collide each stacker prop with every other prop in the stack.
			
			- Added console variables for server operators to limit various parts of stacker.
				> stacker_improved_max_per_player         <-inf/inf> (less than 0 == no limit)
				> stacker_improved_max_per_stack          <-inf/inf> (less than 0 == no limit)
				> stacker_improved_max_offsetx            <-inf/inf>
				> stacker_improved_max_offsety            <-inf/inf>
				> stacker_improved_max_offsetz            <-inf/inf>
				> stacker_improved_force_stayinworld         <0/1>
				> stacker_improved_force_weld                <0/1>
				> stacker_improved_force_freeze              <0/1>
				> stacker_improved_force_nocollide           <0/1>
				> stacker_improved_force_nocollide_all       <0/1>
				> stacker_improved_delay                     <0/inf>

			- Added console commands for server admins to control the console variables that limit stacker.
				> stacker_improved_set_max_per_player     <-inf/inf> (less than 0 == no limit)
				> stacker_improved_set_max_per_stack      <-inf/inf> (less than 0 == no limit)
				> stacker_improved_set_maxoffset          <-inf/inf>
				> stacker_improved_set_maxoffsetx         <-inf/inf>
				> stacker_improved_set_maxoffsety         <-inf/inf>
				> stacker_improved_set_maxoffsetz         <-inf/inf>
				> stacker_improved_set_force_stayinworld     <0/1>
				> stacker_improved_set_weld                  <0/1>
				> stacker_improved_set_freeze                <0/1>
				> stacker_improved_set_nocollide             <0/1>
				> stacker_improved_set_nocollide_all         <0/1>
				> stacker_improved_set_delay                 <0/inf>

----------------------------------------------------------------------------]]

local mode = TOOL.Mode -- defined by the name of this file (default should be stacker_improved)

--[[--------------------------------------------------------------------------
-- Modules & Dependencies
--------------------------------------------------------------------------]]--

-- needed for localization support (depends on GMod locale: "gmod_language")
include( "improvedstacker/localify.lua" )
localify.LoadSharedFile( "improvedstacker/localization.lua" ) -- loads the file containing localized phrases
local L = localify.Localize                                   -- used for translating string tokens into localized phrases
local prefix = "#tool."..mode.."."                            -- prefix used for this tool's localization tokens

-- needed for various stacker functionality
include( "improvedstacker/improvedstacker.lua" )
improvedstacker.Initialize( mode )

--[[--------------------------------------------------------------------------
-- Localized Functions & Variables
--------------------------------------------------------------------------]]--

-- localizing global functions/tables is an encouraged practice that improves code efficiency,
-- since accessing a local value is considerably faster than a global value
local bit = bit
local cam = cam
local net = net
local util = util
local math = math
local undo = undo
local halo = halo
local game = game
local ents = ents
local draw = draw
local hook = hook
local list = list
local pairs = pairs
local table = table
local Angle = Angle
local Color = Color
local render = render
local Vector = Vector
local tobool = tobool
local CurTime = CurTime
local surface = surface
local IsValid = IsValid
local localify = localify
local language = language
local tonumber = tonumber
local GetConVar = GetConVar
local construct = construct
local duplicator = duplicator
local constraint = constraint
local concommand = concommand
local LocalPlayer = LocalPlayer
local CreateConVar = CreateConVar
local improvedstacker = improvedstacker
local GetConVarNumber = GetConVarNumber
local RunConsoleCommand = RunConsoleCommand

local IN_USE = IN_USE
local NOTIFY_ERROR = NOTIFY_ERROR or 1
local MOVETYPE_NONE = MOVETYPE_NONE
local SOLID_VPHYSICS = SOLID_VPHYSICS
local RENDERMODE_TRANSALPHA = RENDERMODE_TRANSALPHA

local TRANSPARENT = Color( 255, 255, 255, 150 )

local MIN_NOTIFY_BITS = 3 -- the minimum number of bits needed to send a NOTIFY enum
local NOTIFY_DURATION = 5 -- the number of seconds to display notifications

local MAX_ANGLE = 180

local showSettings = false

--[[--------------------------------------------------------------------------
-- Tool Settings
--------------------------------------------------------------------------]]--

TOOL.Category = "Construction"
TOOL.Name     = L(prefix.."name")

TOOL.Information = {
	"left",
	"right",
	{ 
		name  = "shift_left",
		icon2  = "gui/e.png",
		icon = "gui/lmb.png",
		
	},
	{
		name  = "shift_right",
		icon2  = "gui/e.png",
		icon = "gui/rmb.png",
	},
	"reload",
}

if ( CLIENT ) then

	TOOL.ClientConVar[ "mode" ]          = improvedstacker.MODE_PROP
	TOOL.ClientConVar[ "direction" ]     = improvedstacker.DIRECTION_UP
	TOOL.ClientConVar[ "count" ]         = "1"
	TOOL.ClientConVar[ "freeze" ]        = "1"
	TOOL.ClientConVar[ "weld" ]          = "1"
	TOOL.ClientConVar[ "nocollide" ]     = "1"
	TOOL.ClientConVar[ "ghostall" ]      = "1"
	TOOL.ClientConVar[ "material" ]      = "1"
	TOOL.ClientConVar[ "physprop" ]      = "1"
	TOOL.ClientConVar[ "color" ]         = "1"
	TOOL.ClientConVar[ "offsetx" ]       = "0"
	TOOL.ClientConVar[ "offsety" ]       = "0"
	TOOL.ClientConVar[ "offsetz" ]       = "0"
	TOOL.ClientConVar[ "pitch" ]         = "0"
	TOOL.ClientConVar[ "yaw" ]           = "0"
	TOOL.ClientConVar[ "roll" ]          = "0"
	TOOL.ClientConVar[ "relative" ]      = "1"
	TOOL.ClientConVar[ "draw_halos" ]    = "0"
	TOOL.ClientConVar[ "halo_r" ]        = "255"
	TOOL.ClientConVar[ "halo_g" ]        = "0"
	TOOL.ClientConVar[ "halo_b" ]        = "0"
	TOOL.ClientConVar[ "halo_a" ]        = "255"
	TOOL.ClientConVar[ "draw_axis" ]     = "1"
	TOOL.ClientConVar[ "axis_labels" ]   = "1"
	TOOL.ClientConVar[ "axis_angles" ]   = "0"
	TOOL.ClientConVar[ "opacity" ]       = "100"
	TOOL.ClientConVar[ "use_shift_key" ] = "0"

	--[[--------------------------------------------------------------------------
	-- Language Settings
	--------------------------------------------------------------------------]]--

	language.Add( "tool."..mode..".name",         L(prefix.."name") )
	language.Add( "tool."..mode..".desc",         L(prefix.."desc") )
	--language.Add( "tool."..mode..".0",            L(prefix.."0") )
	language.Add( "tool."..mode..".left",         L(prefix.."left") )
	language.Add( "tool."..mode..".shift_left",   L(prefix.."shift_left") )
	language.Add( "tool."..mode..".right",        L(prefix.."right") )
	language.Add( "tool."..mode..".shift_right",  L(prefix.."shift_right") )
	language.Add( "tool."..mode..".reload",       L(prefix.."reload") )
	language.Add( "Undone_"..mode,                L("Undone_"..mode) )
	
	--[[--------------------------------------------------------------------------
	-- Net Messages
	--------------------------------------------------------------------------]]--
	
	--[[--------------------------------------------------------------------------
	-- 	Net :: <toolmode>_error( string )
	--]]--
	net.Receive( mode.."_error", function( bytes )
		surface.PlaySound( "buttons/button10.wav" )
		notification.AddLegacy( net.ReadString(), net.ReadUInt(MIN_NOTIFY_BITS), NOTIFY_DURATION )
	end )
	
end

--[[--------------------------------------------------------------------------
-- Console Variables
--------------------------------------------------------------------------]]--

-- This is solely for backwards compatibility.
-- We're essentially copying everyone's old cvar values over since we're switching from 'stacker' to 'stacker_improved'.
-- If we didn't do this, we'd run the risk of ruining someone's custom setup
--[[local oldMaxTotal    = GetConVar( "stacker_max_total" )       and GetConVar( "stacker_max_total" ):GetInt()       or -1
local oldMaxCount    = GetConVar( "stacker_max_count" )       and GetConVar( "stacker_max_count" ):GetInt()       or 15
local oldMaxOffX     = GetConVar( "stacker_max_offsetx" )     and GetConVar( "stacker_max_offsetx" ):GetFloat()   or 200
local oldMaxOffY     = GetConVar( "stacker_max_offsety" )     and GetConVar( "stacker_max_offsety" ):GetFloat()   or 200
local oldMaxOffZ     = GetConVar( "stacker_max_offsetz" )     and GetConVar( "stacker_max_offsetz" ):GetFloat()   or 200
local oldStayInWorld = GetConVar( "stacker_stayinworld" )     and GetConVar( "stacker_stayinworld" ):GetInt()     or 1
local oldFreeze      = GetConVar( "stacker_force_freeze" )    and GetConVar( "stacker_force_freeze" ):GetInt()    or 0
local oldWeld        = GetConVar( "stacker_force_weld" )      and GetConVar( "stacker_force_weld" ):GetInt()      or 0
local oldNoCollide   = GetConVar( "stacker_force_nocollide" ) and GetConVar( "stacker_force_nocollide" ):GetInt() or 0
local oldDelay       = GetConVar( "stacker_delay" )           and GetConVar( "stacker_delay" ):GetFloat()         or 0.25
]]
local cvarFlags, cvarFlagsNotify

if ( SERVER ) then
	cvarFlags      = bit.bor( FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE )
	cvarFlagsNotif = bit.bor( cvarFlags, FCVAR_NOTIFY )
elseif ( CLIENT ) then
	cvarFlags      = bit.bor( FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE )
	cvarFlagsNotif = bit.bor( cvarFlags, FCVAR_NOTIFY )
end

local oldMaxTotal    = CreateConVar( "stacker_max_total",        -1, cvarFlagsNotif, "Defines the max amount of props that a player can have spawned from stacker" )
local oldMaxCount    = CreateConVar( "stacker_max_count",        15, cvarFlagsNotif, "Defines the max amount of props that can be stacked at a time" )
local oldDelay       = CreateConVar( "stacker_delay",           0.5, cvarFlagsNotif, "Determines the amount of time that must pass before a player can use stacker again" )
local oldMaxOffX     = CreateConVar( "stacker_max_offsetx",     200, cvarFlagsNotif, "Defines the max distance on the x plane that stacked props can be offset (for individual control)" )
local oldMaxOffY     = CreateConVar( "stacker_max_offsety",     200, cvarFlagsNotif, "Defines the max distance on the y plane that stacked props can be offset (for individual control)" )
local oldMaxOffZ     = CreateConVar( "stacker_max_offsetz",     200, cvarFlagsNotif, "Defines the max distance on the z plane that stacked props can be offset (for individual control)" )
local oldFreeze      = CreateConVar( "stacker_force_freeze",      0, cvarFlagsNotif, "Determines whether props should be forced to spawn frozen or not" )
local oldWeld        = CreateConVar( "stacker_force_weld",        0, cvarFlagsNotif, "Determines whether props should be forced to spawn welded or not" )
local oldNoCollide   = CreateConVar( "stacker_force_nocollide",   0, cvarFlagsNotif, "Determines whether props should be forced to spawn nocollided or not" )
local oldStayInWorld = CreateConVar( "stacker_stayinworld",       1, cvarFlagsNotif, "Determines whether props should be restricted to spawning inside the world or not (addresses possible crashes)" )

local cvarMaxPerPlayer = CreateConVar( mode.."_max_per_player",      oldMaxTotal:GetInt(),    cvarFlags,      "Defines the max amount of props that a player can have spawned from stacker" )
local cvarMaxPerStack  = CreateConVar( mode.."_max_per_stack",       oldMaxCount:GetInt(),    cvarFlags,      "Defines the max amount of props that can be stacked at a time" )
local cvarDelay        = CreateConVar( mode.."_delay",               oldDelay:GetFloat(),     cvarFlags,      "Determines the amount of time that must pass before a player can use stacker again" )
local cvarMaxOffX      = CreateConVar( mode.."_max_offsetx",         oldMaxOffX:GetFloat(),   cvarFlags,      "Defines the max distance on the x plane that stacked props can be offset (for individual control)" )
local cvarMaxOffY      = CreateConVar( mode.."_max_offsety",         oldMaxOffY:GetFloat(),   cvarFlags,      "Defines the max distance on the y plane that stacked props can be offset (for individual control)" )
local cvarMaxOffZ      = CreateConVar( mode.."_max_offsetz",         oldMaxOffZ:GetFloat(),   cvarFlags,      "Defines the max distance on the z plane that stacked props can be offset (for individual control)" )
local cvarFreeze       = CreateConVar( mode.."_force_freeze",        oldFreeze:GetInt(),      cvarFlagsNotif, "Determines whether props should be forced to spawn frozen or not" )
local cvarWeld         = CreateConVar( mode.."_force_weld",          oldWeld:GetInt(),        cvarFlagsNotif, "Determines whether props should be forced to spawn welded or not" )
local cvarNoCollide    = CreateConVar( mode.."_force_nocollide",     oldNoCollide:GetInt(),   cvarFlagsNotif, "Determines whether props should be forced to spawn nocollided or not" )
local cvarNoCollideAll = CreateConVar( mode.."_force_nocollide_all", 0,                       cvarFlags,      "(EXPERIMENTAL, DISABLED) Determines whether props should be nocollide with everything except players, vehicles, and npcs" )
local cvarStayInWorld  = CreateConVar( mode.."_force_stayinworld",   oldStayInWorld:GetInt(), cvarFlagsNotif, "Determines whether props should be restricted to spawning inside the world or not (addresses possible crashes)" )

--[[--------------------------------------------------------------------------
-- Console Commands
--------------------------------------------------------------------------]]--

if ( CLIENT ) then
	
	concommand.Add( mode.."_reset_offsets", function( ply, cmd, args )
		-- reset all of the offset values to 0
		RunConsoleCommand( mode.."_offsetx", "0.00" )
		RunConsoleCommand( mode.."_offsety", "0.00" )
		RunConsoleCommand( mode.."_offsetz", "0.00" )
	end	)
	
	concommand.Add( mode.."_reset_angles", function( ply, cmd, args )
		-- reset all of the angle values to 0
		RunConsoleCommand( mode.."_pitch",   "0.00" )
		RunConsoleCommand( mode.."_yaw",     "0.00" )
		RunConsoleCommand( mode.."_roll",    "0.00" )
	end )
	
	concommand.Add( mode.."_reset_admin", function( ply, cmd, args )
		for cmd, val in pairs( improvedstacker.SETTINGS_DEFAULT ) do
			RunConsoleCommand( cmd, val )
		end
	end )
	
elseif ( SERVER ) then

	local function validateCommand( ply, cmd, arg )
		-- run our hook to see if the server is manually allowing/blocking this player from changing the cvar
		-- true:          allow
		-- false:         block
		-- nil (default): fallback to a ply:IsAdmin() check
		local result, reason = hook.Run( "StackerConVar", ply, cmd, arg )

		-- if a player ran the command and the server didn't explicitly allow them to change the cvar
		if ( IsValid( ply ) and result ~= true ) then
			-- if the server blocked the change, send the player an error
			if ( result == false )                     then
				ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_blocked_by_server", localify.GetLocale( ply )) .. (isstring(reason) and ": " .. reason or "") )
				return false
			end
			-- if the server didn't give a response, fallback to a ply:IsAdmin() check
			if ( result == nil and not ply:IsAdmin() ) then
				ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_not_admin", localify.GetLocale( ply )) .. ": " .. cmd )
				return false
			end
		end
		
		-- lastly, ensure the argument is a valid number before returning true
		if ( not tonumber( arg ) ) then
			ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_invalid_argument", localify.GetLocale( ply )) )
			return false
		end
		
		return true
	end
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_per_player", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_per_player", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_per_player", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_per_stack", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_per_stack", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_per_stack", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offset", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offset", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetx", args[1] )
		RunConsoleCommand( mode.."_max_offsety", args[1] )
		RunConsoleCommand( mode.."_max_offsetz", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsetx", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsetx", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetx", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsety", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsety", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsety", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsetz", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsetz", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetz", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_stayinworld", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_stayinworld", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_stayinworld", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_freeze", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_freeze", args[1] ) ) then return false end	
		RunConsoleCommand( mode.."_force_freeze", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_weld", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_weld", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_weld", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_nocollide", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_nocollide", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_nocollide", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_nocollide_all", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_nocollide_all", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_nocollide_all", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_delay", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_delay", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_delay", args[1] )
	end )

	
	util.AddNetworkString( mode.."_error" )

	--[[--------------------------------------------------------------------------
	--	TOOL:SendError( str )
	--	Convenience function for sending an error to the tool owner.
	--]]--
	function TOOL:SendError( str )		
		net.Start( mode.."_error" )
			net.WriteString( str )
			net.WriteUInt( NOTIFY_ERROR, MIN_NOTIFY_BITS )
		net.Send( self:GetOwner() )
	end

end

--[[--------------------------------------------------------------------------
-- Convenience Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
-- 	TOOL:GetMaxPerPlayer() and TOOL:GetNumberPlayerEnts()
--
--	The total number of props a player has spawned from the Stacker tool is recorded
--	on them via ply.TotalStackerEnts. When a player removes a prop that has been spawned
--	from Stacker, the total count is decreased by 1.
--
--	In combination with the stacker_max_per_player cvar, this function can prevent players
--	from crashing the server by stacking dozens of welded props and unfreezing them.
--
--	By default, the number of stacker props is -1 (infinite). This is done to not interfere
--	with servers that don't want to limit the number of Stacker props a player can spawn directly.
--	They may still hit cvars like sbox_maxprops before ever hitting stacker_max_per_player.
--
--	As an example case, if players are crashing your servers by spawning 50 welded chairs 
--	and unfreezing them all at once, you can set stacker_max_per_player to 30 so that at any
--	given time they can only have 30 props created by Stacker. Trying to stack any more props
--	would give the player an error message.
--]]--
function TOOL:GetMaxPerPlayer()     return cvarMaxPerPlayer:GetInt() end
function TOOL:GetNumberPlayerEnts() return improvedstacker.GetEntCount( self:GetOwner(), 0 ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetStackSize()
--	Gets the amount of props that the client wants to stack at once.
--]]--
function TOOL:GetStackSize() return self:GetClientNumber( "count" ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetMaxPerStack()
--	Gets the maximum amount of props that can be stacked at a time.
--]]--
function TOOL:GetMaxPerStack() return cvarMaxPerStack:GetInt() end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetDirection()
--	Gets the direction to stack the props.
--]]--
function TOOL:GetDirection()
	local direction = self:GetClientNumber( "direction" )
	return improvedstacker.Directions[ direction ] and direction or improvedstacker.DIRECTION_FRONT
end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetStackerMode()
--	Gets the stacker mode (1 = MODE_WORLD, 2 = MODE_PROP).
--]]--
function TOOL:GetStackerMode()
	local stackMode = self:GetClientNumber( "mode" )
	return improvedstacker.Modes[ stackMode ] and stackMode or improvedstacker.MODE_PROP
end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetOffsetX(), TOOL:GetOffsetY(), TOOL:GetOffsetZ(), TOOL:GetOffsetVector()
--	Gets the distance to offset the position of the stacked props.
--	These values are clamped to prevent server crashes from players
--	using very high offset values.
--]]--
function TOOL:GetOffsetX()      return math.Clamp( self:GetClientNumber( "offsetx" ), -cvarMaxOffX:GetFloat(), cvarMaxOffX:GetFloat() ) end
function TOOL:GetOffsetY()      return math.Clamp( self:GetClientNumber( "offsety" ), -cvarMaxOffY:GetFloat(), cvarMaxOffY:GetFloat() ) end
function TOOL:GetOffsetZ()      return math.Clamp( self:GetClientNumber( "offsetz" ), -cvarMaxOffZ:GetFloat(), cvarMaxOffZ:GetFloat() ) end
function TOOL:GetOffsetVector() return Vector( self:GetOffsetX(), self:GetOffsetY(), self:GetOffsetZ() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetRotateP(), TOOL:GetRotateY(), TOOL:GetRotateR(), TOOL:GetRotationAngle()
--	Gets the value to rotate the angle of the stacked props.
--	These values are clamped to prevent server crashes from players
--	using very high rotation values.
--]]--
function TOOL:GetRotateP()     return math.Clamp( self:GetClientNumber( "pitch" ), -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotateY()     return math.Clamp( self:GetClientNumber( "yaw" ),   -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotateR()     return math.Clamp( self:GetClientNumber( "roll" ),  -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotationAngle() return Angle( self:GetRotateP(), self:GetRotateY(), self:GetRotateR() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldFreeze()
--	Returns true if the stacked props should be spawned frozen.
--]]--
function TOOL:ShouldApplyFreeze() return self:GetClientNumber( "freeze" ) == 1 end
function TOOL:ShouldForceFreeze() return cvarFreeze:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldWeld()
--	Returns true if the stacked props should be welded together.
--]]--
function TOOL:ShouldApplyWeld() return self:GetClientNumber( "weld" ) == 1 end
function TOOL:ShouldForceWeld() return cvarWeld:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldNoCollide()
--	Returns true if the stacked props should be nocollided with each other.
--]]--
function TOOL:ShouldApplyNoCollide() return self:GetClientNumber( "nocollide" ) == 1 end
function TOOL:ShouldForceNoCollide() return cvarNoCollide:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldStackRelative()
--	Returns true if the stacked props should be stacked relative to the new rotation.
--	Using this setting will allow you to create curved structures out of props.
--]]--
function TOOL:ShouldStackRelative() return self:GetClientNumber( "relative" ) == 1 end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldGhostAll()
--	Returns true if the stacked props should all be ghosted or if only the 
--	first stacked prop should be ghosted.
--]]--
function TOOL:ShouldGhostAll() return self:GetClientNumber( "ghostall" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldAddHalos(), TOOL:GetHaloR(), TOOL:GetHaloG(), TOOL:GetHaloB() TOOL:GetHaloA() TOOL:GetHaloColor()
--	Returns true if the stacked props should have halos drawn on them for added visibility.
--	Gets the RGBA values of the halo color.
--]]--
function TOOL:ShouldAddHalos() return self:GetClientNumber( "draw_halos" ) == 1 end
function TOOL:GetHaloR()       return math.Clamp( self:GetClientNumber( "halo_r" ), 0, 255 ) end
function TOOL:GetHaloG()       return math.Clamp( self:GetClientNumber( "halo_g" ), 0, 255 ) end
function TOOL:GetHaloB()       return math.Clamp( self:GetClientNumber( "halo_b" ), 0, 255 ) end
function TOOL:GetHaloA()       return math.Clamp( self:GetClientNumber( "halo_a" ), 0, 255 ) end
function TOOL:GetHaloColor()   return Color( self:GetHaloR(), self:GetHaloG(), self:GetHaloB(), self:GetHaloA() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyMaterial()
--	Returns true if the stacked props should have the original prop's material applied.
--]]--
function TOOL:ShouldApplyMaterial() return self:GetClientNumber( "material" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyColor()
--	Returns true if the stacked props should have the original prop's color applied.
--]]--
function TOOL:ShouldApplyColor() return self:GetClientNumber( "color" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyPhysicalProperties()
--	Returns true if the stacked props should have the original prop's physicsl properties
--	applied, including gravity, physics material, and weight.
--]]--
function TOOL:ShouldApplyPhysicalProperties() return self:GetClientNumber( "physprop" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetDelay()
--	Returns the time in seconds that must pass before a player can use stacker again.
--	For example, if stacker_delay is set to 3, a player must wait 3 seconds in between each
--	use of stacker's left click. A delay of <= 0 means stacks can be created instantly.
--]]--
function TOOL:GetDelay() return cvarDelay:GetFloat() end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetOpacity()
--	Returns the alpha value (opacity) of the ghosted props seen on the client.
--	Should be between 0 (invisible) and 255 (fully visible).
--]]--
function TOOL:GetOpacity() return self:GetClientNumber( "opacity" ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetUseShiftKey()
--	Returns true if the client has enabled the alternate use of SHIFT in combination
--	with left and right clicking. If enable, holding SHIFT and pressing LMB/RMB will
--	have the same effect as holding E and pressing LMB/RMB.
--]]--
function TOOL:GetUseShiftKey() return self:GetClientNumber( "use_shift_key" ) == 1 end
--[[--------------------------------------------------------------------------
-- Tool Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
-- 	TOOL:LeftClick( table, boolean = nil )
--
--	Attempts to create a stack of props relative to the entity being left clicked.
--]]--
function TOOL:LeftClick( tr, isRightClick )
	local ply = self:GetOwner()
	
	-- check if the player is holding E or SHIFT (as long as they've enabled it)
	if ( ply:KeyDown( IN_USE ) or (self:GetUseShiftKey() and ply:KeyDown( IN_SPEED )) ) then
		if ( CLIENT ) then return false end
		-- increase their stack count by 1 (until it hits the stack max)
		local newCount = self:GetStackSize() >= self:GetMaxPerStack() and self:GetMaxPerStack() or self:GetStackSize() + 1
		ply:ConCommand( mode.."_count "..newCount )
		return false
	end

	if ( not IsValid( tr.Entity ) or tr.Entity:GetClass() ~= "prop_physics" ) then return false end
	if ( CLIENT ) then return true end
	
	-- otherwise, stack 1 if right-clicking or get the client's stack size value
	local count = (isRightClick and 1) or self:GetStackSize()
	-- check if the server wants to control how many props the player can use in the stack
	local maxCount = hook.Run( "StackerMaxPerStack", ply, count, isRightClick ) or self:GetMaxPerStack()

	-- check if the player's stack size is higher than the server's max allowed size (but only if the server didn't explictly override it)
	if ( maxCount >= 0 ) then
		if ( count > maxCount ) then self:SendError( L(prefix.."error_max_per_stack", localify.GetLocale( self:GetOwner() )) .. maxCount ) end
		count = math.Clamp( count, 0, maxCount )
	end
	
	-- get the player's last stacker usage time, defaulting to 0 if it hasn't been set
	local lastStackTime = improvedstacker.GetLastStackTime( ply, 0 )
	
	-- retrieve the time delay between stacker usage
	-- we call StackerDelay to let external mods to set their own delays (less than or equal to 0 means no delay)
	-- delay time is in seconds (e.g. 0.1 is a tenth of a second)
	local delay = hook.Run( "StackerDelay", ply, lastStackTime ) or self:GetDelay()
	
	-- check if the player is trying to use stacker too quickly
	if ( lastStackTime + delay > CurTime() ) then self:SendError( L(prefix.."error_too_quick", localify.GetLocale( self:GetOwner() )) ) return false end
	improvedstacker.SetLastStackTime( ply, CurTime() )
	
	local stackDirection = self:GetDirection()
	local stackMode      = self:GetStackerMode()
	local stackOffset    = self:GetOffsetVector()
	local stackRotation  = self:GetRotationAngle()
	local stackRelative  = self:ShouldStackRelative()
	
	-- determines whether the stacked props are allowed to be positioned outside of the world or not
	local stayInWorld   = cvarStayInWorld:GetBool()

	-- store the properties of the original prop so we can apply them to the stacked props
	local ent = tr.Entity
	local entPos   = ent:GetPos()
	local entAng   = ent:GetAngles()
	local entMod   = ent:GetModel()
	local entSkin  = ent:GetSkin()
	local entMat   = ent:GetMaterial()
	local physMat  = ent:GetPhysicsObject():GetMaterial()
	local physGrav = ent:GetPhysicsObject():IsGravityEnabled()
	
	-- setup a table to hold the original prop's color data so that we can apply it to the stacked props
	local colorData = {
		Color      = ent:GetColor(), 
		RenderMode = ent:GetRenderMode(), 
		RenderFX   = ent:GetRenderFX()
	}	
		
	local newEnt
	local newEnts = { ent }
	local lastEnt = ent
	
	local direction, offset
	-- we only need to calculate the distance once based on the direction the user selected
	local distance = improvedstacker.GetDistance( stackMode, stackDirection, ent )
	
	-- setup a new undo block so the player can undo the whole stack at once
	undo.Create( mode )
	
	-- check if the server wants to control how many stacker entities this player can create
	local maxPerPlayer = hook.Run( "StackerMaxPerPlayer", ply, self:GetNumberPlayerEnts() ) or self:GetMaxPerPlayer()
	
	-- loop for every prop to create in the stack and allow external addons to dictate control over the new stacked entities
	for i = 1, count do
		
		-- check if the player has too many active stacker props spawned out already
		local stackerEntsSpawned = self:GetNumberPlayerEnts()
		if ( maxPerPlayer >= 0 and stackerEntsSpawned >= maxPerPlayer ) then self:SendError( ("%s (%s)"):format(L(prefix.."error_max_per_player", localify.GetLocale( self:GetOwner() )), maxPerPlayer) ) break end
		-- check if the player has exceeded the sbox_maxprops cvar
		if ( not self:GetSWEP():CheckLimit( "props" ) )            then break end
		-- check if external admin mods are blocking this entity
		if ( hook.Run( "PlayerSpawnProp", ply, entMod ) == false ) then break end
		
		-- if we're positioning the first entity in the stack (regardless of relative to PROP or WORLD), or
		-- if we're stacking relative to PROP and on the previous rotation, update the new direction and offset
		if ( i == 1 or ( stackMode == improvedstacker.MODE_PROP and stackRelative ) ) then
			direction = improvedstacker.GetDirection( stackMode, stackDirection, entAng )
			offset    = improvedstacker.GetOffset( stackMode, stackDirection, entAng, stackOffset )
		end

		-- calculate the next stacked entity's position
		entPos = entPos + (direction * distance) + offset
		-- rotate the next stacked entity's angle by the client's rotation values
		improvedstacker.RotateAngle( stackMode, stackDirection, entAng, stackRotation )
		
		
		-- check if the stacked props would be spawned outside of the world
		if ( stayInWorld and not util.IsInWorld( entPos ) ) then self:SendError( L(prefix.."error_not_in_world", localify.GetLocale( self:GetOwner() )) ) break end
		
		-- create the new stacked entity
		newEnt = ents.Create( "prop_physics" )
		newEnt:SetModel( entMod )
		newEnt:SetPos( entPos )
		newEnt:SetAngles( entAng )
		newEnt:SetSkin( entSkin )
		newEnt:Spawn()

		-- this hook is for external prop protections and anti-spam addons.
		-- it is called before undo, ply:AddCount, and ply:AddCleanup to allow developers to
		-- remove or mark this entity so that those same functions (if overridden) can
		-- detect that the entity came from Stacker
		if ( not IsValid( newEnt ) or hook.Run( "StackerEntity", newEnt, ply ) ~= nil )             then break end
		if ( not IsValid( newEnt ) or hook.Run( "PlayerSpawnedProp", ply, entMod, newEnt ) ~= nil ) then break end

		-- disabling this for now due to problems with ShouldCollide
		--improvedstacker.MarkEntity( self:GetOwner(), newEnt )
		
		-- increase the total number of active stacker props spawned by the player by 1
		improvedstacker.IncrementEntCount( ply )
		
		-- decrement the total number of active stacker props spawned by the player by 1
		-- when the prop gets removed in any way
		newEnt:CallOnRemove( "UpdateStackerTotal", function( ent, ply )
			-- if the player is no longer connected, there is nothing to do
			if ( not IsValid( ply ) ) then return end
			improvedstacker.DecrementEntCount( ply )
		end, ply )
		
		self:ApplyMaterial( newEnt, entMat )
		self:ApplyColor( newEnt, colorData )
		self:ApplyFreeze( ply, newEnt )
		
		-- attempt to nocollide the new entity with the last, or break out of the loop if CBaseEntityList::AddNonNetworkableEntity fails
		if ( not self:ApplyNoCollide( lastEnt, newEnt ) ) then
			newEnt:Remove()
			break
		end
		
		-- attempt to weld the new entity with the last, or break out of the loop if CBaseEntityList::AddNonNetworkableEntity fails
		if ( not self:ApplyWeld( lastEnt, newEnt ) ) then
			newEnt:Remove()
			break
		end
		
		self:ApplyPhysicalProperties( ent, newEnt, tr.PhysicsBone, { GravityToggle = physGrav, Material = physMat } )
		
		lastEnt = newEnt
		table.insert( newEnts, newEnt )
		
		undo.AddEntity( newEnt )
		ply:AddCleanup( "props", newEnt )
	end
	
	newEnts = nil
	
	undo.SetPlayer( ply )
	undo.Finish()

	-- disabling this for now due to problems with ShouldCollide
	--improvedstacker.MarkEntity( self:GetOwner(), ent )
	
	return true
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:RightClick( trace )
--
--	Performs a LeftClick operation but only creates a single stacked entity.
--	Alternatively, if the player is holding down their USE key, this will
--	decrease their stack count by 1.
--]]--
function TOOL:RightClick( tr )
	local ply = self:GetOwner()

	-- check if the player is holding E or SHIFT (as long as they've enabled it)
	if ( ply:KeyDown( IN_USE ) or (self:GetUseShiftKey() and ply:KeyDown( IN_SPEED )) ) then
		if ( CLIENT ) then return false end
		-- decrease the player's stack count by 1 (until a minimum of 1)
		local count = self:GetStackSize()
		local newCount = (count <= 1 and 1) or count - 1
		ply:ConCommand( mode.."_count " .. newCount )
		return false
	else
		-- create a single entity in the stack
		return self:LeftClick( tr, true )
	end
	
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:Reload()
--
--	Switches the client's stack direction.
--]]--
function TOOL:Reload()
	if ( CLIENT ) then return false end

	local ply = self:GetOwner()
	local direction = self:GetDirection()
	
	-- if they were at the last numerical direction (6), wrap around to the first (1)
	if ( direction == improvedstacker.DIRECTION_DOWN ) then
		direction = improvedstacker.DIRECTION_FRONT
	-- otherwise just increment to the next direction
	else
		direction = direction + 1
	end
	
	-- make the player update their client direction setting
	ply:ConCommand( mode.."_direction " .. direction )
	
	return false
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyMaterial( entity, string )
--
--	Applies the original entity's material onto the stacked props.
--]]--
function TOOL:ApplyMaterial( ent, material )
	if ( not self:ShouldApplyMaterial() ) then ent:SetMaterial( "" ) return end
	
	-- From: gamemodes/sandbox/entities/weapons/gmod_tool/stools/material.lua
	-- "Make sure this is in the 'allowed' list in multiplayer - to stop people using exploits"
	if ( not game.SinglePlayer() and not list.Contains( "OverrideMaterials", material ) and material ~= "" ) then return end

	ent:SetMaterial( material )
	duplicator.StoreEntityModifier( ent, "material", { MaterialOverride = material } )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyColor( entity, color )
--
--	Applies the original entity's color onto the stacked props.
--]]--
function TOOL:ApplyColor( ent, data )
	if ( not self:ShouldApplyColor() ) then return end

	ent:SetColor( data.Color )
	ent:SetRenderMode( data.RenderMode )
	ent:SetRenderFX( data.RenderFX )
	
	duplicator.StoreEntityModifier( ent, "colour", table.Copy( data ) )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyFreeze( player, entity )
--
--	Attempts to freeze the stacked props in place.
--]]--
function TOOL:ApplyFreeze( ply, ent )
	if ( self:ShouldForceFreeze() or self:ShouldApplyFreeze() ) then
		ent:GetPhysicsObject():EnableMotion( false )
	else
		ent:GetPhysicsObject():Wake()
	end
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyWeld( entity, entity )
--
--	Attempts to weld the new entity to the last entity.
--]]--
function TOOL:ApplyWeld( lastEnt, newEnt )
	if ( not self:ShouldForceWeld() and not self:ShouldApplyWeld() ) then return true end
	
	local forceLimit    = 0
	local isNocollided  = self:ShouldForceNoCollide() or self:ShouldApplyNoCollide()
	local deleteOnBreak = false
	
	local ok, err = pcall( constraint.Weld, lastEnt, newEnt, 0, 0, forceLimit, isNocollided, deleteOnBreak )
	
	if ( not ok ) then
		print( mode .. ": " .. L(prefix.."error_max_constraints") .." (error: " .. err .. ")" )
		self:SendError( mode .. ": " .. L(prefix.."error_max_constraints", localify.GetLocale( self:GetOwner() )) )
	end
	
	return ok
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyNoCollide( entity, entity )
--
--	Attempts to nocollide the new entity to the last entity.
--]]--
function TOOL:ApplyNoCollide( lastEnt, newEnt )
	if ( not self:ShouldForceNoCollide() and not self:ShouldApplyNoCollide() ) then return true end
	-- we can skip this function if the client is trying to weld -and- nocollide, because
	-- constraint.Weld already has a nocollide parameter
	if ( self:ShouldForceWeld() or self:ShouldApplyWeld() ) then return true end
	
	local ok, err = pcall( constraint.NoCollide, lastEnt, newEnt, 0, 0 )
	
	if ( not ok ) then
		print( mode .. ": " .. L(prefix.."error_max_constraints") .." (error: " .. err .. ")" )
		self:SendError( mode .. ": " .. L(prefix.."error_max_constraints", localify.GetLocale( self:GetOwner() )) )
	end
	
	return ok
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyPhysicalProperties( entity, entity, number, table )
--
--	Attempts to apply the original entity's Gravity/Physics Material properties 
--	and weight onto the stacked propa.
--	
--]]--
function TOOL:ApplyPhysicalProperties( original, newEnt, boneID, properties )
	if ( not self:ShouldApplyPhysicalProperties() ) then return end
	
	if ( boneID ) then construct.SetPhysProp( nil, newEnt, boneID, nil, properties ) end
	newEnt:GetPhysicsObject():SetMass( original:GetPhysicsObject():GetMass() )
end

if ( CLIENT ) then
	
	-- get the cvars if they're valid (e.g., editing and auto-refreshing this file).
	-- otherwise they won't be valid yet when first ran and we have to wait until
	-- TOOL:Init() gets called (below) to set them up
	local cvarTool       = GetConVar( "gmod_toolmode" )
	local cvarCount      = GetConVar( mode.."_count" )
	local cvarMode       = GetConVar( mode.."_mode" )
	local cvarDirection  = GetConVar( mode.."_direction" )
	local cvarOffsetX    = GetConVar( mode.."_offsetx" )
	local cvarOffsetY    = GetConVar( mode.."_offsety" )
	local cvarOffsetZ    = GetConVar( mode.."_offsetz" )
	local cvarPitch      = GetConVar( mode.."_pitch" )
	local cvarYaw        = GetConVar( mode.."_yaw" )
	local cvarRoll       = GetConVar( mode.."_roll" )
	local cvarRelative   = GetConVar( mode.."_relative" )
	local cvarMaterial   = GetConVar( mode.."_material" )
	local cvarColor      = GetConVar( mode.."_color" )
	local cvarGhostAll   = GetConVar( mode.."_ghostall" )
	local cvarOpacity    = GetConVar( mode.."_opacity" )
	local cvarHalo       = GetConVar( mode.."_draw_halos" )
	local cvarHaloR      = GetConVar( mode.."_halo_r" )
	local cvarHaloG      = GetConVar( mode.."_halo_g" )
	local cvarHaloB      = GetConVar( mode.."_halo_b" )
	local cvarHaloA      = GetConVar( mode.."_halo_a" )	
	local cvarHalo       = GetConVar( mode.."_draw_halos" )
	local cvarAxis       = GetConVar( mode.."_draw_axis" )
	local cvarAxisLbl    = GetConVar( mode.."_axis_labels" )
	local cvarAxisAng    = GetConVar( mode.."_axis_angles" )
	
	-- offsets for drawing the axis arrows
	local o1 = Vector(     0, 0,  0.05 )
	local o2 = Vector(     0, 0, -0.05 )
	local o3 = Vector(  0.05, 0,     0 )
	local o4 = Vector( -0.05, 0,     0 )
	local ao = 2.5
	
	-- colors for the axis arrows
	local RED   = Color( 255,  50,  50 )
	local GREEN = Color(   0, 255,   0 )
	local BLUE  = Color(  50, 150, 255 )
	local BLACK = Color(   0,   0,   0 )
	
	surface.CreateFont( mode.."_direction", {
		font = "Arial",
		size = 24,
		weight = 700,
		antialias = true
	})
	
	
	-- we're creating a bunch of local functions here using the cvars above so that we don't have to
	-- rely on the TOOL object (which can be problematic when trying to use it inside a hook).
	-- these should be pretty much identical to the TOOL functions created near the top of this file
	local function getStackSize()        return cvarCount:GetInt()       end
	local function getMaxPerStack()      return cvarMaxPerStack:GetInt() end
	local function getStackerMode()      return cvarMode:GetInt()        end
	local function getDirection()        return cvarDirection:GetInt()   end
	local function getOpacity()          return cvarOpacity:GetInt()     end	
	local function shouldGhostAll()      return cvarGhostAll:GetBool()   end
	local function shouldStackRelative() return cvarRelative:GetBool()   end
	local function shouldApplyMaterial() return cvarMaterial:GetBool()   end
	local function shouldApplyColor()    return cvarColor:GetBool()      end
	local function shouldAddHalos()      return cvarHalo:GetBool()       end
	
	local function getOffsetVector()
		return Vector( math.Clamp( cvarOffsetX:GetFloat(), -cvarMaxOffX:GetFloat(), cvarMaxOffX:GetFloat() ), 
	                   math.Clamp( cvarOffsetY:GetFloat(), -cvarMaxOffY:GetFloat(), cvarMaxOffY:GetFloat() ),
	                   math.Clamp( cvarOffsetZ:GetFloat(), -cvarMaxOffZ:GetFloat(), cvarMaxOffZ:GetFloat() ) )
	end

	local function getRotationAngle()
		return Angle( math.Clamp( cvarPitch:GetFloat(), -MAX_ANGLE, MAX_ANGLE ),
                      math.Clamp( cvarYaw:GetFloat(),   -MAX_ANGLE, MAX_ANGLE ),
                      math.Clamp( cvarRoll:GetFloat(),  -MAX_ANGLE, MAX_ANGLE ) )
	end
	
	local function getHaloColor()
		return Color( cvarHaloR:GetInt(),
                      cvarHaloG:GetInt(),
                      cvarHaloB:GetInt(),
	                  cvarHaloA:GetInt() )
	end
	
	--[[--------------------------------------------------------------------------
	--
	-- 	TOOL:Init()
	--
	--]]--
	function TOOL:Init()
		-- now the convars are truly valid, so reassign the upvalues
		cvarTool       = GetConVar( "gmod_toolmode" )
		cvarCount      = GetConVar( mode.."_count" )
		cvarMode       = GetConVar( mode.."_mode" )
		cvarDirection  = GetConVar( mode.."_direction" )
		cvarOffsetX    = GetConVar( mode.."_offsetx" )
		cvarOffsetY    = GetConVar( mode.."_offsety" )
		cvarOffsetZ    = GetConVar( mode.."_offsetz" )
		cvarPitch      = GetConVar( mode.."_pitch" )
		cvarYaw        = GetConVar( mode.."_yaw" )
		cvarRoll       = GetConVar( mode.."_roll" )
		cvarRelative   = GetConVar( mode.."_relative" )
		cvarMaterial   = GetConVar( mode.."_material" )
		cvarColor      = GetConVar( mode.."_color" )
		cvarGhostAll   = GetConVar( mode.."_ghostall" )
		cvarOpacity    = GetConVar( mode.."_opacity" )
		cvarHalo       = GetConVar( mode.."_draw_halos" )
		cvarHaloR      = GetConVar( mode.."_halo_r" )
		cvarHaloG      = GetConVar( mode.."_halo_g" )
		cvarHaloB      = GetConVar( mode.."_halo_b" )
		cvarHaloA      = GetConVar( mode.."_halo_a" )
		cvarHalo       = GetConVar( mode.."_draw_halos" )
		cvarAxis       = GetConVar( mode.."_draw_axis" )
		cvarAxisLbl    = GetConVar( mode.."_axis_labels" )
		cvarAxisAng    = GetConVar( mode.."_axis_angles" )
	end
	
	--[[--------------------------------------------------------------------------
	--
	-- 	createGhostStack( entity, vector, angle )
	--
	--	Attempts to create a stack of ghosted props on the prop the player is currently
	--	looking at before they actually left click to create the stack. This acts
	--	as a visual aid for the player so they can see the results without actually creating
	--	the entities yet (if in multiplayer).
	--]]--
	local function createGhostStack( ent )
		if ( improvedstacker.GetGhosts() ) then improvedstacker.ReleaseGhosts() end

		-- truncate the stack size to the maximum allowed by the server
		local count    = getStackSize()
		local maxCount = getMaxPerStack()
		if ( not shouldGhostAll() and count ~= 0 ) then count = 1 end
		if ( maxCount >= 0 and count > maxCount )  then count = maxCount end

		local entMod  = ent:GetModel()
		local entSkin = ent:GetSkin()
		
		local ghosts = {}
		local ghost
		
		-- loop for the total stack size and create a new ghost prop
		for i = 1, count do
			ghost = ClientsideModel( entMod )
			
			if ( not IsValid( ghost ) ) then continue end

			ghost:SetModel( entMod )
			ghost:SetSkin( entSkin )
			ghost:Spawn()

			ghost:SetRenderMode( RENDERMODE_TRANSALPHA )
			
			table.insert( ghosts, ghost )
		end
		
		-- store the ghost array for later use
		improvedstacker.SetGhosts( ghosts )
		
		return true
	end

	--[[--------------------------------------------------------------------------
	--
	-- 	validateGhostStack()
	--
	--	Attempts to validate the status of the ghosted props in the stack.
	--		True:  all good, ready to update
	--		False: something is invalid or missing, clear it
	--]]--
	local function validateGhostStack()
		-- check if the array of ghosts is valid
		local ghosts = improvedstacker.GetGhosts()
		if ( not ghosts ) then return false end
		
		-- check if all the ghost entities are valid
		for i = 1, #ghosts do
			if ( not IsValid( ghosts[ i ] ) ) then return false end
		end
		
		-- clamp the client's ghost stack to the server's maximum allowed size
		local count    = getStackSize()
		local maxCount = getMaxPerStack()
		if ( maxCount >= 0 and count > maxCount ) then count = maxCount end
		
		-- check if the number of ghosts in the stack matches the client's setting
		if     ( #ghosts ~= count and     shouldGhostAll() ) then return false
		-- number of ghosts matches client's setting, so check if we should only be ghosting one
		elseif ( #ghosts ~= 1     and not shouldGhostAll() ) then return false end
		
		return true
	end

	--[[--------------------------------------------------------------------------
	--
	-- 	updateGhostStack( entity )
	--
	--	Attempts to update the positions and angles of all ghosted props in the stack.
	--]]--
	local function updateGhostStack( ent )		
		local stackMode      = getStackerMode()
		local stackDirection = getDirection()
		local stackOffset    = getOffsetVector()
		local stackRotation  = getRotationAngle()
		local stackRelative  = shouldStackRelative()
		
		local applyMat  = shouldApplyMaterial()
		local applyCol  = shouldApplyColor()
		
		local lastEnt = ent
		local entPos = ent:GetPos()
		local entAng = ent:GetAngles()
		local entMat = ent:GetMaterial()
		local entCol = ent:GetColor()
			  entCol.a = getOpacity()
		
		local direction, offset
		-- we only need to calculate the distance once based on the direction the user selected
		local distance = improvedstacker.GetDistance( stackMode, stackDirection, ent )
		
		local ghost
		local ghosts = improvedstacker.GetGhosts()
		
		for i = 1, #ghosts do
			-- if we're positioning the first entity in the stack (regardless of relative to PROP or WORLD), or
			-- if we're stacking relative to PROP and on the previous rotation, update the new direction and offset
			if ( i == 1 or ( stackMode == improvedstacker.MODE_PROP and stackRelative ) ) then
				direction = improvedstacker.GetDirection( stackMode, stackDirection, entAng )
				offset    = improvedstacker.GetOffset( stackMode, stackDirection, entAng, stackOffset )
			end

			-- calculate the next stacked entity's position
			entPos = entPos + (direction * distance) + offset
			-- rotate the next stacked entity's angle by the client's rotation values
			improvedstacker.RotateAngle( stackMode, stackDirection, entAng, stackRotation )
			
			local ghost = ghosts[ i ]
			ghost:SetPos( entPos )
			ghost:SetAngles( entAng )
			ghost:SetMaterial( ( applyMat and entMat ) or "" )
			ghost:SetColor( ( applyCol and entCol ) or TRANSPARENT )
			ghost:SetNoDraw( false )
			
			lastEnt = ghost
		end
	end
	
	
	--[[--------------------------------------------------------------------------
	--
	-- 	Hook :: PreDrawHalos
	--
	--	Loads the hook that draws halos on the ghosted entities in the stack. 
	--
	--	This is the appropriate hook to create halos, NOT TOOL:Think(). The latter 
	--	will be called way more than it needs to be and causes horrible FPS drops in singleplayer.
	--]]--
	hook.Add( "PreDrawHalos", mode.."_predrawhalos", function()
		-- check if the player has fully initialized
		local ply = LocalPlayer()
		if ( not IsValid( ply ) ) then return end
		
		-- check if they have the toolgun out and have stacker selected
		local wep = ply:GetActiveWeapon()
		if ( not ( IsValid( wep ) and wep:GetClass() == "gmod_tool" and cvarTool and cvarTool:GetString() == mode ) ) then
			improvedstacker.ReleaseGhosts()
			improvedstacker.SetLookedAt( nil )
			return
		end
		
		-- check if we're looking at a valid entity
		local lookingAt = ply:GetEyeTrace().Entity
		if ( not ( IsValid( lookingAt ) and lookingAt:GetClass() == "prop_physics" ) ) then
			improvedstacker.ReleaseGhosts()
			improvedstacker.SetLookedAt( nil )
			return
		end
		
		-- check if the current toolobject is valid before trying to use it --
		-- commenting this out for now since I refactored these TOOL functions
		-- into just local functions to ditch the need for the tool object
		--[[local tool = wep.GetToolObject and wep:GetToolObject() 
		if ( not ( tool and tool.GetOwner and IsValid( tool:GetOwner() ) ) ) then
			return
		end]]
		
		-- specify the entity that the client is currently looking at for future reference
		improvedstacker.SetLookingAt( lookingAt )
		-- get the entity that the client was last (successfully) looking at
		local lookedAt = improvedstacker.GetLookedAt()
		
		-- if we're still looking at the same entity from the previous frame
		if ( lookingAt == lookedAt ) then
			-- if the ghost stack is still valid (nothing got deleted, etc)
			if ( validateGhostStack() ) then
				-- reposition the stack to the client's most recent stack settings
				updateGhostStack( lookingAt )
			else
				-- something is wrong in the stack, so remove the ghost entities
				improvedstacker.ReleaseGhosts()
				improvedstacker.SetLookedAt( nil )
				return
			end
		-- we looked at something else since the last frame
		else
			-- try to initialize a new ghost stack
			if ( createGhostStack( lookingAt ) ) then
				-- ghost stack was successfully created
				improvedstacker.SetLookedAt( lookingAt )
			end
		end
		
		-- check if we want to add halos to the ghost stack
		if ( not shouldAddHalos() ) then return end
		
		-- check if there are any ghosts to add halos to at all
		local ghosts = improvedstacker.GetGhosts()
		if ( not ghosts or #ghosts <= 0 ) then return end

		halo.Add( ghosts, getHaloColor() )
	end )
	
	--[[--------------------------------------------------------------------------
	--
	-- 	Hook :: PostDrawTranslucentRenderables
	--
	--	Draws the 2D x/y/z axis when looking at entities with the stacker tool.
	--]]--
	
	hook.Add( "PostDrawTranslucentRenderables", mode.."_directions", function( drawingDepth, drawingSky )
		if ( drawingSky ) then return end
		
		-- check if the player has fully initialized
		local ply = LocalPlayer()
		if ( not IsValid( ply ) ) then return end
		
		-- check if we want to draw the axis at all
		if ( not ( cvarAxis and cvarAxis:GetBool() ) ) then return end
		
		-- check if they have the toolgun out and have stacker selected
		local wep = ply:GetActiveWeapon()
		if ( not ( IsValid( wep ) and wep:GetClass() == "gmod_tool" and cvarTool and cvarTool:GetString() == mode ) ) then
			return
		end
		
		-- check if we're looking at a valid entity
		local ent = ply:GetEyeTrace().Entity
		if ( not IsValid( ent ) ) then
			return
		end
		
		local pos = ent:GetPos()
		
		local f = ent:GetForward()
		local r = ent:GetRight()
		local u = ent:GetUp()
		
		-- draw the front arrow (red)
		render.DrawLine( pos,    pos + (f*50),      RED, false )
		render.DrawLine( pos + (f*50) - f*ao + Vector(0,0,ao), pos + (f*50), RED, false )
		render.DrawLine( pos + (f*50) - f*ao - Vector(0,0,ao), pos + (f*50), RED, false )
		render.DrawLine( pos+o1, pos + (f*50) + o1, RED, false )
		render.DrawLine( pos+o2, pos + (f*50) + o2, RED, false )
		
		-- draw the right arrow (green)
		render.DrawLine( pos,    pos + (r*50),      GREEN, false )
		render.DrawLine( pos + (r*50) - r*ao + f*ao, pos + (r*50), GREEN, false )
		render.DrawLine( pos + (r*50) - r*ao - f*ao, pos + (r*50), GREEN, false )
		render.DrawLine( pos+o1, pos + (r*50) + o1, GREEN, false )
		render.DrawLine( pos+o2, pos + (r*50) + o2, GREEN, false )
		
		-- draw the upward arrow (blue)
		render.DrawLine( pos,    pos + (u*50),      BLUE, false )
		render.DrawLine( pos + (u*50) - u*ao + r*ao, pos + (u*50), BLUE, false )
		render.DrawLine( pos + (u*50) - u*ao - r*ao, pos + (u*50), BLUE, false )
		render.DrawLine( pos+o3, pos + (u*50) + o3, BLUE, false )
		render.DrawLine( pos+o4, pos + (u*50) + o4, BLUE, false )
		
		-- check if we want to draw the axis labels
		if ( not ( cvarAxisLbl           and cvarAxisAng ) )           then return end
		if ( not ( cvarAxisLbl:GetBool() or  cvarAxisAng:GetBool() ) ) then return end
		
		local fs = (pos + f*50 - u*5):ToScreen()
		local rs = (pos + r*50 - u*5):ToScreen()
		local us = (pos + u*55):ToScreen()
		
		local ang = ent:GetAngles()
		
		local front = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_front").." " or "", cvarAxisAng:GetBool() and "("..ang.x..")" or "" )
		local right = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_right").." " or "", cvarAxisAng:GetBool() and "("..ang.y..")" or "" )
		local upwrd = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_up").." "    or "", cvarAxisAng:GetBool() and "("..ang.z..")" or "" )
		
		cam.Start2D()
			draw.SimpleTextOutlined( front, mode.."_direction", fs.x, fs.y, RED,   0, 0, 1, BLACK )
			draw.SimpleTextOutlined( right, mode.."_direction", rs.x, rs.y, GREEN, 0, 0, 1, BLACK )
			draw.SimpleTextOutlined( upwrd, mode.."_direction", us.x, us.y, BLUE,  1, 0, 1, BLACK )
		cam.End2D()
		
	end )
	
end

if ( CLIENT ) then
	--[[--------------------------------------------------------------------------
	--
	-- 	TOOL.BuildCPanel( panel )
	--
	--	Builds the control panel menu that can be seen when holding Q and accessing
	--	the stacker menu.
	--]]--
	local function buildCPanel( cpanel )
		-- quick presets for default settings
		local presets = { 
			Label      = "Presets",
			MenuButton = 1,
			Folder     = mode,
			Options = {
				[L(prefix.."combobox_default")] = {
					[mode.."_mode"]        = tostring(improvedstacker.MODE_PROP),
					[mode.."_direction"]   = tostring(improvedstacker.DIRECTION_UP),
					[mode.."_count"]       = "1",
					[mode.."_freeze"]      = "1",
					[mode.."_weld"]        = "1",
					[mode.."_nocollide"]   = "1",
					[mode.."_ghostall"]    = "1",
					[mode.."_material"]    = "1",
					[mode.."_physprop"]    = "1",
					[mode.."_color"]       = "1",
					[mode.."_offsetx"]     = "0",
					[mode.."_offsety"]     = "0",
					[mode.."_offsetz"]     = "0",
					[mode.."_pitch"]       = "0",
					[mode.."_yaw"]         = "0",
					[mode.."_roll"]        = "0",
					[mode.."_relative"]    = "1",
					[mode.."_draw_halos"]  = "0",
					[mode.."_halo_r"]      = "255",
					[mode.."_halo_g"]      = "0",
					[mode.."_halo_b"]      = "0",
					[mode.."_halo_a"]      = "255",
					[mode.."_draw_axis"]   = "1",
					[mode.."_axis_labels"] = "1",
					[mode.."_axis_angles"] = "0",
				},
			},
			CVars = { 
				mode.."_mode",
				mode.."_direction",
				mode.."_count",
				mode.."_freeze",
				mode.."_weld",
				mode.."_nocollide",
				mode.."_ghostall",
				mode.."_material",
				mode.."_physprop",
				mode.."_color",
				mode.."_offsetx",
				mode.."_offsety",
				mode.."_offsetz",
				mode.."_pitch",
				mode.."_yaw",
				mode.."_roll",
				mode.."_relative",
				mode.."_draw_halos",
				mode.."_halo_r",
				mode.."_halo_g",
				mode.."_halo_b",
				mode.."_halo_a",
				mode.."_draw_axis",
				mode.."_axis_labels",
				mode.."_axis_angles",
			}
		}
		
		local relativeOptions = {
			[L(prefix.."combobox_world")] = { [mode.."_mode"] = improvedstacker.MODE_WORLD },
			[L(prefix.."combobox_prop")]  = { [mode.."_mode"] = improvedstacker.MODE_PROP  },
		}
		
		local relative = { Label = L(prefix.."label_relative"), MenuButton = "0", Options = relativeOptions }
		
		local directionOptions = {
			["1 - "..L(prefix.."combobox_direction_front")] = { [mode.."_direction"] = improvedstacker.DIRECTION_FRONT },
			["2 - "..L(prefix.."combobox_direction_back")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_BACK  },
			["3 - "..L(prefix.."combobox_direction_right")] = { [mode.."_direction"] = improvedstacker.DIRECTION_RIGHT },
			["4 - "..L(prefix.."combobox_direction_left")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_LEFT  },
			["5 - "..L(prefix.."combobox_direction_up")]    = { [mode.."_direction"] = improvedstacker.DIRECTION_UP    },
			["6 - "..L(prefix.."combobox_direction_down")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_DOWN  },
		}
		
		local directions = { Label = L(prefix.."label_direction"), MenuButton = "0", Options = directionOptions }
		
		-- populate the table of valid languages that clients can switch between
		local languageOptions = {}
		
		for code, tbl in pairs( localify.GetLocalizations() ) do
			if ( not L(prefix.."language_"..code, code) ) then continue end
			
			languageOptions[ L(prefix.."language_"..code, code) ] = { localify_language = code }
		end
		
		local languages = {
			Label      = L(prefix.."label_language"),
			MenuButton = 0,
			Options    = languageOptions,
		}
		
		cpanel:AddControl( "ComboBox", languages )
		cpanel:ControlHelp( "\n" .. L(prefix.."label_credits") )
		cpanel:AddControl( "Label",    { Text = L(prefix.."label_presets") } )
		cpanel:AddControl( "ComboBox", presets )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_freeze"),    Command = mode.."_freeze" } )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_weld"),      Command = mode.."_weld" } )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_nocollide"), Command = mode.."_nocollide" } )	
		cpanel:AddControl( "ComboBox", relative )	
		cpanel:AddControl( "ComboBox", directions )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_count"), Min = 1, Max = cvarMaxPerStack:GetInt(), Command = mode.."_count", Description = "How many props to create in each stack" } )
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_reset_offsets"), Command = mode.."_reset_offsets" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_x"),     Type = "Float", Min = - cvarMaxOffX:GetInt(), Max = cvarMaxOffX:GetInt(), Value = 0, Command = mode.."_offsetx" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_y"),     Type = "Float", Min = - cvarMaxOffY:GetInt(), Max = cvarMaxOffY:GetInt(), Value = 0, Command = mode.."_offsety" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_z"),     Type = "Float", Min = - cvarMaxOffZ:GetInt(), Max = cvarMaxOffZ:GetInt(), Value = 0, Command = mode.."_offsetz" } )
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_reset_angles"),  Command = mode.."_reset_angles" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_pitch"), Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_pitch" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_yaw"),   Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_yaw" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_roll"),  Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_roll" } )
		
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_"..(showSettings and "hide" or "show").."_settings"),   Command = mode.."_show_settings" } )
		
		if ( showSettings ) then
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_use_shift_key"), Command = mode.."_use_shift_key", Description = "Toggles the ability to hold SHIFT and click the left and right mouse buttons to change stack size" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_relative"),      Command = mode.."_relative",      Description = "Stacks each prop relative to the prop right before it. This allows you to create curved stacks" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_material"),      Command = mode.."_material",      Description = "Applies the material of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_color"),         Command = mode.."_color",         Description = "Applies the color of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_physprop"),      Command = mode.."_physprop",      Description = "Applies the physical properties of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_ghost"),         Command = mode.."_ghostall",      Description = "Creates every ghost prop in the stack instead of just the first ghost prop" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis"),          Command = mode.."_draw_axis", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis_labels"),   Command = mode.."_axis_labels", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis_angles"),   Command = mode.."_axis_angles", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_halo"),          Command = mode.."_draw_halos", Description = "Gives halos to all of the props in to ghosted stack" } )
			cpanel:AddControl( "Slider",   { Label = L(prefix.."label_opacity"), Type = "Integer", Min = 0, Max = 255, Command = mode.."_opacity" } )
			cpanel:AddControl( "Color",    { Label = L(prefix.."checkbox_halo_color"), Red = mode.."_halo_r", Green = mode.."_halo_g", Blue = mode.."_halo_b", Alpha = mode.."_halo_a" } )
		end
	end
	
	concommand.Add( mode.."_show_settings", function( ply, cmd, args )
		local cpanel = controlpanel.Get( mode )
		if ( not IsValid( cpanel ) ) then return end
		showSettings = not showSettings
		cpanel:ClearControls()
		buildCPanel( cpanel )
	end )

	-- listen for changes to the localify language and reload the tool's menu to update the localizations
	cvars.AddChangeCallback( "localify_language", function( name, old, new )
		local cpanel = controlpanel.Get( mode )
		if ( not IsValid( cpanel ) ) then return end
		cpanel:ClearControls()
		buildCPanel( cpanel )
	end, "improvedstacker" )
	
	TOOL.BuildCPanel = buildCPanel

	--[[--------------------------------------------------------------------------
	--
	-- 	PopulateToolMenu
	--
	--	Builds the admin settings control panel in the utility menu. This allows server
	--	operators to quickly and easily save/change Stacker server settings.
	--]]--
	hook.Add( "PopulateToolMenu", mode.."AdminUtilities", function()
		spawnmenu.AddToolMenuOption( "Utilities", "Admin", mode.."_utils", L(prefix.."name"), "", "", function( cpanel )
			
			-- quick presets for default settings
			local presets = {
				label      = "Presets",
				menubutton = 1,
				folder     = mode.."_admin",
				options = {
					[L(prefix.."combobox_default")]      = improvedstacker.SETTINGS_DEFAULT,
					[L(prefix.."combobox_sandbox")]      = improvedstacker.SETTINGS_SANDBOX,
					[L(prefix.."combobox_darkrp")]       = improvedstacker.SETTINGS_DARKRP,
					[L(prefix.."combobox_singleplayer")] = improvedstacker.SETTINGS_SINGLEPLAYER,
				},
				cvars = {
					{ CVar = mode.."_max_per_player",    CCmd = mode.."_set_max_per_player" },
					{ CVar = mode.."_max_per_stack",     CCmd = mode.."_set_max_per_stack" },
					{ CVar = mode.."_delay",             CCmd = mode.."_set_delay" },
					{ CVar = mode.."_max_offsetx",       CCmd = mode.."_set_max_offsetx" },
					{ CVar = mode.."_max_offsety",       CCmd = mode.."_set_max_offsety" },
					{ CVar = mode.."_max_offsetz",       CCmd = mode.."_set_max_offsetz" },
					{ CVar = mode.."_force_freeze",      CCmd = mode.."_set_force_freeze" },
					{ CVar = mode.."_force_weld",        CCmd = mode.."_set_force_weld" },
					{ CVar = mode.."_force_nocollide",   CCmd = mode.."_set_force_nocollide" },
					{ CVar = mode.."_force_stayinworld", CCmd = mode.."_set_force_stayinworld" },
				},
			}
			
			local ctrl = vgui.Create( "StackerControlPresets", cpanel )
			ctrl:SetPreset( presets.folder )
			for k, v in pairs( presets.options ) do
				ctrl:AddOption( k, v )
			end
			for k, v in pairs( presets.cvars ) do
				ctrl:AddConVar( v )
			end			
			cpanel:AddItem( ctrl )
			--cpanel:AddControl( "ComboBox", presets )
			
			
			local bg = Color( 210, 210, 210 ) or Color( 179, 216, 255 )
			local fg = Color( 240, 240, 240 ) or Color( 229, 242, 255 )
			
			local sliders = {
				{ String = "max_per_player", Min = -1, Max = 2048,  Decimals = 0 },
				{ String = "max_per_stack",  Min =  1, Max = 100,   Decimals = 0 },
				{ String = "delay",          Min =  0, Max = 5,                  },
				{ String = "max_offsetx",    Min =  0, Max = 10000,              },
				{ String = "max_offsety",    Min =  0, Max = 10000,              },
				{ String = "max_offsetz",    Min =  0, Max = 10000,              },
			}
			
			local sliderlist = vgui.Create( "DListLayout", cpanel )
			sliderlist:DockPadding( 3, 1, 3, 3 )
			sliderlist:SetPaintBackground( true )
			function sliderlist:Paint( w, h )
				draw.RoundedBox( 0, 0, 0, w, h, bg )
			end
			cpanel:AddItem( sliderlist )
			
			for k, data in pairs( sliders ) do
				local list = vgui.Create( "DListLayout", sliderlist )
				list:DockPadding( 5, 0, 5, 5 )
				list:DockMargin( 0, 2, 0, 0 )
				list:SetPaintBackground( true )
				function list:Paint( w, h )
					draw.RoundedBox( 0, 0, 0, w, h, fg )
				end
			
				local decimals = data.Decimals or 2
			
				local slider = vgui.Create( "StackerDNumSlider", list )
				slider:SetText( L(prefix.."label_"..data.String) )
				slider.Label:SetFont( "DermaDefaultBold" )
				slider:SetMinMax( data.Min, data.Max )
				slider:SetDark( true )
				slider:SizeToContents()
				slider:SetDecimals( decimals )
				slider:SetValue( decimals == 0 and GetConVar( mode.."_"..data.String ):GetInt() or GetConVar( mode.."_"..data.String ):GetFloat(), true )
				
				local cmd = mode.."_set_"..data.String
				
				function slider:OnValueChanged( value )
					value = math.Round( value, decimals )
					RunConsoleCommand( cmd, value )
				end
				
				if ( L(prefix.."help_"..data.String) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."help_"..data.String) )
					help:DockMargin( 10, 0, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
				end
				
				if ( L(prefix.."warning_"..data.String) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."warning_"..data.String) )
					help:DockMargin( 10, 0, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
					help:SetTextColor( Color( 200, 0, 0 ) )
				end
				
				cvars.AddChangeCallback( mode.."_"..data.String, function( name, old, new )
					if ( not IsValid( slider ) ) then return end
					slider:SetValue( GetConVar( mode.."_"..data.String ):GetFloat(), true )
				end, mode.."_"..data.String.."_utilities" )
			end
			
			
			
			local checkboxes = {
				"freeze",
				"weld",
				"nocollide",
				"nocollide_all",
				"stayinworld",
			}

			local cblist = vgui.Create( "DListLayout", cpanel )
			cblist:DockPadding( 3, 1, 3, 3 )
			cblist:SetPaintBackground( true )
			function cblist:Paint( w, h )
				draw.RoundedBox( 0, 0, 0, w, h, bg )
			end
			cpanel:AddItem( cblist )
			
			for k, data in pairs( checkboxes ) do
				local list = vgui.Create( "DListLayout", cblist )
				list:DockPadding( 5, 5, 5, 5 )
				list:DockMargin( 0, 2, 0, 0 )
				list:SetPaintBackground( true )
				function list:Paint( w, h )
					draw.RoundedBox( 0, 0, 0, w, h, fg )
				end
			
				local cb = vgui.Create( "DCheckBoxLabel", list )
				cb:SetText( L(prefix.."checkbox_"..data) )
				cb:SetChecked( GetConVar( mode.."_force_"..data ):GetBool() )
				cb.Label:SetFont( "DermaDefaultBold" )
				cb:SizeToContents()
				cb:SetDark( true )
				-- we don't want this value to be changed while the server is running, so disable the checkbox
				if ( data == "nocollide_all" ) then
					cb:SetDisabled( true )
				end
				
				function cb:OnChange( bool ) RunConsoleCommand( mode.."_set_force_"..data, bool and "1" or "0" ) end
				
				cvars.AddChangeCallback( mode.."_force_"..data, function( name, old, new )
					if ( not IsValid( cb ) ) then return end
					cb:SetChecked( tobool( new ) )
				end, mode.."_"..data.."_utilities" )
				
				if ( L(prefix.."help_"..data) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."help_"..data) )
					help:DockMargin( 25, 5, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
				end
				
				if ( L(prefix.."warning_"..data) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."warning_"..data) )
					help:DockMargin( 25, 5, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
					help:SetTextColor( Color( 200, 0, 0 ) )
				end
			end
		end )
	end )
end

--PATH addons/sl_utils/lua/weapons/gmod_tool/stools/textscreen.lua:
TOOL.Category = "Construction"
TOOL.Name = "#tool.textscreen.name"
TOOL.Command = nil
TOOL.ConfigName = ""
local textBox = {}
local lineLabels = {}
local labels = {}
local sliders = {}
local rainbowCheckboxes = {}
local textscreenFonts = textscreenFonts
local rainbow_enabled = cvars.Number("ss_enable_rainbow", 1)
local max_characters = cvars.Number("ss_max_characters", 0)

for i = 1, 5 do
	TOOL.ClientConVar["text" .. i] = ""
	TOOL.ClientConVar["size" .. i] = 20
	TOOL.ClientConVar["r" .. i] = 255
	TOOL.ClientConVar["g" .. i] = 255
	TOOL.ClientConVar["b" .. i] = 255
	TOOL.ClientConVar["a" .. i] = 255
	TOOL.ClientConVar["font" .. i] = 1
	TOOL.ClientConVar["rainbow" .. i] = 0
end

cleanup.Register("textscreens")

if (CLIENT) then
	TOOL.Information = {
		{ name = "left" },
		{ name = "right" },
		{ name = "reload" },
	}
	-- Add default english language strings here, in case no localisation exists
	language.Add("tool.textscreen.name", "3D2D Textscreen")
	language.Add("tool.textscreen.desc", "Create a textscreen with multiple lines, font colours and sizes.")
	language.Add("tool.textscreen.left", "Spawn a textscreen.") -- Does not work with capital T in tool. Same with right and reload.
	language.Add("tool.textscreen.right", "Update textscreen with settings.")
	language.Add("tool.textscreen.reload", "Copy textscreen.")
	language.Add("Undone.textscreens", "Undone textscreen")
	language.Add("Undone_textscreens", "Undone textscreen")
	language.Add("Cleanup.textscreens", "Textscreens")
	language.Add("Cleanup_textscreens", "Textscreens")
	language.Add("Cleaned.textscreens", "Cleaned up all textscreens")
	language.Add("Cleaned_textscreens", "Cleaned up all textscreens")
	language.Add("SBoxLimit.textscreens", "You've hit the textscreen limit!")
	language.Add("SBoxLimit_textscreens", "You've hit the textscreen limit!")
end

function TOOL:LeftClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end
	local ply = self:GetOwner()

	if hook.Run("PlayerSpawnTextscreen", ply, tr) == false then return false end

	if not (self:GetWeapon():CheckLimit("textscreens")) then return false end
	-- ensure at least 1 line of the textscreen has text before creating entity
	local hasText = false
	for i = 1, 5 do
		local text = self:GetClientInfo("text" .. i) or ""
		if text ~= "" then
			hasText = true
		end
	end
	if not hasText then return false end
	local textScreen = ents.Create("sammyservers_textscreen")
	textScreen:SetPos(tr.HitPos)
	local angle = tr.HitNormal:Angle()
	angle:RotateAroundAxis(tr.HitNormal:Angle():Right(), -90)
	angle:RotateAroundAxis(tr.HitNormal:Angle():Forward(), 90)
	textScreen:SetAngles(angle)
	textScreen:Spawn()
	textScreen:Activate()

	undo.Create("textscreens")
	undo.AddEntity(textScreen)
	undo.SetPlayer(ply)
	undo.Finish()
	ply:AddCount("textscreens", textScreen)
	ply:AddCleanup("textscreens", textScreen)

	for i = 1, 5 do
		local txt = self:GetClientInfo("text" .. i) or ""
		textScreen:SetLine(
			i, -- Line
			max_characters ~= 0 and string.Left(txt, max_characters) or txt, -- text
			Color( -- Color
				tonumber(self:GetClientInfo("r" .. i)) or 255,
				tonumber(self:GetClientInfo("g" .. i)) or 255,
				tonumber(self:GetClientInfo("b" .. i)) or 255,
				tonumber(self:GetClientInfo("a" .. i)) or 255
			),
			tonumber(self:GetClientInfo("size" .. i)) or 20,
			-- font
			tonumber(self:GetClientInfo("font" .. i)) or 1,

			rainbow_enabled == 1 and tonumber(self:GetClientInfo("rainbow" .. i)) or 0
		)
	end

	return true
end

function TOOL:RightClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end
	local traceEnt = tr.Entity

	if (IsValid(traceEnt) and traceEnt:GetClass() == "sammyservers_textscreen") then
		for i = 1, 5 do
			local txt = tostring(self:GetClientInfo("text" .. i))
			traceEnt:SetLine(
				i, -- Line
				max_characters ~= 0 and string.Left(txt, max_characters) or txt, -- text
				Color( -- Color
					tonumber(self:GetClientInfo("r" .. i)) or 255,
					tonumber(self:GetClientInfo("g" .. i)) or 255,
					tonumber(self:GetClientInfo("b" .. i)) or 255,
					tonumber(self:GetClientInfo("a" .. i)) or 255
				),
				tonumber(self:GetClientInfo("size" .. i)) or 20,
				-- font
				tonumber(self:GetClientInfo("font" .. i)) or 1,

				rainbow_enabled and tonumber(self:GetClientInfo("rainbow" .. i)) or 0
			)
		end

		traceEnt:Broadcast()

		return true
	end
end

function TOOL:Reload(tr)
	if (SERVER) then return true end
	local traceEnt = tr.Entity
	if (not isentity(traceEnt) or traceEnt:GetClass() ~= "sammyservers_textscreen") then return false end

	for i = 1, 5 do
		local linedata = traceEnt.lines[i]
		RunConsoleCommand("textscreen_r" .. i, linedata.color.r)
		RunConsoleCommand("textscreen_g" .. i, linedata.color.g)
		RunConsoleCommand("textscreen_b" .. i, linedata.color.b)
		RunConsoleCommand("textscreen_a" .. i, linedata.color.a)
		RunConsoleCommand("textscreen_size" .. i, linedata.size)
		RunConsoleCommand("textscreen_text" .. i, linedata.text)
		RunConsoleCommand("textscreen_font" .. i, linedata.font)
		RunConsoleCommand("textscreen_rainbow" .. i, linedata.rainbow)
	end

	return true
end

local conVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)
	local logo = vgui.Create("DImage", CPanel)
	logo:SetSize(267, 134)
	logo:SetImage("textscreens/logo.png")
	CPanel:AddItem(logo)

	CPanel:AddControl("Header", {
		Text = "#tool.textscreen.name",
		Description = "#tool.textscreen.desc"
	})

	local function TrimFontName(fontnum)
		return string.Left(textscreenFonts[fontnum], 8) == "Screens_" and string.TrimLeft(textscreenFonts[fontnum], "Screens_") or textscreenFonts[fontnum]
	end

	local changefont
	local fontnum = textscreenFonts[GetConVar("textscreen_font1"):GetInt()] ~= nil and GetConVar("textscreen_font1"):GetInt() or 1

	cvars.AddChangeCallback("textscreen_font1", function(convar_name, value_old, value_new)
		fontnum = textscreenFonts[tonumber(value_new)] ~= nil and tonumber(value_new) or 1
		local font = TrimFontName(fontnum)
		changefont:SetText("Change font (" .. font .. ")")
	end)

	local function ResetFont(lines, text)
		if #lines >= 5 then
			fontnum = 1
			for i = 1, 5 do
				RunConsoleCommand("textscreen_font" .. i, 1)
			end
		end
		for k, i in pairs(lines) do
			if text then
				RunConsoleCommand("textscreen_text" .. i, "")
				labels[i]:SetText("")
			end
			labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
		end
	end

	resetall = vgui.Create("DButton", resetbuttons)
	resetall:SetSize(100, 25)
	resetall:SetText("Reset all")

	resetall.DoClick = function()
		local menu = DermaMenu()

		menu:AddOption("Reset colors", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
			end
		end)

		menu:AddOption("Reset sizes", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
			end
		end)

		menu:AddOption("Reset textboxes", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_text" .. i, "")
				textBox[i]:SetValue("")
			end
		end)

		menu:AddOption("Reset fonts", function()
			ResetFont({1, 2, 3, 4, 5}, false)
		end)

		if rainbow_enabled == 1 then
			menu:AddOption("Reset rainbow", function()
				for i = 1, 5 do
					rainbowCheckboxes[i]:SetValue(0)
				end
			end)
		end

		menu:AddOption("Reset everything", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				RunConsoleCommand("textscreen_font" .. i, 1)
				textBox[i]:SetValue("")
				if rainbow_enabled == 1 then
					rainbowCheckboxes[i]:SetValue(0)
				end
			end
			ResetFont({1, 2, 3, 4, 5}, true)
		end)

		menu:Open()
	end

	CPanel:AddItem(resetall)
	resetline = vgui.Create("DButton")
	resetline:SetSize(100, 25)
	resetline:SetText("Reset line")

	resetline.DoClick = function()
		local menu = DermaMenu()

		for i = 1, 5 do
			menu:AddOption("Reset line " .. i, function()
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				textBox[i]:SetValue("")
				ResetFont({i}, true)
			end)
		end

		menu:AddOption("Reset all lines", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				RunConsoleCommand("textscreen_font" .. i, 1)
				textBox[i]:SetValue("")
			end
			ResetFont({1, 2, 3, 4, 5}, true)
		end)

		menu:Open()
	end

	CPanel:AddItem(resetline)

	-- Change font
	changefont = vgui.Create("DButton")
	changefont:SetSize(100, 25)
	changefont:SetText("Change font (" .. TrimFontName(fontnum) .. ")" )

	changefont.DoClick = function()
		local menu = DermaMenu()

		for i = 1, #textscreenFonts do
			local font = TrimFontName(i)
			menu:AddOption(font, function()
				fontnum = i
				for o = 1, 5 do
					RunConsoleCommand("textscreen_font" .. o, i)
					labels[o]:SetFont(textscreenFonts[fontnum] .. "_MENU")
				end
				changefont:SetText("Change font (" .. font .. ")")
			end)
		end

		menu:Open()
	end

	CPanel:AddItem(changefont)

	CPanel:AddControl("ComboBox", {
		MenuButton = 1,
		Folder = "textscreen",
		Options = {
			["#preset.default"] = conVarsDefault
		},
		CVars = table.GetKeys(conVarsDefault)
	})

	for i = 1, 5 do
		lineLabels[i] = CPanel:AddControl("Label", {
			Text = "Line " .. i,
			Description = "Line " .. i
		})

		lineLabels[i]:SetFont("Default")

		CPanel:AddControl("Color", {
			Label = "Line " .. i .. " font color",
			Red = "textscreen_r" .. i,
			Green = "textscreen_g" .. i,
			Blue = "textscreen_b" .. i,
			Alpha = "textscreen_a" .. i,
			ShowHSV = 1,
			ShowRGB = 1,
			Multiplier = 255
		})

		if rainbow_enabled == 1 then
			rainbowCheckboxes[i] = vgui.Create("DCheckBoxLabel")
			rainbowCheckboxes[i]:SetText("Rainbow Text")
			rainbowCheckboxes[i]:SetTextColor(Color(0,0,0,255))
			rainbowCheckboxes[i]:SetConVar("textscreen_rainbow" .. i)
			rainbowCheckboxes[i]:SetTooltip("Enable for rainbow text")
			rainbowCheckboxes[i]:SetValue(GetConVar("textscreen_rainbow" .. i):GetInt())
			CPanel:AddItem(rainbowCheckboxes[i])
		end

		sliders[i] = vgui.Create("DNumSlider")
		sliders[i]:SetText("Font size")
		sliders[i]:SetMinMax(20, 100)
		sliders[i]:SetDecimals(0)
		sliders[i]:SetValue(GetConVar("textscreen_size" .. i))
		sliders[i]:SetConVar("textscreen_size" .. i)

		CPanel:AddItem(sliders[i])
		textBox[i] = vgui.Create("DTextEntry")
		textBox[i]:SetUpdateOnType(true)
		textBox[i]:SetEnterAllowed(true)
		textBox[i]:SetConVar("textscreen_text" .. i)
		textBox[i]:SetValue(GetConVar("textscreen_text" .. i):GetString())

		textBox[i].OnTextChanged = function()
			labels[i]:SetText(textBox[i]:GetValue())
		end

		if max_characters ~= 0 then
			textBox[i].AllowInput = function()
				if string.len(textBox[i]:GetValue()) >= max_characters then return true end
			end
		end

		CPanel:AddItem(textBox[i])

		labels[i] = CPanel:AddControl("Label", {
			Text = #GetConVar("textscreen_text" .. i):GetString() >= 1 and GetConVar("textscreen_text" .. i):GetString() or "Line " .. i,
			Description = "Line " .. i
		})

		labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
		labels[i]:SetAutoStretchVertical(true)
		labels[i]:SetDisabled(true)
		labels[i]:SetHeight(50)

		labels[i].Think = function()
			labels[i]:SetColor(
				Color(
					GetConVar("textscreen_r" .. i):GetInt(),
					GetConVar("textscreen_g" .. i):GetInt(),
					GetConVar("textscreen_b" .. i):GetInt(),
					GetConVar("textscreen_a" .. i):GetInt()
				)
			)
		end
	end
end

--PATH addons/sl_utils/lua/weapons/guigui_handcuffs_lockpick.lua:
SWEP.PrintName = guigui_handcuff_lang().PrintName_Lockpick
SWEP.Author = "Guillaume"
SWEP.Category = "Guillaume's weapons"
SWEP.Instructions = guigui_handcuff_lang().Instructions_Lockpick
SWEP.Contact = "steamcommunity.com/id/guillaume_"
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.ViewModelFOV = 62
SWEP.WorldModel = ""
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "rpg"
SWEP.UseHands = true
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic  = true
SWEP.Secondary.Ammo = "none"
SWEP.DrawAmmo = false

function SWEP:Initialize()
	self:SetHoldType("normal")
end

function SWEP:Deploy()
	return true
end

function SWEP:PreDrawViewModel()
	return true
end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	local ply = self.Owner
	local ent = ply:GetEyeTrace().Entity
	if ply:GetPos():DistToSqr(ent:GetPos())<2500 then
		if ent:IsValid() and ent:IsPlayer() then
			local wep = ent:GetActiveWeapon():GetClass()
			if wep == "guigui_handcuffed" then
				ply:PrintMessage(4, "...")
				timer.Simple(2, function() if ply:GetPos():DistToSqr(ent:GetPos())<2500 then RemoveHandcuff(ent, ply, 1) ply:StripWeapon("guigui_handcuffs_lockpick") end end )
			end
		end
	end
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end
--PATH addons/sl_main_system/lua/weapons/mad_asso_detecteur/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_baton11/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_baton13/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_baton14/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "14 : Baton marguerite" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/baton9.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_baton" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Baton NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "magie"
SWEP.holdtype = "sl_mage_ht_mad"
SWEP.BonusDegats = 114

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_baton18/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_baton2/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_baton8/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "8 : Baton maudit" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/baton15.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_baton" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Baton NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "magie"
SWEP.holdtype = "sl_mage_ht_mad"
SWEP.BonusDegats = 66

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_corpsacorps/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "Base : Corps à Corps" 
SWEP.Author 		      = "Absalom" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "weapon_base" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Base NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------

local DATA = {}
DATA.Name = "sl_corpsacorps_ht_mad"
DATA.HoldType = "sl_corpsacorps_ht_mad"
DATA.BaseHoldType = "normal"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
    { Sequence = "mad_tambour_run_base", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
    { Sequence = "mad_eaujump3", Weight = 1 },
}            

DATA.Translations[ ACT_MP_WALK ] = {
    { Sequence = "mad_tambour_run_base", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
    { Sequence = "mad_tambour_run_base", Weight = 1 },
}

DATA.Translations[ ACT_MP_RUN ] = {
    { Sequence = "mad_tambour_run_base", Weight = 5 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )

--------------------------------------------------------------------------

function SWEP:PrimaryAttack()
end

function SWEP:SecondaryAttack()
end

SWEP.TypeArme = "corpsacorps"

function SWEP:Initialize()
    if IsValid(self) and IsValid(self:GetOwner()) then
        self:GetOwner():SetNWInt("Combo", 0)
        if CLIENT then
        self:GetOwner():SetNWInt("FOV", self:GetOwner():GetFOV())
        end
        self.Weapon:SetHoldType( "sl_corpsacorps_ht_mad" )
    end
end

function SWEP:Deploy()
    self.Weapon:SetHoldType( "sl_corpsacorps_ht_mad" )
    print(self:GetOwner():GetFOV())
    self:GetOwner():SetNWInt("Combo", 0)   
end

--PATH addons/sl_main_system/lua/weapons/mad_dague14/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_dague14/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "14 : Dague Royal" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/dague34.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_dague" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Dague NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "dague"
SWEP.holdtype = "sl_dague_ht_mad"
SWEP.BonusDegats = 114

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_dague21/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "21 : Dague en Rubis" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/dague22.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_dague" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Dague NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "dague"
SWEP.holdtype = "sl_dague_ht_mad"
SWEP.BonusDegats = 170

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_dague4/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "4 : Dague en fer aiguisé" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/dague18.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_dague" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Dague NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "dague"
SWEP.holdtype = "sl_dague_ht_mad"
SWEP.BonusDegats = 34

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_dague7/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_epee1/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs
                modif par Absalom

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "E : Épée en fer poli" 
SWEP.Author 		      = "Absalom" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/sword8.mdl"
SWEP.ShowWorldModel         = false
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_epee" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Epee NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

SWEP.TypeArme = "sword"
SWEP.BonusDegats = 18
SWEP.holdtype = "sl_epee_ht_mad"
--PATH addons/sl_main_system/lua/weapons/mad_epee10/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_epee21/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "21 : Épée Majestueuse" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/sword9.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_epee" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Epee NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "sword"
SWEP.holdtype = "sl_epee_ht_mad"
SWEP.BonusDegats = 178

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_epee22/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_epee4/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "4 : Épée en fer aiguisé" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/sword15.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_epee" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Epee NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "sword"
SWEP.holdtype = "sl_epee_ht_mad"
SWEP.BonusDegats = 42

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_epee6/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "6 : Épée barbare" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/petitsword3.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_epee" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Epee NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "sword"
SWEP.holdtype = "sl_epee_ht_mad"
SWEP.BonusDegats = 58

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_epee7/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_marteau2/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "2 : Marteau en fer fine" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/marteau2.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_marteau" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Hache NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

SWEP.TypeArme = "marteau"
SWEP.BonusDegats = 18
SWEP.holdtype = "sl_marteau_ht_mad"
--PATH addons/sl_main_system/lua/weapons/mad_marteau20/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_marteau20/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "20 : Armorslayer en Pierre" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/enormeepee11.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_marteau" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Hache NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "marteau"
SWEP.holdtype = "sl_marteau_ht_mad"
SWEP.BonusDegats = 162

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_marteau22/cl_init.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

include("shared.lua")
AddCSLuaFile()

function SWEP:DrawHUD()

end
--PATH addons/sl_main_system/lua/weapons/mad_marteau22/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "22 : Armorslayer Royale" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/enormeepee7.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_marteau" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Hache NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "marteau"
SWEP.holdtype = "sl_marteau_ht_mad"
SWEP.BonusDegats = 178

--------------------------------------------------------------------------
--PATH addons/sl_main_system/lua/weapons/mad_marteau4/shared.lua:
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

--[[

                888b     d888        d8888 8888888b.  
                8888b   d8888       d88888 888  "Y88b 
                88888b.d88888      d88P888 888    888 
                888Y88888P888     d88P 888 888    888 
                888 Y888P 888    d88P  888 888    888 
                888  Y8P  888   d88P   888 888    888 
                888   "   888  d8888888888 888  .d88P 
                888       888 d88P     888 8888888P"  
    
                Addon réalisé par Mad (alias retard.fr).
                => Discord : madbrigs

]]--

-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================
-- ============================================================================================

SWEP.PrintName 		      = "4 : Marteau en fer aiguisé" 
SWEP.Author 		      = "Mad" 
SWEP.Instructions 	      = "" 
SWEP.Contact 		      = "" 
SWEP.AdminSpawnable       = true 
SWEP.Spawnable 		      = true 
SWEP.ViewModelFlip        = false
SWEP.ViewModelFOV 	      = 85
SWEP.ViewModel =            ""
SWEP.WorldModel = ""
SWEP.ModelArme = "models/mad_worldmodel/marteau8.mdl"
SWEP.ShowWorldModel         = true
SWEP.AutoSwitchTo 	      = false 
SWEP.AutoSwitchFrom       = true 
SWEP.DrawAmmo             = false 
SWEP.Base                 = "mad_marteau" 
SWEP.Slot 			      = 0
SWEP.SlotPos              = 0
SWEP.DrawCrosshair        = true 
SWEP.Weight               = 0 

SWEP.Category             = "[Hache NW]"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true
SWEP.Primary.Ammo         	= "None"

SWEP.Secondary.ClipSize		= 0
SWEP.Secondary.DefaultClip	= 0
SWEP.Secondary.Automatic   	= true
SWEP.Secondary.Ammo         = "none"

--------------------------------------------------------------------------
SWEP.TypeArme = "marteau"
SWEP.holdtype = "sl_marteau_ht_mad"
SWEP.BonusDegats = 34

--------------------------------------------------------------------------
--PATH addons/sl_utils/lua/weapons/surrender_animation_swep/shared.lua:
--[[
Only allowed to use in Addons by
​Mattis 'Mattzimann' Krämer
]]--

SWEP.Purpose				= "You can now surrender!"
SWEP.Instructions 			= "Click to surrender."

SWEP.Category 				= "EGM Animation SWEPs"
SWEP.PrintName				= "Surrender"
SWEP.Spawnable				= true
SWEP.deactivateOnMove		= 110

SWEP.Base = "animation_swep_base"

if CLIENT then
	function SWEP:GetGesture()
		return {
	        ["ValveBiped.Bip01_L_Forearm"] = Angle(25,-65,25),
	        ["ValveBiped.Bip01_R_Forearm"] = Angle(-25,-65,-25),
	        ["ValveBiped.Bip01_L_UpperArm"] = Angle(-70,-180,70),
	        ["ValveBiped.Bip01_R_UpperArm"] = Angle(70,-180,-70),
	    }
	end
end

--PATH gamemodes/mangarp/entities/weapons/weapon_glock2/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Author = "DarkRP Developers"
    SWEP.Instructions = "Shoot with it"
    SWEP.Slot = 1
    SWEP.SlotPos = 0
    SWEP.IconLetter = "c"

    killicon.AddFont("weapon_glock2", "CSKillIcons", SWEP.IconLetter, Color(255, 80, 0, 255))
end

SWEP.Base = "weapon_cs_base2"

SWEP.PrintName = "Glock"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "DarkRP (Weapon)"

SWEP.ViewModel = "models/weapons/cstrike/c_pist_glock18.mdl"
SWEP.WorldModel = "models/weapons/w_pist_glock18.mdl"
SWEP.HoldType = "pistol"
SWEP.LoweredHoldType = "normal"

SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.Primary.Sound = Sound("Weapon_Glock.Single")
SWEP.Primary.Recoil = 2
SWEP.Primary.Unrecoil = 6
SWEP.Primary.Damage = 10
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0.05
SWEP.Primary.ClipSize = 20
SWEP.Primary.Delay = 0.06
SWEP.Primary.DefaultClip = 20
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

--Start of Firemode configuration
SWEP.IronSightsPos = Vector(-5.77, -6.6, 2.7)
SWEP.IronSightsAng = Vector(0.9, 0, 0)

--PATH lua/entities/bagel3/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Bagel"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Bagel3.mdl")
	
end
--PATH lua/entities/bdcakeslice2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Birthday Cake (Slice)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A piece of birthday cake"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/cakepiece2.mdl")
	
end
--PATH lua/entities/bdcakeslice3/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Birthday Cake (Slice)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A piece of birthday cake"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/cakeslice1.mdl")
	
end
--PATH lua/entities/beer1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Beer (Master)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/beer_master.mdl")
	
end
--PATH lua/entities/bricks_server_npc/cl_init.lua:
include('shared.lua')

local Padding = 10
function ENT:Draw()
	self:DrawModel()

	local ShopName = ((BRICKS_SERVER.CONFIG.NPCS or {})[(self:GetNPCKeyVar() or 0)] or {}).Name or self.PrintName

    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    Ang:RotateAroundAxis(Ang:Up(), 90)
	Ang:RotateAroundAxis(Ang:Forward(), 90)

	local YPos = -(self:OBBMaxs().z*20)-5

	local Distance = LocalPlayer():GetPos():DistToSqr( self:GetPos() )

	if( Distance < BRICKS_SERVER.CONFIG.GENERAL["3D2D Display Distance"] ) then
		cam.Start3D2D(Pos + Ang:Up() * 0.5, Ang, 0.05)
		
			surface.SetFont("BRICKS_SERVER_Font45")
		
			local width, height = surface.GetTextSize( ShopName )
			width, height = width+20, height+15

			draw.RoundedBox( 5, -(width/2)-Padding, YPos-(height+(2*Padding)), width+(2*Padding), height+(2*Padding), BRICKS_SERVER.Func.GetTheme( 1 ) )		
			draw.RoundedBox( 5, -(width/2)-Padding, YPos-(height+(2*Padding)), 20, height+(2*Padding), BRICKS_SERVER.Func.GetTheme( 5 ) )	

			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 1 ) )
			surface.DrawRect( -(width/2)-Padding+5, YPos-(height+(2*Padding)), 15, height+(2*Padding) )

			draw.SimpleText( ShopName, "BRICKS_SERVER_Font45", 0, YPos-((height+(2*Padding))/2), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 1 )
			
		cam.End3D2D()
	end
end
--PATH addons/sl_main_system/lua/entities/buellost_tree/shared.lua:
ENT.Base	    			= "base_ai"
ENT.Type	    			= "ai"
ENT.PrintName				= "Arbre"
ENT.Author					= "Buellos"
ENT.Category                = "[SL - CRAFTING]"
ENT.Instructions			= ""
ENT.Spawnable				= true
ENT.AdminSpawnable			= true

ENT.TreeType = "bois"

function ENT:SetupDataTables()	
	self:NetworkVar( "Int", 0, "ResourceMax" )
end
--PATH lua/entities/champagne2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Champagne (on plate)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A bottle of champagne on a plate"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/champagneonplate.mdl")
	
end
--PATH lua/entities/champagne5/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Champagne"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/champagne3.mdl")
	
end
--PATH lua/entities/chipsbag2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Chips - Crunch Tators"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A bag of Chips (Crisps if ya from Blighty)"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/chipsbag2.mdl")
	
end
--PATH lua/entities/chipslays4/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Chips - Lays Sour Cream and Onion"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A bag of Lays"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/chipslays4.mdl")
	
end
--PATH lua/entities/chipslays6/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Chips - Lays Flamin Hot"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A bag of Lays"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/chipslays6.mdl")
	
end
--PATH lua/entities/chocolatine/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Chocolatine"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Chocolatine.mdl")
	
end
--PATH lua/entities/colas1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Cola (Swift)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/cola_swift1.mdl")
	
end
--PATH gamemodes/mangarp/entities/entities/darkrp_tip_jar/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Tip Jar"
ENT.Author = "FPtje"
ENT.Spawnable = false
ENT.IsTipjar = true

function ENT:initVars()
    self.model = "models/props_lab/jar01a.mdl"
    self.damage = 100
    self.callOnRemoveId = "tipjar_activedonation_" .. self:EntIndex() .. "_"

    self.activeDonations = {}
    self.madeDonations = {}

    self.PlayerUse = true
end

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
end

function ENT:UpdateActiveDonation(ply, amount)
    local old = self.activeDonations[ply]
    self.activeDonations[ply] = amount

    self:PruneActiveDonations()

    ply:CallOnRemove(self.callOnRemoveId .. ply:UserID(), function()
        if not IsValid(self) then return end

        self:ExitActiveDonation(ply)
    end)

    hook.Call("tipjarUpdateActiveDonation", DarkRP.hooks, self, ply, amount, old)
end

function ENT:ExitActiveDonation(ply)
    local old = self.activeDonations[ply]

    self.activeDonations[ply] = nil

    self:PruneActiveDonations()
    hook.Call("tipjarExitActiveDonation", DarkRP.hooks, self, ply, old)

    self:RemoveCallOnRemove(self.callOnRemoveId .. ply:UserID())
end

function ENT:ClearActiveDonations()
    table.Empty(self.activeDonations)
    hook.Call("tipjarClearActiveDonation", DarkRP.hooks, self)
end

function ENT:PruneActiveDonations()
    for ply, _ in pairs(self.activeDonations) do
        if not IsValid(ply) then self.activeDonations[ply] = nil end
    end
end

function ENT:AddDonation(name, amount)
    local lastDonation = self.madeDonations[#self.madeDonations]

    if lastDonation and lastDonation.name == name then
        lastDonation.amount = lastDonation.amount + amount
    else
        table.insert(self.madeDonations, {
            name = name,
            amount = amount,
        })
   end

   -- Enforce maximum of 100 donations
   while #self.madeDonations > 100 do
       table.remove(self.madeDonations, 1)
   end
end

function ENT:ClearDonations()
    table.Empty(self.madeDonations)
end

--PATH addons/the_perfect_training_system/lua/entities/diablos_punching_base/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end


--PATH addons/the_perfect_training_system/lua/entities/diablos_treadmill/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()

	if Diablos.TS.Materials["TreadmillMat"] then
		self:SetTreadmillMaterial(self:GetTrainingSpeed())
	end

	local ply = LocalPlayer()
	local CUR_DIST = ply:GetPos():DistToSqr(self:GetPos())

	if CUR_DIST > Diablos.TS.Optimization * 100 then return end

	local curtime = CurTime()

	local ang = self:GetAngles()

	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), -90)

	local w = 600
	local h = 355
	local lineY = 60

	cam.Start3D2D(self:GetPos() + self:GetUp() * 63.3 + self:GetRight() * 15 + self:GetForward() * -44.1, ang + Angle(0, 0, -16), .05)

		surface.SetDrawColor(Diablos.TS.Colors.gl) surface.DrawRect(0, 0, w, h)
		surface.SetDrawColor(color_white) surface.DrawRect(10, 10, w - 20, h - 20)

		-- Lines
		surface.SetDrawColor(color_black)
		surface.DrawRect(50, lineY, w - 100, 3)
		surface.DrawRect(50, h - lineY - 3, w - 100, 3)

		local text
		if IsValid(self:GetTrainingPlayer()) then
			if self:GetTrainingPlayer() == ply then
				local timeRemaining = math.floor(ply.EndTraining - curtime)
				text = string.format(Diablos.TS:GetLanguageString("treadmillDrawLeft"), timeRemaining)
			else
				text = Diablos.TS:GetLanguageString("treadmillDrawSomeone")
			end
		else
			text = Diablos.TS:GetLanguageString("treadmillDrawCanUse")
		end
		draw.SimpleText(text, "Diablos:Font:TS:45", w / 2, 80, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

		surface.SetDrawColor(color_white)
		surface.SetMaterial(Diablos.TS.Materials.treadmillOrientation)
		local SIZE_MATERIAL = 100
		surface.DrawTexturedRect(w / 2 - SIZE_MATERIAL - 5, h - 80 - SIZE_MATERIAL, SIZE_MATERIAL, SIZE_MATERIAL)

		local orientation = self:GetAngle()
		local tab = Diablos.TS.TreadmillSizeEquivalence[orientation]
		draw.SimpleText(string.format("%u°", tab.angle), "Diablos:Font:TS:80", w / 2 + SIZE_MATERIAL, h - 80 - SIZE_MATERIAL / 2, color_black, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

	cam.End3D2D()
end
--PATH lua/entities/digestivechoko/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Digestives Chocolate"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A pack of chocolate Digestives"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Digestive1.mdl")
	
end
--PATH lua/entities/drgbase_nextbot/locomotion.lua:
if CLIENT then return end

-- Handlers --

function ENT:_InitLocomotion()
	self:SetAcceleration(self.Acceleration)
	self:SetDeceleration(self.Deceleration)
	self:SetJumpHeight(self.JumpHeight)
	self:SetStepHeight(self.StepHeight)
	self:SetMaxYawRate(self.MaxYawRate)
	self:SetDeathDropHeight(self.DeathDropHeight)
end

-- Getters/setters --

function ENT:GetAcceleration()
	return self.loco:GetAcceleration()
end
function ENT:SetAcceleration(accel)
	return self.loco:SetAcceleration(accel)
end

function ENT:GetDeceleration()
	return self.loco:GetDeceleration()
end
function ENT:SetDeceleration(decel)
	return self.loco:SetDeceleration(decel)
end

function ENT:GetJumpHeight()
	return self.loco:GetJumpHeight()
end
function ENT:SetJumpHeight(height)
	return self.loco:SetJumpHeight(height)
end

function ENT:GetStepHeight()
	return self.loco:GetStepHeight()
end
function ENT:SetStepHeight(height)
	return self.loco:SetStepHeight(height)
end

function ENT:GetMaxYawRate()
	return self.loco:GetMaxYawRate()
end
function ENT:SetMaxYawRate(rate)
	return self.loco:SetMaxYawRate(rate)
end

function ENT:GetDeathDropHeight()
	return self.loco:GetDeathDropHeight()
end
function ENT:SetDeathDropHeight(height)
	return self.loco:SetDeathDropHeight(height)
end

function ENT:IsStuck()
	return self.loco:IsStuck()
end
function ENT:ClearStuck()
	return self.loco:ClearStuck()
end
function ENT:IsStuckInWorld()
	return self:TraceHull(Vector(0, 0, 0), {
		collisiongroup = COLLISION_GROUP_DEBRIS
	}).HitWorld
end

function ENT:GetDesiredSpeed()
	return self:GetNW2Float("DrGBaseDesiredSpeed")
end
function ENT:SetDesiredSpeed(speed)
	return self.loco:SetDesiredSpeed(speed)
end

-- Meta --

local locoMETA = FindMetaTable("CLuaLocomotion")

local old_IsClimbingOrJumping = locoMETA.IsClimbingOrJumping
function locoMETA:IsClimbingOrJumping()
	local nextbot = self:GetNextBot()
	if nextbot.IsDrGNextbot then
		return nextbot:IsClimbing() or old_IsClimbingOrJumping(self)
	else return old_IsClimbingOrJumping(self) end
end

local old_IsUsingLadder = locoMETA.IsUsingLadder
function locoMETA:IsUsingLadder()
	local nextbot = self:GetNextBot()
	if nextbot.IsDrGNextbot then
		local bool, ladder = nextbot:IsClimbingLadder()
		return bool
	else return old_IsUsingLadder(self) end
end

local old_SetDesiredSpeed = locoMETA.SetDesiredSpeed
function locoMETA:SetDesiredSpeed(speed)
	local nextbot = self:GetNextBot()
	if nextbot.IsDrGNextbot then
		nextbot:SetNW2Float("DrGBaseDesiredSpeed", speed)
		nextbot:SetNW2Float("DrGBaseSpeed", speed/nextbot:GetScale())
		return old_SetDesiredSpeed(self, speed)
	else return old_SetDesiredSpeed(self, speed) end
end

--PATH lua/entities/drgbase_nextbot/weapons.lua:

-- Getters/setters --

function ENT:GetActiveWeapon()
	return self:GetNW2Entity("DrGBaseWeapon")
end
function ENT:GetWeapon(class)
	if isstring(class) then
		return self._DrGBaseWeapons[class] or NULL
	else return self:GetActiveWeapon() end
end
function ENT:HasWeapon(class)
	return IsValid(self:GetWeapon(class))
end
function ENT:HaveWeapon(class)
	return self:HasWeapon(class)
end

function ENT:GetWeapons()
	return table.DrG_Copy(self._DrGBaseWeapons)
end
function ENT:GetWeaponCount()
	local count = 0
	for class, weapon in pairs(self._DrGBaseWeapons) do
		if IsValid(weapon) then count = count+1 end
	end
	return count
end

function ENT:IsReloadingWeapon()
	if not self:HasWeapon() then return false end
	return self:GetNW2Bool("DrGBaseReloadWeapon")
end

function ENT:GetShootPos(class)
	if self:HasWeapon(class) then
		local weapon = self:GetWeapon(class)
		for boneId = 0, (weapon:GetBoneCount()-1) do
			local boneName = weapon:GetBoneName(boneId)
			local lookedUp = self:LookupBone(boneName)
			if lookedUp then
				local bonepos = self:GetBonePosition(lookedUp)
				return bonepos
			end
		end
		return self:WorldSpaceCenter()
	else return self:WorldSpaceCenter() end
end
function ENT:GetAimVector(class)
	if self:IsPossessed() then
		local lockedOn = self:PossessionGetLockedOn()
		if IsValid(lockedOn) then
			local aimAt = self:OnAimAtEntity(lockedOn) or lockedOn:WorldSpaceCenter()
			return self:GetShootPos(class):DrG_Direction(aimAt):GetNormalized()
		else return self:GetShootPos(class):DrG_Direction(self:PossessorTrace().HitPos):GetNormalized() end
	elseif self:HasEnemy() then
		local enemy = self:GetEnemy()
		local aimAt = self:OnAimAtEntity(enemy) or enemy:WorldSpaceCenter()
		return self:GetShootPos(class):DrG_Direction(aimAt):GetNormalized()
	else return self:EyeAngles():Forward() end
end

-- Functions --

-- Hooks --

function ENT:OnWeaponChange() end
function ENT:OnPickupWeapon() end
function ENT:OnDropWeapon() end
function ENT:OnAimAtEntity() end

-- Handlers --

local LONG_RANGE = {
	["crossbow"] = true
}
local MEDIUM_RANGE = {
	["pistol"] = true,
	["revolver"] = true,
	["grenade"] = true,
	["duel"] = true
}
local CLOSE_RANGE = {
	["shotgun"] = true,
	["camera"] = true
}

function ENT:_InitWeapons()
	self._DrGBaseWeapons = {}
	self:SetNW2VarProxy("DrGBaseWeapon", function(self, name, old, new)
		if not self:OnWeaponChange(old, new) and SERVER and
		self.BehaviourType == AI_BEHAV_HUMAN then
			local holdType = new:GetHoldType()
			if DrGBase.IsMeleeWeapon(new) then
				self.RangeAttackRange = 0
				self.MeleeAttackRange = 30
				self.ReachEnemyRange = 25
				self.AvoidEnemyRange = 0
			elseif LONG_RANGE[holdType] then
				self.RangeAttackRange = 3000
				self.MeleeAttackRange = 0
				self.ReachEnemyRange = 2000
				self.AvoidEnemyRange = 750
			elseif CLOSE_RANGE[holdType] then
				self.RangeAttackRange = 325
				self.MeleeAttackRange = 0
				self.ReachEnemyRange = 250
				self.AvoidEnemyRange = 175
			elseif MEDIUM_RANGE[holdType] then
				self.RangeAttackRange = 750
				self.MeleeAttackRange = 0
				self.ReachEnemyRange = 500
				self.AvoidEnemyRange = 350
			else
				self.RangeAttackRange = 1500
				self.MeleeAttackRange = 0
				self.ReachEnemyRange = 1000
				self.AvoidEnemyRange = 750
			end
		end
	end)
	if CLIENT then return end
	if self.UseWeapons then
		for i, class in ipairs(self.Weapons) do
			self:GiveWeapon(class)
		end
		self:RandomWeapon()
	end
end

if SERVER then

	-- Misc --

	local function IsWeapon(ent)
		return isentity(ent) and IsValid(ent) and ent:IsWeapon()
	end

	-- Getters/setters --

	function ENT:SetActiveWeapon(weapon)
		if not IsWeapon(weapon) then return false end
		if self._DrGBaseWeapons[weapon:GetClass()] ~= weapon then return false end
		local active = self:GetActiveWeapon()
		if IsValid(active) then active:SetNoDraw(true) end
		weapon:SetNoDraw(false)
		self:SetNW2Entity("DrGBaseWeapon", weapon)
		return true
	end

	function ENT:GetWeaponPrimaryAmmo(class)
		if not self:HasWeapon(class) then return 0 end
		local wep = self:GetWeapon(class)
		if wep:GetMaxClip1() > 0 then return wep:Clip1()
		elseif wep:GetPrimaryAmmoType() > -1 then
			return -1
		else return math.huge end
	end
	function ENT:GetWeaponSecondaryAmmo(class)
		if not self:HasWeapon(class) then return 0 end
		local wep = self:GetWeapon(class)
		if wep:GetMaxClip2() > 0 then return wep:Clip2()
		elseif wep:GetSecondaryAmmoType() > -1 then
			return -1
		else return math.huge end
	end

	function ENT:IsWeaponPrimaryFull(class)
		if not self:HasWeapon(class) then return false end
		local ammo = self:GetWeaponPrimaryAmmo(class)
		if ammo == math.huge or ammo == -1 then return true end
		return ammo >= self:GetWeapon(class):GetMaxClip1()
	end
	function ENT:IsWeaponPrimaryEmpty(class)
		if not self:HasWeapon(class) then return true end
		local ammo = self:GetWeaponPrimaryAmmo(class)
		if ammo == -1 then return false end
		return ammo <= 0
	end

	function ENT:IsWeaponSecondaryFull(class)
		if not self:HasWeapon(class) then return false end
		local ammo = self:GetWeaponSecondaryAmmo(class)
		if ammo == math.huge or ammo == -1 then return true end
		return ammo >= self:GetWeapon(class):GetMaxClip2()
	end
	function ENT:IsWeaponSecondaryEmpty(class)
		if not self:HasWeapon(class) then return true end
		local ammo = self:GetWeaponSecondaryAmmo(class)
		if ammo == -1 then return false end
		return ammo <= 0
	end

	function ENT:IsWeaponFull(class)
		return self:IsWeaponPrimaryFull(class) and self:IsWeaponSecondaryFull(class)
	end
	function ENT:IsWeaponEmpty(class)
		return self:IsWeaponPrimaryEmpty(class) and self:IsWeaponSecondaryEmpty(class)
	end

	-- Functions --

	function ENT:GiveWeapon(class)
		if not self:HasWeapon(class) then
			local weapon = ents.Create(class)
			if not IsValid(weapon) then return NULL end
			if IsWeapon(weapon) then
				weapon:Spawn()
				if not self:PickupWeapon(weapon) then
					weapon:Remove()
					return NULL
				else return weapon end
			else
				weapon:Remove()
				return NULL
			end
		else return self:GetWeapon(class) end
	end
	function ENT:PickupWeapon(weapon)
		if not IsWeapon(weapon) then return false end
		if self:HasWeapon(weapon:GetClass()) then return false end
		weapon:SetPos(self:WorldSpaceCenter())
		weapon:SetNotSolid(true)
		weapon:SetMoveType(MOVETYPE_NONE)
		weapon:SetOwner(self)
		weapon:SetParent(self)
		weapon:AddEffects(EF_BONEMERGE)
		self._DrGBaseWeapons[weapon:GetClass()] = weapon
		self:OnPickupWeapon(weapon, weapon:GetClass())
		self:NetMessage("DrGBasePickupWeapon", weapon)
		if IsValid(self:GetActiveWeapon()) then
			weapon:SetNoDraw(true)
		else self:SetActiveWeapon(weapon) end
		return true
	end

	function ENT:RemoveWeapon(weapon)
		weapon = self:DropWeapon(weapon or self:GetActiveWeapon())
		if IsValid(weapon) then
			weapon:Remove()
			return weapon
		else return NULL end
	end
	function ENT:DropWeapon(weapon)
		if weapon == nil then weapon = self:GetActiveWeapon() end
		if isstring(weapon) then weapon = self:GetWeapon(weapon) end
		if not IsWeapon(weapon) then return NULL end
		if self._DrGBaseWeapons[weapon:GetClass()] ~= weapon then return NULL end
		local active = self:GetActiveWeapon()
		weapon:SetOwner(NULL)
		weapon:SetParent(NULL)
		weapon:RemoveEffects(EF_BONEMERGE)
		weapon:SetMoveType(MOVETYPE_VPHYSICS)
		weapon:SetPos(self:WorldSpaceCenter())
		self._DrGBaseWeapons[weapon:GetClass()] = nil
		self:OnDropWeapon(weapon, weapon:GetClass())
		self:NetMessage("DrGBaseDropWeapon", weapon:GetClass())
		if active == weapon then self:SwitchWeapon() end
		weapon:SetNoDraw(false)
		weapon:SetNotSolid(false)
		return weapon
	end

	function ENT:SelectWeapon(class)
		local weapon = self:GetWeapon(class)
		if not IsValid(weapon) then return NULL end
		self:SetActiveWeapon(weapon)
		return weapon
	end
	function ENT:SwitchWeapon()
		local weapon = table.DrG_Fetch(self._DrGBaseWeapons, function(weap1, weap2)
			if not IsValid(weap1) then return false end
			if not IsValid(weap2) then return true end
			local res = self:OnSwitchWeapon(weap1, weap2)
			if isbool(res) then return res end
			return weap1:GetWeight() > weap2:GetWeight()
		end)
		if not IsValid(weapon) then return NULL end
		self:SetActiveWeapon(weapon)
		return weapon
	end
	function ENT:RandomWeapon()
		local weapons = {}
		for class, weapon in pairs(self._DrGBaseWeapons) do
			if IsValid(weapon) then table.insert(weapons, weapon) end
		end
		if #weapons > 0 then
			local weapon = weapons[math.random(#weapons)]
			self:SetActiveWeapon(weapon)
			return weapon
		else return NULL end
	end

	-- Shoot/reload
	local SUPPORTED_GUNS = {
		["weapon_ar2"] = {
			Bullet = {Damage = 8, TracerName = "AR2Tracer", Spread = Vector(0.020, 0.020, 0)},
			Sound = "Weapon_AR2.Single", Empty = "Weapon_AR2.Empty",
			Delay = 0.1, Cost = 1
		},
		["weapon_smg1"] = {
			Bullet = {Damage = 4, Spread = Vector(0.035, 0.035, 0)},
			Sound = "Weapon_SMG1.Single", Empty = "Weapon_SMG1.Empty",
			Delay = 0.065, Cost = 1
		},
		["weapon_shotgun"] = {
			Bullet = {Damage = 8, Spread = Vector(0.1, 0.1, 0), Num = 7},
			Sound = "Weapon_Shotgun.Single", Empty = "Weapon_Shotgun.Empty",
			Delay = 1.25, Cost = 1
		},
		["weapon_pistol"] = {
			Bullet = {Damage = 5, Spread = Vector(0.015, 0.015, 0)},
			Sound = "Weapon_Pistol.Single", Empty = "Weapon_Pistol.Empty",
			Delay = 0.75, Cost = 1
		},
		["weapon_357"] = {
			Bullet = {Damage = 40, Spread = Vector(0.015, 0.015, 0)},
			Sound = "Weapon_Revolver.Single", Empty = "Weapon_Pistol.Empty",
			Delay = 1.25, Cost = 1
		}
	}
	local function ShootGun(self, weapon, data)
		if not weapon._DrGBaseNextShoot or CurTime() > weapon._DrGBaseNextShoot then
			weapon._DrGBaseNextShoot = CurTime() + data.Delay
			if weapon:Clip1() >= data.Cost then
				weapon:EmitSound(data.Sound)
				data.Bullet.Src = self:GetShootPos()
				data.Bullet.Dir = self:GetAimVector()
				data.Bullet.Filter = {self, weapon, self:GetPossessor()}
				data.Bullet.Callback = function(self, tr, dmg)
					dmg:SetInflictor(weapon)
				end
				self:FireBullets(data.Bullet)
				weapon:SetClip1(weapon:Clip1() - data.Cost)
				return true
			else
				weapon:EmitSound(data.Empty)
				return false
			end
		else return false end
	end
	local function UseToolgun(self, toolgun, tr)
		if IsValid(tr.Entity) then
			local ent = tr.Entity
			local res = self:OnUseToolgun(ent, tr)
			if not isbool(res) then
				local rand = math.random(6)
				if rand == 1 then
					ent:SetColor(Color(math.random(0, 255), math.random(0, 255), math.random(0, 255)))
				elseif rand == 2 then
					local materials = list.Get("OverrideMaterials")
					ent:SetMaterial(materials[math.random(#materials)])
				elseif rand == 3 then
					local fx = EffectData()
					fx:SetOrigin(ent:GetPos())
					fx:SetEntity(ent)
					util.Effect("entity_remove", fx, true, true)
					if ent:IsPlayer() then ent:KillSilent()
					else SafeRemoveEntity(ent) end
				elseif rand == 4 then
					local dmg = DamageInfo()
					dmg:SetDamage(math.random(1, ent:Health()))
					dmg:SetAttacker(self)
					dmg:SetInflictor(toolgun)
					ent:DispatchTraceAttack(dmg, tr)
				elseif rand == 5 then
					local health = ent:Health()
					local maxHealth = ent:GetMaxHealth()
					ent:SetHealth(math.min(health + math.random(maxHealth - health + 1), maxHealth))
				elseif rand == 6 then
					local scale = math.Rand(0.1, 2)
					if ent.IsDrGNextbot then ent:Scale(scale, 0.1)
					else ent:SetModelScale(ent:GetModelScale()*scale, 0.1) end
				elseif rand == 7 then

				end
				return true
			else return res end
		else return false end
	end
	local function FireCrossbow(self, crossbow, target)
		local speed = 3500
		local offset = self:GetAimVector()*10
		if isentity(target) then
			local shootPos = self:GetShootPos()+offset
			local aimAt = self:OnAimAtEntity(target) or target:WorldSpaceCenter()
			local dist = shootPos:Distance(aimAt)
			if target:IsNPC() then
				return FireCrossbow(self, crossbow, aimAt+target:GetGroundSpeedVelocity()*(dist/speed))
			else return FireCrossbow(self, crossbow, aimAt+target:GetVelocity()*(dist/speed)) end
		elseif isvector(target) then
			local bolt = ents.Create("crossbow_bolt")
			if not IsValid(bolt) then return NULL end
			local shootPos = self:GetShootPos()+offset
			local dir = shootPos:DrG_Direction(target)
			bolt:SetOwner(self)
			bolt:SetPos(shootPos)
			bolt:SetAngles(dir:Angle())
			bolt:Fire("SetDamage", 100)
			bolt:Spawn()
			bolt:SetVelocity(dir:GetNormalized()*speed)
			return bolt
		else return NULL end
	end
	function ENT:WeaponPrimaryFire(anim)
		if not self:HasWeapon() then return false end
		if self:IsReloadingWeapon() then return false end
		local weapon = self:GetWeapon()
		local class = weapon:GetClass()
		if class == "gmod_tool" then
			if not weapon._DrGBaseNextShoot or CurTime() > weapon._DrGBaseNextShoot then
				weapon._DrGBaseNextShoot = CurTime() + 1.25
				local shootPos = self:GetShootPos()
				local tr = util.DrG_TraceLine({
					start = shootPos, endpos = shootPos+self:GetAimVector()*99999,
					filter = {self, weapon, self:GetPossessor()}
				})
				if UseToolgun(self, weapon, tr) then
					weapon:DoShootEffect(tr.HitPos, tr.HitNormal, tr.Entity, tr.PhysicsBone, true)
					self:PlayAnimation(anim)
				end
				return true
			else return false end
		elseif class == "weapon_crossbow" then
			if not weapon._DrGBaseNextShoot or CurTime() > weapon._DrGBaseNextShoot then
				weapon._DrGBaseNextShoot = CurTime() + 2.5
				if self:IsPossessed() then
					local lockedOn = self:PossessionGetLockedOn()
					if not IsValid(lockedOn) then
						FireCrossbow(self, weapon, self:PossessorTrace().HitPos)
					else FireCrossbow(self, weapon, lockedOn) end
				elseif self:HasEnemy() then
					FireCrossbow(self, weapon, self:GetEnemy())
				elseif self:HadEnemy() then
					self:UpdateEnemy()
					return self:WeaponPrimaryFire(anim)
				else FireCrossbow(self, weapon, self:GetPos()+self:GetForward()*3500) end
				weapon:EmitSound("Weapon_Crossbow.Single")
				weapon:EmitSound("Weapon_Crossbow.BoltFly")
				self:PlayAnimation(anim)
				return true
			else return false end
		elseif class == "gmod_camera" then
			if not weapon._DrGBaseNextShoot or CurTime() > weapon._DrGBaseNextShoot then
				weapon._DrGBaseNextShoot = CurTime() + 2.5
				weapon:EmitSound(weapon.ShootSound)
				return true
			else return false end
		elseif SUPPORTED_GUNS[class] then
			if weapon:Clip1() > weapon:GetMaxClip1() then weapon:SetClip1(weapon:GetMaxClip1()) end
			local data = SUPPORTED_GUNS[weapon:GetClass()]
			local res = ShootGun(self, weapon, data)
			if res then self:PlayAnimation(anim) end
			return res
		elseif weapon:IsScripted() and not self:IsWeaponPrimaryEmpty() then
			if CurTime() < weapon:GetNextPrimaryFire() then return false end
			self:PlayAnimation(anim)
			weapon:PrimaryAttack()
		else return false end
		return true
	end
	function ENT:WeaponSecondaryFire(anim)
		if not self:HasWeapon() then return false end
		if self:IsReloadingWeapon() then return false end
		local weapon = self:GetWeapon()
		local class = weapon:GetClass()
		if class == "weapon_ar2" then
			if not weapon._DrGBaseNextShoot or CurTime() > weapon._DrGBaseNextShoot then
				weapon._DrGBaseNextShoot = CurTime() + 1.5
				--[[local ball = ents.Create("prop_combine_ball")
				if not IsValid(ball) then return false end
				ball:SetOwner(self)
				ball:SetPos(self:GetShootPos()+self:GetAimVector()*10)
				ball:Spawn()
				local phys = ball:GetPhysicsObject()
				phys:Wake()
				phys:SetVelocity(self:GetAimVector()*500)]]
			else return false end
			return true
		elseif class == "weapon_shotgun" then
			if isstring(anim) then self:AddGestureSequence(anim)
			elseif isnumber(anim) then self:AddGesture(anim) end
			return ShootGun(self, weapon, {
				Bullet = {Damage = 8, Spread = Vector(0.1, 0.1, 0), Num = 14},
				Sound = "Weapon_Shotgun.Double", Empty = "Weapon_Shotgun.Empty",
				Delay = 1.25, Cost = 2
			}, anim)
		elseif weapon:IsScripted() and not self:IsWeaponSecondaryEmpty() then
			if CurTime() < weapon:GetNextSecondaryFire() then return false end
			if isstring(anim) then self:AddGestureSequence(anim)
			elseif isnumber(anim) then self:AddGesture(anim) end
			weapon:SecondaryAttack()
		else return false end
		return true
	end
	function ENT:WeaponReload(anim)
		if not self:HasWeapon() then return false end
		if self:IsReloadingWeapon() then return false end
		local weapon = self:GetWeapon()
		self:SetNW2Bool("DrGBaseReloadWeapon", true)
		self:Timer(self:PlayAnimation(anim) or 0, function()
			self:SetNW2Bool("DrGBaseReloadWeapon", false)
			if not self:HasWeapon() then return end
			weapon = self:GetWeapon()
			if not self:IsWeaponPrimaryFull() then
				weapon:SetClip1(weapon:GetMaxClip1())
			end
			if not self:IsWeaponSecondaryFull() then
				weapon:SetClip2(weapon:GetMaxClip2())
			end
		end)
		return true
	end

	-- Hooks --

	function ENT:OnSwitchWeapon() end
	function ENT:OnUseToolgun() end

	-- Handlers --

	hook.Add("PlayerCanPickupWeapon", "DrGBaseNextbotWeaponDisablePickup", function(ply, weapon)
		local owner = weapon:GetOwner()
		if IsValid(owner) and owner.IsDrGNextbot then return false end
	end)

else

	-- Getters/setters --

	-- Functions --

	-- Hooks --

	-- Handlers --

end

--PATH lua/drgbase/entity_helpers.lua:
if not istable(ENT) then return end

-- Print --

function ENT:PrintPoseParameters()
	for i = 0, (self:GetNumPoseParameters()-1) do
		local min, max = self:GetPoseParameterRange(i)
		print(self:GetPoseParameterName(i).." "..min.." / "..max)
	end
end
function ENT:PrintAnimations()
	for i, seq in pairs(self:GetSequenceList()) do
		local act = self:GetSequenceActivity(i)
		if act ~= -1 then
			print(i.." => "..seq.." / "..act.." => "..self:GetSequenceActivityName(i))
		else
			print(i.." => "..seq.." / -1")
		end
	end
end
function ENT:PrintBones()
	for i = 0, (self:GetBoneCount()-1) do
		local bonename = self:GetBoneName(i)
		if bonename == nil then continue end
		print(i.." => "..bonename)
	end
end
function ENT:PrintAttachments()
	for i, attach in ipairs(self:GetAttachments()) do
		print(attach.id.." => "..attach.name)
	end
end
function ENT:PrintBodygroups()
	for i, group in ipairs(self:GetBodyGroups()) do
		print(group.id.." => "..group.name.." ("..group.num.." subgroups)")
	end
end

-- Timers --

function ENT:Timer(...)
	return self:DrG_Timer(...)
end
function ENT:LoopTimer(...)
	return self:DrG_LoopTimer(...)
end

-- Traces --

function ENT:TraceLine(vec, data)
	return self:DrG_TraceLine(vec, data)
end
function ENT:TraceHull(vec, data)
	return self:DrG_TraceHull(vec, data)
end
function ENT:TraceLineRadial(distance, precision, data)
	return self:DrG_TraceLineRadial(distance, precision, data)
end
function ENT:TraceHullRadial(distance, precision, data)
	return self:DrG_TraceHullRadial(distance, precision, data)
end

-- Misc --

function ENT:ScreenShake(amplitude, frequency, duration, radius)
	return util.ScreenShake(self:GetPos(), amplitude, frequency, duration, radius)
end

function ENT:GetCooldown(name)
	local delay = self:GetNW2Float("DrGBaseCooldowns/"..tostring(name), false)
	if delay ~= false then
		return math.Clamp(delay - CurTime(), 0, math.huge)
	else return 0 end
end

--[[function ENT:GetScale()
	return self:GetModelScale()
end
function ENT:SetScale(scale)
	return self:SetModelScale(scale)
end
function ENT:Scale(scale)
	return self:SetModelScale(self:GetModelScale()*scale)
end]]

-- Net --

function ENT:NetMessage(name, ...)
	return net.DrG_Send("DrGBaseEntMessage", name, self, ...)
end
function ENT:_HandleNetMessage() end
function ENT:OnNetMessage() end

if SERVER then
	AddCSLuaFile()

	-- Misc --

	function ENT:RandomPos(min, max)
		return self:DrG_RandomPos(min, max)
	end

	function ENT:SetCooldown(name, delay)
		self:SetNW2Float("DrGBaseCooldowns/"..tostring(name), CurTime() + delay)
	end

	function ENT:PushEntity(ent, force)
		if istable(ent) then
			local vecs = {}
			for i, en in ipairs(ent) do
				if not IsValid(en) then continue end
				vecs[en:EntIndex()] = self:PushEntity(en, force)
			end
			return vecs
		elseif isentity(ent) and IsValid(ent) then
			local direction = self:GetPos():DrG_Direction(ent:GetPos())
			local forward = direction
			forward.z = 0
			forward:Normalize()
			local right = Vector()
			right:Set(forward)
			right:Rotate(Angle(0, -90, 0))
			local up = Vector(0, 0, 1)
			local vec = forward*force.x + right*force.y + up*force.z
			local phys = ent:GetPhysicsObject()
			if ent:IsNextBot() then
				local jumpHeight = ent.loco:GetJumpHeight()
				local seq = ent:GetSequence()
				local rate = ent:GetPlaybackRate()
				local cycle = ent:GetCycle()
				ent.loco:SetJumpHeight(1)
				ent.loco:Jump()
				ent.loco:SetJumpHeight(jumpHeight)
				ent.loco:SetVelocity(ent.loco:GetVelocity()+vec)
				ent:ResetSequence(seq)
				ent:SetPlaybackRate(rate)
				ent:SetCycle(cycle)
			elseif IsValid(phys) and not ent:IsPlayer() then
				phys:AddVelocity(vec)
			else ent:SetVelocity(ent:GetVelocity()+vec) end
			return vec
		end
	end

	-- Net --

	net.DrG_Receive("DrGBaseEntMessage", function(ply, name, self, ...)
		if not IsValid(self) then return end
		if not self.IsDrGEntity then return end
		if not self:_HandleNetMessage(name, ply, ...) then
			self:OnNetMessage(name, ply, ...)
		end
	end)
	function ENT:CallOnClient(name, ...)
		if not isstring(name) then return end
		return self:NetMessage("DrGBaseCallOnClient", name, ...)
	end

	function ENT:NetCallback(name, callback, ply, ...)
		if not isfunction(callback) then return end
		if not ply:IsPlayer() then return end
		return ply:DrG_NetCallback(name, function(...)
			if IsValid(self) then callback(self, ...) end
		end, self, ...)
	end

	-- Effects --

	function ENT:ParticleEffect(effect, ...)
		return self:DrG_ParticleEffect(effect, ...)
	end
	function ENT:DynamicLight(color, radius, brightness, style, attachment)
		return self:DrG_DynamicLight(color, radius, brightness, style, attachment)
	end

else

	-- Net --

	local function ReceiveMessage(name, self, ...)
		if not IsValid(self) then return end
		if isfunction(self._HandleNetMessage) and isfunction(self.OnNetMessage) then
			if name == "DrGBaseCallOnClient" then
				local args, n = table.DrG_Pack(...)
				local functionName = table.remove(args, 1)
				if isfunction(self[functionName]) then
					self[functionName](self, table.DrG_Unpack(args, n-1))
				end
			elseif not self:_HandleNetMessage(name, ...) then self:OnNetMessage(name, ...) end
		else timer.DrG_Simple(engine.TickInterval(), ReceiveMessage, name, self, ...) end
	end
	net.DrG_Receive("DrGBaseEntMessage", ReceiveMessage)
	function ENT:NetCallback(name, callback, ...)
		if not isfunction(callback) then return end
		return net.DrG_UseCallback(name, function(...)
			if IsValid(self) then callback(self, ...) end
		end, self, ...)
	end

	-- Effects --

	function ENT:DynamicLight(color, radius, brightness, style, attachment)
		return self:DrG_DynamicLight(color, radius, brightness, style, attachment)
	end

end

--PATH lua/entities/drgbase_nextbot/hooks.lua:

-- Convars --

local MultDamagePlayer = CreateConVar("drgbase_multiplier_damage_players", "1", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED})
local MultDamageNPC = CreateConVar("drgbase_multiplier_damage_npc", "1", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED})
local RemoveDead = CreateConVar("drgbase_remove_dead", "0", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED})

-- Functions --

function ENT:LastHitGroup()
	return self:GetNW2Int("DrGBaseLastHitGroup", 0)
end

-- Handlers --

function ENT:_InitHooks()
	if CLIENT then return end
	self._DrGBaseLastDmgInflicted = {}
end

if SERVER then

	-- Damage --

	function ENT:OnTakeDamage(dmg)
		self:SpotEntity(dmg:GetAttacker())
	end
	--function ENT:OnTookDamage() end

	function ENT:OnFatalDamage() end
	function ENT:OnDowned() end
	--function ENT:OnDeath() end

	function ENT:OnDealtDamage() end

	local function NextbotDeath(self, dmg)
		if not IsValid(self) then return end
		if self:HasWeapon() and self.DropWeaponOnDeath then
			self:DropWeapon()
		end
		if self.RagdollOnDeath then
			return self:BecomeRagdoll(dmg)
		else self:Remove() end
	end

	function ENT:OnTraceAttack() end
	function ENT:_HandleTraceAttack(dmg, dir, tr)
		self:SetNW2Int("DrGBaseLastHitGroup", tr.HitGroup)
		self._DrGBaseHitGroupToHandle = true
	end
	function ENT:OnInjured(dmg)
		if dmg:GetDamage() <= 0 or self:GetGodMode() then
			self._DrGBaseHitGroupToHandle = false
			return dmg:ScaleDamage(0)
		else
			self:Timer(0, self._UpdateHealth)
			local hitgroup = self._DrGBaseHitGroupToHandle and self:LastHitGroup() or HITGROUP_GENERIC
			local attacker = dmg:GetAttacker()
			local res = self:OnTakeDamage(dmg, hitgroup)
			if IsValid(attacker) and DrGBase.IsTarget(attacker) then
				if self:IsAlly(attacker) then
					self._DrGBaseAllyDamageTolerance[attacker] = self._DrGBaseAllyDamageTolerance[attacker] or 0
					self._DrGBaseAllyDamageTolerance[attacker] = self._DrGBaseAllyDamageTolerance[attacker] + self.AllyDamageTolerance
					self:AddEntityRelationship(attacker, D_HT, self._DrGBaseAllyDamageTolerance[attacker])
				elseif self:IsAfraidOf(attacker) then
					self._DrGBaseAfraidOfDamageTolerance[attacker] = self._DrGBaseAfraidOfDamageTolerance[attacker] or 0
					self._DrGBaseAfraidOfDamageTolerance[attacker] = self._DrGBaseAfraidOfDamageTolerance[attacker] + self.AfraidDamageTolerance
					self:AddEntityRelationship(attacker, D_HT, self._DrGBaseAfraidOfDamageTolerance[attacker])
				elseif self:IsNeutral(attacker) then
					self._DrGBaseNeutralDamageTolerance[attacker] = self._DrGBaseNeutralDamageTolerance[attacker] or 0
					self._DrGBaseNeutralDamageTolerance[attacker] = self._DrGBaseNeutralDamageTolerance[attacker] + self.NeutralDamageTolerance
					self:AddEntityRelationship(attacker, D_HT, self._DrGBaseNeutralDamageTolerance[attacker])
				end
			end
			if res == true or self:IsDown() or self:IsDead() then
				self._DrGBaseHitGroupToHandle = false
				return dmg:ScaleDamage(0)
			else
				if isnumber(res) then dmg:SetDamage(res) end
				if dmg:GetDamage() >= self:Health() then
					if self:OnFatalDamage(dmg, hitgroup) then
						self._DrGBaseHitGroupToHandle = false
						self:SetNW2Bool("DrGBaseDown", true)
						self:SetNW2Int("DrGBaseDowned", self:GetNW2Int("DrGBaseDowned")+1)
						self:SetHealth(1)
						if #self.OnDownedSounds > 0 then
							self:EmitSound(self.OnDownedSounds[math.random(#self.OnDownedSounds)])
						end
						local noTarget = self:GetNoTarget()
						self:SetNoTarget(true)
						local data = util.DrG_SaveDmg(dmg)
						self:CallInCoroutine(function(self)
							self:OnDowned(util.DrG_LoadDmg(data), hitgroup)
							if self:Health() <= 0 then self:SetHealth(1) end
							self:SetNoTarget(noTarget)
							self:SetNW2Bool("DrGBaseDown", false)
						end)
					else self:SetHealth(0) end
					return dmg:ScaleDamage(0)
				else
					self._DrGBaseHitGroupToHandle = false
					if #self.OnDamageSounds > 0 then
						self:EmitSlotSound("DrGBaseDamageSounds", self.DamageSoundDelay, self.OnDamageSounds[math.random(#self.OnDamageSounds)])
					end
					if isfunction(self.OnTookDamage) then
						local data = util.DrG_SaveDmg(dmg)
						self:ReactInCoroutine(function(self)
							if self:IsDown() then return end
							dmg = util.DrG_LoadDmg(data)
							self:OnTookDamage(dmg, hitgroup)
						end)
					elseif isfunction(self.AfterTakeDamage) then
						local data = util.DrG_SaveDmg(dmg)
						local now = CurTime()
						self:ReactInCoroutine(function(self)
							if self:IsDown() then return end
							dmg = util.DrG_LoadDmg(data)
							self:AfterTakeDamage(dmg, CurTime()-now, hitgroup)
						end)
					end
				end
			end
		end
	end
	function ENT:OnKilled(dmg)
		if self:IsDead() then return end
		local hitgroup = self._DrGBaseHitGroupToHandle and self:LastHitGroup() or HITGROUP_GENERIC
		self._DrGBaseHitGroupToHandle = false
		self:SetHealth(0)
		self:SetNW2Bool("DrGBaseDying", true)
		self:DrG_DeathNotice(dmg:GetAttacker(), dmg:GetInflictor())
		if #self.OnDeathSounds > 0 then
			self:EmitSound(self.OnDeathSounds[math.random(#self.OnDeathSounds)])
		end
		if dmg:IsDamageType(DMG_DISSOLVE) then self:DrG_Dissolve() end
		if isfunction(self.OnDeath) then
			local data = util.DrG_SaveDmg(dmg)
			self.BehaveThread = coroutine.create(function()
				self:SetNW2Bool("DrGBaseDying", false)
				self:SetNW2Bool("DrGBaseDead", true)
				if RemoveDead:GetBool() and GetConVar("drgbase_remove_ragdolls"):GetFloat() >= 0 then
					self:Timer(GetConVar("drgbase_remove_ragdolls"):GetFloat(), self.Remove)
				end
				local now = CurTime()
				dmg = self:OnDeath(util.DrG_LoadDmg(data), hitgroup)
				if dmg == nil then
					dmg = util.DrG_LoadDmg(data)
					if CurTime() > now then
						dmg:SetDamageForce(Vector(0, 0, 1))
					end
				end
				NextbotDeath(self, dmg)
			end)
		else
			self:SetNW2Bool("DrGBaseDying", false)
			self:SetNW2Bool("DrGBaseDead", true)
			NextbotDeath(self, dmg)
		end
	end

	hook.Add("EntityTakeDamage", "DrGBaseNextbotDealtDamage", function(ent, dmg)
		local attacker = dmg:GetAttacker()
		if IsValid(attacker) and attacker.IsDrGNextbot then
			if attacker == ent then return true end
			if ent:IsPlayer() then dmg:ScaleDamage(MultDamagePlayer:GetFloat())
			else dmg:ScaleDamage(MultDamageNPC:GetFloat()) end
			local res = attacker:OnDealtDamage(ent, dmg)
			if isnumber(res) then dmg:ScaleDamage(res)
			elseif res == true then return true end
			attacker._DrGBaseLastDmgInflicted[ent] = {
				data = util.DrG_SaveDmg(dmg), time = CurTime()
			}
		end
	end)
	function ENT:LastDamageDealt(ent)
		if not self._DrGBaseLastDmgInflicted[ent] then return nil, -1 end
		local last = self._DrGBaseLastDmgInflicted[ent]
		return util.DrG_LoadDmg(last.data), last.time
	end

	-- Collisions --

	function ENT:OnCombineBall() end

	function ENT:OnPhysDamage(ent, data)
		return (data.TheirOldVelocity:Length()*data.HitObject:GetMass())/1000
	end
	function ENT:_HandleCollide(data)
		local ent = data.HitEntity
		if not IsValid(ent) then return end
		local class = ent:GetClass()
		local phys = data.HitObject
		if class == "prop_combine_ball" then
			if self:IsFlagSet(FL_DISSOLVING) then return end
			if not self:OnCombineBall(ent) then
				if not self:IsDead() then
					local dmg = DamageInfo()
					local owner = ent:GetOwner()
					dmg:SetAttacker(IsValid(owner) and owner or ent)
					dmg:SetInflictor(ent)
					dmg:SetDamage(1000)
					dmg:SetDamageType(DMG_DISSOLVE)
					dmg:SetDamageForce(ent:GetVelocity())
					self:TakeDamageInfo(dmg)
				else self:DrG_Dissolve() end
				ent:EmitSound("NPC_CombineBall.KillImpact")
			end
		elseif not ent:IsPlayerHolding() then
			local damage = math.floor(self:OnPhysDamage(ent, data))
			if damage > math.max(0, self.MinPhysDamage) then
				local dmg = DamageInfo()
				if ent:IsVehicle() and IsValid(ent:GetDriver()) then
					dmg:SetAttacker(ent:GetDriver())
				elseif IsValid(ent:GetPhysicsAttacker()) then
					dmg:SetAttacker(ent:GetPhysicsAttacker())
				else dmg:SetAttacker(ent) end
				dmg:SetInflictor(ent)
				dmg:SetDamage(damage)
				if ent:IsVehicle() then
					dmg:SetDamageType(DMG_VEHICLE)
				else dmg:SetDamageType(DMG_CRUSH) end
				dmg:SetDamageForce(phys:GetVelocity())
				self:TakeDamageInfo(dmg)
			end
		end
	end

	hook.Add("OnEntityCreated", "DrGBaseAddPhysicsCollideCallback", function(ent)
		ent:DrG_Timer(0, function()
			ent:AddCallback("PhysicsCollide", function(ent, data)
				if not isfunction(ent.PhysicsCollide) then return end
				if IsValid(data.HitEntity) and data.HitEntity.IsDrGNextbot then
					ent:PhysicsCollide(data, data.PhysObject)
				end
			end)
		end)
	end)

	-- Ground --

	function ENT:OnFallDamage(speed)
		--return math.max(0, speed-self.loco:GetDeathDropHeight())/15
		return 0
	end
	-- function ENT:OnLeftGround() end
	-- function ENT:OnLandedOnGround() end

	function ENT:OnLeaveGround() end
	function ENT:_HandleLeaveGround()
		self:SetNW2Bool("DrGBaseOnGround", false)
		self:UpdateAnimation()
		self:UpdateSpeed()
		if isfunction(self.OnLeftGround) then
			self:ReactInCoroutine(self.OnLeftGround)
		end
	end

	function ENT:OnLandOnGround() end
	function ENT:_HandleLandOnGround()
		self:SetNW2Bool("DrGBaseOnGround", true)
		self:UpdateAnimation()
		self:UpdateSpeed()
		self:InvalidatePath()
		local damage = math.floor(self:OnFallDamage(self._DrGBaseDownSpeed))
		--print(damage)
		if damage > math.max(0, self.MinFallDamage) then
			local dmg = DamageInfo()
			dmg:SetDamage(damage)
			--dmg:SetAttacker(self)
			--dmg:SetInflictor(self)
			dmg:SetDamageType(DMG_FALL)
			self:TakeDamageInfo(dmg)
		end
		if isfunction(self.OnLandedOnGround) then
			self:ReactInCoroutine(self.OnLandedOnGround)
		end
	end

	-- OnNavAreaChanged --

	function ENT:GetPreviousNavArea()
		return self._DrGBasePreviousNavArea
	end
	function ENT:GetNavArea()
		return self._DrGBaseNavArea
	end

	function ENT:OnNavAreaChanged() end
	function ENT:_HandleNavAreaChanged(old, new)
		self._DrGBasePreviousNavArea = old
		self._DrGBaseNavArea = new
	end

	-- Misc --

	hook.Add("vFireEntityStartedBurning", "DrGBaseNextbotOnIgniteVFire", function(ent)
		if ent.IsDrGNextbot then ent:OnIgnite() end
	end)

end

--PATH lua/entities/drgbase_nextbot/misc.lua:

-- Convars --

local DisableRagCollisions = CreateConVar("drgbase_ragdoll_collisions_disabled", "0", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED})
local RemoveRagdolls = CreateConVar("drgbase_remove_ragdolls", "-1", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED})
local RagdollFadeOut = CreateConVar("drgbase_ragdoll_fadeout", "3", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED})
local PossessTargetAll = CreateConVar("drgbase_possession_targetall", "1", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED})

-- Getters/setters --

function ENT:IsInRange(pos, range)
	if isentity(pos) and not IsValid(pos) then return false end
	return self:GetHullRangeSquaredTo(pos) <= (range*self:GetScale())^2
end
function ENT:GetHullRangeTo(pos)
	if isentity(pos) then pos = pos:NearestPoint(self:GetPos()) end
	return self:NearestPoint(pos):Distance(pos)
end
function ENT:GetHullRangeSquaredTo(pos)
	if isentity(pos) then pos = pos:NearestPoint(self:GetPos()) end
	return self:NearestPoint(pos):DistToSqr(pos)
end

function ENT:IsAttack(seq)
	if isstring(seq) then seq = self:LookupSequence(seq)
	elseif not isnumber(seq) then return false end
	if seq == -1 then return false end
	if self:GetNW2Bool("DrGBaseAnimAttack/"..tostring(seq)) then return true
	elseif string.find(string.lower(self:GetSequenceName(seq)), "attack") then
		return true
	elseif string.find(self:GetSequenceActivityName(seq), "ATTACK") then
		return true
	else return false end
end

-- Functions --

function ENT:EmitSlotSound(slot, duration, soundName, soundLevel, pitchPercent, volume, channel)
	local lastSlot = self._DrGBaseSlotSounds[slot]
	if lastSlot == nil or CurTime() > lastSlot then
		self._DrGBaseSlotSounds[slot] = CurTime() + duration
		self:EmitSound(soundName, soundLevel, pitchPercent, volume, channel)
		return true
	else return false end
end

function ENT:EmitStep(soundLevel, pitchPercent, volume, channel)
	if not self:OnGround() then return end
	local tr = util.TraceLine({
		start = self:GetPos(),
		endpos = self:GetPos() - self:GetUp()*999,
		filter = self
	})
	local sounds = self.Footsteps[tr.MatType] or DrGBase.DefaultFootsteps[tr.MatType]
	if not istable(sounds) or #sounds == 0 then sounds = self.Footsteps[MAT_DEFAULT] end
	if not istable(sounds) or #sounds == 0 then return false end
	return self:EmitSound(sounds[math.random(#sounds)], soundLevel, pitchPercent, volume, channel or CHAN_BODY)
end
function ENT:EmitFootstep(...)
	return self:EmitStep(...)
end

function ENT:CalcPosDirection(pos, subs)
	local direction = "N"
	if subs then
		local angle = math.AngleDifference(self:GetAngles().y + 202.5, (pos - self:GetPos()):Angle().y) + 180
		if angle > 45 and angle <= 90 then direction = "NE"
		elseif angle > 90 and angle <= 135 then direction = "E"
		elseif angle > 135 and angle <= 180 then direction = "SE"
		elseif angle > 180 and angle <= 225 then direction = "S"
		elseif angle > 225 and angle <= 270 then direction = "SW"
		elseif angle > 270 and angle <= 315 then direction = "W"
		elseif angle > 315 and angle <= 360 then direction = "NW" end
		return direction, angle
	else
		local angle = math.AngleDifference(self:GetAngles().y + 225, (pos - self:GetPos()):Angle().y) + 180
		if angle > 90 and angle <= 180 then direction = "E"
		elseif angle > 180 and angle <= 270 then direction = "S"
		elseif angle > 270 and angle <= 360 then direction = "W" end
		return direction, angle
	end
end

function ENT:CalcFlinchProbability(dmg)
	local perc = math.Clamp(dmg:GetDamage()/self:Health()*100, 0, 100)
	return math.random(100) < perc
end

function ENT:CalcOffset(vec)
	return self:GetForward()*vec.x + self:GetRight()*vec.y + self:GetUp()*vec.z
end

function ENT:Height()
	local bound1, bound2 = self:GetCollisionBounds()
	return math.max(bound1.z, bound2.z)
end
function ENT:Length()
	local bound1, bound2 = self:GetCollisionBounds()
	bound1.z, bound2.z = 0, 0
	return bound1:Distance(bound2)
end

function ENT:RandomizeBodygroup(id)
	self:SetBodygroup(id, math.random(0, self:GetBodygroupCount(id)-1))
end
function ENT:RandomizeBodygroups()
	for i, bodygroup in ipairs(self:GetBodyGroups()) do
		self:RandomizeBodygroup(bodygroup.id)
	end
end

-- Hooks --

function ENT:OnAngleChange() end
function ENT:OnFireBullets() end

-- Handlers --

function ENT:_InitMisc()
	if SERVER then
		self._DrGBaseAnimAttacks = {}
		self._DrGBaseGrabbedRagdolls = {}
		self._DrGBaseGrabbedRagdollsCollisionGroups = {}
	end
	self._DrGBaseSlotSounds = {}
	self:AddCallback("OnAngleChange", function(self, angles)
		if self:OnAngleChange(angles) then return end
		if CLIENT then return end
		self:SetAngles(Angle(0, angles.y, 0))
	end)
end

hook.Add("PhysgunDrop", "DrGBaseNextbotPhysgunDrop", function(ply, ent)
	if ent.IsDrGNextbot then ent:Timer(0, ent.SetVelocity, Vector(0, 0, 0)) end
end)
hook.Add("EntityFireBullets", "DrGBaseNextbotFireBullets", function(ent, bullet)
	if ent.IsDrGNextbot then ent:OnFireBullets(bullet) end
end)

-- Meta --

local entMETA = FindMetaTable("Entity")

local old_EyePos = entMETA.EyePos
function entMETA:EyePos()
	if self.IsDrGNextbot then
		local bound1, bound2 = self:GetCollisionBounds()
		local eyepos = self:GetPos() + (bound1 + bound2)/2
		local boneid
		if isstring(self.EyeBone) then boneid = self:LookupBone(self.EyeBone) end
		if boneid ~= nil then eyepos = self:GetBonePosition(boneid) end
		eyepos = eyepos + self:CalcOffset(self.EyeOffset)
		return eyepos
	else return old_EyePos(self) end
end

local old_EyeAngles = entMETA.EyeAngles
function entMETA:EyeAngles()
	if self.IsDrGNextbot then
		--[[if isstring(self.EyeBone) then
			local boneid = self:LookupBone(self.EyeBone)
			if boneid ~= nil then
				local pos, angles = self:GetBonePosition(boneid)
				return self:GetAngles() + angles + self.EyeAngle
			end
		end]]
		return self:GetAngles() + self.EyeAngle
	else return old_EyeAngles(self) end
end

if SERVER then

	-- Getters/setters --

	function ENT:GetNoTarget()
		return self:IsFlagSet(FL_NOTARGET)
	end
	function ENT:SetNoTarget(bool)
		if bool then self:AddFlags(FL_NOTARGET)
		else self:RemoveFlags(FL_NOTARGET) end
	end

	-- Functions --

	function ENT:GroundDistance(pos, generator)
		if isentity(pos) then pos = pos:GetPos() end
		local path = Path("Follow")
		path:Compute(self, pos, generator)
		if not IsValid(path) then return -1
		else return path:GetLength() end
	end

	function ENT:Attack(attack, callback)
		attack = attack or {}
		attack.damage = attack.damage or 0
		attack.delay = attack.delay or 0
		attack.type = attack.type or DMG_GENERIC
		attack.force = attack.force or Vector(100, 0, 0)
		attack.viewpunch = attack.viewpunch or Angle(10, 0, 0)
		attack.range = attack.range or self.MeleeAttackRange
		attack.angle = attack.angle or 90
		if attack.relationships == nil then
			if self:IsPossessed() and PossessTargetAll:GetBool() then
				attack.relationships = {D_LI, D_HT, D_FR, D_NU}
			else attack.relationships = {D_HT, D_FR} end
		end
		if not istable(attack.relationships) then attack.relationships = {attack.relationships} end
		self:Timer(math.Clamp(attack.delay, 0, math.huge), function(self)
			local hit = {}
			for i, ent in ipairs(self:EntitiesInCone(attack.angle, attack.range, attack.relationships)) do
				if ent == self then continue end
				if not DrGBase.CanAttack(ent) then continue end
				if not self:Visible(ent) then continue end
				local trace = false
				local origin = self:WorldSpaceCenter()
				local aimAt = ent:WorldSpaceCenter()
				if isfunction(attack.aimat) then
					local res = attack.aimat(ent)
					if isvector(res) then aimAt = res end
				elseif isstring(attack.aimat) then
					local boneId = ent:DrG_SearchBone(attack.aimat)
					if boneId then aimAt = ent:GetBonePosition(boneId) end
				--elseif isnumber(attack.aimat) then
				end
				local dmg = DamageInfo()
				dmg:SetAttacker(self)
				dmg:SetInflictor(self)
				dmg:SetDamageType(attack.type)
				if attack.push and (not attack.groundforce or ent:IsOnGround()) then
					dmg:SetDamageForce(self:PushEntity(ent, attack.force))
				else dmg:SetDamageForce(self:CalcOffset(attack.force)) end
				if isstring(attack.attachment) or isnumber(attack.attachment) then
					if isstring(attack.attachment) then
						attack.attachment = self:LookupAttachment(attack.attachment)
					end
					local attachment = self:GetAttachment(attack.attachment)
					if attachment then
						if attack.trace then
							trace = self:TraceLine(nil, {
								endpos = attachment.Pos + attachment.Pos:DrG_Direction(aimAt),
								start = attachment.Pos
							})
						end
						origin = attachment.Pos
					end
				elseif isstring(attack.bone) or isnumber(attack.bone) then
					if isstring(attack.bone) then attack.bone = self:LookupBone(attack.bone) end
					if isnumber(attack.bone) then
						local bonePos, boneAngles = self:GetBonePosition(attack.bone)
						if attack.trace then
							trace = self:TraceLine(nil, {
								endpos = bonePos + bonePos:DrG_Direction(aimAt),
								start = bonePos
							})
						end
						origin = bonePos
					end
				elseif attack.trace then
					trace = self:TraceLine(origin:DrG_Direction(aimAt))
				end
				dmg:SetDamage(isfunction(attack.damage) and attack.damage(ent, origin) or attack.damage)
				if attack.trace and trace and trace.Entity == ent then
					dmg:SetReportedPosition(trace.HitPos)
					dmg:SetDamagePosition(trace.HitPos)
					ent:DispatchTraceAttack(dmg, trace)
				else
					dmg:SetReportedPosition(origin)
					dmg:SetDamagePosition(origin)
					ent:TakeDamageInfo(dmg)
				end
				if attack.viewpunch and ent:IsPlayer() then
					ent:ViewPunch(attack.viewpunch)
				end
				table.insert(hit, ent)
			end
			if isfunction(callback) then callback(self, hit) end
		end)
	end
	function ENT:BlastAttack(attack, callback)
		attack = attack or {}
		attack.angle = attack.angle or 360
		attack.range = attack.range or self.MeleeAttackRange
		if isnumber(attack.damage) then
			local damage = attack.damage
			attack.damage = function(ent, pos)
				return damage*math.Clamp((attack.range-pos:Distance(ent:GetPos()))/attack.range, 0, 1)
			end
		end
		return self:Attack(attack, callback)
	end

	function ENT:IsAttacking()
		if self:IsAttack(self:GetSequence()) then return true end
		for seq, playing in pairs(self._DrGBaseCurrentGestures) do
			if playing and self:IsAttack(seq) then return true end
		end
		return false
	end
	function ENT:SetAttack(seq, attack)
		if isstring(seq) then seq = self:LookupSequence(seq)
		elseif not isnumber(seq) then return false end
		if seq ~= 1 then self:SetNW2Bool("DrGBaseAnimAttack/"..tostring(seq), attack) end
	end

	function ENT:SequenceAttack(seq, cycle, attack, callback)
		if istable(seq) then
			for i, se in ipairs(seq) do self:SetAttack(se, true) end
		else self:SetAttack(seq, true) end
		self:SequenceEvent(seq, cycle, function(self)
			self:Attack(attack, callback)
		end)
	end

	function ENT:CreateProjectile(str, binds, str2)
		if not isstring(str2) then
			if not isstring(str) then return NULL end
			local proj
			if not string.EndsWith(str, ".mdl") then
				proj = ents.Create(str)
				proj:Spawn()
			else proj = DrGBase.CreateProjectile(str, binds) end
			if not IsValid(proj) then return NULL end
			proj:SetOwner(self)
			return proj
		else return self:CreateProjectile(str2) end
	end
	function ENT:CreateGrenade()
		return self:CreateProjectile("proj_drg_grenade")
	end
	function ENT:CreateFlashGrenade()
		return self:CreateProjectile("proj_drg_flashbang")
	end
	function ENT:CreateSmokeGrenade()
		return self:CreateProjectile("proj_drg_smoke_grenade")
	end
	function ENT:CreateProp(model)
		local prop = ents.Create("prop_physics")
		if not IsValid(prop) then return NULL end
		prop:SetModel(model)
		prop:SetOwner(self)
		prop:Spawn()
		return prop
	end

	function ENT:CollisionHulls(distance, forwardOnly)
		distance = distance or 5
		if distance < 0 then distance = 0 end
		local NW = self:TraceHull((self:GetForward()-self:GetRight()):GetNormalized()*distance, {step = true})
		local NE = self:TraceHull((self:GetForward()+self:GetRight()):GetNormalized()*distance, {step = true})
		if forwardOnly then
			return {
				NorthWest = NW,
				NorthEast = NE
			}
		else
			local SW = self:TraceHull((-self:GetForward()-self:GetRight()):GetNormalized()*distance, {step = true})
			local SE = self:TraceHull((-self:GetForward()+self:GetRight()):GetNormalized()*distance, {step = true})
			return {
				NorthWest = NW,
				NorthEast = NE,
				SouthWest = SW,
				SouthEast = SE
			}
		end
	end

	function ENT:IsInCone(ent, angle, distance)
		if isnumber(distance) and
		not self:IsInRange(ent, distance) then return false end
		local selfpos = self:GetPos()
		local forward = self:GetForward()
		return (selfpos + forward):DrG_Degrees(ent:GetPos(), selfpos) <= angle/2
	end
	function ENT:EntitiesInCone(angle, distance, disp, spotted)
		local entities = {}
		local selfpos = self:GetPos()
		local forward = self:GetForward()
		for ent in self:EntityIterator(disp, spotted) do
			if self:IsInCone(ent, angle, distance) then table.insert(entities, ent) end
		end
		return entities
	end
	function ENT:AlliesInCone(angle, distance, spotted)
		return self:EntitiesInCone(angle, distance, D_LI, spotted)
	end
	function ENT:EnemiesInCone(angle, distance, spotted)
		return self:EntitiesInCone(angle, distance, D_HT, spotted)
	end
	function ENT:AfraidOfInCone(angle, distance, spotted)
		return self:EntitiesInCone(angle, distance, D_FR, spotted)
	end
	function ENT:HostilesInCone(angle, distance, spotted)
		return self:EntitiesInCone(angle, distance, {D_HT, D_FR}, spotted)
	end
	function ENT:NeutralsInCone(angle, distance, spotted)
		return self:EntitiesInCone(angle, distance, D_NU, spotted)
	end

	function ENT:Kill(attacker, inflictor, type)
		local dmg = DamageInfo()
		dmg:SetDamage(math.huge)
		dmg:SetDamageType(type or DMG_DIRECT)
		dmg:SetDamageForce(Vector(0, 0, 1))
		if IsValid(attacker) then dmg:SetAttacker(attacker)
		else dmg:SetAttacker(game.GetWorld()) end
		if IsValid(inflictor) then dmg:SetInflictor(inflictor)
		elseif IsValid(attacker) then dmg:SetInflictor(attacker)
		else dmg:SetInflictor(game.GetWorld()) end
		self:OnKilled(dmg)
	end
	function ENT:Suicide(type)
		self:Kill(self, self, type)
	end

	function ENT:GrabRagdoll(ragdoll, bone, attachment)
		if not IsValid(ragdoll) then return NULL end
		local boneId = ragdoll:DrG_SearchBone(bone)
		if not boneId then return NULL end
		local attach = ents.Create("point_drg_ragdoll")
		if not IsValid(attach) then return NULL end
		if not ragdoll:IsRagdoll() then
			local dmg = DamageInfo()
			dmg:SetAttacker(self)
			dmg:SetInflictor(self)
			ragdoll = ragdoll:DrG_RagdollDeath(dmg)
		end
		if not IsValid(ragdoll) then return NULL end
		attach:SetParent(self)
		if isstring(attachment) then attach:Fire("SetParentAttachment", attachment) end
		attach:SetRagdoll(ragdoll)
		attach:SetBone(boneId)
		attach:Spawn()
		attach:Activate()
		self._DrGBaseGrabbedRagdolls[ragdoll] = self._DrGBaseGrabbedRagdolls[ragdoll] or {}
		self._DrGBaseGrabbedRagdolls[ragdoll][attach] = true
		if not self._DrGBaseGrabbedRagdollsCollisionGroups[ragdoll] then
			self._DrGBaseGrabbedRagdollsCollisionGroups[ragdoll] = ragdoll:GetCollisionGroup()
			ragdoll:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		end
		return ragdoll
	end
	function ENT:DropRagdoll(ragdoll)
		if not self:HasGrabbedRagdoll(ragdoll) then return end
		for attach, attached in pairs(self._DrGBaseGrabbedRagdolls[ragdoll]) do
			if not IsValid(attach) then continue end
			self._DrGBaseGrabbedRagdolls[ragdoll][attach] = nil
			attach:Remove()
		end
		self._DrGBaseGrabbedRagdolls[ragdoll] = nil
		ragdoll:SetCollisionGroup(self._DrGBaseGrabbedRagdollsCollisionGroups[ragdoll])
		self._DrGBaseGrabbedRagdollsCollisionGroups[ragdoll] = nil
	end
	function ENT:GrabbedRagdolls()
		local ragdolls = {}
		for ragdoll, attachs in pairs(self._DrGBaseGrabbedRagdolls) do
			if IsValid(ragdoll) then
				for attach, attached in pairs(attachs) do
					if IsValid(attach) then
						table.insert(ragdolls, ragdoll)
						break
					else attachs[attach] = nil end
				end
			else self._DrGBaseGrabbedRagdolls[ragdoll] = nil end
		end
		return ragdolls
	end
	function ENT:DropAllRagdolls()
		for i, ragdoll in ipairs(self:GrabbedRagdolls()) do
			self:DropRagdoll(ragdoll)
		end
	end
	function ENT:HasGrabbedRagdoll(ragdoll)
		if not IsValid(ragdoll) then return false end
		return istable(self._DrGBaseGrabbedRagdolls[ragdoll])
	end

	function ENT:AimProjectile(proj, speed)
		if self:IsPossessed() then
			local lockedOn = self:PossessionGetLockedOn()
			if not IsValid(lockedOn) then
				return proj:DrG_AimAt(self:PossessorTrace().HitPos, speed)
			else return proj:DrG_AimAt(lockedOn, speed) end
		elseif self:HasEnemy() then
			return proj:DrG_AimAt(self:GetEnemy(), speed)
		elseif self:HadEnemy() then
			self:UpdateEnemy()
			return self:AimProjectile(proj, speed)
		else return proj:DrG_AimAt(nil, speed) end
	end

	--[[function ENT:OpenDoor(door, speed)
		if IsValid(door) and door:DrG_IsDoor() then
			door = door:DrG_Wrap()
			--local oldSpeed = door:GetSpeed()
			--if isnumber(speed) then door:SetSpeed(speed) end
			door:Open(self)
		end
	end
	function ENT:CloseDoor(door, speed)
		if IsValid(door) and door:DrG_IsDoor() then
			door = door:DrG_Wrap()
			--local oldSpeed = door:GetSpeed()
			--if isnumber(speed) then door:SetSpeed(speed) end
			door:Close()
		end
	end]]

	function ENT:SafeSetPos(pos)
		if self:TraceHull(nil, {start = pos, endpos = pos}).Hit then return false end
		self:SetPos(pos)
		return true
	end

	-- Hooks --

	function ENT:OnRagdoll() end

	-- Handlers --

	local lastBarnacle = nil
	DrGBase.BARNACLES = DrGBase.BARNACLES or {}
	hook.Add("OnEntityCreated", "DrGBaseRegisterBarnacles", function(ent)
		ent:DrG_Timer(0, function()
			local class = ent:GetClass()
			if class == "npc_barnacle" then
				lastBarnacle = ent
			elseif class == "npc_barnacle_tongue_tip" then
				DrGBase.BARNACLES[lastBarnacle] = ent
				lastBarnacle:CallOnRemove("DrGBaseRegisterBarnacles", function(ent)
					DrGBase.BARNACLES[ent] = nil
				end)
			end
		end)
	end)
	hook.Add("Think", "DrGBaseBarnacleTongues", function()
		if GetConVar("ai_disabled"):GetBool() then return end
		if #DrGBase.GetNextbots() == 0 then return end
		for barnacle, tongue in pairs(DrGBase.BARNACLES) do
			if not IsValid(barnacle) or not IsValid(tongue) then continue end
			local dist = 2.5
			local tr = util.DrG_TraceHull({
				start = barnacle:GetPos() - Vector(0, 0, 5),
				endpos = tongue:WorldSpaceCenter(),
				mins = Vector(-dist, -dist, -dist),
				maxs = Vector(dist, dist, dist),
				filter = barnacle
			})
			local ent = tr.Entity
			if IsValid(ent) and ent.IsDrGNextbot and not ent:IsAlly(barnacle) and
			ent.RagdollOnDeath and util.IsValidRagdoll(ent:GetModel()) then
				local dmg = DamageInfo()
				dmg:SetAttacker(barnacle)
				dmg:SetInflictor(barnacle)
				ent:DrG_RagdollDeath(dmg)
			end
		end
	end)

	-- Meta --

	local entMETA = FindMetaTable("Entity")

	local old_GetVelocity = entMETA.GetVelocity
	function entMETA:GetVelocity()
		if self.IsDrGNextbot then
			return self.loco:GetVelocity()
		else return old_GetVelocity(self) end
	end

	local old_SetVelocity = entMETA.SetVelocity
	function entMETA:SetVelocity(velocity)
		if self.IsDrGNextbot then
			return self.loco:SetVelocity(velocity)
		else return old_SetVelocity(self, velocity) end
	end

	local old_DropToFloor = entMETA.DropToFloor
	function entMETA:DropToFloor()
		if self.IsDrGNextbot then
			if self:IsOnGround() then return end
			local tr = self:TraceHull(Vector(0, 0, -9999999))
			self:SetPos(tr.HitPos)
		else return old_DropToFloor(self) end
	end

	local old_Remove = entMETA.Remove
	function entMETA:Remove()
		if self.IsDrGNextbot then self._DrGBaseRemoved = true end
		return old_Remove(self)
	end

	DrGBase.OLD_SetPos = DrGBase.OLD_SetPos or entMETA.SetPos
	function entMETA:SetPos(pos)
		if self.IsDrGNextbot then
			local singlePlayer = game.SinglePlayer()
			if not singlePlayer then self:PhysicsDestroy() end
			local res = DrGBase.OLD_SetPos(self, pos)
			if not singlePlayer then self:PhysicsInitShadow() end
			return res
		else return DrGBase.OLD_SetPos(self, pos) end
	end

	local nextbotMETA = FindMetaTable("NextBot")

	local old_BecomeRagdoll = nextbotMETA.BecomeRagdoll
	function nextbotMETA:BecomeRagdoll(dmg)
		if self.IsDrGNextbot then
			if self:IsFlagSet(FL_KILLME) or
			self:IsMarkedForDeletion() or
			self._DrGBaseRemoved then return NULL end
			if not dmg then dmg = DamageInfo() end
			if not self.IsDrGNextbotSprite and
			util.IsValidRagdoll(self:GetModel()) and
			not dmg:IsDamageType(DMG_REMOVENORAGDOLL) and
			not self:IsFlagSet(FL_DISSOLVING) and
			not self:IsFlagSet(FL_TRANSRAGDOLL) then
				self:AddFlags(FL_TRANSRAGDOLL)
				local ragdoll = self:DrG_CreateRagdoll(dmg)
				if IsValid(ragdoll) then
					undo.ReplaceEntity(self, ragdoll)
					cleanup.ReplaceEntity(self, ragdoll)
					if not GetConVar("ai_serverragdolls"):GetBool() or DisableRagCollisions:GetBool() then
						ragdoll:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
					end
					if not self.OnRagdoll(ragdoll, dmg, self) and RemoveRagdolls:GetFloat() >= 0 then
						ragdoll:Fire("fadeandremove", math.Clamp(RagdollFadeOut:GetFloat(), 0, math.huge), RemoveRagdolls:GetFloat())
					end
				end
				self:Remove()
				return ragdoll
			else
				self:Remove()
				return NULL
			end
		else return old_BecomeRagdoll(self, dmg) end
	end

else

	-- Getters/setters --

	function ENT:GetRangeTo(pos)
		if isentity(pos) then pos = pos:GetPos() end
		return self:GetPos():Distance(pos)
	end

	function ENT:GetRangeSquaredTo(pos)
		if isentity(pos) then pos = pos:GetPos() end
		return self:GetPos():DistToSqr(pos)
	end

	-- Functions --

	function ENT:RenderOffset(offset, origin, color, writeZ)
		if not isvector(offset) then return end
		origin = isvector(origin) and origin or self:GetPos()
		local vec = self:CalcOffset(offset)
		render.DrawLine(origin, origin+vec, color, writeZ)
		render.DrawWireframeSphere(origin+vec, 2*self:GetScale(), 4, 4, color, writeZ)
	end

	-- Hooks --

	-- Handlers --

	local entMETA = FindMetaTable("Entity")

	local old_tostring = entMETA.__tostring
	function entMETA:__tostring()
		if self.IsDrGNextbot then
			return "NextBot ["..self:EntIndex().."]["..self:GetClass().."]"
		else return old_tostring(self) end
	end

end

--PATH lua/entities/drgbase_nextbot_human/movements.lua:

-- Getters/setters --

function ENT:IsCrouching()
	return self:GetNW2Bool("DrGBaseCrouching")
end

if SERVER then

	-- Getters/setters --

	function ENT:SetCrouching(bool)
		self:SetNW2Bool("DrGBaseCrouching", bool)
	end

	-- Handlers --

	function ENT:OnUpdateSpeed()
		if self:IsClimbing() then return self.ClimbSpeed
		elseif self:IsCrouching() then
			if self:IsRunning() then return self.WalkSpeed
			else return self.CrouchSpeed end
		elseif self:IsRunning() then return self.RunSpeed
		else return self.WalkSpeed end
	end

	-- Climbing --

	function ENT:OnClimbing(ladder, left, down)
		if IsValid(ladder) then
			self:EmitSlotSound("DrGBaseLadderClimbing", 0.3, "player/footsteps/ladder"..math.random(4)..".wav")
		end
		return not down and left < 112.5
	end
	function ENT:OnStopClimbing(ladder, height, down)
		if down then return end
		local footstep = false
		self:PlayActivityAndMoveAbsolute(ACT_ZOMBIE_CLIMB_END, self.ClimbAnimRate, function(self, cycle)
			if cycle >= 0.875 and not footstep then
				footstep = true
				self:EmitFootstep()
			end
			if cycle > 0.5 or not IsValid(ladder) then return end
			self:EmitSlotSound("DrGBaseLadderClimbing", 0.3, "player/footsteps/ladder"..math.random(4)..".wav")
		end)
	end

end

--PATH lua/entities/egg/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Fried Egg"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A fried egg"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/egg.mdl")
	
end
--PATH lua/entities/fruitbanana/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Banana"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/bananna.mdl")
	
end
--PATH lua/entities/fruitgrape3/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Grapes"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/grapes3.mdl")
	
end
--PATH addons/gmod_info_board/lua/entities/gmib_board/cl_init.lua:
include("shared.lua")

local function RecieveData( len, ply )	
	local board = net.ReadEntity()
	board.data = net.ReadTable()
end
net.Receive( "bulletin_board", RecieveData )

function ENT:Initialize()
	
	self.data = {}
	self.data.bodies = {}
	for k=0,10,1 do
		self.data.bodies[k] = {}
		for l=0,10,1 do
			self.data.bodies[k][l] = ""
		end
	end
	
	local i = 5
	self.data.pos = {}
	self.data.pos[1] = { mainX = 0, mainY = 0 }
	self.data.pos[2] = { mainX = 400 + i*1, mainY = 0 }
	self.data.pos[3] = { mainX = 800 + i*2, mainY = 0 }
	self.data.pos[4] = { mainX = 1200 + i*3, mainY = 0 }
	self.data.pos[5] = { mainX = 1600 + i*4, mainY = 0 }
	self.data.pos[6] = { mainX = 0, mainY = 600 }
	self.data.pos[7] = { mainX = 400 + i*1, mainY = 600 }
	self.data.pos[8] = { mainX = 800 + i*2, mainY = 600 }
	self.data.pos[9] = { mainX = 1200 + i*3, mainY = 600 }
	self.data.pos[10] = { mainX = 1600 + i*4, mainY = 600 }
	
	self.data.font = {}
	for i=1,10,1 do
		self.data.font[i] = math.floor(math.Rand(1,3))
	end
	
	self.data.lastDistCheck = os.time()
    self.data.distance = 1000
    self.data.maxTransparency = 400
	self.data.visualsCutoff = false
	
	self.data.cam3d2dvector = Vector(0.75,-25,59)
	self.data.backgroundColor = Color(205,205,205)
	self.data.textColor = Color(55,55,55)
end
--	END OF ENT:INITIALIZE

local pos, ang, origin, alpha
origin = {}
origin.x = 70
origin.y = -225

function ENT:Draw()
	self:DrawModel()
    if self:VisualCutoff() == false then return end

    ang = self:GetAngles()
    alpha = 340 - self.data.distance

    --if alpha < 0 then return end
		
	local job = team.GetName(LocalPlayer():Team())
	
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Right(), 0)
		
	cam.Start3D2D( self:LocalToWorld(self.data.cam3d2dvector), ang, 0.025 )
	-- Base Color
	
	for i=1,10,1 do
		if gmib.bck[i] == nil then return end
		if gmib.ads[i] && job == gmib.ads[i].jobRelated || gmib.ads[i] && "No" == gmib.ads[i].jobRelated then
			surface.SetDrawColor( self.data.backgroundColor )
			surface.SetMaterial(gmib.bck[i])
			surface.DrawTexturedRectUV( origin.x-70 + self.data.pos[i].mainX, origin.y + self.data.pos[i].mainY, 380, 580,0,0,1,1)
			
			draw.SimpleText( gmib.ads[i].title,"gmib_font48_" .. self.data.font[i], origin.x + 120 + self.data.pos[i].mainX, origin.y + 60 + self.data.pos[i].mainY + 20, self.data.textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			
			for j=1,table.Count(gmib.bodies[i])-1,1 do
				draw.SimpleText( gmib.bodies[i][j],"gmib_font32_" .. self.data.font[i], origin.x - 5 + self.data.pos[i].mainX, origin.y + 90 + 35*j + self.data.pos[i].mainY, self.data.textColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			end
			
			draw.SimpleText( "by " .. gmib.ads[i].user,"gmib_font32_" .. self.data.font[i], origin.x + 250 + self.data.pos[i].mainX, origin.y + 260 + 250+ self.data.pos[i].mainY, self.data.textColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
			
		elseif gmib.ads[i] && job != gmib.ads[i].jobRelated then
			
			surface.SetDrawColor( self.data.backgroundColor )
			if !gmib.bck[i] then return end
			surface.SetMaterial(gmib.bck[i])
			surface.DrawTexturedRectUV( origin.x-70 + self.data.pos[i].mainX, origin.y + self.data.pos[i].mainY, 380, 580,0,0,1,1)
			
			draw.SimpleText( gmib.ads[i].title,"gmib_font48_" .. self.data.font[i], origin.x + 120 + self.data.pos[i].mainX, origin.y + 60 + self.data.pos[i].mainY + 20, self.data.textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			draw.SimpleText( "To see this ad you need to be ","gmib_font32_" .. self.data.font[i], origin.x - 55 + self.data.pos[i].mainX, origin.y + 90 + 35*1 + self.data.pos[i].mainY, self.data.textColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			draw.SimpleText( gmib.ads[i].jobRelated,"gmib_font32_" .. self.data.font[i], origin.x - 55 + self.data.pos[i].mainX, origin.y + 90 + 35*2 + self.data.pos[i].mainY, self.data.textColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			draw.SimpleText( "by " .. gmib.ads[i].user,"gmib_font32_" .. self.data.font[i], origin.x + 250 + self.data.pos[i].mainX, origin.y + 260 + 250+ self.data.pos[i].mainY, self.data.textColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		
		elseif gmib.ads[i] && "No" == gmib.ads[i].jobRelated then
			surface.SetDrawColor( self.data.backgroundColor )
			if !gmib.bck[i] then return end
			surface.SetMaterial(gmib.bck[i])
			surface.DrawTexturedRectUV( origin.x-70 + self.data.pos[i].mainX, origin.y + self.data.pos[i].mainY, 380, 580,0,0,1,1)
			
			draw.SimpleText( gmib.ads[i].title,"gmib_font48_" .. self.data.font[i], origin.x + 120 + self.data.pos[i].mainX, origin.y + 60 + self.data.pos[i].mainY + 20, self.data.textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			
			for j=1,table.Count(gmib.bodies[i])-1,1 do
				draw.SimpleText( gmib.bodies[i][j],"gmib_font32_" .. self.data.font[i], origin.x - 5 + self.data.pos[i].mainX, origin.y + 90 + 35*j + self.data.pos[i].mainY, self.data.textColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			end
			
			draw.SimpleText( "by " .. gmib.ads[i].user,"gmib_font32_" .. self.data.font[i], origin.x + 250 + self.data.pos[i].mainX, origin.y + 260 + 250+ self.data.pos[i].mainY, self.data.textColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )			
		end
	end	
	cam.End3D2D()
end --of Draw

function ENT:VisualCutoff()
    --Check if player is close enough to draw 3D2D.
    if self.data.lastDistCheck + 1 > os.time() then return end
    self.data.lastDistCheck = os.time()
    local pos = self:GetPos()
    self.data.distance = pos:Distance( LocalPlayer():GetPos() )

    if self.data.distance <= 200 then
        return true 
    else     
        return false
    end
end --of VisualCutoff

--PATH lua/entities/icecream2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Ice Cream (Vanilla)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/IceCream2.mdl")
	
end
--PATH lua/entities/mcdburgerbox/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "McDonalds Cheeseburger (in box)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A double cheeseburger from McDonalds"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/mcdburgerbox.mdl")
	
end
--PATH lua/entities/meat3/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Raw Meat"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/meat3.mdl")
	
end
--PATH lua/entities/meat5/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Raw Meat"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/meat5.mdl")
	
end
--PATH addons/mc_quests/lua/entities/mqs_ent/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Quest Item"
ENT.Author = "Mactavish"

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "CModel")
	self:NetworkVar("Entity", 0, "TPly")
	self:NetworkVar("Entity", 1, "Reroot")
	self:NetworkVar("Bool", 0, "Distractible")
	self:NetworkVar("Bool", 1, "EnablePhys")
	self:NetworkVar("Bool", 2, "ShowPointer")
	self:NetworkVar("Int", 0, "UseHold")
	self:NetworkVar("Float", 0, "PickProgress")
end
--PATH addons/sl_main_system/lua/entities/npc_demonboss.lua:

if not DrGBase then return end -- return if DrGBase isn't installed
ENT.Base = "drgbase_nextbot" -- DO NOT TOUCH (obviously)

local hitjoueur = {
	"mad_sfx_sololeveling/punch/se_Punch_FaceHit.ogg",
	"mad_sfx_sololeveling/punch/se_Punch_Hit01.ogg",
	"mad_sfx_sololeveling/punch/se_Punch_Hit02.ogg"
}

local swing_attack = {
	"mad_sfx_sololeveling/punch/chopper_Punch01.ogg",
	"mad_sfx_sololeveling/punch/chopper_Punch02.ogg",
	"mad_sfx_sololeveling/punch/chopper_Punch03.ogg"
}

-- Misc --
ENT.PrintName = "Seigneur Démoniaque"
ENT.Category = "SL - NPC"
ENT.Models = {"models/mad_demonboss.mdl"}
ENT.BloodColor = BLOOD_COLOR_RED
ENT.CollisionBounds = Vector(30, 30, 60)
ENT.type = "boss"

-- Stats --
ENT.xp = 15000
ENT.money = 1000000
ENT.Damage = 1500 -- 800
ENT.SpecialDamage = 2200 --1K
ENT.SpawnHealth = 80000 -- 30k

ENT.WalkSpeed = 100
ENT.RunSpeed = 900

ENT.HPBarOffset = 35
ENT.HPBarScale = 0.5

-- Detection --
ENT.EyeBone = ""
ENT.EyeOffset = Vector(0, 0, 0)
ENT.EyeAngle = Angle(0, 0, 0)
ENT.SightFOV = 150
ENT.SightRange = 1000
ENT.MinLuminosity = 0
ENT.MaxLuminosity = 1
ENT.HearingCoefficient = 1

-- Sounds --
ENT.OnDamageSounds = {""}
ENT.OnDeathSounds = {""}

-- AI --
ENT.Omniscient = false
ENT.SpotDuration = 10
ENT.RangeAttackRange = 0
ENT.MeleeAttackRange = 150
ENT.ReachEnemyRange = 150
ENT.AvoidEnemyRange = 0

-- Relationships --
ENT.Factions = {FACTION_ZOMBIES}

-- Movements/animations --
ENT.WalkAnimation = ACT_WALK
ENT.WalkAnimRate = 1
ENT.RunAnimation = ACT_RUN
ENT.RunAnimRate = 1
ENT.IdleAnimation = ACT_IDLE
ENT.IdleAnimRate = 1

-- Possession --
ENT.PossessionEnabled = true

if SERVER then

	-- Init/Think --

	function ENT:CustomInitialize()
		self:SetDefaultRelationship(D_HT)
		self:DrawShadow(false)
		self:SetHP(self:Health())
		self:SetHPY(self:Health())
		self:SetModelScale(1.2)

		self.StartHealth = self:Health()

		self:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE)
	
		timer.Simple(0, function()
			self:SetHP(self:Health())
			self:SetHPY(self:Health())
			self:SetDMGDealt(0)
		end)
	end


	if CLIENT then
		function ENT:CustomThink()
			if self:GetCooldown("DS1_"..self:GetClass().."_HPYDegrade") <= 0 then
				local var = self:GetHPY()
				self:SetDMGDealt(0)
				self:SetHPY(math.Clamp(var-(self.StartHealth/250),self:Health(),self.StartHealth))
			end
		end
	end

	-- AI --
ENT.Omniscient = false
ENT.SpotDuration = 10

local function SpotTimerName(self, ent)
    return "DrGBaseNB" .. self:GetCreationID() .. "SpotENT" .. ent:GetCreationID()
end

function ENT:SpotEntity(ent)
    if not IsValid(ent) then return end
    if GetConVar("ai_ignoreplayers"):GetBool() then return end
    if ent:IsPlayer() and not ent:Alive() then return end

    if ent:GetNoDraw() == false then
        local distanceThreshold = 300  -- Définissez ici la distance maximale d'aggro
        
        -- Vérifiez si nous avons déjà une cible
        if self.CurrentTarget and IsValid(self.CurrentTarget) then
            local currentDistance = self.CurrentTarget:GetPos():Distance(self:GetPos())
            if currentDistance > distanceThreshold then
                -- Si la cible actuelle est trop loin, réinitialisez-la
                self:LoseEntity(self.CurrentTarget)
                self.CurrentTarget = nil
            else
                -- Si la cible est valide et à portée, ne faites rien
                return
            end
        end

        if self:GetSpotDuration() == 0 then return end
        local spotted = self:HasSpotted(ent)
        self._DrGBaseLastTimeSpotted[ent] = CurTime()
        self._DrGBaseSpotted[ent] = true
        local disp = self:GetRelationship(ent, true)
        
        if disp == D_HT or disp == D_LI or disp == D_FR then
            self._DrGBaseRelationshipCachesSpotted[disp][ent] = true
        end
        
        self:UpdateKnownPosition(ent)
        
        if self._DrGBasePatrolSound and self._DrGBasePatrolSound:GetSound().Entity == ent then
            self:RemovePatrol(self._DrGBasePatrolSound)
        end
        
        if not spotted then
            self:OnSpotted(ent)
            self.CurrentTarget = ent  -- Enregistrer l'entité comme cible actuelle
            if ent:IsPlayer() then
                if ent:GetNoDraw() == true then
                    self:LoseEntity(ent)
                end
                net.Start("DrGBaseNextbotPlayerAwareness")
                net.WriteEntity(self)
                net.WriteBit(true)
                net.Send(ent)
            end
        end
        
        local timerName = SpotTimerName(self, ent)
        timer.Remove(timerName)
        if self:GetSpotDuration() <= 0 then return end
        
        timer.Create(timerName, self:GetSpotDuration(), 1, function()
            if not IsValid(self) or not IsValid(ent) then return end
            self:LoseEntity(ent)
            self.CurrentTarget = nil  -- Réinitialiser la cible actuelle
        end)
    end
end

function ENT:OnReachedPatrol()
end

function ENT:OnIdle()
end

function ENT:OnMeleeAttack(enemy)
	if not IsValid(enemy) then return end
	if not IsValid(self) then return end
	self.cdAttack = self.cdAttack or 0
	if self.Freeze == true then return end
	self.cdSpecialAttack = self.cdSpecialAttack or 0  -- Cooldown pour l'attaque spéciale

	-- Vérifie si l'attaque spéciale est prête à être utilisée
	if self.cdSpecialAttack < CurTime() then
		self:OnSpecialAttack(enemy)
		return
	end

	-- Exécution de l'attaque normale
	if self.cdAttack < CurTime() then
		self.cdAttack = CurTime() + 1
		if self:Health() < 1 then return end
		self:EmitSound(swing_attack[math.random(1,3)], 80, math.random(70, 130), 0.8, CHAN_AUTO)
		self:EmitSound("mad_sfx_sololeveling/npc/demonboss/demonboss_atk".. math.random(1, 4) .. ".wav", 80, math.random(70, 80), 1, CHAN_AUTO)
		timer.Simple(0.7, function()
			if self:Health() < 1 then return end
			if IsValid(self) and IsValid(enemy) then
				if enemy:GetPos():Distance(self:GetPos()) < 450 then
					enemy:TakeDamage(self.Damage, self, self)
					timer.Simple(0.001, function()
						if enemy:Health() <= 0 then
							local currentXP = enemy:getDarkRPVar("xp") or 0
							-- Calcule 50% de l'XP
							local xpToRemove = currentXP * 0.1
							-- Enlève 50% de l'XP au joueur
							enemy:addXP(-xpToRemove)
			
							-- Réinitialise les cristaux
							enemy:SetDataItemSL_INV("crystal", 0)
							enemy:SetDataItemSL_INV("crystal2", 0)
							enemy:SetDataItemSL_INV("crystal3", 0)
							enemy:SetDataItemSL_INV("crystal4", 0)
						end
					end)
					enemy:EmitSound(hitjoueur[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO)
				end
			end
		end)
		self:PlaySequenceAndMove("attack"..math.random(2), 1, self.FaceEnemy)
	end
end

function ENT:OnSpecialAttack(enemy)
	if not IsValid(enemy) then return end
	if not IsValid(self) then return end
	if self.Freeze == true then return end
	self.cdSpecialAttack = CurTime() + 10  -- Cooldown de 10 secondes pour l'attaque spéciale

	if self:Health() < 1 then return end
	self:EmitSound("mad_sfx_sololeveling/npc/demonboss/demonboss_spe.wav", 80, math.random(70, 80), 1, CHAN_AUTO)
	timer.Simple(0.001, function() ParticleEffect( "dust_conquer_charge", self:GetPos(), self:GetAngles(), self ) end)
	timer.Simple(0.001, function() ParticleEffect( "dust_sharp_shockwave", self:GetPos(), self:GetAngles(), self ) end)
	timer.Simple(0.001, function() ParticleEffect( "auraburst_sharp", self:GetPos(), self:GetAngles(), self ) end)

	local zone = ents.Create("mad_zone_radius")
	zone:SetNWInt("Radius", 7000)
	if IsValid(zone) then
		zone:SetModel("models/effects/teleporttrail.mdl")  -- Modèle arbitraire
		zone:SetPos(self:GetPos())
		zone:SetModelScale(0.001)
		zone:Spawn()
		zone:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		zone:SetNoDraw(false)  -- Rendre l'entité invisible
		zone:SetParent(self)

		-- Supprimer l'entité "mad_zone_radius" après l'attaque spéciale
		timer.Simple(2.4, function()
			util.ScreenShake(self:GetPos(), 500, 5, 5, 900)
			self:EmitSound("mad_sfx_sololeveling/npc/demonboss/demonboss_spe2.wav", 80, math.random(60, 70), 1, CHAN_AUTO)
			if IsValid(zone) then
				zone:Remove()
			end
		end)
	end

	-- Délai avant l'attaque spéciale
	timer.Simple(2.4, function()
		if not IsValid(self) then return end
		if self:Health() < 1 then return end
		ParticleEffect( "[union]_rock_smash", self:GetPos(), self:GetAngles() )
		if /*IsValid(self) and*/ IsValid(enemy) then
			local entities = ents.FindInSphere(self:GetPos(), 700)  -- Trouver les entités dans un rayon de 330 unités
			for _, ent in pairs(entities) do
				if ent:IsPlayer() or ent:IsNPC() then
					ent:TakeDamage(self.SpecialDamage, self, self)
					if ent:Health() <= 0 and ent:IsPlayer() then
						local currentXP = ent:getDarkRPVar("xp") or 0
						-- Calcule 50% de l'XP
						local xpToRemove = currentXP * 0.1
						-- Enlève 50% de l'XP au joueur
						ent:addXP(-xpToRemove)
		
						-- Réinitialise les cristaux
						ent:SetDataItemSL_INV("crystal", 0)
						ent:SetDataItemSL_INV("crystal2", 0)
						ent:SetDataItemSL_INV("crystal3", 0)
						ent:SetDataItemSL_INV("crystal4", 0)
					end
					ent:SetVelocity(self:GetForward()*150 + ent:GetUp()*500)
					ent:EmitSound(hitjoueur[math.random(1,3)], 75, math.random(70, 130), 0.8, CHAN_AUTO)
				end
			end
		end
	end)
	self:PlaySequenceAndMove("skill", self.FaceEnemy)
end

	-- Créez une table locale pour stocker les dégâts infligés par chaque joueur pour cet NPC spécifique
	ENT.playerDamage = {}

	function ENT:OnTakeDamage(damage)
		self:SetHP(math.Clamp(self:Health()-damage:GetDamage(),0,self.StartHealth))
		self:SetCooldown("DS1_"..self:GetClass().."_HPYDegrade", 1.5)
		if IsValid(damage:GetAttacker()) and damage:GetAttacker():IsPlayer() then
			local attacker = damage:GetAttacker()

			-- Ajoutez les dégâts infligés à la table du joueur pour cet NPC
			self.playerDamage[attacker] = (self.playerDamage[attacker] or 0) + damage:GetDamage()
		end
	end

	function ENT:OnDeath(dmginfo, hitgroup)
		local totalDamage = 0
		local eligiblePlayers = {} -- Tableau pour stocker les joueurs éligibles

		local ent = ents.Create("mad_crystal")
		ent:SetNWInt("item", "crystal4")
		ent:SetPos(self:GetPos() + Vector(0, 0, 20))
		ent:Spawn()
	
		-- Calculez le total des dégâts infligés pour cet NPC
		for _, damage in pairs(self.playerDamage) do
			totalDamage = totalDamage + damage
		end
	
		-- Distribuez l'argent équitablement entre les joueurs
		if totalDamage > 0 then
			for player, damage in pairs(self.playerDamage) do
				local moneyEarned = math.floor(self.money * damage / totalDamage)
				local xpEarned = math.floor(self.xp * damage / totalDamage)
	
				if player:GetUserGroup() == "vip" then
					player:addXP(xpEarned*1.2,true,true)
					net.Start("SL:Notification")
					net.WriteString(self.PrintName.. " vaincu : + ".. xpEarned*1.2 .." XP")
					net.Send(player)
					player:addMoney(moneyEarned*1.2)
					net.Start("SL:Notification")
					net.WriteString("Vous avez gagnez : + ".. formatMoney(moneyEarned*1.2))
					net.Send(player)
				else
					player:addXP(xpEarned,true,true)
					net.Start("SL:Notification")
					net.WriteString(self.PrintName.. " vaincu : + "..xpEarned.." XP")
					net.Send(player)
					player:addMoney(moneyEarned)
					net.Start("SL:Notification")
					net.WriteString("Vous avez gagnez : + ".. formatMoney(moneyEarned))
					net.Send(player)
				end

				-- Vérifier si le joueur est éligible pour une compétence
				local playerLevel = player:getDarkRPVar("level")
				local playerClass = player:GetNWInt("Classe")
				for skillName, skillData in pairs(SKILLS_SL) do
					if skillData.classe == playerClass and playerLevel >= skillData.level then
						table.insert(eligiblePlayers, player)
						break
					end
				end
			end
		end
	
		-- Distribution des compétences avec une chance de 10 % par joueur éligible
		for _, player in ipairs(eligiblePlayers) do
			if math.random() <= 0.6 then
				local playerClass = player:GetNWInt("Classe")
				local playerLevel = player:getDarkRPVar("level")
				local availableSkills = {} -- Tableau pour stocker les compétences disponibles pour ce joueur
				for skillName, skillData in pairs(SKILLS_SL) do
					if skillData.classe == playerClass and playerLevel >= skillData.level and player:HasSkill(skillName) == false then
						if skillData.ismagie == false then
							table.insert(availableSkills, skillName)
						elseif skillData.ismagie == true then
							if player:GetNWInt("Magie") == skillData.element then
								table.insert(availableSkills, skillName)
							end
						end
					end
				end
	
				-- Sélectionnez une compétence aléatoire parmi les compétences disponibles pour le joueur
				local randomSkill = availableSkills[math.random(#availableSkills)]
				local skillData = SKILLS_SL[randomSkill]
	
				-- Ajouter la compétence au joueur
				if skillData then
					player:AddDataSkillsSL(randomSkill, skillData.level)
					net.Start("SL:Notification")
					net.WriteString("Vous avez obtenu le skill : "..skillData.name)
					net.Send(player)
				end
			end
		end
	
		-- Réinitialisez la table des dégâts pour la prochaine instance de NPC
		self.playerDamage = {}
	
		timer.Simple(0.8, function()
			self:EmitSound("mad_sfx_sololeveling/npc/demonboss/demonboss_spe2.wav", 80, math.random(60, 70), 1, CHAN_AUTO)
			ParticleEffect( "[union]_rock_smash", self:GetPos(), self:GetAngles() )
			timer.Simple(1.2, function()
				self:EmitSound("mad_sfx_sololeveling/npc/demonboss/demonboss_spe2.wav", 80, math.random(60, 70), 1, CHAN_AUTO)
				ParticleEffect( "[union]_rock_smash", self:GetPos() + self:GetForward()*125, self:GetAngles() )
			end)
		end)
		self:PlaySequenceAndWait("die")
	end
	
	ENT.DefaultRunSpeed = ENT.RunSpeed
	ENT.DefaultWalkSpeed = ENT.WalkSpeed
	function ENT:Abs_Freeze(bool)
		if bool == true then
			self.Freeze = true
			self.RunSpeed = 0
			self.WalkSpeed = 0
		else
			self.Freeze = false
			self.RunSpeed = self.DefaultRunSpeed
			self.WalkSpeed = self.DefaultWalkSpeed
		end
	end

end

if CLIENT then
	ENT.RenderGroup = RENDERGROUP_OPAQUE
	ENT.HUDMat_Main = Material("mad_sololeveling/mob/boss_hpbar.png", "smooth unlitgeneric")
	ENT.HUDMat_Bar = Material("mad_sololeveling/mob/hpbar.png", "smooth unlitgeneric")
	ENT.HUDMat_Bar2 = Material("hud/ds1/boss_hpbar_ylw.png", "smooth unlitgeneric")
	local tab = {["$pp_colour_addr"]=0,["$pp_colour_addg"]=0,["$pp_colour_addb"]=0,["$pp_colour_brightness"]=0,["$pp_colour_contrast"]=0.1,["$pp_colour_colour"]=0,["$pp_colour_mulr"]=50, ["$pp_colour_mulg"]=0, ["$pp_colour_mulb"]=0 }
		function ENT:CustomDraw()
			-- if self:GetNetworkVars()["Phantom"]!=nil then
			-- if self:GetPhantom() then
				-- render.SetStencilWriteMask(0xFF)
				-- render.SetStencilTestMask(0xFF)
				-- render.ClearStencil()
				-- render.SetStencilEnable(true)
				-- render.SetStencilReferenceValue(1)
				-- render.SetStencilCompareFunction(STENCIL_ALWAYS)
				-- render.SetStencilPassOperation(STENCIL_REPLACE)
				-- render.SetStencilFailOperation(STENCIL_KEEP)
				-- render.SetStencilZFailOperation(STENCIL_KEEP)
				-- self:DrawModel()
				-- render.SetStencilCompareFunction(STENCIL_EQUAL)
				-- DrawSobel(0.1)
				-- -- halo.Add({self}, Color(255,0,0)) -- crashes the game apparently, epic
				-- DrawColorModify(tab)
				-- DrawMaterialOverlay("effects/tp_refract", 0.02)
				-- DrawMaterialOverlay("effects/water_warp01", -0.01)
				-- render.SetStencilEnable(false)
			-- end
			-- end
			if self:IsDead() and (math.Round(self:GetHPY())<=math.Round(self:GetHP())) then return end
				local angle = EyeAngles()
				angle = Angle(0,angle.y,0)
				angle.y = angle.y + math.sin(CurTime())*10
				angle:RotateAroundAxis(angle:Up(),-90)
				angle:RotateAroundAxis(angle:Forward(),90)
				
				local pos = self:GetBonePosition(self:LookupBone("Bip001 Head")) + Vector(0,0,self.HPBarOffset)
				cam.Start3D2D(pos,angle,self.HPBarScale)
					local hp = math.Round(self:GetHP())
					local hp2 = math.Round(self:GetHPY())
					local hpmax = self.SpawnHealth
					local text = self.PrintName
					local text2 = tostring(math.Round(self:GetDMGDealt()))
					surface.SetFont("Trebuchet24")
					local tW, tH = surface.GetTextSize(text)
	
					local pad = 0.01
					surface.SetDrawColor(255,255,255,255)
					surface.SetMaterial(self.HUDMat_Bar2)
					surface.DrawTexturedRect(-(self.HUDMat_Main:Width()/6)+8, -(self.HUDMat_Main:Height())+5, (self.HUDMat_Bar2:Width()*1.05)*(hp2/hpmax), self.HUDMat_Bar2:Height()/2, 1)
					surface.SetMaterial(self.HUDMat_Bar)
					surface.DrawTexturedRect(-(self.HUDMat_Main:Width()/6)+8, -(self.HUDMat_Main:Height())+5, (self.HUDMat_Bar:Width()*1.05)*(hp/hpmax), self.HUDMat_Bar:Height()/2, 1)
					surface.SetMaterial(self.HUDMat_Main)
					surface.DrawTexturedRect(-(self.HUDMat_Main:Width()/6), -(self.HUDMat_Main:Height()), self.HUDMat_Main:Width()/3, self.HUDMat_Main:Height(), 2)
	
					draw.SimpleText(text, "M_Font5", -(self.HUDMat_Main:Width()/6)+8, -(self.HUDMat_Main:Height()+16), Color(200,0,0))
					if text2 != "0" then draw.SimpleText(text2, "M_Font5", (self.HUDMat_Main:Width()/6)-16, -(self.HUDMat_Main:Height()+16), Color(200,0,0)) end
				cam.End3D2D()
			self:DS1_Draw()
		end
		function ENT:DS1_Draw()
			
		end
	end
	function ENT:SetupDataTables()
		self:NetworkVar("Float", 0, "HP")
		self:NetworkVar("Float", 1, "HPY")
		self:NetworkVar("Float", 2, "DMGDealt")
		self:NetworkVar("Bool", 0, "Phantom")
	end

-- DO NOT TOUCH --
AddCSLuaFile()
DrGBase.AddNextbot(ENT)

--PATH lua/entities/npc_drg_zombie.lua:
if not DrGBase then return end -- return if DrGBase isn't installed
ENT.Base = "drgbase_nextbot" -- DO NOT TOUCH (obviously)

-- Misc --
ENT.PrintName = "Zombie"
ENT.Category = "DrGBase"
ENT.Models = {"models/Zombie/Classic.mdl"}
ENT.BloodColor = BLOOD_COLOR_GREEN

-- Sounds --
ENT.OnDamageSounds = {"Zombie.Pain"}
ENT.OnDeathSounds = {"Zombie.Die"}

-- Stats --
ENT.SpawnHealth = 100

-- AI --
ENT.RangeAttackRange = 0
ENT.MeleeAttackRange = 30
ENT.ReachEnemyRange = 30
ENT.AvoidEnemyRange = 0

-- Relationships --
ENT.Factions = {FACTION_ZOMBIES}

-- Movements/animations --
ENT.UseWalkframes = true
ENT.RunAnimation = ACT_WALK

-- Detection --
ENT.EyeBone = "ValveBiped.Bip01_Spine4"
ENT.EyeOffset = Vector(7.5, 0, 5)

-- Possession --
ENT.PossessionEnabled = true
ENT.PossessionMovement = POSSESSION_MOVE_8DIR
ENT.PossessionViews = {
	{
		offset = Vector(0, 30, 20),
		distance = 100
	},
	{
		offset = Vector(7.5, 0, 0),
		distance = 0,
		eyepos = true
	}
}
ENT.PossessionBinds = {
	[IN_ATTACK] = {{
		coroutine = true,
		onkeydown = function(self)
			self:EmitSound("Zombie.Attack")
			self:PlayActivityAndMove(ACT_MELEE_ATTACK1, 1, self.PossessionFaceForward)
		end
	}}
}

if SERVER then

	-- Init/Think --

	function ENT:CustomInitialize()
		self:SetDefaultRelationship(D_HT)
		self:SetBodygroup(1, 1)
	end

	-- AI --

	function ENT:OnMeleeAttack(enemy)
		self:EmitSound("Zombie.Attack")
		self:PlayActivityAndMove(ACT_MELEE_ATTACK1, 1, self.FaceEnemy)
	end

	function ENT:OnReachedPatrol()
		self:Wait(math.random(3, 7))
	end
	function ENT:OnIdle()
		self:AddPatrolPos(self:RandomPos(1500))
	end

	-- Damage --

	function ENT:OnDeath(dmg, delay, hitgroup)
		if hitgroup ~= HITGROUP_HEAD then
			self:SetBodygroup(1, 0)
			local headcrab = ents.Create("npc_drg_headcrab")
			if not IsValid(headcrab) then return end
			headcrab:SetPos(self:EyePos())
			headcrab:SetAngles(self:GetAngles())
			headcrab:Spawn()
			if IsValid(self:GetCreator()) then
				self:GetCreator():DrG_AddUndo(headcrab, "NPC", "Undone Headcrab")
			end
		end
	end

	-- Animations/Sounds --

	function ENT:OnNewEnemy()
		self:EmitSound("Zombie.Alert")
	end

	function ENT:OnAnimEvent()
		if self:IsAttacking() and self:GetCycle() > 0.3 then
			self:Attack({
				damage = 10,
				type = DMG_SLASH,
				viewpunch = Angle(20, math.random(-10, 10), 0)
			}, function(self, hit)
				if #hit > 0 then
					self:EmitSound("Zombie.AttackHit")
				else self:EmitSound("Zombie.AttackMiss") end
			end)
		elseif math.random(2) == 1 then
			self:EmitSound("Zombie.FootstepLeft")
		else self:EmitSound("Zombie.FootstepRight") end
	end

end

-- DO NOT TOUCH --
AddCSLuaFile()
DrGBase.AddNextbot(ENT)

--PATH addons/pcasino/lua/entities/pcasino_mystery_wheel/cl_init.lua:
include("shared.lua")


function ENT:Initialize()
	self.active = false
	self.currentBets = {}

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
end

local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local draw_simpletext = draw.SimpleText
local surface_setdrawcolor = surface.SetDrawColor
local surface_setmaterial = surface.SetMaterial
local surface_gettextsize = surface.GetTextSize
local surface_setfont = surface.SetFont
local draw_notexture = draw.NoTexture
local math_cos = math.cos
local math_sin = math.sin
local math_rad = math.rad
local black = Color(0, 0, 0, 155)
local white = Color(255, 255, 255, 100)
function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end


	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	-- Basic setups
	local pos = self:GetPos()
	local ang = self:GetBoneMatrix(2):GetAngles()

	ang:RotateAroundAxis(ang:Up(), 89.8)
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Up(), -162)

	cam.Start3D2D(pos + (self:GetUp()*9.75) + (self:GetRight()*0.2) + (self:GetForward()*-17.4), ang, 0.08)
		-- Spinny wheel icons
		local itter = 0
		for i=1, 360, 360/20 do 
			itter = itter + 1
			local x = math_cos(math_rad(i - 91)) * 155
			local y = math_sin(math_rad(i - 91)) * 155

			draw_notexture()
			surface_setdrawcolor(255, 255, 255, 255)
			surface_setmaterial(PerfectCasino.Icons[self.data.wheel[21 - itter].p].mat)

			PerfectCasino.UI.DrawTexturedRectRotatedPoint(x, y, 60, 60, (-i+1), 0, -218)
			PerfectCasino.UI.TextRotated(self.data.wheel[21 - itter].n, x, y, color_white, "pCasino.Title.Static", i-90, 1)
		end
	cam.End3D2D()

	if tobool(self.data.buySpin.buy) or (tobool(self.data.general.useFreeSpins) and (PerfectCasino.Spins > 0)) then
		-- Basic setups
		local pos = self:GetPos()
		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), 50)
		ang:RotateAroundAxis(ang:Forward(), 90)
	
		surface_setfont("pCasino.Entity.Arrows")
		local spinSize, _ = surface_gettextsize(PerfectCasino.Translation.UI.PurchaseASpin)
		local moneySize, _ = surface_gettextsize(PerfectCasino.Config.FormatMoney(self.data.buySpin.cost))
		local biggestSize = (spinSize > moneySize) and spinSize or moneySize
		biggestSize = biggestSize + 100

		cam.Start3D2D(pos + (ang:Up()*-35) + (ang:Forward()*25) + (ang:Right()*-9) + ((ang:Right()*-2)*(math.sin(CurTime()*0.5))), ang, 0.05)
				-- Current bet
				surface_setdrawcolor(black)
				surface_drawrect(-10, -20, biggestSize, 120)
				-- Border
				surface_setdrawcolor(white)
				surface_drawrect(-15, -25, biggestSize+10, 5)
				surface_drawrect(-15, -20, 5, 120)
				surface_drawrect(biggestSize-10, -20, 5, 120)
				surface_drawrect(-15, 100, biggestSize+10, 5)
				-- Current Bid
				draw_simpletext((PerfectCasino.Spins > 0) and PerfectCasino.Translation.UI.FreeSpin or PerfectCasino.Translation.UI.PurchaseASpin, "pCasino.Entity.Arrows", biggestSize/2-10, 37, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
				draw_simpletext((PerfectCasino.Spins > 0) and string.format(PerfectCasino.Translation.UI.FreeSpinCount, PerfectCasino.Spins) or PerfectCasino.Config.FormatMoney(self.data.buySpin.cost), "pCasino.Entity.Arrows", biggestSize/2-10, 37, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		cam.End3D2D()
	end
end
--PATH addons/pcasino/lua/entities/pcasino_sign_interior_wall/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Interior Wall"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

PerfectCasino.Core.RegisterEntity("pcasino_sign_interior_wall", {
	-- General data
	general = {
		text = {d = "Roulette Tables", t = "string"} -- The text to show
	}
},
"models/freeman/owain_interiorsign_wall.mdl")
--PATH addons/pcasino/lua/entities/pcasino_sign_plaque/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.letters = {}

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
	
	local letterMap = PerfectCasino.Core.Letter

	-- Letter calculations
	local startPoint = self:GetRight() * 25
	local curLength = vector_origin
	local right = self:GetRight()

	for k, v in ipairs(string.Split(string.lower(self.data.general.text), "")) do
		if not letterMap[v] then -- It's either a space or a character we don't support
			curLength = curLength + (self:GetRight() * 5)
			continue
		end

		-- Create the letter
		local letter = ClientsideModel("models/freeman/owain_casino_alphabet.mdl")
		table.insert(self.letters, letter)
		letter:SetParent(self)
		curLength = curLength + ((self:GetRight()) * (letterMap[v].w*2))
		letter:SetPos(self:GetPos() + startPoint - curLength + ((self:GetRight()) * (letterMap[v].w)))
		letter:SetAngles(self:GetAngles())
		letter:SetBodygroup(1, letterMap[v].b)
	end
end

function ENT:OnRemove()
	-- Clear the board of last rounds best
	for k, v in pairs(self.letters) do
		if not IsValid(v) then continue end

		v:Remove()
	end
end

function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end
end
--PATH addons/pcasino/lua/entities/pcasino_sign_wall_logo/cl_init.lua:
include("shared.lua")

function ENT:PostData()
end
--PATH addons/pcasino/lua/entities/pcasino_wheel_slot_machine/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Wheel Slot Machine"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "CurrentJackpot")
end

PerfectCasino.Core.RegisterEntity("pcasino_wheel_slot_machine", {
	-- General data
	general = {
		limitUse = {d = false, t = "bool"}
	},
	-- Bet data
	bet = {
		default = {d = 1000, t = "num"}, -- The default bet
	},
	-- Combo data
	combo = {
		{c = {"gold", "gold", "gold"}, p = 0.5, j = false},
		{c = {"coins", "coins", "coins"}, p = 0.8, j = false},
		{c = {"emerald", "emerald", "emerald"}, p = 1, j = false},
		{c = {"bag", "bag", "bag"}, p = 1.6, j = false},
		{c = {"bar", "bar", "bar"}, p = 2, j = false},
		{c = {"coin", "coin", "coin"}, p = 2.5, j = false},
		{c = {"coin", "coin", "anything"}, p = 2, j = false},
		{c = {"anything", "coin", "coin"}, p = 2, j = false},
		{c = {"vault", "vault", "vault"}, p = 2.8, j = false},
		{c = {"chest", "anything", "anything"}, p = 0, j = true},
		{c = {"anything", "chest", "anything"}, p = 0, j = true},
		{c = {"anything", "anything", "chest"}, p = 0, j = true},
	},
	-- Combo data
	wheel = {
		{n = "$1,000", f = "money", i = 1000, p = "dolla"},
		{n = "$10,000", f = "money", i = 10000, p = "dolla"},
		{n = "$100,000", f = "money", i = 100000, p = "dolla"},
		{n = "$1,000,000", f = "money", i = 1000000, p = "dolla"},
		{n = "Jackpot!", f = "jackpot", i = 1000000, p = "diamond"},
		{n = "Nothing", f = "nothing", i = 1000000, p = "melon"},
		{n = "Free Spin", f = "prize_wheel", i = 0, p = "mystery_2"},
		{n = "$1", f = "money", i = 1, p = "dolla"},
		{n = "$1,000", f = "money", i = 1000, p = "dolla"},
		{n = "$100,000", f = "money", i = 100000, p = "dolla"},
		{n = "Nothing", f = "nothing", i = 1000000, p = "melon"},
		{n = "Jackpot!", f = "jackpot", i = 100000, p = "diamond"}
	},
	-- Jackpot data
	jackpot = {
		toggle = {d = true, t = "bool"}, -- The bell chance
		startValue = {d = 10000, t = "num"}, -- The bell chance
		betAdd = {d = 0.5, t = "num"}, -- The % of the bet to add to the jackpot
	},
	-- Chance data
	chance = {
		gold = {d = 15},
		coins = {d = 10},
		emerald = {d = 9},
		bag = {d = 8},
		bar = {d = 6},
		coin = {d = 6},
		vault = {d = 4},
		chest = {d = 1},
	},
},
"models/freeman/owain_slotmachine_wheel.mdl")
--PATH lua/entities/pfx1_06.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Flamethrower 1"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]flamethrower_basic"
--PATH lua/entities/pfx1_08_~_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Yellow]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_yellow"
--PATH lua/entities/pfx1_08_~a.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Purple]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_purple"
--PATH lua/entities/pfx2_02_a.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Gushing Blood [Alien, Large]"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]gushing_blood_alien*"



--PATH lua/entities/pfx4_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Basic Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_f"



--PATH lua/entities/pfx4_00~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Basic Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_f*"



--PATH lua/entities/pfx4_02~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Red Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_r*"

--PATH lua/entities/pfx4_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Green Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_g"
--PATH lua/entities/pfx4_03_s~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Green Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_g_s*"
--PATH lua/entities/pfx4_03~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Green Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_g*"
--PATH lua/entities/pfx4_0b.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Matrix Sphere"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]binary_sphere"
--PATH lua/entities/pfx8_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Red Vortex"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]red_vortex"
--PATH lua/entities/pfx8_03_alt.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Green Portal"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]magic_portal*"
--PATH lua/entities/pie1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Pie"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/pie.mdl")
	
end
--PATH lua/entities/pizzaslice/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Pizza Slice"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A slice of pepperoni pizza"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/pizzaslice.mdl")
	
end
--PATH lua/entities/proj_drg_default/shared.lua:
ENT.Base = "drgbase_entity"
ENT.IsDrGProjectile = true

-- Misc --
ENT.PrintName = "Projectile"
ENT.Category = "DrGBase"
ENT.Models = {}
ENT.ModelScale = 1

-- Physics --
ENT.Gravity = true
ENT.Physgun = false
ENT.Gravgun = false

-- Contact --
ENT.OnContactDelay = 0.1
ENT.OnContactDelete = -1
ENT.OnContactDecals = {}

-- Sounds --
ENT.LoopSounds = {}
ENT.OnContactSounds = {}
ENT.OnRemoveSounds = {}

-- Effects --
ENT.AttachEffects = {}
ENT.OnContactEffects = {}
ENT.OnRemoveEffects = {}

-- Misc --
DrGBase.IncludeFile("meta.lua")

-- Convars --

local ProjectileTickrate = CreateConVar("drgbase_projectile_tickrate", "-1", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED})

-- Handlers --

hook.Add("PhysgunPickup", "DrGBaseProjectilePhysgun", function(ply, ent)
	if ent.IsDrGProjectile then return ent.Physgun or false end
end)

if SERVER then
	AddCSLuaFile()

	-- Init/Think --

	function ENT:SpawnFunction(ply, tr, class)
		if not tr.Hit then return end
		local pos = tr.HitPos + tr.HitNormal*16
		local ent = ents.Create(class)
		ent:SetOwner(ply)
		ent:SetPos(pos)
		ent:Spawn()
		ent:Activate()
		return ent
	end

	function ENT:Initialize()
		if #self.Models > 0 then
			self:SetModel(self.Models[math.random(#self.Models)])
		else
			self:SetModel("models/props_junk/watermelon01.mdl")
			self:SetNoDraw(true)
		end
		self:SetModelScale(self.ModelScale)
		self:SetUseType(SIMPLE_USE)
		self:SetTrigger(true)
		-- sounds/effects --
		self:CallOnRemove("DrGBaseOnRemoveSoundsEffects", function(self)
			if #self.OnRemoveSounds > 0 then
				self:EmitSound(self.OnRemoveSounds[math.random(#self.OnRemoveSounds)])
			end
			if #self.OnRemoveEffects > 0 then
				ParticleEffect(self.OnRemoveEffects[math.random(#self.OnRemoveEffects)], self:GetPos(), self:GetAngles())
			end
		end)
		if #self.LoopSounds > 0 then
			self._DrGBaseLoopingSound = self:StartLoopingSound(self.LoopSounds[math.random(#self.LoopSounds)])
			self:CallOnRemove("DrGBaseStopLoopingSound", function(self)
				self:StopLoopingSound(self._DrGBaseLoopingSound)
			end)
		end
		if #self.AttachEffects > 0 then
			self:ParticleEffect(self.AttachEffects[math.random(#self.AttachEffects)])
		end
		-- custom code --
		self:_BaseInitialize()
		self:CustomInitialize()
		self._DrGBaseBaseThinkDelay = 0
		self._DrGBaseCustomThinkDelay = 0
		-- physics --
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:Wake()
			phys:EnableDrag(false)
			phys:EnableGravity(tobool(self.Gravity))
		end
	end
	function ENT:_BaseInitialize() end
	function ENT:CustomInitialize() end

	function ENT:Think()
		if CurTime() > self._DrGBaseBaseThinkDelay then
			local delay = self:_BaseThink() or 0
			self._DrGBaseBaseThinkDelay = CurTime() + delay
		end
		if CurTime() > self._DrGBaseCustomThinkDelay then
			local delay = self:CustomThink() or 0
			self._DrGBaseCustomThinkDelay = CurTime() + delay
		end
		local tickrate = ProjectileTickrate:GetFloat()
		if tickrate > 0 then
			self:NextThink(CurTime() + 1/tickrate)
		else self:NextThink(CurTime() + engine.TickInterval()) end
		return true
	end
	function ENT:_BaseThink() end
	function ENT:CustomThink() end

	-- Collisions --

	function ENT:PhysicsCollide(data)
		local ent = data.HitEntity
		if not IsValid(ent) and not ent:IsWorld() then return end
		if ent:IsWorld() and #self.OnContactDecals > 0 then
			util.Decal(self.OnContactDecals[math.random(#self.OnContactDecals)], data.HitPos+data.HitNormal, data.HitPos-data.HitNormal)
		end
		self:Contact(ent)
	end
	function ENT:Touch(ent)
		self:Contact(ent)
	end

	function ENT:Contact(ent)
		if not IsValid(ent) and not ent:IsWorld() then return end
		if ent:GetClass() == "trigger_soundscape" then return end
		if (not isnumber(self._DrGBaseLastContact) or CurTime() > self._DrGBaseLastContact + self.OnContactDelay) and self:OnContact(ent) ~= false then
			self._DrGBaseLastContact = CurTime()
			if #self.OnContactSounds > 0 then
				self:EmitSound(self.OnContactSounds[math.random(#self.OnContactSounds)])
			end
			if #self.OnContactEffects > 0 then
				ParticleEffect(self.OnContactEffects[math.random(#self.OnContactEffects)], self:GetPos(), self:GetAngles())
			end
			if self.OnContactDelete == 0 then
				self:Remove()
			elseif self.OnContactDelete > 0 then
				self:Timer(self.OnContactDelete, self.Remove)
			end
		end
	end
	function ENT:OnContact() end

	-- Misc --

	function ENT:OnDealtDamage(ent, dmg)
		if dmg:IsDamageType(DMG_CRUSH) then return true end
	end

	-- Helpers --

	function ENT:AimAt(target, speed, feet)
		return self:DrG_AimAt(target, speed, feet)
	end
	function ENT:ThrowAt(target, options, feet)
		return self:DrG_ThrowAt(target, options, feet)
	end

	function ENT:DealDamage(ent, value, type)
		if ent == self then return end
		local dmg = DamageInfo()
		dmg:SetDamage(value)
		dmg:SetDamageForce(self:GetVelocity())
		dmg:SetDamageType(type or DMG_DIRECT)
		dmg:SetDamagePosition(self:GetPos())
		if IsValid(self:GetOwner()) then
			dmg:SetAttacker(self:GetOwner())
		else dmg:SetAttacker(self) end
		dmg:SetInflictor(self)
		ent:TakeDamageInfo(dmg)
	end
	function ENT:RadiusDamage(damage, type, range, filter)
		local owner = self:GetOwner()
		if not isfunction(filter) then filter = function(ent)
			if ent == owner then return false end
			if not IsValid(owner) or not owner.IsDrGNextbot then return true end
			return not owner:IsAlly(ent)
		end end
		for i, ent in ipairs(ents.FindInSphere(self:GetPos(), range)) do
			if not IsValid(ent) then continue end
			if ent == self then continue end
			if not filter(ent) then continue end
			self:DealDamage(ent, damage*math.Clamp((range-self:GetPos():Distance(ent:GetPos()))/range, 0, 1), type)
		end
	end

	function ENT:Explosion(damage, range, filter)
		local explosion = ents.Create("env_explosion")
		if IsValid(explosion) then
			explosion:Spawn()
			explosion:SetPos(self:GetPos())
			explosion:SetKeyValue("iMagnitude", 0)
			explosion:SetKeyValue("iRadiusOverride", 0)
			explosion:Fire("Explode", 0, 0)
		else
			local fx = EffectData()
			fx:SetOrigin(self:GetPos())
			util.Effect("Explosion", fx)
		end
		self:RadiusDamage(damage, DMG_BLAST, range, filter)
	end

	-- Handlers --

	hook.Add("GravGunPickupAllowed", "DrGBaseProjectileGravgun", function(ply, ent)
		if ent.IsDrGProjectile then return ent.Gravgun or false end
	end)

	hook.Add("EntityTakeDamage", "DrGBaseProjectilePhysicsDamage", function(ent, dmg)
		local inflictor = dmg:GetInflictor()
		if IsValid(inflictor) and inflictor.IsDrGProjectile then
			return inflictor:OnDealtDamage(ent, dmg)
		end
	end)

else

	function ENT:Initialize()
		self._DrGBaseBaseThinkDelay = 0
		self._DrGBaseCustomThinkDelay = 0
		self:_BaseInitialize()
		self:CustomInitialize()
	end
	function ENT:_BaseInitialize() end
	function ENT:CustomInitialize() end

	function ENT:Think()
		if CurTime() > self._DrGBaseBaseThinkDelay then
			local delay = self:_BaseThink() or 0
			self._DrGBaseBaseThinkDelay = CurTime() + delay
		end
		if CurTime() > self._DrGBaseCustomThinkDelay then
			local delay = self:CustomThink() or 0
			self._DrGBaseCustomThinkDelay = CurTime() + delay
		end
	end
	function ENT:_BaseThink() end
	function ENT:CustomThink() end

	function ENT:Draw()
		self:DrawModel()
		self:_BaseDraw()
		self:CustomDraw()
	end
	function ENT:_BaseDraw() end
	function ENT:CustomDraw() end

end

--PATH addons/sl_main_system/lua/entities/rochemine/shared.lua:
ENT.Base	    			= "base_ai"
ENT.Type	    			= "ai"
ENT.PrintName				= "Roche"
ENT.Author					= "Mad"
ENT.Category                = "Union - SL"
ENT.Instructions			= "Appuyez sur votre touche [USE]"
ENT.Spawnable				= true
ENT.AdminSpawnable			= true
--PATH lua/entities/salmon/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Cooked Salmon Steak"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Salmon.mdl")
	
end
--PATH lua/entities/sent_catmullrom_camera/cl_init.lua:
include("shared.lua")

CreateConVar("cl_draw_catmullrom_cameras", "1")

ENT.RenderGroup = RENDERGROUP_BOTH

local SpriteOffset = Vector(0, 0, 32)

local CAMERA_MODEL = Model("models/dav0r/camera.mdl")

local MatLaser  = Material("cable/physbeam")
local MatLaserB = Material("cable/white")
local MatSprite = Material("sprites/physg_glow1")

local color_yellow = Color(255, 255, 0, 100)
local color_red    = Color(255, 0,   0, 100)

local PointColour  = Color(64, 168, 255, 128)

local VectorUp = Vector(1.25, 1.25, 1.25)

local IconMats = {}
IconMats.Node               = Material("gui/silkicons/camera_link")
IconMats.Controller         = Material("gui/silkicons/camera")
IconMats.Controller_Playing = Material("gui/silkicons/camera_go")

ENT.KeyTextures = {}

function ENT:Initialize()
	self:InitController()
	
	self.ShouldDraw     = 1
	self.ShouldDrawInfo = false
	
	self.LastDrawCheckTimestamp = 0
	
	self.ZoomTimestamp = 0
	self.LastGuideBeamRenderTimestamp = 0
	
	self:FireShootOff()
end
---[[
function ENT:Think()
    if self.NeedCameraGhost then
        if not self.GuideCameraGhost then
            self.GuideCameraGhost = ClientsideModel(CAMERA_MODEL, RENDERGROUP_OPAQUE)
        end
    end
    
	if self:GetNWBool("IsMapController") then return end
	if not self:GetNWEntity("MasterController").DoZoom then return end -- Haven't received the controller yet
	
	if LocalPlayer():GetNWEntity("UnderControlCatmullRomCamera") == self:GetNWEntity("MasterController") then
		if not self.WasPlayingFOVHackz then
			self.CatmullRomController:Reset()
			
			self.WasPlayingFOVHackz = true
		end
		
		self:RemoveGuideGhost()
		
		return self:GetNWEntity("MasterController"):DoZoom()
	else
		self.WasPlayingFOVHackz = false
	end
	
	self:TrackEntity(self.Entity:GetNetworkedEntity("TrackEnt"), self.Entity:GetNetworkedVector("TrackEntLPos"))
	
	self.ShouldDrawInfo = (self:GetNWEntity("MasterController"):GetNetworkedEntity("ControllingPlayer") == LocalPlayer())
	self.ShouldDraw     = (GetConVarNumber("cl_draw_catmullrom_cameras") == 0) and 0 or 1 -- Like that you can see other player's cameras while you're filming
	
	if (self.ShouldDraw == 0) then return end
	if not self:GetNWBool("IsMasterController") then return end
	
	self.Key = self:GetNWInt("NumPadKey")
	
	if not self.KeyTextures[self.Key] then
		
	end
	
	self.Texture = self.Key
	
	self:GetPointData()
	
	if #self.CatmullRomController.PointsList >= 4 then
		self.CatmullRomController:CalcEntireSpline()
	else
		self:RemoveGuideGhost()
	end
	
	self:NextThink(CurTime() + .5)
end
---[[
function ENT:Draw()
	if self:GetNWBool("IsMapController") then return end
	if not self:GetNWEntity("MasterController").RequestGuideBeamDraw then return end -- Haven't received the controller yet
	
	if self.ShouldDraw == 0 then return end
	if LocalPlayer():GetNWEntity("UnderControlCatmullRomCamera") == self:GetNWEntity("MasterController") then return end
	
	local wep = LocalPlayer():GetActiveWeapon()
	
	if wep:IsValid() and (wep:GetClass() == "gmod_camera") then return end
	
	self:DrawGuideBeam()
	self:RequestGuideBeamDraw(self.CLTrackIndex)
	
	self.Entity:DrawModel()
	
	return self:Icon()
end

function ENT:DrawTranslucent()
	if self:GetNWBool("IsMapController") then return end
	if not self:GetNWBool("IsMasterController") then return end
	
	if (not self.ShouldDrawInfo) or (not self.Texture) then return end
	if LocalPlayer():GetNWEntity("UnderControlCatmullRomCamera") == self:GetNWEntity("MasterController") then return end
	
	local wep = LocalPlayer():GetActiveWeapon()
	
	if wep:IsValid() then
		if wep:GetClass() == "gmod_camera" then return end
	end
	
	local SPOS = self:GetPos():ToScreen()
	draw.DrawText("" .. self.Texture .. "", "ChatFont", SPOS.x, SPOS.y, Color(255, 0, 0, 255),TEXT_ALIGN_CENTER)
	
	return self:Icon()
end

function ENT:DoZoom()
	local CTime = CurTime()
	
	if self.ZoomTimestamp < CTime then
		self.ZoomTimestamp = CTime
		
		self.CatmullRomController:CalcPerc() -- Can't be done in the parameter call or a side effect doesn't manifest properly
		LocalPlayer().CatmullRomCamsTrackZoom = self.CatmullRomController:CalcZoom()
	end
end

local scrn = 1
local size = 2 * scrn

function ENT:Icon()
	local pos = self:GetPos() + (self:GetRight() * 1.75) + (self:GetForward() * -3.5) + (self:GetUp() * -2)
	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Right(), -90)
	ang:RotateAroundAxis(ang:Up(),     90)
	ang:RotateAroundAxis(ang:Right(),  90)
	
	cam.Start3D2D(pos, ang, scrn)
		local ok, err = pcall(self.DrawIcon, self)
		if not ok then ErrorNoHalt(err, "\n") end
	cam.End3D2D()
end

function ENT:DrawIcon()
	local CTime = SysTime()
	local alpha = 200 + (math.sin(CTime * 3) * 55)
	
	surface.SetMaterial(self:GetNWBool("IsMasterController") and IconMats.Controller or IconMats.Node)
	surface.SetDrawColor(255, 255, 255, alpha)
	surface.DrawTexturedRect(0, 0, size, size)
	
	if self.CurShootOff ~= 0 then
		local perc = (self.CurShootOff - CTime) / .75
		
		if perc > 0 then
			local size   = size + ((1 - perc) * 2 * size)
			local offset = (1 - perc)
			
			surface.SetDrawColor(255, 255, 255, perc * 150)
			surface.DrawTexturedRectRotated(1, 1, size, size, 0)
			--surface.DrawTexturedRectRotated(1, 1, size, size, perc * 360 * self.CurShootOffRoll)
		else
			self.CurShootOff = 0
			
			--timer.Simple(math.random(1, 2.5), self.FireShootOff, self)
		end
	elseif (alpha > 254) and (math.random(1, 2) == 1) then
		self:FireShootOff()
	end
end

function ENT:FireShootOff()
	if not (self and self:IsValid()) then return end
	
	self.CurShootOffStart = SysTime()
	self.CurShootOff      = self.CurShootOffStart + .75
	--[[
	if math.random(1, 2) == 1 then
		self.CurShootOffRoll = (math.random(1, 2) == 1) and math.random() or math.random() * -1
	else
		self.CurShootOffRoll = 0
	end
	--]]
end

function ENT:DrawGuideBeam()
	if self:GetNWBool("IsMapController") then return end
	
	if not self:GetNWBool("IsMasterController") then
		if self:GetNWEntity("MasterController"):IsValid() and (LocalPlayer():GetNWEntity("UnderControlCatmullRomCamera") ~= self:GetNWEntity("MasterController")) then
			return self:GetNWEntity("MasterController"):DrawGuideBeam()
		end
		
		return
	end
	
	if #self.CatmullRomController.PointsList < 4 then
		self:RemoveGuideGhost()
		
		return --print("not enough points.", #self.CatmullRomController.PointsList)
	end
	
	local CTime = UnPredictedCurTime()
	
	if self.LastDrawCheckTimestamp > CTime then return end--print("too soon") end
	
	self.LastDrawCheckTimestamp = CTime
	
	local size = 35 + math.abs(self.CatmullRomController.Perc - .5) * 100
	
	local pos, ang = self:GetGuideCamPosAng()
    
    self.NeedCameraGhost = true
	
    if self.GuideCameraGhost then

	local VMC1 =  VectorUp * (math.sin(1 - math.abs(self.CatmullRomController.Perc - .5)) * .5 + .6) 
	local VMC2 = Matrix()
	VMC2:Scale( VMC1 )
	self.GuideCameraGhost:EnableMatrix( "RenderMultiply", VMC2 )

        
        self.GuideCameraGhost:SetAngles(ang)
        self.GuideCameraGhost:SetPos(pos)
    end
end

function ENT:RequestGuideBeamDraw(trackindex)
	if not trackindex then return end
	if (not self:GetNWBool("IsMasterController")) then
		if self:GetNWEntity("MasterController").RequestGuideBeamDraw then
			return self:GetNWEntity("MasterController"):RequestGuideBeamDraw(trackindex)
		end
		
		return
	end
	
	if (trackindex == 1) or (trackindex == self.CatmullRomController.CLEntityListCount) or (self.CatmullRomController.CLEntityListCount == 0) then return end
	
	local CTime = CurTime()
	
	--self.LastGuideBeamRenderTimestamp = self.LastGuideBeamRenderTimestamp or 0 -- Had some strange issues with this in MP testing so patch it here
	--self.CatmullRomController.EntityList[trackindex - 1].LastGuideBeamRenderTimestamp = self.CatmullRomController.EntityList[trackindex - 1].LastGuideBeamRenderTimestamp or 0 -- Here too. :/
	
	local drawbackbeam    = (trackindex > 2) and self.CatmullRomController.EntityList[trackindex - 1] and (self.CatmullRomController.EntityList[trackindex - 1].LastGuideBeamRenderTimestamp < CurTime())
	local drawforwardbeam = (trackindex < self.CatmullRomController.CLEntityListCount - 1) and self.CatmullRomController.EntityList[trackindex] and (self.CatmullRomController.EntityList[trackindex].LastGuideBeamRenderTimestamp < CurTime())
	
	if drawbackbeam then
		self.CatmullRomController.EntityList[trackindex - 1].LastGuideBeamRenderTimestamp = CTime
		
		render.SetMaterial(MatLaser)
		render.StartBeam(self.CatmullRomController.STEPS + 2)
			ok, err = pcall(self.RenderSubBeams, self, CTime, (trackindex - 1))
		render.EndBeam()
	end
	
	if drawforwardbeam then
		self.CatmullRomController.EntityList[trackindex].LastGuideBeamRenderTimestamp = CTime
		
		render.SetMaterial(MatLaser)
		render.StartBeam(self.CatmullRomController.STEPS + 2)
			ok, err = pcall(self.RenderSubBeams, self, CTime, trackindex)
		render.EndBeam()
	end
end

function ENT:GetGuideCamPosAng(pos1, pos2, pos3, pos4)
	if self:GetNWBool("IsMasterController") then
		self:CalcPerc() -- Can't be done in the parameter call or a side effect doesn't manifest properly
		
		return self.CatmullRomController:Point(), self.CatmullRomController:Angle()
	end
end

function ENT:RenderBeams()
	local CTime = CurTime()
	
	render.AddBeam(self.CatmullRomController.PointsList[2], 10, CTime, color_white)
	
	for i = 1, #self.CatmullRomController.Spline do
		render.AddBeam(self.CatmullRomController.Spline[i], 10, CTime, color_white)
	end
end

function ENT:RenderSubBeams(CTime, trackindex)
	local base = (trackindex - 2) * self.CatmullRomController.STEPS
	
	render.AddBeam(self.CatmullRomController.PointsList[trackindex], 10, CTime or 1, color_white)
----------------------------------------------------
	for i = 1, self.CatmullRomController.STEPS do
		render.AddBeam(self.CatmullRomController.Spline[base + i], 10, CTime or 1, color_white)
	end
	
	render.AddBeam(self.CatmullRomController.PointsList[trackindex + 1], 10, CTime or 1, color_white)
end

function ENT:RemoveGuideGhost()
	if self.GuideCameraGhost and self.GuideCameraGhost:IsValid() then
		self.GuideCameraGhost:Remove()
		
		self.GuideCameraGhost = nil
	end
	
	--return collectgarbage()
end

function ENT:Lock()
	self.IsLocked = true
end

function ENT:Unlock()
	self.IsLocked = false
end

--PATH lua/entities/sent_catmullrom_camera_viewpnt/shared.lua:
ENT.Type = "anim"

ENT.PrintName		= "Cubic Cameras Viewpoint"
ENT.Author			= "Olivier 'LuaPineapple' Hamel"
ENT.Contact			= "evilpineapple@cox.net"
ENT.Purpose			= "For the lulz."
ENT.Instructions	= "Try the GMod Tower servers, but be sure to check out Duke Nukem: Forever first!"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false



--PATH addons/sl_main_system/lua/entities/shop_item_sl/cl_init.lua:
include('shared.lua')

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()

	if string.len(string.Trim("Shop")) < 1 then return end

	if LocalPlayer():GetPos():Distance(self:GetPos()) < 400 then
		local alpha = (LocalPlayer():GetPos():Distance(self:GetPos()) / 500.0)
		alpha = math.Clamp(1.25 - alpha, 0 ,1)
		local a = Angle(0,0,0) 
		a:RotateAroundAxis(Vector(1,0,0),90) 
		a.y = LocalPlayer():GetAngles().y - 90 

		cam.Start3D2D(self:GetPos() + Vector(0,0,80), a , 0.08) 
			draw.RoundedBox(8,-200,-75,400,75 , Color(25,25,25,255 * alpha)) 
			local tri = {{x = -25 , y = 0},{x = 25 , y = 0},{x = 0 , y = 25}} 
			surface.SetDrawColor(Color(25,25,25,255 * alpha)) 
			draw.NoTexture() 
			surface.DrawPoly( tri ) 
			draw.SimpleText("Shop","DermaLarge",0,-40, white , 1 , 1) 
		cam.End3D2D() 
	end
end
--PATH addons/sl_main_system/lua/entities/shop_item_sl/shared.lua:
ENT.Base	    			= "base_ai"
ENT.Type	    			= "ai"
ENT.PrintName				= "Shop"
ENT.Author					= "Mad"
ENT.Category                = "Union - SL"
ENT.Instructions			= "Appuyez sur votre touche [USE]"
ENT.Spawnable				= true
ENT.AdminSpawnable			= true
--PATH addons/sl_bouffe/lua/entities/sl_sodacan04/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Soda (Pepsi)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Sodacan04.mdl")
	
end
--PATH addons/sl_bouffe/lua/entities/sl_sodacan05/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Soda (Sprite)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Sodacan05.mdl")
	
end
--PATH addons/sl_bouffe/lua/entities/sl_sodacanb03/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Monster Energy (Assault)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Sodacanb03.mdl")
	
end
--PATH addons/sl_bouffe/lua/entities/sl_winewhite1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Wine (White)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/wine_white1.mdl")
	
end
--PATH addons/sl_bouffe/lua/entities/sl_winewhite2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Wine (White)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/wine_white2.mdl")
	
end
--PATH lua/entities/sodacan01/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Soda (Coca Cola)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/Sodacan01.mdl")
	
end
--PATH lua/entities/sodacolalarge/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Cola (Large)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A large bottle of off brand cola"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/colabig.mdl")
	
end
--PATH gamemodes/mangarp/entities/entities/spawned_money/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Spawned Money"
ENT.Author = "FPtje"
ENT.Spawnable = false
ENT.IsSpawnedMoney = true

function ENT:SetupDataTables()
    self:NetworkVar("Int",0,"amount")
end
--PATH lua/entities/steak2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Cooked Steak"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/steak2.mdl")
	
end
--PATH lua/entities/toast/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Toast"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A toasted piece of toast"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/toast.mdl")
	
end
--PATH lua/entities/toblerone/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Toblerone"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "A pack of Toblerone"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/toblerone.mdl")
	
end
--PATH lua/entities/veggourd/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Gourd"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/gourd.mdl")
	
end
--PATH lua/entities/veglettuce/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Lettuce"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/lettuce.mdl")
	
end
--PATH lua/entities/vegpepper3/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Pepper (green)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/pepper3.mdl")
	
end
--PATH addons/leveling-system/lua/entities/vrondakis_printer/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Money Printer"
ENT.Author = "vrondakis"
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "price")
	self:NetworkVar("Entity", 0, "owning_ent")
end
--PATH lua/entities/winered1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Wine (Red)"
ENT.Author = "SaDow4100"
ENT.Contact = "Steam"
ENT.Purpose = "Food"
ENT.Instructions = "E" 
ENT.Category = "Food"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:SetupModel()

	self.Entity:SetModel("models/FoodNHouseholdItems/wine_red1.mdl")
	
end
--PATH addons/sl_main_system/lua/effects/sl_effect2.lua:
EFFECT.mat = Material( "sprites/light_glow02_add" )

local propHalos = {}  -- Tableau pour stocker les modèles nécessitant un halo

hook.Add("PreDrawHalos", "AddPropHalos", function()
    halo.Add(propHalos, Color(127,255,255,255), 0, 15, 2)  -- Ajouter des halos aux modèles stockés dans la table
end)

function EFFECT:Init( data )
    self.Ent = data:GetEntity()
    self.Pos = data:GetOrigin()

    self.LifeTime = 12
    self.DieTime = CurTime() + self.LifeTime

    if not IsValid( self.Ent ) then return end

    self.Model = ClientsideModel( self.Ent:GetModel(), RENDERGROUP_TRANSLUCENT )

    self.Model:SetMaterial("Models/effects/comball_sphere")
    self.Model:SetColor( Color(127,255,255) )
    self.Model:SetParent( self.Ent, 0 )
    self.Model:SetMoveType( MOVETYPE_NONE )
    self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
    self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
    self.Model:AddEffects( EF_BONEMERGE )

	table.insert(propHalos, self.Model)

    for i = 0,self.Ent:GetBoneCount() do
        self.Model:ManipulateBoneScale( i, Vector(1,1,1) * 1.1 )
    end

    for i = 0, self.Ent:GetNumBodyGroups() do
        self.Model:SetBodygroup(i, self.Ent:GetBodygroup(i))
    end
end

function EFFECT:Think()
    if self.DieTime < CurTime() or not IsValid( self.Ent ) or (self.Ent.Alive and not self.Ent:Alive()) then 
        if IsValid( self.Model ) then
            self.Model:Remove()
        end

        return false
    end

    if IsValid( self.Model ) then
        self.Model:SetColor( Color(127* (self.DieTime - CurTime()) / self.LifeTime,255,255,255) )
    end

    return true
end

function EFFECT:Render()
    if not IsValid( self.Ent ) then return end

end

--PATH lua/effects/wraith_stealth_off.lua:
local mat_stealth = Material( "models/mana/c_player_stealth" )
local stealth = "models/mana/c_player_stealth"

function EFFECT:Init( data )

	if ( GetConVar( "mat_fillrate" ):GetBool() ) then return end

	self.Time = 0.5
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.ParentEntity = ent
	
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	
	mat_old = self.ParentEntity:GetMaterial()

	self.ParentEntity.SpawnEffect = self
	
	if ( ent == LocalPlayer():GetHands() ) then
		self.ViewModel = true
	end
	
	self.ParentRenderMode = self.ParentEntity:GetRenderMode()
	
	self.ParentEntity:SetRenderMode( RENDERMODE_TRANSALPHADD )

end

local itFallBack = Material( "models/black" ):GetTexture( "$bumpmap" )

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end
	
	local PPos = self.ParentEntity:GetPos()
	self:SetPos( PPos + (EyePos() - PPos):GetNormal() )

	self:DrawModel()
	
	self.ParentEntity:SetMaterial( stealth )
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity:SetMaterial( "" )
	
	self.ParentEntity:SetRenderMode( self.ParentRenderMode )

	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil
	
	return false
	
end

function EFFECT:Render()

	self:RenderOverlay( self.ParentEntity )

end

function EFFECT:RenderOverlay( entity )

	if ( !IsValid( entity ) ) && !( self:IsPlayer() || self:GetOwner():IsPlayer() ) then return end

	local Fraction = ( self.LifeTime - 0.1 - CurTime() ) / self.Time
	Fraction = math.Clamp( Fraction, 0, 1 )

	local EyeNormal = entity:GetPos() - EyePos()
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local offset 
	
	if ( self.ViewModel ) then
		offset = EyeAngles():Forward() * 10
	else
		offset = EyeNormal * Distance * 0.001
	end
	
	local Pos = EyePos() + offset
	local amount = math.Clamp( 1 - Fraction, 0, 1 )
	local scale = 0 + amount

	render.SetBlend( scale, scale, scale )

	cam.Start3D( Pos, EyeAngles() )
		entity:SetMaterial("")
		entity:DrawModel()
	cam.End3D()

end
--PATH LuaCmd:
function GAMEMODE:HUDDrawTargetID() return false end RunConsoleCommand('hud_deathnotice_time', '0')